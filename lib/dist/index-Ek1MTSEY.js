import { getCurrentScope as _W, onScopeDispose as W5, ref as J, watch as Ie, unref as _, getCurrentInstance as ur, onMounted as Yt, nextTick as rt, readonly as H5, computed as P, defineComponent as fe, openBlock as F, createElementBlock as X, createElementVNode as ee, warn as SW, watchEffect as xW, onBeforeUnmount as us, inject as pt, isRef as $a, shallowRef as Vd, onBeforeMount as $W, provide as _r, renderSlot as je, mergeProps as ga, toRef as $o, onUnmounted as TW, reactive as is, toRefs as hc, normalizeClass as Z, onUpdated as J5, createVNode as ye, Fragment as Ft, useSlots as Nf, withCtx as te, createBlock as ce, resolveDynamicComponent as Mn, normalizeStyle as It, createTextVNode as Kn, toDisplayString as it, createCommentVNode as he, TransitionGroup as EW, useAttrs as Z5, withDirectives as nn, withModifiers as Dt, vShow as Ei, Transition as ko, cloneVNode as IW, Text as K5, Comment as MW, Teleport as Y5, onDeactivated as CW, toRaw as uf, vModelCheckbox as Yw, vModelRadio as Q5, h as vl, resolveComponent as Vn, renderList as bi, onBeforeUpdate as OW, withKeys as Ui, vModelText as X5, toHandlers as kW, createSlots as b$, triggerRef as ym, resolveDirective as AW, createApp as PW, shallowReactive as RW, isVNode as $g, render as Qw, pushScopeId as LW, popScopeId as FW } from "vue";
function eD(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: NW } = Object.prototype, { getPrototypeOf: LC } = Object, P_ = /* @__PURE__ */ ((e) => (t) => {
  const n = NW.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Aa = (e) => (e = e.toLowerCase(), (t) => P_(t) === e), R_ = (e) => (t) => typeof t === e, { isArray: Df } = Array, Tg = R_("undefined");
function DW(e) {
  return e !== null && !Tg(e) && e.constructor !== null && !Tg(e.constructor) && Ls(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const tD = Aa("ArrayBuffer");
function jW(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && tD(e.buffer), t;
}
const VW = R_("string"), Ls = R_("function"), nD = R_("number"), L_ = (e) => e !== null && typeof e == "object", zW = (e) => e === !0 || e === !1, yb = (e) => {
  if (P_(e) !== "object")
    return !1;
  const t = LC(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, BW = Aa("Date"), UW = Aa("File"), qW = Aa("Blob"), GW = Aa("FileList"), WW = (e) => L_(e) && Ls(e.pipe), HW = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Ls(e.append) && ((t = P_(e)) === "formdata" || // detect form-data instance
  t === "object" && Ls(e.toString) && e.toString() === "[object FormData]"));
}, JW = Aa("URLSearchParams"), ZW = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function d0(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Df(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = s.length;
    let a;
    for (r = 0; r < o; r++)
      a = s[r], t.call(null, e[a], a, e);
  }
}
function rD(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const iD = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, sD = (e) => !Tg(e) && e !== iD;
function w$() {
  const { caseless: e } = sD(this) && this || {}, t = {}, n = (r, i) => {
    const s = e && rD(t, i) || i;
    yb(t[s]) && yb(r) ? t[s] = w$(t[s], r) : yb(r) ? t[s] = w$({}, r) : Df(r) ? t[s] = r.slice() : t[s] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && d0(arguments[r], n);
  return t;
}
const KW = (e, t, n, { allOwnKeys: r } = {}) => (d0(t, (i, s) => {
  n && Ls(i) ? e[s] = eD(i, n) : e[s] = i;
}, { allOwnKeys: r }), e), YW = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), QW = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, XW = (e, t, n, r) => {
  let i, s, o;
  const a = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      o = i[s], (!r || r(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = n !== !1 && LC(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, eH = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, tH = (e) => {
  if (!e)
    return null;
  if (Df(e))
    return e;
  let t = e.length;
  if (!nD(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, nH = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && LC(Uint8Array)), rH = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, iH = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, sH = Aa("HTMLFormElement"), oH = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), rA = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), aH = Aa("RegExp"), oD = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  d0(n, (i, s) => {
    let o;
    (o = t(i, s, e)) !== !1 && (r[s] = o || i);
  }), Object.defineProperties(e, r);
}, lH = (e) => {
  oD(e, (t, n) => {
    if (Ls(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Ls(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, uH = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((s) => {
      n[s] = !0;
    });
  };
  return Df(e) ? r(e) : r(String(e).split(t)), n;
}, cH = () => {
}, dH = (e, t) => (e = +e, Number.isFinite(e) ? e : t), p2 = "abcdefghijklmnopqrstuvwxyz", iA = "0123456789", aD = {
  DIGIT: iA,
  ALPHA: p2,
  ALPHA_DIGIT: p2 + p2.toUpperCase() + iA
}, pH = (e = 16, t = aD.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function hH(e) {
  return !!(e && Ls(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const fH = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (L_(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const s = Df(r) ? [] : {};
        return d0(r, (o, a) => {
          const l = n(o, i + 1);
          !Tg(l) && (s[a] = l);
        }), t[i] = void 0, s;
      }
    }
    return r;
  };
  return n(e, 0);
}, mH = Aa("AsyncFunction"), yH = (e) => e && (L_(e) || Ls(e)) && Ls(e.then) && Ls(e.catch), ne = {
  isArray: Df,
  isArrayBuffer: tD,
  isBuffer: DW,
  isFormData: HW,
  isArrayBufferView: jW,
  isString: VW,
  isNumber: nD,
  isBoolean: zW,
  isObject: L_,
  isPlainObject: yb,
  isUndefined: Tg,
  isDate: BW,
  isFile: UW,
  isBlob: qW,
  isRegExp: aH,
  isFunction: Ls,
  isStream: WW,
  isURLSearchParams: JW,
  isTypedArray: nH,
  isFileList: GW,
  forEach: d0,
  merge: w$,
  extend: KW,
  trim: ZW,
  stripBOM: YW,
  inherits: QW,
  toFlatObject: XW,
  kindOf: P_,
  kindOfTest: Aa,
  endsWith: eH,
  toArray: tH,
  forEachEntry: rH,
  matchAll: iH,
  isHTMLForm: sH,
  hasOwnProperty: rA,
  hasOwnProp: rA,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: oD,
  freezeMethods: lH,
  toObjectSet: uH,
  toCamelCase: oH,
  noop: cH,
  toFiniteNumber: dH,
  findKey: rD,
  global: iD,
  isContextDefined: sD,
  ALPHABET: aD,
  generateString: pH,
  isSpecCompliantForm: hH,
  toJSONObject: fH,
  isAsyncFn: mH,
  isThenable: yH
};
function vt(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
ne.inherits(vt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ne.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const lD = vt.prototype, uD = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  uD[e] = { value: e };
});
Object.defineProperties(vt, uD);
Object.defineProperty(lD, "isAxiosError", { value: !0 });
vt.from = (e, t, n, r, i, s) => {
  const o = Object.create(lD);
  return ne.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), vt.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o;
};
const gH = null;
function _$(e) {
  return ne.isPlainObject(e) || ne.isArray(e);
}
function cD(e) {
  return ne.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function sA(e, t, n) {
  return e ? e.concat(t).map(function(i, s) {
    return i = cD(i), !n && s ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function vH(e) {
  return ne.isArray(e) && !e.some(_$);
}
const bH = ne.toFlatObject(ne, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function F_(e, t, n) {
  if (!ne.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ne.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, w) {
    return !ne.isUndefined(w[v]);
  });
  const r = n.metaTokens, i = n.visitor || p, s = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && ne.isSpecCompliantForm(t);
  if (!ne.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(g) {
    if (g === null)
      return "";
    if (ne.isDate(g))
      return g.toISOString();
    if (!l && ne.isBlob(g))
      throw new vt("Blob is not supported. Use a Buffer instead.");
    return ne.isArrayBuffer(g) || ne.isTypedArray(g) ? l && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
  function p(g, v, w) {
    let b = g;
    if (g && !w && typeof g == "object") {
      if (ne.endsWith(v, "{}"))
        v = r ? v : v.slice(0, -2), g = JSON.stringify(g);
      else if (ne.isArray(g) && vH(g) || (ne.isFileList(g) || ne.endsWith(v, "[]")) && (b = ne.toArray(g)))
        return v = cD(v), b.forEach(function($, I) {
          !(ne.isUndefined($) || $ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? sA([v], I, s) : o === null ? v : v + "[]",
            c($)
          );
        }), !1;
    }
    return _$(g) ? !0 : (t.append(sA(w, v, s), c(g)), !1);
  }
  const f = [], m = Object.assign(bH, {
    defaultVisitor: p,
    convertValue: c,
    isVisitable: _$
  });
  function y(g, v) {
    if (!ne.isUndefined(g)) {
      if (f.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      f.push(g), ne.forEach(g, function(b, S) {
        (!(ne.isUndefined(b) || b === null) && i.call(
          t,
          b,
          ne.isString(S) ? S.trim() : S,
          v,
          m
        )) === !0 && y(b, v ? v.concat(S) : [S]);
      }), f.pop();
    }
  }
  if (!ne.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function oA(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function FC(e, t) {
  this._pairs = [], e && F_(e, this, t);
}
const dD = FC.prototype;
dD.append = function(t, n) {
  this._pairs.push([t, n]);
};
dD.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, oA);
  } : oA;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function wH(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function pD(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || wH, i = n && n.serialize;
  let s;
  if (i ? s = i(t, n) : s = ne.isURLSearchParams(t) ? t.toString() : new FC(t, n).toString(r), s) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class _H {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ne.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const aA = _H, hD = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, SH = typeof URLSearchParams < "u" ? URLSearchParams : FC, xH = typeof FormData < "u" ? FormData : null, $H = typeof Blob < "u" ? Blob : null, TH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: SH,
    FormData: xH,
    Blob: $H
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, fD = typeof window < "u" && typeof document < "u", EH = ((e) => fD && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), IH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", MH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: fD,
  hasStandardBrowserEnv: EH,
  hasStandardBrowserWebWorkerEnv: IH
}, Symbol.toStringTag, { value: "Module" })), fa = {
  ...MH,
  ...TH
};
function CH(e, t) {
  return F_(e, new fa.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, s) {
      return fa.isNode && ne.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function OH(e) {
  return ne.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function kH(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let s;
  for (r = 0; r < i; r++)
    s = n[r], t[s] = e[s];
  return t;
}
function mD(e) {
  function t(n, r, i, s) {
    let o = n[s++];
    const a = Number.isFinite(+o), l = s >= n.length;
    return o = !o && ne.isArray(i) ? i.length : o, l ? (ne.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !ne.isObject(i[o])) && (i[o] = []), t(n, r, i[o], s) && ne.isArray(i[o]) && (i[o] = kH(i[o])), !a);
  }
  if (ne.isFormData(e) && ne.isFunction(e.entries)) {
    const n = {};
    return ne.forEachEntry(e, (r, i) => {
      t(OH(r), i, n, 0);
    }), n;
  }
  return null;
}
function AH(e, t, n) {
  if (ne.isString(e))
    try {
      return (t || JSON.parse)(e), ne.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const NC = {
  transitional: hD,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = ne.isObject(t);
    if (s && ne.isHTMLForm(t) && (t = new FormData(t)), ne.isFormData(t))
      return i && i ? JSON.stringify(mD(t)) : t;
    if (ne.isArrayBuffer(t) || ne.isBuffer(t) || ne.isStream(t) || ne.isFile(t) || ne.isBlob(t))
      return t;
    if (ne.isArrayBufferView(t))
      return t.buffer;
    if (ne.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (s) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return CH(t, this.formSerializer).toString();
      if ((a = ne.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return F_(
          a ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || i ? (n.setContentType("application/json", !1), AH(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || NC.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && ne.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? vt.from(a, vt.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: fa.classes.FormData,
    Blob: fa.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ne.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  NC.headers[e] = {};
});
const DC = NC, PH = ne.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), RH = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && PH[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, lA = Symbol("internals");
function gm(e) {
  return e && String(e).trim().toLowerCase();
}
function gb(e) {
  return e === !1 || e == null ? e : ne.isArray(e) ? e.map(gb) : String(e);
}
function LH(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const FH = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function h2(e, t, n, r, i) {
  if (ne.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!ne.isString(t)) {
    if (ne.isString(r))
      return t.indexOf(r) !== -1;
    if (ne.isRegExp(r))
      return r.test(t);
  }
}
function NH(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function DH(e, t) {
  const n = ne.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, s, o) {
        return this[r].call(this, t, i, s, o);
      },
      configurable: !0
    });
  });
}
class N_ {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function s(a, l, c) {
      const p = gm(l);
      if (!p)
        throw new Error("header name must be a non-empty string");
      const f = ne.findKey(i, p);
      (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = gb(a));
    }
    const o = (a, l) => ne.forEach(a, (c, p) => s(c, p, l));
    return ne.isPlainObject(t) || t instanceof this.constructor ? o(t, n) : ne.isString(t) && (t = t.trim()) && !FH(t) ? o(RH(t), n) : t != null && s(n, t, r), this;
  }
  get(t, n) {
    if (t = gm(t), t) {
      const r = ne.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return LH(i);
        if (ne.isFunction(n))
          return n.call(this, i, r);
        if (ne.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = gm(t), t) {
      const r = ne.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || h2(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function s(o) {
      if (o = gm(o), o) {
        const a = ne.findKey(r, o);
        a && (!n || h2(r, r[a], a, n)) && (delete r[a], i = !0);
      }
    }
    return ne.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const s = n[r];
      (!t || h2(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return ne.forEach(this, (i, s) => {
      const o = ne.findKey(r, s);
      if (o) {
        n[o] = gb(i), delete n[s];
        return;
      }
      const a = t ? NH(s) : String(s).trim();
      a !== s && delete n[s], n[a] = gb(i), r[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ne.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && ne.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[lA] = this[lA] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = gm(o);
      r[a] || (DH(i, o), r[a] = !0);
    }
    return ne.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
N_.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ne.reduceDescriptors(N_.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
ne.freezeMethods(N_);
const $l = N_;
function f2(e, t) {
  const n = this || DC, r = t || n, i = $l.from(r.headers);
  let s = r.data;
  return ne.forEach(e, function(a) {
    s = a.call(n, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function yD(e) {
  return !!(e && e.__CANCEL__);
}
function p0(e, t, n) {
  vt.call(this, e ?? "canceled", vt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ne.inherits(p0, vt, {
  __CANCEL__: !0
});
function jH(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new vt(
    "Request failed with status code " + n.status,
    [vt.ERR_BAD_REQUEST, vt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const VH = fa.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, s) {
      const o = [e + "=" + encodeURIComponent(t)];
      ne.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), ne.isString(r) && o.push("path=" + r), ne.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function zH(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function BH(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function gD(e, t) {
  return e && !zH(t) ? BH(e, t) : t;
}
const UH = fa.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(s) {
      let o = s;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(o) {
      const a = ne.isString(o) ? i(o) : o;
      return a.protocol === r.protocol && a.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function qH(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function GH(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, s = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), p = r[s];
    o || (o = c), n[i] = l, r[i] = c;
    let f = s, m = 0;
    for (; f !== i; )
      m += n[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), c - o < t)
      return;
    const y = p && c - p;
    return y ? Math.round(m * 1e3 / y) : void 0;
  };
}
function uA(e, t) {
  let n = 0;
  const r = GH(50, 250);
  return (i) => {
    const s = i.loaded, o = i.lengthComputable ? i.total : void 0, a = s - n, l = r(a), c = s <= o;
    n = s;
    const p = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: l || void 0,
      estimated: l && o && c ? (o - s) / l : void 0,
      event: i
    };
    p[t ? "download" : "upload"] = !0, e(p);
  };
}
const WH = typeof XMLHttpRequest < "u", HH = WH && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const s = $l.from(e.headers).normalize();
    let { responseType: o, withXSRFToken: a } = e, l;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(l), e.signal && e.signal.removeEventListener("abort", l);
    }
    let p;
    if (ne.isFormData(i)) {
      if (fa.hasStandardBrowserEnv || fa.hasStandardBrowserWebWorkerEnv)
        s.setContentType(!1);
      else if ((p = s.getContentType()) !== !1) {
        const [v, ...w] = p ? p.split(";").map((b) => b.trim()).filter(Boolean) : [];
        s.setContentType([v || "multipart/form-data", ...w].join("; "));
      }
    }
    let f = new XMLHttpRequest();
    if (e.auth) {
      const v = e.auth.username || "", w = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      s.set("Authorization", "Basic " + btoa(v + ":" + w));
    }
    const m = gD(e.baseURL, e.url);
    f.open(e.method.toUpperCase(), pD(m, e.params, e.paramsSerializer), !0), f.timeout = e.timeout;
    function y() {
      if (!f)
        return;
      const v = $l.from(
        "getAllResponseHeaders" in f && f.getAllResponseHeaders()
      ), b = {
        data: !o || o === "text" || o === "json" ? f.responseText : f.response,
        status: f.status,
        statusText: f.statusText,
        headers: v,
        config: e,
        request: f
      };
      jH(function($) {
        n($), c();
      }, function($) {
        r($), c();
      }, b), f = null;
    }
    if ("onloadend" in f ? f.onloadend = y : f.onreadystatechange = function() {
      !f || f.readyState !== 4 || f.status === 0 && !(f.responseURL && f.responseURL.indexOf("file:") === 0) || setTimeout(y);
    }, f.onabort = function() {
      f && (r(new vt("Request aborted", vt.ECONNABORTED, e, f)), f = null);
    }, f.onerror = function() {
      r(new vt("Network Error", vt.ERR_NETWORK, e, f)), f = null;
    }, f.ontimeout = function() {
      let w = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const b = e.transitional || hD;
      e.timeoutErrorMessage && (w = e.timeoutErrorMessage), r(new vt(
        w,
        b.clarifyTimeoutError ? vt.ETIMEDOUT : vt.ECONNABORTED,
        e,
        f
      )), f = null;
    }, fa.hasStandardBrowserEnv && (a && ne.isFunction(a) && (a = a(e)), a || a !== !1 && UH(m))) {
      const v = e.xsrfHeaderName && e.xsrfCookieName && VH.read(e.xsrfCookieName);
      v && s.set(e.xsrfHeaderName, v);
    }
    i === void 0 && s.setContentType(null), "setRequestHeader" in f && ne.forEach(s.toJSON(), function(w, b) {
      f.setRequestHeader(b, w);
    }), ne.isUndefined(e.withCredentials) || (f.withCredentials = !!e.withCredentials), o && o !== "json" && (f.responseType = e.responseType), typeof e.onDownloadProgress == "function" && f.addEventListener("progress", uA(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && f.upload && f.upload.addEventListener("progress", uA(e.onUploadProgress)), (e.cancelToken || e.signal) && (l = (v) => {
      f && (r(!v || v.type ? new p0(null, e, f) : v), f.abort(), f = null);
    }, e.cancelToken && e.cancelToken.subscribe(l), e.signal && (e.signal.aborted ? l() : e.signal.addEventListener("abort", l)));
    const g = qH(m);
    if (g && fa.protocols.indexOf(g) === -1) {
      r(new vt("Unsupported protocol " + g + ":", vt.ERR_BAD_REQUEST, e));
      return;
    }
    f.send(i || null);
  });
}, S$ = {
  http: gH,
  xhr: HH
};
ne.forEach(S$, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const cA = (e) => `- ${e}`, JH = (e) => ne.isFunction(e) || e === null || e === !1, vD = {
  getAdapter: (e) => {
    e = ne.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let s = 0; s < t; s++) {
      n = e[s];
      let o;
      if (r = n, !JH(n) && (r = S$[(o = String(n)).toLowerCase()], r === void 0))
        throw new vt(`Unknown adapter '${o}'`);
      if (r)
        break;
      i[o || "#" + s] = r;
    }
    if (!r) {
      const s = Object.entries(i).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? s.length > 1 ? `since :
` + s.map(cA).join(`
`) : " " + cA(s[0]) : "as no adapter specified";
      throw new vt(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: S$
};
function m2(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new p0(null, e);
}
function dA(e) {
  return m2(e), e.headers = $l.from(e.headers), e.data = f2.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), vD.getAdapter(e.adapter || DC.adapter)(e).then(function(r) {
    return m2(e), r.data = f2.call(
      e,
      e.transformResponse,
      r
    ), r.headers = $l.from(r.headers), r;
  }, function(r) {
    return yD(r) || (m2(e), r && r.response && (r.response.data = f2.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = $l.from(r.response.headers))), Promise.reject(r);
  });
}
const pA = (e) => e instanceof $l ? e.toJSON() : e;
function cf(e, t) {
  t = t || {};
  const n = {};
  function r(c, p, f) {
    return ne.isPlainObject(c) && ne.isPlainObject(p) ? ne.merge.call({ caseless: f }, c, p) : ne.isPlainObject(p) ? ne.merge({}, p) : ne.isArray(p) ? p.slice() : p;
  }
  function i(c, p, f) {
    if (ne.isUndefined(p)) {
      if (!ne.isUndefined(c))
        return r(void 0, c, f);
    } else
      return r(c, p, f);
  }
  function s(c, p) {
    if (!ne.isUndefined(p))
      return r(void 0, p);
  }
  function o(c, p) {
    if (ne.isUndefined(p)) {
      if (!ne.isUndefined(c))
        return r(void 0, c);
    } else
      return r(void 0, p);
  }
  function a(c, p, f) {
    if (f in t)
      return r(c, p);
    if (f in e)
      return r(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, p) => i(pA(c), pA(p), !0)
  };
  return ne.forEach(Object.keys(Object.assign({}, e, t)), function(p) {
    const f = l[p] || i, m = f(e[p], t[p], p);
    ne.isUndefined(m) && f !== a || (n[p] = m);
  }), n;
}
const bD = "1.6.2", jC = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  jC[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const hA = {};
jC.transitional = function(t, n, r) {
  function i(s, o) {
    return "[Axios v" + bD + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "");
  }
  return (s, o, a) => {
    if (t === !1)
      throw new vt(
        i(o, " has been removed" + (n ? " in " + n : "")),
        vt.ERR_DEPRECATED
      );
    return n && !hA[o] && (hA[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, o, a) : !0;
  };
};
function ZH(e, t, n) {
  if (typeof e != "object")
    throw new vt("options must be an object", vt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i], o = t[s];
    if (o) {
      const a = e[s], l = a === void 0 || o(a, s, e);
      if (l !== !0)
        throw new vt("option " + s + " must be " + l, vt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new vt("Unknown option " + s, vt.ERR_BAD_OPTION);
  }
}
const x$ = {
  assertOptions: ZH,
  validators: jC
}, Vl = x$.validators;
class Xw {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new aA(),
      response: new aA()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = cf(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: s } = n;
    r !== void 0 && x$.assertOptions(r, {
      silentJSONParsing: Vl.transitional(Vl.boolean),
      forcedJSONParsing: Vl.transitional(Vl.boolean),
      clarifyTimeoutError: Vl.transitional(Vl.boolean)
    }, !1), i != null && (ne.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : x$.assertOptions(i, {
      encode: Vl.function,
      serialize: Vl.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = s && ne.merge(
      s.common,
      s[n.method]
    );
    s && ne.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete s[g];
      }
    ), n.headers = $l.concat(o, s);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(n) === !1 || (l = l && v.synchronous, a.unshift(v.fulfilled, v.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(v) {
      c.push(v.fulfilled, v.rejected);
    });
    let p, f = 0, m;
    if (!l) {
      const g = [dA.bind(this), void 0];
      for (g.unshift.apply(g, a), g.push.apply(g, c), m = g.length, p = Promise.resolve(n); f < m; )
        p = p.then(g[f++], g[f++]);
      return p;
    }
    m = a.length;
    let y = n;
    for (f = 0; f < m; ) {
      const g = a[f++], v = a[f++];
      try {
        y = g(y);
      } catch (w) {
        v.call(this, w);
        break;
      }
    }
    try {
      p = dA.call(this, y);
    } catch (g) {
      return Promise.reject(g);
    }
    for (f = 0, m = c.length; f < m; )
      p = p.then(c[f++], c[f++]);
    return p;
  }
  getUri(t) {
    t = cf(this.defaults, t);
    const n = gD(t.baseURL, t.url);
    return pD(n, t.params, t.paramsSerializer);
  }
}
ne.forEach(["delete", "get", "head", "options"], function(t) {
  Xw.prototype[t] = function(n, r) {
    return this.request(cf(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
ne.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(s, o, a) {
      return this.request(cf(a || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  Xw.prototype[t] = n(), Xw.prototype[t + "Form"] = n(!0);
});
const vb = Xw;
class VC {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        r.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(s);
      }, o;
    }, t(function(s, o, a) {
      r.reason || (r.reason = new p0(s, o, a), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new VC(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
const KH = VC;
function YH(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function QH(e) {
  return ne.isObject(e) && e.isAxiosError === !0;
}
const $$ = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries($$).forEach(([e, t]) => {
  $$[t] = e;
});
const XH = $$;
function wD(e) {
  const t = new vb(e), n = eD(vb.prototype.request, t);
  return ne.extend(n, vb.prototype, t, { allOwnKeys: !0 }), ne.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return wD(cf(e, i));
  }, n;
}
const Bn = wD(DC);
Bn.Axios = vb;
Bn.CanceledError = p0;
Bn.CancelToken = KH;
Bn.isCancel = yD;
Bn.VERSION = bD;
Bn.toFormData = F_;
Bn.AxiosError = vt;
Bn.Cancel = Bn.CanceledError;
Bn.all = function(t) {
  return Promise.all(t);
};
Bn.spread = YH;
Bn.isAxiosError = QH;
Bn.mergeConfig = cf;
Bn.AxiosHeaders = $l;
Bn.formToJSON = (e) => mD(ne.isHTMLForm(e) ? new FormData(e) : e);
Bn.getAdapter = vD.getAdapter;
Bn.HttpStatusCode = XH;
Bn.default = Bn;
const zC = Bn;
function u(e, t, n, r) {
  var i, s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(e, t, n, r);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
  return s > 3 && o && Object.defineProperty(t, n, o), o;
}
function eJ(e) {
  return e && e.release && typeof e.release == "function";
}
function tJ(e) {
  return e && e.acquire && typeof e.acquire == "function";
}
let fc = class T$ {
  constructor(t, n, r, i = 1, s = 0) {
    if (this.ctor = t, this.acquireFunction = n, this.releaseFunction = r, this.allocationSize = i, this._pool = new Array(s), this._initialSize = s, this.ctor)
      for (let o = 0; o < s; o++)
        this._pool[o] = new this.ctor();
    this.allocationSize = Math.max(i, 1);
  }
  destroy() {
    this.prune(0);
  }
  acquire(...t) {
    let n;
    if (T$.test.disabled)
      n = new this.ctor();
    else {
      if (this._pool.length === 0) {
        const r = this.allocationSize;
        for (let i = 0; i < r; i++)
          this._pool[i] = new this.ctor();
      }
      n = this._pool.pop();
    }
    return this.acquireFunction ? this.acquireFunction(n, ...t) : tJ(n) && n.acquire(...t), n;
  }
  release(t) {
    t && !T$.test.disabled && (this.releaseFunction ? this.releaseFunction(t) : eJ(t) && t.release(), this._pool.push(t));
  }
  prune(t = this._initialSize) {
    if (!(t >= this._pool.length)) {
      for (let n = t; n < this._pool.length; ++n) {
        const r = this._pool[n];
        this._dispose(r);
      }
      this._pool.length = t;
    }
  }
  _dispose(t) {
    t.dispose && typeof t.dispose == "function" && t.dispose();
  }
};
fc.test = { disabled: !1 };
function nJ(e) {
  e.length = 0;
}
let Hr = class {
  constructor(t = 50, n = 50) {
    this._pool = new fc(Array, void 0, nJ, n, t);
  }
  acquire() {
    return this._pool.acquire();
  }
  release(t) {
    this._pool.release(t);
  }
  prune() {
    this._pool.prune(0);
  }
  static acquire() {
    return y2.acquire();
  }
  static release(t) {
    return y2.release(t);
  }
  static prune() {
    y2.prune();
  }
};
const y2 = new Hr(100);
var fA, mA;
let wl;
var yA, gA;
(fA = globalThis.dojoConfig) != null && fA.has || (mA = globalThis.geosceneConfig) != null && mA.has ? wl = { ...(yA = globalThis.dojoConfig) == null ? void 0 : yA.has, ...(gA = globalThis.geosceneConfig) == null ? void 0 : gA.has } : wl = {};
function K(e) {
  return typeof wl[e] == "function" ? wl[e] = wl[e](globalThis) : wl[e];
}
K.add = (e, t, n, r) => ((r || wl[e] === void 0) && (wl[e] = t), n && K(e)), K.cache = wl, K.add("geoscene-deprecation-warnings", !0), (() => {
  var e;
  K.add("host-webworker", globalThis.WorkerGlobalScope !== void 0 && self instanceof globalThis.WorkerGlobalScope);
  const t = typeof window < "u" && typeof location < "u" && typeof document < "u" && window.location === location && window.document === document;
  if (K.add("host-browser", t), K.add("host-node", typeof globalThis.process == "object" && ((e = globalThis.process.versions) == null ? void 0 : e.node) && globalThis.process.versions.v8), K.add("dom", t), K("host-browser")) {
    const n = navigator, r = n.userAgent, i = n.appVersion, s = parseFloat(i);
    if (K.add("wp", parseFloat(r.split("Windows Phone")[1]) || void 0), K.add("msapp", parseFloat(r.split("MSAppHost/")[1]) || void 0), K.add("khtml", i.includes("Konqueror") ? s : void 0), K.add("edge", parseFloat(r.split("Edge/")[1]) || void 0), K.add("opr", parseFloat(r.split("OPR/")[1]) || void 0), K.add("webkit", !K("wp") && !K("edge") && parseFloat(r.split("WebKit/")[1]) || void 0), K.add("chrome", !K("edge") && !K("opr") && parseFloat(r.split("Chrome/")[1]) || void 0), K.add("android", !K("wp") && parseFloat(r.split("Android ")[1]) || void 0), K.add("safari", !i.includes("Safari") || K("wp") || K("chrome") || K("android") || K("edge") || K("opr") ? void 0 : parseFloat(i.split("Version/")[1])), K.add("mac", i.includes("Macintosh")), !K("wp") && r.match(/(iPhone|iPod|iPad)/)) {
      const o = RegExp.$1.replace(/P/, "p"), a = r.match(/OS ([\d_]+)/) ? RegExp.$1 : "1", l = parseFloat(a.replace(/_/, ".").replace(/_/g, ""));
      K.add(o, l), K.add("ios", l);
    }
    K.add("trident", parseFloat(i.split("Trident/")[1]) || void 0), K("webkit") || (!r.includes("Gecko") || K("wp") || K("khtml") || K("trident") || K("edge") || K.add("mozilla", s), K("mozilla") && K.add("ff", parseFloat(r.split("Firefox/")[1] || r.split("Minefield/")[1]) || void 0));
  }
})(), (() => {
  if (globalThis.navigator) {
    const e = navigator.userAgent, t = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i.test(e), n = /iPhone/i.test(e);
    t && K.add("geoscene-mobile", t), n && K.add("geoscene-iPhone", n), K.add("geoscene-geolocation", !!navigator.geolocation);
  }
  K.add("geoscene-canvas-svg-support", !K("trident")), K.add("geoscene-wasm", "WebAssembly" in globalThis), K.add("geoscene-shared-array-buffer", () => {
    const e = "SharedArrayBuffer" in globalThis, t = globalThis.crossOriginIsolated === !1;
    return e && !t;
  }), K.add("geoscene-atomics", "Atomics" in globalThis), K.add("geoscene-workers", "Worker" in globalThis), K.add("web-feat:cache", "caches" in globalThis), K.add("geoscene-workers-arraybuffer-transfer", !K("safari") || Number(K("safari")) >= 12), K.add("featurelayer-simplify-thresholds", [0.5, 0.5, 0.5, 0.5]), K.add("featurelayer-simplify-payload-size-factors", [1, 1, 4]), K.add("featurelayer-snapshot-enabled", !0), K.add("featurelayer-snapshot-point-min-threshold", 8e4), K.add("featurelayer-snapshot-point-max-threshold", 4e5), K.add("featurelayer-snapshot-point-coverage", 0.1), K.add("featurelayer-advanced-symbols", !1), K.add("featurelayer-pbf", !0), K.add("featurelayer-pbf-statistics", !1), K.add("feature-layers-workers", !0), K.add("feature-polyline-generalization-factor", 1), K.add("mapview-transitions-duration", 200), K.add("mapview-srswitch-adjust-rotation-scale-threshold", 24e6), K.add("mapserver-pbf-enabled", !1), K("host-webworker") || K("host-browser") && (K.add("geoscene-csp-restrictions", () => {
    try {
      new Function();
    } catch {
      return !0;
    }
    return !1;
  }), K.add("geoscene-image-decode", () => {
    if ("decode" in new Image()) {
      const e = new Image();
      return e.src = 'data:image/svg+xml;charset=UTF-8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>', void e.decode().then(() => {
        K.add("geoscene-image-decode", !0, !0, !0);
      }).catch(() => {
        K.add("geoscene-image-decode", !1, !0, !0);
      });
    }
    return !1;
  }), K.add("geoscene-url-encodes-apostrophe", () => {
    const e = window.document.createElement("a");
    return e.href = "?'", e.href.includes("?%27");
  }));
})();
const vA = /* @__PURE__ */ new Set();
function rJ(e, t, n = !1) {
  n && vA.has(t) || (n && vA.add(t), e.warn(` DEPRECATED - ${t}`));
}
function Xp(e, t, n = {}) {
  if (K("geoscene-deprecation-warnings")) {
    const { moduleName: r } = n;
    D_(e, `Function: ${(r ? r + "::" : "") + t + "()"}`, n);
  }
}
function iJ(e, t, n = {}) {
  if (K("geoscene-deprecation-warnings")) {
    const { moduleName: r } = n;
    D_(e, `Property: ${(r ? r + "::" : "") + t}`, n);
  }
}
function D_(e, t, n = {}) {
  if (K("geoscene-deprecation-warnings")) {
    const { replacement: r, version: i, see: s, warnOnce: o } = n;
    let a = t;
    r && (a += `
	 Replacement: ${r}`), i && (a += `
	 Version: ${i}`), s && (a += `
	 See ${s} for more details.`), rJ(e, a, o);
  }
}
const sJ = null;
function O(e) {
  return e != null;
}
function H(e) {
  return e == null;
}
function L3e(e) {
  return e === void 0;
}
function Nu(e, t) {
  return O(e) ? t(e) : sJ;
}
function F3e(e) {
  return e;
}
function oJ(e, t) {
  if (H(e))
    throw new Error(t);
  return e;
}
function BC(e, t) {
  return O(e) ? e : typeof t == "function" ? t() : t;
}
function N3e(e, t) {
  return O(e) ? e : t;
}
function pa(e) {
  return O(e) && e.destroy(), null;
}
function D3e(e) {
  return O(e) && e.dispose(), null;
}
function Sp(e) {
  return O(e) && e.remove(), null;
}
function E$(e) {
  return O(e) && e.abort(), null;
}
function j3e(e) {
  return O(e) && e.release(), null;
}
function aJ(e) {
  return null;
}
function V3e(e, t) {
  const n = new Array();
  for (const r of e)
    n.push(Jm(r, null, t));
  return n;
}
function z3e(e, t) {
  for (const n of e)
    Nu(n, t);
}
function Jm(e, t, n) {
  return O(e) ? n(e) : t;
}
function B3e(e) {
  return e.filter((t) => O(t));
}
function _D(e, ...t) {
  let n = e;
  for (let r = 0; r < t.length && n; ++r)
    n = n[t[r]];
  return n;
}
function U3e(e) {
  return e;
}
let g2 = class Ac {
  constructor(t = 1) {
    this._seed = t;
  }
  set seed(t) {
    this._seed = t ?? Math.random() * Ac._m;
  }
  getInt() {
    return this._seed = (Ac._a * this._seed + Ac._c) % Ac._m, this._seed;
  }
  getFloat() {
    return this.getInt() / (Ac._m - 1);
  }
  getIntRange(t, n) {
    return Math.round(this.getFloatRange(t, n));
  }
  getFloatRange(t, n) {
    const r = n - t;
    return t + this.getInt() / Ac._m * r;
  }
};
g2._m = 2147483647, g2._a = 48271, g2._c = 0;
function SD(e, t, n) {
  if (H(e) && H(t))
    return !0;
  if (H(e) || H(t) || e.length !== t.length)
    return !1;
  if (n) {
    for (let r = 0; r < e.length; r++)
      if (!n(e[r], t[r]))
        return !1;
  } else
    for (let r = 0; r < e.length; r++)
      if (e[r] !== t[r])
        return !1;
  return !0;
}
function q3e(e) {
  return e && typeof e.length == "number";
}
const lJ = !!Array.prototype.fill;
function G3e(e, t) {
  if (lJ)
    return new Array(e).fill(t);
  const n = new Array(e);
  for (let r = 0; r < e; r++)
    n[r] = t;
  return n;
}
function W3e(e, t) {
  t === void 0 && (t = e, e = 0);
  const n = new Array(t - e);
  for (let r = e; r < t; r++)
    n[r - e] = r;
  return n;
}
let xD = class {
  constructor() {
    this.last = 0;
  }
};
const $D = new xD();
function TD(e, t, n, r) {
  r = r || $D;
  const i = Math.max(0, r.last - 10);
  for (let o = i; o < n; ++o)
    if (e[o] === t)
      return r.last = o, o;
  const s = Math.min(i, n);
  for (let o = 0; o < s; ++o)
    if (e[o] === t)
      return r.last = o, o;
  return -1;
}
function ED(e, t, n, r) {
  const i = n ?? e.length, s = TD(e, t, i, r);
  if (s !== -1)
    return e[s] = e[i - 1], n == null && e.pop(), t;
}
const Ks = /* @__PURE__ */ new Set();
function uJ(e, t, n = e.length, r = t.length, i, s) {
  if (r === 0 || n === 0)
    return n;
  Ks.clear();
  for (let a = 0; a < r; ++a)
    Ks.add(t[a]);
  i = i || $D;
  const o = Math.max(0, i.last - 10);
  for (let a = o; a < n; ++a)
    if (Ks.has(e[a]) && (s && s.push(e[a]), Ks.delete(e[a]), e[a] = e[n - 1], --n, --a, Ks.size === 0 || n === 0))
      return Ks.clear(), n;
  for (let a = 0; a < o; ++a)
    if (Ks.has(e[a]) && (s && s.push(e[a]), Ks.delete(e[a]), e[a] = e[n - 1], --n, --a, Ks.size === 0 || n === 0))
      return Ks.clear(), n;
  return Ks.clear(), n;
}
function cJ(e, t) {
  const n = e.indexOf(t);
  return n !== -1 ? (e.splice(n, 1), t) : null;
}
function J3e(e, t) {
  if (e.forEach)
    e.forEach(t);
  else
    for (let n = 0; n < e.length; n++)
      t(e[n], n, e);
}
function dJ(e, t, n) {
  if (e.slice)
    return e.slice(t, n);
  t === void 0 ? t = 0 : (t < 0 && (t += e.length), t = Math.min(e.length, Math.max(0, t))), n === void 0 ? n = e.length : (n < 0 && (n += e.length), n = Math.min(e.length, Math.max(0, n)));
  const r = Math.max(0, n - t), i = new e.constructor(r);
  for (let s = 0; s < r; s++)
    i[s] = e[t + s];
  return i;
}
function Z3e(e) {
  return e instanceof ArrayBuffer || e && e.constructor && e.constructor.name === "ArrayBuffer";
}
function pJ(e) {
  return e instanceof Int8Array || e && e.constructor && e.constructor.name === "Int8Array";
}
function hJ(e) {
  return e instanceof Uint8Array || e && e.constructor && e.constructor.name === "Uint8Array";
}
function fJ(e) {
  return e instanceof Uint8ClampedArray || e && e.constructor && e.constructor.name === "Uint8ClampedArray";
}
function mJ(e) {
  return e instanceof Int16Array || e && e.constructor && e.constructor.name === "Int16Array";
}
function yJ(e) {
  return e instanceof Uint16Array || e && e.constructor && e.constructor.name === "Uint16Array";
}
function gJ(e) {
  return e instanceof Int32Array || e && e.constructor && e.constructor.name === "Int32Array";
}
function vJ(e) {
  return e instanceof Uint32Array || e && e.constructor && e.constructor.name === "Uint32Array";
}
function bJ(e) {
  return e instanceof Float32Array || e && e.constructor && e.constructor.name === "Float32Array";
}
function wJ(e) {
  return e instanceof Float64Array || e && e.constructor && e.constructor.name === "Float64Array";
}
function ID(e, t) {
  let n;
  if (t)
    for (n in e)
      e.hasOwnProperty(n) && (e[n] === void 0 ? delete e[n] : e[n] instanceof Object && ID(e[n], !0));
  else
    for (n in e)
      e.hasOwnProperty(n) && e[n] === void 0 && delete e[n];
  return e;
}
function q(e) {
  if (!e || typeof e != "object" || typeof e == "function")
    return e;
  const t = kD(e);
  if (O(t))
    return t;
  if (MD(e))
    return e.clone();
  if (CD(e))
    return e.map(q);
  if (OD(e))
    return e.clone();
  const n = {};
  for (const r of Object.getOwnPropertyNames(e))
    n[r] = q(e[r]);
  return n;
}
function I$(e) {
  if (!e || typeof e != "object" || typeof e == "function")
    return e;
  const t = kD(e);
  if (O(t))
    return t;
  if (CD(e)) {
    let n = !0;
    const r = e.map((i) => {
      const s = I$(i);
      return i != null && s == null && (n = !1), s;
    });
    return n ? r : null;
  }
  if (MD(e))
    return e.clone();
  if (!OD(e)) {
    const n = new (Object.getPrototypeOf(e)).constructor();
    for (const r of Object.getOwnPropertyNames(e)) {
      const i = e[r], s = I$(i);
      if (i != null && s == null)
        return null;
      n[r] = s;
    }
    return n;
  }
  return null;
}
function MD(e) {
  return typeof e.clone == "function";
}
function CD(e) {
  return typeof e.map == "function" && typeof e.forEach == "function";
}
function OD(e) {
  return typeof e.notifyChange == "function" && typeof e.watch == "function";
}
function kD(e) {
  if (pJ(e) || hJ(e) || fJ(e) || mJ(e) || yJ(e) || gJ(e) || vJ(e) || bJ(e) || wJ(e))
    return dJ(e);
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof ArrayBuffer)
    return e.slice(0, e.byteLength);
  if (e instanceof Map) {
    const t = /* @__PURE__ */ new Map();
    return e.forEach((n, r) => {
      t.set(r, q(n));
    }), t;
  }
  if (e instanceof Set) {
    const t = /* @__PURE__ */ new Set();
    return e.forEach((n) => {
      t.add(q(n));
    }), t;
  }
  return null;
}
function j_(e, t) {
  return e === t || typeof e == "number" && isNaN(e) && typeof t == "number" && isNaN(t) || typeof (e || {}).getTime == "function" && typeof (t || {}).getTime == "function" && e.getTime() === t.getTime() || !1;
}
function AD(e, t, n = !1) {
  return RD(e, t, n);
}
function jf(e, t) {
  if (t != null)
    return t[e] || PD(e.split("."), !1, t);
}
function ss(e, t, n) {
  const r = e.split("."), i = r.pop(), s = PD(r, !0, n);
  s && i && (s[i] = t);
}
function PD(e, t, n) {
  let r = n;
  for (const i of e) {
    if (r == null)
      return;
    if (!(i in r)) {
      if (!t)
        return;
      r[i] = {};
    }
    r = r[i];
  }
  return r;
}
function RD(e, t, n) {
  return t ? Object.keys(t).reduce(function(r, i) {
    let s = r[i], o = t[i];
    return s === o ? r : s === void 0 ? (r[i] = q(o), r) : (Array.isArray(o) || Array.isArray(r) ? (s = s ? Array.isArray(s) ? r[i] = s.concat() : r[i] = [s] : r[i] = [], o && (Array.isArray(o) || (o = [o]), n ? o.forEach((a) => {
      s.indexOf(a) === -1 && s.push(a);
    }) : r[i] = o.concat())) : o && typeof o == "object" ? r[i] = RD(s, o, n) : r.hasOwnProperty(i) && !t.hasOwnProperty(i) || (r[i] = o), r);
  }, e || {}) : e;
}
var bA;
const Pt = { apiKey: void 0, applicationUrl: (bA = globalThis.location) == null ? void 0 : bA.href, assetsPath: "", fontsUrl: "https://doc.geoscene.cn/resources/fonts", geometryServiceUrl: "https://www.geosceneonline.cn/server/rest/services/Utilities/Geometry/GeometryServer", geoRSSServiceUrl: "https://www.geosceneonline.cn/geoscene/sharing/rss", kmlServiceUrl: "https://www.geosceneonline.cn/geoscene/sharing/kml", portalUrl: "https://www.geosceneonline.cn/geoscene", routeServiceUrl: "undefined", workers: { loaderConfig: { has: {}, paths: {}, map: {}, packages: [] } }, request: { httpsDomains: ["arcgis.com", "geosceneonline.cn", "arcgisonline.com", "esrikr.com", "premiumservices.blackbridge.com", "esripremium.accuweather.com", "gbm.digitalglobe.com", "firstlook.digitalglobe.com", "msi.digitalglobe.com"], interceptors: [], maxUrlLength: 2e3, proxyRules: [], proxyUrl: null, timeout: 6e4, trustedServers: [], useIdentity: !0 }, log: { interceptors: [], level: null } };
if (globalThis.geosceneConfig && (AD(Pt, globalThis.geosceneConfig, !0), delete Pt.has), !Pt.assetsPath) {
  const e = "4.23.7";
  Pt.assetsPath = `https://js.geoscene.cn/${e.slice(0, -2)}/@geoscene/core/assets`;
}
Pt.baseUrl && console.warn("[geoscene.config]", "baseUrl has been replaced by assetsPath"), Object.defineProperty(Pt, "baseUrl", { set() {
  console.warn("[geoscene.config]", "baseUrl has been replaced by assetsPath");
} }), Pt.request.corsEnabledServers = [], Pt.request.corsEnabledServers.push = function() {
  return console.warn("[geoscene.config]", "request.corsEnabledServers is not supported and will be removed in a future release. See https://doc.geoscene.cn/javascript/latest/"), 0;
};
const _J = /\{([^\}]+)\}/g;
function wA(e) {
  return e ?? "";
}
function Ta(e, t) {
  return e.replace(_J, typeof t == "object" ? (n, r) => wA(jf(r, t)) : (n, r) => wA(t(r)));
}
function LD(e, t) {
  return e.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, (n) => t && t.indexOf(n) !== -1 ? n : `\\${n}`);
}
function UC(e) {
  let t = 0;
  for (let n = 0; n < e.length; n++)
    t = (t << 5) - t + e.charCodeAt(n), t |= 0;
  return t;
}
function K3e(e) {
  return new DOMParser().parseFromString(e || "", "text/html").body.innerText || "";
}
const _A = { info: 0, warn: 1, error: 2, none: 3 };
let we = class Ir {
  constructor(t) {
    this.level = null, this._module = "", this._parent = null, this.writer = null, this._loggedMessages = { error: /* @__PURE__ */ new Map(), warn: /* @__PURE__ */ new Map(), info: /* @__PURE__ */ new Map() }, t.level != null && (this.level = t.level), t.writer != null && (this.writer = t.writer), this._module = t.module, Ir._loggers[this.module] = this;
    const n = this.module.lastIndexOf(".");
    n !== -1 && (this._parent = Ir.getLogger(this.module.slice(0, n)));
  }
  get module() {
    return this._module;
  }
  get parent() {
    return this._parent;
  }
  error(...t) {
    this._log("error", "always", ...t);
  }
  warn(...t) {
    this._log("warn", "always", ...t);
  }
  info(...t) {
    this._log("info", "always", ...t);
  }
  errorOnce(...t) {
    this._log("error", "once", ...t);
  }
  warnOnce(...t) {
    this._log("warn", "once", ...t);
  }
  infoOnce(...t) {
    this._log("info", "once", ...t);
  }
  errorOncePerTick(...t) {
    this._log("error", "oncePerTick", ...t);
  }
  warnOncePerTick(...t) {
    this._log("warn", "oncePerTick", ...t);
  }
  infoOncePerTick(...t) {
    this._log("info", "oncePerTick", ...t);
  }
  get test() {
    const t = this;
    return { loggedMessages: t._loggedMessages, clearLoggedWarnings: () => t._loggedMessages.warn.clear() };
  }
  static get testSingleton() {
    return { resetLoggers(t = {}) {
      const n = Ir._loggers;
      return Ir._loggers = t, n;
    }, set throttlingDisabled(t) {
      Ir._throttlingDisabled = t;
    } };
  }
  static getLogger(t) {
    let n = Ir._loggers[t];
    return n || (n = new Ir({ module: t })), n;
  }
  _log(t, n, ...r) {
    if (this._matchLevel(t)) {
      if (n !== "always" && !Ir._throttlingDisabled) {
        const i = this._argsToKey(r), s = this._loggedMessages[t].get(i);
        if (n === "once" && s != null || n === "oncePerTick" && s && s >= Ir._tickCounter)
          return;
        this._loggedMessages[t].set(i, Ir._tickCounter), Ir._scheduleTickCounterIncrement();
      }
      for (const i of Pt.log.interceptors)
        if (i(t, this.module, ...r))
          return;
      this._inheritedWriter()(t, this.module, ...r);
    }
  }
  _parentWithMember(t, n) {
    let r = this;
    for (; O(r); ) {
      const i = r[t];
      if (O(i))
        return i;
      r = r.parent;
    }
    return n;
  }
  _inheritedWriter() {
    return this._parentWithMember("writer", this._consoleWriter);
  }
  _consoleWriter(t, n, ...r) {
    console[t](`[${n}]`, ...r);
  }
  _matchLevel(t) {
    const n = Pt.log.level ? Pt.log.level : "warn";
    return _A[this._parentWithMember("level", n)] <= _A[t];
  }
  _argsToKey(...t) {
    return UC(JSON.stringify(t, (r, i) => typeof i != "object" || Array.isArray(i) ? i : "[Object]"));
  }
  static _scheduleTickCounterIncrement() {
    Ir._tickCounterScheduled || (Ir._tickCounterScheduled = !0, Promise.resolve().then(() => {
      Ir._tickCounter++, Ir._tickCounterScheduled = !1;
    }));
  }
};
we._loggers = {}, we._tickCounter = 0, we._tickCounterScheduled = !1, we._throttlingDisabled = !1;
function V_(e) {
  return Vf(() => e.forEach((t) => O(t) && t.remove()));
}
function Vf(e) {
  return { remove: () => {
    e && (e(), e = void 0);
  } };
}
function Xr(e) {
  return e ? e.__accessor__ ? e.__accessor__ : e.propertyInvalidated ? e : null : null;
}
function SJ(e, t) {
  return e != null && e.metadatas && e.metadatas[t] != null;
}
function bb(e, t, n) {
  return n ? e1(e, t, { policy: n, path: "" }) : e1(e, t, null);
}
function e1(e, t, n) {
  return t ? Object.keys(t).reduce(function(r, i) {
    let s = null, o = "merge";
    if (n && (s = n.path ? `${n.path}.${i}` : i, o = n.policy(s)), o === "replace")
      return r[i] = t[i], r;
    if (r[i] === void 0)
      return r[i] = q(t[i]), r;
    let a = r[i], l = t[i];
    if (a === l)
      return r;
    if (Array.isArray(l) || Array.isArray(r))
      a = a ? Array.isArray(a) ? r[i] = a.concat() : r[i] = [a] : r[i] = [], l && (Array.isArray(l) || (l = [l]), l.forEach((c) => {
        a.indexOf(c) === -1 && a.push(c);
      }));
    else if (l && typeof l == "object")
      if (n) {
        const c = n.path;
        n.path = s, r[i] = e1(a, l, n), n.path = c;
      } else
        r[i] = e1(a, l, null);
    else
      r.hasOwnProperty(i) && !t.hasOwnProperty(i) || (r[i] = l);
    return r;
  }, e || {}) : e;
}
function FD(e) {
  return Array.isArray(e) ? e : e.split(".");
}
function SA(e) {
  return e.indexOf(",") > -1 ? e.split(",").map((t) => t.trim()) : [e.trim()];
}
function xJ(e) {
  if (Array.isArray(e)) {
    const t = [];
    for (const n of e)
      t.push(...SA(n));
    return t;
  }
  return SA(e);
}
function ND(e, t, n, r) {
  const i = xJ(t);
  if (i.length !== 1) {
    const s = i.map((o) => r(e, o, n));
    return V_(s);
  }
  return r(e, i[0], n);
}
function DD(e) {
  let t = !1;
  return () => {
    t || (t = !0, e());
  };
}
function jD(e, t) {
  const n = e[e.length - 1] === "?" ? e.slice(0, -1) : e;
  if (t.getItemAt != null || Array.isArray(t)) {
    const i = parseInt(n, 10);
    if (!isNaN(i))
      return Array.isArray(t) ? t[i] : t.getItemAt(i);
  }
  const r = Xr(t);
  return SJ(r, n) ? r.get(n) : t[n];
}
function VD(e, t, n) {
  if (e == null)
    return e;
  const r = jD(t[n], e);
  return !r && n < t.length - 1 ? void 0 : n === t.length - 1 ? r : VD(r, t, n + 1);
}
function h0(e, t, n = 0) {
  return typeof t == "string" && t.indexOf(".") === -1 ? jD(t, e) : VD(e, FD(t), n);
}
function t1(e, t) {
  return h0(e, t);
}
function xA(e, t) {
  return h0(t, e) !== void 0;
}
var ha;
(function(e) {
  e[e.INITIALIZING = 0] = "INITIALIZING", e[e.CONSTRUCTING = 1] = "CONSTRUCTING", e[e.CONSTRUCTED = 2] = "CONSTRUCTED";
})(ha || (ha = {}));
let $A = class {
  constructor(t) {
    this.autoDestroy = !1, this.properties = t;
  }
};
function f0(e) {
  let t = e.constructor.__accessorMetadata__;
  const n = Object.prototype.hasOwnProperty.call(e.constructor, "__accessorMetadata__");
  if (t) {
    if (!n) {
      const r = Object.create(t.properties), i = t.autoDestroy;
      for (const s in r)
        r[s] = q(r[s]);
      t = new $A(r), t.autoDestroy = i, Object.defineProperty(e.constructor, "__accessorMetadata__", { value: t, enumerable: !1, configurable: !0, writable: !0 });
    }
  } else
    t = new $A({}), Object.defineProperty(e.constructor, "__accessorMetadata__", { value: t, enumerable: !1, configurable: !0, writable: !0 });
  return e.constructor.__accessorMetadata__;
}
function $J(e) {
  return f0(e).properties;
}
function z_(e, t) {
  const n = $J(e);
  let r = n[t];
  return r || (r = n[t] = {}), r;
}
function TJ(e, t) {
  return bb(e, t, IJ);
}
const EJ = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/;
function IJ(e) {
  return EJ.test(e) ? "replace" : "merge";
}
var ot;
(function(e) {
  e[e.DEFAULTS = 0] = "DEFAULTS", e[e.COMPUTED = 1] = "COMPUTED", e[e.SERVICE = 2] = "SERVICE", e[e.PORTAL_ITEM = 3] = "PORTAL_ITEM", e[e.WEB_SCENE = 4] = "WEB_SCENE", e[e.WEB_MAP = 5] = "WEB_MAP", e[e.USER = 6] = "USER";
})(ot || (ot = {}));
const M$ = ot.USER + 1;
function Vu(e) {
  switch (e) {
    case "defaults":
      return ot.DEFAULTS;
    case "service":
      return ot.SERVICE;
    case "portal-item":
      return ot.PORTAL_ITEM;
    case "web-scene":
      return ot.WEB_SCENE;
    case "web-map":
      return ot.WEB_MAP;
    case "user":
      return ot.USER;
  }
}
function n1(e) {
  switch (e) {
    case ot.DEFAULTS:
      return "defaults";
    case ot.SERVICE:
      return "service";
    case ot.PORTAL_ITEM:
      return "portal-item";
    case ot.WEB_SCENE:
      return "web-scene";
    case ot.WEB_MAP:
      return "web-map";
    case ot.USER:
      return "user";
  }
  return void 0;
}
function MJ(e) {
  return n1(e);
}
var At;
(function(e) {
  e[e.Dirty = 1] = "Dirty", e[e.Overriden = 2] = "Overriden", e[e.Computing = 4] = "Computing", e[e.NonNullable = 8] = "NonNullable", e[e.HasDefaultValue = 16] = "HasDefaultValue", e[e.DepTrackingInitialized = 32] = "DepTrackingInitialized", e[e.AutoTracked = 64] = "AutoTracked", e[e.ExplicitlyTracking = 128] = "ExplicitlyTracking";
})(At || (At = {}));
let r1, Zm = [];
const CJ = we.getLogger("geoscene.core.Accessor");
function Ye(e) {
  r1 !== void 0 && r1.onObservableAccessed(e);
}
let wb = !1, _b = !1;
function Ml(e, t, n) {
  if (wb)
    return qC(e, t, n);
  zD(e);
  const r = t.call(n);
  return BD(), r;
}
function OJ(e, t) {
  return Ml(void 0, e, t);
}
function qC(e, t, n) {
  const r = wb;
  wb = !0, zD(e);
  let i = null;
  try {
    i = t.call(n);
  } catch (s) {
    _b && CJ.error(s);
  }
  return BD(), wb = r, i;
}
function zD(e) {
  r1 = e, Zm.push(e);
}
function BD() {
  const e = Zm.pop();
  r1 = Zm.length > 0 ? Zm[Zm.length - 1] : void 0, e !== void 0 && e.onTrackingEnd();
}
function UD(e, t) {
  if (t.flags & At.DepTrackingInitialized)
    return;
  const n = _b;
  _b = !1, t.flags & At.AutoTracked ? qC(t, t.metadata.get, e) : qD(e, t), _b = n;
}
const kJ = [];
function qD(e, t) {
  t.flags & At.ExplicitlyTracking || (t.flags |= At.ExplicitlyTracking, qC(t, () => {
    const n = t.metadata.dependsOn || kJ;
    for (const r of n)
      if (typeof r == "string" && r.indexOf(".") === -1)
        TA(e, r, !1);
      else {
        const i = FD(r);
        for (let s = 0, o = e; s < i.length && o != null && typeof o == "object"; ++s)
          o = TA(o, i[s], s !== i.length - 1);
      }
  }), t.flags &= ~At.ExplicitlyTracking);
}
function TA(e, t, n) {
  const r = t[t.length - 1] === "?" ? t.slice(0, -1) : t;
  if (e.getItemAt != null || Array.isArray(e)) {
    const o = parseInt(r, 10);
    if (!isNaN(o))
      return Array.isArray(e) ? e[o] : e.getItemAt(o);
  }
  const i = Xr(e), s = i == null ? void 0 : i.properties.get(r);
  return s && (Ye(s), UD(e, s)), n ? e[r] : void 0;
}
let GD = class {
  constructor(t, n) {
    this._observers = t, this._observer = n;
  }
  remove() {
    cJ(this._observers, this._observer);
  }
}, EA = class {
  constructor(t, n, r) {
    this.properties = t, this.propertyName = n, this.metadata = r, this._observers = null, this._accessed = null, this._handles = null, this.flags = At.Dirty | (r.nonNullable ? At.NonNullable : 0) | (r.hasOwnProperty("value") ? At.HasDefaultValue : 0) | (r.get === void 0 ? At.DepTrackingInitialized : 0) | (r.dependsOn === void 0 ? At.AutoTracked : 0);
  }
  destroy() {
    this._accessed = null, this._observers = null, this._clearObservationHandles();
  }
  getComputed() {
    Ye(this);
    const t = this.properties.store, n = this.propertyName, r = this.flags, i = t.get(n);
    if (r & At.Computing || ~r & At.Dirty && t.has(n))
      return i;
    this.flags |= At.Computing;
    const s = this.properties.host;
    let o;
    r & At.AutoTracked ? o = Ml(this, this.metadata.get, s) : (qD(s, this), o = this.metadata.get.call(s)), t.set(n, o, ot.COMPUTED);
    const a = t.get(n);
    return a === i ? this.flags &= ~At.Dirty : OJ(this.commit, this), this.flags &= ~At.Computing, a;
  }
  onObservableAccessed(t) {
    t !== this && (this._accessed === null && (this._accessed = []), this._accessed.includes(t) || this._accessed.push(t));
  }
  onTrackingEnd() {
    this._clearObservationHandles(), this.flags |= At.DepTrackingInitialized;
    const t = this._accessed;
    if (t === null)
      return;
    let n = this._handles;
    n === null && (n = this._handles = []);
    for (let r = 0; r < t.length; ++r)
      n.push(t[r].observe(this));
    t.length = 0;
  }
  observe(t) {
    return this._observers === null && (this._observers = []), this._observers.includes(t) || this._observers.push(t), new GD(this._observers, t);
  }
  notifyChange() {
    this.onInvalidated(), this.onCommitted();
  }
  invalidate() {
    this.onInvalidated();
  }
  onInvalidated() {
    ~this.flags & At.Overriden && (this.flags |= At.Dirty);
    const t = this._observers;
    if (t !== null)
      for (let n = 0; n < t.length; ++n)
        t[n].onInvalidated();
  }
  commit() {
    this.flags &= ~At.Dirty, this.onCommitted();
  }
  onCommitted() {
    if (this._observers === null)
      return;
    const t = this._observers.slice();
    for (let n = 0; n < t.length; ++n)
      t[n].onCommitted();
  }
  _clearObservationHandles() {
    const t = this._handles;
    if (t !== null) {
      for (let n = 0; n < t.length; ++n)
        t[n].remove();
      t.length = 0;
    }
  }
}, AJ = class WD {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(t) {
    const n = new WD();
    return this._values.forEach((r, i) => {
      t && t.has(i) || n.set(i, q(r));
    }), n;
  }
  get(t) {
    return this._values.get(t);
  }
  originOf() {
    return ot.USER;
  }
  keys() {
    return [...this._values.keys()];
  }
  set(t, n) {
    this._values.set(t, n);
  }
  delete(t) {
    this._values.delete(t);
  }
  has(t) {
    return this._values.has(t);
  }
  forEach(t) {
    this._values.forEach(t);
  }
};
function iv(e, t, n) {
  return e !== void 0;
}
function IA(e, t, n, r) {
  return e !== void 0 && (!(n == null && e.flags & At.NonNullable) || (r.lifecycle, ha.INITIALIZING, !1));
}
function PJ(e) {
  return e && typeof e.destroy == "function";
}
we.getLogger("geoscene.core.accessorSupport.Properties");
let RJ = class {
  constructor(t) {
    this.host = t, this.properties = /* @__PURE__ */ new Map(), this.ctorArgs = null, this.destroyed = !1, this.lifecycle = ha.INITIALIZING, this.store = new AJ(), this._origin = ot.USER;
    const n = this.host.constructor.__accessorMetadata__, r = n.properties;
    for (const i in r) {
      const s = new EA(this, i, r[i]);
      this.properties.set(i, s);
    }
    this.metadatas = r, this._autoDestroy = n.autoDestroy;
  }
  initialize() {
    this.lifecycle = ha.CONSTRUCTING;
  }
  constructed() {
    this.lifecycle = ha.CONSTRUCTED;
  }
  destroy() {
    if (this.destroyed = !0, this._autoDestroy)
      for (const [t, n] of this.properties) {
        const r = this.internalGet(t);
        r && PJ(r) && (r.destroy(), ~n.flags & At.NonNullable && this._internalSet(n, null)), n.destroy();
      }
    else
      for (const [t, n] of this.properties)
        n.destroy();
  }
  get initialized() {
    return this.lifecycle !== ha.INITIALIZING;
  }
  get(t) {
    const n = this.properties.get(t);
    if (n.metadata.get)
      return n.getComputed();
    Ye(n);
    const r = this.store;
    return r.has(t) ? r.get(t) : n.metadata.value;
  }
  originOf(t) {
    const n = this.store.originOf(t);
    if (n === void 0) {
      const r = this.properties.get(t);
      if (r !== void 0 && r.flags & At.HasDefaultValue)
        return "defaults";
    }
    return n1(n);
  }
  has(t) {
    return !!this.properties.has(t) && this.store.has(t);
  }
  keys() {
    return [...this.properties.keys()];
  }
  internalGet(t) {
    const n = this.properties.get(t);
    if (iv(n))
      return this.store.has(t) ? this.store.get(t) : n.metadata.value;
  }
  internalSet(t, n) {
    const r = this.properties.get(t);
    iv(r) && this._internalSet(r, n);
  }
  getDependsInfo(t, n, r) {
    const i = this.properties.get(n);
    if (!iv(i))
      return "";
    const s = /* @__PURE__ */ new Set(), o = Ml({ onObservableAccessed: (l) => s.add(l), onTrackingEnd: () => {
    } }, () => {
      var l;
      return (l = i.metadata.get) == null ? void 0 : l.call(t);
    });
    let a = `${r}${t.declaredClass.split(".").pop()}.${n}: ${o}
`;
    if (s.size === 0)
      return a;
    r += "  ";
    for (const l of s) {
      if (!(l instanceof EA))
        continue;
      const c = l.properties.host, p = l.propertyName, f = Xr(c);
      a += f ? f.getDependsInfo(c, p, r) : `${r}${p}: undefined
`;
    }
    return a;
  }
  setAtOrigin(t, n, r) {
    const i = this.properties.get(t);
    if (iv(i))
      return this._setAtOrigin(i, n, r);
  }
  isOverridden(t) {
    const n = this.properties.get(t);
    return n !== void 0 && !!(n.flags & At.Overriden);
  }
  clearOverride(t) {
    const n = this.properties.get(t);
    n !== void 0 && n.flags & At.Overriden && (n.flags &= ~At.Overriden, n.notifyChange());
  }
  override(t, n) {
    const r = this.properties.get(t);
    if (!IA(r, t, n, this))
      return;
    const i = r.metadata.cast;
    if (i) {
      const s = this._cast(i, n), { valid: o, value: a } = s;
      if (v2.release(s), !o)
        return;
      n = a;
    }
    r.flags |= At.Overriden, this._internalSet(r, n);
  }
  set(t, n) {
    const r = this.properties.get(t);
    if (!IA(r, t, n, this))
      return;
    const i = r.metadata.cast;
    if (i) {
      const o = this._cast(i, n), { valid: a, value: l } = o;
      if (v2.release(o), !a)
        return;
      n = l;
    }
    const s = r.metadata.set;
    s ? s.call(this.host, n) : this._internalSet(r, n);
  }
  setDefaultOrigin(t) {
    this._origin = Vu(t);
  }
  getDefaultOrigin() {
    return n1(this._origin);
  }
  notifyChange(t) {
    const n = this.properties.get(t);
    n !== void 0 && n.notifyChange();
  }
  invalidate(t) {
    const n = this.properties.get(t);
    n !== void 0 && n.invalidate();
  }
  commit(t) {
    const n = this.properties.get(t);
    n !== void 0 && n.commit();
  }
  _internalSet(t, n) {
    const r = this.lifecycle !== ha.INITIALIZING ? this._origin : ot.DEFAULTS;
    this._setAtOrigin(t, n, r);
  }
  _setAtOrigin(t, n, r) {
    const i = this.store, s = t.propertyName;
    i.has(s, r) && j_(n, i.get(s)) && ~t.flags & At.Overriden && r === i.originOf(s) || (t.invalidate(), i.set(s, n, r), t.commit(), UD(this.host, t));
  }
  _cast(t, n) {
    const r = v2.acquire();
    return r.valid = !0, r.value = n, t && (r.value = t.call(this.host, n, r)), r;
  }
}, LJ = class {
  constructor() {
    this.value = null, this.valid = !0;
  }
  acquire() {
    this.valid = !0;
  }
  release() {
    this.value = null;
  }
};
const v2 = new fc(LJ);
function FJ(e, t) {
  return e.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g, function(n, r) {
    if (r === "")
      return "$";
    const i = jf(r, t), s = i ?? "";
    if (s === void 0)
      throw new Error(`could not find key "${r}" in template`);
    return s.toString();
  });
}
let HD = class JD {
  constructor(t, n, r) {
    this.name = t, this.details = r, this.message = void 0, this instanceof JD && (this.message = n && FJ(n, r) || "");
  }
  toString() {
    return "[" + this.name + "]: " + this.message;
  }
}, D = class Sb extends HD {
  constructor(t, n, r) {
    if (super(t, n, r), !(this instanceof Sb))
      return new Sb(t, n, r);
  }
  toJSON() {
    if (this.details != null)
      try {
        return { name: this.name, message: this.message, details: JSON.parse(JSON.stringify(this.details, (t, n) => {
          if (n && typeof n == "object" && typeof n.toJSON == "function")
            return n;
          try {
            return q(n);
          } catch {
            return "[object]";
          }
        })) };
      } catch (t) {
        throw we.getLogger("geoscene.core.Error").error(t), t;
      }
    return { name: this.name, message: this.message, details: this.details };
  }
  static fromJSON(t) {
    return new Sb(t.name, t.message, t.details);
  }
};
D.prototype.type = "error";
function i1(e, t, n) {
  if (e && t)
    if (typeof t == "object")
      for (const r of Object.getOwnPropertyNames(t))
        i1(e, r, t[r]);
    else {
      if (t.indexOf(".") !== -1) {
        const i = t.split("."), s = i.splice(i.length - 1, 1)[0];
        return void i1(t1(e, i), s, n);
      }
      const r = e.__accessor__;
      r != null && NJ(t, r), e[t] = n;
    }
}
function NJ(e, t) {
  if (K("geoscene-unknown-property-errors") && !DJ(e, t))
    throw new D("set:unknown-property", jJ(e, t));
}
function DJ(e, t) {
  return t.metadatas[e] != null;
}
function jJ(e, t) {
  return "setting unknown property '" + e + "' on instance of " + t.host.declaredClass;
}
we.getLogger("geoscene.core.accessorSupport.set");
let VJ = class extends fc {
  constructor() {
    super(...arguments), this._set = /* @__PURE__ */ new Set();
  }
  destroy() {
    super.destroy(), this._set = aJ(this._set);
  }
  acquire(...t) {
    const n = super.acquire(...t);
    return this._set.delete(n), n;
  }
  release(t) {
    t && !this._set.has(t) && (super.release(t), this._set.add(t));
  }
  _dispose(t) {
    this._set.delete(t), super._dispose(t);
  }
};
const sv = [];
function s1(e) {
  sv.push(e), sv.length === 1 && queueMicrotask(() => {
    const t = sv.slice();
    sv.length = 0;
    for (const n of t)
      n();
  });
}
const zJ = 29;
let Hy = class {
  constructor(t, n = zJ) {
    this.name = t, this._counter = 0, this._items = new Array(n);
  }
  record(t) {
    this._items[++this._counter % this._items.length] = t;
  }
  get median() {
    return this._items.slice().sort((t, n) => t - n)[Math.floor(this._items.length / 2)];
  }
  get average() {
    return this._items.reduce((t, n) => t + n, 0) / this._items.length;
  }
  get last() {
    return this._items[this._counter % this._items.length];
  }
};
var C$;
(function(e) {
  const t = (s, o, a, l) => {
    let c = o, p = o;
    const f = a >>> 1, m = s[c - 1];
    for (; p <= f; ) {
      p = c << 1, p < a && l(s[p - 1], s[p]) < 0 && ++p;
      const y = s[p - 1];
      if (l(y, m) <= 0)
        break;
      s[c - 1] = y, c = p;
    }
    s[c - 1] = m;
  }, n = (s, o) => s < o ? -1 : s > o ? 1 : 0;
  function r(s, o, a, l) {
    o === void 0 && (o = 0), a === void 0 && (a = s.length), l === void 0 && (l = n);
    for (let p = a >>> 1; p > o; p--)
      t(s, p, a, l);
    const c = o + 1;
    for (let p = a - 1; p > o; p--) {
      const f = s[o];
      s[o] = s[p], s[p] = f, t(s, c, p, l);
    }
  }
  function* i(s, o, a, l) {
    o === void 0 && (o = 0), a === void 0 && (a = s.length), l === void 0 && (l = n);
    for (let p = a >>> 1; p > o; p--)
      t(s, p, a, l), yield;
    const c = o + 1;
    for (let p = a - 1; p > o; p--) {
      const f = s[o];
      s[o] = s[p], s[p] = f, t(s, c, p, l), yield;
    }
  }
  e.sort = r, e.iterableSort = i;
})(C$ || (C$ = {}));
const MA = C$, BJ = 1.5, UJ = 1.1;
let zd = class {
  constructor(t) {
    this.data = [], this._length = 0, this._allocator = void 0, this._deallocator = () => null, this._shrink = () => {
    }, this._hint = new xD(), t && (t.initialSize && (this.data = new Array(t.initialSize)), t.allocator && (this._allocator = t.allocator), t.deallocator !== void 0 && (this._deallocator = t.deallocator), t.shrink && (this._shrink = () => CA(this)));
  }
  toArray() {
    return this.data.slice(0, this.length);
  }
  filter(t) {
    const n = new Array();
    for (let r = 0; r < this._length; r++) {
      const i = this.data[r];
      t(i) && n.push(i);
    }
    return n;
  }
  getItemAt(t) {
    if (!(t < 0 || t >= this._length))
      return this.data[t];
  }
  get length() {
    return this._length;
  }
  set length(t) {
    if (t > this._length) {
      if (this._allocator) {
        for (; this._length < t; )
          this.data[this._length++] = this._allocator(this.data[this._length]);
        return;
      }
      this._length = t;
    } else {
      if (this._deallocator)
        for (let n = t; n < this._length; ++n)
          this.data[n] = this._deallocator(this.data[n]);
      this._length = t, this._shrink();
    }
  }
  clear() {
    this.length = 0;
  }
  prune() {
    this.clear(), this.data = [];
  }
  push(t) {
    this.data[this._length++] = t;
  }
  pushArray(t, n = t.length) {
    for (let r = 0; r < n; r++)
      this.data[this._length++] = t[r];
  }
  fill(t, n) {
    for (let r = 0; r < n; r++)
      this.data[this._length++] = t;
  }
  pushNew() {
    this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
    const t = this.data[this._length];
    return ++this._length, t;
  }
  unshift(t) {
    this.data.unshift(t), this._length++, CA(this);
  }
  pop() {
    if (this.length === 0)
      return;
    const t = this.data[this.length - 1];
    return this.length = this.length - 1, this._shrink(), t;
  }
  remove(t) {
    const n = TD(this.data, t, this.length, this._hint);
    if (n !== -1)
      return this.data.splice(n, 1), this.length = this.length - 1, t;
  }
  removeUnordered(t) {
    const n = ED(this.data, t, this.length, this._hint);
    return n !== void 0 && (this.length = this.length - 1), this._shrink(), n;
  }
  removeUnorderedIndex(t) {
    if (!(t >= this.length || t < 0))
      return this.swapElements(t, this.length - 1), this.pop();
  }
  removeUnorderedMany(t, n = t.length, r) {
    this.length = uJ(this.data, t, this.length, n, this._hint, r), this._shrink();
  }
  front() {
    if (this.length !== 0)
      return this.data[0];
  }
  back() {
    if (this.length !== 0)
      return this.data[this.length - 1];
  }
  swapElements(t, n) {
    t >= this.length || n >= this.length || t === n || ([this.data[t], this.data[n]] = [this.data[n], this.data[t]]);
  }
  sort(t) {
    MA.sort(this.data, 0, this.length, t);
  }
  iterableSort(t) {
    return MA.iterableSort(this.data, 0, this.length, t);
  }
  some(t, n) {
    for (let r = 0; r < this.length; ++r)
      if (t.call(n, this.data[r], r, this.data))
        return !0;
    return !1;
  }
  filterInPlace(t, n) {
    let r = 0;
    for (let i = 0; i < this._length; ++i) {
      const s = this.data[i];
      t.call(n, s, i, this.data) && (this.data[i] = this.data[r], this.data[r] = s, r++);
    }
    if (this._deallocator)
      for (let i = r; i < this._length; i++)
        this.data[i] = this._deallocator(this.data[i]);
    return this._length = r, this._shrink(), this;
  }
  forAll(t, n) {
    const r = this.length, i = this.data;
    for (let s = 0; s < r; ++s)
      t.call(n, i[s], s, i);
  }
  forEach(t, n) {
    for (let r = 0; r < this.length; ++r)
      t.call(n, this.data[r], r, this.data);
  }
  map(t, n) {
    const r = new Array(this.length);
    for (let i = 0; i < this.length; ++i)
      r[i] = t.call(n, this.data[i], i, this.data);
    return r;
  }
  reduce(t, n) {
    let r = n;
    for (let i = 0; i < this.length; ++i)
      r = t(r, this.data[i], i, this.data);
    return r;
  }
  has(t) {
    const n = this.length, r = this.data;
    for (let i = 0; i < n; ++i)
      if (r[i] === t)
        return !0;
    return !1;
  }
};
function CA(e) {
  e.data.length > BJ * e.length && (e.data.length = Math.floor(e.length * UJ));
}
function qJ(e) {
  return { setTimeout: (t, n) => {
    const r = e.setTimeout(t, n);
    return { remove: () => e.clearTimeout(r) };
  } };
}
const m0 = qJ(globalThis);
function B_(e) {
  return e && (typeof e.on == "function" || typeof e.addEventListener == "function");
}
function U_(e, t, n) {
  if (!B_(e))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("on" in e)
    return e.on(t, n);
  if (Array.isArray(t)) {
    const r = t.slice();
    for (const i of r)
      e.addEventListener(i, n);
    return { remove() {
      for (const i of r)
        e.removeEventListener(i, n);
    } };
  }
  return e.addEventListener(t, n), { remove() {
    e.removeEventListener(t, n);
  } };
}
function ZD(e, t, n) {
  if (!B_(e))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("once" in e)
    return e.once(t, n);
  const r = U_(e, t, (i) => {
    r.remove(), n.call(e, i);
  });
  return { remove() {
    r.remove();
  } };
}
const GJ = { Win: "Meta", Scroll: "ScrollLock", Spacebar: " ", Down: "ArrowDown", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Del: "Delete", Apps: "ContextMenu", Esc: "Escape", Multiply: "*", Add: "+", Subtract: "-", Decimal: ".", Divide: "/" };
function yd({ key: e }) {
  return GJ[e] || e;
}
function KD(e) {
  return Promise.all(e);
}
function GC(e) {
  return new Promise((t, n) => {
    try {
      e(t, n);
    } catch (r) {
      Promise.resolve().then(() => n(r));
    }
  });
}
function Cn(e = "Aborted") {
  return new D("AbortError", e);
}
function On(e, t = "Aborted") {
  if (Ea(e))
    throw Cn(t);
}
function q_(e) {
  return O(e) ? "aborted" in e ? e : e.signal : e;
}
function Ea(e) {
  const t = q_(e);
  return O(t) && t.aborted;
}
function y0(e) {
  if (Ws(e))
    throw e;
}
function O$(e) {
  if (!Ws(e))
    throw e;
}
function Ao(e, t) {
  const n = q_(e);
  if (!H(n)) {
    if (!n.aborted)
      return ZD(n, "abort", () => t());
    t();
  }
}
function G_(e, t) {
  const n = q_(e);
  if (!H(n))
    return On(n), ZD(n, "abort", () => t(Cn()));
}
function YD(e, t) {
  const n = q_(t);
  return H(n) ? e : new Promise((r, i) => {
    let s = Ao(t, () => i(Cn()));
    const o = () => s = Sp(s);
    e.then(o, o), e.then(r, i);
  });
}
function Ws(e) {
  return e && e.name === "AbortError";
}
function k$(e) {
  return e.catch((t) => {
    if (!Ws(t))
      throw t;
  });
}
function Cl() {
  let e = null;
  const t = new Promise((n, r) => {
    e = { promise: void 0, resolve: n, reject: r };
  });
  return e.promise = t, e;
}
function Ii(e) {
  if (!e)
    return;
  if (typeof e.forEach != "function") {
    const n = Object.keys(e);
    return Ii(n.map((r) => e[r])).then((r) => {
      const i = {};
      return n.forEach((s, o) => i[s] = r[o]), i;
    });
  }
  const t = e;
  return GC((n) => {
    const r = [];
    let i = t.length;
    i === 0 && n(r), t.forEach((s) => {
      const o = { promise: s || Promise.resolve(s) };
      r.push(o), o.promise.then((a) => {
        o.value = a;
      }).catch((a) => {
        o.error = a;
      }).then(() => {
        --i, i === 0 && n(r);
      });
    });
  });
}
function WJ(e) {
  return Ii(e).then((t) => t.filter((n) => !!n.value).map((n) => n.value));
}
function OA(e) {
  return Promise.reject(e);
}
function Dh(e) {
  return Promise.resolve(e);
}
function WC(e, t, n) {
  const r = new AbortController();
  return Ao(n, () => r.abort()), new Promise((i, s) => {
    let o = setTimeout(() => {
      o = 0, i(t);
    }, e);
    Ao(r, () => {
      o && (clearTimeout(o), s(Cn()));
    });
  });
}
function Fl(e) {
  return e && typeof e.then == "function";
}
function A$(e) {
  return Fl(e) ? e : Promise.resolve(e);
}
function QD(e, t = -1) {
  let n, r, i, s, o = null;
  const a = (...l) => {
    if (n) {
      r = l, s && s.reject(Cn()), s = Cl();
      const m = s.promise;
      if (o) {
        const y = o;
        o = null, y.abort();
      }
      return m;
    }
    if (i = s || Cl(), s = null, t > 0) {
      const m = new AbortController();
      n = A$(e(...l, m.signal));
      const y = n;
      WC(t).then(() => {
        n === y && (s ? m.abort() : o = m);
      });
    } else
      n = 1, n = A$(e(...l));
    const c = () => {
      const m = r;
      r = i = n = o = null, m != null && a(...m);
    }, p = n, f = i;
    return p.then(c, c), p.then(f.resolve, f.reject), f.promise;
  };
  return a;
}
function HJ() {
  let e, t;
  const n = new Promise((i, s) => {
    e = i, t = s;
  }), r = (i) => {
    e(i);
  };
  return r.resolve = (i) => e(i), r.reject = (i) => t(i), r.timeout = (i, s) => m0.setTimeout(() => r.reject(s), i), r.promise = n, r;
}
function XD(e, t) {
  let n, r = new AbortController();
  const i = e(r.signal);
  let s = { promise: i, finished: !1, abort: () => {
    r && (r.abort(), r = null);
  } };
  const o = () => {
    s && (s.finished = !0, s = null), O(n) && (n.remove(), n = null), r = null;
  };
  return i.then(o, o), n = Ao(t, () => {
    O(s) && s.abort();
  }), s;
}
function sAe(e) {
  return Promise.resolve().then(() => {
    On(e);
  });
}
function oAe(e) {
  return e;
}
let JJ = class {
  constructor(t) {
    this.phases = t, this.paused = !1, this.ticks = -1, this.removed = !1;
  }
}, ZJ = class {
  constructor(t) {
    this.callback = t, this.isActive = !0;
  }
  remove() {
    this.isActive = !1;
  }
}, P$ = 0;
const vm = { time: 0, deltaTime: 0, elapsedFrameTime: 0, frameDuration: 0 }, R$ = ["prepare", "preRender", "render", "postRender", "update", "finish"], L$ = [], Qd = new zd();
let KJ = class {
  constructor(t) {
    this._task = t;
  }
  remove() {
    this._task.removed = !0;
  }
  pause() {
    this._task.paused = !0;
  }
  resume() {
    this._task.paused = !1;
  }
};
const o1 = { frameTasks: Qd, willDispatch: !1, clearFrameTasks: YJ, dispatch: n8, executeFrameTasks: QJ };
function g0(e) {
  const t = new ZJ(e);
  return L$.push(t), o1.willDispatch || (o1.willDispatch = !0, s1(n8)), t;
}
function df(e) {
  const t = new JJ(e);
  return Qd.push(t), a1 == null && (P$ = performance.now(), a1 = requestAnimationFrame(e8)), new KJ(t);
}
let a1 = null;
function YJ(e = !1) {
  Qd.forAll((t) => {
    t.removed = !0;
  }), e && t8();
}
function e8() {
  const e = performance.now();
  a1 = null, a1 = Qd.length > 0 ? requestAnimationFrame(e8) : null, o1.executeFrameTasks(e);
}
function QJ(e) {
  const t = e - P$;
  P$ = e;
  const n = 1e3 / 60, r = Math.max(0, t - n);
  for (let i = 0; i < R$.length; i++) {
    const s = performance.now(), o = R$[i];
    Qd.forAll((a) => {
      var l;
      a.paused || a.removed || (i === 0 && a.ticks++, a.phases[o] && (vm.time = e, vm.deltaTime = a.ticks === 0 ? 0 : t, vm.elapsedFrameTime = performance.now() - e, vm.frameDuration = n - r, (l = a.phases[o]) == null || l.call(a, vm)));
    }), XJ[i].record(performance.now() - s);
  }
  t8(), eZ.record(performance.now() - e);
}
const ov = new zd();
function t8() {
  Qd.forAll((e) => {
    e.removed && ov.push(e);
  }), Qd.removeUnorderedMany(ov.data, ov.length), ov.clear();
}
function n8() {
  for (; L$.length; ) {
    const e = L$.shift();
    e.isActive && e.callback();
  }
  o1.willDispatch = !1;
}
function cAe(e = 1, t) {
  const n = HJ(), r = () => {
    Ea(t) ? n.reject(Cn()) : e === 0 ? n() : (--e, s1(() => r()));
  };
  return r(), n.promise;
}
const XJ = R$.map((e) => new Hy(e)), eZ = new Hy("total");
let tZ = 0;
function Jy() {
  return ++tZ;
}
let W_ = class {
  constructor(t) {
    this._notify = t, this._accessed = [], this._handles = [], this._invalidCount = 0;
  }
  destroy() {
    this._accessed.length = 0, this.clear();
  }
  onInvalidated() {
    this._invalidCount++;
  }
  onCommitted() {
    const t = this._invalidCount;
    if (t === 1)
      return this._invalidCount = 0, void this._notify();
    this._invalidCount = t > 0 ? t - 1 : 0;
  }
  onObservableAccessed(t) {
    this._accessed.includes(t) || this._accessed.push(t);
  }
  onTrackingEnd() {
    const t = this._handles, n = this._accessed;
    for (let r = 0; r < n.length; ++r)
      t.push(n[r].observe(this));
    n.length = 0;
  }
  clear() {
    const t = this._handles;
    for (let n = 0; n < t.length; ++n)
      t[n].remove();
    t.length = 0;
  }
}, Kh = !1;
const l1 = [];
function r8(e, t) {
  let n = new W_(s), r = null, i = !1;
  function s() {
    if (!n || i)
      return;
    if (Kh)
      return void o8(s);
    const a = r;
    n.clear(), Kh = !0, i = !0, r = Ml(n, e), i = !1, Kh = !1, t(r, a), a8();
  }
  function o() {
    n && (n.destroy(), n = null, r = null);
  }
  return i = !0, r = Ml(n, e), i = !1, { remove: o };
}
function i8(e, t) {
  let n = new W_(i), r = null;
  function i() {
    t(r, o);
  }
  function s() {
    n && (n.destroy(), n = null), r = null;
  }
  function o() {
    return n ? (n.clear(), r = Ml(n, e), r) : null;
  }
  return o(), { remove: s };
}
function s8(e) {
  let t = new W_(r), n = !1;
  function r() {
    t && !n && (Kh ? o8(r) : (t.clear(), Kh = !0, n = !0, Ml(t, e), n = !1, Kh = !1, a8()));
  }
  function i() {
    t && (t.destroy(), t = null);
  }
  return n = !0, Ml(t, e), n = !1, { remove: i };
}
function o8(e) {
  l1.includes(e) || l1.unshift(e);
}
function a8() {
  for (; l1.length; )
    l1.pop()();
}
var Zy;
(function(e) {
  e[e.Untracked = 0] = "Untracked", e[e.Tracked = 1] = "Tracked";
})(Zy || (Zy = {}));
let Eg = class {
  constructor() {
    this.uid = Jy(), this.removed = !1, this.type = null, this.oldValue = null, this.callback = null, this.getValue = null, this.target = null, this.path = null, this.equals = null;
  }
  static acquireUntracked(t, n, r, i, s) {
    return this.pool.acquire(Zy.Untracked, t, n, r, i, s, j_);
  }
  static acquireTracked(t, n, r, i) {
    return this.pool.acquire(Zy.Tracked, t, n, r, null, null, i);
  }
  notify(t, n) {
    this.type === Zy.Untracked ? this.callback.call(this.target, t, n, this.path, this.target) : this.callback.call(null, t, n);
  }
  acquire(t, n, r, i, s, o, a) {
    this.uid = Jy(), this.removed = !1, this.type = t, this.oldValue = n, this.callback = r, this.getValue = i, this.target = s, this.path = o, this.equals = a;
  }
  release() {
    this.target = this.path = this.oldValue = this.callback = this.getValue = null, this.uid = Jy(), this.removed = !0;
  }
};
Eg.pool = new VJ(Eg);
const xb = new Hr(), Ju = /* @__PURE__ */ new Set();
let u1;
function c1(e) {
  Ju.delete(e), Ju.add(e), u1 || (u1 = g0(iZ));
}
function nZ(e) {
  if (e.removed)
    return;
  const t = e.oldValue, n = e.getValue();
  e.equals(t, n) || (e.oldValue = n, e.notify(n, t));
}
function rZ(e) {
  for (const t of Ju.values())
    t.target === e && (t.removed = !0);
}
function iZ() {
  let e = 10;
  for (; u1 && e--; ) {
    u1 = null;
    const t = sZ(), n = xb.acquire();
    for (const r of t) {
      const i = r.uid;
      nZ(r), i === r.uid && r.removed && n.push(r);
    }
    for (const r of Ju)
      r.removed && (n.push(r), Ju.delete(r));
    for (const r of n)
      Eg.pool.release(r);
    xb.release(n), xb.release(t), oZ.forEach((r) => r());
  }
}
function sZ() {
  const e = xb.acquire();
  e.length = Ju.size;
  let t = 0;
  for (const n of Ju)
    e[t] = n, ++t;
  return Ju.clear(), e;
}
const oZ = /* @__PURE__ */ new Set();
function aZ(e, t, n) {
  let r = ND(e, t, n, (i, s, o) => {
    let a, l, c = i8(() => h0(i, s), (p, f) => {
      i.__accessor__.destroyed || a && a.uid !== l ? r.remove() : (a || (a = Eg.acquireUntracked(p, o, f, i, s), l = a.uid), c1(a));
    });
    return { remove: DD(() => {
      c.remove(), a && (a.uid !== l || a.removed || (a.removed = !0, c1(a)), a = null), r = c = null;
    }) };
  });
  return r;
}
function lZ(e, t, n) {
  const r = ND(e, t, n, (i, s, o) => {
    let a = !1;
    return r8(() => h0(i, s), (l, c) => {
      i.__accessor__.destroyed ? r.remove() : a || (a = !0, j_(c, l) || o.call(i, l, c, s, i), a = !1);
    });
  });
  return r;
}
function uZ(e, t, n, r = !1) {
  return !e.__accessor__ || e.__accessor__.destroyed ? { remove() {
  } } : r ? lZ(e, t, n) : aZ(e, t, n);
}
function cZ(e, t, n) {
  let r, i, s = i8(e, (o, a) => {
    r && r.uid !== i ? s.remove() : (r || (r = Eg.acquireTracked(o, t, a, n), i = r.uid), c1(r));
  });
  return { remove: DD(() => {
    s.remove(), r && (r.uid !== i || r.removed || (r.removed = !0, c1(r)), r = null), s = null;
  }) };
}
function dZ(e, t, n) {
  let r = !1;
  return r8(e, (i, s) => {
    r || (r = !0, n(s, i) || t(i, s), r = !1);
  });
}
function pZ(e, t, n = !1, r = j_) {
  return n ? dZ(e, t, r) : cZ(e, t, r);
}
function H_(e, t) {
  for (const [n, r] of e)
    if (t(r, n))
      return !0;
  return !1;
}
function hZ(e, t, n) {
  const r = e.get(t);
  if (r !== void 0)
    return r;
  const i = n();
  return e.set(t, i), i;
}
const Yh = we.getLogger("geoscene.core.Accessor");
function fZ(e) {
  return e == null ? e : new Date(e);
}
function mZ(e) {
  return e == null ? e : !!e;
}
function v0(e) {
  return e == null ? e : e.toString();
}
function ks(e) {
  return e == null ? e : (e = parseFloat(e), isNaN(e) ? 0 : e);
}
function HC(e) {
  return e == null ? e : Math.round(parseFloat(e));
}
function l8(e) {
  return e && e.constructor && e.constructor.__accessorMetadata__ !== void 0;
}
function d1(e, t) {
  return t != null && e && !(t instanceof e);
}
function u8(e) {
  return e && "isCollection" in e;
}
function kA(e) {
  return e && e.Type ? typeof e.Type == "function" ? e.Type : e.Type.base : null;
}
function yZ(e, t) {
  if (!t || !t.constructor || !u8(t.constructor))
    return F$(e, t) ? t : new e(t);
  const n = kA(e.prototype.itemType), r = kA(t.constructor.prototype.itemType);
  return n ? r ? n === r ? t : n.prototype.isPrototypeOf(r.prototype) ? new e(t) : (F$(e, t), t) : new e(t) : t;
}
function F$(e, t) {
  return !!l8(t) && (Yh.error("Accessor#set", "Assigning an instance of '" + (t.declaredClass || "unknown") + "' which is not a subclass of '" + J_(e) + "'"), !0);
}
function JC(e, t) {
  return t == null ? t : u8(e) ? yZ(e, t) : d1(e, t) ? F$(e, t) ? t : new e(t) : t;
}
function J_(e) {
  return e && e.prototype && e.prototype.declaredClass || "unknown";
}
const gZ = /* @__PURE__ */ new WeakMap();
function vZ(e) {
  switch (e) {
    case Number:
      return ks;
    case Vt:
      return HC;
    case Boolean:
      return mZ;
    case String:
      return v0;
    case Date:
      return fZ;
    default:
      return hZ(gZ, e, () => JC.bind(null, e));
  }
}
function kn(e, t) {
  const n = vZ(e);
  return arguments.length === 1 ? n : n(t);
}
function Ig(e, t, n) {
  return arguments.length === 1 ? Ig.bind(null, e) : t && (Array.isArray(t) ? t.map((r) => e(r, n)) : [e(t, n)]);
}
function bZ(e, t) {
  return arguments.length === 1 ? Ig(kn.bind(null, e)) : Ig(kn.bind(null, e), t);
}
function c8(e, t, n) {
  return t !== 0 && Array.isArray(n) ? n.map((r) => c8(e, t - 1, r)) : e(n);
}
function p1(e, t, n) {
  if (arguments.length === 2)
    return p1.bind(null, e, t);
  if (!n)
    return n;
  let r = t, i = n = c8(e, t, n);
  for (; r > 0 && Array.isArray(i); )
    r--, i = i[0];
  if (i !== void 0)
    for (let s = 0; s < r; s++)
      n = [n];
  return n;
}
function wZ(e, t, n) {
  return arguments.length === 2 ? p1(kn.bind(null, e), t) : p1(kn.bind(null, e), t, n);
}
function d8(e) {
  return !!Array.isArray(e) && !e.some((t) => {
    const n = typeof t;
    return !(n === "string" || n === "number" || n === "function" && e.length > 1);
  });
}
function N$(e, t) {
  if (arguments.length === 2)
    return N$(e).call(null, t);
  const n = /* @__PURE__ */ new Set(), r = e.filter((a) => typeof a != "function"), i = e.filter((a) => typeof a == "function");
  for (const a of e)
    typeof a != "string" && typeof a != "number" || n.add(a);
  let s = null, o = null;
  return (a, l) => {
    if (a == null)
      return a;
    const c = typeof a, p = c === "string" || c === "number";
    return p && (n.has(a) || i.some((f) => c === "string" && f === String || c === "number" && f === Number)) || c === "object" && i.some((f) => !d1(a, f)) ? a : (p && r.length ? (s || (s = r.map((f) => typeof f == "string" ? `'${f}'` : `${f}`).join(", ")), Yh.error("Accessor#set", `'${a}' is not a valid value for this property, only the following values are valid: ${s}`)) : typeof a == "object" && i.length ? (o || (o = i.map((f) => J_(f)).join(", ")), Yh.error("Accessor#set", `'${a}' is not a valid value for this property, value must be one of ${o}`)) : Yh.error("Accessor#set", `'${a}' is not a valid value for this property`), l && (l.valid = !1), null);
  };
}
function Ia(e, t) {
  if (arguments.length === 2)
    return Ia(e).call(null, t);
  const n = {}, r = [], i = [];
  for (const l in e.typeMap) {
    const c = e.typeMap[l];
    n[l] = kn(c), r.push(J_(c)), i.push(l);
  }
  const s = () => `'${r.join("', '")}'`, o = () => `'${i.join("', '")}'`, a = typeof e.key == "string" ? (l) => l[e.key] : e.key;
  return (l) => {
    if (e.base && !d1(e.base, l) || l == null)
      return l;
    const c = a(l) || e.defaultKeyValue, p = n[c];
    if (!p)
      return Yh.error("Accessor#set", `Invalid property value, value needs to be one of ${s()}, or a plain object that can autocast (having .type = ${o()})`), null;
    if (!d1(e.typeMap[c], l))
      return l;
    if (typeof e.key == "string" && !l8(l)) {
      const f = {};
      for (const m in l)
        m !== e.key && (f[m] = l[m]);
      return p(f);
    }
    return p(l);
  };
}
let Vt = class {
};
const fAe = { native: (e) => ({ type: "native", value: e }), array: (e) => ({ type: "array", value: e }), oneOf: (e) => ({ type: "one-of", values: e }) };
function _Z(e) {
  if (!e || !("type" in e))
    return !1;
  switch (e.type) {
    case "native":
    case "array":
    case "one-of":
      return !0;
  }
  return !1;
}
function p8(e) {
  switch (e.type) {
    case "native":
      return kn(e.value);
    case "array":
      return Ig(p8(e.value));
    case "one-of":
      return SZ(e);
    default:
      return null;
  }
}
function SZ(e) {
  let t = null;
  return (n, r) => j$(n, e) ? n : (t == null && (t = D$(e)), Yh.error("Accessor#set", `Invalid property value, value needs to be of type ${t}`), r && (r.valid = !1), null);
}
function D$(e) {
  switch (e.type) {
    case "native":
      switch (e.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case Vt:
          return "integer";
        case Date:
          return "date";
        default:
          return J_(e.value);
      }
    case "array":
      return `array of ${D$(e.value)}`;
    case "one-of": {
      const t = e.values.map((n) => D$(n));
      return `one of ${t.slice(0, t.length - 1)} or ${t[t.length - 1]}`;
    }
  }
  return "unknown";
}
function j$(e, t) {
  if (e == null)
    return !0;
  switch (t.type) {
    case "native":
      switch (t.value) {
        case Number:
        case Vt:
          return typeof e == "number";
        case Boolean:
          return typeof e == "boolean";
        case String:
          return typeof e == "string";
      }
      return e instanceof t.value;
    case "array":
      return !!Array.isArray(e) && !e.some((n) => !j$(n, t.value));
    case "one-of":
      return t.values.some((n) => j$(e, n));
  }
}
function d(e = {}) {
  return (t, n) => {
    if (t === Function.prototype)
      throw new Error(`Inappropriate use of @property() on a static field: ${t.name}.${n}. Accessor does not support static properties.`);
    const r = Object.getOwnPropertyDescriptor(t, n), i = z_(t, n);
    r && (r.get || r.set ? (i.get = r.get || i.get, i.set = r.set || i.set) : "value" in r && ("value" in e && we.getLogger("geoscene.core.accessorSupport.decorators.property").warn(`@property() will redefine the value of "${n}" on "${t.constructor.name}" already defined in the metadata`, e), i.value = e.value = r.value)), e.readOnly != null && (i.readOnly = e.readOnly);
    const s = e.aliasOf;
    if (s) {
      const l = typeof s == "string" ? s : s.source, c = typeof s == "string" ? null : s.overridable === !0;
      let p;
      i.dependsOn = [l], i.get = function() {
        let f = t1(this, l);
        if (typeof f == "function") {
          p || (p = l.split(".").slice(0, -1).join("."));
          const m = t1(this, p);
          m && (f = f.bind(m));
        }
        return f;
      }, i.readOnly || (i.set = c ? function(f) {
        f !== void 0 ? this._override(n, f) : this._clearOverride(n);
      } : function(f) {
        i1(this, l, f);
      });
    }
    const o = e.type, a = e.types;
    i.cast || (o ? i.cast = xZ(o) : a && (Array.isArray(a) ? i.cast = Ig(Ia(a[0])) : i.cast = Ia(a))), e.range && (i.cast = $Z(i.cast, e.range)), TJ(i, e);
  };
}
function h8(e, t, n) {
  const r = z_(e, n);
  r.json || (r.json = {});
  let i = r.json;
  return t !== void 0 && (i.origins || (i.origins = {}), i.origins[t] || (i.origins[t] = {}), i = i.origins[t]), i;
}
function xZ(e) {
  let t = 0, n = e;
  if (_Z(e))
    return p8(e);
  for (; Array.isArray(n) && n.length === 1 && typeof n[0] != "string" && typeof n[0] != "number"; )
    n = n[0], t++;
  const r = n;
  if (d8(r))
    return t === 0 ? N$(r) : p1(N$(r), t);
  if (t === 1)
    return bZ(r);
  if (t > 1)
    return wZ(r, t);
  const i = e;
  return i.from ? i.from : kn(i);
}
function $Z(e, t) {
  return (n) => {
    let r = +e(n);
    return t.step != null && (r = Math.round(r / t.step) * t.step), t.min != null && (r = Math.max(t.min, r)), t.max != null && (r = Math.min(t.max, r)), r;
  };
}
function TZ(e) {
  if (e.json && e.json.origins) {
    const t = e.json.origins, n = { "web-document": ["web-scene", "web-map"] };
    for (const r in n)
      if (t[r]) {
        const i = t[r];
        n[r].forEach((s) => {
          t[s] = i;
        }), delete t[r];
      }
  }
}
let Ds = class V$ extends HD {
  constructor(t, n, r) {
    if (super(t, n, r), !(this instanceof V$))
      return new V$(t, n, r);
  }
};
Ds.prototype.type = "warning";
function f8(e) {
  return !!e && e.prototype && e.prototype.declaredClass && e.prototype.declaredClass.indexOf("geoscene.core.Collection") === 0;
}
const z$ = we.getLogger("geoscene.core.accessorSupport.extensions.serializableProperty.reader");
function AA(e, t, n) {
  var r, i;
  e && (!n && !t.read || (r = t.read) != null && r.reader || ((i = t.read) == null ? void 0 : i.enabled) === !1 || MZ(e) && ss("read.reader", zf(e), t));
}
function zf(e) {
  var t;
  const n = (t = e.ndimArray) != null ? t : 0;
  if (n > 1)
    return IZ(e);
  if (n === 1)
    return PA(e);
  if ("type" in e && y8(e.type)) {
    var r, i;
    const s = (r = e.type.prototype) == null || (i = r.itemType) == null ? void 0 : i.Type, o = PA(typeof s == "function" ? { type: s } : { types: s });
    return (a, l, c) => {
      const p = o(a, l, c);
      return p && new e.type(p);
    };
  }
  return ZC(e);
}
function ZC(e) {
  return "type" in e ? EZ(e.type) : CZ(e.types);
}
function EZ(e) {
  return e.prototype.read ? (t, n, r) => {
    if (t == null)
      return t;
    const i = typeof t;
    if (i !== "object")
      return void z$.error(`Expected JSON value of type 'object' to deserialize type '${e.prototype.declaredClass}', but got '${i}'`);
    const s = new e();
    return s.read(t, r), s;
  } : e.fromJSON;
}
function m8(e, t, n, r) {
  return r !== 0 && Array.isArray(t) ? t.map((i) => m8(e, i, n, r - 1)) : e(t, void 0, n);
}
function IZ(e) {
  var t;
  const n = ZC(e), r = m8.bind(null, n), i = (t = e.ndimArray) != null ? t : 0;
  return (s, o, a) => {
    if (s == null)
      return s;
    s = r(s, a, i);
    let l = i, c = s;
    for (; l > 0 && Array.isArray(c); )
      l--, c = c[0];
    if (c !== void 0)
      for (let p = 0; p < l; p++)
        s = [s];
    return s;
  };
}
function PA(e) {
  const t = ZC(e);
  return (n, r, i) => {
    if (n == null)
      return n;
    if (Array.isArray(n)) {
      const o = [];
      for (const a of n) {
        const l = t(a, void 0, i);
        l !== void 0 && o.push(l);
      }
      return o;
    }
    const s = t(n, void 0, i);
    return s !== void 0 ? [s] : void 0;
  };
}
function y8(e) {
  if (!f8(e))
    return !1;
  const t = e.prototype.itemType;
  return !(!t || !t.Type) && (typeof t.Type == "function" ? KC(t.Type) : g8(t.Type));
}
function MZ(e) {
  return "types" in e ? g8(e.types) : KC(e.type);
}
function KC(e) {
  return !Array.isArray(e) && !!e && e.prototype && ("read" in e.prototype || "fromJSON" in e || y8(e));
}
function g8(e) {
  for (const t in e.typeMap)
    if (!KC(e.typeMap[t]))
      return !1;
  return !0;
}
function CZ(e) {
  var t;
  let n = null;
  const r = (t = e.errorContext) != null ? t : "type";
  return (i, s, o) => {
    if (i == null)
      return i;
    const a = typeof i;
    if (a !== "object")
      return void z$.error(`Expected JSON value of type 'object' to deserialize, but got '${a}'`);
    n || (n = OZ(e));
    const l = e.key;
    if (typeof l != "string")
      return;
    const c = i[l], p = c ? n[c] : e.defaultKeyValue ? e.typeMap[e.defaultKeyValue] : void 0;
    if (!p) {
      const m = `Type '${c || "unknown"}' is not supported`;
      return o && o.messages && i && o.messages.push(new Ds(`${r}:unsupported`, m, { definition: i, context: o })), void z$.error(m);
    }
    const f = new p();
    return f.read(i, o), f;
  };
}
function OZ(e) {
  const t = {};
  for (const i in e.typeMap) {
    var n, r;
    const s = e.typeMap[i], o = f0(s.prototype);
    if (typeof e.key == "function")
      continue;
    const a = o.properties[e.key];
    if (!a)
      continue;
    (n = a.json) != null && n.type && Array.isArray(a.json.type) && a.json.type.length === 1 && typeof a.json.type[0] == "string" && (t[a.json.type[0]] = s);
    const l = (r = a.json) == null ? void 0 : r.write;
    if (!l || !l.writer) {
      t[i] = s;
      continue;
    }
    const c = l.target, p = typeof c == "string" ? c : e.key, f = {};
    l.writer(i, f, p), f[p] && (t[f[p]] = s);
  }
  return t;
}
function kZ(e) {
  if (e.json || (e.json = {}), LA(e.json), FA(e.json), RA(e.json), e.json.origins)
    for (const t in e.json.origins)
      LA(e.json.origins[t]), FA(e.json.origins[t]), RA(e.json.origins[t]);
  return !0;
}
function RA(e) {
  e.name && (e.read && typeof e.read == "object" ? e.read.source === void 0 && (e.read.source = e.name) : e.read = { source: e.name }, e.write && typeof e.write == "object" ? e.write.target === void 0 && (e.write.target = e.name) : e.write = { target: e.name });
}
function LA(e) {
  typeof e.read == "boolean" ? e.read = { enabled: e.read } : typeof e.read == "function" ? e.read = { enabled: !0, reader: e.read } : e.read && typeof e.read == "object" && e.read.enabled === void 0 && (e.read.enabled = !0);
}
function FA(e) {
  typeof e.write == "boolean" ? e.write = { enabled: e.write } : typeof e.write == "function" ? e.write = { enabled: !0, writer: e.write } : e.write && typeof e.write == "object" && e.write.enabled === void 0 && (e.write.enabled = !0);
}
const AZ = we.getLogger("geoscene.core.accessorSupport.extensions.serializableProperty.writer");
function NA(e, t) {
  var n;
  if (!t.write || t.write.writer || t.write.enabled === !1 && !t.write.overridePolicy)
    return;
  const r = (n = e == null ? void 0 : e.ndimArray) != null ? n : 0;
  e && (r === 1 || "type" in e && f8(e.type)) ? t.write.writer = LZ : r > 1 ? t.write.writer = FZ(r) : t.types ? Array.isArray(t.types) ? t.write.writer = RZ(t.types[0]) : t.write.writer = PZ(t.types) : t.write.writer = Mg;
}
function PZ(e) {
  return (t, n, r, i) => t ? v8(t, e, i) ? Mg(t, n, r, i) : void 0 : Mg(t, n, r, i);
}
function v8(e, t, n) {
  for (const s in t.typeMap)
    if (e instanceof t.typeMap[s])
      return !0;
  if (n != null && n.messages) {
    var r, i;
    const s = (r = t.errorContext) != null ? r : "type", o = `Values of type '${(i = typeof t.key != "function" ? e[t.key] : e.declaredClass) != null ? i : "Unknown"}' cannot be written`;
    n && n.messages && e && n.messages.push(new D(`${s}:unsupported`, o, { definition: e, context: n })), AZ.error(o);
  }
  return !1;
}
function RZ(e) {
  return (t, n, r, i) => !t || !Array.isArray(t) ? Mg(t, n, r, i) : Mg(t.filter((s) => v8(s, e, i)), n, r, i);
}
function Mg(e, t, n, r) {
  ss(n, h1(e, r), t);
}
function h1(e, t) {
  return e && typeof e.write == "function" ? e.write({}, t) : e && typeof e.toJSON == "function" ? e.toJSON() : typeof e == "number" ? f1(e) : e;
}
function f1(e) {
  return e === -1 / 0 ? -Number.MAX_VALUE : e === 1 / 0 ? Number.MAX_VALUE : isNaN(e) ? null : e;
}
function LZ(e, t, n, r) {
  let i;
  e === null ? i = null : e && typeof e.map == "function" ? (i = e.map((s) => h1(s, r)), typeof i.toArray == "function" && (i = i.toArray())) : i = [h1(e, r)], ss(n, i, t);
}
function b8(e, t, n) {
  return n !== 0 && Array.isArray(e) ? e.map((r) => b8(r, t, n - 1)) : h1(e, t);
}
function FZ(e) {
  return function(t, n, r, i) {
    let s;
    if (t === null)
      s = null;
    else {
      s = b8(t, i, e);
      let o = e, a = s;
      for (; o > 0 && Array.isArray(a); )
        o--, a = a[0];
      if (a !== void 0)
        for (let l = 0; l < o; l++)
          s = [s];
    }
    ss(r, s, n);
  };
}
function B$(e, t) {
  return YC(e, "read", t);
}
function w8(e, t) {
  return YC(e, "write", t);
}
function YC(e, t, n) {
  let r = e && e.json;
  if (e && e.json && e.json.origins && n) {
    const i = e.json.origins[n.origin];
    i && (t === "any" || t in i) && (r = i);
  }
  return r;
}
function NZ(e) {
  const t = DZ(e);
  if (e.json.origins)
    for (const n in e.json.origins) {
      const r = e.json.origins[n], i = r.types ? jZ(r) : t;
      AA(i, r, !1), r.types && !r.write && e.json.write && e.json.write.enabled && (r.write = { ...e.json.write }), NA(i, r);
    }
  AA(t, e.json, !0), NA(t, e.json);
}
function DZ(e) {
  return e.json.types ? U$(e.json) : e.type ? _8(e) : U$(e);
}
function jZ(e) {
  return e.type ? _8(e) : U$(e);
}
function _8(e) {
  if (!e.type)
    return;
  let t = 0, n = e.type;
  for (; Array.isArray(n) && !d8(n); )
    n = n[0], t++;
  return { type: n, ndimArray: t };
}
function U$(e) {
  if (!e.types)
    return;
  let t = 0, n = e.types;
  for (; Array.isArray(n); )
    n = n[0], t++;
  return { types: n, ndimArray: t };
}
function VZ(e) {
  kZ(e) && (TZ(e), NZ(e));
}
const b2 = /* @__PURE__ */ new Set(), w2 = /* @__PURE__ */ new Set();
function T(e) {
  return (t) => {
    t.prototype.declaredClass = e, BZ(t);
    const n = [], r = [];
    let i = t.prototype;
    for (; i; )
      i.hasOwnProperty("initialize") && !b2.has(i.initialize) && (b2.add(i.initialize), n.push(i.initialize)), i.hasOwnProperty("destroy") && !w2.has(i.destroy) && (w2.add(i.destroy), r.push(i.destroy)), i = Object.getPrototypeOf(i);
    b2.clear(), w2.clear();
    class s extends t {
      constructor(...a) {
        if (super(...a), this.constructor === s && typeof this.postscript == "function") {
          if (n.length && Object.defineProperty(this, "initialize", { enumerable: !1, configurable: !0, value() {
            for (let l = n.length - 1; l >= 0; l--)
              n[l].call(this);
          } }), r.length) {
            let l = !1;
            Object.defineProperty(this, "destroy", { enumerable: !1, configurable: !0, value() {
              if (!l) {
                l = !0;
                for (let c = 0; c < r.length; c++)
                  r[c].call(this);
              }
            } });
          }
          this.postscript(...a);
        }
      }
    }
    return s.__accessorMetadata__ = f0(t.prototype), s.prototype.declaredClass = e, s;
  };
}
function zZ(e, t) {
  return t.get == null ? function() {
    const n = this.__accessor__.properties.get(e);
    if (n === void 0)
      return;
    Ye(n);
    const r = this.__accessor__.store;
    return r.has(e) ? r.get(e) : n.metadata.value;
  } : function() {
    const n = this.__accessor__.properties.get(e);
    if (n !== void 0)
      return n.getComputed();
  };
}
function BZ(e) {
  const t = e.prototype, n = f0(t).properties, r = {};
  for (const i of Object.getOwnPropertyNames(n)) {
    const s = n[i];
    VZ(s), r[i] = { enumerable: !0, configurable: !0, get: zZ(i, s), set(o) {
      const a = this.__accessor__;
      if (a !== void 0) {
        if (!Object.isFrozen(this)) {
          if (a.initialized && s.readOnly)
            throw new TypeError(`[accessor] cannot assign to read-only property '${i}' of ${this.declaredClass}`);
          if (a.lifecycle === ha.CONSTRUCTED && s.constructOnly)
            throw new TypeError(`[accessor] cannot assign to construct-only property '${i}' of ${this.declaredClass}`);
          a.set(i, o);
        }
      } else
        Object.defineProperty(this, i, { enumerable: !0, configurable: !0, writable: !0, value: o });
    } };
  }
  Object.defineProperties(e.prototype, r);
}
function UZ(e) {
  if (e == null)
    return { value: e };
  if (Array.isArray(e))
    return { type: [e[0]], value: null };
  switch (typeof e) {
    case "object":
      return e.constructor && e.constructor.__accessorMetadata__ || e instanceof Date ? { type: e.constructor, value: e } : e;
    case "boolean":
      return { type: Boolean, value: e };
    case "string":
      return { type: String, value: e };
    case "number":
      return { type: Number, value: e };
    case "function":
      return { type: e, value: null };
    default:
      return;
  }
}
let ke = class S8 {
  constructor(...t) {
    if (this.constructor === S8)
      throw new Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
    Object.defineProperty(this, "__accessor__", { enumerable: !1, value: new RJ(this) }), t.length > 0 && this.normalizeCtorArgs && (this.__accessor__.ctorArgs = this.normalizeCtorArgs.apply(this, t));
  }
  static createSubclass(t = {}) {
    if (Array.isArray(t))
      throw new Error("Multi-inheritance unsupported since 4.16");
    const { properties: n, declaredClass: r, constructor: i } = t;
    delete t.declaredClass, delete t.properties, delete t.constructor;
    const s = this;
    class o extends s {
      constructor(...l) {
        super(...l), this.inherited = null, i && i.apply(this, l);
      }
    }
    f0(o.prototype);
    for (const a in t) {
      const l = t[a];
      o.prototype[a] = typeof l == "function" ? function(...c) {
        const p = this.inherited;
        let f;
        this.inherited = function(...m) {
          if (s.prototype[a])
            return s.prototype[a].apply(this, m);
        };
        try {
          f = l.apply(this, c);
        } catch (m) {
          throw this.inherited = p, m;
        }
        return this.inherited = p, f;
      } : t[a];
    }
    for (const a in n) {
      const l = UZ(n[a]);
      d(l)(o.prototype, a);
    }
    return T(r)(o);
  }
  postscript(t) {
    const n = this.__accessor__, r = n.ctorArgs || t;
    n.initialize(), r && (this.set(r), n.ctorArgs = null), n.constructed(), this.initialize();
  }
  initialize() {
  }
  destroy() {
    this.destroyed || (rZ(this), this.__accessor__.destroy());
  }
  get initialized() {
    return this.__accessor__ && this.__accessor__.initialized || !1;
  }
  get constructed() {
    return this.__accessor__ && this.__accessor__.lifecycle === ha.CONSTRUCTED || !1;
  }
  get destroyed() {
    return this.__accessor__ && this.__accessor__.destroyed || !1;
  }
  commitProperty(t) {
    this.get(t);
  }
  get(t) {
    return t1(this, t);
  }
  hasOwnProperty(t) {
    return this.__accessor__ ? this.__accessor__.has(t) : Object.prototype.hasOwnProperty.call(this, t);
  }
  isInstanceOf(t) {
    return Xp(we.getLogger(this.declaredClass), "isInstanceOf", { replacement: "Use instanceof directly", version: "4.16" }), this instanceof t;
  }
  keys() {
    return this.__accessor__ ? this.__accessor__.keys() : [];
  }
  set(t, n) {
    return i1(this, t, n), this;
  }
  watch(t, n, r) {
    return uZ(this, t, n, r);
  }
  _clearOverride(t) {
    return this.__accessor__.clearOverride(t);
  }
  _override(t, n) {
    return this.__accessor__.override(t, n);
  }
  _isOverridden(t) {
    return this.__accessor__.isOverridden(t);
  }
  notifyChange(t) {
    this.__accessor__.notifyChange(t);
  }
  _get(t) {
    return this.__accessor__.internalGet(t);
  }
  _set(t, n) {
    return this.__accessor__.internalSet(t, n), this;
  }
}, $b = class x8 {
  constructor() {
    this._emitter = new x8.EventEmitter(this);
  }
  emit(t, n) {
    return this._emitter.emit(t, n);
  }
  on(t, n) {
    return this._emitter.on(t, n);
  }
  once(t, n) {
    return this._emitter.once(t, n);
  }
  hasEventListener(t) {
    return this._emitter.hasEventListener(t);
  }
};
(function(e) {
  class t {
    constructor(i = null) {
      this.target = i, this._listenersMap = null;
    }
    clear() {
      this._listenersMap && this._listenersMap.clear(), this._listenersMap = null;
    }
    emit(i, s) {
      const o = this._listenersMap && this._listenersMap.get(i);
      if (!o)
        return !1;
      const a = this.target || this;
      return [...o].forEach((l) => {
        l.call(a, s);
      }), o.length > 0;
    }
    on(i, s) {
      if (Array.isArray(i)) {
        const a = i.map((l) => this.on(l, s));
        return V_(a);
      }
      if (i.indexOf(",") > -1)
        throw new TypeError("Evented.on() with a comma delimited string of event types is not supported");
      this._listenersMap || (this._listenersMap = /* @__PURE__ */ new Map());
      const o = this._listenersMap.get(i) || [];
      return o.push(s), this._listenersMap.set(i, o), { remove: () => {
        const a = this._listenersMap && this._listenersMap.get(i) || [], l = a.indexOf(s);
        l >= 0 && a.splice(l, 1);
      } };
    }
    once(i, s) {
      const o = this.on(i, (a) => {
        o.remove(), s.call(null, a);
      });
      return o;
    }
    hasEventListener(i) {
      const s = this._listenersMap && this._listenersMap.get(i);
      return s != null && s.length > 0;
    }
  }
  e.EventEmitter = t, e.EventedMixin = (r) => {
    let i = class extends r {
      constructor() {
        super(...arguments), this._emitter = new t();
      }
      destroy() {
        this._emitter.clear();
      }
      emit(s, o) {
        return this._emitter.emit(s, o);
      }
      on(s, o) {
        return this._emitter.on(s, o);
      }
      once(s, o) {
        return this._emitter.once(s, o);
      }
      hasEventListener(s) {
        return this._emitter.hasEventListener(s);
      }
    };
    return i = u([T("geoscene.core.Evented")], i), i;
  };
  let n = class extends ke {
    constructor() {
      super(...arguments), this._emitter = new $b.EventEmitter(this);
    }
    destroy() {
      this._emitter.clear();
    }
    emit(r, i) {
      return this._emitter.emit(r, i);
    }
    on(r, i) {
      return this._emitter.on(r, i);
    }
    once(r, i) {
      return this._emitter.once(r, i);
    }
    hasEventListener(r) {
      return this._emitter.hasEventListener(r);
    }
  };
  n = u([T("geoscene.core.Evented")], n), e.EventedAccessor = n;
})($b || ($b = {}));
const mc = $b;
var xt;
(function(e) {
  e[e.ADD = 1] = "ADD", e[e.REMOVE = 2] = "REMOVE", e[e.MOVE = 4] = "MOVE";
})(xt || (xt = {}));
function QC(e) {
  return (t, n) => {
    t[n] = e;
  };
}
let qZ = class {
  constructor() {
    this._observers = [];
  }
  observe(t) {
    return this._observers.includes(t) || this._observers.push(t), new GD(this._observers, t);
  }
  notify() {
    const t = this._observers.slice();
    for (let n = 0; n < t.length; ++n) {
      const r = t[n];
      r.onInvalidated(), r.onCommitted();
    }
  }
};
var ml;
let GZ = class {
  constructor() {
    this.target = null, this.cancellable = !1, this.defaultPrevented = !1, this.item = void 0, this.type = void 0;
  }
  preventDefault() {
    this.cancellable && (this.defaultPrevented = !0);
  }
  reset(t) {
    this.defaultPrevented = !1, this.item = t;
  }
};
const fs = new fc(GZ, void 0, (e) => {
  e.item = null, e.target = null, e.defaultPrevented = !1, e.cancellable = !1;
}), WZ = () => {
};
function _2(e) {
  return e ? e instanceof gd ? e.toArray() : e.length ? Array.prototype.slice.apply(e) : [] : [];
}
function S2(e) {
  if (e && e.length)
    return e[0];
}
function HZ(e, t, n, r) {
  const i = Math.min(e.length - n, t.length - r);
  let s = 0;
  for (; s < i && e[n + s] === t[r + s]; )
    s++;
  return s;
}
function $8(e, t, n, r) {
  t && t.forEach((i, s, o) => {
    e.push(i), $8(e, n.call(r, i, s, o), n, r);
  });
}
const zl = /* @__PURE__ */ new Set(), Bl = /* @__PURE__ */ new Set(), Ul = /* @__PURE__ */ new Set(), x2 = /* @__PURE__ */ new Map();
let JZ = 0, gd = ml = class extends mc.EventedAccessor {
  constructor(e) {
    super(e), this._chgListeners = [], this._notifications = null, this._timer = null, this._observable = new qZ(), this.length = 0, this._items = [], Object.defineProperty(this, "uid", { value: JZ++ });
  }
  static isCollection(e) {
    return e != null && e instanceof ml;
  }
  normalizeCtorArgs(e) {
    return e ? Array.isArray(e) || e instanceof ml ? { items: e } : e : {};
  }
  destroy() {
    this.removeAll();
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  get items() {
    return Ye(this._observable), this._items;
  }
  set items(e) {
    this._emitBeforeChanges(xt.ADD) || (this._splice(0, this.length, _2(e)), this._emitAfterChanges(xt.ADD));
  }
  hasEventListener(e) {
    return e === "change" ? this._chgListeners.length > 0 : this._emitter.hasEventListener(e);
  }
  on(e, t) {
    if (e === "change") {
      const n = this._chgListeners, r = { removed: !1, callback: t };
      return n.push(r), this._notifications && this._notifications.push({ listeners: n.slice(), items: this._items.slice(), changes: [] }), { remove() {
        this.remove = WZ, r.removed = !0, n.splice(n.indexOf(r), 1);
      } };
    }
    return this._emitter.on(e, t);
  }
  once(e, t) {
    const n = this.on(e, t);
    return { remove() {
      n.remove();
    } };
  }
  add(e, t) {
    if (Ye(this._observable), this._emitBeforeChanges(xt.ADD))
      return this;
    const n = this.getNextIndex(t ?? null);
    return this._splice(n, 0, [e]), this._emitAfterChanges(xt.ADD), this;
  }
  addMany(e, t = this._items.length) {
    if (Ye(this._observable), !e || !e.length)
      return this;
    if (this._emitBeforeChanges(xt.ADD))
      return this;
    const n = this.getNextIndex(t);
    return this._splice(n, 0, _2(e)), this._emitAfterChanges(xt.ADD), this;
  }
  at(e) {
    if (Ye(this._observable), (e = Math.trunc(e) || 0) < 0 && (e += this.length), !(e < 0 || e >= this.length))
      return this._items[e];
  }
  removeAll() {
    if (Ye(this._observable), !this.length || this._emitBeforeChanges(xt.REMOVE))
      return [];
    const e = this._splice(0, this.length) || [];
    return this._emitAfterChanges(xt.REMOVE), e;
  }
  clone() {
    return Ye(this._observable), this._createNewInstance({ items: this._items.map(q) });
  }
  concat(...e) {
    Ye(this._observable);
    const t = e.map(_2);
    return this._createNewInstance({ items: this._items.concat(...t) });
  }
  drain(e, t) {
    if (Ye(this._observable), !this.length || this._emitBeforeChanges(xt.REMOVE))
      return;
    const n = this._splice(0, this.length), r = n.length;
    for (let i = 0; i < r; i++)
      e.call(t, n[i], i, n);
    this._emitAfterChanges(xt.REMOVE);
  }
  every(e, t) {
    return Ye(this._observable), this._items.every(e, t);
  }
  filter(e, t) {
    let n;
    return Ye(this._observable), n = arguments.length === 2 ? this._items.filter(e, t) : this._items.filter(e), this._createNewInstance({ items: n });
  }
  find(e, t) {
    return Ye(this._observable), this._items.find(e, t);
  }
  findIndex(e, t) {
    return Ye(this._observable), this._items.findIndex(e, t);
  }
  flatten(e, t) {
    Ye(this._observable);
    const n = [];
    return $8(n, this, e, t), new ml(n);
  }
  forEach(e, t) {
    return Ye(this._observable), this._items.forEach(e, t);
  }
  getItemAt(e) {
    return Ye(this._observable), this._items[e];
  }
  getNextIndex(e) {
    Ye(this._observable);
    const t = this.length;
    return (e = e ?? t) < 0 ? e = 0 : e > t && (e = t), e;
  }
  includes(e, t = 0) {
    return Ye(this._observable), this._items.includes(e, t);
  }
  indexOf(e, t = 0) {
    return Ye(this._observable), this._items.indexOf(e, t);
  }
  join(e = ",") {
    return Ye(this._observable), this._items.join(e);
  }
  lastIndexOf(e, t = this.length - 1) {
    return Ye(this._observable), this._items.lastIndexOf(e, t);
  }
  map(e, t) {
    Ye(this._observable);
    const n = this._items.map(e, t);
    return new ml({ items: n });
  }
  reorder(e, t = this.length - 1) {
    Ye(this._observable);
    const n = this.indexOf(e);
    if (n !== -1) {
      if (t < 0 ? t = 0 : t >= this.length && (t = this.length - 1), n !== t) {
        if (this._emitBeforeChanges(xt.MOVE))
          return e;
        this._splice(n, 1), this._splice(t, 0, [e]), this._emitAfterChanges(xt.MOVE);
      }
      return e;
    }
  }
  pop() {
    if (Ye(this._observable), !this.length || this._emitBeforeChanges(xt.REMOVE))
      return;
    const e = S2(this._splice(this.length - 1, 1));
    return this._emitAfterChanges(xt.REMOVE), e;
  }
  push(...e) {
    return Ye(this._observable), this._emitBeforeChanges(xt.ADD) || (this._splice(this.length, 0, e), this._emitAfterChanges(xt.ADD)), this.length;
  }
  reduce(e, t) {
    Ye(this._observable);
    const n = this._items;
    return arguments.length === 2 ? n.reduce(e, t) : n.reduce(e);
  }
  reduceRight(e, t) {
    Ye(this._observable);
    const n = this._items;
    return arguments.length === 2 ? n.reduceRight(e, t) : n.reduceRight(e);
  }
  remove(e) {
    return Ye(this._observable), this.removeAt(this.indexOf(e));
  }
  removeAt(e) {
    if (Ye(this._observable), e < 0 || e >= this.length || this._emitBeforeChanges(xt.REMOVE))
      return;
    const t = S2(this._splice(e, 1));
    return this._emitAfterChanges(xt.REMOVE), t;
  }
  removeMany(e) {
    if (Ye(this._observable), !e || !e.length || this._emitBeforeChanges(xt.REMOVE))
      return [];
    const t = e instanceof ml ? e.toArray() : e, n = this._items, r = [], i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s], a = n.indexOf(o);
      if (a > -1) {
        const l = 1 + HZ(t, n, s + 1, a + 1), c = this._splice(a, l);
        c && c.length > 0 && r.push.apply(r, c), s += l - 1;
      }
    }
    return this._emitAfterChanges(xt.REMOVE), r;
  }
  reverse() {
    if (Ye(this._observable), this._emitBeforeChanges(xt.MOVE))
      return this;
    const e = this._splice(0, this.length);
    return e && (e.reverse(), this._splice(0, 0, e)), this._emitAfterChanges(xt.MOVE), this;
  }
  shift() {
    if (Ye(this._observable), !this.length || this._emitBeforeChanges(xt.REMOVE))
      return;
    const e = S2(this._splice(0, 1));
    return this._emitAfterChanges(xt.REMOVE), e;
  }
  slice(e = 0, t = this.length) {
    return Ye(this._observable), this._createNewInstance({ items: this._items.slice(e, t) });
  }
  some(e, t) {
    return Ye(this._observable), this._items.some(e, t);
  }
  sort(e) {
    if (Ye(this._observable), !this.length || this._emitBeforeChanges(xt.MOVE))
      return this;
    const t = this._splice(0, this.length);
    return arguments.length ? t.sort(e) : t.sort(), this._splice(0, 0, t), this._emitAfterChanges(xt.MOVE), this;
  }
  splice(e, t, ...n) {
    Ye(this._observable);
    const r = (t ? xt.REMOVE : 0) | (n.length ? xt.ADD : 0);
    if (this._emitBeforeChanges(r))
      return [];
    const i = this._splice(e, t, n) || [];
    return this._emitAfterChanges(r), i;
  }
  toArray() {
    return Ye(this._observable), this._items.slice();
  }
  toJSON() {
    return Ye(this._observable), this.toArray();
  }
  toLocaleString() {
    return Ye(this._observable), this._items.toLocaleString();
  }
  toString() {
    return Ye(this._observable), this._items.toString();
  }
  unshift(...e) {
    return Ye(this._observable), !e.length || this._emitBeforeChanges(xt.ADD) || (this._splice(0, 0, e), this._emitAfterChanges(xt.ADD)), this.length;
  }
  _createNewInstance(e) {
    return new this.constructor(e);
  }
  _splice(e, t, n) {
    const r = this._items, i = this.itemType;
    let s, o;
    if (!this._notifications && this.hasEventListener("change") && (this._notifications = [{ listeners: this._chgListeners.slice(), items: this._items.slice(), changes: [] }], this._timer && this._timer.remove(), this._timer = g0(() => this._dispatchChange())), t) {
      if (o = r.splice(e, t), this.hasEventListener("before-remove")) {
        const a = fs.acquire();
        a.target = this, a.cancellable = !0;
        for (let l = 0, c = o.length; l < c; l++)
          s = o[l], a.reset(s), this.emit("before-remove", a), a.defaultPrevented && (o.splice(l, 1), r.splice(e, 0, s), e += 1, l -= 1, c -= 1);
        fs.release(a);
      }
      if (this.length = this._items.length, this.hasEventListener("after-remove")) {
        const a = fs.acquire();
        a.target = this, a.cancellable = !1;
        const l = o.length;
        for (let c = 0; c < l; c++)
          a.reset(o[c]), this.emit("after-remove", a);
        fs.release(a);
      }
    }
    if (n && n.length) {
      if (i) {
        const p = [];
        for (const f of n) {
          const m = i.ensureType(f);
          m == null && f != null || p.push(m);
        }
        n = p;
      }
      const a = this.hasEventListener("before-add"), l = this.hasEventListener("after-add"), c = e === this.length;
      if (a || l) {
        const p = fs.acquire();
        p.target = this, p.cancellable = !0;
        const f = fs.acquire();
        f.target = this, f.cancellable = !1;
        for (const m of n)
          a ? (p.reset(m), this.emit("before-add", p), p.defaultPrevented || (c ? r.push(m) : r.splice(e++, 0, m), this._set("length", r.length), l && (f.reset(m), this.emit("after-add", f)))) : (c ? r.push(m) : r.splice(e++, 0, m), this._set("length", r.length), f.reset(m), this.emit("after-add", f));
        fs.release(f), fs.release(p);
      } else {
        if (c)
          for (const p of n)
            r.push(p);
        else
          r.splice(e, 0, ...n);
        this._set("length", r.length);
      }
    }
    return (n && n.length || o && o.length) && this._notifyChangeEvent(n, o), o;
  }
  _emitBeforeChanges(e) {
    let t = !1;
    if (this.hasEventListener("before-changes")) {
      const n = fs.acquire();
      n.target = this, n.cancellable = !0, n.type = e, this.emit("before-changes", n), t = n.defaultPrevented, fs.release(n);
    }
    return t;
  }
  _emitAfterChanges(e) {
    if (this.hasEventListener("after-changes")) {
      const t = fs.acquire();
      t.target = this, t.cancellable = !1, t.type = e, this.emit("after-changes", t), fs.release(t);
    }
    this._observable.notify();
  }
  _notifyChangeEvent(e, t) {
    this.hasEventListener("change") && this._notifications && this._notifications[this._notifications.length - 1].changes.push({ added: e, removed: t });
  }
  _dispatchChange() {
    if (this._timer && (this._timer.remove(), this._timer = null), !this._notifications)
      return;
    const e = this._notifications;
    this._notifications = null;
    for (const t of e) {
      const n = t.changes;
      zl.clear(), Bl.clear(), Ul.clear();
      for (const { added: l, removed: c } of n) {
        if (l)
          if (Ul.size === 0 && Bl.size === 0)
            for (const p of l)
              zl.add(p);
          else
            for (const p of l)
              Bl.has(p) ? (Ul.add(p), Bl.delete(p)) : Ul.has(p) || zl.add(p);
        if (c)
          if (Ul.size === 0 && zl.size === 0)
            for (const p of c)
              Bl.add(p);
          else
            for (const p of c)
              zl.has(p) ? zl.delete(p) : (Ul.delete(p), Bl.add(p));
      }
      const r = Hr.acquire();
      zl.forEach((l) => {
        r.push(l);
      });
      const i = Hr.acquire();
      Bl.forEach((l) => {
        i.push(l);
      });
      const s = this._items, o = t.items, a = Hr.acquire();
      if (Ul.forEach((l) => {
        o.indexOf(l) !== s.indexOf(l) && a.push(l);
      }), t.listeners && (r.length || i.length || a.length)) {
        const l = { target: this, added: r, removed: i, moved: a }, c = t.listeners.length;
        for (let p = 0; p < c; p++) {
          const f = t.listeners[p];
          f.removed || f.callback.call(this, l);
        }
      }
      Hr.release(r), Hr.release(i), Hr.release(a);
    }
    zl.clear(), Bl.clear(), Ul.clear();
  }
};
gd.ofType = (e) => {
  if (!e)
    return ml;
  if (x2.has(e))
    return x2.get(e);
  let t = null;
  if (typeof e == "function")
    t = e.prototype.declaredClass;
  else if (e.base)
    t = e.base.prototype.declaredClass;
  else
    for (const r in e.typeMap) {
      const i = e.typeMap[r].prototype.declaredClass;
      t ? t += ` | ${i}` : t = i;
    }
  let n = class extends ml {
  };
  return u([QC({ Type: e, ensureType: typeof e == "function" ? kn(e) : Ia(e) })], n.prototype, "itemType", void 0), n = u([T(`geoscene.core.Collection<${t}>`)], n), x2.set(e, n), n;
}, u([d()], gd.prototype, "length", void 0), u([d()], gd.prototype, "items", null), gd = ml = u([T("geoscene.core.Collection")], gd);
const Ne = gd;
function Xd(e, t, n = Ne) {
  return t || (t = new n()), t === e || (t.removeAll(), ZZ(e) ? t.addMany(e) : e && t.add(e)), t;
}
function T8(e) {
  return e;
}
function ZZ(e) {
  return e && (Array.isArray(e) || "items" in e && Array.isArray(e.items));
}
let KZ = class E8 {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(t) {
    const n = new E8();
    return this._values.forEach((r, i) => {
      t && t.has(i) || n.set(i, q(r.value), r.origin);
    }), n;
  }
  get(t, n) {
    n = this._normalizeOrigin(n);
    const r = this._values.get(t);
    return n == null || (r == null ? void 0 : r.origin) === n ? r == null ? void 0 : r.value : void 0;
  }
  originOf(t) {
    var n, r;
    return (n = (r = this._values.get(t)) == null ? void 0 : r.origin) != null ? n : ot.USER;
  }
  keys(t) {
    t = this._normalizeOrigin(t);
    const n = [...this._values.keys()];
    return t == null ? n : n.filter((r) => {
      var i;
      return ((i = this._values.get(r)) == null ? void 0 : i.origin) === t;
    });
  }
  set(t, n, r) {
    if ((r = this._normalizeOrigin(r)) === ot.DEFAULTS) {
      const i = this._values.get(t);
      if (i && i.origin != null && i.origin > r)
        return;
    }
    this._values.set(t, new YZ(n, r));
  }
  delete(t, n) {
    var r;
    (n = this._normalizeOrigin(n)) != null && ((r = this._values.get(t)) == null ? void 0 : r.origin) !== n || this._values.delete(t);
  }
  has(t, n) {
    var r;
    return (n = this._normalizeOrigin(n)) != null ? ((r = this._values.get(t)) == null ? void 0 : r.origin) === n : this._values.has(t);
  }
  forEach(t) {
    this._values.forEach(({ value: n }, r) => t(n, r));
  }
  _normalizeOrigin(t) {
    if (t != null)
      return t === ot.DEFAULTS ? t : ot.USER;
  }
}, YZ = class {
  constructor(t, n) {
    this.value = t, this.origin = n;
  }
};
function I8(e, t, n) {
  t.keys().forEach((i) => {
    n.set(i, t.get(i), ot.DEFAULTS);
  });
  const r = e.metadatas;
  Object.keys(r).forEach((i) => {
    e.internalGet(i) && n.set(i, e.internalGet(i), ot.DEFAULTS);
  });
}
function QZ(e, t, n) {
  if (!e || !e.read || e.read.enabled === !1 || !e.read.source)
    return !1;
  const r = e.read.source;
  if (typeof r == "string") {
    if (r === t || r.indexOf(".") > -1 && r.indexOf(t) === 0 && xA(r, n))
      return !0;
  } else
    for (const i of r)
      if (i === t || i.indexOf(".") > -1 && i.indexOf(t) === 0 && xA(i, n))
        return !0;
  return !1;
}
function XZ(e) {
  return e && (!e.read || e.read.enabled !== !1 && !e.read.source);
}
function eK(e, t, n, r, i) {
  let s = B$(t[n], i);
  XZ(s) && (e[n] = !0);
  for (const o of Object.getOwnPropertyNames(t))
    s = B$(t[o], i), QZ(s, n, r) && (e[o] = !0);
}
function tK(e, t, n, r) {
  const i = n.metadatas, s = YC(i[t], "any", r), o = s && s.default;
  if (o === void 0)
    return;
  const a = typeof o == "function" ? o.call(e, t, r) : o;
  a !== void 0 && n.set(t, a);
}
const M8 = { origin: "service" };
function C8(e, t, n = M8) {
  if (!t || typeof t != "object")
    return;
  const r = Xr(e), i = r.metadatas, s = {};
  for (const o of Object.getOwnPropertyNames(t))
    eK(s, i, o, t, n);
  r.setDefaultOrigin(n.origin);
  for (const o of Object.getOwnPropertyNames(s)) {
    const a = B$(i[o], n).read, l = a && a.source;
    let c;
    c = l && typeof l == "string" ? h0(t, l) : t[o], a && a.reader && (c = a.reader.call(e, c, t, n)), c !== void 0 && r.set(o, c);
  }
  if (!n || !n.ignoreDefaults) {
    r.setDefaultOrigin("defaults");
    for (const o of Object.getOwnPropertyNames(i))
      s[o] || tK(e, o, r, n);
  }
  r.setDefaultOrigin("user");
}
function nK(e, t, n, r = M8) {
  var i;
  const s = { ...r, messages: [] };
  n(s), (i = s.messages) == null || i.forEach((o) => {
    o.type !== "warning" || e.loaded ? r && r.messages && r.messages.push(o) : e.loadWarnings.push(o);
  });
}
const rK = we.getLogger("geoscene.core.accessorSupport.write");
function iK(e, t, n, r, i) {
  var s, o;
  const a = {};
  return (s = t.write) == null || (o = s.writer) == null || o.call(e, r, a, n, i), a;
}
function O8(e, t, n, r, i, s) {
  if (!r || !r.write)
    return !1;
  const o = e.get(n);
  if (!i && r.write.overridePolicy) {
    const a = r.write.overridePolicy.call(e, o, n, s);
    a !== void 0 && (i = a);
  }
  if (i || (i = r.write), !i || i.enabled === !1)
    return !1;
  if ((o === null && !i.allowNull && !i.writerEnsuresNonNull || o === void 0) && i.isRequired) {
    const a = new D("web-document-write:property-required", `Missing value for required property '${n}' on '${e.declaredClass}'`, { propertyName: n, target: e });
    return a && s && s.messages ? s.messages.push(a) : a && !s && rK.error(a.name, a.message), !1;
  }
  return !(o === void 0 || o === null && !i.allowNull && !i.writerEnsuresNonNull || (!t.store.multipleOriginsSupported || t.store.originOf(n) === ot.DEFAULTS) && sK(e, n, s, r, o) || !i.ignoreOrigin && s && s.origin && t.store.multipleOriginsSupported && t.store.originOf(n) < Vu(s.origin));
}
function sK(e, t, n, r, i) {
  const s = r.default;
  if (s === void 0)
    return !1;
  if (r.defaultEquals != null)
    return r.defaultEquals(i);
  if (typeof s == "function") {
    if (Array.isArray(i)) {
      const o = s.call(e, t, n);
      return SD(o, i);
    }
    return !1;
  }
  return s === i;
}
function oK(e, t, n, r) {
  const i = Xr(e), s = i.metadatas, o = w8(s[t], r);
  return !!o && O8(e, i, t, o, n, r);
}
function k8(e, t, n) {
  if (e && typeof e.toJSON == "function" && (!e.toJSON.isDefaultToJSON || !e.write))
    return bb(t, e.toJSON());
  const r = Xr(e), i = r.metadatas;
  for (const a in i) {
    const l = w8(i[a], n);
    if (!O8(e, r, a, l, void 0, n))
      continue;
    const c = e.get(a), p = iK(e, l, l.write && typeof l.write.target == "string" ? l.write.target : a, c, n);
    var s, o;
    Object.keys(p).length > 0 && (t = bb(t, p), n != null && (s = n.resources) != null && (o = s.pendingOperations) != null && o.length && Promise.all(n.resources.pendingOperations).then(() => bb(t, p)), n && n.writtenProperties && n.writtenProperties.push({ target: e, propName: a, oldOrigin: MJ(r.store.originOf(a)), newOrigin: n.origin }));
  }
  return t;
}
const b0 = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n);
      const r = Xr(this), i = r.store, s = new KZ();
      r.store = s, I8(r, i, s);
    }
    read(n, r) {
      C8(this, n, r);
    }
    write(n = {}, r) {
      return k8(this, n, r);
    }
    toJSON(n) {
      return this.write({}, n);
    }
    static fromJSON(n, r) {
      return aK.call(this, n, r);
    }
  };
  return t = u([T("geoscene.core.JSONSupport")], t), t.prototype.toJSON.isDefaultToJSON = !0, t;
};
function aK(e, t) {
  if (!e)
    return null;
  if (e.declaredClass)
    throw new Error("JSON object is already hydrated");
  const n = new this();
  return n.read(e, t), n;
}
let se = class extends b0(ke) {
};
se = u([T("geoscene.core.JSONSupport")], se);
var ku;
(function(e) {
  e[e.PENDING = 0] = "PENDING", e[e.RESOLVED = 1] = "RESOLVED", e[e.REJECTED = 2] = "REJECTED";
})(ku || (ku = {}));
let lK = class {
  constructor(t) {
    this.instance = t, this._resolver = Cl(), this._status = ku.PENDING, this._resolvingPromises = [], this._resolver.promise.then(() => {
      this._status = ku.RESOLVED, this._cleanUp();
    }, () => {
      this._status = ku.REJECTED, this._cleanUp();
    });
  }
  addResolvingPromise(t) {
    this._resolvingPromises.push(t), this._tryResolve();
  }
  isResolved() {
    return this._status === ku.RESOLVED;
  }
  isRejected() {
    return this._status === ku.REJECTED;
  }
  isFulfilled() {
    return this._status !== ku.PENDING;
  }
  abort() {
    this._resolver.reject(Cn());
  }
  when(t, n) {
    return this._resolver.promise.then(t, n);
  }
  _cleanUp() {
    this._allPromise = this._resolvingPromises = this._allPromise = null;
  }
  _tryResolve() {
    if (this.isFulfilled())
      return;
    const t = Cl(), n = [...this._resolvingPromises, t.promise], r = this._allPromise = Promise.all(n);
    r.then(() => {
      this.isFulfilled() || this._allPromise !== r || this._resolver.resolve(this.instance);
    }, (i) => {
      this.isFulfilled() || this._allPromise !== r || Ws(i) || this._resolver.reject(i);
    }), t.resolve();
  }
};
const Z_ = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this._promiseProps = new lK(this), this.addResolvingPromise(Promise.resolve());
    }
    isResolved() {
      return this._promiseProps.isResolved();
    }
    isRejected() {
      return this._promiseProps.isRejected();
    }
    isFulfilled() {
      return this._promiseProps.isFulfilled();
    }
    when(n, r) {
      return new Promise((i, s) => {
        this._promiseProps.when(i, s);
      }).then(n, r);
    }
    catch(n) {
      return this.when(null, n);
    }
    addResolvingPromise(n) {
      n && !this._promiseProps.isFulfilled() && this._promiseProps.addResolvingPromise("_promiseProps" in n ? n.when() : n);
    }
  };
  return t = u([T("geoscene.core.Promise")], t), t;
};
let m1 = class extends Z_(ke) {
};
m1 = u([T("geoscene.core.Promise")], m1);
const uK = "not-loaded", cK = "loading", dK = "failed", DA = "loaded", A8 = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this._loadController = null, this.loadError = null, this.loadStatus = "not-loaded", this._set("loadWarnings", []), this.addResolvingPromise(new Promise((r) => {
        const i = this.load.bind(this);
        this.load = (s) => {
          const o = new Promise((a, l) => {
            const c = G_(s, l);
            this.destroyed && l(new D("load:instance-destroyed", `Instance of '${this.declaredClass || this.constructor.name}' is already destroyed`, { instance: this })), this._promiseProps.when(a, l).finally(() => {
              c && c.remove();
            });
          });
          if (this.loadStatus === uK) {
            this._set("loadStatus", cK);
            const a = this._loadController = new AbortController();
            i({ signal: a.signal }), Ao(a.signal, () => {
              this._promiseProps.abort();
            });
          }
          return r(), o;
        };
      })), this.when(() => {
        this._set("loadStatus", DA), this._loadController = null;
      }, (r) => {
        this._set("loadStatus", dK), this._set("loadError", r), this._loadController = null;
      });
    }
    get loaded() {
      return this.loadStatus === DA;
    }
    get loadWarnings() {
      return this._get("loadWarnings");
    }
    load() {
      return null;
    }
    cancelLoad() {
      var n;
      return this.isFulfilled() || (this._set("loadError", new D("load:cancelled", "Cancelled")), (n = this._loadController) == null || n.abort()), this;
    }
  };
  return u([d({ readOnly: !0 })], t.prototype, "loaded", null), u([d({ readOnly: !0 })], t.prototype, "loadError", void 0), u([d({ clonable: !1 })], t.prototype, "loadStatus", void 0), u([d({ type: [Ds], readOnly: !0 })], t.prototype, "loadWarnings", null), t = u([T("geoscene.core.Loadable")], t), t;
};
let Km = class extends A8(m1) {
};
Km = u([T("geoscene.core.Loadable")], Km), function(e) {
  function t(n) {
    return !(!n || !n.load);
  }
  e.LoadableMixin = A8, e.isLoadable = t;
}(Km || (Km = {}));
const Ol = Km;
function pK(e, t, n) {
  return Ii(e.map((r, i) => t.apply(n, [r, i])));
}
function hK(e, t, n) {
  return Ii(e.map((r, i) => t.apply(n, [r, i]))).then((r) => r.map((i) => i.value));
}
function K_(e) {
  return H(e) ? Dh() : e.then((t) => ({ ok: !0, value: t })).catch((t) => ({ ok: !1, error: t }));
}
function SAe(e) {
  return e.then((t) => ({ ok: !0, value: t })).catch((t) => (y0(t), { ok: !1, error: t }));
}
async function P8(e, t) {
  return await e.load(), fK(e, t);
}
async function fK(e, t) {
  const n = [], r = (...s) => {
    for (const o of s)
      H(o) || (Array.isArray(o) ? r(...o) : Ne.isCollection(o) ? o.forEach((a) => r(a)) : Ol.isLoadable(o) && n.push(o));
  };
  t(r);
  let i = null;
  if (await hK(n, async (s) => {
    (await K_(mK(s) ? s.loadAll() : s.load())).ok !== !1 || i || (i = s);
  }), i)
    throw i.loadError;
  return e;
}
function mK(e) {
  return "loadAll" in e && typeof e.loadAll == "function";
}
const yK = we.getLogger("geoscene.core.urlUtils"), Bf = Pt.request, jA = "geoscene/config: geosceneConfig.request.proxyUrl is not set.", R8 = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i, L8 = /^\s*http:/i, gK = /^\s*https:/i, vK = /^\s*file:/i, bK = /:\d+$/, wK = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i, _K = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"), SK = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
let Qh = class {
  constructor(t = "") {
    this.uri = t, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let n = this.uri.match(_K);
    this.scheme = n[2] || (n[1] ? "" : null), this.authority = n[4] || (n[3] ? "" : null), this.path = n[5], this.query = n[7] || (n[6] ? "" : null), this.fragment = n[9] || (n[8] ? "" : null), this.authority != null && (n = this.authority.match(SK), this.user = n[3] || null, this.password = n[4] || null, this.host = n[6] || n[7], this.port = n[9] || null);
  }
  toString() {
    return this.uri;
  }
};
const av = {}, xK = new Qh(Pt.applicationUrl);
let Pr = xK;
const $K = TK();
let XC = $K;
const F8 = () => Pr, $Ae = () => XC;
function TK() {
  const e = Pr.path, t = e.substring(0, e.lastIndexOf(e.split("/")[e.split("/").length - 1]));
  return `${`${Pr.scheme}://${Pr.host}${Pr.port != null ? `:${Pr.port}` : ""}`}${t}`;
}
function cr(e) {
  const t = { path: null, query: null }, n = new Qh(e), r = e.indexOf("?");
  return n.query === null ? t.path = e : (t.path = e.substring(0, r), t.query = N8(n.query)), n.fragment && (t.hash = n.fragment, n.query === null && (t.path = t.path.substring(0, t.path.length - (n.fragment.length + 1)))), t;
}
function N8(e) {
  const t = e.split("&"), n = {};
  for (const r of t) {
    if (!r)
      continue;
    const i = r.indexOf("=");
    let s, o;
    i < 0 ? (s = decodeURIComponent(r), o = "") : (s = decodeURIComponent(r.slice(0, i)), o = decodeURIComponent(r.slice(i + 1)));
    let a = n[s];
    typeof a == "string" && (a = n[s] = [a]), Array.isArray(a) ? a.push(o) : n[s] = o;
  }
  return n;
}
function VA(e) {
  return e && typeof e == "object" && "toJSON" in e && typeof e.toJSON == "function";
}
function Cg(e, t) {
  return e ? t && typeof t == "function" ? Object.keys(e).map((n) => encodeURIComponent(n) + "=" + encodeURIComponent(t(n, e[n]))).join("&") : Object.keys(e).map((n) => {
    const r = e[n];
    if (r == null)
      return "";
    const i = encodeURIComponent(n) + "=", s = t && t[n];
    return s ? i + encodeURIComponent(s(r)) : Array.isArray(r) ? r.map((o) => VA(o) ? i + encodeURIComponent(JSON.stringify(o)) : i + encodeURIComponent(o)).join("&") : VA(r) ? i + encodeURIComponent(JSON.stringify(r)) : i + encodeURIComponent(r);
  }).filter((n) => n).join("&") : "";
}
function EK(e = !1) {
  let t, n = Bf.proxyUrl;
  if (typeof e == "string") {
    t = PK(e);
    const r = Y_(e);
    r && (n = r.proxyUrl);
  } else
    t = !!e;
  if (!n)
    throw yK.warn(jA), new D("urlutils:proxy-not-set", jA);
  return t && q$() && (n = iO(n)), cr(n);
}
function IK(e) {
  const t = Y_(e);
  let n, r;
  if (t) {
    const i = eO(t.proxyUrl);
    n = i.path, r = i.query ? N8(i.query) : null;
  }
  if (n) {
    const i = cr(e);
    e = n + "?" + i.path;
    const s = Cg({ ...r, ...i.query });
    s && (e = `${e}?${s}`);
  }
  return e;
}
const bm = { path: "", query: "" };
function eO(e) {
  const t = e.indexOf("?");
  return t !== -1 ? (bm.path = e.slice(0, t), bm.query = e.slice(t + 1)) : (bm.path = e, bm.query = null), bm;
}
function D8(e) {
  return e = (e = g1(e = jK(e = eO(e).path), !0)).toLowerCase();
}
function MK(e) {
  const t = { proxyUrl: e.proxyUrl, urlPrefix: D8(e.urlPrefix) }, n = Bf.proxyRules, r = t.urlPrefix;
  let i = n.length;
  for (let s = 0; s < n.length; s++) {
    const o = n[s].urlPrefix;
    if (r.indexOf(o) === 0) {
      if (r.length === o.length)
        return -1;
      i = s;
      break;
    }
    o.indexOf(r) === 0 && (i = s + 1);
  }
  return n.splice(i, 0, t), i;
}
function Y_(e) {
  const t = Bf.proxyRules, n = D8(e);
  for (let r = 0; r < t.length; r++)
    if (n.indexOf(t[r].urlPrefix) === 0)
      return t[r];
}
function j8(e, t) {
  return e = zA(e), t = zA(t), g1(e) === g1(t);
}
function zA(e) {
  const t = (e = Co(e)).indexOf("/sharing");
  return t > 0 ? e.substring(0, t) : e.replace(/\/+$/, "");
}
function V8(e) {
  const t = (r) => r == null || r instanceof RegExp && r.test(e) || typeof r == "string" && e.startsWith(r), n = Bf.interceptors;
  if (n) {
    for (const r of n)
      if (Array.isArray(r.urls)) {
        if (r.urls.some(t))
          return r;
      } else if (t(r.urls))
        return r;
  }
  return null;
}
function y1(e, t, n = !1) {
  const r = W$(e), i = W$(t);
  return !(!n && r.scheme !== i.scheme) && r.host != null && i.host != null && r.host.toLowerCase() === i.host.toLowerCase() && r.port === i.port;
}
function tO(e) {
  if (typeof e == "string") {
    if (!es(e))
      return !0;
    e = W$(e);
  }
  if (y1(e, Pr))
    return !0;
  const t = Bf.trustedServers || [];
  for (let n = 0; n < t.length; n++) {
    const r = CK(t[n]);
    for (let i = 0; i < r.length; i++)
      if (y1(e, r[i]))
        return !0;
  }
  return !1;
}
function CK(e) {
  return av[e] || (rO(e) || Ma(e) ? av[e] = [new Qh(To(e))] : av[e] = [new Qh(`http://${e}`), new Qh(`https://${e}`)]), av[e];
}
function To(e, t = XC, n) {
  return Ma(e) ? n && n.preserveProtocolRelative ? e : Pr.scheme === "http" && Pr.authority === Uf(e).slice(2) ? `http:${e}` : `https:${e}` : rO(e) ? e : Xu(e[0] === "/" ? NK(t) : t, e);
}
function nO(e, t = XC, n) {
  if (!es(e))
    return e;
  const r = Co(e), i = r.toLowerCase(), s = Co(t).toLowerCase().replace(/\/+$/, ""), o = n ? Co(n).toLowerCase().replace(/\/+$/, "") : null;
  if (o && s.indexOf(o) !== 0)
    return e;
  const a = (f, m, y) => (y = f.indexOf(m, y)) === -1 ? f.length : y;
  let l = a(i, "/", i.indexOf("//") + 2), c = -1;
  for (; i.slice(0, l + 1) === s.slice(0, l) + "/" && (c = l + 1, l !== i.length); )
    l = a(i, "/", l + 1);
  if (c === -1 || o && c < o.length)
    return e;
  e = r.slice(c);
  const p = s.slice(c - 1).replace(/[^/]+/g, "").length;
  if (p > 0)
    for (let f = 0; f < p; f++)
      e = `../${e}`;
  else
    e = `./${e}`;
  return e;
}
function Co(e) {
  return e = BK(e = zK(e = VK(e = To(e = e.trim()))));
}
function Xu(...e) {
  const t = e.filter(O);
  if (!t || !t.length)
    return;
  const n = [];
  if (es(t[0])) {
    const i = t[0], s = i.indexOf("//");
    s !== -1 && (n.push(i.slice(0, s + 1)), LK(t[0]) && (n[0] += "/"), t[0] = i.slice(s + 2));
  } else
    t[0][0] === "/" && n.push("");
  const r = t.reduce((i, s) => s ? i.concat(s.split("/")) : i, []);
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    s === ".." && n.length > 0 && n[n.length - 1] !== ".." ? n.pop() : (!s && i === r.length - 1 || s && (s !== "." || n.length === 0)) && n.push(s);
  }
  return n.join("/");
}
function Uf(e, t = !1) {
  if (Q_(e) || xp(e))
    return null;
  let n = e.indexOf("://");
  if (n === -1 && Ma(e))
    n = 2;
  else {
    if (n === -1)
      return null;
    n += 3;
  }
  const r = e.indexOf("/", n);
  return r !== -1 && (e = e.slice(0, r)), t && (e = g1(e, !0)), e;
}
function es(e) {
  return Ma(e) || rO(e);
}
function Q_(e) {
  return e != null && e.slice(0, 5) === "blob:";
}
function xp(e) {
  return e.slice(0, 5) === "data:";
}
function TAe(e) {
  const t = z8(e);
  if (!t || !t.isBase64)
    return null;
  const n = atob(t.data), r = new Uint8Array(n.length);
  for (let i = 0; i < n.length; i++)
    r[i] = n.charCodeAt(i);
  return r.buffer;
}
function EAe(e) {
  return btoa(String.fromCharCode.apply(null, e)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
const OK = /^data:(.*?)(;base64)?,(.*)$/;
function z8(e) {
  const t = e.match(OK);
  if (!t)
    return null;
  const [, n, r, i] = t;
  return { mediaType: n, isBase64: !!r, data: i };
}
function B8(e) {
  return e.isBase64 ? `data:${e.mediaType};base64,${e.data}` : `data:${e.mediaType},${e.data}`;
}
function IAe(e, t) {
  kK(e, t) || AK(e, t);
}
function kK(e, t) {
  if (!e)
    return !1;
  const n = document.createElement("a");
  if (!("download" in n))
    return !1;
  const r = URL.createObjectURL(e);
  return n.download = t, n.href = r, n.style.display = "none", document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r), !0;
}
function AK(e, t) {
  return !!window.navigator.msSaveOrOpenBlob && window.navigator.msSaveOrOpenBlob(e, t);
}
function Ma(e) {
  return e != null && e !== void 0 && e[0] === "/" && e[1] === "/";
}
function rO(e) {
  return R8.test(e);
}
function PK(e) {
  return gK.test(e) || Pr.scheme === "https" && Ma(e);
}
function RK(e) {
  return L8.test(e) || Pr.scheme === "http" && Ma(e);
}
function LK(e) {
  return vK.test(e);
}
function iO(e) {
  return Ma(e) ? `https:${e}` : e.replace(L8, "https:");
}
function FK() {
  return Pr.scheme === "http";
}
function q$() {
  return Pr.scheme === "https";
}
function g1(e, t = !1) {
  return Ma(e) ? e.slice(2) : (e = e.replace(R8, ""), t && e.length > 1 && e[0] === "/" && e[1] === "/" && (e = e.slice(2)), e);
}
function NK(e) {
  const t = e.indexOf("//"), n = e.indexOf("/", t + 2);
  return n === -1 ? e : e.slice(0, n);
}
function DK(e) {
  let t = 0;
  if (es(e)) {
    const r = e.indexOf("//");
    r !== -1 && (t = r + 2);
  }
  const n = e.lastIndexOf("/");
  return n < t ? e : e.slice(0, n + 1);
}
function MAe(e, t) {
  if (!e)
    return "";
  const n = cr(e).path.replace(/\/+$/, ""), r = n.substring(n.lastIndexOf("/") + 1);
  if (t == null || !t.length)
    return r;
  const i = new RegExp(`.(${t.join("|")})$`, "ig");
  return r.replace(i, "");
}
function jK(e) {
  return e && e[e.length - 1] === "/" ? e : `${e}/`;
}
function U8(e) {
  return e.replace(/\/+$/, "");
}
function VK(e) {
  if (/^https?:\/\//i.test(e)) {
    const t = eO(e);
    e = (e = t.path.replace(/\/{2,}/g, "/")).replace("/", "//"), t.query && (e += `?${t.query}`);
  }
  return e;
}
function zK(e) {
  return e.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function BK(e) {
  const t = Bf.httpsDomains;
  if (!RK(e))
    return e;
  const n = e.indexOf("/", 7);
  let r;
  if (r = n === -1 ? e : e.slice(0, n), r = r.toLowerCase().slice(7), bK.test(r)) {
    if (!r.endsWith(":80"))
      return e;
    r = r.slice(0, -3), e = e.replace(":80", "");
  }
  return FK() && r === Pr.authority && !wK.test(e) || (q$() && r === Pr.authority || t && t.some((i) => r === i || r.endsWith(`.${i}`)) || q$() && !Y_(e)) && (e = iO(e)), e;
}
function G$(e, t, n) {
  if (!(t && n && e && es(e)))
    return e;
  const r = e.indexOf("//"), i = e.indexOf("/", r + 2), s = e.indexOf(":", r + 2), o = Math.min(i < 0 ? e.length : i, s < 0 ? e.length : s);
  return e.slice(r + 2, o).toLowerCase() !== t.toLowerCase() ? e : `${e.slice(0, r + 2)}${n}${e.slice(o)}`;
}
function W$(e) {
  return typeof e == "string" ? new Qh(To(e)) : (e.scheme || (e.scheme = Pr.scheme), e);
}
function CAe(e) {
  return qK.test(e);
}
function q8(e, t) {
  const n = cr(e), r = Object.keys(n.query || {});
  return r.length > 0 && t && t.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${r.join(", ")}.`), n.path;
}
function G8(e, t, n) {
  const r = cr(e), i = r.query || {};
  return i[t] = String(n), `${r.path}?${Cg(i)}`;
}
function BA(e, t) {
  const n = cr(e), r = n.query || {};
  for (const s in t)
    r[s] = t[s];
  const i = Cg(r);
  return i ? `${n.path}?${i}` : n.path;
}
function OAe(e) {
  if (H(e))
    return null;
  const t = e.match(UK);
  return t ? t[1] : null;
}
const UK = /.*?\.([^\/]*)$/, qK = /(^data:image\/svg|\.svg$)/i;
function xe(e, t, n) {
  let r, i;
  return t === void 0 ? (i = e, r = [void 0]) : typeof t != "string" ? (i = e, r = [void 0], n = t) : (i = t, r = Array.isArray(e) ? e : [e]), (s, o) => {
    const a = s.constructor.prototype;
    for (const l of r) {
      const c = h8(s, l, i);
      c.write && typeof c.write == "object" || (c.write = {}), n && (c.write.target = n), c.write.writer = a[o];
    }
  };
}
var ep;
(function(e) {
  e[e.CGCS2000 = 4490] = "CGCS2000", e[e.GCSMARS2000 = 104971] = "GCSMARS2000", e[e.GCSMARS2000_SPHERE = 104905] = "GCSMARS2000_SPHERE", e[e.GCSMOON2000 = 104903] = "GCSMOON2000";
})(ep || (ep = {}));
let h;
const x = { values: [1, 0.3048, 0.3048006096012192, 0.3047972654, 0.9143917962, 0.201166195164, 0.9143984146160287, 0.3047994715386762, 20.11676512155263, 20.11678249437587, 0.9143985307444408, 0.91439523, 0.3047997101815088, 20.1168, 20.116756, 5e4, 15e4], units: ["Meter", "Foot", "Foot_US", "Foot_Clarke", "Yard_Clarke", "Link_Clarke", "Yard_Sears", "Foot_Sears", "Chain_Sears", "Chain_Benoit_1895_B", "Yard_Indian", "Yard_Indian_1937", "Foot_Gold_Coast", "Chain", "Chain_Sears_1922_Truncated", "50_Kilometers", "150_Kilometers"], 2066: 5, 2136: 12, 2155: 2, 2157: 0, 2158: 0, 2159: 12, 2160: 12, 2204: 2, 2219: 0, 2220: 0, 2254: 2, 2255: 2, 2256: 1, 2265: 1, 2266: 1, 2267: 2, 2268: 2, 2269: 1, 2270: 1, 2271: 2, 2272: 2, 2273: 1, 2294: 0, 2295: 0, 2314: 3, 2899: 2, 2900: 2, 2901: 1, 2909: 1, 2910: 1, 2911: 2, 2912: 2, 2913: 1, 2914: 1, 2992: 1, 2993: 0, 2994: 1, 3080: 1, 3089: 2, 3090: 0, 3091: 2, 3102: 2, 3141: 0, 3142: 0, 3167: 14, 3359: 2, 3360: 0, 3361: 1, 3362: 0, 3363: 2, 3364: 0, 3365: 2, 3366: 3, 3404: 2, 3405: 0, 3406: 0, 3407: 3, 3439: 0, 3440: 0, 3479: 1, 3480: 0, 3481: 1, 3482: 0, 3483: 1, 3484: 0, 3485: 2, 3486: 0, 3487: 2, 3488: 0, 3489: 0, 3490: 2, 3491: 0, 3492: 2, 3493: 0, 3494: 2, 3495: 0, 3496: 2, 3497: 0, 3498: 2, 3499: 0, 3500: 2, 3501: 0, 3502: 2, 3503: 0, 3504: 2, 3505: 0, 3506: 2, 3507: 0, 3508: 2, 3509: 0, 3510: 2, 3511: 0, 3512: 2, 3513: 0, 3514: 0, 3515: 2, 3516: 0, 3517: 2, 3518: 0, 3519: 2, 3520: 0, 3521: 2, 3522: 0, 3523: 2, 3524: 0, 3525: 2, 3526: 0, 3527: 2, 3528: 0, 3529: 2, 3530: 0, 3531: 2, 3532: 0, 3533: 2, 3534: 0, 3535: 2, 3536: 0, 3537: 2, 3538: 0, 3539: 2, 3540: 0, 3541: 2, 3542: 0, 3543: 2, 3544: 0, 3545: 2, 3546: 0, 3547: 2, 3548: 0, 3549: 2, 3550: 0, 3551: 2, 3552: 0, 3553: 2, 3582: 2, 3583: 0, 3584: 2, 3585: 0, 3586: 2, 3587: 0, 3588: 1, 3589: 0, 3590: 1, 3591: 0, 3592: 0, 3593: 1, 3598: 2, 3599: 0, 3600: 2, 3605: 1, 3606: 0, 3607: 0, 3608: 2, 3609: 0, 3610: 2, 3611: 0, 3612: 2, 3613: 0, 3614: 2, 3615: 0, 3616: 2, 3617: 0, 3618: 2, 3619: 0, 3620: 2, 3621: 0, 3622: 2, 3623: 0, 3624: 2, 3625: 0, 3626: 2, 3627: 0, 3628: 2, 3629: 0, 3630: 2, 3631: 0, 3632: 2, 3633: 0, 3634: 1, 3635: 0, 3636: 1, 3640: 2, 3641: 0, 3642: 2, 3643: 0, 3644: 1, 3645: 0, 3646: 1, 3647: 0, 3648: 1, 3649: 0, 3650: 2, 3651: 0, 3652: 2, 3653: 0, 3654: 2, 3655: 0, 3656: 1, 3657: 0, 3658: 2, 3659: 0, 3660: 2, 3661: 0, 3662: 2, 3663: 0, 3664: 2, 3668: 2, 3669: 0, 3670: 2, 3671: 0, 3672: 2, 3673: 0, 3674: 2, 3675: 0, 3676: 1, 3677: 2, 3678: 0, 3679: 1, 3680: 2, 3681: 0, 3682: 1, 3683: 2, 3684: 0, 3685: 0, 3686: 2, 3687: 0, 3688: 2, 3689: 0, 3690: 2, 3691: 0, 3692: 2, 3696: 2, 3697: 0, 3698: 2, 3699: 0, 3700: 2, 3793: 0, 3794: 0, 3812: 0, 3854: 0, 3857: 0, 3920: 0, 3978: 0, 3979: 0, 3991: 2, 3992: 2, 4026: 0, 4037: 0, 4038: 0, 4071: 0, 4082: 0, 4083: 0, 4087: 0, 4088: 0, 4217: 2, 4414: 0, 4415: 0, 4417: 0, 4434: 0, 4437: 0, 4438: 2, 4439: 2, 4462: 0, 4467: 0, 4471: 0, 4474: 0, 4559: 0, 4647: 0, 4822: 0, 4826: 0, 4839: 0, 5018: 0, 5048: 0, 5167: 0, 5168: 0, 5221: 0, 5223: 0, 5234: 0, 5235: 0, 5243: 0, 5247: 0, 5266: 0, 5316: 0, 5320: 0, 5321: 0, 5325: 0, 5337: 0, 5361: 0, 5362: 0, 5367: 0, 5382: 0, 5383: 0, 5396: 0, 5456: 0, 5457: 0, 5469: 0, 5472: 4, 5490: 0, 5513: 0, 5514: 0, 5523: 0, 5559: 0, 5588: 1, 5589: 3, 5596: 0, 5627: 0, 5629: 0, 5641: 0, 5643: 0, 5644: 0, 5646: 2, 5654: 2, 5655: 2, 5659: 0, 5700: 0, 5825: 0, 5836: 0, 5837: 0, 5839: 0, 5842: 0, 5844: 0, 5858: 0, 5879: 0, 5880: 0, 5887: 0, 5890: 0, 6128: 1, 6129: 1, 6141: 1, 6204: 0, 6210: 0, 6211: 0, 6307: 0, 6312: 0, 6316: 0, 6362: 0, 6391: 1, 6405: 1, 6406: 0, 6407: 1, 6408: 0, 6409: 1, 6410: 0, 6411: 2, 6412: 0, 6413: 2, 6414: 0, 6415: 0, 6416: 2, 6417: 0, 6418: 2, 6419: 0, 6420: 2, 6421: 0, 6422: 2, 6423: 0, 6424: 2, 6425: 0, 6426: 2, 6427: 0, 6428: 2, 6429: 0, 6430: 2, 6431: 0, 6432: 2, 6433: 0, 6434: 2, 6435: 0, 6436: 2, 6437: 0, 6438: 2, 6439: 0, 6440: 0, 6441: 2, 6442: 0, 6443: 2, 6444: 0, 6445: 2, 6446: 0, 6447: 2, 6448: 0, 6449: 2, 6450: 0, 6451: 2, 6452: 0, 6453: 2, 6454: 0, 6455: 2, 6456: 0, 6457: 2, 6458: 0, 6459: 2, 6460: 0, 6461: 2, 6462: 0, 6463: 2, 6464: 0, 6465: 2, 6466: 0, 6467: 2, 6468: 0, 6469: 2, 6470: 0, 6471: 2, 6472: 0, 6473: 2, 6474: 0, 6475: 2, 6476: 0, 6477: 2, 6478: 0, 6479: 2, 6484: 2, 6485: 0, 6486: 2, 6487: 0, 6488: 2, 6489: 0, 6490: 2, 6491: 0, 6492: 2, 6493: 0, 6494: 1, 6495: 0, 6496: 1, 6497: 0, 6498: 0, 6499: 1, 6500: 0, 6501: 2, 6502: 0, 6503: 2, 6504: 0, 6505: 2, 6506: 0, 6507: 2, 6508: 0, 6509: 0, 6510: 2, 6515: 1, 6516: 0, 6518: 0, 6519: 2, 6520: 0, 6521: 2, 6522: 0, 6523: 2, 6524: 0, 6525: 2, 6526: 0, 6527: 2, 6528: 0, 6529: 2, 6530: 0, 6531: 2, 6532: 0, 6533: 2, 6534: 0, 6535: 2, 6536: 0, 6537: 2, 6538: 0, 6539: 2, 6540: 0, 6541: 2, 6542: 0, 6543: 2, 6544: 0, 6545: 1, 6546: 0, 6547: 1, 6548: 0, 6549: 2, 6550: 0, 6551: 2, 6552: 0, 6553: 2, 6554: 0, 6555: 2, 6556: 0, 6557: 1, 6558: 0, 6559: 1, 6560: 0, 6561: 1, 6562: 0, 6563: 2, 6564: 0, 6565: 2, 6566: 0, 6567: 0, 6568: 2, 6569: 0, 6570: 1, 6571: 0, 6572: 2, 6573: 0, 6574: 2, 6575: 0, 6576: 2, 6577: 0, 6578: 2, 6582: 2, 6583: 0, 6584: 2, 6585: 0, 6586: 2, 6587: 0, 6588: 2, 6589: 0, 6590: 2, 6591: 0, 6592: 0, 6593: 2, 6594: 0, 6595: 2, 6596: 0, 6597: 2, 6598: 0, 6599: 2, 6600: 0, 6601: 2, 6602: 0, 6603: 2, 6605: 2, 6606: 0, 6607: 2, 6608: 0, 6609: 2, 6610: 0, 6611: 0, 6612: 2, 6613: 0, 6614: 2, 6615: 0, 6616: 2, 6617: 0, 6618: 2, 6633: 2, 6646: 0, 6703: 0, 6784: 0, 6785: 1, 6786: 0, 6787: 1, 6788: 0, 6789: 1, 6790: 0, 6791: 1, 6792: 0, 6793: 1, 6794: 0, 6795: 1, 6796: 0, 6797: 1, 6798: 0, 6799: 1, 6800: 0, 6801: 1, 6802: 0, 6803: 1, 6804: 0, 6805: 1, 6806: 0, 6807: 1, 6808: 0, 6809: 1, 6810: 0, 6811: 1, 6812: 0, 6813: 1, 6814: 0, 6815: 1, 6816: 0, 6817: 1, 6818: 0, 6819: 1, 6820: 0, 6821: 1, 6822: 0, 6823: 1, 6824: 0, 6825: 1, 6826: 0, 6827: 1, 6828: 0, 6829: 1, 6830: 0, 6831: 1, 6832: 0, 6833: 1, 6834: 0, 6835: 1, 6836: 0, 6837: 1, 6838: 0, 6839: 1, 6840: 0, 6841: 1, 6842: 0, 6843: 1, 6844: 0, 6845: 1, 6846: 0, 6847: 1, 6848: 0, 6849: 1, 6850: 0, 6851: 1, 6852: 0, 6853: 1, 6854: 0, 6855: 1, 6856: 0, 6857: 1, 6858: 0, 6859: 1, 6860: 0, 6861: 1, 6862: 0, 6863: 1, 6867: 0, 6868: 1, 6870: 0, 6875: 0, 6876: 0, 6879: 0, 6880: 2, 6884: 0, 6885: 1, 6886: 0, 6887: 1, 6915: 0, 6922: 0, 6923: 2, 6924: 0, 6925: 2, 6962: 0, 6984: 0, 6991: 0, 7128: 2, 7131: 0, 7132: 2, 7142: 0, 7257: 0, 7258: 2, 7259: 0, 7260: 2, 7261: 0, 7262: 2, 7263: 0, 7264: 2, 7265: 0, 7266: 2, 7267: 0, 7268: 2, 7269: 0, 7270: 2, 7271: 0, 7272: 2, 7273: 0, 7274: 2, 7275: 0, 7276: 2, 7277: 0, 7278: 2, 7279: 0, 7280: 2, 7281: 0, 7282: 2, 7283: 0, 7284: 2, 7285: 0, 7286: 2, 7287: 0, 7288: 2, 7289: 0, 7290: 2, 7291: 0, 7292: 2, 7293: 0, 7294: 2, 7295: 0, 7296: 2, 7297: 0, 7298: 2, 7299: 0, 7300: 2, 7301: 0, 7302: 2, 7303: 0, 7304: 2, 7305: 0, 7306: 2, 7307: 0, 7308: 2, 7309: 0, 7310: 2, 7311: 0, 7312: 2, 7313: 0, 7314: 2, 7315: 0, 7316: 2, 7317: 0, 7318: 2, 7319: 0, 7320: 2, 7321: 0, 7322: 2, 7323: 0, 7324: 2, 7325: 0, 7326: 2, 7327: 0, 7328: 2, 7329: 0, 7330: 2, 7331: 0, 7332: 2, 7333: 0, 7334: 2, 7335: 0, 7336: 2, 7337: 0, 7338: 2, 7339: 0, 7340: 2, 7341: 0, 7342: 2, 7343: 0, 7344: 2, 7345: 0, 7346: 2, 7347: 0, 7348: 2, 7349: 0, 7350: 2, 7351: 0, 7352: 2, 7353: 0, 7354: 2, 7355: 0, 7356: 2, 7357: 0, 7358: 2, 7359: 0, 7360: 2, 7361: 0, 7362: 2, 7363: 0, 7364: 2, 7365: 0, 7366: 2, 7367: 0, 7368: 2, 7369: 0, 7370: 2, 7877: 0, 7878: 0, 7882: 0, 7883: 0, 7887: 0, 7899: 0, 7991: 0, 7992: 0, 8035: 2, 8036: 2, 8058: 0, 8059: 0, 8082: 0, 8083: 0, 8088: 0, 8090: 0, 8091: 2, 8092: 0, 8093: 2, 8095: 0, 8096: 2, 8097: 0, 8098: 2, 8099: 0, 8100: 2, 8101: 0, 8102: 2, 8103: 0, 8104: 2, 8105: 0, 8106: 2, 8107: 0, 8108: 2, 8109: 0, 8110: 2, 8111: 0, 8112: 2, 8113: 0, 8114: 2, 8115: 0, 8116: 2, 8117: 0, 8118: 2, 8119: 0, 8120: 2, 8121: 0, 8122: 2, 8123: 0, 8124: 2, 8125: 0, 8126: 2, 8127: 0, 8128: 2, 8129: 0, 8130: 2, 8131: 0, 8132: 2, 8133: 0, 8134: 2, 8135: 0, 8136: 2, 8137: 0, 8138: 2, 8139: 0, 8140: 2, 8141: 0, 8142: 2, 8143: 0, 8144: 2, 8145: 0, 8146: 2, 8147: 0, 8148: 2, 8149: 0, 8150: 2, 8151: 0, 8152: 2, 8153: 0, 8154: 2, 8155: 0, 8156: 2, 8157: 0, 8158: 2, 8159: 0, 8160: 2, 8161: 0, 8162: 2, 8163: 0, 8164: 2, 8165: 0, 8166: 2, 8167: 0, 8168: 2, 8169: 0, 8170: 2, 8171: 0, 8172: 2, 8173: 0, 8177: 2, 8179: 0, 8180: 2, 8181: 0, 8182: 2, 8184: 0, 8185: 2, 8187: 0, 8189: 2, 8191: 0, 8193: 2, 8196: 0, 8197: 2, 8198: 0, 8200: 2, 8201: 0, 8202: 2, 8203: 0, 8204: 2, 8205: 0, 8206: 2, 8207: 0, 8208: 2, 8209: 0, 8210: 2, 8212: 0, 8213: 2, 8214: 0, 8216: 2, 8218: 0, 8220: 2, 8222: 0, 8224: 2, 8225: 0, 8226: 2, 8311: 0, 8312: 1, 8313: 0, 8314: 1, 8315: 0, 8316: 1, 8317: 0, 8318: 1, 8319: 0, 8320: 1, 8321: 0, 8322: 1, 8323: 0, 8324: 1, 8325: 0, 8326: 1, 8327: 0, 8328: 1, 8329: 0, 8330: 1, 8331: 0, 8332: 1, 8333: 0, 8334: 1, 8335: 0, 8336: 1, 8337: 0, 8338: 1, 8339: 0, 8340: 1, 8341: 0, 8342: 1, 8343: 0, 8344: 1, 8345: 0, 8346: 1, 8347: 0, 8348: 1, 8352: 0, 8353: 0, 8379: 0, 8380: 2, 8381: 0, 8382: 2, 8383: 0, 8384: 2, 8385: 0, 8387: 2, 8391: 0, 8395: 0, 8433: 0, 8441: 0, 8455: 0, 8456: 0, 8531: 2, 8682: 0, 8686: 0, 8687: 0, 8692: 0, 8693: 0, 8826: 0, 8903: 0, 8950: 0, 8951: 0, 9039: 0, 9040: 0, 9141: 0, 9149: 0, 9150: 0, 9191: 0, 9221: 0, 9222: 0, 9249: 0, 9250: 0, 9252: 0, 9254: 0, 9265: 0, 9284: 0, 9285: 0, 9300: 0, 9354: 0, 9367: 0, 9373: 0, 9377: 0, 9387: 0, 9391: 0, 9456: 0, 9473: 0, 9498: 0, 9674: 0, 9678: 0, 9680: 0, 9709: 0, 9712: 0, 9713: 0, 9716: 0, 9741: 0, 9748: 2, 9749: 2, 9761: 0, 9766: 0, 20499: 0, 20538: 0, 20539: 0, 20790: 0, 20791: 0, 21291: 0, 21292: 0, 21500: 0, 21817: 0, 21818: 0, 22032: 0, 22033: 0, 22091: 0, 22092: 0, 22332: 0, 22391: 0, 22392: 0, 22700: 0, 22770: 0, 22780: 0, 22832: 0, 23090: 0, 23095: 0, 23239: 0, 23240: 0, 23433: 0, 23700: 0, 24047: 0, 24048: 0, 24100: 3, 24200: 0, 24305: 0, 24306: 0, 24382: 10, 24383: 0, 24500: 0, 24547: 0, 24548: 0, 24571: 9, 24600: 0, 25e3: 0, 25231: 0, 25884: 0, 25932: 0, 26237: 0, 26331: 0, 26332: 0, 26432: 0, 26591: 0, 26592: 0, 26632: 0, 26692: 0, 27120: 0, 27200: 0, 27291: 6, 27292: 6, 27429: 0, 27492: 0, 27493: 0, 27500: 0, 27700: 0, 28232: 0, 28600: 0, 28991: 0, 28992: 0, 29100: 0, 29101: 0, 29220: 0, 29221: 0, 29333: 0, 29635: 0, 29636: 0, 29701: 0, 29738: 0, 29739: 0, 29849: 0, 29850: 0, 29871: 8, 29872: 7, 29873: 0, 29874: 0, 30200: 5, 30339: 0, 30340: 0, 30591: 0, 30592: 0, 30791: 0, 30792: 0, 30800: 0, 31028: 0, 31121: 0, 31154: 0, 31170: 0, 31171: 0, 31370: 0, 31528: 0, 31529: 0, 31600: 0, 31700: 0, 31838: 0, 31839: 0, 31900: 0, 31901: 0, 32061: 0, 32062: 0, 32098: 0, 32099: 2, 32100: 0, 32104: 0, 32161: 0, 32766: 0, 53048: 0, 53049: 0, 54090: 0, 54091: 0, 65061: 2, 65062: 2, 65161: 0, 65163: 0, 102041: 2, 102064: 11, 102068: 15, 102069: 16, 102118: 2, 102119: 1, 102120: 2, 102121: 2, 102217: 2, 102218: 0, 102219: 2, 102220: 2, 102378: 1, 102379: 1, 102380: 0, 102381: 1, 102589: 2, 102599: 2, 102600: 2, 102604: 2, 102647: 0, 102704: 2, 102705: 2, 102706: 0, 102759: 1, 102760: 1, 102761: 2, 102762: 0, 102763: 2, 102764: 0, 102765: 0, 102766: 2, 102962: 0, 102963: 0, 102970: 1, 102974: 2, 102993: 0, 102994: 0, 102995: 2, 102996: 2, 103015: 0, 103016: 2, 103017: 0, 103018: 2, 103025: 0, 103026: 0, 103027: 2, 103028: 2, 103035: 0, 103036: 0, 103037: 2, 103038: 2, 103039: 0, 103040: 0, 103041: 2, 103042: 2, 103043: 0, 103044: 0, 103045: 2, 103046: 2, 103047: 0, 103048: 0, 103049: 2, 103050: 2, 103051: 0, 103052: 2, 103053: 0, 103054: 2, 103055: 0, 103056: 2, 103057: 0, 103058: 0, 103059: 2, 103060: 2, 103061: 0, 103062: 0, 103063: 2, 103064: 2, 103069: 2, 103070: 0, 103071: 0, 103072: 2, 103073: 2, 103086: 0, 103087: 0, 103088: 2, 103089: 2, 103094: 1, 103095: 0, 103096: 2, 103103: 0, 103104: 2, 103105: 0, 103106: 2, 103121: 0, 103122: 2, 103123: 0, 103124: 0, 103125: 1, 103126: 1, 103127: 0, 103128: 0, 103129: 2, 103130: 2, 103131: 0, 103132: 0, 103133: 2, 103134: 2, 103135: 0, 103136: 0, 103137: 1, 103138: 1, 103139: 0, 103140: 2, 103141: 0, 103142: 2, 103143: 0, 103144: 2, 103145: 0, 103146: 1, 103147: 0, 103148: 0, 103149: 2, 103150: 2, 103151: 0, 103152: 2, 103172: 0, 103173: 2, 103174: 0, 103175: 0, 103176: 2, 103177: 2, 103178: 0, 103179: 0, 103180: 2, 103181: 2, 103182: 0, 103183: 0, 103184: 2, 103185: 2, 103228: 0, 103229: 0, 103230: 2, 103231: 2, 103250: 0, 103251: 2, 103252: 0, 103253: 2, 103260: 0, 103261: 0, 103262: 2, 103263: 2, 103270: 0, 103271: 0, 103272: 2, 103273: 2, 103274: 0, 103275: 0, 103276: 2, 103277: 2, 103278: 0, 103279: 0, 103280: 2, 103281: 2, 103282: 0, 103283: 0, 103284: 2, 103285: 2, 103286: 0, 103287: 2, 103288: 0, 103289: 2, 103290: 0, 103291: 2, 103292: 0, 103293: 0, 103294: 2, 103295: 2, 103296: 0, 103297: 0, 103298: 2, 103299: 2, 103376: 2, 103377: 0, 103378: 0, 103379: 2, 103380: 2, 103393: 0, 103394: 0, 103395: 2, 103396: 2, 103472: 0, 103473: 1, 103474: 0, 103475: 2, 103482: 0, 103483: 2, 103484: 0, 103485: 2, 103500: 0, 103501: 2, 103502: 0, 103503: 0, 103504: 1, 103505: 1, 103506: 0, 103507: 0, 103508: 2, 103509: 2, 103510: 0, 103511: 0, 103512: 2, 103513: 2, 103514: 0, 103515: 2, 103516: 0, 103517: 2, 103518: 0, 103519: 2, 103520: 0, 103521: 1, 103522: 0, 103523: 0, 103524: 2, 103525: 2, 103526: 0, 103527: 2, 103561: 2, 103562: 2, 103563: 0, 103564: 0, 103565: 2, 103566: 2, 103567: 0, 103568: 0, 103569: 2, 103570: 2, 103584: 0, 103585: 2, 103586: 0, 103587: 2, 103588: 1, 103589: 0, 103590: 2, 103591: 1, 103592: 0, 103593: 2, 103594: 1, 103695: 2 };
for (h = 2e3; h <= 2045; h++)
  x[h] = 0;
for (h = 2056; h <= 2065; h++)
  x[h] = 0;
for (h = 2067; h <= 2135; h++)
  x[h] = 0;
for (h = 2137; h <= 2154; h++)
  x[h] = 0;
for (h = 2161; h <= 2170; h++)
  x[h] = 0;
for (h = 2172; h <= 2193; h++)
  x[h] = 0;
for (h = 2195; h <= 2198; h++)
  x[h] = 0;
for (h = 2200; h <= 2203; h++)
  x[h] = 0;
for (h = 2205; h <= 2217; h++)
  x[h] = 0;
for (h = 2222; h <= 2224; h++)
  x[h] = 1;
for (h = 2225; h <= 2250; h++)
  x[h] = 2;
for (h = 2251; h <= 2253; h++)
  x[h] = 1;
for (h = 2257; h <= 2264; h++)
  x[h] = 2;
for (h = 2274; h <= 2279; h++)
  x[h] = 2;
for (h = 2280; h <= 2282; h++)
  x[h] = 1;
for (h = 2283; h <= 2289; h++)
  x[h] = 2;
for (h = 2290; h <= 2292; h++)
  x[h] = 0;
for (h = 2308; h <= 2313; h++)
  x[h] = 0;
for (h = 2315; h <= 2491; h++)
  x[h] = 0;
for (h = 2494; h <= 2866; h++)
  x[h] = 0;
for (h = 2867; h <= 2869; h++)
  x[h] = 1;
for (h = 2870; h <= 2888; h++)
  x[h] = 2;
for (h = 2891; h <= 2895; h++)
  x[h] = 2;
for (h = 2896; h <= 2898; h++)
  x[h] = 1;
for (h = 2902; h <= 2908; h++)
  x[h] = 2;
for (h = 2915; h <= 2920; h++)
  x[h] = 2;
for (h = 2921; h <= 2923; h++)
  x[h] = 1;
for (h = 2924; h <= 2930; h++)
  x[h] = 2;
for (h = 2931; h <= 2962; h++)
  x[h] = 0;
for (h = 2964; h <= 2968; h++)
  x[h] = 2;
for (h = 2969; h <= 2973; h++)
  x[h] = 0;
for (h = 2975; h <= 2991; h++)
  x[h] = 0;
for (h = 2995; h <= 3051; h++)
  x[h] = 0;
for (h = 3054; h <= 3079; h++)
  x[h] = 0;
for (h = 3081; h <= 3088; h++)
  x[h] = 0;
for (h = 3092; h <= 3101; h++)
  x[h] = 0;
for (h = 3106; h <= 3138; h++)
  x[h] = 0;
for (h = 3146; h <= 3151; h++)
  x[h] = 0;
for (h = 3153; h <= 3166; h++)
  x[h] = 0;
for (h = 3168; h <= 3172; h++)
  x[h] = 0;
for (h = 3174; h <= 3203; h++)
  x[h] = 0;
for (h = 3294; h <= 3358; h++)
  x[h] = 0;
for (h = 3367; h <= 3403; h++)
  x[h] = 0;
for (h = 3408; h <= 3416; h++)
  x[h] = 0;
for (h = 3417; h <= 3438; h++)
  x[h] = 2;
for (h = 3441; h <= 3446; h++)
  x[h] = 2;
for (h = 3447; h <= 3450; h++)
  x[h] = 0;
for (h = 3451; h <= 3459; h++)
  x[h] = 2;
for (h = 3460; h <= 3478; h++)
  x[h] = 0;
for (h = 3554; h <= 3559; h++)
  x[h] = 0;
for (h = 3560; h <= 3570; h++)
  x[h] = 2;
for (h = 3571; h <= 3581; h++)
  x[h] = 0;
for (h = 3594; h <= 3597; h++)
  x[h] = 0;
for (h = 3601; h <= 3604; h++)
  x[h] = 0;
for (h = 3637; h <= 3639; h++)
  x[h] = 0;
for (h = 3665; h <= 3667; h++)
  x[h] = 0;
for (h = 3693; h <= 3695; h++)
  x[h] = 0;
for (h = 3701; h <= 3727; h++)
  x[h] = 0;
for (h = 3728; h <= 3739; h++)
  x[h] = 2;
for (h = 3740; h <= 3751; h++)
  x[h] = 0;
for (h = 3753; h <= 3760; h++)
  x[h] = 2;
for (h = 3761; h <= 3773; h++)
  x[h] = 0;
for (h = 3775; h <= 3777; h++)
  x[h] = 0;
for (h = 3779; h <= 3781; h++)
  x[h] = 0;
for (h = 3783; h <= 3785; h++)
  x[h] = 0;
for (h = 3788; h <= 3791; h++)
  x[h] = 0;
for (h = 3797; h <= 3802; h++)
  x[h] = 0;
for (h = 3814; h <= 3816; h++)
  x[h] = 0;
for (h = 3825; h <= 3829; h++)
  x[h] = 0;
for (h = 3832; h <= 3841; h++)
  x[h] = 0;
for (h = 3844; h <= 3852; h++)
  x[h] = 0;
for (h = 3873; h <= 3885; h++)
  x[h] = 0;
for (h = 3890; h <= 3893; h++)
  x[h] = 0;
for (h = 3907; h <= 3912; h++)
  x[h] = 0;
for (h = 3942; h <= 3950; h++)
  x[h] = 0;
for (h = 3968; h <= 3970; h++)
  x[h] = 0;
for (h = 3973; h <= 3976; h++)
  x[h] = 0;
for (h = 3986; h <= 3989; h++)
  x[h] = 0;
for (h = 3994; h <= 3997; h++)
  x[h] = 0;
for (h = 4048; h <= 4051; h++)
  x[h] = 0;
for (h = 4056; h <= 4063; h++)
  x[h] = 0;
for (h = 4093; h <= 4096; h++)
  x[h] = 0;
for (h = 4390; h <= 4398; h++)
  x[h] = 0;
for (h = 4399; h <= 4413; h++)
  x[h] = 2;
for (h = 4418; h <= 4433; h++)
  x[h] = 2;
for (h = 4455; h <= 4457; h++)
  x[h] = 2;
for (h = 4484; h <= 4489; h++)
  x[h] = 0;
for (h = 4491; h <= 4554; h++)
  x[h] = 0;
for (h = 4568; h <= 4589; h++)
  x[h] = 0;
for (h = 4652; h <= 4656; h++)
  x[h] = 0;
for (h = 4766; h <= 4800; h++)
  x[h] = 0;
for (h = 5014; h <= 5016; h++)
  x[h] = 0;
for (h = 5069; h <= 5072; h++)
  x[h] = 0;
for (h = 5105; h <= 5130; h++)
  x[h] = 0;
for (h = 5173; h <= 5188; h++)
  x[h] = 0;
for (h = 5253; h <= 5259; h++)
  x[h] = 0;
for (h = 5269; h <= 5275; h++)
  x[h] = 0;
for (h = 5292; h <= 5311; h++)
  x[h] = 0;
for (h = 5329; h <= 5331; h++)
  x[h] = 0;
for (h = 5343; h <= 5349; h++)
  x[h] = 0;
for (h = 5355; h <= 5357; h++)
  x[h] = 0;
for (h = 5387; h <= 5389; h++)
  x[h] = 0;
for (h = 5459; h <= 5463; h++)
  x[h] = 0;
for (h = 5479; h <= 5482; h++)
  x[h] = 0;
for (h = 5518; h <= 5520; h++)
  x[h] = 0;
for (h = 5530; h <= 5539; h++)
  x[h] = 0;
for (h = 5550; h <= 5552; h++)
  x[h] = 0;
for (h = 5562; h <= 5583; h++)
  x[h] = 0;
for (h = 5623; h <= 5625; h++)
  x[h] = 2;
for (h = 5631; h <= 5639; h++)
  x[h] = 0;
for (h = 5649; h <= 5653; h++)
  x[h] = 0;
for (h = 5663; h <= 5680; h++)
  x[h] = 0;
for (h = 5682; h <= 5685; h++)
  x[h] = 0;
for (h = 5875; h <= 5877; h++)
  x[h] = 0;
for (h = 5896; h <= 5899; h++)
  x[h] = 0;
for (h = 5921; h <= 5940; h++)
  x[h] = 0;
for (h = 6050; h <= 6125; h++)
  x[h] = 0;
for (h = 6244; h <= 6275; h++)
  x[h] = 0;
for (h = 6328; h <= 6348; h++)
  x[h] = 0;
for (h = 6350; h <= 6356; h++)
  x[h] = 0;
for (h = 6366; h <= 6372; h++)
  x[h] = 0;
for (h = 6381; h <= 6387; h++)
  x[h] = 0;
for (h = 6393; h <= 6404; h++)
  x[h] = 0;
for (h = 6480; h <= 6483; h++)
  x[h] = 0;
for (h = 6511; h <= 6514; h++)
  x[h] = 0;
for (h = 6579; h <= 6581; h++)
  x[h] = 0;
for (h = 6619; h <= 6624; h++)
  x[h] = 0;
for (h = 6625; h <= 6627; h++)
  x[h] = 2;
for (h = 6628; h <= 6632; h++)
  x[h] = 0;
for (h = 6634; h <= 6637; h++)
  x[h] = 0;
for (h = 6669; h <= 6692; h++)
  x[h] = 0;
for (h = 6707; h <= 6709; h++)
  x[h] = 0;
for (h = 6720; h <= 6723; h++)
  x[h] = 0;
for (h = 6732; h <= 6738; h++)
  x[h] = 0;
for (h = 6931; h <= 6933; h++)
  x[h] = 0;
for (h = 6956; h <= 6959; h++)
  x[h] = 0;
for (h = 7005; h <= 7007; h++)
  x[h] = 0;
for (h = 7057; h <= 7070; h++)
  x[h] = 2;
for (h = 7074; h <= 7082; h++)
  x[h] = 0;
for (h = 7109; h <= 7118; h++)
  x[h] = 0;
for (h = 7119; h <= 7127; h++)
  x[h] = 1;
for (h = 7374; h <= 7376; h++)
  x[h] = 0;
for (h = 7528; h <= 7586; h++)
  x[h] = 0;
for (h = 7587; h <= 7645; h++)
  x[h] = 2;
for (h = 7692; h <= 7696; h++)
  x[h] = 0;
for (h = 7755; h <= 7787; h++)
  x[h] = 0;
for (h = 7791; h <= 7795; h++)
  x[h] = 0;
for (h = 7799; h <= 7801; h++)
  x[h] = 0;
for (h = 7803; h <= 7805; h++)
  x[h] = 0;
for (h = 7825; h <= 7831; h++)
  x[h] = 0;
for (h = 7845; h <= 7859; h++)
  x[h] = 0;
for (h = 8013; h <= 8032; h++)
  x[h] = 0;
for (h = 8065; h <= 8068; h++)
  x[h] = 1;
for (h = 8518; h <= 8529; h++)
  x[h] = 2;
for (h = 8533; h <= 8536; h++)
  x[h] = 2;
for (h = 8538; h <= 8540; h++)
  x[h] = 2;
for (h = 8677; h <= 8679; h++)
  x[h] = 0;
for (h = 8836; h <= 8840; h++)
  x[h] = 0;
for (h = 8857; h <= 8859; h++)
  x[h] = 0;
for (h = 8908; h <= 8910; h++)
  x[h] = 0;
for (h = 9154; h <= 9159; h++)
  x[h] = 0;
for (h = 9205; h <= 9218; h++)
  x[h] = 0;
for (h = 9271; h <= 9273; h++)
  x[h] = 0;
for (h = 9295; h <= 9297; h++)
  x[h] = 0;
for (h = 9356; h <= 9360; h++)
  x[h] = 0;
for (h = 9404; h <= 9407; h++)
  x[h] = 0;
for (h = 9476; h <= 9482; h++)
  x[h] = 0;
for (h = 9487; h <= 9494; h++)
  x[h] = 0;
for (h = 9697; h <= 9699; h++)
  x[h] = 0;
for (h = 20002; h <= 20032; h++)
  x[h] = 0;
for (h = 20062; h <= 20092; h++)
  x[h] = 0;
for (h = 20135; h <= 20138; h++)
  x[h] = 0;
for (h = 20248; h <= 20258; h++)
  x[h] = 0;
for (h = 20348; h <= 20358; h++)
  x[h] = 0;
for (h = 20436; h <= 20440; h++)
  x[h] = 0;
for (h = 20822; h <= 20824; h++)
  x[h] = 0;
for (h = 20904; h <= 20932; h++)
  x[h] = 0;
for (h = 20934; h <= 20936; h++)
  x[h] = 0;
for (h = 21004; h <= 21032; h++)
  x[h] = 0;
for (h = 21035; h <= 21037; h++)
  x[h] = 0;
for (h = 21095; h <= 21097; h++)
  x[h] = 0;
for (h = 21148; h <= 21150; h++)
  x[h] = 0;
for (h = 21207; h <= 21264; h++)
  x[h] = 0;
for (h = 21307; h <= 21364; h++)
  x[h] = 0;
for (h = 21413; h <= 21423; h++)
  x[h] = 0;
for (h = 21453; h <= 21463; h++)
  x[h] = 0;
for (h = 21473; h <= 21483; h++)
  x[h] = 0;
for (h = 21780; h <= 21782; h++)
  x[h] = 0;
for (h = 21891; h <= 21894; h++)
  x[h] = 0;
for (h = 21896; h <= 21899; h++)
  x[h] = 0;
for (h = 22171; h <= 22177; h++)
  x[h] = 0;
for (h = 22181; h <= 22187; h++)
  x[h] = 0;
for (h = 22191; h <= 22197; h++)
  x[h] = 0;
for (h = 22234; h <= 22236; h++)
  x[h] = 0;
for (h = 22521; h <= 22525; h++)
  x[h] = 0;
for (h = 22991; h <= 22994; h++)
  x[h] = 0;
for (h = 23028; h <= 23038; h++)
  x[h] = 0;
for (h = 23830; h <= 23853; h++)
  x[h] = 0;
for (h = 23866; h <= 23872; h++)
  x[h] = 0;
for (h = 23877; h <= 23884; h++)
  x[h] = 0;
for (h = 23886; h <= 23894; h++)
  x[h] = 0;
for (h = 23946; h <= 23948; h++)
  x[h] = 0;
for (h = 24311; h <= 24313; h++)
  x[h] = 0;
for (h = 24342; h <= 24347; h++)
  x[h] = 0;
for (h = 24370; h <= 24374; h++)
  x[h] = 10;
for (h = 24375; h <= 24381; h++)
  x[h] = 0;
for (h = 24718; h <= 24721; h++)
  x[h] = 0;
for (h = 24817; h <= 24821; h++)
  x[h] = 0;
for (h = 24877; h <= 24882; h++)
  x[h] = 0;
for (h = 24891; h <= 24893; h++)
  x[h] = 0;
for (h = 25391; h <= 25395; h++)
  x[h] = 0;
for (h = 25828; h <= 25838; h++)
  x[h] = 0;
for (h = 26191; h <= 26195; h++)
  x[h] = 0;
for (h = 26391; h <= 26393; h++)
  x[h] = 0;
for (h = 26701; h <= 26722; h++)
  x[h] = 0;
for (h = 26729; h <= 26799; h++)
  x[h] = 2;
for (h = 26801; h <= 26803; h++)
  x[h] = 2;
for (h = 26811; h <= 26813; h++)
  x[h] = 2;
for (h = 26847; h <= 26870; h++)
  x[h] = 2;
for (h = 26891; h <= 26899; h++)
  x[h] = 0;
for (h = 26901; h <= 26923; h++)
  x[h] = 0;
for (h = 26929; h <= 26946; h++)
  x[h] = 0;
for (h = 26948; h <= 26998; h++)
  x[h] = 0;
for (h = 27037; h <= 27040; h++)
  x[h] = 0;
for (h = 27205; h <= 27232; h++)
  x[h] = 0;
for (h = 27258; h <= 27260; h++)
  x[h] = 0;
for (h = 27391; h <= 27398; h++)
  x[h] = 0;
for (h = 27561; h <= 27564; h++)
  x[h] = 0;
for (h = 27571; h <= 27574; h++)
  x[h] = 0;
for (h = 27581; h <= 27584; h++)
  x[h] = 0;
for (h = 27591; h <= 27594; h++)
  x[h] = 0;
for (h = 28191; h <= 28193; h++)
  x[h] = 0;
for (h = 28348; h <= 28358; h++)
  x[h] = 0;
for (h = 28402; h <= 28432; h++)
  x[h] = 0;
for (h = 28462; h <= 28492; h++)
  x[h] = 0;
for (h = 29118; h <= 29122; h++)
  x[h] = 0;
for (h = 29168; h <= 29172; h++)
  x[h] = 0;
for (h = 29177; h <= 29185; h++)
  x[h] = 0;
for (h = 29187; h <= 29195; h++)
  x[h] = 0;
for (h = 29900; h <= 29903; h++)
  x[h] = 0;
for (h = 30161; h <= 30179; h++)
  x[h] = 0;
for (h = 30491; h <= 30494; h++)
  x[h] = 0;
for (h = 30729; h <= 30732; h++)
  x[h] = 0;
for (h = 31251; h <= 31259; h++)
  x[h] = 0;
for (h = 31265; h <= 31268; h++)
  x[h] = 0;
for (h = 31275; h <= 31279; h++)
  x[h] = 0;
for (h = 31281; h <= 31297; h++)
  x[h] = 0;
for (h = 31461; h <= 31469; h++)
  x[h] = 0;
for (h = 31491; h <= 31495; h++)
  x[h] = 0;
for (h = 31917; h <= 31922; h++)
  x[h] = 0;
for (h = 31965; h <= 32e3; h++)
  x[h] = 0;
for (h = 32001; h <= 32003; h++)
  x[h] = 2;
for (h = 32005; h <= 32031; h++)
  x[h] = 2;
for (h = 32033; h <= 32060; h++)
  x[h] = 2;
for (h = 32064; h <= 32067; h++)
  x[h] = 2;
for (h = 32074; h <= 32077; h++)
  x[h] = 2;
for (h = 32081; h <= 32086; h++)
  x[h] = 0;
for (h = 32107; h <= 32130; h++)
  x[h] = 0;
for (h = 32133; h <= 32158; h++)
  x[h] = 0;
for (h = 32164; h <= 32167; h++)
  x[h] = 2;
for (h = 32180; h <= 32199; h++)
  x[h] = 0;
for (h = 32201; h <= 32260; h++)
  x[h] = 0;
for (h = 32301; h <= 32360; h++)
  x[h] = 0;
for (h = 32601; h <= 32662; h++)
  x[h] = 0;
for (h = 32664; h <= 32667; h++)
  x[h] = 2;
for (h = 32701; h <= 32761; h++)
  x[h] = 0;
for (h = 53001; h <= 53004; h++)
  x[h] = 0;
for (h = 53008; h <= 53019; h++)
  x[h] = 0;
for (h = 53021; h <= 53032; h++)
  x[h] = 0;
for (h = 53034; h <= 53037; h++)
  x[h] = 0;
for (h = 53042; h <= 53046; h++)
  x[h] = 0;
for (h = 53074; h <= 53080; h++)
  x[h] = 0;
for (h = 54001; h <= 54004; h++)
  x[h] = 0;
for (h = 54008; h <= 54019; h++)
  x[h] = 0;
for (h = 54021; h <= 54032; h++)
  x[h] = 0;
for (h = 54034; h <= 54037; h++)
  x[h] = 0;
for (h = 54042; h <= 54046; h++)
  x[h] = 0;
for (h = 54048; h <= 54053; h++)
  x[h] = 0;
for (h = 54074; h <= 54080; h++)
  x[h] = 0;
for (h = 54098; h <= 54101; h++)
  x[h] = 0;
for (h = 102001; h <= 102040; h++)
  x[h] = 0;
for (h = 102042; h <= 102063; h++)
  x[h] = 0;
for (h = 102065; h <= 102067; h++)
  x[h] = 0;
for (h = 102070; h <= 102117; h++)
  x[h] = 0;
for (h = 102122; h <= 102216; h++)
  x[h] = 0;
for (h = 102221; h <= 102377; h++)
  x[h] = 0;
for (h = 102382; h <= 102388; h++)
  x[h] = 0;
for (h = 102389; h <= 102398; h++)
  x[h] = 2;
for (h = 102399; h <= 102444; h++)
  x[h] = 0;
for (h = 102445; h <= 102447; h++)
  x[h] = 2;
for (h = 102448; h <= 102458; h++)
  x[h] = 0;
for (h = 102459; h <= 102468; h++)
  x[h] = 2;
for (h = 102469; h <= 102499; h++)
  x[h] = 0;
for (h = 102500; h <= 102519; h++)
  x[h] = 1;
for (h = 102520; h <= 102524; h++)
  x[h] = 0;
for (h = 102525; h <= 102529; h++)
  x[h] = 2;
for (h = 102530; h <= 102588; h++)
  x[h] = 0;
for (h = 102590; h <= 102598; h++)
  x[h] = 0;
for (h = 102601; h <= 102603; h++)
  x[h] = 0;
for (h = 102605; h <= 102628; h++)
  x[h] = 0;
for (h = 102629; h <= 102646; h++)
  x[h] = 2;
for (h = 102648; h <= 102700; h++)
  x[h] = 2;
for (h = 102701; h <= 102703; h++)
  x[h] = 0;
for (h = 102707; h <= 102730; h++)
  x[h] = 2;
for (h = 102733; h <= 102758; h++)
  x[h] = 2;
for (h = 102767; h <= 102900; h++)
  x[h] = 0;
for (h = 102901; h <= 102933; h++)
  x[h] = 2;
for (h = 102934; h <= 102950; h++)
  x[h] = 13;
for (h = 102951; h <= 102960; h++)
  x[h] = 0;
for (h = 102965; h <= 102969; h++)
  x[h] = 0;
for (h = 102971; h <= 102973; h++)
  x[h] = 0;
for (h = 102975; h <= 102989; h++)
  x[h] = 0;
for (h = 102990; h <= 102992; h++)
  x[h] = 1;
for (h = 102997; h <= 103002; h++)
  x[h] = 0;
for (h = 103003; h <= 103008; h++)
  x[h] = 2;
for (h = 103009; h <= 103011; h++)
  x[h] = 0;
for (h = 103012; h <= 103014; h++)
  x[h] = 2;
for (h = 103019; h <= 103021; h++)
  x[h] = 0;
for (h = 103022; h <= 103024; h++)
  x[h] = 2;
for (h = 103029; h <= 103031; h++)
  x[h] = 0;
for (h = 103032; h <= 103034; h++)
  x[h] = 2;
for (h = 103065; h <= 103068; h++)
  x[h] = 0;
for (h = 103074; h <= 103076; h++)
  x[h] = 0;
for (h = 103077; h <= 103079; h++)
  x[h] = 1;
for (h = 103080; h <= 103082; h++)
  x[h] = 0;
for (h = 103083; h <= 103085; h++)
  x[h] = 2;
for (h = 103090; h <= 103093; h++)
  x[h] = 0;
for (h = 103097; h <= 103099; h++)
  x[h] = 0;
for (h = 103100; h <= 103102; h++)
  x[h] = 2;
for (h = 103107; h <= 103109; h++)
  x[h] = 0;
for (h = 103110; h <= 103112; h++)
  x[h] = 2;
for (h = 103113; h <= 103116; h++)
  x[h] = 0;
for (h = 103117; h <= 103120; h++)
  x[h] = 2;
for (h = 103153; h <= 103157; h++)
  x[h] = 0;
for (h = 103158; h <= 103162; h++)
  x[h] = 2;
for (h = 103163; h <= 103165; h++)
  x[h] = 0;
for (h = 103166; h <= 103168; h++)
  x[h] = 1;
for (h = 103169; h <= 103171; h++)
  x[h] = 2;
for (h = 103186; h <= 103188; h++)
  x[h] = 0;
for (h = 103189; h <= 103191; h++)
  x[h] = 2;
for (h = 103192; h <= 103195; h++)
  x[h] = 0;
for (h = 103196; h <= 103199; h++)
  x[h] = 2;
for (h = 103200; h <= 103224; h++)
  x[h] = 0;
for (h = 103225; h <= 103227; h++)
  x[h] = 1;
for (h = 103232; h <= 103237; h++)
  x[h] = 0;
for (h = 103238; h <= 103243; h++)
  x[h] = 2;
for (h = 103244; h <= 103246; h++)
  x[h] = 0;
for (h = 103247; h <= 103249; h++)
  x[h] = 2;
for (h = 103254; h <= 103256; h++)
  x[h] = 0;
for (h = 103257; h <= 103259; h++)
  x[h] = 2;
for (h = 103264; h <= 103266; h++)
  x[h] = 0;
for (h = 103267; h <= 103269; h++)
  x[h] = 2;
for (h = 103300; h <= 103375; h++)
  x[h] = 0;
for (h = 103381; h <= 103383; h++)
  x[h] = 0;
for (h = 103384; h <= 103386; h++)
  x[h] = 1;
for (h = 103387; h <= 103389; h++)
  x[h] = 0;
for (h = 103390; h <= 103392; h++)
  x[h] = 2;
for (h = 103397; h <= 103399; h++)
  x[h] = 0;
for (h = 103400; h <= 103471; h++)
  x[h] = 2;
for (h = 103476; h <= 103478; h++)
  x[h] = 0;
for (h = 103479; h <= 103481; h++)
  x[h] = 2;
for (h = 103486; h <= 103488; h++)
  x[h] = 0;
for (h = 103489; h <= 103491; h++)
  x[h] = 2;
for (h = 103492; h <= 103495; h++)
  x[h] = 0;
for (h = 103496; h <= 103499; h++)
  x[h] = 2;
for (h = 103528; h <= 103543; h++)
  x[h] = 0;
for (h = 103544; h <= 103548; h++)
  x[h] = 2;
for (h = 103549; h <= 103551; h++)
  x[h] = 0;
for (h = 103552; h <= 103554; h++)
  x[h] = 1;
for (h = 103555; h <= 103557; h++)
  x[h] = 2;
for (h = 103558; h <= 103560; h++)
  x[h] = 0;
for (h = 103571; h <= 103573; h++)
  x[h] = 0;
for (h = 103574; h <= 103576; h++)
  x[h] = 2;
for (h = 103577; h <= 103580; h++)
  x[h] = 0;
for (h = 103581; h <= 103583; h++)
  x[h] = 2;
for (h = 103595; h <= 103694; h++)
  x[h] = 0;
for (h = 103696; h <= 103699; h++)
  x[h] = 0;
for (h = 103700; h <= 103793; h++)
  x[h] = 2;
for (h = 103794; h <= 103872; h++)
  x[h] = 0;
for (h = 103900; h <= 103971; h++)
  x[h] = 2;
const GK = { 102113: !0, 102100: !0, 3857: !0, 3785: !0 }, WK = { 102113: !0, 102100: !0, 3857: !0, 3785: !0, 4326: !0 }, UA = 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]', lv = [-20037508342788905e-9, 20037508342788905e-9], uv = [-20037508342787e-6, 20037508342787e-6], W8 = { 102113: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: lv, origin: uv, dx: 1e-5 }, 102100: { wkTemplate: UA, valid: lv, origin: uv, dx: 1e-5 }, 3785: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: lv, origin: uv, dx: 1e-5 }, 3857: { wkTemplate: UA, valid: lv, origin: uv, dx: 1e-5 }, 4326: { wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]', altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104971: { wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104905: { wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 } };
function Oi(e, t) {
  return !H(e) && !H(t) && (e === t || (e.wkid != null || t.wkid != null ? e.wkid === t.wkid || tp(e) && tp(t) || t.latestWkid != null && e.wkid === t.latestWkid || e.latestWkid != null && t.wkid === e.latestWkid : !(!e.wkt || !t.wkt) && e.wkt.toUpperCase() === t.wkt.toUpperCase()));
}
function Oo(e) {
  return Mi(e) && e.wkid ? W8[e.wkid] : null;
}
function H8(e) {
  return !!Mi(e) && (e.wkid ? x[e.wkid] == null : !!e.wkt && !!/^\s*GEOGCS/i.test(e.wkt));
}
function HK(e) {
  return !(X_(e) || eS(e));
}
function Og(e) {
  return Mi(e) && e.wkid === 4326;
}
function kAe(e) {
  return Mi(e) && e.wkid === ep.CGCS2000;
}
function tp(e) {
  return Mi(e) && e.wkid != null && GK[e.wkid] === !0;
}
function JK(e) {
  return Mi(e) && e.wkid === 32662;
}
function sO(e) {
  return e === ep.GCSMARS2000 || e === ep.GCSMARS2000_SPHERE;
}
function X_(e) {
  return Mi(e) && e.wkid != null && sO(e.wkid);
}
function oO(e) {
  return e === ep.GCSMOON2000;
}
function eS(e) {
  return Mi(e) && e.wkid != null && oO(e.wkid);
}
function ZK(e) {
  return Mi(e) && e.wkid != null && WK[e.wkid] === !0;
}
function Mi(e) {
  return O(e) && (e.wkid != null && e.wkid >= 2e3 || e.wkt != null);
}
const KK = { wkid: 4326, wkt: Ta(W8[4326].wkTemplate, { Central_Meridian: "0.0" }) }, YK = { wkid: 102100, latestWkid: 3857 }, QK = { wkid: 32662 };
var Wo;
let Ot = Wo = class extends se {
  constructor(e) {
    super(e), this.latestWkid = null, this.wkid = null, this.wkt = null, this.vcsWkid = null, this.latestVcsWkid = null, this.imageCoordinateSystem = null;
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.wkid) {
      if (e.wkid === 102100)
        return Wo.WebMercator;
      if (e.wkid === 4326)
        return Wo.WGS84;
    }
    const t = new Wo();
    return t.read(e), t;
  }
  normalizeCtorArgs(e) {
    return e && typeof e == "object" ? e : { [typeof e == "string" ? "wkt" : "wkid"]: e };
  }
  get isWGS84() {
    return Og(this);
  }
  get isWebMercator() {
    return tp(this);
  }
  get isGeographic() {
    return H8(this);
  }
  get isWrappable() {
    return ZK(this);
  }
  writeWkt(e, t) {
    this.wkid || (t.wkt = e);
  }
  clone() {
    if (this === Wo.WGS84)
      return Wo.WGS84;
    if (this === Wo.WebMercator)
      return Wo.WebMercator;
    const e = new Wo();
    return this.wkid != null ? (e.wkid = this.wkid, this.latestWkid != null && (e.latestWkid = this.latestWkid), this.vcsWkid != null && (e.vcsWkid = this.vcsWkid), this.latestVcsWkid != null && (e.latestVcsWkid = this.latestVcsWkid)) : this.wkt != null && (e.wkt = this.wkt), this.imageCoordinateSystem && (e.imageCoordinateSystem = q(this.imageCoordinateSystem)), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    if (this.imageCoordinateSystem || e.imageCoordinateSystem) {
      if (this.imageCoordinateSystem == null || e.imageCoordinateSystem == null)
        return !1;
      const { id: t, referenceServiceName: n } = e.imageCoordinateSystem, { geodataXform: r } = e.imageCoordinateSystem, i = this.imageCoordinateSystem;
      return t == null || r ? JSON.stringify(i) === JSON.stringify(e.imageCoordinateSystem) : n ? i.id === t && i.referenceServiceName === n : i.id === t;
    }
    return Oi(this, e);
  }
  toJSON(e) {
    return this.write(void 0, e);
  }
};
Ot.GCS_NAD_1927 = null, Ot.WGS84 = null, Ot.WebMercator = null, Ot.PlateCarree = null, u([d({ readOnly: !0 })], Ot.prototype, "isWGS84", null), u([d({ readOnly: !0 })], Ot.prototype, "isWebMercator", null), u([d({ readOnly: !0 })], Ot.prototype, "isGeographic", null), u([d({ readOnly: !0 })], Ot.prototype, "isWrappable", null), u([d({ type: Vt, json: { write: !0 } })], Ot.prototype, "latestWkid", void 0), u([d({ type: Vt, json: { write: !0, origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkt === null };
} } } } } })], Ot.prototype, "wkid", void 0), u([d({ type: String, json: { origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkid === null };
} } } } } })], Ot.prototype, "wkt", void 0), u([xe("wkt"), xe("web-scene", "wkt")], Ot.prototype, "writeWkt", null), u([d({ type: Vt, json: { write: !0 } })], Ot.prototype, "vcsWkid", void 0), u([d({ type: Vt, json: { write: !0 } })], Ot.prototype, "latestVcsWkid", void 0), u([d()], Ot.prototype, "imageCoordinateSystem", void 0), Ot = Wo = u([T("geoscene.geometry.SpatialReference")], Ot), Ot.prototype.toJSON.isDefaultToJSON = !0, Ot.GCS_NAD_1927 = new Ot({ wkid: 4267, wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]' }), Ot.WGS84 = new Ot(KK), Ot.WebMercator = new Ot(YK), Ot.PlateCarree = new Ot(QK), Object.freeze && (Object.freeze(Ot.GCS_NAD_1927), Object.freeze(Ot.WGS84), Object.freeze(Ot.WebMercator));
const Qe = Ot, J8 = "20220404", Z8 = "ecb69ff5e08a61c162de0ddc0b1f397ed5d4071b", K8 = "4.23", XK = { async request(e, t) {
  var n;
  const { default: r } = await Promise.resolve().then(() => fY), i = e.options, s = i.responseType;
  i.signal = t == null ? void 0 : t.signal, i.responseType = s === "native" || s === "native-request-init" ? "native-request-init" : ["blob", "json", "text"].includes(s) && (n = V8(e.url)) != null && n.after ? s : "array-buffer";
  const o = await r(e.url, i), a = { data: o.data, ssl: o.ssl };
  switch (o.requestOptions.responseType) {
    case "native-request-init":
      return delete a.data.signal, a;
    case "blob":
      a.data = await a.data.arrayBuffer();
      break;
    case "json":
      a.data = new TextEncoder().encode(JSON.stringify(a.data)).buffer;
      break;
    case "text":
      a.data = new TextEncoder().encode(a.data).buffer;
  }
  return { result: a, transferList: [a.data] };
} };
let En;
function AAe(e) {
  En = e;
}
function eY(e) {
  const t = En && En.findCredential(e);
  return t && t.token ? G8(e, "token", t.token) : e;
}
K("host-webworker") || (K("edge") || K("trident")) && console.warn("Deprecated browser - see https://doc.geoscene.cn/javascript/latest/system-requirements/");
const tY = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function Y8(e) {
  const t = Uf(e, !0);
  return t && t.endsWith(".arcgis.com") && !tY.includes(t) && !e.endsWith("/sharing/rest/generateToken");
}
function nY(e, t, n = !1, r) {
  return new Promise((i, s) => {
    if (Ea(r))
      return void s(qA());
    let o = () => {
      c(), s(new Error(`Unable to load ${t}`));
    }, a = () => {
      const p = e;
      c(), i(p);
    }, l = () => {
      if (!e)
        return;
      const p = e;
      c(), p.src = "", s(qA());
    };
    const c = () => {
      K("geoscene-image-decode") || (e.removeEventListener("error", o), e.removeEventListener("load", a)), o = null, a = null, e = null, O(r) && r.removeEventListener("abort", l), l = null, n && URL.revokeObjectURL(t);
    };
    O(r) && r.addEventListener("abort", l), K("geoscene-image-decode") ? e.decode().then(a, o) : (e.addEventListener("error", o), e.addEventListener("load", a));
  });
}
function qA() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const e = new Error();
    return e.name = "AbortError", e;
  }
}
async function rn(e, t) {
  var n;
  const r = xp(e), i = Q_(e);
  i || r || (e = Co(e));
  const s = { url: e, requestOptions: { ...t } };
  let o = V8(e);
  if (o) {
    const p = await cY(o, s);
    if (p != null)
      return { data: p, getHeader: aO, requestOptions: s.requestOptions, url: s.url };
    o.after || o.error || (o = null);
  }
  if (e = s.url, (t = s.requestOptions).responseType === "image") {
    if (K("host-webworker") || K("host-node"))
      throw Eo("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), s);
  } else if (r)
    throw Eo("request:invalid-parameters", new Error("Data URLs are not supported for responseType = " + t.responseType), s);
  if (t.method === "head") {
    if (t.body)
      throw Eo("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), s);
    if (r || i)
      throw Eo("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), s);
  }
  if (await aY(), v1)
    return v1.execute(e, t);
  const a = new AbortController();
  Ao(t, () => a.abort());
  const l = { controller: a, credential: null, credentialToken: null, fetchOptions: null, hasToken: !1, interceptor: o, params: s, redoRequest: !1, useIdentity: pl.useIdentity, useProxy: !1, useSSL: !1, withCredentials: !1 }, c = await pY(l);
  return (n = o) == null || n.after == null || n.after(c), c;
}
let v1;
const pl = Pt.request, Q8 = "FormData" in globalThis, rY = [499, 498, 403, 401], iY = ["COM_0056", "COM_0057", "SB_0008"], sY = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i], aO = () => null, H$ = Symbol();
function oY(e) {
  const t = Uf(e);
  t && !rn._corsServers.includes(t) && rn._corsServers.push(t);
}
function GA(e) {
  const t = Uf(e);
  return !t || t.endsWith(".arcgis.com") || rn._corsServers.includes(t) || tO(t);
}
function Eo(e, t, n, r) {
  let i = "Error";
  const s = { url: n.url, requestOptions: n.requestOptions, getHeader: aO, ssl: !1 };
  if (t instanceof D)
    return t.details ? (t.details = q(t.details), t.details.url = n.url, t.details.requestOptions = n.requestOptions) : t.details = s, t;
  if (t) {
    const o = r && ((c) => r.headers.get(c)), a = r && r.status, l = t.message;
    l && (i = l), o && (s.getHeader = o), s.httpStatus = (t.httpCode != null ? t.httpCode : t.code) || a || 0, s.subCode = t.subcode, s.messageCode = t.messageCode, typeof t.details == "string" ? s.messages = [t.details] : s.messages = t.details, s.raw = H$ in t ? t[H$] : t;
  }
  return Ws(t) ? Cn() : new D(e, i, s);
}
async function aY() {
  K("host-webworker") ? v1 || (v1 = await import("./request-b5q-AX0D.js")) : rn._abortableFetch || (rn._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function J$() {
  En || await import("./IdentityManager-Dqa0R8pG.js");
}
async function lY(e) {
  const t = e.params.url, n = e.params.requestOptions, r = e.controller.signal, i = n.body;
  let s = null, o = null, a = null;
  if (Q8 && "HTMLFormElement" in globalThis && (i instanceof FormData ? s = i : i instanceof HTMLFormElement && (o = i, s = new FormData(o))), typeof i == "string" && (a = i), e.fetchOptions = { cache: n.cacheBust && !rn._abortableFetch.polyfill ? "no-cache" : "default", credentials: "same-origin", headers: n.headers || {}, method: n.method === "head" ? "HEAD" : "GET", mode: "cors", redirect: "follow", signal: r }, (s || a) && (e.fetchOptions.body = s || a), n.authMode === "anonymous" && (e.useIdentity = !1), e.hasToken = !!(/token=/i.test(t) || n.query && n.query.token || s && s.get && s.get("token") || o && o.elements.token), !e.hasToken && Pt.apiKey && Y8(t) && (n.query || (n.query = {}), n.query.token = Pt.apiKey, e.hasToken = !0), e.useIdentity && !e.hasToken && !e.credentialToken && !X8(t) && !Ea(r)) {
    let l;
    n.authMode === "immediate" ? (await J$(), l = await En.getCredential(t, { signal: r }), e.credential = l) : n.authMode === "no-prompt" ? (await J$(), l = await En.getCredential(t, { prompt: !1, signal: r }).catch(() => {
    }), e.credential = l) : En && (l = En.findCredential(t)), l && (e.credentialToken = l.token, e.useSSL = !!l.ssl);
  }
}
function X8(e) {
  return sY.some((t) => t.test(e));
}
async function uY(e) {
  let t = e.params.url;
  const n = e.params.requestOptions, r = e.fetchOptions, i = Q_(t) || xp(t), s = n.responseType || "json", o = i ? 0 : n.timeout != null ? n.timeout : pl.timeout;
  let a = !1;
  if (!i) {
    e.useSSL && (t = iO(t)), n.cacheBust && r.cache === "default" && (t = G8(t, "request.preventCache", Date.now()));
    let m = { ...n.query };
    e.credentialToken && (m.token = e.credentialToken);
    let y = Cg(m);
    K("geoscene-url-encodes-apostrophe") && (y = y.replace(/'/g, "%27"));
    const g = t.length + 1 + y.length;
    let v;
    a = n.method === "delete" || n.method === "post" || n.method === "put" || !!n.body || g > pl.maxUrlLength;
    const w = n.useProxy || !!Y_(t);
    if (w) {
      const b = EK(t);
      v = b.path, !a && v.length + 1 + g > pl.maxUrlLength && (a = !0), b.query && (m = { ...b.query, ...m });
    }
    if (r.method === "HEAD" && (a || w)) {
      if (a)
        throw g > pl.maxUrlLength ? Eo("request:invalid-parameters", new Error("URL exceeds maximum length"), e.params) : Eo("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e.params);
      if (w)
        throw Eo("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e.params);
    }
    if (a ? (r.method = n.method === "delete" ? "DELETE" : n.method === "put" ? "PUT" : "POST", n.body ? t = BA(t, m) : (r.body = Cg(m), r.headers["Content-Type"] = "application/x-www-form-urlencoded")) : t = BA(t, m), w && (e.useProxy = !0, t = `${v}?${t}`), m.token && Q8 && r.body instanceof FormData) {
      const b = r.body;
      b.set ? b.set("token", m.token) : b.append("token", m.token);
    }
    if (n.hasOwnProperty("withCredentials"))
      e.withCredentials = n.withCredentials;
    else if (!y1(t, F8())) {
      if (tO(t))
        e.withCredentials = !0;
      else if (En) {
        const b = En.findServerInfo(t);
        b && b.webTierAuth && (e.withCredentials = !0);
      }
    }
    e.withCredentials && (r.credentials = "include");
  }
  let l, c, p = 0, f = !1;
  o > 0 && (p = setTimeout(() => {
    f = !0, e.controller.abort();
  }, o));
  try {
    if (n.responseType === "native-request-init")
      c = r, c.url = t;
    else if (n.responseType !== "image" || r.cache !== "default" || r.method !== "GET" || a || dY(n.headers) || !i && !e.useProxy && pl.proxyUrl && !GA(t)) {
      if (l = await rn._abortableFetch(t, r), e.useProxy || oY(t), n.responseType === "native")
        c = l;
      else if (r.method !== "HEAD")
        if (l.ok) {
          switch (s) {
            case "array-buffer":
              c = await l.arrayBuffer();
              break;
            case "blob":
            case "image":
              c = await l.blob();
              break;
            default:
              c = await l.text();
          }
          if (p && (clearTimeout(p), p = 0), s === "json" || s === "xml" || s === "document")
            if (c)
              switch (s) {
                case "json":
                  c = JSON.parse(c);
                  break;
                case "xml":
                  c = WA(c, "application/xml");
                  break;
                case "document":
                  c = WA(c, "text/html");
              }
            else
              c = null;
          if (c) {
            if (s === "array-buffer" || s === "blob") {
              const m = l.headers.get("Content-Type");
              if (/application\/json|text\/plain/i.test(m) && c[s === "blob" ? "size" : "byteLength"] <= 750)
                try {
                  const y = await new Response(c).json();
                  y.error && (c = y);
                } catch {
                }
            }
            s === "image" && c instanceof Blob && (c = await HA(URL.createObjectURL(c), e, !0));
          }
        } else
          c = await l.text();
    } else
      c = await HA(t, e);
  } catch (m) {
    if (m.name === "AbortError")
      throw f ? new Error("Timeout exceeded") : Cn("Request canceled");
    if (!(!l && m instanceof TypeError && pl.proxyUrl) || n.body || n.method === "delete" || n.method === "head" || n.method === "post" || n.method === "put" || e.useProxy || GA(t))
      throw m;
    e.redoRequest = !0, MK({ proxyUrl: pl.proxyUrl, urlPrefix: Uf(t) });
  } finally {
    p && clearTimeout(p);
  }
  return [l, c];
}
async function cY(e, t) {
  if (e.responseData != null)
    return e.responseData;
  if (e.headers && (t.requestOptions.headers = { ...t.requestOptions.headers, ...e.headers }), e.query && (t.requestOptions.query = { ...t.requestOptions.query, ...e.query }), e.before) {
    let n, r;
    try {
      r = await e.before(t);
    } catch (i) {
      n = Eo("request:interceptor", i, t);
    }
    if ((r instanceof Error || r instanceof D) && (n = Eo("request:interceptor", r, t)), n)
      throw e.error && e.error(n), n;
    return r;
  }
}
function dY(e) {
  if (e) {
    for (const t of Object.getOwnPropertyNames(e))
      if (e[t])
        return !0;
  }
  return !1;
}
function WA(e, t) {
  let n;
  try {
    n = new DOMParser().parseFromString(e, t);
  } catch {
  }
  if (!n || n.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return n;
}
async function pY(e) {
  var t, n;
  let r, i;
  await lY(e);
  try {
    do
      [r, i] = await uY(e);
    while (!await hY(e, r, i));
  } catch (a) {
    const l = Eo("request:server", a, e.params, r);
    throw l.details.ssl = e.useSSL, e.interceptor && e.interceptor.error && e.interceptor.error(l), l;
  }
  const s = e.params.url;
  if (/\/sharing\/rest\/(accounts|portals)\/self/i.test(s) && !e.hasToken && !e.credentialToken && (t = i) != null && (n = t.user) != null && n.username && !tO(s)) {
    const a = Uf(s, !0);
    a && pl.trustedServers.push(a);
  }
  const o = e.credential;
  if (o && En) {
    const a = En.findServerInfo(o.server);
    let l = a && a.owningSystemUrl;
    if (l) {
      l = l.replace(/\/?$/, "/sharing");
      const c = En.findCredential(l, o.userId);
      c && En._getIdenticalSvcIdx(l, c) === -1 && c.resources.unshift(l);
    }
  }
  return { data: i, getHeader: r ? (a) => r.headers.get(a) : aO, requestOptions: e.params.requestOptions, ssl: e.useSSL, url: e.params.url };
}
async function hY(e, t, n) {
  if (e.redoRequest)
    return e.redoRequest = !1, !1;
  const r = e.params.requestOptions;
  if (!t || r.responseType === "native" || r.responseType === "native-request-init")
    return !0;
  let i, s, o, a;
  if (!t.ok)
    throw i = new Error(`Unable to load ${t.url} status: ${t.status}`), i[H$] = n, i;
  n != null && n.error && (i = n.error), i && (s = Number(i.code), o = i.hasOwnProperty("subcode") ? Number(i.subcode) : null, a = i.messageCode, a = a && a.toUpperCase());
  const l = r.authMode;
  if (s === 403 && (o === 4 || i.message && i.message.toLowerCase().indexOf("ssl") > -1 && i.message.toLowerCase().indexOf("permission") === -1)) {
    if (!e.useSSL)
      return e.useSSL = !0, !1;
  } else if (!e.hasToken && e.useIdentity && (l !== "no-prompt" || s === 498) && rY.indexOf(s) !== -1 && !X8(e.params.url) && (s !== 403 || iY.indexOf(a) === -1 && (o == null || o === 2 && e.credentialToken))) {
    await J$();
    try {
      const c = await En.getCredential(e.params.url, { error: Eo("request:server", i, e.params), prompt: l !== "no-prompt", signal: e.controller.signal, token: e.credentialToken });
      return e.credential = c, e.credentialToken = c.token, e.useSSL = e.useSSL || c.ssl, !1;
    } catch (c) {
      if (l === "no-prompt")
        return e.credential = null, e.credentialToken = null, !1;
      i = c;
    }
  }
  if (i)
    throw i;
  return !0;
}
function HA(e, t, n = !1) {
  const r = t.controller.signal, i = new Image();
  return t.withCredentials ? i.crossOrigin = "use-credentials" : i.crossOrigin = "anonymous", i.alt = "", i.src = e, nY(i, e, n, r);
}
rn._abortableFetch = null, rn._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];
const fY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: rn
}, Symbol.toStringTag, { value: "Module" }));
function be(e, t, n) {
  let r, i;
  return t === void 0 || Array.isArray(t) ? (i = e, n = t, r = [void 0]) : (i = t, r = Array.isArray(e) ? e : [e]), (s, o) => {
    const a = s.constructor.prototype;
    r.forEach((l) => {
      const c = h8(s, l, i);
      c.read && typeof c.read == "object" || (c.read = {}), c.read.reader = a[o], n && (c.read.source = (c.read.source || []).concat(n));
    });
  };
}
let Ho = class extends se {
  constructor(...t) {
    super(...t), this.type = null, this.hasM = !1, this.hasZ = !1, this.spatialReference = Qe.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(t, n) {
    if (t instanceof Qe)
      return t;
    if (t != null) {
      const r = new Qe();
      return r.read(t, n), r;
    }
    return t;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(t) {
    return this.cache[t];
  }
  setCacheValue(t, n) {
    this.cache[t] = n;
  }
};
u([d()], Ho.prototype, "type", void 0), u([d({ readOnly: !0 })], Ho.prototype, "cache", null), u([d({ readOnly: !0 })], Ho.prototype, "extent", null), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Ho.prototype, "hasM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Ho.prototype, "hasZ", void 0), u([d({ type: Qe, json: { write: !0 } })], Ho.prototype, "spatialReference", void 0), u([be("spatialReference")], Ho.prototype, "readSpatialReference", null), Ho = u([T("geoscene.geometry.Geometry")], Ho);
const Ci = Ho, mY = Object.prototype.toString;
function yY(e) {
  const t = "__accessorMetadata__" in e ? kn(e) : e;
  return function(...n) {
    if (n.push(t), typeof n[2] == "number")
      throw new Error("Using @cast has parameter decorator is not supported since 4.16");
    return gY.apply(this, n);
  };
}
function gY(e, t, n, r) {
  z_(e, t).cast = r;
}
function vY(e) {
  return function(t, n) {
    z_(t, e).cast = t[n];
  };
}
function mt(...e) {
  if (e.length !== 3 || typeof e[1] != "string")
    return e.length === 1 && mY.call(e[0]) === "[object Function]" ? yY(e[0]) : e.length === 1 && typeof e[0] == "string" ? vY(e[0]) : void 0;
}
function bY(e, t, n, r) {
  var i;
  return e.x = e.x + t, e.y = e.y + n, r != null && (e.z = ((i = e.z) != null ? i : 0) + r), e;
}
function wY(e, t) {
  const n = e.x - t.x, r = e.y - t.y, i = e.hasZ && t.hasZ ? e.z - t.z : 0;
  return Math.sqrt(n * n + r * r + i * i);
}
let lO = class {
  constructor(t, n, r, i) {
    this.semiMajorAxis = t, this.flattening = n, this.outerAtmosphereRimWidth = r;
    const s = 1 - this.flattening;
    this.semiMinorAxis = this.semiMajorAxis * s, this.halfSemiMajorAxis = this.semiMajorAxis / 2, this.halfCircumference = Math.PI * this.semiMajorAxis, this.metersPerDegree = this.halfCircumference / 180, this.inverseFlattening = 1 / (1 - this.flattening) - 1, this.eccentricitySquared = i || 2 * this.flattening - this.flattening * this.flattening, this.meanRadiusSemiAxes = (2 * this.semiMajorAxis + this.semiMinorAxis) / 3;
  }
  get radius() {
    return this.semiMajorAxis;
  }
};
const Kt = new lO(6378137, 1 / 298.257223563, 3e5, 0.006694379990137799), Tl = new lO(3396190, 1 / 169.8944472236118, 23e4), ec = new lO(1737400, 0, 0), _Y = 57.29577951308232, SY = 0.017453292519943;
function JA(e) {
  return e * _Y;
}
function ZA(e) {
  return e * SY;
}
function LAe(e) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-e / Kt.radius));
}
function Z$(e) {
  return e.wkid != null || e.wkt != null;
}
const $2 = [0, 0];
function b1(e, t, n, r, i) {
  const s = e, o = i;
  if (o.spatialReference = n, "x" in s && "x" in o)
    [o.x, o.y] = t(s.x, s.y, $2, r);
  else if ("xmin" in s && "xmin" in o)
    [o.xmin, o.ymin] = t(s.xmin, s.ymin, $2, r), [o.xmax, o.ymax] = t(s.xmax, s.ymax, $2, r);
  else if ("paths" in s && "paths" in o || "rings" in s && "rings" in o) {
    const a = "paths" in s ? s.paths : s.rings, l = [];
    let c;
    for (let p = 0; p < a.length; p++) {
      const f = a[p];
      c = [], l.push(c);
      for (let m = 0; m < f.length; m++)
        c.push(t(f[m][0], f[m][1], [0, 0], r)), f[m].length > 2 && c[m].push(f[m][2]), f[m].length > 3 && c[m].push(f[m][3]);
    }
    "paths" in o ? o.paths = l : o.rings = l;
  } else if ("points" in s && "points" in o) {
    const a = s.points, l = [];
    for (let c = 0; c < a.length; c++)
      l[c] = t(a[c][0], a[c][1], [0, 0], r), a[c].length > 2 && l[c].push(a[c][2]), a[c].length > 3 && l[c].push(a[c][3]);
    o.points = l;
  }
  return i;
}
function Tb(e, t) {
  const n = e && (Z$(e) ? e : e.spatialReference), r = t && (Z$(t) ? t : t.spatialReference);
  return !(e && "type" in e && e.type === "mesh" || t && "type" in t && t.type === "mesh" || !n || !r) && (!!Oi(r, n) || tp(r) && Og(n) || tp(n) && Og(r));
}
function tS(e, t) {
  if (H(e))
    return null;
  const n = e.spatialReference, r = t && (Z$(t) ? t : t.spatialReference);
  return Tb(n, r) ? Oi(n, r) ? q(e) : tp(r) ? b1(e, jh, Qe.WebMercator, !1, q(e)) : Og(r) ? b1(e, Ky, Qe.WGS84, !1, q(e)) : null : null;
}
function jh(e, t, n = [0, 0]) {
  t > 89.99999 ? t = 89.99999 : t < -89.99999 && (t = -89.99999);
  const r = ZA(t);
  return n[0] = ZA(e) * Kt.radius, n[1] = Kt.halfSemiMajorAxis * Math.log((1 + Math.sin(r)) / (1 - Math.sin(r))), n;
}
function Ky(e, t, n = [0, 0], r = !1) {
  const i = JA(e / Kt.radius);
  return n[0] = r ? i : i - 360 * Math.floor((i + 180) / 360), n[1] = JA(Math.PI / 2 - 2 * Math.atan(Math.exp(-t / Kt.radius))), n;
}
function Zu(e, t = !1, n = q(e)) {
  return b1(e, jh, Qe.WebMercator, t, n);
}
function Ym(e, t = !1, n = q(e)) {
  return b1(e, Ky, Qe.WGS84, t, n);
}
var Eb;
const wm = [0, 0];
function KA(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
const cv = we.getLogger("geoscene.geometry.Point");
let Vr = Eb = class extends Ci {
  constructor(...e) {
    super(...e), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  static copy(e, t) {
    t._set("x", e._get("x")), t._set("y", e._get("y")), t._set("z", e._get("z")), t._set("m", e._get("m"));
    const n = e._get("spatialReference");
    t._set("spatialReference", Object.isFrozen(n) ? n : n.clone());
  }
  normalizeCtorArgs(e, t, n, r, i) {
    let s;
    if (Array.isArray(e))
      s = e, i = t, e = s[0], t = s[1], n = s[2], r = s[3];
    else if (e && typeof e == "object") {
      if (s = e, e = s.x != null ? s.x : s.longitude, t = s.y != null ? s.y : s.latitude, n = s.z, r = s.m, (i = s.spatialReference) && i.declaredClass !== "geoscene.geometry.SpatialReference" && (i = new Qe(i)), s.longitude != null || s.latitude != null) {
        if (s.longitude == null)
          cv.warn(".longitude=", "Latitude was defined without longitude");
        else if (s.latitude == null)
          cv.warn(".latitude=", "Longitude was defined without latitude");
        else if (!s.declaredClass && i && i.isWebMercator) {
          const a = jh(s.longitude, s.latitude, wm);
          e = a[0], t = a[1];
        }
      }
    } else
      KA(n) ? (i = n, n = null) : KA(r) && (i = r, r = null);
    const o = { x: e, y: t };
    return o.x == null && o.y != null ? cv.warn(".y=", "Y coordinate was defined without an X coordinate") : o.y == null && o.x != null && cv.warn(".x=", "X coordinate was defined without a Y coordinate"), i != null && (o.spatialReference = i), n != null && (o.z = n), r != null && (o.m = r), o;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return this.m !== void 0;
  }
  set hasM(e) {
    e !== (this._get("m") !== void 0) && (this._set("m", e ? 0 : void 0), this._set("hasM", e));
  }
  get hasZ() {
    return this.z !== void 0;
  }
  set hasZ(e) {
    e !== (this._get("z") !== void 0) && (this._set("z", e ? 0 : void 0), this._set("hasZ", e));
  }
  get latitude() {
    const { spatialReference: e, x: t, y: n } = this;
    if (e) {
      if (e.isWebMercator)
        return Ky(t, n, wm)[1];
      if (e.isGeographic)
        return n;
    }
    return null;
  }
  set latitude(e) {
    const { spatialReference: t, x: n } = this;
    t && (t.isWebMercator ? this._set("y", jh(n, e, wm)[1]) : t.isGeographic && this._set("y", e), this._set("latitude", e));
  }
  get longitude() {
    const { x: e, y: t, spatialReference: n } = this;
    if (n) {
      if (n.isWebMercator)
        return Ky(e, t, wm)[0];
      if (n.isGeographic)
        return e;
    }
    return null;
  }
  set longitude(e) {
    const { y: t, spatialReference: n } = this;
    n && (n.isWebMercator ? this._set("x", jh(e, t, wm)[0]) : n.isGeographic && this._set("x", e), this._set("longitude", e));
  }
  writeX(e, t, n) {
    t[n] = isNaN(e) ? "NaN" : e;
  }
  readX(e) {
    return typeof e == "string" ? NaN : e;
  }
  clone() {
    const e = new Eb();
    return e.x = this.x, e.y = this.y, e.z = this.z, e.m = this.m, e.spatialReference = this.spatialReference, e;
  }
  copy(e) {
    return Eb.copy(e, this), this;
  }
  equals(e) {
    if (H(e))
      return !1;
    const { x: t, y: n, z: r, m: i, spatialReference: s } = this, { z: o, m: a } = e;
    let { x: l, y: c, spatialReference: p } = e;
    if (!s.equals(p))
      if (s.isWebMercator && p.isWGS84)
        [l, c] = jh(l, c), p = s;
      else {
        if (!s.isWGS84 || !p.isWebMercator)
          return !1;
        [l, c] = Ky(l, c), p = s;
      }
    return t === l && n === c && r === o && i === a && s.wkid === p.wkid;
  }
  offset(e, t, n) {
    return bY(this, e, t, n);
  }
  normalize() {
    if (!this.spatialReference)
      return this;
    const e = Oo(this.spatialReference);
    if (!e)
      return this;
    let t = this.x;
    const [n, r] = e.valid, i = 2 * r;
    let s;
    return t > r ? (s = Math.ceil(Math.abs(t - r) / i), t -= s * i) : t < n && (s = Math.ceil(Math.abs(t - n) / i), t += s * i), this._set("x", t), this;
  }
  distance(e) {
    return wY(this, e);
  }
  toArray() {
    const e = this.hasZ, t = this.hasM;
    return e && t ? [this.x, this.y, this.z, this.m] : e ? [this.x, this.y, this.z] : t ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], Vr.prototype, "cache", null), u([d({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Vr.prototype, "hasM", null), u([d({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Vr.prototype, "hasZ", null), u([d({ type: Number })], Vr.prototype, "latitude", null), u([d({ type: Number })], Vr.prototype, "longitude", null), u([d({ type: Number, json: { type: [Number, String], write: { isRequired: !0, allowNull: !0 } } }), mt((e) => isNaN(e) ? e : ks(e))], Vr.prototype, "x", void 0), u([xe("x")], Vr.prototype, "writeX", null), u([be("x")], Vr.prototype, "readX", null), u([d({ type: Number, json: { write: !0 } })], Vr.prototype, "y", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Vr.prototype, "z", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Vr.prototype, "m", void 0), Vr = Eb = u([T("geoscene.geometry.Point")], Vr), Vr.prototype.toJSON.isDefaultToJSON = !0;
const Oe = Vr, T2 = [0, 0];
function nS(e, t) {
  return !!O(t) && qr(e, t.x, t.y, t.z);
}
function FAe(e, t) {
  if (!t.points || t.points.length)
    return !1;
  for (const n of t.points)
    if (!pf(e, n))
      return !1;
  return !0;
}
function xY(e, t) {
  const { xmin: n, ymin: r, zmin: i, xmax: s, ymax: o, zmax: a } = t;
  return e.hasZ && t.hasZ ? qr(e, n, r, i) && qr(e, n, o, i) && qr(e, s, o, i) && qr(e, s, r, i) && qr(e, n, r, a) && qr(e, n, o, a) && qr(e, s, o, a) && qr(e, s, r, a) : qr(e, n, r) && qr(e, n, o) && qr(e, s, o) && qr(e, s, r);
}
function pf(e, t) {
  return qr(e, t[0], t[1]);
}
function $Y(e, t) {
  return qr(e, t[0], t[1], t[2]);
}
function qr(e, t, n, r) {
  return t >= e.xmin && t <= e.xmax && n >= e.ymin && n <= e.ymax && (r == null || !e.hasZ || r >= e.zmin && r <= e.zmax);
}
function e6(e, t) {
  return T2[1] = t.y, T2[0] = t.x, t6(e, T2);
}
function t6(e, t) {
  return TY(e.rings, t);
}
function TY(e, t) {
  if (!e)
    return !1;
  if (EY(e))
    return YA(!1, e, t);
  let n = !1;
  for (let r = 0, i = e.length; r < i; r++)
    n = YA(n, e[r], t);
  return n;
}
function EY(e) {
  return !Array.isArray(e[0][0]);
}
function YA(e, t, n) {
  const [r, i] = n;
  let s = e, o = 0;
  for (let a = 0, l = t.length; a < l; a++) {
    o++, o === l && (o = 0);
    const [c, p] = t[a], [f, m] = t[o];
    (p < i && m >= i || m < i && p >= i) && c + (i - p) / (m - p) * (f - c) < r && (s = !s);
  }
  return s;
}
function IY(e, t) {
  return nS(e, t);
}
function MY(e, t) {
  const n = e.hasZ && t.hasZ;
  let r, i, s;
  if (e.xmin <= t.xmin) {
    if (r = t.xmin, e.xmax < r)
      return !1;
  } else if (r = e.xmin, t.xmax < r)
    return !1;
  if (e.ymin <= t.ymin) {
    if (i = t.ymin, e.ymax < i)
      return !1;
  } else if (i = e.ymin, t.ymax < i)
    return !1;
  if (n && t.hasZ) {
    if (e.zmin <= t.zmin) {
      if (s = t.zmin, e.zmax < s)
        return !1;
    } else if (s = e.zmin, t.zmax < s)
      return !1;
  }
  return !0;
}
function CY(e, t) {
  const { points: n, hasZ: r } = t, i = r ? $Y : pf;
  for (const s of n)
    if (i(e, s))
      return !0;
  return !1;
}
const np = [0, 0], rp = [0, 0], ip = [0, 0], sp = [0, 0], OY = [np, rp, ip, sp], n6 = [[ip, np], [np, rp], [rp, sp], [sp, ip]];
function kY(e, t) {
  np[0] = e.xmin, np[1] = e.ymax, rp[0] = e.xmax, rp[1] = e.ymax, ip[0] = e.xmin, ip[1] = e.ymin, sp[0] = e.xmax, sp[1] = e.ymin;
  for (const n of OY)
    if (t6(t, n))
      return !0;
  for (const n of t.rings) {
    if (!n.length)
      continue;
    let r = n[0];
    if (pf(e, r))
      return !0;
    for (let i = 1; i < n.length; i++) {
      const s = n[i];
      if (pf(e, s) || r6(r, s, n6))
        return !0;
      r = s;
    }
  }
  return !1;
}
function AY(e, t) {
  np[0] = e.xmin, np[1] = e.ymax, rp[0] = e.xmax, rp[1] = e.ymax, ip[0] = e.xmin, ip[1] = e.ymin, sp[0] = e.xmax, sp[1] = e.ymin;
  const n = t.paths;
  for (const r of n) {
    if (!n.length)
      continue;
    let i = r[0];
    if (pf(e, i))
      return !0;
    for (let s = 1; s < r.length; s++) {
      const o = r[s];
      if (pf(e, o) || r6(i, o, n6))
        return !0;
      i = o;
    }
  }
  return !1;
}
const sr = [0, 0];
function PY(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    for (let i = 0; i < n.length - 1; i++) {
      const s = n[i], o = n[i + 1];
      for (let a = t + 1; a < e.length; a++)
        for (let l = 0; l < e[a].length - 1; l++) {
          const c = e[a][l], p = e[a][l + 1];
          if (K$(s, o, c, p, sr) && !(sr[0] === s[0] && sr[1] === s[1] || sr[0] === c[0] && sr[1] === c[1] || sr[0] === o[0] && sr[1] === o[1] || sr[0] === p[0] && sr[1] === p[1]))
            return !0;
        }
    }
    const r = n.length;
    if (!(r <= 4))
      for (let i = 0; i < r - 3; i++) {
        let s = r - 1;
        i === 0 && (s = r - 2);
        const o = n[i], a = n[i + 1];
        for (let l = i + 2; l < s; l++) {
          const c = n[l], p = n[l + 1];
          if (K$(o, a, c, p, sr) && !(sr[0] === o[0] && sr[1] === o[1] || sr[0] === c[0] && sr[1] === c[1] || sr[0] === a[0] && sr[1] === a[1] || sr[0] === p[0] && sr[1] === p[1]))
            return !0;
        }
      }
  }
  return !1;
}
function r6(e, t, n) {
  for (let r = 0; r < n.length; r++)
    if (K$(e, t, n[r][0], n[r][1]))
      return !0;
  return !1;
}
function K$(e, t, n, r, i) {
  const [s, o] = e, [a, l] = t, [c, p] = n, [f, m] = r, y = f - c, g = s - c, v = a - s, w = m - p, b = o - p, S = l - o, $ = w * v - y * S;
  if ($ === 0)
    return !1;
  const I = (y * b - w * g) / $, M = (v * b - S * g) / $;
  return I >= 0 && I <= 1 && M >= 0 && M <= 1 && (i && (i[0] = s + I * (a - s), i[1] = o + I * (l - o)), !0);
}
function RY(e) {
  switch (e) {
    case "esriGeometryEnvelope":
    case "extent":
      return MY;
    case "esriGeometryMultipoint":
    case "multipoint":
      return CY;
    case "esriGeometryPoint":
    case "point":
      return IY;
    case "esriGeometryPolygon":
    case "polygon":
      return kY;
    case "esriGeometryPolyline":
    case "polyline":
      return AY;
  }
}
var vs;
function LY(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
function ql(e, t, n) {
  return t == null ? n : n == null ? t : e(t, n);
}
let qn = vs = class extends Ci {
  constructor(...e) {
    super(...e), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(e, t, n, r, i) {
    return LY(e) ? { spatialReference: e, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : typeof e == "object" ? (e.spatialReference = e.spatialReference == null ? Qe.WGS84 : e.spatialReference, e) : { xmin: e, ymin: t, xmax: n, ymax: r, spatialReference: i ?? Qe.WGS84 };
  }
  static fromBounds(e, t) {
    return new vs({ xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: t });
  }
  static fromPoint(e) {
    return new vs({ xmin: e.x, ymin: e.y, zmin: e.z, xmax: e.x, ymax: e.y, zmax: e.z, spatialReference: e.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const e = new Oe({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (e.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (e.m = 0.5 * (this.mmin + this.mmax)), e;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return this.mmin != null && this.mmax != null;
  }
  get hasZ() {
    return this.zmin != null && this.zmax != null;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(e) {
    const t = this.center;
    return e.z != null && this.hasZ ? this.offset(e.x - t.x, e.y - t.y, e.z - t.z) : this.offset(e.x - t.x, e.y - t.y);
  }
  clone() {
    const e = new vs();
    return e.xmin = this.xmin, e.ymin = this.ymin, e.xmax = this.xmax, e.ymax = this.ymax, e.spatialReference = this.spatialReference, this.zmin != null && (e.zmin = this.zmin, e.zmax = this.zmax), this.mmin != null && (e.mmin = this.mmin, e.mmax = this.mmax), e;
  }
  contains(e) {
    if (!e)
      return !1;
    const t = this.spatialReference, n = e.spatialReference;
    return t && n && !t.equals(n) && Tb(t, n) && (e = t.isWebMercator ? Zu(e) : Ym(e, !0)), e.type === "point" ? nS(this, e) : e.type === "extent" && xY(this, e);
  }
  equals(e) {
    if (this === e)
      return !0;
    if (H(e))
      return !1;
    const t = this.spatialReference, n = e.spatialReference;
    return t && n && !t.equals(n) && Tb(t, n) && (e = t.isWebMercator ? Zu(e) : Ym(e, !0)), this.xmin === e.xmin && this.ymin === e.ymin && this.zmin === e.zmin && this.mmin === e.mmin && this.xmax === e.xmax && this.ymax === e.ymax && this.zmax === e.zmax && this.mmax === e.mmax;
  }
  expand(e) {
    const t = 0.5 * (1 - e), n = this.width * t, r = this.height * t;
    if (this.xmin += n, this.ymin += r, this.xmax -= n, this.ymax -= r, this.hasZ) {
      const i = (this.zmax - this.zmin) * t;
      this.zmin += i, this.zmax -= i;
    }
    if (this.hasM) {
      const i = (this.mmax - this.mmin) * t;
      this.mmin += i, this.mmax -= i;
    }
    return this;
  }
  intersects(e) {
    if (H(e))
      return !1;
    e.type === "mesh" && (e = e.extent);
    const t = this.spatialReference, n = e.spatialReference;
    return t && n && !t.equals(n) && Tb(t, n) && (e = t.isWebMercator ? Zu(e) : Ym(e, !0)), RY(e.type)(this, e);
  }
  normalize() {
    const e = this._normalize(!1, !0);
    return Array.isArray(e) ? e : [e];
  }
  offset(e, t, n) {
    return this.xmin += e, this.ymin += t, this.xmax += e, this.ymax += t, n != null && (this.zmin += n, this.zmax += n), this;
  }
  shiftCentralMeridian() {
    return this._normalize(!0);
  }
  union(e) {
    return this === e || (this.xmin = Math.min(this.xmin, e.xmin), this.ymin = Math.min(this.ymin, e.ymin), this.xmax = Math.max(this.xmax, e.xmax), this.ymax = Math.max(this.ymax, e.ymax), (this.hasZ || e.hasZ) && (this.zmin = ql(Math.min, this.zmin, e.zmin), this.zmax = ql(Math.max, this.zmax, e.zmax)), (this.hasM || e.hasM) && (this.mmin = ql(Math.min, this.mmin, e.mmin), this.mmax = ql(Math.max, this.mmax, e.mmax))), this;
  }
  intersection(e) {
    return this === e ? this : H(e) || !this.intersects(e) ? null : (this.xmin = Math.max(this.xmin, e.xmin), this.ymin = Math.max(this.ymin, e.ymin), this.xmax = Math.min(this.xmax, e.xmax), this.ymax = Math.min(this.ymax, e.ymax), (this.hasZ || e.hasZ) && (this.zmin = ql(Math.max, this.zmin, e.zmin), this.zmax = ql(Math.min, this.zmax, e.zmax)), (this.hasM || e.hasM) && (this.mmin = ql(Math.max, this.mmin, e.mmin), this.mmax = ql(Math.min, this.mmax, e.mmax)), this);
  }
  toJSON(e) {
    return this.write({}, e);
  }
  _shiftCM(e = Oo(this.spatialReference)) {
    if (!e || !this.spatialReference)
      return this;
    const t = this.spatialReference, n = this._getCM(e);
    if (n) {
      const r = t.isWebMercator ? Ym(n) : n;
      this.xmin -= n.x, this.xmax -= n.x, t.isWebMercator || (r.x = this._normalizeX(r.x, e).x), this.spatialReference = new Qe(Ta(t.isWGS84 ? e.altTemplate : e.wkTemplate, { Central_Meridian: r.x }));
    }
    return this;
  }
  _getCM(e) {
    let t = null;
    const [n, r] = e.valid, i = this.xmin, s = this.xmax;
    return i >= n && i <= r && s >= n && s <= r || (t = this.center), t;
  }
  _normalize(e, t, n) {
    const r = this.spatialReference;
    if (!r)
      return this;
    if (!(n = n || Oo(r)))
      return this;
    const i = this._getParts(n).map((a) => a.extent);
    if (i.length < 2)
      return i[0] || this;
    if (i.length > 2)
      return e ? this._shiftCM(n) : this.set({ xmin: n.valid[0], xmax: n.valid[1] });
    if (e)
      return this._shiftCM(n);
    if (t)
      return i;
    let s = !0, o = !0;
    return i.forEach((a) => {
      a.hasZ || (s = !1), a.hasM || (o = !1);
    }), { rings: i.map((a) => {
      const l = [[a.xmin, a.ymin], [a.xmin, a.ymax], [a.xmax, a.ymax], [a.xmax, a.ymin], [a.xmin, a.ymin]];
      if (s) {
        const c = (a.zmax - a.zmin) / 2;
        for (let p = 0; p < l.length; p++)
          l[p].push(c);
      }
      if (o) {
        const c = (a.mmax - a.mmin) / 2;
        for (let p = 0; p < l.length; p++)
          l[p].push(c);
      }
      return l;
    }), hasZ: s, hasM: o, spatialReference: r };
  }
  _getParts(e) {
    let t = this.cache._parts;
    if (!t) {
      t = [];
      const { ymin: i, ymax: s, spatialReference: o } = this, a = this.width, l = this.xmin, c = this.xmax;
      let p;
      e = e || Oo(o);
      const [f, m] = e.valid;
      p = this._normalizeX(this.xmin, e);
      const y = p.x, g = p.frameId;
      p = this._normalizeX(this.xmax, e);
      const v = p.x, w = p.frameId, b = y === v && a > 0;
      if (a > 2 * m) {
        const S = new vs(l < c ? y : v, i, m, s, o), $ = new vs(f, i, l < c ? v : y, s, o), I = new vs(0, i, m, s, o), M = new vs(f, i, 0, s, o), E = [], C = [];
        S.contains(I) && E.push(g), S.contains(M) && C.push(g), $.contains(I) && E.push(w), $.contains(M) && C.push(w);
        for (let A = g + 1; A < w; A++)
          E.push(A), C.push(A);
        t.push({ extent: S, frameIds: [g] }, { extent: $, frameIds: [w] }, { extent: I, frameIds: E }, { extent: M, frameIds: C });
      } else
        y > v || b ? t.push({ extent: new vs(y, i, m, s, o), frameIds: [g] }, { extent: new vs(f, i, v, s, o), frameIds: [w] }) : t.push({ extent: new vs(y, i, v, s, o), frameIds: [g] });
      this.cache._parts = t;
    }
    const n = this.hasZ, r = this.hasM;
    if (n || r) {
      const i = {};
      n && (i.zmin = this.zmin, i.zmax = this.zmax), r && (i.mmin = this.mmin, i.mmax = this.mmax);
      for (let s = 0; s < t.length; s++)
        t[s].extent.set(i);
    }
    return t;
  }
  _normalizeX(e, t) {
    const [n, r] = t.valid, i = 2 * r;
    let s, o = 0;
    return e > r ? (s = Math.ceil(Math.abs(e - r) / i), e -= s * i, o = s) : e < n && (s = Math.ceil(Math.abs(e - n) / i), e += s * i, o = -s), { x: e, frameId: o };
  }
};
u([d({ readOnly: !0 })], qn.prototype, "cache", null), u([d({ readOnly: !0 })], qn.prototype, "center", null), u([d({ readOnly: !0 })], qn.prototype, "extent", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], qn.prototype, "hasM", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], qn.prototype, "hasZ", null), u([d({ readOnly: !0 })], qn.prototype, "height", null), u([d({ readOnly: !0 })], qn.prototype, "width", null), u([d({ type: Number, json: { type: [Number, String], write: { enabled: !0, allowNull: !0 } } })], qn.prototype, "xmin", void 0), u([d({ type: Number, json: { write: !0 } })], qn.prototype, "ymin", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], qn.prototype, "mmin", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], qn.prototype, "zmin", void 0), u([d({ type: Number, json: { write: !0 } })], qn.prototype, "xmax", void 0), u([d({ type: Number, json: { write: !0 } })], qn.prototype, "ymax", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], qn.prototype, "mmax", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], qn.prototype, "zmax", void 0), qn = vs = u([T("geoscene.geometry.Extent")], qn), qn.prototype.toJSON.isDefaultToJSON = !0;
const Mt = qn;
var QA, XA, eP;
let FY, Yy;
const tP = (QA = (XA = globalThis.geosceneConfig) == null ? void 0 : XA.locale) != null ? QA : (eP = globalThis.dojoConfig) == null ? void 0 : eP.locale;
function i6() {
  var e, t;
  return (e = tP ?? ((t = globalThis.navigator) == null ? void 0 : t.language)) != null ? e : "en";
}
function ts() {
  return Yy === void 0 && (Yy = i6()), Yy;
}
const Qy = [];
function NY(e) {
  return Qy.push(e), { remove() {
    Qy.splice(Qy.indexOf(e), 1);
  } };
}
const Y$ = [];
function uO(e) {
  return Y$.push(e), { remove() {
    Qy.splice(Y$.indexOf(e), 1);
  } };
}
function DY() {
  var e;
  const t = (e = FY) != null ? e : i6();
  Yy !== t && (Yy = t, [...Y$].forEach((n) => {
    n.call(null, t);
  }), [...Qy].forEach((n) => {
    n.call(null, t);
  }));
}
globalThis.addEventListener == null || globalThis.addEventListener("languagechange", DY);
let st = class {
  constructor(t, n = { ignoreUnknown: !1, useNumericKeys: !1 }) {
    this.jsonToAPI = t, this.options = n, this.apiValues = [], this.jsonValues = [], this.apiToJSON = this._invertMap(t), this.apiValues = this._getKeysSorted(this.apiToJSON), this.jsonValues = this._getKeysSorted(this.jsonToAPI), this.read = (r) => this.fromJSON(r), this.write = (r, i, s) => {
      const o = this.toJSON(r);
      o !== void 0 && ss(s, o, i);
    }, this.write.isJSONMapWriter = !0;
  }
  toJSON(t) {
    if (this.apiToJSON.hasOwnProperty(t)) {
      const n = this.apiToJSON[t];
      return this.options.useNumericKeys ? +n : n;
    }
    return this.options.ignoreUnknown ? void 0 : t;
  }
  fromJSON(t) {
    return this.jsonToAPI.hasOwnProperty(t) ? this.jsonToAPI[t] : this.options.ignoreUnknown ? void 0 : t;
  }
  _invertMap(t) {
    const n = {};
    for (const r in t)
      n[t[r]] = r;
    return n;
  }
  _getKeysSorted(t) {
    const n = [];
    for (const r in t)
      n.push(r);
    return n.sort(), n;
  }
};
function $r() {
  return function(e, t) {
    return new st(e, { ignoreUnknown: !0, ...t });
  };
}
var Q$;
const jY = new st({ avgRating: "avg-rating", numRatings: "num-ratings", numComments: "num-comments", numViews: "num-views" });
let bs = Q$ = class extends ke {
  constructor(e) {
    super(e), this.categories = null, this.disableExtraQuery = !1, this.extent = null, this.filter = null, this.num = 10, this.query = null, this.sortField = null, this.start = 1;
  }
  get sortOrder() {
    return this._get("sortOrder") || "asc";
  }
  set sortOrder(e) {
    e !== "asc" && e !== "desc" || this._set("sortOrder", e);
  }
  clone() {
    return new Q$({ categories: this.categories ? q(this.categories) : null, disableExtraQuery: this.disableExtraQuery, extent: this.extent ? this.extent.clone() : null, filter: this.filter, num: this.num, query: this.query, sortField: this.sortField, sortOrder: this.sortOrder, start: this.start });
  }
  toRequestOptions(e, t) {
    let n, r;
    if (this.categories && (n = this.categories.map((o) => Array.isArray(o) ? JSON.stringify(o) : o)), this.extent) {
      const o = tS(this.extent, Qe.WGS84);
      O(o) && (r = `${o.xmin},${o.ymin},${o.xmax},${o.ymax}`);
    }
    let i = this.query;
    !this.disableExtraQuery && e.extraQuery && (i = "(" + i + ")" + e.extraQuery);
    const s = { categories: n, bbox: r, q: i, filter: this.filter, num: this.num, sortField: null, sortOrder: null, start: this.start };
    return this.sortField && (s.sortField = this.sortField.split(",").map((o) => jY.toJSON(o.trim())).join(","), s.sortOrder = this.sortOrder), { query: { ...t, ...s } };
  }
};
u([d()], bs.prototype, "categories", void 0), u([d()], bs.prototype, "disableExtraQuery", void 0), u([d({ type: Mt })], bs.prototype, "extent", void 0), u([d()], bs.prototype, "filter", void 0), u([d()], bs.prototype, "num", void 0), u([d()], bs.prototype, "query", void 0), u([d()], bs.prototype, "sortField", void 0), u([d()], bs.prototype, "sortOrder", null), u([d()], bs.prototype, "start", void 0), bs = Q$ = u([T("geoscene.portal.PortalQueryParams")], bs);
const bl = bs;
let Pc = class extends ke {
  constructor(t) {
    super(t), this.nextQueryParams = null, this.queryParams = null, this.results = null, this.total = null;
  }
};
u([d()], Pc.prototype, "nextQueryParams", void 0), u([d()], Pc.prototype, "queryParams", void 0), u([d()], Pc.prototype, "results", void 0), u([d()], Pc.prototype, "total", void 0), Pc = u([T("geoscene.portal.PortalQueryResult")], Pc);
const VY = Pc;
let qa = class extends se {
  constructor(t) {
    super(t), this.created = null, this.id = null, this.portal = null, this.title = null, this.username = null;
  }
  get url() {
    const t = this.get("portal.restUrl");
    return t ? `${t}/content/users/${this.username}/${this.id}` : null;
  }
  toJSON() {
    throw new D("internal:not-yet-implemented", "PortalFolder.toJSON is not yet implemented");
  }
};
u([d({ type: Date })], qa.prototype, "created", void 0), u([d()], qa.prototype, "id", void 0), u([d()], qa.prototype, "portal", void 0), u([d()], qa.prototype, "title", void 0), u([d({ readOnly: !0 })], qa.prototype, "url", null), u([d()], qa.prototype, "username", void 0), qa = u([T("geoscene.portal.PortalFolder")], qa);
const zY = qa;
let Gn = class extends se {
  constructor(t) {
    super(t), this.access = null, this.created = null, this.description = null, this.id = null, this.isInvitationOnly = !1, this.modified = null, this.owner = null, this.portal = null, this.snippet = null, this.sortField = null, this.sortOrder = null, this.tags = null, this.title = null;
  }
  get thumbnailUrl() {
    const t = this.url, n = this.thumbnail;
    return t && n ? this.portal._normalizeUrl(`${t}/info/${n}?f=json`) : null;
  }
  get url() {
    const t = this.get("portal.restUrl");
    return t ? t + "/community/groups/" + this.id : null;
  }
  fetchCategorySchema(t) {
    return this.portal._request(this.url + "/categorySchema", t).then((n) => {
      const r = n.categorySchema || [];
      return r.some((i) => i.source === "contentCategorySetsGroupQuery.LivingAtlas") ? this._fetchCategorySchemaSet("LivingAtlas", t) : r;
    });
  }
  fetchMembers(t) {
    return this.portal._request(this.url + "/users", t);
  }
  getThumbnailUrl(t) {
    let n = this.thumbnailUrl;
    return n && t && (n += `&w=${t}`), n;
  }
  toJSON() {
    throw new D("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  queryItems(t, n) {
    let r = kn(bl, t);
    return parseFloat(this.portal.currentVersion) > 5 ? (r = r || new bl(), this.portal._queryPortal(`/content/groups/${this.id}/search`, r, "PortalItem", n)) : (r = r ? r.clone() : new bl(), r.query = "group:" + this.id + (r.query ? " " + r.query : ""), this.portal.queryItems(r, n));
  }
  _fetchCategorySchemaSet(t, n) {
    return this.portal._fetchSelf(this.portal.authMode, !0, n).then((r) => {
      const i = r.contentCategorySetsGroupQuery;
      if (i) {
        const s = new bl();
        return s.disableExtraQuery = !0, s.num = 1, s.query = i, this.portal.queryGroups(s, n);
      }
      throw new D("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery value not found");
    }).then((r) => {
      if (r.total) {
        const i = r.results[0], s = new bl();
        return s.num = 1, s.query = `typekeywords:"${t}"`, i.queryItems(s, n);
      }
      throw new D("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery group not found");
    }).then((r) => r.total ? r.results[0].fetchData("json", n).then((i) => {
      const s = i && i.categorySchema;
      return s && s.length ? s : [];
    }) : []);
  }
};
u([d()], Gn.prototype, "access", void 0), u([d({ type: Date })], Gn.prototype, "created", void 0), u([d()], Gn.prototype, "description", void 0), u([d()], Gn.prototype, "id", void 0), u([d()], Gn.prototype, "isInvitationOnly", void 0), u([d({ type: Date })], Gn.prototype, "modified", void 0), u([d()], Gn.prototype, "owner", void 0), u([d()], Gn.prototype, "portal", void 0), u([d()], Gn.prototype, "snippet", void 0), u([d()], Gn.prototype, "sortField", void 0), u([d()], Gn.prototype, "sortOrder", void 0), u([d()], Gn.prototype, "tags", void 0), u([d()], Gn.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], Gn.prototype, "thumbnailUrl", null), u([d()], Gn.prototype, "title", void 0), u([d({ readOnly: !0 })], Gn.prototype, "url", null), Gn = u([T("geoscene.portal.PortalGroup")], Gn);
const X$ = Gn, BY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: X$
}, Symbol.toStringTag, { value: "Module" }));
var eT;
let qt = eT = class extends se {
  constructor(...e) {
    super(...e), this.access = null, this.created = null, this.culture = null, this.description = null, this.email = null, this.fullName = null, this.modified = null, this.orgId = null, this.portal = null, this.preferredView = null, this.privileges = null, this.region = null, this.role = null, this.roleId = null, this.sourceJSON = null, this.units = null, this.username = null, this.userType = null;
  }
  get thumbnailUrl() {
    const e = this.url, t = this.thumbnail;
    return e && t ? this.portal._normalizeUrl(`${e}/info/${t}?f=json`) : null;
  }
  get userContentUrl() {
    const e = this.get("portal.restUrl");
    return e ? `${e}/content/users/${this.username}` : null;
  }
  get url() {
    const e = this.get("portal.restUrl");
    return e ? `${e}/community/users/${this.username}` : null;
  }
  addItem(e) {
    const t = e && e.item, n = e && e.data, r = e && e.folder, i = { method: "post" };
    t && (i.query = t.createPostQuery(), n != null && (typeof n == "string" ? i.query.text = n : typeof n == "object" && (i.query.text = JSON.stringify(n))));
    let s = this.userContentUrl;
    return r && (s += "/" + (typeof r == "string" ? r : r.id)), this.portal._request(s + "/addItem", i).then((o) => (t.id = o.id, t.portal = this.portal, t.loaded ? t.reload() : t.load()));
  }
  deleteItem(e) {
    let t = this.userContentUrl;
    return e.ownerFolder && (t += "/" + e.ownerFolder), this.portal._request(t + `/items/${e.id}/delete`, { method: "post" }).then(() => {
      e.id = null, e.portal = null;
    });
  }
  deleteItems(e) {
    const t = this.userContentUrl + "/deleteItems", n = e.map((r) => r.id);
    if (n.length) {
      const r = { method: "post", query: { items: n.join(",") } };
      return this.portal._request(t, r).then(() => {
        e.forEach((i) => {
          i.id = null, i.portal = null;
        });
      });
    }
    return Promise.resolve(void 0);
  }
  fetchFolders() {
    const e = { query: { num: 1 } };
    return this.portal._request(this.userContentUrl, e).then((t) => {
      let n;
      return n = t && t.folders ? t.folders.map((r) => {
        const i = zY.fromJSON(r);
        return i.portal = this.portal, i;
      }) : [], n;
    });
  }
  fetchGroups() {
    return this.portal._request(this.url).then((e) => {
      let t;
      return t = e && e.groups ? e.groups.map((n) => {
        const r = X$.fromJSON(n);
        return r.portal = this.portal, r;
      }) : [], t;
    });
  }
  fetchItems(e) {
    e || (e = {});
    let t, n = this.userContentUrl;
    return e.folder && (n += "/" + e.folder.id), Promise.resolve().then(() => s6).then(({ default: r }) => {
      t = r;
      const i = { folders: !1, num: e.num || 10, start: e.start || 1, sortField: e.sortField || "created", sortOrder: e.sortOrder || "asc" };
      return this.portal._request(n, { query: i });
    }).then((r) => {
      let i;
      return r && r.items ? (i = r.items.map((s) => {
        const o = t.fromJSON(s);
        return o.portal = this.portal, o;
      }), Promise.all(i.map((s) => s.load())).catch((s) => s).then(() => ({ items: i, nextStart: r.nextStart, total: r.total }))) : { items: [], nextStart: -1, total: 0 };
    });
  }
  fetchTags() {
    return this.portal._request(this.url + "/tags").then((e) => e.tags);
  }
  getThumbnailUrl(e) {
    let t = this.thumbnailUrl;
    return t && e && (t += `&w=${e}`), t;
  }
  queryFavorites(e) {
    return this.favGroupId ? (this._favGroup || (this._favGroup = new X$({ id: this.favGroupId, portal: this.portal })), this._favGroup.queryItems(e)) : Promise.reject(new D("internal:unknown", "Unknown internal error", { internalError: "Unknown favGroupId" }));
  }
  toJSON() {
    throw new D("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    const t = new eT();
    return t.sourceJSON = e, t.read(e), t;
  }
};
u([d()], qt.prototype, "access", void 0), u([d({ type: Date })], qt.prototype, "created", void 0), u([d()], qt.prototype, "culture", void 0), u([d()], qt.prototype, "description", void 0), u([d()], qt.prototype, "email", void 0), u([d()], qt.prototype, "favGroupId", void 0), u([d()], qt.prototype, "fullName", void 0), u([d({ type: Date })], qt.prototype, "modified", void 0), u([d()], qt.prototype, "orgId", void 0), u([d()], qt.prototype, "portal", void 0), u([d()], qt.prototype, "preferredView", void 0), u([d()], qt.prototype, "privileges", void 0), u([d()], qt.prototype, "region", void 0), u([d()], qt.prototype, "role", void 0), u([d()], qt.prototype, "roleId", void 0), u([d()], qt.prototype, "sourceJSON", void 0), u([d()], qt.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], qt.prototype, "thumbnailUrl", null), u([d()], qt.prototype, "units", void 0), u([d({ readOnly: !0 })], qt.prototype, "userContentUrl", null), u([d({ readOnly: !0 })], qt.prototype, "url", null), u([d()], qt.prototype, "username", void 0), u([d()], qt.prototype, "userType", void 0), qt = eT = u([T("geoscene.portal.PortalUser")], qt);
const cO = qt, UY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cO
}, Symbol.toStringTag, { value: "Module" }));
var Ni;
let E2;
const nP = { PortalGroup: () => Promise.resolve().then(() => BY), PortalItem: () => Promise.resolve().then(() => s6), PortalUser: () => Promise.resolve().then(() => UY) };
let ge = Ni = class extends b0(Ol) {
  constructor(e) {
    super(e), this.access = null, this.allSSL = !1, this.authMode = "auto", this.authorizedCrossOriginDomains = null, this.basemapGalleryGroupQuery = null, this.bingKey = null, this.canListApps = !1, this.canListData = !1, this.canListPreProvisionedItems = !1, this.canProvisionDirectPurchase = !1, this.canSearchPublic = !0, this.canShareBingPublic = !1, this.canSharePublic = !1, this.canSignInArcGIS = !1, this.canSignInIDP = !1, this.colorSetsGroupQuery = null, this.commentsEnabled = !1, this.created = null, this.culture = null, this.customBaseUrl = null, this.defaultBasemap = null, this.defaultDevBasemap = null, this.defaultExtent = null, this.defaultVectorBasemap = null, this.description = null, this.devBasemapGalleryGroupQuery = null, this.eueiEnabled = null, this.featuredGroups = null, this.featuredItemsGroupQuery = null, this.galleryTemplatesGroupQuery = null, this.livingAtlasGroupQuery = null, this.hasCategorySchema = !1, this.helperServices = null, this.homePageFeaturedContent = null, this.homePageFeaturedContentCount = null, this.httpPort = null, this.httpsPort = null, this.id = null, this.ipCntryCode = null, this.isPortal = !1, this.isReadOnly = !1, this.layerTemplatesGroupQuery = null, this.maxTokenExpirationMinutes = null, this.modified = null, this.name = null, this.portalHostname = null, this.portalMode = null, this.portalProperties = null, this.region = null, this.rotatorPanels = null, this.showHomePageDescription = !1, this.sourceJSON = null, this.supportsHostedServices = !1, this.symbolSetsGroupQuery = null, this.templatesGroupQuery = null, this.units = null, this.url = Pt.portalUrl, this.urlKey = null, this.user = null, this.useStandardizedQuery = !1, this.useVectorBasemaps = !1, this.vectorBasemapGalleryGroupQuery = null;
  }
  normalizeCtorArgs(e) {
    return typeof e == "string" ? { url: e } : e;
  }
  destroy() {
    this._geosceneId_credentialCreateHandle && (this._geosceneId_credentialCreateHandle.remove(), this._geosceneId_credentialCreateHandle = null);
  }
  readAuthorizedCrossOriginDomains(e) {
    if (e)
      for (const t of e)
        Pt.request.trustedServers.indexOf(t) === -1 && Pt.request.trustedServers.push(t);
    return e;
  }
  readDefaultBasemap(e) {
    return this._readBasemap(e);
  }
  readDefaultDevBasemap(e) {
    return this._readBasemap(e);
  }
  readDefaultVectorBasemap(e) {
    return this._readBasemap(e);
  }
  get extraQuery() {
    const e = !(this.user && this.user.orgId) || this.canSearchPublic;
    return this.id && !e ? ` AND orgid:${this.id}` : null;
  }
  get isOrganization() {
    return !!this.access;
  }
  get restUrl() {
    let e = this.url;
    if (e) {
      const t = e.indexOf("/sharing");
      e = t > 0 ? e.substring(0, t) : this.url.replace(/\/+$/, ""), e += "/sharing/rest";
    }
    return e;
  }
  get stylesGroupQuery() {
    return iJ(we.getLogger(this.declaredClass), "stylesGroupQuery", { replacement: "stylesGroupQuery3d", version: "4.21" }), this.stylesGroupQuery3d;
  }
  get thumbnailUrl() {
    const e = this.restUrl, t = this.thumbnail;
    return e && t ? this._normalizeSSL(e + "/portals/self/resources/" + t) : null;
  }
  readUrlKey(e) {
    return e && e.toLowerCase();
  }
  readUser(e) {
    let t = null;
    return e && (t = cO.fromJSON(e), t.portal = this), t;
  }
  load(e) {
    const t = Promise.resolve().then(() => oQ).then(({ default: n }) => {
      On(e), E2 = n;
    }).then(() => this.sourceJSON ? this.sourceJSON : this._fetchSelf(this.authMode, !1, e)).then((n) => {
      if (En) {
        const r = En;
        this.credential = r.findCredential(this.restUrl), this.credential || this.authMode !== Ni.AUTH_MODE_AUTO || (this._geosceneId_credentialCreateHandle = r.on("credential-create", () => {
          r.findCredential(this.restUrl) && this._signIn();
        }));
      }
      this.sourceJSON = n, this.read(n);
    });
    return this.addResolvingPromise(t), Promise.resolve(this);
  }
  async createClosestFacilityTask() {
    Xp(we.getLogger(this.declaredClass), null, { replacement: "Use helperServices url with geoscene/rest/closestFacility", version: "4.21" }), await this.load();
    const e = this._getHelperServiceUrl("closestFacility");
    return new (await import("./ClosestFacilityTask-zIjL_qjh.js")).default(e);
  }
  async createElevationLayers() {
    await this.load();
    const e = this._getHelperService("defaultElevationLayers"), t = (await import("./ElevationLayer-y6mFolfM.js")).default;
    return e ? e.map((n) => new t({ id: n.id, url: n.url })) : [];
  }
  async createGeometryService() {
    Xp(we.getLogger(this.declaredClass), null, { replacement: "Use helperServices url with geoscene/rest/geometryService", version: "4.21" }), await this.load();
    const e = this._getHelperServiceUrl("geometry");
    return new (await import("./GeometryService-JbawuuJQ.js")).default({ url: e });
  }
  async createPrintTask() {
    Xp(we.getLogger(this.declaredClass), null, { replacement: "Use helperServices url with geoscene/rest/print", version: "4.21" }), await this.load();
    const e = this._getHelperServiceUrl("printTask");
    return new (await import("./PrintTask-tWNQFX8f.js")).default(e);
  }
  async createRouteTask() {
    Xp(we.getLogger(this.declaredClass), null, { replacement: "Use helperServices url with geoscene/rest/route", version: "4.21" }), await this.load();
    const e = this._getHelperServiceUrl("route");
    return new (await import("./RouteTask-s6kcGOYs.js")).default(e);
  }
  async createServiceAreaTask() {
    Xp(we.getLogger(this.declaredClass), null, { replacement: "Use helperServices url with geoscene/rest/serviceArea", version: "4.21" }), await this.load();
    const e = this._getHelperServiceUrl("serviceArea");
    return new (await import("./ServiceAreaTask-zSMZ__3E.js")).default(e);
  }
  fetchBasemaps(e, t) {
    const n = new bl();
    return n.query = e || (Pt.apiKey && Y8(this.url) ? this.devBasemapGalleryGroupQuery : this.useVectorBasemaps ? this.vectorBasemapGalleryGroupQuery : this.basemapGalleryGroupQuery), n.disableExtraQuery = !0, this.queryGroups(n, t).then((r) => {
      if (n.num = 100, n.query = 'type:"Web Map" -type:"Web Application"', r.total) {
        const i = r.results[0];
        return n.sortField = i.sortField || "name", n.sortOrder = i.sortOrder || "desc", i.queryItems(n, t);
      }
      return null;
    }).then((r) => {
      let i;
      return i = r && r.total ? r.results.filter((s) => s.type === "Web Map").map((s) => new E2({ portalItem: s })) : [], i;
    });
  }
  fetchCategorySchema(e) {
    return this.hasCategorySchema ? this._request(this.restUrl + "/portals/self/categorySchema", e).then((t) => t.categorySchema) : Ea(e) ? Promise.reject(Cn()) : Promise.resolve([]);
  }
  fetchFeaturedGroups(e) {
    const t = this.featuredGroups, n = new bl();
    if (n.num = 100, n.sortField = "title", t && t.length) {
      const r = [];
      for (const i of t)
        r.push(`(title:"${i.title}" AND owner:${i.owner})`);
      return n.query = r.join(" OR "), this.queryGroups(n, e).then((i) => i.results);
    }
    return Ea(e) ? Promise.reject(Cn()) : Promise.resolve([]);
  }
  fetchRegions(e) {
    var t;
    const n = ((t = this.user) == null ? void 0 : t.culture) || this.culture || ts();
    return this._request(this.restUrl + "/portals/regions", { ...e, query: { culture: n } });
  }
  fetchSettings(e) {
    var t;
    const n = ((t = this.user) == null ? void 0 : t.culture) || this.culture || ts();
    return this._request(this.restUrl + "/portals/self/settings", { ...e, query: { culture: n } });
  }
  static getDefault() {
    return Ni._default && !Ni._default.destroyed || (Ni._default = new Ni()), Ni._default;
  }
  queryGroups(e, t) {
    return this._queryPortal("/community/groups", e, "PortalGroup", t);
  }
  queryItems(e, t) {
    return this._queryPortal("/search", e, "PortalItem", t);
  }
  queryUsers(e, t) {
    return e.sortField || (e.sortField = "username"), this._queryPortal("/community/users", e, "PortalUser", t);
  }
  toJSON() {
    throw new D("internal:not-yet-implemented", "Portal.toJSON is not yet implemented");
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new Ni({ sourceJSON: e });
  }
  _getHelperService(e) {
    const t = this.helperServices && this.helperServices[e];
    if (!t)
      throw new D("portal:service-not-found", `The \`helperServices\` do not include an entry named "${e}"`);
    return t;
  }
  _getHelperServiceUrl(e) {
    const t = this._getHelperService(e);
    if (!t.url)
      throw new D("portal:service-url-not-found", `The \`helperServices\` entry "${e}" does not include a \`url\` value`);
    return t.url;
  }
  _fetchSelf(e = this.authMode, t = !1, n) {
    const r = this.restUrl + "/portals/self", i = { authMode: e, query: { culture: ts().toLowerCase() }, ...n };
    return i.authMode === "auto" && (i.authMode = "no-prompt"), t && (i.query.default = !0), this._request(r, i);
  }
  _queryPortal(e, t, n, r) {
    const i = kn(bl, t), s = (o) => this._request(this.restUrl + e, { ...i.toRequestOptions(this), ...r }).then((a) => {
      const l = i.clone();
      return l.start = a.nextStart, new VY({ nextQueryParams: l, queryParams: i, total: a.total, results: Ni._resultsToTypedArray(o, { portal: this }, a, r) });
    }).then((a) => Promise.all(a.results.map((l) => typeof l.when == "function" ? l.when() : a)).then(() => a, (l) => (y0(l), a)));
    return n && nP[n] ? nP[n]().then(({ default: o }) => (On(r), s(o))) : s();
  }
  _signIn() {
    if (this.authMode === Ni.AUTH_MODE_ANONYMOUS)
      return Promise.reject(new D("portal:invalid-auth-mode", `Current "authMode"' is "${this.authMode}"`));
    if (this.loadStatus === "failed")
      return Promise.reject(this.loadError);
    const e = (t) => Promise.resolve().then(() => this.loadStatus === "not-loaded" ? (t || (this.authMode = "immediate"), this.load().then(() => null)) : this.loadStatus === "loading" ? this.load().then(() => this.credential ? null : (this.credential = t, this._fetchSelf("immediate"))) : this.user && this.credential === t ? null : (this.credential = t, this._fetchSelf("immediate"))).then((n) => {
      n && (this.sourceJSON = n, this.read(n));
    });
    return En ? En.getCredential(this.restUrl).then((t) => e(t)) : e(this.credential);
  }
  _normalizeSSL(e) {
    return e.replace(/^http:/i, "https:").replace(":7080", ":7443");
  }
  _normalizeUrl(e) {
    const t = this.credential && this.credential.token;
    return this._normalizeSSL(t ? e + (e.indexOf("?") > -1 ? "&" : "?") + "token=" + t : e);
  }
  _requestToTypedArray(e, t, n) {
    return this._request(e, t).then((r) => {
      const i = Ni._resultsToTypedArray(n, { portal: this }, r);
      return Promise.all(i.map((s) => typeof s.when == "function" ? s.when() : r)).then(() => i, () => i);
    });
  }
  _readBasemap(e) {
    if (e) {
      const t = E2.fromJSON(e);
      return t.portalItem = { portal: this }, t;
    }
    return null;
  }
  _request(e, t = {}) {
    const n = { f: "json", ...t.query }, { authMode: r = this.authMode === Ni.AUTH_MODE_ANONYMOUS ? "anonymous" : "auto", body: i = null, cacheBust: s = !1, method: o = "auto", responseType: a = "json", signal: l } = t, c = { authMode: r, body: i, cacheBust: s, method: o, query: n, responseType: a, timeout: 0, signal: l };
    return rn(this._normalizeSSL(e), c).then((p) => p.data);
  }
  static _resultsToTypedArray(e, t, n, r) {
    let i;
    if (n) {
      const s = O(r) ? r.signal : null;
      i = n.listings || n.notifications || n.userInvitations || n.tags || n.items || n.groups || n.comments || n.provisions || n.results || n.relatedItems || n, (e || t) && (i = i.map((o) => {
        const a = Object.assign(e ? e.fromJSON(o) : o, t);
        return typeof a.load == "function" && a.load(s), a;
      }));
    } else
      i = [];
    return i;
  }
};
ge.AUTH_MODE_ANONYMOUS = "anonymous", ge.AUTH_MODE_AUTO = "auto", ge.AUTH_MODE_IMMEDIATE = "immediate", u([d()], ge.prototype, "access", void 0), u([d()], ge.prototype, "allSSL", void 0), u([d()], ge.prototype, "authMode", void 0), u([d()], ge.prototype, "authorizedCrossOriginDomains", void 0), u([be("authorizedCrossOriginDomains")], ge.prototype, "readAuthorizedCrossOriginDomains", null), u([d()], ge.prototype, "basemapGalleryGroupQuery", void 0), u([d()], ge.prototype, "bingKey", void 0), u([d()], ge.prototype, "canListApps", void 0), u([d()], ge.prototype, "canListData", void 0), u([d()], ge.prototype, "canListPreProvisionedItems", void 0), u([d()], ge.prototype, "canProvisionDirectPurchase", void 0), u([d()], ge.prototype, "canSearchPublic", void 0), u([d()], ge.prototype, "canShareBingPublic", void 0), u([d()], ge.prototype, "canSharePublic", void 0), u([d()], ge.prototype, "canSignInArcGIS", void 0), u([d()], ge.prototype, "canSignInIDP", void 0), u([d()], ge.prototype, "colorSetsGroupQuery", void 0), u([d()], ge.prototype, "commentsEnabled", void 0), u([d({ type: Date })], ge.prototype, "created", void 0), u([d()], ge.prototype, "credential", void 0), u([d()], ge.prototype, "culture", void 0), u([d()], ge.prototype, "currentVersion", void 0), u([d()], ge.prototype, "customBaseUrl", void 0), u([d()], ge.prototype, "defaultBasemap", void 0), u([be("defaultBasemap")], ge.prototype, "readDefaultBasemap", null), u([d()], ge.prototype, "defaultDevBasemap", void 0), u([be("defaultDevBasemap")], ge.prototype, "readDefaultDevBasemap", null), u([d({ type: Mt })], ge.prototype, "defaultExtent", void 0), u([d()], ge.prototype, "defaultVectorBasemap", void 0), u([be("defaultVectorBasemap")], ge.prototype, "readDefaultVectorBasemap", null), u([d()], ge.prototype, "description", void 0), u([d()], ge.prototype, "devBasemapGalleryGroupQuery", void 0), u([d()], ge.prototype, "eueiEnabled", void 0), u([d({ readOnly: !0 })], ge.prototype, "extraQuery", null), u([d()], ge.prototype, "featuredGroups", void 0), u([d()], ge.prototype, "featuredItemsGroupQuery", void 0), u([d()], ge.prototype, "galleryTemplatesGroupQuery", void 0), u([d()], ge.prototype, "livingAtlasGroupQuery", void 0), u([d()], ge.prototype, "hasCategorySchema", void 0), u([d()], ge.prototype, "helpBase", void 0), u([d()], ge.prototype, "helperServices", void 0), u([d()], ge.prototype, "helpMap", void 0), u([d()], ge.prototype, "homePageFeaturedContent", void 0), u([d()], ge.prototype, "homePageFeaturedContentCount", void 0), u([d()], ge.prototype, "httpPort", void 0), u([d()], ge.prototype, "httpsPort", void 0), u([d()], ge.prototype, "id", void 0), u([d()], ge.prototype, "ipCntryCode", void 0), u([d({ readOnly: !0 })], ge.prototype, "isOrganization", null), u([d()], ge.prototype, "isPortal", void 0), u([d()], ge.prototype, "isReadOnly", void 0), u([d()], ge.prototype, "layerTemplatesGroupQuery", void 0), u([d()], ge.prototype, "maxTokenExpirationMinutes", void 0), u([d({ type: Date })], ge.prototype, "modified", void 0), u([d()], ge.prototype, "name", void 0), u([d()], ge.prototype, "portalHostname", void 0), u([d()], ge.prototype, "portalMode", void 0), u([d()], ge.prototype, "portalProperties", void 0), u([d()], ge.prototype, "region", void 0), u([d({ readOnly: !0 })], ge.prototype, "restUrl", null), u([d()], ge.prototype, "rotatorPanels", void 0), u([d()], ge.prototype, "showHomePageDescription", void 0), u([d()], ge.prototype, "sourceJSON", void 0), u([d()], ge.prototype, "staticImagesUrl", void 0), u([d({ readOnly: !0, json: { read: !1 } })], ge.prototype, "stylesGroupQuery", null), u([d({ json: { name: "2DStylesGroupQuery" } })], ge.prototype, "stylesGroupQuery2d", void 0), u([d({ json: { name: "stylesGroupQuery" } })], ge.prototype, "stylesGroupQuery3d", void 0), u([d()], ge.prototype, "supportsHostedServices", void 0), u([d()], ge.prototype, "symbolSetsGroupQuery", void 0), u([d()], ge.prototype, "templatesGroupQuery", void 0), u([d()], ge.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], ge.prototype, "thumbnailUrl", null), u([d()], ge.prototype, "units", void 0), u([d()], ge.prototype, "url", void 0), u([d()], ge.prototype, "urlKey", void 0), u([be("urlKey")], ge.prototype, "readUrlKey", null), u([d()], ge.prototype, "user", void 0), u([be("user")], ge.prototype, "readUser", null), u([d()], ge.prototype, "useStandardizedQuery", void 0), u([d()], ge.prototype, "useVectorBasemaps", void 0), u([d()], ge.prototype, "vectorBasemapGalleryGroupQuery", void 0), ge = Ni = u([T("geoscene.portal.Portal")], ge);
const os = ge, qY = we.getLogger("geoscene.assets");
function ma(e) {
  if (!Pt.assetsPath)
    throw qY.errorOnce("The API assets location needs to be set using config.assetsPath. More information: https://doc.geoscene.cn/javascript/latest/api-reference/geoscene-config.html"), new D("assets:path-not-set", "config.assetsPath is not set");
  return Xu(Pt.assetsPath, e);
}
const GY = we.getLogger("geoscene.portal.PortalItemResource");
let nu = class extends ke {
  constructor(t) {
    super(t), this.portalItem = null;
  }
  normalizeCtorArgs(t) {
    return t && t.portalItem && t.path ? { ...t, path: this._normalizePath(t.path, t.portalItem) } : t;
  }
  set path(t) {
    O(t) && es(t) ? GY.error("portalitemresource:invalid-path", "A portal item resource path must be relative") : this._set("path", t);
  }
  _castPath(t) {
    return this._normalizePath(t, this.portalItem);
  }
  get url() {
    return this.portalItem && this.path ? `${this.portalItem.itemUrl}/resources/${this.path}` : null;
  }
  get itemRelativeUrl() {
    return this.portalItem && this.path ? `./resources/${this.path}` : null;
  }
  fetch(t = "json", n) {
    const r = this.url;
    if (H(r))
      throw new D("portal-item-resource:fetch", "Portal item resource does not refer to a valid item or path");
    return this.portalItem.portal._request(r, { responseType: t, query: { token: this.portalItem.apiKey }, signal: _D(n, "signal") });
  }
  async update(t, n) {
    return (await import("./resourceUtils-OFVXASHI.js")).addOrUpdateResource(this, "update", t, n);
  }
  hasPath() {
    return O(this.path);
  }
  _normalizePath(t, n) {
    return H(t) ? t : (t = t.replace(/^\/+/, ""), O(n) && es(t) && (t = nO(t, n.itemUrl)), t.replace(/^\/+/, "").replace(/^(\.\/)?resources\//, ""));
  }
};
u([d()], nu.prototype, "portalItem", void 0), u([d({ type: String, value: null })], nu.prototype, "path", null), u([mt("path")], nu.prototype, "_castPath", null), u([d({ type: String, readOnly: !0 })], nu.prototype, "url", null), u([d({ type: String, readOnly: !0 })], nu.prototype, "itemRelativeUrl", null), nu = u([T("geoscene.portal.PortalItemResource")], nu);
const WY = nu;
let Qm = class extends ke {
  constructor(t) {
    super(t), this.created = null, this.rating = null;
  }
};
u([d()], Qm.prototype, "created", void 0), u([d()], Qm.prototype, "rating", void 0), Qm = u([T("geoscene.portal.PortalRating")], Qm);
const I2 = Qm;
var eh;
let et = eh = class extends b0(Ol) {
  constructor(e) {
    super(e), this.access = null, this.accessInformation = null, this.apiKey = null, this.applicationProxies = null, this.avgRating = null, this.categories = null, this.created = null, this.culture = null, this.description = null, this.extent = null, this.groupCategories = null, this.id = null, this.itemControl = null, this.licenseInfo = null, this.modified = null, this.name = null, this.numComments = null, this.numRatings = null, this.numViews = null, this.owner = null, this.ownerFolder = null, this.portal = null, this.screenshots = null, this.size = null, this.snippet = null, this.sourceJSON = null, this.tags = null, this.title = null, this.type = null, this.typeKeywords = null, this.url = null;
  }
  static from(e) {
    return JC(eh, e);
  }
  destroy() {
    this.portal = null;
  }
  get displayName() {
    const e = this.type, t = this.typeKeywords || [];
    let n = e;
    return e === "Feature Service" || e === "Feature Collection" ? n = t.indexOf("Table") > -1 ? "Table" : t.indexOf("Route Layer") > -1 ? "Route Layer" : t.indexOf("Markup") > -1 ? "Markup" : "Feature Layer" : e === "Image Service" ? n = t.indexOf("Elevation 3D Layer") > -1 ? "Elevation Layer" : t.indexOf("Tiled Imagery") > -1 ? "Tiled Imagery Layer" : "Imagery Layer" : e === "Scene Service" ? n = "Scene Layer" : e === "Media Service" ? n = "Media Layer" : e === "Scene Package" ? n = "Scene Layer Package" : e === "Stream Service" ? n = "Feature Layer" : e === "Geoprocessing Service" && this.portal && this.portal.isPortal ? n = t.indexOf("Web Tool") > -1 ? "Tool" : "Geoprocessing Service" : e === "Geocoding Service" ? n = "Locator" : e === "Geoenrichment Service" ? n = "GeoEnrichment Service" : e === "Microsoft Powerpoint" ? n = "Microsoft PowerPoint" : e === "GeoJson" ? n = "GeoJSON" : e === "Globe Service" ? n = "Globe Layer" : e === "Vector Tile Service" ? n = "Tile Layer" : e === "netCDF" ? n = "NetCDF" : e === "Map Service" ? n = t.indexOf("Spatiotemporal") === -1 && (t.indexOf("Hosted Service") > -1 || t.indexOf("Tiled") > -1) && t.indexOf("Relational") === -1 ? "Tile Layer" : "Map Image Layer" : e && e.toLowerCase().indexOf("add in") > -1 ? n = e.replace(/(add in)/gi, "Add-In") : e === "datastore catalog service" ? n = "Big Data File Share" : e === "Compact Tile Package" ? n = "Tile Package (tpkx)" : e === "OGCFeatureServer" ? n = "OGC Feature Layer" : e === "web mapping application" && t.indexOf("configurableApp") > -1 && (n = "Instant App"), n;
  }
  readExtent(e) {
    return e && e.length ? new Mt(e[0][0], e[0][1], e[1][0], e[1][1]) : null;
  }
  get iconUrl() {
    const e = this.type && this.type.toLowerCase() || "", t = this.typeKeywords || [], n = "geoscene/images/portal/", r = "16";
    let i, s = !1, o = !1, a = !1, l = !1, c = !1, p = !1;
    return e.indexOf("service") > 0 || e === "feature collection" || e === "kml" || e === "wms" || e === "wmts" || e === "wfs" ? (s = t.indexOf("Hosted Service") > -1, e === "feature service" || e === "feature collection" || e === "kml" || e === "wfs" ? (o = t.indexOf("Table") > -1, a = t.indexOf("Route Layer") > -1, l = t.indexOf("Markup") > -1, c = t.indexOf("Spatiotemporal") !== -1, p = t.indexOf("UtilityNetwork") !== -1, i = c && o ? "spatiotemporaltable" : o ? "table" : a ? "routelayer" : l ? "markup" : c ? "spatiotemporal" : s ? "featureshosted" : p ? "utilitynetwork" : "features") : i = e === "map service" || e === "wms" || e === "wmts" ? s || t.indexOf("Tiled") > -1 || e === "wmts" ? "maptiles" : "mapimages" : e === "scene service" ? t.indexOf("Line") > -1 ? "sceneweblayerline" : t.indexOf("3DObject") > -1 ? "sceneweblayermultipatch" : t.indexOf("Point") > -1 ? "sceneweblayerpoint" : t.indexOf("IntegratedMesh") > -1 ? "sceneweblayermesh" : t.indexOf("PointCloud") > -1 ? "sceneweblayerpointcloud" : t.indexOf("Polygon") > -1 ? "sceneweblayerpolygon" : t.indexOf("Building") > -1 ? "sceneweblayerbuilding" : t.indexOf("Voxel") > -1 ? "sceneweblayervoxel" : "sceneweblayer" : e === "image service" ? t.indexOf("Elevation 3D Layer") > -1 ? "elevationlayer" : t.indexOf("Tiled Imagery") > -1 ? "tiledimagerylayer" : "imagery" : e === "stream service" ? "streamlayer" : e === "media service" ? "mediaservice" : e === "vector tile service" ? "vectortile" : e === "datastore catalog service" ? "datastorecollection" : e === "geocoding service" ? "geocodeservice" : e === "geoprocessing service" && t.indexOf("Web Tool") > -1 && this.portal && this.portal.isPortal ? "tool" : "layers") : i = e === "web map" || e === "cityengine web scene" ? "maps" : e === "web scene" ? t.indexOf("ViewingMode-Local") > -1 ? "webscenelocal" : "websceneglobal" : e === "web mapping application" && t.indexOf("configurableApp") > -1 ? "instantapps" : e === "web mapping application" || e === "mobile application" || e === "application" || e === "operation view" || e === "desktop application" ? "apps" : e === "map document" || e === "map package" || e === "published map" || e === "scene document" || e === "globe document" || e === "basemap package" || e === "mobile basemap package" || e === "mobile map package" || e === "project package" || e === "project template" || e === "pro map" || e === "layout" || e === "layer" && t.indexOf("ArcGIS Pro") > -1 || e === "explorer map" && t.indexOf("Explorer Document") ? "mapsgray" : e === "service definition" || e === "csv" || e === "shapefile" || e === "cad drawing" || e === "geojson" || e === "360 vr experience" || e === "netcdf" || e === "administrative report" ? "datafiles" : e === "explorer add in" || e === "desktop add in" || e === "windows viewer add in" || e === "windows viewer configuration" ? "appsgray" : e === "arcgis pro add in" || e === "arcgis pro configuration" ? "addindesktop" : e === "rule package" || e === "file geodatabase" || e === "sqlite geodatabase" || e === "csv collection" || e === "kml collection" || e === "windows mobile package" || e === "map template" || e === "desktop application template" || e === "gml" || e === "arcpad package" || e === "code sample" || e === "form" || e === "document link" || e === "earth configuration" || e === "operations dashboard add in" || e === "rules package" || e === "image" || e === "workflow manager package" || e === "explorer map" && t.indexOf("Explorer Mapping Application") > -1 || t.indexOf("Document") > -1 ? "datafilesgray" : e === "network analysis service" || e === "geoprocessing service" || e === "geodata service" || e === "geometry service" || e === "geoprocessing package" || e === "locator package" || e === "geoprocessing sample" || e === "workflow manager service" ? "toolsgray" : e === "layer" || e === "layer package" || e === "explorer layer" ? "layersgray" : e === "scene package" ? "scenepackage" : e === "mobile scene package" ? "mobilescenepackage" : e === "tile package" || e === "compact tile package" ? "tilepackage" : e === "task file" ? "taskfile" : e === "report template" ? "report-template" : e === "statistical data collection" ? "statisticaldatacollection" : e === "insights workbook" ? "workbook" : e === "insights model" ? "insightsmodel" : e === "insights page" ? "insightspage" : e === "insights theme" ? "insightstheme" : e === "hub initiative" ? "hubinitiative" : e === "hubpage" ? "hubpage" : e === "hub event" ? "hubevent" : e === "hub site application" ? "hubsite" : e === "hub project" ? "hubproject" : e === "relational database connection" ? "relationaldatabaseconnection" : e === "big data file share" ? "datastorecollection" : e === "image collection" ? "imagecollection" : e === "style" ? "style" : e === "desktop style" ? "desktopstyle" : e === "dashboard" ? "dashboard" : e === "raster function template" ? "rasterprocessingtemplate" : e === "vector tile package" ? "vectortilepackage" : e === "ortho mapping project" ? "orthomappingproject" : e === "ortho mapping template" ? "orthomappingtemplate" : e === "solution" ? "solutions" : e === "geopackage" ? "geopackage" : e === "deep learning package" ? "deeplearningpackage" : e === "real time analytic" ? "realtimeanalytics" : e === "big data analytic" ? "bigdataanalytics" : e === "feed" ? "feed" : e === "excalibur imagery project" ? "excaliburimageryproject" : e === "notebook" ? "notebook" : e === "storymap" ? "storymap" : e === "survey123 add in" ? "survey123addin" : e === "mission" ? "mission" : e === "mission report" ? "missionreport" : e === "quickcapture project" ? "quickcaptureproject" : e === "pro report" ? "proreport" : e === "urban model" ? "urbanmodel" : e === "web experience" ? "experiencebuilder" : e === "web experience template" ? "webexperiencetemplate" : e === "experience builder widget" ? "experiencebuilderwidget" : e === "experience builder widget package" ? "experiencebuilderwidgetpackage" : e === "workflow" ? "workflow" : e === "insights script" ? "insightsscript" : e === "kernel gateway connection" ? "kernelgatewayconnection" : e === "hub initiative template" ? "hubinitiativetemplate" : e === "storymap theme" ? "storymaptheme" : e === "knowledge graph" ? "knowledgegraph" : e === "native application" ? "nativeapp" : e === "native application installer" ? "nativeappinstaller" : e === "link chart" ? "linkchart" : e === "investigation" ? "investigation" : e === "ogcfeatureserver" ? "features" : e === "pro project" ? "proproject" : e === "insights workbook package" ? "insightsworkbookpackage" : e === "apache parquet" ? "apacheparquet" : "maps", i ? ma(n + i + r + ".png") : null;
  }
  get isLayer() {
    return ["Map Service", "Feature Service", "Feature Collection", "Scene Service", "Image Service", "Stream Service", "Vector Tile Service", "WMTS", "WMS"].indexOf(this.type) > -1;
  }
  get itemUrl() {
    const e = this.get("portal.restUrl");
    return e ? e + "/content/items/" + this.id : null;
  }
  get thumbnailUrl() {
    const e = this.itemUrl, t = this.thumbnail;
    return e && t ? this.portal._normalizeUrl(`${e}/info/${t}?f=json`) : null;
  }
  get userItemUrl() {
    const e = this.get("portal.restUrl");
    if (!e)
      return null;
    const t = this.owner || this.get("portal.user.username");
    return t ? `${e}/content/users/${this.ownerFolder ? `${t}/${this.ownerFolder}` : t}/items/${this.id}` : null;
  }
  load(e) {
    this.portal || (this.portal = os.getDefault());
    const t = this.portal.load(e).then(() => this.sourceJSON ? this.sourceJSON : this.id && this.itemUrl ? this.portal._request(this.itemUrl, { signal: O(e) ? e.signal : null, query: { token: this.apiKey } }) : {}).then((n) => {
      this.sourceJSON = n, this.read(n);
    });
    return this.addResolvingPromise(t), Promise.resolve(this);
  }
  addRating(e) {
    const t = { method: "post", query: {} };
    return e instanceof I2 && (e = e.rating), isNaN(e) || typeof e != "number" || (t.query.rating = e), this.portal._request(this.itemUrl + "/addRating", t).then(() => new I2({ rating: e, created: /* @__PURE__ */ new Date() }));
  }
  clone() {
    const e = { access: this.access, accessInformation: this.accessInformation, applicationProxies: q(this.applicationProxies), avgRating: this.avgRating, categories: q(this.categories), created: q(this.created), culture: this.culture, description: this.description, extent: q(this.extent), groupCategories: q(this.groupCategories), id: this.id, itemControl: this.itemControl, licenseInfo: this.licenseInfo, modified: q(this.modified), name: this.name, numComments: this.numComments, numRatings: this.numRatings, numViews: this.numViews, owner: this.owner, ownerFolder: this.ownerFolder, portal: this.portal, screenshots: q(this.screenshots), size: this.size, snippet: this.snippet, tags: q(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: q(this.typeKeywords), url: this.url };
    return this.loaded && (e.loadStatus = "loaded"), new eh({ sourceJSON: this.sourceJSON }).set(e);
  }
  createPostQuery() {
    const e = this.toJSON();
    for (const t in e)
      t === "tags" && e[t] !== null && (e[t] = e[t].join(", ")), t === "typeKeywords" && e[t] !== null && (e[t] = e[t].join(", ")), t === "extent" && e[t] && (e[t] = JSON.stringify(e[t]));
    return e;
  }
  deleteRating() {
    return this.portal._request(this.itemUrl + "/deleteRating", { method: "post" }).then(() => {
    });
  }
  fetchData(e = "json", t) {
    return this.portal._request(this.itemUrl + "/data", { responseType: e, ...t, query: { token: this.apiKey } });
  }
  fetchRating(e) {
    return this.portal._request(this.itemUrl + "/rating", { query: { token: this.apiKey }, ...e }).then((t) => t.rating != null ? (t.created = new Date(t.created), new I2(t)) : null);
  }
  fetchRelatedItems(e, t) {
    return this.portal._requestToTypedArray(this.itemUrl + "/relatedItems", { query: { ...e, token: this.apiKey }, ...t }, eh);
  }
  getThumbnailUrl(e) {
    let t = this.thumbnailUrl;
    return t && e && (t += `&w=${e}`), t;
  }
  reload() {
    return this.portal._request(this.itemUrl, { cacheBust: !0, query: { token: this.apiKey } }).then((e) => (this.sourceJSON = e, this.read(e), this));
  }
  update(e) {
    return this.id ? this.load().then(() => this.portal._signIn()).then(() => {
      const t = e && e.data, n = { method: "post" };
      n.query = this.createPostQuery();
      for (const r in n.query)
        n.query[r] === null && (n.query[r] = "");
      return n.query.clearEmptyFields = !0, t != null && (typeof t == "string" ? n.query.text = t : typeof t == "object" && (n.query.text = JSON.stringify(t))), this.portal._request(`${this.userItemUrl}/update`, n).then(() => this.reload());
    }) : Promise.reject(new D("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  updateThumbnail(e) {
    return this.id ? this.load().then(() => this.portal._signIn()).then(() => {
      const t = e.thumbnail, n = e.filename, r = { method: "post" };
      if (typeof t == "string")
        xp(t) ? r.query = { data: t } : r.query = { url: To(t) }, O(n) && (r.query.filename = n);
      else {
        const i = new FormData();
        O(n) ? i.append("file", t, n) : i.append("file", t), r.body = i;
      }
      return this.portal._request(`${this.userItemUrl}/updateThumbnail`, r).then(() => this.reload());
    }) : Promise.reject(new D("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async fetchResources(e = {}, t) {
    return (await import("./resourceUtils-OFVXASHI.js")).fetchResources(this, e, t);
  }
  async addResource(e, t, n) {
    const r = await import("./resourceUtils-OFVXASHI.js");
    return e.portalItem = this, r.addOrUpdateResource(e, "add", t, n);
  }
  async removeResource(e, t) {
    const n = await import("./resourceUtils-OFVXASHI.js");
    if (e.portalItem && e.portalItem.itemUrl !== this.itemUrl)
      throw new D("removeresource:portal-item-mismatch", "The portal item associated with the provided resource does not match the item");
    return n.removeResource(this, e, t);
  }
  async removeAllResources(e) {
    return (await import("./resourceUtils-OFVXASHI.js")).removeAllResources(this, e);
  }
  resourceFromPath(e) {
    return new WY({ portalItem: this, path: e });
  }
  toJSON() {
    const e = this.extent, t = { created: this.created && this.created.getTime(), description: this.description, extent: e && [[e.xmin, e.ymin], [e.xmax, e.ymax]], id: this.id, modified: this.modified && this.modified.getTime(), name: this.name, owner: this.owner, ownerFolder: this.ownerFolder, snippet: this.snippet, tags: this.tags, thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: this.typeKeywords, url: this.url };
    return ID(t);
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new eh({ sourceJSON: e });
  }
  _getPostQuery() {
    const e = this.toJSON();
    for (const t in e)
      t === "tags" && e[t] !== null && (e[t] = e[t].join(", ")), t === "typeKeywords" && e[t] !== null && (e[t] = e[t].join(", ")), t === "extent" && e[t] && (e[t] = JSON.stringify(e[t]));
    return e;
  }
};
u([d({ type: ["private", "shared", "org", "public"] })], et.prototype, "access", void 0), u([d()], et.prototype, "accessInformation", void 0), u([d({ type: String })], et.prototype, "apiKey", void 0), u([d({ json: { read: { source: "appProxies" } } })], et.prototype, "applicationProxies", void 0), u([d()], et.prototype, "avgRating", void 0), u([d()], et.prototype, "categories", void 0), u([d({ type: Date })], et.prototype, "created", void 0), u([d()], et.prototype, "culture", void 0), u([d()], et.prototype, "description", void 0), u([d({ readOnly: !0 })], et.prototype, "displayName", null), u([d({ type: Mt })], et.prototype, "extent", void 0), u([be("extent")], et.prototype, "readExtent", null), u([d()], et.prototype, "groupCategories", void 0), u([d({ readOnly: !0 })], et.prototype, "iconUrl", null), u([d()], et.prototype, "id", void 0), u([d({ readOnly: !0 })], et.prototype, "isLayer", null), u([d()], et.prototype, "itemControl", void 0), u([d({ readOnly: !0 })], et.prototype, "itemUrl", null), u([d()], et.prototype, "licenseInfo", void 0), u([d({ type: Date })], et.prototype, "modified", void 0), u([d()], et.prototype, "name", void 0), u([d()], et.prototype, "numComments", void 0), u([d()], et.prototype, "numRatings", void 0), u([d()], et.prototype, "numViews", void 0), u([d()], et.prototype, "owner", void 0), u([d()], et.prototype, "ownerFolder", void 0), u([d({ type: os })], et.prototype, "portal", void 0), u([d()], et.prototype, "screenshots", void 0), u([d()], et.prototype, "size", void 0), u([d()], et.prototype, "snippet", void 0), u([d()], et.prototype, "sourceJSON", void 0), u([d()], et.prototype, "tags", void 0), u([d()], et.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], et.prototype, "thumbnailUrl", null), u([d()], et.prototype, "title", void 0), u([d()], et.prototype, "type", void 0), u([d()], et.prototype, "typeKeywords", void 0), u([d()], et.prototype, "url", void 0), u([d({ readOnly: !0 })], et.prototype, "userItemUrl", null), et = eh = u([T("geoscene.portal.PortalItem")], et);
const w1 = et, s6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: w1
}, Symbol.toStringTag, { value: "Module" })), rP = /^([a-z]{2})(?:[-_]([A-Za-z]{2}))?$/, HY = { ar: !0, bg: !0, bs: !0, ca: !0, cs: !0, da: !0, de: !0, el: !0, en: !0, es: !0, et: !0, fi: !0, fr: !0, he: !0, hr: !0, hu: !0, id: !0, it: !0, ja: !0, ko: !0, lt: !0, lv: !0, nb: !0, nl: !0, pl: !0, "pt-BR": !0, "pt-PT": !0, ro: !0, ru: !0, sk: !0, sl: !0, sr: !0, sv: !0, th: !0, tr: !0, uk: !0, vi: !0, "zh-CN": !0, "zh-HK": !0, "zh-TW": !0 };
function iP(e) {
  var t;
  return (t = HY[e]) != null && t;
}
const Xm = [], Xh = /* @__PURE__ */ new Map();
function sP(e) {
  for (const t of Xh.keys())
    a6(e.pattern, t) && Xh.delete(t);
}
function JY(e) {
  return Xm.includes(e) || (sP(e), Xm.unshift(e)), { remove() {
    const t = Xm.indexOf(e);
    t > -1 && (Xm.splice(t, 1), sP(e));
  } };
}
async function o6(e) {
  const t = ts();
  Xh.has(e) || Xh.set(e, KY(e, t));
  const n = Xh.get(e);
  return await YY.add(n), n;
}
function ZY(e) {
  if (!rP.test(e))
    return null;
  const [, t, n] = rP.exec(e), r = t + (n ? "-" + n.toUpperCase() : "");
  return iP(r) ? r : iP(t) ? t : null;
}
async function KY(e, t) {
  const n = [];
  for (const r of Xm)
    if (a6(r.pattern, e))
      try {
        return await r.fetchMessageBundle(e, t);
      } catch (i) {
        n.push(i);
      }
  throw n.length ? new D("intl:message-bundle-error", `Errors occurred while loading "${e}"`, { errors: n }) : new D("intl:no-message-bundle-loader", `No loader found for message bundle "${e}"`);
}
function a6(e, t) {
  return typeof e == "string" ? t.startsWith(e) : e.test(t);
}
uO(() => {
  Xh.clear();
});
const YY = new class {
  constructor() {
    this._numLoading = 0;
  }
  async waitForAll() {
    this._dfd && await this._dfd.promise;
  }
  add(e) {
    return this._increase(), e.then(() => this._decrease(), () => this._decrease()), this.waitForAll();
  }
  _increase() {
    this._numLoading++, this._dfd || (this._dfd = Cl());
  }
  _decrease() {
    this._numLoading = Math.max(this._numLoading - 1, 0), this._dfd && this._numLoading === 0 && (this._dfd.resolve(), this._dfd = null);
  }
}();
async function QY(e) {
  if (!e)
    return;
  const t = e.indexOf("-vector") > -1 ? e.slice(0, e.indexOf("-vector")) : e, n = await o6("geoscene/t9n/basemaps");
  return n[e] || n[t];
}
const tT = { "geoscene-community": { get thumbnailUrl() {
  return ma("geoscene/images/basemap/community.jpg");
}, id: "geoscene-community", classic: !0, title: "", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer" }] }, "geoscene-gray": { get thumbnailUrl() {
  return ma("geoscene/images/basemap/gray.jpg");
}, id: "geoscene-gray", classic: !0, title: "", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetGray/MapServer" }] }, "geoscene-blue": { get thumbnailUrl() {
  return ma("geoscene/images/basemap/blue.jpg");
}, id: "geoscene-blue", classic: !0, title: "", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer" }] }, "geoscene-warm": { get thumbnailUrl() {
  return ma("geoscene/images/basemap/warm.jpg");
}, id: "geoscene-warm", classic: !0, title: "", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetWarm/MapServer" }] }, "tianditu-topography": { classic: !0, title: "-", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/ter_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=ter&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_6884", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cta_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cta&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_4525", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }] }, "tianditu-image": { classic: !0, title: "-", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=img&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_3572", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cia&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_5882", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }] }, "tianditu-vector": { classic: !0, title: "-", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=vec&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_8803", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cva&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_2198", title: "-", type: "WebTiledLayer", layerType: "WebTiledLayer" }] } }, XY = /* @__PURE__ */ new Set(["bing-maps", "imagery", "imagery-tile", "map-image", "open-street-map", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wms", "wmts"]), eQ = /* @__PURE__ */ new Set(["csv", "feature", "geo-rss", "geojson", "group", "imagery", "imagery-tile", "kml", "map-image", "map-notes", "ogc-feature", "route", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wfs", "wms", "wmts"]);
function tQ(e) {
  return e.layerContainerType === "basemap" ? XY : e.layerContainerType === "operational-layers" ? eQ : null;
}
function dO(e) {
  return !(e.type !== "feature" || e.url || !e.source || e.source.type !== "memory");
}
function nQ(e, t) {
  if (t.restrictedWebMapWriting) {
    const n = tQ(t);
    return !O(n) || n.has(e.type) && !dO(e);
  }
  return !0;
}
function rQ(e, t) {
  if (dO(e)) {
    const n = jf("featureCollection.layers", t), r = n && n[0] && n[0].layerDefinition;
    r && M2(e, r);
  } else
    e.type === "stream" ? M2(e, t.layerDefinition = t.layerDefinition || {}) : e.type !== "group" && M2(e, t);
}
function M2(e, t) {
  "maxScale" in e && (t.maxScale = f1(e.maxScale)), "minScale" in e && (t.minScale = f1(e.minScale));
}
function iQ(e, t) {
  if (rQ(e, t), "blendMode" in e && (t.blendMode = e.blendMode, t.blendMode === "normal" && delete t.blendMode), t.opacity = f1(e.opacity), t.title = e.title || "Layer", t.visibility = e.visible, "legendEnabled" in e && e.type !== "wmts")
    if (dO(e)) {
      const n = t.featureCollection;
      n && (n.showLegend = e.legendEnabled);
    } else
      t.showLegend = e.legendEnabled;
}
function oP(e, t, n) {
  if (!("write" in e) || !e.write)
    return n && n.messages && n.messages.push(new D("layer:unsupported", `Layers (${e.title}, ${e.id}) of type '${e.declaredClass}' cannot be persisted`, { layer: e })), null;
  if (nQ(e, n)) {
    const r = {};
    return e.write(r, n) ? r : null;
  }
  return O(t) && iQ(e, t = q(t)), t;
}
var Ib;
let sQ = 0;
const C2 = we.getLogger("geoscene.Basemap");
let ws = Ib = class extends b0(Ol) {
  constructor(e) {
    super(e), this.id = null, this.portalItem = null, this.spatialReference = null, this.thumbnailUrl = null, this.title = "Basemap", this.id = Date.now().toString(16) + "-basemap-" + sQ++, this.baseLayers = new Ne(), this.referenceLayers = new Ne();
    const t = (r) => {
      r.parent && r.parent !== this && "remove" in r.parent && r.parent.remove(r), r.parent = this, r.type === "elevation" && C2.error(`Layer '${r.title}, id:${r.id}' of type '${r.type}' is not supported as a basemap layer and will therefore be ignored.`);
    }, n = (r) => {
      r.parent = null;
    };
    this.baseLayers.on("after-add", (r) => t(r.item)), this.referenceLayers.on("after-add", (r) => t(r.item)), this.baseLayers.on("after-remove", (r) => n(r.item)), this.referenceLayers.on("after-remove", (r) => n(r.item));
  }
  initialize() {
    this.when().catch((e) => {
      C2.error("#load()", `Failed to load basemap (title: '${this.title}', id: '${this.id}')`, e);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    var e;
    const t = this.baseLayers.removeAll();
    for (const r of t)
      r.destroy();
    const n = this.referenceLayers.removeAll();
    for (const r of n)
      r.destroy();
    this.baseLayers.destroy(), this.referenceLayers.destroy(), (e = this.portalItem) == null || e.destroy(), this.portalItem = null;
  }
  normalizeCtorArgs(e) {
    return e && "resourceInfo" in e && (this._set("resourceInfo", e.resourceInfo), delete (e = { ...e }).resourceInfo), e;
  }
  set baseLayers(e) {
    this._set("baseLayers", Xd(e, this._get("baseLayers")));
  }
  _writeBaseLayers(e, t, n) {
    const r = [];
    e && (n = { ...n, layerContainerType: "basemap" }, this.baseLayers.forEach((i) => {
      const s = oP(i, n.webmap ? n.webmap.getLayerJSONFromResourceInfo(i) : null, n);
      O(s) && r.push(s);
    }), this.referenceLayers.forEach((i) => {
      const s = oP(i, n.webmap ? n.webmap.getLayerJSONFromResourceInfo(i) : null, n);
      O(s) && (s.isReference = !0, r.push(s));
    })), t.baseMapLayers = r;
  }
  set referenceLayers(e) {
    this._set("referenceLayers", Xd(e, this._get("referenceLayers")));
  }
  writeTitle(e, t) {
    t.title = e || "Basemap";
  }
  load(e) {
    return this.addResolvingPromise(this._loadFromSource(e)), Promise.resolve(this);
  }
  loadAll() {
    return P8(this, (e) => {
      e(this.baseLayers, this.referenceLayers);
    });
  }
  clone() {
    const e = { id: this.id, title: this.title, portalItem: this.portalItem, baseLayers: this.baseLayers.slice(), referenceLayers: this.referenceLayers.slice() };
    return this.loaded && (e.loadStatus = "loaded"), new Ib({ resourceInfo: this.resourceInfo }).set(e);
  }
  read(e, t) {
    this.resourceInfo || this._set("resourceInfo", { data: e, context: t }), super.read(e, t);
  }
  write(e, t) {
    return e = e || {}, t && t.origin || (t = { origin: "web-map", ...t }), super.write(e, t), !this.loaded && this.resourceInfo && this.resourceInfo.data.baseMapLayers && (e.baseMapLayers = this.resourceInfo.data.baseMapLayers.map((n) => {
      const r = q(n);
      return r.url && Ma(r.url) && (r.url = `https:${r.url}`), r.templateUrl && Ma(r.templateUrl) && (r.templateUrl = `https:${r.templateUrl}`), r;
    })), e;
  }
  async _loadFromSource(e) {
    const { resourceInfo: t, portalItem: n } = this;
    On(e);
    const r = [];
    if (t) {
      const i = t.context ? t.context.url : null;
      if (r.push(this._loadLayersFromJSON(t.data, i, e)), t.data.id && !t.data.title) {
        const s = t.data.id;
        r.push(QY(s).then((o) => {
          o && this.read({ title: o }, t.context);
        }));
      }
    } else
      n && r.push(this._loadFromItem(n, e));
    await Promise.all(r);
  }
  async _loadLayersFromJSON(e, t, n) {
    const r = this.resourceInfo && this.resourceInfo.context, i = this.portalItem && this.portalItem.portal || r && r.portal || null, s = r && r.origin === "web-scene" ? "web-scene" : "web-map", { populateOperationalLayers: o } = await import("./layersCreator-6ySjFtdV.js"), a = [];
    if (On(n), e.baseMapLayers && Array.isArray(e.baseMapLayers)) {
      const l = { context: { origin: s, url: t, portal: i, layerContainerType: "basemap" }, defaultLayerType: "DefaultTileLayer" }, c = o(this.baseLayers, e.baseMapLayers.filter((f) => !f.isReference), l);
      a.push(c);
      const p = o(this.referenceLayers, e.baseMapLayers.filter((f) => f.isReference), l);
      a.push(p);
    }
    await Ii(a);
  }
  async _loadFromItem(e, t) {
    const n = await e.load(t), r = await n.fetchData("json", t), i = cr(e.itemUrl);
    return this._set("resourceInfo", { data: r.baseMap, context: { origin: "web-map", portal: e.portal || os.getDefault(), url: i } }), this.read(this.resourceInfo.data, this.resourceInfo.context), this.read({ spatialReference: r.spatialReference }, this.resourceInfo.context), this.read({ title: e.title, thumbnailUrl: e.thumbnailUrl }, { origin: "portal-item", portal: e.portal || os.getDefault(), url: i }), this._loadLayersFromJSON(this.resourceInfo.data, i, t);
  }
  static fromId(e) {
    const t = tT[e];
    if (t) {
      if (t.deprecated) {
        let n = null;
        e === "dark-gray" ? n = "dark-gray-vector" : e === "gray" ? n = "gray-vector" : e === "streets" ? n = "streets-vector" : e === "topo" && (n = "topo-vector"), D_(C2, `The ${e} basemap has entered mature support and is no longer being updated.`, { replacement: n, see: "https://doc.geoscene.cn/blog/1iq8aD", warnOnce: !0 });
      }
      return Ib.fromJSON(t);
    }
    return null;
  }
};
u([d({ json: { write: { ignoreOrigin: !0, target: "baseMapLayers", writer(e, t, n, r) {
  this._writeBaseLayers(e, t, r);
} }, origins: { "web-scene": { write: { ignoreOrigin: !0, target: { baseMapLayers: { type: Ne } }, writer(e, t, n, r) {
  this._writeBaseLayers(e, t, r);
} } } } } })], ws.prototype, "baseLayers", null), u([d({ type: String, json: { origins: { "web-scene": { write: !0 } } } })], ws.prototype, "id", void 0), u([d({ type: w1 })], ws.prototype, "portalItem", void 0), u([d()], ws.prototype, "referenceLayers", null), u([d({ readOnly: !0 })], ws.prototype, "resourceInfo", void 0), u([d({ type: Qe })], ws.prototype, "spatialReference", void 0), u([d()], ws.prototype, "thumbnailUrl", void 0), u([d({ type: String, json: { origins: { "web-scene": { write: { isRequired: !0 } } } } })], ws.prototype, "title", void 0), u([xe("title")], ws.prototype, "writeTitle", null), ws = Ib = u([T("geoscene.Basemap")], ws);
const _1 = ws, oQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _1
}, Symbol.toStringTag, { value: "Module" })), S1 = { transparent: [0, 0, 0, 0], black: [0, 0, 0, 1], silver: [192, 192, 192, 1], gray: [128, 128, 128, 1], white: [255, 255, 255, 1], maroon: [128, 0, 0, 1], red: [255, 0, 0, 1], purple: [128, 0, 128, 1], fuchsia: [255, 0, 255, 1], green: [0, 128, 0, 1], lime: [0, 255, 0, 1], olive: [128, 128, 0, 1], yellow: [255, 255, 0, 1], navy: [0, 0, 128, 1], blue: [0, 0, 255, 1], teal: [0, 128, 128, 1], aqua: [0, 255, 255, 1], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], blanchedalmond: [255, 235, 205, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], oldlace: [253, 245, 230, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], rebeccapurple: [102, 51, 153, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], whitesmoke: [245, 245, 245, 1], yellowgreen: [154, 205, 50, 1] };
function l6(e) {
  return S1[e] || S1[e.toLowerCase()];
}
function pO(e) {
  var t;
  return (t = S1[e]) != null ? t : S1[e.toLowerCase()];
}
function aQ(e) {
  return [...pO(e)];
}
function O2(e, t, n) {
  n < 0 && ++n, n > 1 && --n;
  const r = 6 * n;
  return r < 1 ? e + (t - e) * r : 2 * n < 1 ? t : 3 * n < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function u6(e, t, n, r = 1) {
  const i = (e % 360 + 360) % 360 / 360, s = n <= 0.5 ? n * (t + 1) : n + t - n * t, o = 2 * n - s;
  return [Math.round(255 * O2(o, s, i + 1 / 3)), Math.round(255 * O2(o, s, i)), Math.round(255 * O2(o, s, i - 1 / 3)), r];
}
function lQ(e) {
  const t = e.length > 5, n = t ? 8 : 4, r = (1 << n) - 1, i = t ? 1 : 17, s = t ? e.length === 9 : e.length === 5;
  let o = +("0x" + e.substr(1));
  if (isNaN(o))
    return null;
  const a = [0, 0, 0, 1];
  let l;
  return s && (l = o & r, o >>= n, a[3] = i * l / 255), l = o & r, o >>= n, a[2] = i * l, l = o & r, o >>= n, a[1] = i * l, l = o & r, o >>= n, a[0] = i * l, a;
}
function qf() {
  return [0, 0, 0];
}
function UAe(e) {
  return [e[0], e[1], e[2]];
}
function c6(e, t, n) {
  return [e, t, n];
}
function qAe(e) {
  const t = qf(), n = Math.min(3, e.length);
  for (let r = 0; r < n; ++r)
    t[r] = e[r];
  return t;
}
function GAe(e, t) {
  return new Float64Array(e, t, 3);
}
function uQ() {
  return qf();
}
function cQ() {
  return c6(1, 1, 1);
}
const WAe = uQ(), dQ = cQ(), Dn = 1e-6, pQ = Math.PI / 180;
function d6(e) {
  return e * pQ;
}
function HAe(e) {
  const t = e[0], n = e[1], r = e[2];
  return Math.sqrt(t * t + n * n + r * r);
}
function JAe(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
}
function ZAe(e, t, n, r) {
  return e[0] = t, e[1] = n, e[2] = r, e;
}
function KAe(e, t, n) {
  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e;
}
function YAe(e, t, n) {
  return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e;
}
function QAe(e, t, n) {
  return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e;
}
function hQ(e, t, n) {
  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e;
}
function XAe(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2];
  return Math.sqrt(n * n + r * r + i * i);
}
function ePe(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1], i = t[2] - e[2];
  return n * n + r * r + i * i;
}
function tPe(e, t) {
  const n = t[0], r = t[1], i = t[2];
  let s = n * n + r * r + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s), e;
}
function nPe(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function rPe(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = n[0], a = n[1], l = n[2];
  return e[0] = i * l - s * a, e[1] = s * o - r * l, e[2] = r * a - i * o, e;
}
function iPe(e, t, n, r) {
  const i = t[0], s = t[1], o = t[2];
  return e[0] = i + r * (n[0] - i), e[1] = s + r * (n[1] - s), e[2] = o + r * (n[2] - o), e;
}
function sPe(e, t, n) {
  const r = t[0], i = t[1], s = t[2];
  return e[0] = n[0] * r + n[4] * i + n[8] * s + n[12], e[1] = n[1] * r + n[5] * i + n[9] * s + n[13], e[2] = n[2] * r + n[6] * i + n[10] * s + n[14], e;
}
function oPe(e, t, n) {
  const r = t[0], i = t[1], s = t[2];
  return e[0] = r * n[0] + i * n[3] + s * n[6], e[1] = r * n[1] + i * n[4] + s * n[7], e[2] = r * n[2] + i * n[5] + s * n[8], e;
}
function aPe(e, t, n) {
  const r = n[0], i = n[1], s = n[2], o = n[3], a = t[0], l = t[1], c = t[2];
  let p = i * c - s * l, f = s * a - r * c, m = r * l - i * a, y = i * m - s * f, g = s * p - r * m, v = r * f - i * p;
  const w = 2 * o;
  return p *= w, f *= w, m *= w, y *= 2, g *= 2, v *= 2, e[0] = a + p + y, e[1] = l + f + g, e[2] = c + m + v, e;
}
function lPe(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
}
function uPe(e, t, n) {
  const r = n[0] - t[0], i = n[1] - t[1], s = n[2] - t[2];
  let o = r * r + i * i + s * s;
  return o > 0 ? (o = 1 / Math.sqrt(o), e[0] = r * o, e[1] = i * o, e[2] = s * o, e) : (e[0] = 0, e[1] = 0, e[2] = 0, e);
}
const aP = new Float32Array(1);
function cPe(e) {
  --e;
  for (let t = 1; t < 32; t <<= 1)
    e |= e >> t;
  return e + 1;
}
function js(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function dPe(e) {
  return (e & e - 1) == 0;
}
function pPe(e) {
  return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e;
}
function hPe(e, t, n) {
  return e + (t - e) * n;
}
function fQ(e) {
  return e * Math.PI / 180;
}
function p6(e) {
  return 180 * e / Math.PI;
}
function fPe(e) {
  return Math.acos(js(e, -1, 1));
}
function mQ(e) {
  return Math.asin(js(e, -1, 1));
}
function mPe(e) {
  return h6(Math.max(-lP, Math.min(e, lP)));
}
function h6(e) {
  return aP[0] = e, aP[0];
}
const lP = h6(34028234663852886e22);
function dv(e) {
  return js(HC(e), 0, 255);
}
function pv(e, t, n) {
  return e = Number(e), isNaN(e) ? n : e < t ? t : e > n ? n : e;
}
let Mb = class mr {
  constructor(t) {
    this.r = 255, this.g = 255, this.b = 255, this.a = 1, t && this.setColor(t);
  }
  static blendColors(t, n, r, i = new mr()) {
    return i.r = Math.round(t.r + (n.r - t.r) * r), i.g = Math.round(t.g + (n.g - t.g) * r), i.b = Math.round(t.b + (n.b - t.b) * r), i.a = t.a + (n.a - t.a) * r, i._sanitize();
  }
  static fromRgb(t, n) {
    const r = t.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
    if (r) {
      const i = r[2].split(/\s*,\s*/), s = r[1];
      if (s === "rgb" && i.length === 3 || s === "rgba" && i.length === 4) {
        const o = i[0];
        if (o.charAt(o.length - 1) === "%") {
          const a = i.map((l) => 2.56 * parseFloat(l));
          return i.length === 4 && (a[3] = parseFloat(i[3])), mr.fromArray(a, n);
        }
        return mr.fromArray(i.map((a) => parseFloat(a)), n);
      }
      if (s === "hsl" && i.length === 3 || s === "hsla" && i.length === 4)
        return mr.fromArray(u6(parseFloat(i[0]), parseFloat(i[1]) / 100, parseFloat(i[2]) / 100, parseFloat(i[3])), n);
    }
    return null;
  }
  static fromHex(t, n = new mr()) {
    if (t.length !== 4 && t.length !== 7 || t[0] !== "#")
      return null;
    const r = t.length === 4 ? 4 : 8, i = (1 << r) - 1;
    let s = +("0x" + t.substr(1));
    return isNaN(s) ? null : (["b", "g", "r"].forEach((o) => {
      const a = s & i;
      s >>= r, n[o] = r === 4 ? 17 * a : a;
    }), n.a = 1, n);
  }
  static fromArray(t, n = new mr()) {
    return n._set(Number(t[0]), Number(t[1]), Number(t[2]), Number(t[3])), isNaN(n.a) && (n.a = 1), n._sanitize();
  }
  static fromString(t, n) {
    const r = l6(t) ? pO(t) : null;
    return r && mr.fromArray(r, n) || mr.fromRgb(t, n) || mr.fromHex(t, n);
  }
  static fromJSON(t) {
    return t && new mr([t[0], t[1], t[2], t[3] / 255]);
  }
  static toUnitRGB(t) {
    return O(t) ? [t.r / 255, t.g / 255, t.b / 255] : null;
  }
  static toUnitRGBA(t) {
    return O(t) ? [t.r / 255, t.g / 255, t.b / 255, t.a != null ? t.a : 1] : null;
  }
  get isBright() {
    return 0.299 * this.r + 0.587 * this.g + 0.114 * this.b >= 127;
  }
  setColor(t) {
    if (typeof t == "string")
      mr.fromString(t, this);
    else if (Array.isArray(t))
      mr.fromArray(t, this);
    else {
      var n, r, i, s;
      this._set((n = t.r) != null ? n : 0, (r = t.g) != null ? r : 0, (i = t.b) != null ? i : 0, (s = t.a) != null ? s : 1), t instanceof mr || this._sanitize();
    }
    return this;
  }
  toRgb() {
    return [this.r, this.g, this.b];
  }
  toRgba() {
    return [this.r, this.g, this.b, this.a];
  }
  toHex() {
    const t = this.r.toString(16), n = this.g.toString(16), r = this.b.toString(16);
    return `#${t.length < 2 ? "0" + t : t}${n.length < 2 ? "0" + n : n}${r.length < 2 ? "0" + r : r}`;
  }
  toCss(t = !1) {
    const n = this.r + ", " + this.g + ", " + this.b;
    return t ? `rgba(${n}, ${this.a})` : `rgb(${n})`;
  }
  toString() {
    return this.toCss(!0);
  }
  toJSON() {
    return this.toArray();
  }
  toArray(t = mr.AlphaMode.ALWAYS) {
    const n = dv(this.r), r = dv(this.g), i = dv(this.b);
    return t === mr.AlphaMode.ALWAYS || this.a !== 1 ? [n, r, i, dv(255 * this.a)] : [n, r, i];
  }
  clone() {
    return new mr(this.toRgba());
  }
  hash() {
    return this.r << 24 | this.g << 16 | this.b << 8 | 255 * this.a;
  }
  equals(t) {
    return O(t) && t.r === this.r && t.g === this.g && t.b === this.b && t.a === this.a;
  }
  _sanitize() {
    return this.r = Math.round(pv(this.r, 0, 255)), this.g = Math.round(pv(this.g, 0, 255)), this.b = Math.round(pv(this.b, 0, 255)), this.a = pv(this.a, 0, 1), this;
  }
  _set(t, n, r, i) {
    this.r = t, this.g = n, this.b = r, this.a = i;
  }
};
Mb.prototype.declaredClass = "geoscene.Color", function(e) {
  var t;
  (t = e.AlphaMode || (e.AlphaMode = {}))[t.ALWAYS = 0] = "ALWAYS", t[t.UNLESS_OPAQUE = 1] = "UNLESS_OPAQUE";
}(Mb || (Mb = {}));
const Fe = Mb;
function yPe(e) {
}
function yQ(e) {
  return () => e;
}
function De(e, t = {}) {
  var n;
  const r = e instanceof st ? e : new st(e, t), i = { type: (n = t == null ? void 0 : t.ignoreUnknown) == null || n ? r.apiValues : String, json: { type: r.jsonValues, read: (t == null || !t.readOnly) && { reader: r.read }, write: { writer: r.write } } };
  return (t == null ? void 0 : t.readOnly) !== void 0 && (i.readOnly = !!t.readOnly), (t == null ? void 0 : t.default) !== void 0 && (i.json.default = t.default), (t == null ? void 0 : t.name) !== void 0 && (i.json.name = t.name), d(i);
}
var nT;
let Cb = nT = class extends se {
  constructor(e) {
    super(e), this.type = "none";
  }
  clone() {
    return new nT({ type: this.type });
  }
};
u([De({ none: "none", stayAbove: "stay-above" })], Cb.prototype, "type", void 0), Cb = nT = u([T("geoscene.ground.NavigationConstraint")], Cb);
function hO(e) {
  const t = HC(100 * (1 - e));
  return Math.max(0, Math.min(t, 100));
}
function kg(e) {
  const t = 1 - e / 100;
  return Math.max(0, Math.min(t, 1));
}
var rT;
const uP = we.getLogger("geoscene.Ground");
let Ga = rT = class extends b0(Ol) {
  constructor(e) {
    super(e), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new Ne();
    const t = (r) => {
      r.parent && r.parent !== this && "remove" in r.parent && r.parent.remove(r), r.parent = this, r.type !== "elevation" && r.type !== "base-elevation" && uP.error(`Layer '${r.title}, id:${r.id}' of type '${r.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, n = (r) => {
      r.parent = null;
    };
    this.layers.on("after-add", (r) => t(r.item)), this.layers.on("after-remove", (r) => n(r.item));
  }
  initialize() {
    this.when().catch((e) => {
      uP.error("#load()", "Failed to load ground", e);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const e = this.layers.removeAll();
    for (const t of e)
      t.destroy();
    this.layers.destroy();
  }
  normalizeCtorArgs(e) {
    return e && "resourceInfo" in e && (this._set("resourceInfo", e.resourceInfo), delete (e = { ...e }).resourceInfo), e;
  }
  set layers(e) {
    this._set("layers", Xd(e, this._get("layers")));
  }
  writeLayers(e, t, n, r) {
    const i = [];
    e && (r = { ...r, layerContainerType: "ground" }, e.forEach((s) => {
      if ("write" in s) {
        const o = {};
        yQ(s)().write(o, r) && i.push(o);
      } else
        r && r.messages && r.messages.push(new D("layer:unsupported", `Layers (${s.title}, ${s.id}) of type '${s.declaredClass}' cannot be persisted in the ground`, { layer: s }));
    })), t.layers = i;
  }
  load(e) {
    return this.addResolvingPromise(this._loadFromSource(e)), Promise.resolve(this);
  }
  loadAll() {
    return P8(this, (e) => {
      e(this.layers);
    });
  }
  async queryElevation(e, t) {
    await this.load({ signal: t == null ? void 0 : t.signal });
    const { ElevationQuery: n } = await import("./ElevationQuery-LJczKMO4.js");
    On(t);
    const r = new n(), i = this.layers.filter(cP).toArray();
    return r.queryAll(i, e, t);
  }
  async createElevationSampler(e, t) {
    await this.load({ signal: t == null ? void 0 : t.signal });
    const { ElevationQuery: n } = await import("./ElevationQuery-LJczKMO4.js");
    On(t);
    const r = new n(), i = this.layers.filter(cP).toArray();
    return r.createSamplerAll(i, e, t);
  }
  clone() {
    const e = { opacity: this.opacity, surfaceColor: q(this.surfaceColor), navigationConstraint: q(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (e.loadStatus = "loaded"), new rT({ resourceInfo: this.resourceInfo }).set(e);
  }
  read(e, t) {
    this.resourceInfo || this._set("resourceInfo", { data: e, context: t }), super.read(e, t);
  }
  _loadFromSource(e) {
    const t = this.resourceInfo;
    return t ? this._loadLayersFromJSON(t.data, t.context, e) : Promise.resolve(null);
  }
  _loadLayersFromJSON(e, t, n) {
    const r = t && t.origin || "web-scene", i = t && t.portal || null, s = t && t.url || null;
    return import("./layersCreator-6ySjFtdV.js").then(({ populateOperationalLayers: o }) => {
      On(n);
      const a = [];
      if (e.layers && Array.isArray(e.layers)) {
        const l = { context: { origin: r, url: s, portal: i, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
        a.push(o(this.layers, e.layers, l));
      }
      return Ii(a);
    }).then(() => {
    });
  }
};
function gQ(e) {
  return e && "createElevationSampler" in e;
}
function cP(e) {
  return e.type === "elevation" || gQ(e);
}
u([d({ json: { read: !1 } })], Ga.prototype, "layers", null), u([xe("layers")], Ga.prototype, "writeLayers", null), u([d({ readOnly: !0 })], Ga.prototype, "resourceInfo", void 0), u([d({ type: Number, nonNullable: !0, range: { min: 0, max: 1 }, json: { type: Vt, read: { reader: kg, source: "transparency" }, write: { writer: (e, t) => {
  t.transparency = hO(e);
}, target: "transparency" } } })], Ga.prototype, "opacity", void 0), u([d({ type: Fe, json: { type: [Vt], write: (e, t) => {
  t.surfaceColor = e.toJSON().slice(0, 3);
} } })], Ga.prototype, "surfaceColor", void 0), u([d({ type: Cb, json: { write: !0 } })], Ga.prototype, "navigationConstraint", void 0), Ga = rT = u([T("geoscene.Ground")], Ga);
const x1 = Ga;
let Ob = class extends ke {
  constructor(t) {
    super(t), this._groups = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.removeAll();
  }
  get size() {
    let t = 0;
    return this._groups.forEach((n) => {
      t += n.length;
    }), t;
  }
  add(t, n) {
    if (!this._isHandle(t) && !Array.isArray(t) && !Ne.isCollection(t))
      return this;
    const r = this._getOrCreateGroup(n);
    return Array.isArray(t) || Ne.isCollection(t) ? t.forEach((i) => this._isHandle(i) && r.push(i)) : r.push(t), this.notifyChange("size"), this;
  }
  forEach(t, n) {
    if (typeof t == "function")
      this._groups.forEach((r) => r.forEach(t));
    else {
      const r = this._getGroup(t);
      r && n && r.forEach(n);
    }
  }
  has(t) {
    return this._groups.has(this._ensureGroupKey(t));
  }
  remove(t) {
    if (Array.isArray(t) || Ne.isCollection(t))
      return t.forEach(this.remove, this), this;
    if (!this.has(t))
      return this;
    const n = this._getGroup(t);
    for (let r = 0; r < n.length; r++)
      n[r].remove();
    return this._deleteGroup(t), this.notifyChange("size"), this;
  }
  removeAll() {
    return this._groups.forEach((t) => {
      for (let n = 0; n < t.length; n++)
        t[n].remove();
    }), this._groups.clear(), this.notifyChange("size"), this;
  }
  _isHandle(t) {
    return t && !!t.remove;
  }
  _getOrCreateGroup(t) {
    if (this.has(t))
      return this._getGroup(t);
    const n = [];
    return this._groups.set(this._ensureGroupKey(t), n), n;
  }
  _getGroup(t) {
    return this._groups.get(this._ensureGroupKey(t));
  }
  _deleteGroup(t) {
    return this._groups.delete(this._ensureGroupKey(t));
  }
  _ensureGroupKey(t) {
    return t || "_default_";
  }
};
u([d({ readOnly: !0 })], Ob.prototype, "size", null), Ob = u([T("geoscene.core.Handles")], Ob);
const ei = Ob;
function Nt(e, t, n = {}) {
  return fO(e, t, n, f6);
}
function rS(e, t, n = {}) {
  return fO(e, t, n, m6);
}
function fO(e, t, n = {}, r) {
  let i = null;
  const s = n.once ? (o, a) => {
    r(o) && (Sp(i), t(o, a));
  } : (o, a) => {
    r(o) && t(o, a);
  };
  if (i = pZ(e, s, n.sync, n.equals), n.initial) {
    const o = e();
    s(o, o);
  }
  return i;
}
function iT(e, t, n, r = {}) {
  let i = null, s = null, o = null;
  function a() {
    i && s && (s.remove(), r.onListenerRemove == null || r.onListenerRemove(i), i = null, s = null);
  }
  function l(p) {
    r.once && r.once && Sp(o), n(p);
  }
  const c = Nt(e, (p, f) => {
    a(), B_(p) && (i = p, s = U_(p, t, l), r.onListenerAdd == null || r.onListenerAdd(p));
  }, { sync: r.sync, initial: !0 });
  return o = Vf(() => {
    c.remove(), a();
  }), o;
}
function mO(e, t) {
  return vQ(e, m6, t);
}
function vQ(e, t, n) {
  if (Ea(n))
    return Promise.reject(Cn());
  const r = e();
  if (t != null && t(r))
    return Promise.resolve(r);
  let i = null;
  function s() {
    i = Sp(i);
  }
  return new Promise((o, a) => {
    i = V_([Ao(n, () => {
      s(), a(Cn());
    }), fO(e, (l) => {
      s(), o(l);
    }, { sync: !1, once: !0 }, t ?? f6)]);
  });
}
function f6(e) {
  return !0;
}
function m6(e) {
  return !!e;
}
const sT = { sync: !0 }, va = { initial: !0 }, Rc = { sync: !0, initial: !0 };
let ef = class extends ke {
  constructor() {
    super(...arguments), this.updating = !1, this.handleId = 0, this.handles = new ei(), this.scheduleHandleId = 0, this.pendingPromises = /* @__PURE__ */ new Set();
  }
  destroy() {
    this.removeAll(), this.handles.destroy();
  }
  add(t, n, r = {}) {
    return this._installWatch(t, n, r, Nt);
  }
  addWhen(t, n, r = {}) {
    return this._installWatch(t, n, r, rS);
  }
  addOnCollectionChange(t, n, { initial: r = !1 } = {}) {
    const i = ++this.handleId;
    return this.handles.add([iT(t, "after-changes", this._createSyncUpdatingCallback(), sT), iT(t, "change", n, { onListenerAdd: r ? (s) => n({ added: s.toArray(), removed: [] }) : void 0 })], i), { remove: () => this.handles.remove(i) };
  }
  addPromise(t) {
    if (H(t))
      return t;
    const n = ++this.handleId;
    this.handles.add({ remove: () => {
      this.pendingPromises.delete(t) && (this.pendingPromises.size !== 0 || this.handles.has(hv) || this._set("updating", !1));
    } }, n), this.pendingPromises.add(t), this._set("updating", !0);
    const r = () => this.handles.remove(n);
    return t.then(r, r), t;
  }
  removeAll() {
    this.pendingPromises.clear(), this.handles.removeAll(), this._set("updating", !1);
  }
  _installWatch(t, n, r = {}, i) {
    const s = ++this.handleId;
    r.sync || this._installSyncUpdatingWatch(t, s);
    const o = i(t, n, r);
    return this.handles.add(o, s), { remove: () => this.handles.remove(s) };
  }
  _installSyncUpdatingWatch(t, n) {
    const r = this._createSyncUpdatingCallback(), i = Nt(t, r, { sync: !0, equals: () => !1 });
    return this.handles.add(i, n), i;
  }
  _createSyncUpdatingCallback() {
    return () => {
      this.handles.remove(hv), ++this.scheduleHandleId;
      const t = this.scheduleHandleId;
      this._get("updating") || this._set("updating", !0), this.handles.add(g0(() => {
        t === this.scheduleHandleId && (this._set("updating", this.pendingPromises.size > 0), this.handles.remove(hv));
      }), hv);
    };
  }
};
u([d({ readOnly: !0 })], ef.prototype, "updating", void 0), ef = u([T("geoscene.views.support.WatchUpdatingTracking")], ef);
const hv = -42;
var dP;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SYNC = 1] = "SYNC", e[e.INIT = 2] = "INIT";
})(dP || (dP = {}));
const $p = (e) => {
  let t = class extends e {
    destroy() {
      var n, r;
      this.destroyed || ((n = this._get("handles")) == null || n.destroy(), (r = this._get("updatingHandles")) == null || r.destroy());
    }
    get handles() {
      return this._get("handles") || new ei();
    }
    get updatingHandles() {
      return this._get("updatingHandles") || new ef();
    }
  };
  return u([d({ readOnly: !0 })], t.prototype, "handles", null), u([d({ readOnly: !0 })], t.prototype, "updatingHandles", null), t = u([T("geoscene.core.HandleOwner")], t), t;
};
let hf = class extends $p(ke) {
};
hf = u([T("geoscene.core.HandleOwner")], hf);
let th = class extends $p(Ne) {
  constructor(t) {
    super(t), this.getCollections = null;
  }
  initialize() {
    this.handles.add(s8(() => this._refresh()));
  }
  destroy() {
    this.getCollections = null;
  }
  _refresh() {
    const t = O(this.getCollections) ? this.getCollections() : null;
    if (H(t))
      return void this.removeAll();
    let n = 0;
    for (const r of t)
      O(r) && (n = this._processCollection(n, r));
    this.splice(n, this.length);
  }
  _createNewInstance(t) {
    return new Ne(t);
  }
  _processCollection(t, n) {
    if (!n)
      return t;
    const r = this.itemFilterFunction ? this.itemFilterFunction : (i) => !!i;
    for (const i of n)
      if (i) {
        if (r(i)) {
          const s = this.indexOf(i, t);
          s >= 0 ? s !== t && this.reorder(i, t) : this.add(i, t), ++t;
        }
        if (this.getChildrenFunction) {
          const s = this.getChildrenFunction(i);
          if (Array.isArray(s))
            for (const o of s)
              t = this._processCollection(t, o);
          else
            t = this._processCollection(t, s);
        }
      }
    return t;
  }
};
u([d()], th.prototype, "getCollections", void 0), u([d()], th.prototype, "getChildrenFunction", void 0), u([d()], th.prototype, "itemFilterFunction", void 0), th = u([T("geoscene.core.CollectionFlattener")], th);
const tf = th;
function bQ(e) {
  var t;
  return !!(e && e.loaded && "capabilities" in e && e != null && (t = e.capabilities) != null && t.operations && "supportsEditing" in e.capabilities.operations && e.capabilities.operations.supportsEditing === !0) && !("editingEnabled" in e && !e.editingEnabled);
}
const pP = we.getLogger("geoscene.support.basemapUtils");
function wQ() {
  return {};
}
function _Q(e) {
  for (const t in e) {
    const n = e[t];
    (n == null ? void 0 : n.destroyed) === !1 && n.destroy(), delete e[t];
  }
}
function SQ(e, t) {
  var n;
  let r;
  if (typeof e == "string") {
    if (!(e in tT)) {
      const i = Object.entries(tT).filter(([s, o]) => Pt.apiKey && !o.classic || !Pt.apiKey && o.classic && !o.deprecated).map(([s]) => `"${s}"`).join(", ");
      return pP.warn(`Unable to find basemap definition for: ${e}. Try one of these: ${i}`), null;
    }
    t && (r = t[e]), r || (r = _1.fromId(e), t && (t[e] = r));
  } else
    r = kn(_1, e);
  return (n = r) != null && n.destroyed && (pP.warn("The provided basemap is already destroyed", { basemap: r }), r = null), r;
}
const xQ = we.getLogger("geoscene.support.groundUtils"), hP = { "world-elevation": { id: "worldElevation", url: "//links.geoscene.cn/geoscene/rest/services/elevation3d/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//links.geoscene.cn/geoscene/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function $Q(e) {
  let t = null;
  if (typeof e == "string")
    if (e in hP) {
      const n = hP[e];
      t = new x1({ resourceInfo: { data: { layers: [n] } } });
    } else
      xQ.warn(`Unable to find ground definition for: ${e}. Try "world-elevation"`);
  else
    t = kn(x1, e);
  return t;
}
function ff(e, t, n = !1) {
  let { hasM: r, hasZ: i } = e;
  Array.isArray(t) ? t.length !== 4 || r || i ? t.length === 3 && n && !r ? (i = !0, r = !1) : t.length === 3 && r && i && (r = !1, i = !1) : (r = !0, i = !0) : (i = !i && t.hasZ && (!r || t.hasM), r = !r && t.hasM && (!i || t.hasZ)), e.hasZ = i, e.hasM = r;
}
var oT;
function fP(e) {
  return (t, n) => t == null ? n : n == null ? t : e(t, n);
}
function TQ(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
let ru = oT = class extends Ci {
  constructor(...e) {
    super(...e), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(e, t) {
    if (!e && !t)
      return null;
    const n = {};
    Array.isArray(e) ? (n.points = e, n.spatialReference = t) : TQ(e) ? n.spatialReference = e : (e.points && (n.points = e.points), e.spatialReference && (n.spatialReference = e.spatialReference), e.hasZ && (n.hasZ = e.hasZ), e.hasM && (n.hasM = e.hasM));
    const r = n.points && n.points[0];
    return r && (n.hasZ === void 0 && n.hasM === void 0 ? (n.hasZ = r.length > 2, n.hasM = !1) : n.hasZ === void 0 ? n.hasZ = r.length > 3 : n.hasM === void 0 && (n.hasM = r.length > 3)), n;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const e = this.points;
    if (!e.length)
      return null;
    const t = new Mt(), n = this.hasZ, r = this.hasM, i = n ? 3 : 2, s = e[0], o = fP(Math.min), a = fP(Math.max);
    let l, c, p, f, [m, y] = s, [g, v] = s;
    for (let w = 0, b = e.length; w < b; w++) {
      const S = e[w], [$, I] = S;
      if (m = o(m, $), y = o(y, I), g = a(g, $), v = a(v, I), n && S.length > 2) {
        const M = S[2];
        l = o(l, M), p = a(p, M);
      }
      if (r && S.length > i) {
        const M = S[i];
        c = o(c, M), f = a(f, M);
      }
    }
    return t.xmin = m, t.ymin = y, t.xmax = g, t.ymax = v, t.spatialReference = this.spatialReference, n ? (t.zmin = l, t.zmax = p) : (t.zmin = null, t.zmax = null), r ? (t.mmin = c, t.mmax = f) : (t.mmin = null, t.mmax = null), t;
  }
  writePoints(e, t) {
    t.points = q(this.points);
  }
  addPoint(e) {
    return ff(this, e), Array.isArray(e) ? this.points.push(e) : this.points.push(e.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const e = { points: q(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (e.hasZ = !0), this.hasM && (e.hasM = !0), new oT(e);
  }
  getPoint(e) {
    if (!this._validateInputs(e))
      return null;
    const t = this.points[e], n = { x: t[0], y: t[1], spatialReference: this.spatialReference };
    let r = 2;
    return this.hasZ && (n.z = t[2], r = 3), this.hasM && (n.m = t[r]), new Oe(n);
  }
  removePoint(e) {
    if (!this._validateInputs(e))
      return null;
    const t = new Oe(this.points.splice(e, 1)[0], this.spatialReference);
    return this.notifyChange("points"), t;
  }
  setPoint(e, t) {
    return this._validateInputs(e) ? (ff(this, t), Array.isArray(t) || (t = t.toArray()), this.points[e] = t, this.notifyChange("points"), this) : this;
  }
  toJSON(e) {
    return this.write({}, e);
  }
  _validateInputs(e) {
    return e != null && e >= 0 && e < this.points.length;
  }
};
u([d({ readOnly: !0 })], ru.prototype, "cache", null), u([d()], ru.prototype, "extent", null), u([d({ type: [[Number]], json: { write: { isRequired: !0 } } })], ru.prototype, "points", void 0), u([xe("points")], ru.prototype, "writePoints", null), ru = oT = u([T("geoscene.geometry.Multipoint")], ru), ru.prototype.toJSON.isDefaultToJSON = !0;
const Gf = ru;
function EQ(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1];
  if (e.length > 2 && t.length > 2) {
    const i = e[2] - t[2];
    return Math.sqrt(n * n + r * r + i * i);
  }
  return Math.sqrt(n * n + r * r);
}
function IQ(e, t, n) {
  const r = e[0] + n * (t[0] - e[0]), i = e[1] + n * (t[1] - e[1]);
  return e.length > 2 && t.length > 2 ? [r, i, e[2] + n * (t[2] - e[2])] : [r, i];
}
function MQ(e, t, n, r) {
  const [i, s] = t, [o, a] = n[r], [l, c] = n[r + 1], p = l - o, f = c - a, m = p * p + f * f, y = (i - o) * p + (s - a) * f, g = Math.min(1, Math.max(0, y / m));
  return e[0] = o + p * g, e[1] = a + f * g, e;
}
function CQ(e, t) {
  return IQ(e, t, 0.5);
}
function yO(e, t, n) {
  const r = e.length;
  let i = 0, s = 0, o = 0;
  for (let a = 0; a < r; a++) {
    const l = e[a], c = e[(a + 1) % r];
    let p = 2;
    i += l[0] * c[1] - c[0] * l[1], l.length > 2 && c.length > 2 && n && (s += l[0] * c[2] - c[0] * l[2], p = 3), l.length > p && c.length > p && t && (o += l[0] * c[p] - c[0] * l[p]);
  }
  return i <= 0 && s <= 0 && o <= 0;
}
function _Pe(e) {
  if ("rings" in e) {
    for (const t of e.rings)
      t.length < 3 || t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] || t.push([t[0][0], t[0][1]]);
    if (e.rings.length > 0 && !yO(e.rings[0], e.hasM, e.hasZ))
      for (let t = 0; t < e.rings.length; ++t)
        e.rings[t] = e.rings[t].reverse();
  }
}
function SPe(e) {
  return e ? e.hasZ ? [e.xmax - e.xmin / 2, e.ymax - e.ymin / 2, e.zmax - e.zmin / 2] : [e.xmax - e.xmin / 2, e.ymax - e.ymin / 2] : null;
}
function OQ(e) {
  return e ? kQ(e.rings, e.hasZ) : null;
}
function kQ(e, t) {
  if (!e || !e.length)
    return null;
  const n = [], r = [], i = t ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let s = 0, o = e.length; s < o; s++) {
    const a = AQ(e[s], t, i);
    a && r.push(a);
  }
  if (r.sort((s, o) => {
    let a = s[2] - o[2];
    return a === 0 && t && (a = s[4] - o[4]), a;
  }), r.length && (n[0] = r[0][0], n[1] = r[0][1], t && (n[2] = r[0][3]), (n[0] < i[0] || n[0] > i[1] || n[1] < i[2] || n[1] > i[3] || t && (n[2] < i[4] || n[2] > i[5])) && (n.length = 0)), !n.length) {
    const s = e[0] && e[0].length ? PQ(e[0], t) : null;
    if (!s)
      return null;
    n[0] = s[0], n[1] = s[1], t && s.length > 2 && (n[2] = s[2]);
  }
  return n;
}
function AQ(e, t, n) {
  let r = 0, i = 0, s = 0, o = 0, a = 0;
  const l = e.length ? e[0][0] : 0, c = e.length ? e[0][1] : 0, p = e.length && t ? e[0][2] : 0;
  for (let m = 0; m < e.length; m++) {
    const y = e[m], g = e[(m + 1) % e.length], [v, w, b] = y, S = v - l, $ = w - c, I = t ? b - p : void 0, [M, E, C] = g, A = M - l, W = E - c, j = t ? C - p : void 0, G = S * W - A * $;
    if (o += G, r += (S + A) * G, i += ($ + W) * G, t && y.length > 2 && g.length > 2) {
      const R = S * j - A * I;
      s += (I + j) * R, a += R;
    }
    v < n[0] && (n[0] = v), v > n[1] && (n[1] = v), w < n[2] && (n[2] = w), w > n[3] && (n[3] = w), t && (b < n[4] && (n[4] = b), b > n[5] && (n[5] = b));
  }
  if (o > 0 && (o *= -1), a > 0 && (a *= -1), !o)
    return null;
  o *= 0.5, a *= 0.5;
  const f = [r / (6 * o) + l, i / (6 * o) + c, o];
  return t && (n[4] === n[5] || a === 0 ? (f[3] = (n[4] + n[5]) / 2, f[4] = 0) : (f[3] = s / (6 * a) + p, f[4] = a)), f;
}
function PQ(e, t) {
  const n = t ? [0, 0, 0] : [0, 0], r = t ? [0, 0, 0] : [0, 0];
  let i = 0, s = 0, o = 0, a = 0;
  for (let l = 0, c = e.length; l < c - 1; l++) {
    const p = e[l], f = e[l + 1];
    if (p && f) {
      n[0] = p[0], n[1] = p[1], r[0] = f[0], r[1] = f[1], t && p.length > 2 && f.length > 2 && (n[2] = p[2], r[2] = f[2]);
      const m = EQ(n, r);
      if (m) {
        i += m;
        const y = CQ(p, f);
        s += m * y[0], o += m * y[1], t && y.length > 2 && (a += m * y[2]);
      }
    }
  }
  return i > 0 ? t ? [s / i, o / i, a / i] : [s / i, o / i] : e.length ? e[0] : null;
}
function y6(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function g6(e) {
  return e.points !== void 0;
}
function v6(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function b6(e) {
  return e.paths !== void 0;
}
function w6(e) {
  return e.rings !== void 0;
}
function _6(e) {
  return (t, n) => t == null ? n : n == null ? t : e(t, n);
}
const zu = _6(Math.min), Bu = _6(Math.max);
function xPe(e, t) {
  return b6(t) ? mf(e, t.paths, !1, !1) : w6(t) ? mf(e, t.rings, !1, !1) : g6(t) ? gO(e, t.points, !1, !1, !1, !1) : y6(t) ? S6(e, t) : (v6(t) && (e[0] = t.x, e[1] = t.y, e[2] = t.x, e[3] = t.y), e);
}
function $Pe(e, t) {
  return b6(t) ? mf(e, t.paths, !0, !1) : w6(t) ? mf(e, t.rings, !0, !1) : g6(t) ? gO(e, t.points, !0, !1, !0, !1) : y6(t) ? S6(e, t, !0, !1, !0, !1) : (v6(t) && (e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.x, e[4] = t.y, e[5] = t.z), e);
}
function mf(e, t, n, r) {
  const i = n ? 3 : 2;
  if (!t.length || !t[0].length)
    return null;
  let s, o, a, l, [c, p] = t[0][0], [f, m] = t[0][0];
  for (let y = 0; y < t.length; y++) {
    const g = t[y];
    for (let v = 0; v < g.length; v++) {
      const w = g[v], [b, S] = w;
      if (c = zu(c, b), p = zu(p, S), f = Bu(f, b), m = Bu(m, S), n && w.length > 2) {
        const $ = w[2];
        s = zu(s, $), o = Bu(o, $);
      }
      if (r && w.length > i) {
        const $ = w[i];
        a = zu(s, $), l = Bu(o, $);
      }
    }
  }
  return n ? r ? (e[0] = c, e[1] = p, e[2] = s, e[3] = a, e[4] = f, e[5] = m, e[6] = o, e[7] = l, e.length = 8, e) : (e[0] = c, e[1] = p, e[2] = s, e[3] = f, e[4] = m, e[5] = o, e.length = 6, e) : r ? (e[0] = c, e[1] = p, e[2] = a, e[3] = f, e[4] = m, e[5] = l, e.length = 6, e) : (e[0] = c, e[1] = p, e[2] = f, e[3] = m, e.length = 4, e);
}
function S6(e, t, n, r, i, s) {
  const o = t.xmin, a = t.xmax, l = t.ymin, c = t.ymax;
  let p = t.zmin, f = t.zmax, m = t.mmin, y = t.mmax;
  return i ? (p = p || 0, f = f || 0, s ? (m = m || 0, y = y || 0, e[0] = o, e[1] = l, e[2] = p, e[3] = m, e[4] = a, e[5] = c, e[6] = f, e[7] = y, e) : (e[0] = o, e[1] = l, e[2] = p, e[3] = a, e[4] = c, e[5] = f, e)) : s ? (m = m || 0, y = y || 0, e[0] = o, e[1] = l, e[2] = m, e[3] = a, e[4] = c, e[5] = y, e) : (e[0] = o, e[1] = l, e[2] = a, e[3] = c, e);
}
function gO(e, t, n, r, i, s) {
  const o = n ? 3 : 2, a = r && s, l = n && i;
  if (!t.length || !t[0].length)
    return null;
  let c, p, f, m, [y, g] = t[0], [v, w] = t[0];
  for (let b = 0; b < t.length; b++) {
    const S = t[b], [$, I] = S;
    if (y = zu(y, $), g = zu(g, I), v = Bu(v, $), w = Bu(w, I), l && S.length > 2) {
      const M = S[2];
      c = zu(c, M), p = Bu(p, M);
    }
    if (a && S.length > o) {
      const M = S[o];
      f = zu(c, M), m = Bu(p, M);
    }
  }
  return i ? (c = c || 0, p = p || 0, s ? (f = f || 0, m = m || 0, e[0] = y, e[1] = g, e[2] = c, e[3] = f, e[4] = v, e[5] = w, e[6] = p, e[7] = m, e) : (e[0] = y, e[1] = g, e[2] = c, e[3] = v, e[4] = w, e[5] = p, e)) : s ? (f = f || 0, m = m || 0, e[0] = y, e[1] = g, e[2] = f, e[3] = v, e[4] = w, e[5] = m, e) : (e[0] = y, e[1] = g, e[2] = v, e[3] = w, e);
}
function RQ(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function LQ(e) {
  return e.points !== void 0;
}
function FQ(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function NQ(e) {
  return e.paths !== void 0;
}
function DQ(e) {
  return e.rings !== void 0;
}
const vO = [];
function x6(e, t, n, r) {
  return { xmin: e, ymin: t, xmax: n, ymax: r };
}
function $6(e, t, n, r, i, s) {
  return { xmin: e, ymin: t, zmin: n, xmax: r, ymax: i, zmax: s };
}
function T6(e, t, n, r, i, s) {
  return { xmin: e, ymin: t, mmin: n, xmax: r, ymax: i, mmax: s };
}
function E6(e, t, n, r, i, s, o, a) {
  return { xmin: e, ymin: t, zmin: n, mmin: r, xmax: i, ymax: s, zmax: o, mmax: a };
}
function bO(e, t = !1, n = !1) {
  return t ? n ? E6(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]) : $6(e[0], e[1], e[2], e[3], e[4], e[5]) : n ? T6(e[0], e[1], e[2], e[3], e[4], e[5]) : x6(e[0], e[1], e[2], e[3]);
}
function TPe(e) {
  return e ? RQ(e) ? e : FQ(e) ? VQ(e) : DQ(e) ? I6(e) : NQ(e) ? M6(e) : LQ(e) ? jQ(e) : null : null;
}
function jQ(e) {
  const { hasZ: t, hasM: n, points: r } = e;
  return bO(gO(vO, r, t, n), t, n);
}
function VQ(e) {
  const { x: t, y: n, z: r, m: i } = e, s = i != null;
  return r != null ? s ? E6(t, n, r, i, t, n, r, i) : $6(t, n, r, t, n, r) : s ? T6(t, n, i, t, n, i) : x6(t, n, t, n);
}
function I6(e) {
  const { hasZ: t, hasM: n, rings: r } = e, i = mf(vO, r, t, n);
  return i ? bO(i, t, n) : null;
}
function M6(e) {
  const { hasZ: t, hasM: n, paths: r } = e, i = mf(vO, r, t, n);
  return i ? bO(i, t, n) : null;
}
var kb;
function mP(e) {
  return !Array.isArray(e[0]);
}
let Jo = kb = class extends Ci {
  constructor(...e) {
    super(...e), this.rings = [], this.type = "polygon";
  }
  static fromExtent(e) {
    const t = e.clone().normalize(), n = e.spatialReference;
    let r = !1, i = !1;
    for (const o of t)
      o.hasZ && (r = !0), o.hasM && (i = !0);
    const s = { rings: t.map(function(o) {
      const a = [[o.xmin, o.ymin], [o.xmin, o.ymax], [o.xmax, o.ymax], [o.xmax, o.ymin], [o.xmin, o.ymin]];
      if (r && o.hasZ) {
        const l = o.zmin + 0.5 * (o.zmax - o.zmin);
        for (let c = 0; c < a.length; c++)
          a[c].push(l);
      }
      if (i && o.hasM) {
        const l = o.mmin + 0.5 * (o.mmax - o.mmin);
        for (let c = 0; c < a.length; c++)
          a[c].push(l);
      }
      return a;
    }), spatialReference: n };
    return r && (s.hasZ = !0), i && (s.hasM = !0), new kb(s);
  }
  normalizeCtorArgs(e, t) {
    let n, r, i = null, s = null;
    return e && !Array.isArray(e) ? (i = e.rings ? e.rings : null, t || (e.spatialReference ? t = e.spatialReference : e.rings || (t = e)), n = e.hasZ, r = e.hasM) : i = e, i = i || [], t = t || Qe.WGS84, i.length && i[0] && i[0][0] != null && typeof i[0][0] == "number" && (i = [i]), s = i[0] && i[0][0], s && (n === void 0 && r === void 0 ? (n = s.length > 2, r = s.length > 3) : n === void 0 ? n = r ? s.length > 3 : s.length > 2 : r === void 0 && (r = n ? s.length > 3 : s.length > 2)), { rings: i, spatialReference: t, hasZ: n, hasM: r };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const e = OQ(this);
    if (!e || isNaN(e[0]) || isNaN(e[1]) || this.hasZ && isNaN(e[2]))
      return null;
    const t = new Oe();
    return t.x = e[0], t.y = e[1], t.spatialReference = this.spatialReference, this.hasZ && (t.z = e[2]), t;
  }
  get extent() {
    const { spatialReference: e } = this, t = I6(this);
    if (!t)
      return null;
    const n = new Mt(t);
    return n.spatialReference = e, n;
  }
  get isSelfIntersecting() {
    return PY(this.rings);
  }
  writeRings(e, t) {
    t.rings = q(this.rings);
  }
  addRing(e) {
    if (!e)
      return;
    const t = this.rings, n = t.length;
    if (mP(e)) {
      const r = [];
      for (let i = 0, s = e.length; i < s; i++)
        r[i] = e[i].toArray();
      t[n] = r;
    } else
      t[n] = e.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const e = new kb();
    return e.spatialReference = this.spatialReference, e.rings = q(this.rings), e.hasZ = this.hasZ, e.hasM = this.hasM, e;
  }
  equals(e) {
    if (this === e)
      return !0;
    if (H(e))
      return !1;
    const t = this.spatialReference, n = e.spatialReference;
    if (O(t) !== O(n) || O(t) && O(n) && !t.equals(n) || this.rings.length !== e.rings.length)
      return !1;
    const r = ([i, s, o, a], [l, c, p, f]) => i === l && s === c && (o == null && p == null || o === p) && (a == null && f == null || a === f);
    for (let i = 0; i < this.rings.length; i++) {
      const s = this.rings[i], o = e.rings[i];
      if (!SD(s, o, r))
        return !1;
    }
    return !0;
  }
  contains(e) {
    if (!e)
      return !1;
    const t = tS(e, this.spatialReference);
    return e6(this, O(t) ? t : e);
  }
  isClockwise(e) {
    let t;
    return t = mP(e) ? e.map((n) => this.hasZ ? this.hasM ? [n.x, n.y, n.z, n.m] : [n.x, n.y, n.z] : [n.x, n.y]) : e, yO(t, this.hasM, this.hasZ);
  }
  getPoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const n = this.rings[e][t], r = this.hasZ, i = this.hasM;
    return r && !i ? new Oe(n[0], n[1], n[2], void 0, this.spatialReference) : i && !r ? new Oe(n[0], n[1], void 0, n[2], this.spatialReference) : r && i ? new Oe(n[0], n[1], n[2], n[3], this.spatialReference) : new Oe(n[0], n[1], this.spatialReference);
  }
  insertPoint(e, t, n) {
    return this._validateInputs(e, t, !0) ? (ff(this, n), Array.isArray(n) || (n = n.toArray()), this.rings[e].splice(t, 0, n), this.notifyChange("rings"), this) : this;
  }
  removePoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const n = new Oe(this.rings[e].splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), n;
  }
  removeRing(e) {
    if (!this._validateInputs(e, null))
      return null;
    const t = this.rings.splice(e, 1)[0], n = this.spatialReference, r = t.map((i) => new Oe(i, n));
    return this.notifyChange("rings"), r;
  }
  setPoint(e, t, n) {
    return this._validateInputs(e, t) ? (ff(this, n), Array.isArray(n) || (n = n.toArray()), this.rings[e][t] = n, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(e, t, n = !1) {
    if (e == null || e < 0 || e >= this.rings.length)
      return !1;
    if (t != null) {
      const r = this.rings[e];
      if (n && (t < 0 || t > r.length) || !n && (t < 0 || t >= r.length))
        return !1;
    }
    return !0;
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], Jo.prototype, "cache", null), u([d({ readOnly: !0 })], Jo.prototype, "centroid", null), u([d({ readOnly: !0 })], Jo.prototype, "extent", null), u([d({ readOnly: !0 })], Jo.prototype, "isSelfIntersecting", null), u([d({ type: [[[Number]]], json: { write: { isRequired: !0 } } })], Jo.prototype, "rings", void 0), u([xe("rings")], Jo.prototype, "writeRings", null), Jo = kb = u([T("geoscene.geometry.Polygon")], Jo), Jo.prototype.toJSON.isDefaultToJSON = !0;
const Po = Jo;
var aT;
function zQ(e) {
  return !Array.isArray(e[0]);
}
let iu = aT = class extends Ci {
  constructor(...e) {
    super(...e), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(e, t) {
    let n, r, i = null, s = null;
    return e && !Array.isArray(e) ? (i = e.paths ? e.paths : null, t || (e.spatialReference ? t = e.spatialReference : e.paths || (t = e)), n = e.hasZ, r = e.hasM) : i = e, i = i || [], t = t || Qe.WGS84, i.length && i[0] && i[0][0] != null && typeof i[0][0] == "number" && (i = [i]), s = i[0] && i[0][0], s && (n === void 0 && r === void 0 ? (n = s.length > 2, r = !1) : n === void 0 ? n = !r && s.length > 3 : r === void 0 && (r = !n && s.length > 3)), { paths: i, spatialReference: t, hasZ: n, hasM: r };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: e } = this, t = M6(this);
    if (!t)
      return null;
    const n = new Mt(t);
    return n.spatialReference = e, n;
  }
  writePaths(e, t) {
    t.paths = q(this.paths);
  }
  addPath(e) {
    if (!e)
      return;
    const t = this.paths, n = t.length;
    if (zQ(e)) {
      const r = [];
      for (let i = 0, s = e.length; i < s; i++)
        r[i] = e[i].toArray();
      t[n] = r;
    } else
      t[n] = e.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const e = new aT();
    return e.spatialReference = this.spatialReference, e.paths = q(this.paths), e.hasZ = this.hasZ, e.hasM = this.hasM, e;
  }
  getPoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const n = this.paths[e][t], r = this.hasZ, i = this.hasM;
    return r && !i ? new Oe(n[0], n[1], n[2], void 0, this.spatialReference) : i && !r ? new Oe(n[0], n[1], void 0, n[2], this.spatialReference) : r && i ? new Oe(n[0], n[1], n[2], n[3], this.spatialReference) : new Oe(n[0], n[1], this.spatialReference);
  }
  insertPoint(e, t, n) {
    return this._validateInputs(e, t, !0) ? (ff(this, n), Array.isArray(n) || (n = n.toArray()), this.paths[e].splice(t, 0, n), this.notifyChange("paths"), this) : this;
  }
  removePath(e) {
    if (!this._validateInputs(e, null))
      return null;
    const t = this.paths.splice(e, 1)[0], n = this.spatialReference, r = t.map((i) => new Oe(i, n));
    return this.notifyChange("paths"), r;
  }
  removePoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const n = new Oe(this.paths[e].splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), n;
  }
  setPoint(e, t, n) {
    return this._validateInputs(e, t) ? (ff(this, n), Array.isArray(n) || (n = n.toArray()), this.paths[e][t] = n, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(e, t, n = !1) {
    if (e == null || e < 0 || e >= this.paths.length)
      return !1;
    if (t != null) {
      const r = this.paths[e];
      if (n && (t < 0 || t > r.length) || !n && (t < 0 || t >= r.length))
        return !1;
    }
    return !0;
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], iu.prototype, "cache", null), u([d({ readOnly: !0 })], iu.prototype, "extent", null), u([d({ type: [[[Number]]], json: { write: { isRequired: !0 } } })], iu.prototype, "paths", void 0), u([xe("paths")], iu.prototype, "writePaths", null), iu = aT = u([T("geoscene.geometry.Polyline")], iu), iu.prototype.toJSON.isDefaultToJSON = !0;
const Ki = iu, BQ = $r()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon" }), yP = $r()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh" });
function C6(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function wO(e) {
  return e.points !== void 0;
}
function _O(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function SO(e) {
  return e.paths !== void 0;
}
function Bd(e) {
  return e.rings !== void 0;
}
function tc(e) {
  return H(e) ? null : e instanceof Ci ? e : _O(e) ? Oe.fromJSON(e) : SO(e) ? Ki.fromJSON(e) : Bd(e) ? Po.fromJSON(e) : wO(e) ? Gf.fromJSON(e) : C6(e) ? Mt.fromJSON(e) : null;
}
function w0(e) {
  return e ? _O(e) ? "esriGeometryPoint" : SO(e) ? "esriGeometryPolyline" : Bd(e) ? "esriGeometryPolygon" : C6(e) ? "esriGeometryEnvelope" : wO(e) ? "esriGeometryMultipoint" : null : null;
}
const UQ = { esriGeometryPoint: Oe, esriGeometryPolyline: Ki, esriGeometryPolygon: Po, esriGeometryEnvelope: Mt, esriGeometryMultipoint: Gf };
function qQ(e) {
  return e && UQ[e] || null;
}
const Tp = { base: Ci, key: "type", typeMap: { extent: Mt, multipoint: Gf, point: Oe, polyline: Ki, polygon: Po } };
Ia(Tp);
let GQ = 0;
const xO = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), Object.defineProperty(this, "uid", { writable: !1, configurable: !1, value: Date.now().toString(16) + "-object-" + GQ++ });
    }
  };
  return t = u([T("geoscene.core.Identifiable")], t), t;
};
let gP = class extends xO(class {
}) {
};
gP = u([T("geoscene.core.Identifiable")], gP);
let WQ = 0;
const vP = we.getLogger("geoscene.layers.Layer");
let Wn = class extends mc.EventedMixin(xO(Ol)) {
  constructor() {
    super(...arguments), this.attributionDataUrl = null, this.fullExtent = new Mt(-180, -90, 180, 90, Qe.WGS84), this.id = Date.now().toString(16) + "-layer-" + WQ++, this.legendEnabled = !0, this.listMode = "show", this.opacity = 1, this.parent = null, this.popupEnabled = !0, this.attributionVisible = !0, this.spatialReference = Qe.WGS84, this.title = null, this.type = null, this.url = null, this.visible = !0;
  }
  static async fromArcGISServerUrl(t) {
    const n = typeof t == "string" ? { url: t } : t, r = await import("./arcgisLayers-R1LCg1YN.js");
    try {
      return await r.fromUrl(n);
    } catch (i) {
      throw vP.error("#fromArcGISServerUrl({ url: '" + n.url + "'})", "Failed to create layer from arcgis server url", i), i;
    }
  }
  static async fromPortalItem(t) {
    const n = "portalItem" in t ? t : { portalItem: t }, r = await import("./portalLayers-gOzkZUZy.js");
    try {
      return await r.fromItem(n);
    } catch (i) {
      const s = n && n.portalItem, o = s && s.id || "unset", a = s && s.portal && s.portal.url || Pt.portalUrl;
      throw vP.error("#fromPortalItem()", "Failed to create layer from portal item (portal: '" + a + "', id: '" + o + "')", i), i;
    }
  }
  initialize() {
    this.when().catch((t) => {
      var n, r;
      Ws(t) || we.getLogger(this.declaredClass).error("#load()", `Failed to load layer (title: '${(n = this.title) != null ? n : "no title"}', id: '${(r = this.id) != null ? r : "no id"}')`, { error: t });
    });
  }
  destroy() {
    if (this.parent) {
      const t = this, n = this.parent;
      "layers" in n && n.layers.includes(t) ? n.layers.remove(t) : "tables" in n && n.tables.includes(t) ? n.tables.remove(t) : "baseLayers" in n && n.baseLayers.includes(t) ? n.baseLayers.remove(t) : "baseLayers" in n && n.referenceLayers.includes(t) && n.referenceLayers.remove(t);
    }
  }
  get hasAttributionData() {
    return this.attributionDataUrl != null;
  }
  get parsedUrl() {
    const t = this.url;
    return t ? cr(t) : null;
  }
  async fetchAttributionData() {
    const t = this.attributionDataUrl;
    if (this.hasAttributionData && t)
      return (await rn(t, { query: { f: "json" }, responseType: "json" })).data;
    throw new D("layer:no-attribution-data", "Layer does not have attribution data");
  }
};
u([d({ type: String })], Wn.prototype, "attributionDataUrl", void 0), u([d({ type: Mt })], Wn.prototype, "fullExtent", void 0), u([d({ readOnly: !0 })], Wn.prototype, "hasAttributionData", null), u([d({ type: String, clonable: !1 })], Wn.prototype, "id", void 0), u([d({ type: Boolean, nonNullable: !0 })], Wn.prototype, "legendEnabled", void 0), u([d({ type: ["show", "hide", "hide-children"] })], Wn.prototype, "listMode", void 0), u([d({ type: Number, range: { min: 0, max: 1 }, nonNullable: !0 })], Wn.prototype, "opacity", void 0), u([d({ clonable: !1 })], Wn.prototype, "parent", void 0), u([d({ readOnly: !0 })], Wn.prototype, "parsedUrl", null), u([d({ type: Boolean })], Wn.prototype, "popupEnabled", void 0), u([d({ type: Boolean })], Wn.prototype, "attributionVisible", void 0), u([d({ type: Qe })], Wn.prototype, "spatialReference", void 0), u([d({ type: String })], Wn.prototype, "title", void 0), u([d({ type: String, readOnly: !0, json: { read: !1 } })], Wn.prototype, "type", void 0), u([d()], Wn.prototype, "url", void 0), u([d({ type: Boolean, nonNullable: !0 })], Wn.prototype, "visible", void 0), Wn = u([T("geoscene.layers.Layer")], Wn);
const iS = Wn;
function HQ(e) {
  return e && e.type === "group";
}
function lT(e, t, n) {
  let r, i;
  if (e)
    for (let s = 0, o = e.length; s < o; s++) {
      if (r = e.getItemAt(s), r[t] === n)
        return r;
      if (HQ(r) && (i = lT(r.layers, t, n), i))
        return i;
    }
}
const bP = we.getLogger("geoscene.support.LayersMixin"), JQ = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this.layers = new Ne();
      const r = (o) => {
        o.parent && "remove" in o.parent && o.parent.remove(o);
      }, i = (o) => {
        o.parent = this, this.layerAdded(o), o.type !== "elevation" && o.type !== "base-elevation" || bP.error(`Layer 'title:${o.title}, id:${o.id}' of type '${o.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, s = (o) => {
        o.parent = null, this.layerRemoved(o);
      };
      this.layers.on("before-add", (o) => r(o.item)), this.layers.on("after-add", (o) => i(o.item)), this.layers.on("after-remove", (o) => s(o.item));
    }
    destroy() {
      const n = this.layers.removeAll();
      for (const r of n)
        this.layerRemoved(r), r.destroy();
      this.layers.destroy();
    }
    set layers(n) {
      this._set("layers", Xd(n, this._get("layers")));
    }
    add(n, r) {
      const i = this.layers;
      if (r = i.getNextIndex(r), n instanceof iS) {
        const s = n;
        s.parent === this ? this.reorder(s, r) : i.add(s, r);
      } else
        Fl(n) ? n.then((s) => {
          this.destroyed || this.add(s, r);
        }) : bP.error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(n, r) {
      const i = this.layers;
      r = i.getNextIndex(r), n.slice().forEach((s) => {
        s.parent !== this ? (i.add(s, r), r += 1) : this.reorder(s, r);
      });
    }
    findLayerById(n) {
      return lT(this.layers, "id", n);
    }
    findLayerByUid(n) {
      return lT(this.layers, "uid", n);
    }
    remove(n) {
      return this.layers.remove(n);
    }
    removeMany(n) {
      return this.layers.removeMany(n);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(n, r) {
      return this.layers.reorder(n, r);
    }
    layerAdded(n) {
    }
    layerRemoved(n) {
    }
  };
  return u([d()], t.prototype, "layers", null), t = u([T("geoscene.support.LayersMixin")], t), t;
}, O6 = "geoscene.support.TablesMixin", ZQ = we.getLogger(O6);
function KQ(e) {
  return e && e.type === "group";
}
function uT(e, t, n) {
  if (e)
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e.getItemAt(r);
      if (s[t] === n)
        return s;
      if (KQ(s)) {
        const o = uT(s.tables, t, n);
        if (o)
          return o;
      }
    }
}
const YQ = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this.tables = new Ne(), this.tables.on("after-add", (r) => {
        const i = r.item;
        i.parent && i.parent !== this && "tables" in i.parent && i.parent.tables.remove(i), i.parent = this, i.type !== "feature" && ZQ.error(`Layer 'title:${i.title}, id:${i.id}' of type '${i.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (r) => {
        r.item.parent = null;
      });
    }
    destroy() {
      const n = this.tables.removeAll();
      for (const r of n)
        r.destroy();
      this.tables.destroy();
    }
    set tables(n) {
      this._set("tables", Xd(n, this._get("tables")));
    }
    findTableById(n) {
      return uT(this.tables, "id", n);
    }
    findTableByUid(n) {
      return uT(this.tables, "uid", n);
    }
  };
  return u([d()], t.prototype, "tables", null), t = u([T(O6)], t), t;
};
let Zo = class extends YQ(JQ(mc.EventedMixin(ke))) {
  constructor(t) {
    super(t), this.allLayers = new tf({ getCollections: () => {
      var n, r, i;
      return [(n = this.basemap) == null ? void 0 : n.baseLayers, (r = this.ground) == null ? void 0 : r.layers, this.layers, (i = this.basemap) == null ? void 0 : i.referenceLayers];
    }, getChildrenFunction: (n) => "layers" in n ? n.layers : null }), this.allTables = new tf({ getCollections: () => [this.tables, this.layers], getChildrenFunction: (n) => {
      const r = [];
      return "tables" in n && r.push(n.tables), "layers" in n && r.push(n.layers), r;
    }, itemFilterFunction: (n) => {
      const r = n.parent;
      return r && "tables" in r && r.tables.includes(n);
    } }), this.basemap = null, this.editableLayers = new tf({ getCollections: () => [this.allLayers], itemFilterFunction: bQ }), this.ground = new x1(), this._basemapCache = wQ();
  }
  destroy() {
    var t, n;
    this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), (t = this.ground) == null || t.destroy(), (n = this.basemap) == null || n.destroy(), _Q(this._basemapCache), this._basemapCache = null;
  }
  castBasemap(t) {
    return SQ(t, this._basemapCache);
  }
  castGround(t) {
    const n = $Q(t);
    return H(n) ? this._get("ground") : n;
  }
  findLayerById(t) {
    return this.allLayers.find((n) => n.id === t);
  }
  findTableById(t) {
    return this.allTables.find((n) => n.id === t);
  }
};
u([d({ readOnly: !0, dependsOn: [] })], Zo.prototype, "allLayers", void 0), u([d({ readOnly: !0 })], Zo.prototype, "allTables", void 0), u([d({ type: _1 })], Zo.prototype, "basemap", void 0), u([mt("basemap")], Zo.prototype, "castBasemap", null), u([d({ readOnly: !0 })], Zo.prototype, "editableLayers", void 0), u([d({ type: x1, nonNullable: !0 })], Zo.prototype, "ground", void 0), u([mt("ground")], Zo.prototype, "castGround", null), Zo = u([T("geoscene.Map")], Zo);
const k6 = Zo;
var yf;
function QQ(e, t) {
  switch (e.type) {
    case "range": {
      const n = "range" in e ? e.range[0] : e.minValue, r = "range" in e ? e.range[1] : e.maxValue;
      if (+t < n || +t > r)
        return yf.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (e.codedValues == null || e.codedValues.every((n) => n == null || n.code !== t))
        return yf.INVALID_CODED_VALUE;
  }
  return null;
}
(function(e) {
  e.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
})(yf || (yf = {}));
let k2;
function kl() {
  return k2 || (k2 = (async () => {
    const e = await import("./arcadeUtils-w0rSqD6f.js").then((t) => t.q);
    return { arcade: e.arcade, arcadeUtils: e, Dictionary: e.Dictionary, Feature: e.arcadeFeature };
  })()), k2;
}
const CPe = (e, t, n) => $O.create(e, t, n, null, ["$feature"]), OPe = (e, t, n) => $O.create(e, t, n, null, ["$feature", "$view"]), XQ = (e, t, n, r) => $O.create(e, t, n, r, ["$feature", "$view"]);
let $O = class A6 {
  constructor(t, n, r, i, s, o, a, l) {
    this.script = t, this.evaluate = s;
    const c = Array.isArray(a) ? a : a.fields;
    this.fields = c, this._syntaxTree = i, this._arcade = n, this._arcadeDictionary = r, this._arcadeFeature = o, this._spatialReference = l, this._referencesGeometry = n.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(t, n, r, i, s, o) {
    const { arcade: a, Feature: l, Dictionary: c } = await kl(), p = Qe.fromJSON(n), f = a.parseScript(t, o), m = s.reduce((M, E) => ({ ...M, [E]: null }), {});
    let y = null;
    O(i) && (y = new c(i), y.immutable = !0, m.$config = null);
    const g = a.scriptUsesGeometryEngine(f) && a.enableGeometrySupport(), v = a.scriptUsesFeatureSet(f) && a.enableFeatureSetSupport(), w = a.scriptIsAsync(f) && a.enableAsyncSupport(), b = { vars: m, spatialReference: p, useAsync: !!w }, S = new c();
    S.immutable = !1, S.setField("scale", 0);
    const $ = a.compileScript(f, b), I = (M) => ("$view" in M && M.$view && (S.setField("scale", M.$view.scale), M.$view = S), y && (M.$config = y), $({ vars: M, spatialReference: p }));
    return await Promise.all([g, v, w]), new A6(t, a, c, f, I, new l(), r, p);
  }
  repurposeFeature(t) {
    return t.geometry && !t.geometry.spatialReference && (t.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(t.geometry, t.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  createDictionary() {
    return new this._arcadeDictionary();
  }
  referencesMember(t) {
    return this._arcade.referencesMember(this._syntaxTree, t);
  }
  referencesFunction(t) {
    return this._arcade.referencesFunction(this._syntaxTree, t);
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
  extractFieldLiterals() {
    return this._arcade.extractExpectedFieldLiterals(this._syntaxTree);
  }
};
const eX = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"], tX = ["field", "normalizationField"];
function wP(e, t) {
  if (e != null && t != null) {
    for (const n of Array.isArray(e) ? e : [e])
      if (_P(eX, n, t), "visualVariables" in n && n.visualVariables)
        for (const r of n.visualVariables)
          _P(tX, r, t);
  }
}
function _P(e, t, n) {
  if (e)
    for (const r of e) {
      const i = jf(r, t), s = i && typeof i != "function" && n.get(i);
      s && ss(r, s.name, t);
    }
}
function P6(e, t) {
  if (e != null && t != null && t.fields.length)
    if ("startField" in e) {
      const n = t.get(e.startField), r = t.get(e.endField);
      e.startField = n && n.name || null, e.endField = r && r.name || null;
    } else {
      const n = t.get(e.startTimeField), r = t.get(e.endTimeField);
      e.startTimeField = n && n.name || null, e.endTimeField = r && r.name || null;
    }
}
const A2 = /* @__PURE__ */ new Set();
function R6(e, t) {
  return e && t ? (A2.clear(), Ag(A2, e, t), Array.from(A2).sort()) : [];
}
function Ag(e, t, n) {
  var r;
  if (n)
    if (t != null && (r = t.fields) != null && r.length)
      if (n.includes("*"))
        for (const { name: i } of t.fields)
          e.add(i);
      else
        for (const i of n)
          Fs(e, t, i);
    else {
      if (n.includes("*"))
        return e.clear(), void e.add("*");
      for (const i of n)
        e.add(i);
    }
}
function Fs(e, t, n) {
  if (typeof n == "string")
    if (t) {
      const r = t.get(n);
      r && e.add(r.name);
    } else
      e.add(n);
}
function kPe(e, t) {
  return H(t) || H(e) ? [] : t.includes("*") ? e.fields.map((n) => n.name) : t;
}
async function as(e, t, n) {
  var r;
  if (!n)
    return;
  const { arcadeUtils: i } = await kl(), s = i.extractFieldNames(n, t == null || (r = t.fields) == null ? void 0 : r.map((o) => o.name));
  for (const o of s)
    Fs(e, t, o);
}
async function L6(e, t, n) {
  if (n && n !== "1=1") {
    const r = (await import("./WhereClause-tgx5XbAS.js")).WhereClause.create(n, t);
    if (!r.isStandardized)
      throw new D("fieldUtils:collectFilterFields", "Where clause is not standardized");
    Ag(e, t, r.fieldNames);
  }
}
function nX({ displayField: e, fields: t }) {
  return e || (t && t.length ? P2(t, "name-or-title") || P2(t, "unique-identifier") || P2(t, "type-or-category") || rX(t) : null);
}
function rX(e) {
  for (const t of e) {
    if (!t || !t.name)
      continue;
    const n = t.name.toLowerCase();
    if (n.indexOf("name") > -1 || n.indexOf("title") > -1)
      return t.name;
  }
  return null;
}
function P2(e, t) {
  for (const n of e)
    if (n && n.valueType && n.valueType === t)
      return n.name;
  return null;
}
async function APe(e, t) {
  if (!t)
    return;
  const n = jf("elevationInfo.featureExpressionInfo", t);
  return n ? n.collectRequiredFields(e, t.fieldsIndex) : void 0;
}
async function iX(e, t, n) {
  n.outStatistic.onStatisticValueExpression ? as(e, t, n.outStatistic.onStatisticValueExpression) : e.add(n.outStatistic.onStatisticField);
}
async function PPe(e, t, n) {
  var r, i;
  if (!t || !n || n.type !== "cluster")
    return;
  const s = [];
  if ((r = n.popupTemplate) != null && r.expressionInfos && s.push(...n.popupTemplate.expressionInfos.map((o) => as(e, t.fieldsIndex, o.expression))), Array.isArray((i = n.popupTemplate) == null ? void 0 : i.content)) {
    const o = n.popupTemplate.content;
    for (const a of o)
      a.type === "expression" && a.expressionInfo && s.push(as(e, t.fieldsIndex, a.expressionInfo.expression));
  }
  n.fields && s.push(...n.fields.map((o) => iX(e, t.fieldsIndex, o))), await Promise.all(s);
}
async function RPe(e, t, n) {
  t && (t.timeInfo && O(n) && n.timeExtent && Ag(e, t.fieldsIndex, [t.timeInfo.startField, t.timeInfo.endField]), t.floorInfo && Ag(e, t.fieldsIndex, [t.floorInfo.floorField]), O(n) && O(n.where) && await L6(e, t.fieldsIndex, n.where));
}
async function LPe(e, t, n) {
  t && n && await Promise.all(n.map((r) => sX(e, t, r)));
}
async function sX(e, t, n) {
  t && n && (n.valueExpression ? await as(e, t.fieldsIndex, n.valueExpression) : n.field && Fs(e, t.fieldsIndex, n.field));
}
function FPe(e) {
  if (!e)
    return [];
  const t = "editFieldsInfo" in e && e.editFieldsInfo;
  return t ? R6(e.fieldsIndex, [t && t.creatorField, t && t.creationDateField, t && t.editorField, t && t.editDateField]) : [];
}
async function NPe(e, t) {
  const { labelingInfo: n, fieldsIndex: r } = t;
  n && n.length && await Promise.all(n.map((i) => oX(e, r, i)));
}
async function oX(e, t, n) {
  if (!n)
    return;
  const r = n.getLabelExpression(), i = n.where;
  if (r.type === "arcade")
    await as(e, t, r.expression);
  else {
    const s = r.expression.match(/{[^}]*}/g);
    s && s.forEach((o) => {
      Fs(e, t, o.slice(1, -1));
    });
  }
  await L6(e, t, i);
}
function aX(e) {
  const t = e.defaultValue;
  return t !== void 0 && D6(e, t) ? t : e.nullable ? null : void 0;
}
function F6(e) {
  return typeof e == "number" && !isNaN(e) && isFinite(e);
}
function lX(e) {
  return e === null || F6(e);
}
const TO = "isInteger" in Number ? Number.isInteger : (e) => typeof e == "number" && isFinite(e) && Math.floor(e) === e;
function uX(e) {
  return e === null || TO(e);
}
function N6(e) {
  return e != null && typeof e == "string";
}
function cX(e) {
  return e === null || N6(e);
}
function dX() {
  return !0;
}
function D6(e, t) {
  let n;
  switch (e.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
      n = e.nullable ? uX : TO;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      n = e.nullable ? lX : F6;
      break;
    case "string":
    case "esriFieldTypeString":
      n = e.nullable ? cX : N6;
      break;
    default:
      n = dX;
  }
  return arguments.length === 1 ? n : n(t);
}
const pX = ["integer", "small-integer", "single", "double"], hX = /* @__PURE__ */ new Set([...pX, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]);
function EO(e) {
  return e != null && hX.has(e.type);
}
function DPe(e) {
  return e != null && (e.type === "string" || e.type === "esriFieldTypeString");
}
var $1, T1;
function jPe(e) {
  return e == null || typeof e == "number" && isNaN(e) ? null : e;
}
function VPe(e, t) {
  return e.nullable && t === null ? null : EO(e) && !fX(e.type, Number(t)) ? $1.OUT_OF_RANGE : D6(e, t) ? e.domain ? QQ(e.domain, t) : null : T1.INVALID_TYPE;
}
function fX(e, t) {
  const n = typeof e == "string" ? j6(e) : e;
  return !!n && (n.isInteger ? TO(t) && t >= n.min && t <= n.max : t >= n.min && t <= n.max);
}
function j6(e) {
  switch (e) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return mX;
    case "esriFieldTypeInteger":
    case "integer":
      return yX;
    case "esriFieldTypeSingle":
    case "single":
      return gX;
    case "esriFieldTypeDouble":
    case "double":
      return vX;
  }
}
(function(e) {
  e.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
})($1 || ($1 = {})), function(e) {
  e.INVALID_TYPE = "type-validation-error::invalid-type";
}(T1 || (T1 = {}));
const mX = { min: -32768, max: 32767, isInteger: !0 }, yX = { min: -2147483648, max: 2147483647, isInteger: !0 }, gX = { min: -34e37, max: 12e37, isInteger: !1 }, vX = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: !1 };
function zPe(e, t, n) {
  switch (e) {
    case yf.INVALID_CODED_VALUE:
      return `Value ${n} is not in the coded domain - field: ${t.name}, domain: ${JSON.stringify(t.domain)}`;
    case yf.VALUE_OUT_OF_RANGE:
      return `Value ${n} is out of the range of valid values - field: ${t.name}, domain: ${JSON.stringify(t.domain)}`;
    case T1.INVALID_TYPE:
      return `Value ${n} is not a valid value for the field type - field: ${t.name}, type: ${t.type}, nullable: ${t.nullable}`;
    case $1.OUT_OF_RANGE: {
      const { min: r, max: i } = j6(t.type);
      return `Value ${n} is out of range for the number type - field: ${t.name}, type: ${t.type}, value range is ${r} to ${i}`;
    }
  }
}
function bX(e, t) {
  return !wX(e, t, null);
}
function wX(e, t, n) {
  if (!t || !t.attributes || !e) {
    if (O(n))
      for (const s of e)
        n.add(s);
    return !0;
  }
  const r = t.attributes;
  let i = !1;
  for (const s of e)
    if (!(s in r)) {
      if (i = !0, !O(n))
        break;
      n.add(s);
    }
  return i;
}
let Ab = class extends se {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d({ type: ["attachments", "custom", "fields", "media", "text", "expression"], readOnly: !0, json: { read: !1, write: !0 } })], Ab.prototype, "type", void 0), Ab = u([T("geoscene.popup.content.Content")], Ab);
const Ep = Ab;
var cT;
let Lc = cT = class extends Ep {
  constructor(e) {
    super(e), this.description = null, this.displayType = "auto", this.title = null, this.type = "attachments";
  }
  clone() {
    return new cT({ description: this.description, displayType: this.displayType, title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], Lc.prototype, "description", void 0), u([d({ type: ["auto", "preview", "list"], json: { write: !0 } })], Lc.prototype, "displayType", void 0), u([d({ type: String, json: { write: !0 } })], Lc.prototype, "title", void 0), u([d({ type: ["attachments"], readOnly: !0, json: { read: !1, write: !0 } })], Lc.prototype, "type", void 0), Lc = cT = u([T("geoscene.popup.content.AttachmentsContent")], Lc);
const Pg = Lc;
var dT;
let Fc = dT = class extends Ep {
  constructor(e) {
    super(e), this.creator = null, this.destroyer = null, this.outFields = null, this.type = "custom";
  }
  clone() {
    return new dT({ creator: this.creator, destroyer: this.destroyer, outFields: Array.isArray(this.outFields) ? q(this.outFields) : null });
  }
};
u([d()], Fc.prototype, "creator", void 0), u([d()], Fc.prototype, "destroyer", void 0), u([d()], Fc.prototype, "outFields", void 0), u([d({ type: ["custom"], readOnly: !0 })], Fc.prototype, "type", void 0), Fc = dT = u([T("geoscene.popup.content.CustomContent")], Fc);
const _X = Fc;
var pT;
let nh = pT = class extends se {
  constructor(e) {
    super(e), this.title = null, this.expression = null, this.returnType = "dictionary";
  }
  clone() {
    return new pT({ title: this.title, expression: this.expression });
  }
};
u([d({ type: String, json: { write: !0 } })], nh.prototype, "title", void 0), u([d({ type: String, json: { write: !0 } })], nh.prototype, "expression", void 0), u([d({ type: ["dictionary"], readOnly: !0, json: { read: !1, write: !0 } })], nh.prototype, "returnType", void 0), nh = pT = u([T("geoscene.popup.ElementExpressionInfo")], nh);
const V6 = nh;
var hT;
let ey = hT = class extends Ep {
  constructor(e) {
    super(e), this.expressionInfo = null, this.type = "expression";
  }
  clone() {
    var e;
    return new hT({ expressionInfo: (e = this.expressionInfo) == null ? void 0 : e.clone() });
  }
};
u([d({ type: V6, json: { write: !0 } })], ey.prototype, "expressionInfo", void 0), u([d({ type: ["expression"], readOnly: !0, json: { read: !1, write: !0 } })], ey.prototype, "type", void 0), ey = hT = u([T("geoscene.popup.content.ExpressionContent")], ey);
const IO = ey, Rg = $r()({ shortDate: "short-date", shortDateShortTime: "short-date-short-time", shortDateShortTime24: "short-date-short-time-24", shortDateLongTime: "short-date-long-time", shortDateLongTime24: "short-date-long-time-24", shortDateLE: "short-date-le", shortDateLEShortTime: "short-date-le-short-time", shortDateLEShortTime24: "short-date-le-short-time-24", shortDateLELongTime: "short-date-le-long-time", shortDateLELongTime24: "short-date-le-long-time-24", longMonthDayYear: "long-month-day-year", longMonthDayYearShortTime: "long-month-day-year-short-time", longMonthDayYearShortTime24: "long-month-day-year-short-time-24", longMonthDayYearLongTime: "long-month-day-year-long-time", longMonthDayYearLongTime24: "long-month-day-year-long-time-24", dayShortMonthYear: "day-short-month-year", dayShortMonthYearShortTime: "day-short-month-year-short-time", dayShortMonthYearShortTime24: "day-short-month-year-short-time-24", dayShortMonthYearLongTime: "day-short-month-year-long-time", dayShortMonthYearLongTime24: "day-short-month-year-long-time-24", longDate: "long-date", longDateShortTime: "long-date-short-time", longDateShortTime24: "long-date-short-time-24", longDateLongTime: "long-date-long-time", longDateLongTime24: "long-date-long-time-24", longMonthYear: "long-month-year", shortMonthYear: "short-month-year", year: "year" });
Rg.toJSON.bind(Rg);
Rg.fromJSON.bind(Rg);
const Uo = { year: "numeric", month: "numeric", day: "numeric" }, _m = { year: "numeric", month: "long", day: "numeric" }, Sm = { year: "numeric", month: "short", day: "numeric" }, xm = { year: "numeric", month: "long", weekday: "long", day: "numeric" }, _s = { hour: "numeric", minute: "numeric" }, Ys = { ..._s, second: "numeric" }, MO = { "short-date": Uo, "short-date-short-time": { ...Uo, ..._s }, "short-date-short-time-24": { ...Uo, ..._s, hour12: !1 }, "short-date-long-time": { ...Uo, ...Ys }, "short-date-long-time-24": { ...Uo, ...Ys, hour12: !1 }, "short-date-le": Uo, "short-date-le-short-time": { ...Uo, ..._s }, "short-date-le-short-time-24": { ...Uo, ..._s, hour12: !1 }, "short-date-le-long-time": { ...Uo, ...Ys }, "short-date-le-long-time-24": { ...Uo, ...Ys, hour12: !1 }, "long-month-day-year": _m, "long-month-day-year-short-time": { ..._m, ..._s }, "long-month-day-year-short-time-24": { ..._m, ..._s, hour12: !1 }, "long-month-day-year-long-time": { ..._m, ...Ys }, "long-month-day-year-long-time-24": { ..._m, ...Ys, hour12: !1 }, "day-short-month-year": Sm, "day-short-month-year-short-time": { ...Sm, ..._s }, "day-short-month-year-short-time-24": { ...Sm, ..._s, hour12: !1 }, "day-short-month-year-long-time": { ...Sm, ...Ys }, "day-short-month-year-long-time-24": { ...Sm, ...Ys, hour12: !1 }, "long-date": xm, "long-date-short-time": { ...xm, ..._s }, "long-date-short-time-24": { ...xm, ..._s, hour12: !1 }, "long-date-long-time": { ...xm, ...Ys }, "long-date-long-time-24": { ...xm, ...Ys, hour12: !1 }, "long-month-year": { month: "long", year: "numeric" }, "short-month-year": { month: "short", year: "numeric" }, year: { year: "numeric" }, "short-time": _s, "long-time": Ys }, Lg = $r()({ shortDate: "short-date", shortDateShortTime: "short-date-short-time", shortDateShortTime24: "short-date-short-time-24", shortDateLongTime: "short-date-long-time", shortDateLongTime24: "short-date-long-time-24", shortDateLE: "short-date-le", shortDateLEShortTime: "short-date-le-short-time", shortDateLEShortTime24: "short-date-le-short-time-24", shortDateLELongTime: "short-date-le-long-time", shortDateLELongTime24: "short-date-le-long-time-24", longMonthDayYear: "long-month-day-year", longMonthDayYearShortTime: "long-month-day-year-short-time", longMonthDayYearShortTime24: "long-month-day-year-short-time-24", longMonthDayYearLongTime: "long-month-day-year-long-time", longMonthDayYearLongTime24: "long-month-day-year-long-time-24", dayShortMonthYear: "day-short-month-year", dayShortMonthYearShortTime: "day-short-month-year-short-time", dayShortMonthYearShortTime24: "day-short-month-year-short-time-24", dayShortMonthYearLongTime: "day-short-month-year-long-time", dayShortMonthYearLongTime24: "day-short-month-year-long-time-24", longDate: "long-date", longDateShortTime: "long-date-short-time", longDateShortTime24: "long-date-short-time-24", longDateLongTime: "long-date-long-time", longDateLongTime24: "long-date-long-time-24", longMonthYear: "long-month-year", shortMonthYear: "short-month-year", year: "year" });
Lg.apiValues;
Lg.toJSON.bind(Lg);
Lg.fromJSON.bind(Lg);
const SX = { ar: "ar-u-nu-latn-ca-gregory" };
let Pb = /* @__PURE__ */ new WeakMap(), z6 = MO["short-date-short-time"];
function xX(e) {
  const t = e || z6;
  if (!Pb.has(t)) {
    const n = ts(), r = SX[ts()] || n;
    Pb.set(t, new Intl.DateTimeFormat(r, t));
  }
  return Pb.get(t);
}
function B6(e) {
  return MO[e] || null;
}
function nc(e, t) {
  return xX(t).format(e);
}
uO(() => {
  Pb = /* @__PURE__ */ new WeakMap(), z6 = MO["short-date-short-time"];
});
const $X = { ar: "ar-u-nu-latn" };
let Rb = /* @__PURE__ */ new WeakMap(), U6 = {};
function TX(e) {
  const t = e || U6;
  if (!Rb.has(t)) {
    const n = ts(), r = $X[ts()] || n;
    Rb.set(t, new Intl.NumberFormat(r, e));
  }
  return Rb.get(t);
}
function q6(e = {}) {
  const t = {};
  return e.digitSeparator != null && (t.useGrouping = e.digitSeparator), e.places != null && (t.minimumFractionDigits = t.maximumFractionDigits = e.places), t;
}
function op(e, t) {
  return TX(t).format(e);
}
uO(() => {
  Rb = /* @__PURE__ */ new WeakMap(), U6 = {};
});
var fT;
let Nc = fT = class extends se {
  constructor(e) {
    super(e), this.dateFormat = null, this.dateTimeFormatOptions = null, this.digitSeparator = !1, this.places = null;
  }
  clone() {
    return new fT({ dateFormat: this.dateFormat, digitSeparator: this.digitSeparator, places: this.places });
  }
  format(e) {
    return this.dateFormat ? nc(e, { ...B6(this.dateFormat), ...this.dateTimeFormatOptions }) : op(e, q6(this));
  }
};
u([De(Rg)], Nc.prototype, "dateFormat", void 0), u([d({ type: Object, json: { read: !1 } })], Nc.prototype, "dateTimeFormatOptions", void 0), u([d({ type: Boolean, json: { write: !0 } })], Nc.prototype, "digitSeparator", void 0), u([d({ type: Vt, json: { write: !0 } })], Nc.prototype, "places", void 0), Nc = fT = u([T("geoscene.popup.support.FieldInfoFormat")], Nc);
const Xy = Nc;
var mT;
let so = mT = class extends se {
  constructor(e) {
    super(e), this.fieldName = null, this.format = null, this.isEditable = !1, this.label = null, this.stringFieldOption = "text-box", this.statisticType = null, this.tooltip = null, this.visible = !0;
  }
  clone() {
    return new mT({ fieldName: this.fieldName, format: this.format ? q(this.format) : null, isEditable: this.isEditable, label: this.label, stringFieldOption: this.stringFieldOption, statisticType: this.statisticType, tooltip: this.tooltip, visible: this.visible });
  }
};
u([d({ type: String, json: { write: !0 } })], so.prototype, "fieldName", void 0), u([d({ type: Xy, json: { write: !0 } })], so.prototype, "format", void 0), u([d({ type: Boolean, json: { write: !0, default: !1 } })], so.prototype, "isEditable", void 0), u([d({ type: String, json: { write: !0 } })], so.prototype, "label", void 0), u([De(new st({ richtext: "rich-text", textarea: "text-area", textbox: "text-box" }), { default: "text-box" })], so.prototype, "stringFieldOption", void 0), u([d({ type: ["count", "sum", "min", "max", "avg", "stddev", "var"], json: { write: !0 } })], so.prototype, "statisticType", void 0), u([d({ type: String, json: { write: !0 } })], so.prototype, "tooltip", void 0), u([d({ type: Boolean, json: { write: !0 } })], so.prototype, "visible", void 0), so = mT = u([T("geoscene.popup.FieldInfo")], so);
const _0 = so;
var yT;
let Wa = yT = class extends Ep {
  constructor(e) {
    super(e), this.attributes = null, this.description = null, this.fieldInfos = null, this.title = null, this.type = "fields";
  }
  writeFieldInfos(e, t) {
    t.fieldInfos = e && e.map((n) => n.toJSON());
  }
  clone() {
    return new yT(q({ attributes: this.attributes, description: this.description, fieldInfos: this.fieldInfos, title: this.title }));
  }
};
u([d({ type: Object, json: { write: !0 } })], Wa.prototype, "attributes", void 0), u([d({ type: String, json: { write: !0 } })], Wa.prototype, "description", void 0), u([d({ type: [_0] })], Wa.prototype, "fieldInfos", void 0), u([xe("fieldInfos")], Wa.prototype, "writeFieldInfos", null), u([d({ type: String, json: { write: !0 } })], Wa.prototype, "title", void 0), u([d({ type: ["fields"], readOnly: !0, json: { read: !1, write: !0 } })], Wa.prototype, "type", void 0), Wa = yT = u([T("geoscene.popup.content.FieldsContent")], Wa);
const gf = Wa;
let Dc = class extends se {
  constructor(t) {
    super(t), this.altText = null, this.caption = "", this.title = "", this.type = null;
  }
};
u([d({ type: String, json: { write: !0 } })], Dc.prototype, "altText", void 0), u([d({ type: String, json: { write: !0 } })], Dc.prototype, "caption", void 0), u([d({ type: String, json: { write: !0 } })], Dc.prototype, "title", void 0), u([d({ type: ["image", "bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: !0, json: { read: !1, write: !0 } })], Dc.prototype, "type", void 0), Dc = u([T("geoscene.popup.content.mixins.MediaInfo")], Dc);
const CO = Dc;
var gT;
let ty = gT = class extends ke {
  constructor(e) {
    super(e), this.tooltip = null, this.value = null;
  }
  clone() {
    return new gT({ tooltip: this.tooltip, value: this.value });
  }
};
u([d()], ty.prototype, "tooltip", void 0), u([d()], ty.prototype, "value", void 0), ty = gT = u([T("geoscene.popup.content.support.ChartMediaInfoValueSeries")], ty);
const G6 = ty;
var vT;
let jc = vT = class extends se {
  constructor(e) {
    super(e), this.fields = [], this.normalizeField = null, this.series = [], this.tooltipField = null;
  }
  clone() {
    return new vT({ fields: q(this.fields), normalizeField: this.normalizeField, tooltipField: this.tooltipField });
  }
};
u([d({ type: [String], json: { write: !0 } })], jc.prototype, "fields", void 0), u([d({ type: String, json: { write: !0 } })], jc.prototype, "normalizeField", void 0), u([d({ type: [G6], json: { read: !1 } })], jc.prototype, "series", void 0), u([d({ type: String, json: { write: !0 } })], jc.prototype, "tooltipField", void 0), jc = vT = u([T("geoscene.popup.content.support.ChartMediaInfoValue")], jc);
const EX = jc;
let ny = class extends CO {
  constructor(t) {
    super(t), this.type = null, this.value = null;
  }
};
u([d({ type: ["bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: !0, json: { read: !1, write: !0 } })], ny.prototype, "type", void 0), u([d({ type: EX, json: { write: !0 } })], ny.prototype, "value", void 0), ny = u([T("geoscene.popup.content.mixins.ChartMediaInfo")], ny);
const sS = ny, oS = $r()({ barchart: "bar-chart", columnchart: "column-chart", linechart: "line-chart", piechart: "pie-chart" });
var bT;
let Lb = bT = class extends sS {
  constructor(e) {
    super(e), this.type = "bar-chart";
  }
  clone() {
    return new bT({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["bar-chart"], readOnly: !0, json: { type: ["barchart"], read: !1, write: oS.write } })], Lb.prototype, "type", void 0), Lb = bT = u([T("geoscene.popup.content.BarChartMediaInfo")], Lb);
const W6 = Lb;
var wT;
let Fb = wT = class extends sS {
  constructor(e) {
    super(e), this.type = "column-chart";
  }
  clone() {
    return new wT({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["column-chart"], readOnly: !0, json: { type: ["columnchart"], read: !1, write: oS.write } })], Fb.prototype, "type", void 0), Fb = wT = u([T("geoscene.popup.content.ColumnChartMediaInfo")], Fb);
const H6 = Fb;
var _T;
let ry = _T = class extends se {
  constructor(e) {
    super(e), this.linkURL = null, this.sourceURL = null;
  }
  clone() {
    return new _T({ linkURL: this.linkURL, sourceURL: this.sourceURL });
  }
};
u([d({ type: String, json: { write: !0 } })], ry.prototype, "linkURL", void 0), u([d({ type: String, json: { write: !0 } })], ry.prototype, "sourceURL", void 0), ry = _T = u([T("geoscene.popup.content.support.ImageMediaInfoValue")], ry);
const IX = ry;
var ST;
let rh = ST = class extends CO {
  constructor(e) {
    super(e), this.refreshInterval = null, this.type = "image", this.value = null;
  }
  clone() {
    return new ST({ altText: this.altText, title: this.title, caption: this.caption, refreshInterval: this.refreshInterval, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: Number, json: { write: !0 } })], rh.prototype, "refreshInterval", void 0), u([d({ type: ["image"], readOnly: !0, json: { read: !1, write: !0 } })], rh.prototype, "type", void 0), u([d({ type: IX, json: { write: !0 } })], rh.prototype, "value", void 0), rh = ST = u([T("geoscene.popup.content.ImageMediaInfo")], rh);
const J6 = rh;
var xT;
let Nb = xT = class extends sS {
  constructor(e) {
    super(e), this.type = "line-chart";
  }
  clone() {
    return new xT({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["line-chart"], readOnly: !0, json: { type: ["linechart"], read: !1, write: oS.write } })], Nb.prototype, "type", void 0), Nb = xT = u([T("geoscene.popup.content.LineChartMediaInfo")], Nb);
const Z6 = Nb;
var $T;
let Db = $T = class extends sS {
  constructor(e) {
    super(e), this.type = "pie-chart";
  }
  clone() {
    return new $T({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["pie-chart"], readOnly: !0, json: { type: ["piechart"], read: !1, write: oS.write } })], Db.prototype, "type", void 0), Db = $T = u([T("geoscene.popup.content.PieChartMediaInfo")], Db);
const K6 = Db, Y6 = { base: CO, key: "type", defaultKeyValue: "image", typeMap: { "bar-chart": W6, "column-chart": H6, "line-chart": Z6, "pie-chart": K6, image: J6 } };
var TT;
let oo = TT = class extends Ep {
  constructor(e) {
    super(e), this.activeMediaInfoIndex = null, this.attributes = null, this.description = null, this.mediaInfos = null, this.title = null, this.type = "media";
  }
  readMediaInfos(e) {
    return e && e.map((t) => t.type === "image" ? J6.fromJSON(t) : t.type === "barchart" ? W6.fromJSON(t) : t.type === "columnchart" ? H6.fromJSON(t) : t.type === "linechart" ? Z6.fromJSON(t) : t.type === "piechart" ? K6.fromJSON(t) : void 0).filter(Boolean);
  }
  writeMediaInfos(e, t) {
    t.mediaInfos = e && e.map((n) => n.toJSON());
  }
  clone() {
    return new TT(q({ activeMediaInfoIndex: this.activeMediaInfoIndex, attributes: this.attributes, description: this.description, mediaInfos: this.mediaInfos, title: this.title }));
  }
};
u([d()], oo.prototype, "activeMediaInfoIndex", void 0), u([d({ type: Object, json: { write: !0 } })], oo.prototype, "attributes", void 0), u([d({ type: String, json: { write: !0 } })], oo.prototype, "description", void 0), u([d({ types: [Y6] })], oo.prototype, "mediaInfos", void 0), u([be("mediaInfos")], oo.prototype, "readMediaInfos", null), u([xe("mediaInfos")], oo.prototype, "writeMediaInfos", null), u([d({ type: String, json: { write: !0 } })], oo.prototype, "title", void 0), u([d({ type: ["media"], readOnly: !0, json: { read: !1, write: !0 } })], oo.prototype, "type", void 0), oo = TT = u([T("geoscene.popup.content.MediaContent")], oo);
const Fg = oo;
var ET;
let iy = ET = class extends Ep {
  constructor(e) {
    super(e), this.text = null, this.type = "text";
  }
  clone() {
    return new ET({ text: this.text });
  }
};
u([d({ type: String, json: { write: !0 } })], iy.prototype, "text", void 0), u([d({ type: ["text"], readOnly: !0, json: { read: !1, write: !0 } })], iy.prototype, "type", void 0), iy = ET = u([T("geoscene.popup.content.TextContent")], iy);
const vf = iy, MX = { base: null, key: "type", typeMap: { attachment: Pg, media: Fg, text: vf, expression: IO, field: gf } };
var IT;
let Vc = IT = class extends se {
  constructor(e) {
    super(e), this.name = null, this.title = null, this.expression = null, this.returnType = null;
  }
  clone() {
    return new IT({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
u([d({ type: String, json: { write: !0 } })], Vc.prototype, "name", void 0), u([d({ type: String, json: { write: !0 } })], Vc.prototype, "title", void 0), u([d({ type: String, json: { write: !0 } })], Vc.prototype, "expression", void 0), u([d({ type: ["string", "number"], json: { write: !0 } })], Vc.prototype, "returnType", void 0), Vc = IT = u([T("geoscene.popup.ExpressionInfo")], Vc);
const Q6 = Vc;
var MT;
let sy = MT = class extends se {
  constructor(e) {
    super(e), this.returnTopmostRaster = null, this.showNoDataRecords = null;
  }
  clone() {
    return new MT({ showNoDataRecords: this.showNoDataRecords, returnTopmostRaster: this.returnTopmostRaster });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], sy.prototype, "returnTopmostRaster", void 0), u([d({ type: Boolean, json: { write: !0 } })], sy.prototype, "showNoDataRecords", void 0), sy = MT = u([T("geoscene.popup.LayerOptions")], sy);
const CX = sy;
var CT;
let oy = CT = class extends se {
  constructor(e) {
    super(e), this.field = null, this.order = null;
  }
  clone() {
    return new CT({ field: this.field, order: this.order });
  }
};
u([d({ type: String, json: { write: !0 } })], oy.prototype, "field", void 0), u([d({ type: ["asc", "desc"], json: { write: !0 } })], oy.prototype, "order", void 0), oy = CT = u([T("geoscene.popup.support.RelatedRecordsInfoFieldOrder")], oy);
const X6 = oy;
var OT;
let ay = OT = class extends se {
  constructor(e) {
    super(e), this.showRelatedRecords = null, this.orderByFields = null;
  }
  clone() {
    return new OT({ showRelatedRecords: this.showRelatedRecords, orderByFields: this.orderByFields ? q(this.orderByFields) : null });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], ay.prototype, "showRelatedRecords", void 0), u([d({ type: [X6], json: { write: !0 } })], ay.prototype, "orderByFields", void 0), ay = OT = u([T("geoscene.popup.RelatedRecordsInfo")], ay);
const OX = ay;
var kT;
let ao = kT = class extends xO(ke) {
  constructor(e) {
    super(e), this.active = !1, this.className = null, this.disabled = !1, this.id = null, this.indicator = !1, this.title = null, this.type = null, this.visible = !0;
  }
  clone() {
    return new kT({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible });
  }
};
u([d()], ao.prototype, "active", void 0), u([d()], ao.prototype, "className", void 0), u([d()], ao.prototype, "disabled", void 0), u([d()], ao.prototype, "id", void 0), u([d()], ao.prototype, "indicator", void 0), u([d()], ao.prototype, "title", void 0), u([d()], ao.prototype, "type", void 0), u([d()], ao.prototype, "visible", void 0), ao = kT = u([T("geoscene.support.actions.ActionBase")], ao);
const aS = ao;
var AT;
let jb = AT = class extends aS {
  constructor(e) {
    super(e), this.image = null, this.type = "button";
  }
  clone() {
    return new AT({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image });
  }
};
u([d()], jb.prototype, "image", void 0), jb = AT = u([T("geoscene.support.Action.ActionButton")], jb);
const Wf = jb;
var PT;
let ly = PT = class extends aS {
  constructor(e) {
    super(e), this.image = null, this.type = "toggle", this.value = !1;
  }
  clone() {
    return new PT({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image, value: this.value });
  }
};
u([d()], ly.prototype, "image", void 0), u([d()], ly.prototype, "value", void 0), ly = PT = u([T("geoscene.support.Action.ActionToggle")], ly);
const ej = ly;
var RT;
const kX = Ne.ofType({ key: "type", defaultKeyValue: "button", base: aS, typeMap: { button: Wf, toggle: ej } }), AX = { base: Ep, key: "type", typeMap: { media: Fg, custom: _X, text: vf, attachments: Pg, fields: gf, expression: IO } }, tj = "geoscene.PopupTemplate", PX = we.getLogger(tj), RX = ["attachments", "fields", "media", "text", "expression"];
let Ln = RT = class extends se {
  constructor() {
    super(...arguments), this.actions = null, this.content = "", this.expressionInfos = null, this.fieldInfos = null, this.layerOptions = null, this.lastEditInfoEnabled = !0, this.outFields = null, this.overwriteActions = !1, this.returnGeometry = !1, this.title = "", this.relatedRecordsInfo = null;
  }
  castContent(e) {
    return Array.isArray(e) ? e.map((t) => Ia(AX, t)) : typeof e == "string" || typeof e == "function" || e instanceof HTMLElement || Fl(e) ? e : (PX.error("content error", "unsupported content value", { value: e }), null);
  }
  readContent(e, t) {
    const { popupElements: n } = t;
    return Array.isArray(n) && n.length > 0 ? this._readPopupInfoElements(t) : this._readPopupInfo(t);
  }
  writeContent(e, t, n, r) {
    typeof e != "string" ? Array.isArray(e) && (t.popupElements = e.filter((i) => RX.indexOf(i.type) !== -1).map((i) => i && i.toJSON(r)), t.popupElements.forEach((i) => {
      i.type === "attachments" ? this._writeAttachmentContent(t) : i.type === "media" ? this._writeMediaContent(i, t) : i.type === "text" && this._writeTextContent(i, t);
    })) : t.description = e;
  }
  writeFieldInfos(e, t, n, r) {
    const { content: i } = this, s = Array.isArray(i) ? i : null;
    if (e) {
      const o = s ? s.filter((l) => l.type === "fields") : [], a = o.length && o.every((l) => {
        var c;
        return (c = l.fieldInfos) == null ? void 0 : c.length;
      });
      t.fieldInfos = e.filter(Boolean).map((l) => {
        const c = l.toJSON(r);
        return a && (c.visible = !1), c;
      });
    }
    if (s)
      for (const o of s)
        o.type === "fields" && this._writeFieldsContent(o, t);
  }
  writeLayerOptions(e, t, n, r) {
    t[n] = !e || e.showNoDataRecords === null && e.returnTopmostRaster === null ? null : e.toJSON(r);
  }
  writeTitle(e, t) {
    t.title = e || "";
  }
  clone() {
    const { actions: e } = this, t = e ? q(e.toArray()) : [];
    return new RT({ actions: t, content: Array.isArray(this.content) ? q(this.content) : this.content, expressionInfos: Array.isArray(this.expressionInfos) ? q(this.expressionInfos) : null, fieldInfos: Array.isArray(this.fieldInfos) ? q(this.fieldInfos) : null, layerOptions: this.layerOptions ? q(this.layerOptions) : null, lastEditInfoEnabled: this.lastEditInfoEnabled, outFields: Array.isArray(this.outFields) ? q(this.outFields) : null, overwriteActions: this.overwriteActions, returnGeometry: this.returnGeometry, title: this.title, relatedRecordsInfo: this.relatedRecordsInfo ? q(this.relatedRecordsInfo) : null });
  }
  async collectRequiredFields(e, t) {
    const n = this.expressionInfos || [];
    await this._collectExpressionInfoFields(e, t, [...n, ...this._getContentExpressionInfos(this.content, n)]), Ag(e, t, [...this.outFields || [], ...this._getActionsFields(this.actions), ...this._getTitleFields(this.title), ...this._getContentFields(this.content)]);
  }
  async getRequiredFields(e) {
    const t = /* @__PURE__ */ new Set();
    return await this.collectRequiredFields(t, e), [...t].sort();
  }
  _writeFieldsContent(e, t) {
    if (!Array.isArray(e.fieldInfos) || !e.fieldInfos.length)
      return;
    const n = q(e.fieldInfos);
    Array.isArray(t.fieldInfos) ? n.forEach((r) => {
      const i = t.fieldInfos.find((s) => s.fieldName.toLowerCase() === r.fieldName.toLowerCase());
      i ? i.visible = !0 : t.fieldInfos.push(r);
    }) : t.fieldInfos = n;
  }
  _writeAttachmentContent(e) {
    e.showAttachments || (e.showAttachments = !0);
  }
  _writeTextContent(e, t) {
    !t.description && e.text && (t.description = e.text);
  }
  _writeMediaContent(e, t) {
    if (!Array.isArray(e.mediaInfos) || !e.mediaInfos.length)
      return;
    const n = q(e.mediaInfos);
    Array.isArray(t.mediaInfos) ? t.mediaInfos = [...t.mediaInfos, ...n] : t.mediaInfos = n;
  }
  _readPopupInfoElements({ description: e, mediaInfos: t, popupElements: n }) {
    const r = { description: !1, mediaInfos: !1 };
    return n.map((i) => i.type === "media" ? (i.mediaInfos || !t || r.mediaInfos || (i.mediaInfos = t, r.mediaInfos = !0), Fg.fromJSON(i)) : i.type === "text" ? (i.text || !e || r.description || (i.text = e, r.description = !0), vf.fromJSON(i)) : i.type === "attachments" ? Pg.fromJSON(i) : i.type === "fields" ? gf.fromJSON(i) : i.type === "expression" ? IO.fromJSON(i) : void 0).filter(Boolean);
  }
  _readPopupInfo({ description: e, mediaInfos: t, showAttachments: n }) {
    const r = [];
    return e ? r.push(new vf({ text: e })) : r.push(new gf()), Array.isArray(t) && t.length && r.push(Fg.fromJSON({ mediaInfos: t })), n && r.push(Pg.fromJSON({ displayType: "auto" })), r.length ? r : e;
  }
  _getContentElementFields(e) {
    const t = e == null ? void 0 : e.type;
    if (t === "attachments")
      return [...this._extractFieldNames(e.title), ...this._extractFieldNames(e.description)];
    if (t === "custom")
      return e.outFields || [];
    if (t === "fields")
      return [...this._extractFieldNames(e.title), ...this._extractFieldNames(e.description), ...this._getFieldInfoFields(e.fieldInfos || this.fieldInfos)];
    if (t === "media") {
      const n = e.mediaInfos || [];
      return [...this._extractFieldNames(e.title), ...this._extractFieldNames(e.description), ...n.reduce((r, i) => [...r, ...this._getMediaInfoFields(i)], [])];
    }
    return t === "text" ? this._extractFieldNames(e.text) : [];
  }
  _getMediaInfoFields(e) {
    const { caption: t, title: n, value: r } = e, i = r || {}, { fields: s = [], normalizeField: o, tooltipField: a, sourceURL: l, linkURL: c } = i, p = [...this._extractFieldNames(n), ...this._extractFieldNames(t), ...this._extractFieldNames(l), ...this._extractFieldNames(c), ...s];
    return o && p.push(o), a && p.push(a), p;
  }
  _getContentExpressionInfos(e, t) {
    return Array.isArray(e) ? e.reduce((n, r) => [...n, ...r.type === "expression" && r.expressionInfo ? [r.expressionInfo] : []], t) : [];
  }
  _getContentFields(e) {
    return typeof e == "string" ? this._extractFieldNames(e) : Array.isArray(e) ? e.reduce((t, n) => [...t, ...this._getContentElementFields(n)], []) : [];
  }
  async _collectExpressionInfoFields(e, t, n) {
    n && await Promise.all(n.map((r) => as(e, t, r.expression)));
  }
  _getFieldInfoFields(e) {
    return e ? e.filter((t) => t.visible === void 0 || !!t.visible).map((t) => t.fieldName).filter((t) => t.indexOf("relationships/") === -1 && t.indexOf("expression/") === -1) : [];
  }
  _getActionsFields(e) {
    return e ? e.toArray().reduce((t, n) => [...t, ...this._getActionFields(n)], []) : [];
  }
  _getActionFields(e) {
    const { className: t, title: n, type: r } = e, i = r === "button" || r === "toggle" ? e.image : "";
    return [...this._extractFieldNames(n), ...this._extractFieldNames(t), ...this._extractFieldNames(i)];
  }
  _getTitleFields(e) {
    return typeof e == "string" ? this._extractFieldNames(e) : [];
  }
  _extractFieldNames(e) {
    if (!e || typeof e != "string")
      return [];
    const t = /{[^}]*}/g, n = e.match(t);
    if (!n)
      return [];
    const r = /\{(\w+):.+\}/, i = n.filter((s) => !(s.indexOf("{relationships/") === 0 || s.indexOf("{expression/") === 0)).map((s) => s.replace(r, "{$1}"));
    return i ? i.map((s) => s.slice(1, -1)) : [];
  }
};
u([d({ type: kX })], Ln.prototype, "actions", void 0), u([d()], Ln.prototype, "content", void 0), u([mt("content")], Ln.prototype, "castContent", null), u([be("content", ["description", "fieldInfos", "popupElements", "mediaInfos", "showAttachments"])], Ln.prototype, "readContent", null), u([xe("content", { popupElements: { type: Ne.ofType(MX) }, showAttachments: { type: Boolean }, mediaInfos: { type: Ne.ofType(Y6) }, description: { type: String } })], Ln.prototype, "writeContent", null), u([d({ type: [Q6], json: { write: !0 } })], Ln.prototype, "expressionInfos", void 0), u([d({ type: [_0] })], Ln.prototype, "fieldInfos", void 0), u([xe("fieldInfos")], Ln.prototype, "writeFieldInfos", null), u([d({ type: CX })], Ln.prototype, "layerOptions", void 0), u([xe("layerOptions")], Ln.prototype, "writeLayerOptions", null), u([d({ type: Boolean, json: { read: { source: "showLastEditInfo" }, write: { target: "showLastEditInfo" }, default: !0 } })], Ln.prototype, "lastEditInfoEnabled", void 0), u([d()], Ln.prototype, "outFields", void 0), u([d()], Ln.prototype, "overwriteActions", void 0), u([d()], Ln.prototype, "returnGeometry", void 0), u([d({ json: { type: String } })], Ln.prototype, "title", void 0), u([xe("title")], Ln.prototype, "writeTitle", null), u([d({ type: OX, json: { write: !0 } })], Ln.prototype, "relatedRecordsInfo", void 0), Ln = RT = u([T(tj)], Ln);
const lS = Ln, SP = new st({ esriSMS: "simple-marker", esriPMS: "picture-marker", esriSLS: "simple-line", esriSFS: "simple-fill", esriPFS: "picture-fill", esriTS: "text", esriSHD: "shield-label-symbol", PointSymbol3D: "point-3d", LineSymbol3D: "line-3d", PolygonSymbol3D: "polygon-3d", WebStyleSymbol: "web-style", MeshSymbol3D: "mesh-3d", LabelSymbol3D: "label-3d", CIMSymbolReference: "cim" });
let LX = 0, ih = class extends se {
  constructor(t) {
    super(t), this.id = "sym" + LX++, this.type = null, this.color = new Fe([0, 0, 0, 1]);
  }
  readColor(t) {
    return t && t[0] != null ? [t[0], t[1], t[2], t[3] / 255] : t;
  }
  async collectRequiredFields(t, n) {
  }
  hash() {
    return JSON.stringify(this.toJSON());
  }
  clone() {
  }
};
u([d({ type: SP.apiValues, readOnly: !0, json: { read: !1, write: { ignoreOrigin: !0, writer: SP.write } } })], ih.prototype, "type", void 0), u([d({ type: Fe, json: { write: { allowNull: !0 } } })], ih.prototype, "color", void 0), u([be("color")], ih.prototype, "readColor", null), ih = u([T("geoscene.symbols.Symbol")], ih);
const ki = ih;
var LT;
let su = LT = class extends ki {
  constructor(e) {
    super(e), this.data = null, this.type = "cim";
  }
  readData(e, t) {
    return t;
  }
  writeData(e, t) {
    if (e)
      for (const n in e)
        t[n] = e[n];
  }
  async collectRequiredFields(e, t) {
    if (this.data.type === "CIMSymbolReference") {
      const n = this.data.primitiveOverrides;
      if (n) {
        const r = n.map((i) => {
          const s = i.valueExpressionInfo;
          return as(e, t, s.expression);
        });
        await Promise.all(r);
      }
    }
  }
  clone() {
    return new LT({ data: q(this.data) });
  }
  hash() {
    return UC(JSON.stringify(this.data)).toString();
  }
};
u([d({ json: { write: !1 } })], su.prototype, "color", void 0), u([d({ json: { write: !0 } })], su.prototype, "data", void 0), u([be("data", ["symbol"])], su.prototype, "readData", null), u([xe("data", {})], su.prototype, "writeData", null), u([De({ CIMSymbolReference: "cim" }, { readOnly: !0 })], su.prototype, "type", void 0), su = LT = u([T("geoscene.symbols.CIMSymbol")], su);
const S0 = su;
let sh = class extends se {
  constructor(t) {
    super(t), this.enabled = !0, this.type = null;
  }
  writeEnabled(t, n, r) {
    t || (n[r] = t);
  }
};
u([d({ type: Boolean, json: { read: { source: "enable" }, write: { target: "enable" } } })], sh.prototype, "enabled", void 0), u([xe("enabled")], sh.prototype, "writeEnabled", null), u([d({ type: ["icon", "object", "line", "path", "fill", "water", "extrude", "text"], readOnly: !0 })], sh.prototype, "type", void 0), sh = u([T("geoscene.symbols.Symbol3DLayer")], sh);
const Pa = sh, FX = /^-?(\d+(\.\d+)?)\s*((px)|(pt))?$/i, NX = "screenUtils.toPt: input not recognized!", nj = 96;
function HPe(e) {
  return e ? e / 72 * nj : 0;
}
function rc(e) {
  return e ? 72 * e / nj : 0;
}
function $t(e) {
  if (typeof e == "string") {
    const t = e.match(FX);
    if (t) {
      const n = Number(t[1]), r = t[3] && t[3].toLowerCase(), i = e.charAt(0) === "-", s = r === "px" ? rc(n) : n;
      return i ? -s : s;
    }
    return console.warn(NX), null;
  }
  return e;
}
function wi(e = 0, t = 0) {
  return { x: e, y: t };
}
function JPe(e = 0, t = 0) {
  return [e, t];
}
function DX(e, t) {
  const n = t.transparency != null ? kg(t.transparency) : 1, r = t.color;
  return r && Array.isArray(r) ? new Fe([r[0] || 0, r[1] || 0, r[2] || 0, n]) : null;
}
function jX(e, t) {
  t.color = e.toJSON().slice(0, 3);
  const n = hO(e.a);
  n !== 0 && (t.transparency = n);
}
const yc = { type: Fe, json: { type: [Vt], default: null, read: { source: ["color", "transparency"], reader: DX }, write: { target: { color: { type: [Vt] }, transparency: { type: Vt } }, writer: jX } } }, Ca = { type: Number, cast: $t, json: { write: !0 } };
let zc = class extends se {
  constructor(t) {
    super(t), this.color = new Fe([0, 0, 0, 1]), this.extensionLength = 0, this.size = rc(1);
  }
  clone() {
  }
  cloneProperties() {
    return { color: q(this.color), size: this.size, extensionLength: this.extensionLength };
  }
};
u([d({ type: ["solid", "sketch"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], zc.prototype, "type", void 0), u([d(yc)], zc.prototype, "color", void 0), u([d({ ...Ca, json: { write: { overridePolicy: (e) => ({ enabled: !!e }) } } })], zc.prototype, "extensionLength", void 0), u([d(Ca)], zc.prototype, "size", void 0), zc = u([T("geoscene.symbols.edges.Edges3D")], zc);
const OO = zc;
var FT;
let Vb = FT = class extends OO {
  constructor(e) {
    super(e), this.type = "sketch";
  }
  clone() {
    return new FT(this.cloneProperties());
  }
};
u([De({ sketch: "sketch" }, { readOnly: !0 })], Vb.prototype, "type", void 0), Vb = FT = u([T("geoscene.symbols.edges.SketchEdges3D")], Vb);
const VX = Vb;
var NT;
let zb = NT = class extends OO {
  constructor(e) {
    super(e), this.type = "solid";
  }
  clone() {
    return new NT(this.cloneProperties());
  }
};
u([De({ solid: "solid" }, { readOnly: !0 })], zb.prototype, "type", void 0), zb = NT = u([T("geoscene.symbols.support.SolidEdges3D")], zb);
const zX = zb, rj = { types: { key: "type", base: OO, typeMap: { solid: zX, sketch: VX } }, json: { write: !0 } };
var DT;
let ns = DT = class extends se {
  constructor(e) {
    super(e), this.color = null;
  }
  clone() {
    const e = { color: O(this.color) ? this.color.clone() : null };
    return new DT(e);
  }
};
u([d(yc)], ns.prototype, "color", void 0), ns = DT = u([T("geoscene.symbols.support.Symbol3DMaterial")], ns);
var jT;
let ou = jT = class extends Pa {
  constructor(e) {
    super(e), this.type = "extrude", this.size = 1, this.material = null, this.castShadows = !0, this.edges = null;
  }
  clone() {
    return new jT({ edges: this.edges && this.edges.clone(), enabled: this.enabled, material: O(this.material) ? this.material.clone() : null, castShadows: this.castShadows, size: this.size });
  }
};
u([De({ Extrude: "extrude" }, { readOnly: !0 })], ou.prototype, "type", void 0), u([d({ type: Number, json: { write: { enabled: !0, isRequired: !0 } }, nonNullable: !0 })], ou.prototype, "size", void 0), u([d({ type: ns, json: { write: !0 } })], ou.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], ou.prototype, "castShadows", void 0), u([d(rj)], ou.prototype, "edges", void 0), ou = jT = u([T("geoscene.symbols.ExtrudeSymbol3DLayer")], ou);
const kO = ou;
let uy = class extends ki {
  constructor(t) {
    super(t), this.type = "simple-line", this.width = 0.75;
  }
  hash() {
    return `${this.type}.${this.width}`;
  }
};
u([De({ esriSLS: "simple-line" }, { readOnly: !0 })], uy.prototype, "type", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], uy.prototype, "width", void 0), uy = u([T("geoscene.symbols.LineSymbol")], uy);
const BX = uy, UX = ["begin", "end", "begin-end"], ij = ["arrow", "circle", "square", "diamond", "cross", "x"];
var VT;
let Ko = VT = class extends se {
  constructor(e) {
    super(e), this.placement = "begin-end", this.type = "line-marker", this.style = "arrow";
  }
  writeStyle(e, t, n, r) {
    (r == null ? void 0 : r.origin) === "web-map" ? t[n] = "arrow" : t[n] = e;
  }
  set color(e) {
    this._set("color", e);
  }
  readColor(e) {
    return e && e[0] != null ? [e[0], e[1], e[2], e[3] / 255] : e;
  }
  writeColor(e, t, n, r) {
    (r == null ? void 0 : r.origin) === "web-map" || (t[n] = e);
  }
  clone() {
    return new VT({ color: q(this.color), placement: this.placement, style: this.style });
  }
  hash() {
    var e;
    return `${this.placement}.${(e = this.color) == null ? void 0 : e.hash()}.${this.style}`;
  }
};
u([d({ type: ["begin", "end", "begin-end"], json: { write: !0 } })], Ko.prototype, "placement", void 0), u([De({ "line-marker": "line-marker" }, { readOnly: !0 }), d({ json: { origins: { "web-map": { write: !1 } } } })], Ko.prototype, "type", void 0), u([d({ type: ij })], Ko.prototype, "style", void 0), u([xe("style")], Ko.prototype, "writeStyle", null), u([d({ type: Fe, value: null, json: { write: { allowNull: !0 } } })], Ko.prototype, "color", null), u([be("color")], Ko.prototype, "readColor", null), u([xe("color")], Ko.prototype, "writeColor", null), Ko = VT = u([T("geoscene.symbols.LineSymbolMarker")], Ko);
const qX = Ko;
var zT;
const R2 = new st({ esriSLSSolid: "solid", esriSLSDash: "dash", esriSLSDot: "dot", esriSLSDashDot: "dash-dot", esriSLSDashDotDot: "long-dash-dot-dot", esriSLSNull: "none", esriSLSInsideFrame: "inside-frame", esriSLSShortDash: "short-dash", esriSLSShortDot: "short-dot", esriSLSShortDashDot: "short-dash-dot", esriSLSShortDashDotDot: "short-dash-dot-dot", esriSLSLongDash: "long-dash", esriSLSLongDashDot: "long-dash-dot" });
let Ha = zT = class extends BX {
  constructor(...e) {
    super(...e), this.type = "simple-line", this.style = "solid", this.cap = "round", this.join = "round", this.marker = null, this.miterLimit = 2;
  }
  normalizeCtorArgs(e, t, n, r, i, s) {
    if (e && typeof e != "string")
      return e;
    const o = {};
    return e != null && (o.style = e), t != null && (o.color = t), n != null && (o.width = $t(n)), r != null && (o.cap = r), i != null && (o.join = i), s != null && (o.miterLimit = $t(s)), o;
  }
  clone() {
    var e;
    return new zT({ color: q(this.color), style: this.style, width: this.width, cap: this.cap, join: this.join, miterLimit: this.miterLimit, marker: (e = this.marker) == null ? void 0 : e.clone() });
  }
  hash() {
    var e, t;
    return `${super.hash()}.${(e = this.color) == null ? void 0 : e.hash()}.${this.style}.${this.cap}.${this.join}.${this.miterLimit}.${(t = this.marker) == null ? void 0 : t.hash()}`;
  }
};
u([De({ esriSLS: "simple-line" }, { readOnly: !0 })], Ha.prototype, "type", void 0), u([d({ type: R2.apiValues, json: { read: R2.read, write: R2.write } })], Ha.prototype, "style", void 0), u([d({ type: ["butt", "round", "square"], json: { write: { overridePolicy: (e, t, n) => ({ enabled: e !== "round" && (n == null || n.origin == null) }) } } })], Ha.prototype, "cap", void 0), u([d({ type: ["miter", "round", "bevel"], json: { write: { overridePolicy: (e, t, n) => ({ enabled: e !== "round" && (n == null || n.origin == null) }) } } })], Ha.prototype, "join", void 0), u([d({ types: { key: "type", base: null, defaultKeyValue: "line-marker", typeMap: { "line-marker": qX } }, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], Ha.prototype, "marker", void 0), u([d({ type: Number, json: { read: !1, write: !1 } })], Ha.prototype, "miterLimit", void 0), Ha = zT = u([T("geoscene.symbols.SimpleLineSymbol")], Ha);
const Hs = Ha;
let cy = class extends ki {
  constructor(t) {
    super(t), this.outline = null, this.type = null;
  }
  hash() {
    return `${this.type}.${this.outline && this.outline.hash()}`;
  }
};
u([d({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": Hs } }, json: { default: null, write: !0 } })], cy.prototype, "outline", void 0), u([d({ type: ["simple-fill", "picture-fill"], readOnly: !0 })], cy.prototype, "type", void 0), cy = u([T("geoscene.symbols.FillSymbol")], cy);
const sj = cy;
let Bb = class extends se {
  constructor(t) {
    super(t);
  }
  clone() {
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], Bb.prototype, "type", void 0), Bb = u([T("geoscene.symbols.patterns.LinePattern3D")], Bb);
const oj = Bb, GX = ["dash", "dash-dot", "dot", "long-dash", "long-dash-dot", "long-dash-dot-dot", "none", "short-dash", "short-dash-dot", "short-dash-dot-dot", "short-dot", "solid"];
var BT;
const WX = $r()({ dash: "dash", "dash-dot": "dash-dot", "dash-dot-dot": "long-dash-dot-dot", dot: "dot", "long-dash": "long-dash", "long-dash-dot": "long-dash-dot", null: "none", "short-dash": "short-dash", "short-dash-dot": "short-dash-dot", "short-dash-dot-dot": "short-dash-dot-dot", "short-dot": "short-dot", solid: "solid" });
let dy = BT = class extends oj {
  constructor(e) {
    super(e), this.type = "style", this.style = "solid";
  }
  clone() {
    const e = { style: this.style };
    return new BT(e);
  }
};
u([d({ type: ["style"] })], dy.prototype, "type", void 0), u([De(WX), d({ type: GX })], dy.prototype, "style", void 0), dy = BT = u([T("geoscene.symbols.patterns.LineStylePattern3D")], dy);
const AO = dy;
let Ub = class extends se {
  constructor(t) {
    super(t);
  }
  clone() {
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], Ub.prototype, "type", void 0), Ub = u([T("geoscene.symbols.patterns.Pattern3D")], Ub);
const aj = Ub, HX = ["backward-diagonal", "cross", "diagonal-cross", "forward-diagonal", "horizontal", "none", "solid", "vertical"];
var UT;
let py = UT = class extends aj {
  constructor(e) {
    super(e), this.type = "style", this.style = "solid";
  }
  clone() {
    const e = { style: this.style };
    return new UT(e);
  }
};
u([d({ type: ["style"] })], py.prototype, "type", void 0), u([d({ type: HX, json: { read: !0, write: !0 } })], py.prototype, "style", void 0), py = UT = u([T("geoscene.symbols.patterns.StylePattern3D")], py);
const lj = py, JX = { types: { key: "type", base: aj, typeMap: { style: lj } }, json: { write: !0 } }, uj = { types: { key: "type", base: oj, typeMap: { style: AO } }, json: { write: !0 } }, eg = new Fe("white");
new Fe("black");
const ZX = new Fe([255, 255, 255, 0]);
function KX(e) {
  return e.r === 0 && e.g === 0 && e.b === 0;
}
var qT;
let tg = qT = class extends ns {
  constructor(e) {
    super(e), this.colorMixMode = null;
  }
  clone() {
    const e = { color: O(this.color) ? this.color.clone() : null, colorMixMode: this.colorMixMode };
    return new qT(e);
  }
};
u([De({ multiply: "multiply", replace: "replace", tint: "tint" })], tg.prototype, "colorMixMode", void 0), tg = qT = u([T("geoscene.symbols.support.Symbol3DFillMaterial")], tg);
function ap(e = eee) {
  return [e[0], e[1], e[2], e[3]];
}
function eRe(e) {
  return [e[0], e[1], e[2], e[3]];
}
function tRe(e, t, n, r, i = ap()) {
  return i[0] = e, i[1] = t, i[2] = n, i[3] = r, i;
}
function nRe(e, t = ap()) {
  return t[0] = e.xmin, t[1] = e.ymin, t[2] = e.xmax, t[3] = e.ymax, t;
}
function rRe(e, t) {
  return new Mt({ xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: t });
}
function iRe(e, t) {
  t[0] < e[0] && (e[0] = t[0]), t[0] > e[2] && (e[2] = t[0]), t[1] < e[1] && (e[1] = t[1]), t[1] > e[3] && (e[3] = t[1]);
}
function YX(e) {
  return H(e) || e[0] >= e[2] ? 0 : e[2] - e[0];
}
function QX(e) {
  return e[1] >= e[3] ? 0 : e[3] - e[1];
}
function sRe(e) {
  return YX(e) * QX(e);
}
function oRe(e, t, n) {
  return t[0] >= e[0] - n && t[1] >= e[1] - n && t[0] <= e[2] + n && t[1] <= e[3] + n;
}
function aRe(e, t) {
  return Math.max(t[0], e[0]) <= Math.min(t[2], e[2]) && Math.max(t[1], e[1]) <= Math.min(t[3], e[3]);
}
function XX(e, t) {
  return t[0] >= e[0] && t[2] <= e[2] && t[1] >= e[1] && t[3] <= e[3];
}
const lRe = [1 / 0, 1 / 0, -1 / 0, -1 / 0], eee = [0, 0, 0, 0];
function PO(e = see) {
  return [e[0], e[1], e[2], e[3], e[4], e[5]];
}
function RO(e, t, n, r, i, s, o = PO()) {
  return o[0] = e, o[1] = t, o[2] = n, o[3] = r, o[4] = i, o[5] = s, o;
}
function uRe(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.min(e[2], t[2]), e[3] = Math.max(e[3], t[3]), e[4] = Math.max(e[4], t[4]), e[5] = Math.max(e[5], t[5]);
}
function cRe(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.min(e[2], t[2]), e[3] = Math.max(e[3], t[0]), e[4] = Math.max(e[4], t[1]), e[5] = Math.max(e[5], t[2]);
}
function tee(e) {
  return e[0] >= e[3] ? 0 : e[3] - e[0];
}
function nee(e) {
  return e[1] >= e[4] ? 0 : e[4] - e[1];
}
function ree(e) {
  return e[2] >= e[5] ? 0 : e[5] - e[2];
}
function dRe(e, t = [0, 0, 0]) {
  return t[0] = tee(e), t[1] = nee(e), t[2] = ree(e), t;
}
function pRe(e, t, n = e) {
  return n[0] = t[0], n[1] = t[1], n[2] = t[2], n !== e && (n[3] = e[3], n[4] = e[4], n[5] = e[5]), n;
}
function hRe(e, t, n = e) {
  return n[3] = t[0], n[4] = t[1], n[5] = t[2], n !== e && (n[0] = e[0], n[1] = e[1], n[2] = e[2]), e;
}
function iee(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function fRe(e) {
  return e ? iee(e, $P) : PO($P);
}
function mRe(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = Number.NEGATIVE_INFINITY, e[3] = t[2], e[4] = t[3], e[5] = Number.POSITIVE_INFINITY, e;
}
function xP(e) {
  return e.length === 6;
}
function yRe(e, t, n) {
  if (H(e) || H(t))
    return e === t;
  if (!xP(e) || !xP(t))
    return !1;
  if (n) {
    for (let r = 0; r < e.length; r++)
      if (!n(e[r], t[r]))
        return !1;
  } else
    for (let r = 0; r < e.length; r++)
      if (e[r] !== t[r])
        return !1;
  return !0;
}
const $P = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], see = [0, 0, 0, 0, 0, 0];
PO();
function gRe(e, { isPrimitive: t, width: n, depth: r, height: i }) {
  const s = t ? 10 : 1;
  if (n == null && i == null && r == null)
    return [s * e[0], s * e[1], s * e[2]];
  const o = c6(n, r, i);
  let a;
  for (let l = 0; l < 3; l++) {
    const c = o[l];
    if (c != null) {
      a = c / e[l];
      break;
    }
  }
  for (let l = 0; l < 3; l++)
    o[l] == null && (o[l] = e[l] * a);
  return o;
}
const oee = RO(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5), aee = RO(-0.5, -0.5, 0, 0.5, 0.5, 1), lee = RO(-0.5, -0.5, 0, 0.5, 0.5, 0.5);
function vRe(e) {
  switch (e) {
    case "sphere":
    case "cube":
    case "diamond":
      return oee;
    case "cylinder":
    case "cone":
    case "inverted-cone":
      return aee;
    case "tetrahedron":
      return lee;
    default:
      return;
  }
}
const LO = ["butt", "square", "round"], uee = [...LO, "none"], cj = ["miter", "bevel", "round"];
var GT;
let Bc = GT = class extends se {
  constructor(e) {
    super(e), this.color = new Fe([0, 0, 0, 1]), this.size = rc(1), this.pattern = null, this.patternCap = "butt";
  }
  clone() {
    const e = { color: O(this.color) ? this.color.clone() : null, size: this.size, pattern: O(this.pattern) ? this.pattern.clone() : null, patternCap: this.patternCap };
    return new GT(e);
  }
};
u([d(yc)], Bc.prototype, "color", void 0), u([d(Ca)], Bc.prototype, "size", void 0), u([d(uj)], Bc.prototype, "pattern", void 0), u([d({ type: LO, json: { default: "butt", write: { overridePolicy() {
  return { enabled: O(this.pattern) };
} } } })], Bc.prototype, "patternCap", void 0), Bc = GT = u([T("geoscene.symbols.support.Symbol3DOutline")], Bc);
var qb;
let Ja = qb = class extends Pa {
  constructor(e) {
    super(e), this.type = "fill", this.material = null, this.pattern = null, this.castShadows = !0, this.outline = null, this.edges = null;
  }
  clone() {
    const e = { edges: O(this.edges) ? this.edges.clone() : null, enabled: this.enabled, material: O(this.material) ? this.material.clone() : null, pattern: O(this.pattern) ? this.pattern.clone() : null, castShadows: this.castShadows, outline: O(this.outline) ? this.outline.clone() : null };
    return new qb(e);
  }
  static fromSimpleFillSymbol(e) {
    var t, n, r, i, s, o;
    const a = e.outline && e.outline.style && e.outline.style !== "inside-frame" && e.outline.style !== "solid" ? new AO({ style: e.outline.style }) : null, l = { size: (t = (n = e.outline) == null ? void 0 : n.width) != null ? t : 0, color: ((r = (i = e.outline) == null ? void 0 : i.color) != null ? r : eg).clone(), pattern: a };
    return a && (s = e.outline) != null && s.cap && (l.patternCap = e.outline.cap), new qb({ material: new tg({ color: ((o = e.color) != null ? o : ZX).clone() }), pattern: e.style && e.style !== "solid" ? new lj({ style: e.style }) : null, outline: l });
  }
};
u([De({ Fill: "fill" }, { readOnly: !0 })], Ja.prototype, "type", void 0), u([d({ type: tg, json: { write: !0 } })], Ja.prototype, "material", void 0), u([d(JX)], Ja.prototype, "pattern", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], Ja.prototype, "castShadows", void 0), u([d({ type: Bc, json: { write: !0 } })], Ja.prototype, "outline", void 0), u([d(rj)], Ja.prototype, "edges", void 0), Ja = qb = u([T("geoscene.symbols.FillSymbol3DLayer")], Ja);
const x0 = Ja, cee = ["none", "underline", "line-through"], dee = ["normal", "italic", "oblique"], pee = ["normal", "lighter", "bold", "bolder"], dj = { type: Number, cast: (e) => {
  const t = ks(e);
  return t === 0 ? 1 : js(t, 0.1, 4);
}, nonNullable: !0 }, hee = ["left", "right", "center", "justify"], fee = ["left", "right", "center"], mee = ["baseline", "top", "middle", "bottom"], yee = { type: hee, nonNullable: !0 }, gee = { type: fee, nonNullable: !0 }, pj = { type: mee, nonNullable: !0 };
var WT;
let Za = WT = class extends se {
  constructor(e) {
    super(e), this.decoration = "none", this.family = "sans-serif", this.size = 9, this.style = "normal", this.weight = "normal";
  }
  castSize(e) {
    return $t(e);
  }
  clone() {
    return new WT({ decoration: this.decoration, family: this.family, size: this.size, style: this.style, weight: this.weight });
  }
  hash() {
    return `${this.decoration}.${this.family}.${this.size}.${this.style}.${this.weight}`;
  }
};
u([d({ type: cee, json: { default: "none", write: !0 } })], Za.prototype, "decoration", void 0), u([d({ type: String, json: { write: !0 } })], Za.prototype, "family", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e, t, n) => ({ enabled: !n || !n.textSymbol3D }) } } })], Za.prototype, "size", void 0), u([mt("size")], Za.prototype, "castSize", null), u([d({ type: dee, json: { default: "normal", write: !0 } })], Za.prototype, "style", void 0), u([d({ type: pee, json: { default: "normal", write: !0 } })], Za.prototype, "weight", void 0), Za = WT = u([T("geoscene.symbols.Font")], Za);
const uS = Za;
function Hf(e, t) {
  const n = t && t.url && t.url.path;
  if (e && n && (e = To(e, n, { preserveProtocolRelative: !0 }), t.portalItem && t.readResourcePaths)) {
    const r = nO(e, t.portalItem.itemUrl);
    bee.test(r) && t.readResourcePaths.push(t.portalItem.resourceFromPath(r).path);
  }
  return HT(e, t && t.portal);
}
function $0(e, t, n = Ng.YES) {
  if (!e)
    return e;
  !es(e) && t && t.blockedRelativeUrls && t.blockedRelativeUrls.push(e);
  let r = To(e);
  if (t) {
    const i = t.verifyItemRelativeUrls && t.verifyItemRelativeUrls.rootPath || t.url && t.url.path;
    if (i) {
      const s = HT(i, t.portal);
      r = nO(HT(r, t.portal), s, s), r !== e && t.verifyItemRelativeUrls && t.verifyItemRelativeUrls.writtenUrls.push(r);
    }
  }
  return r = _ee(r, t && t.portal), es(r) && (r = Co(r)), t != null && t.resources && t != null && t.portalItem && !es(r) && !xp(r) && n === Ng.YES && t.resources.toKeep.push({ resource: t.portalItem.resourceFromPath(r) }), r;
}
function FO(e, t, n) {
  return Hf(e, n);
}
function lp(e, t, n, r) {
  const i = $0(e, r);
  i !== void 0 && (t[n] = i);
}
const vee = /\/items\/([^\/]+)\/resources\//, bee = /^\.\/resources\//;
function wee(e) {
  const t = O(e) ? e.match(vee) : null;
  return O(t) ? t[1] : null;
}
function _ee(e, t) {
  return t && !t.isPortal && t.urlKey && t.customBaseUrl ? G$(e, `${t.urlKey}.${t.customBaseUrl}`, t.portalHostname) : e;
}
function HT(e, t) {
  if (!t || t.isPortal || !t.urlKey || !t.customBaseUrl)
    return e;
  const n = `${t.urlKey}.${t.customBaseUrl}`, r = F8();
  return y1(r, `${r.scheme}://${n}`) ? G$(e, t.portalHostname, n) : G$(e, n, t.portalHostname);
}
var Ng;
(function(e) {
  e[e.YES = 0] = "YES", e[e.NO = 1] = "NO";
})(Ng || (Ng = {}));
const bRe = Object.freeze({ __proto__: null, fromJSON: Hf, toJSON: $0, read: FO, write: lp, itemIdFromResourceUrl: wee, get MarkKeep() {
  return Ng;
} });
var JT;
const See = $r()({ circle: "circle", square: "square", cross: "cross", x: "x", kite: "kite", triangle: "triangle" });
let Uc = JT = class extends se {
  constructor(e) {
    super(e);
  }
  readHref(e, t, n) {
    return e ? Hf(e, n) : t.dataURI;
  }
  writeHref(e, t, n, r) {
    e && (xp(e) ? t.dataURI = e : (t.href = $0(e, r), es(t.href) && (t.href = Co(t.href))));
  }
  clone() {
    return new JT({ href: this.href, primitive: this.primitive });
  }
};
u([d({ type: String, json: { write: !0, read: { source: ["href", "dataURI"] } } })], Uc.prototype, "href", void 0), u([be("href")], Uc.prototype, "readHref", null), u([xe("href", { href: { type: String }, dataURI: { type: String } })], Uc.prototype, "writeHref", null), u([De(See)], Uc.prototype, "primitive", void 0), Uc = JT = u([T("geoscene.symbols.support.IconSymbol3DLayerResource")], Uc);
var ZT;
let Vh = ZT = class extends ke {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0;
  }
  clone() {
    return new ZT({ x: this.x, y: this.y });
  }
};
u([d({ type: Number })], Vh.prototype, "x", void 0), u([d({ type: Number })], Vh.prototype, "y", void 0), Vh = ZT = u([T("geoscene.symbols.support.Symbol3DAnchorPosition2D")], Vh);
var KT;
let hy = KT = class extends se {
  constructor(e) {
    super(e), this.color = new Fe([0, 0, 0, 1]), this.size = rc(1);
  }
  clone() {
    const e = { color: O(this.color) ? this.color.clone() : null, size: this.size };
    return new KT(e);
  }
};
u([d(yc)], hy.prototype, "color", void 0), u([d(Ca)], hy.prototype, "size", void 0), hy = KT = u([T("geoscene.symbols.support.Symbol3DIconOutline")], hy);
var oh;
const xee = we.getLogger("geoscene.symbols.IconSymbol3DLayer");
let Yo = oh = class extends Pa {
  constructor(e) {
    super(e), this.material = null, this.resource = null, this.type = "icon", this.size = 12, this.anchor = "center", this.anchorPosition = void 0, this.outline = void 0;
  }
  clone() {
    return new oh({ anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), enabled: this.enabled, material: O(this.material) ? this.material.clone() : null, outline: O(this.outline) ? this.outline.clone() : null, resource: this.resource && this.resource.clone(), size: this.size });
  }
  static fromSimpleMarkerSymbol(e) {
    const t = e.color || eg, n = TP(e), r = e.outline && e.outline.width > 0 ? { size: e.outline.width, color: (e.outline.color || eg).clone() } : null;
    return new oh({ size: e.size, resource: { primitive: Tee(e.style) }, material: { color: t }, outline: r, anchor: n ? "relative" : void 0, anchorPosition: n });
  }
  static fromPictureMarkerSymbol(e) {
    const t = !e.color || KX(e.color) ? eg : e.color, n = TP(e);
    return new oh({ size: e.width <= e.height ? e.height : e.width, resource: { href: e.url }, material: { color: t.clone() }, anchor: n ? "relative" : void 0, anchorPosition: n });
  }
  static fromCIMSymbol(e) {
    return new oh({ resource: { href: B8({ mediaType: "application/json", data: JSON.stringify(e.data) }) } });
  }
};
function TP(e) {
  const t = "width" in e ? e.width : e.size, n = "height" in e ? e.height : e.size, r = EP(e.xoffset), i = EP(e.yoffset);
  return (r || i) && t && n ? { x: -r / t, y: i / n } : null;
}
function EP(e) {
  return isFinite(e) ? e : 0;
}
u([d({ type: ns, json: { write: !0 } })], Yo.prototype, "material", void 0), u([d({ type: Uc, json: { write: !0 } })], Yo.prototype, "resource", void 0), u([De({ Icon: "icon" }, { readOnly: !0 })], Yo.prototype, "type", void 0), u([d(Ca)], Yo.prototype, "size", void 0), u([De({ center: "center", left: "left", right: "right", top: "top", bottom: "bottom", topLeft: "top-left", topRight: "top-right", bottomLeft: "bottom-left", bottomRight: "bottom-right", relative: "relative" }), d({ json: { default: "center" } })], Yo.prototype, "anchor", void 0), u([d({ type: Vh, json: { type: [Number], read: { reader: (e) => new Vh({ x: e[0], y: e[1] }) }, write: { writer: (e, t) => {
  t.anchorPosition = [e.x, e.y];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], Yo.prototype, "anchorPosition", void 0), u([d({ type: hy, json: { write: !0 } })], Yo.prototype, "outline", void 0), Yo = oh = u([T("geoscene.symbols.IconSymbol3DLayer")], Yo);
const $ee = { circle: "circle", cross: "cross", diamond: "kite", square: "square", x: "x", triangle: "triangle", path: null };
function Tee(e) {
  return $ee[e] || (xee.warn(`${e} cannot be mapped to Icon symbol. Fallback to "circle"`), "circle");
}
const Uu = Yo;
we.getLogger("geoscene.core.Clonable");
const Ra = (e) => {
  let t = class extends e {
    clone() {
      const n = oJ(Xr(this), "unable to clone instance of non-accessor class"), r = n.metadatas, i = n.store, s = {}, o = /* @__PURE__ */ new Map();
      for (const c in r) {
        const p = r[c], f = i == null ? void 0 : i.originOf(c), m = p.clonable;
        if (p.readOnly || m === !1 || f !== ot.USER && f !== ot.DEFAULTS && f !== ot.WEB_MAP && f !== ot.WEB_SCENE)
          continue;
        const y = this[c];
        let g = null;
        g = typeof m == "function" ? m(y) : m === "reference" ? y : I$(y), y != null && g == null || (f === ot.DEFAULTS ? o.set(c, g) : s[c] = g);
      }
      const a = new (Object.getPrototypeOf(this)).constructor(s);
      if (o.size) {
        var l;
        const c = (l = Xr(a)) == null ? void 0 : l.store;
        if (c)
          for (const [p, f] of o)
            c.set(p, f, ot.DEFAULTS);
      }
      return a;
    }
  };
  return t = u([T("geoscene.core.Clonable")], t), t;
};
let IP = class extends Ra(ke) {
};
IP = u([T("geoscene.core.Clonable")], IP);
let qc = class extends Ra(se) {
  constructor(t) {
    super(t), this.type = "style", this.placement = "begin-end", this.style = "arrow", this.color = null;
  }
  equals(t) {
    return O(t) && t.placement === this.placement && t.style === this.style && (H(this.color) && H(t.color) || O(this.color) && O(t.color) && this.color.toJSON() === t.color.toJSON());
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], qc.prototype, "type", void 0), u([d({ type: UX, json: { default: "begin-end", write: !0 } })], qc.prototype, "placement", void 0), u([d({ type: ij, json: { default: "arrow", write: !0 } })], qc.prototype, "style", void 0), u([d({ type: Fe, json: { type: [Vt], default: null, write: !0 } })], qc.prototype, "color", void 0), qc = u([T("geoscene.symbols.LineStyleMarker3D")], qc);
const YT = qc;
var Gb;
let Qo = Gb = class extends Pa {
  constructor(e) {
    super(e), this.material = null, this.type = "line", this.join = "miter", this.cap = "butt", this.size = rc(1), this.pattern = null, this.marker = null;
  }
  clone() {
    const e = { enabled: this.enabled, material: O(this.material) ? this.material.clone() : null, size: this.size, join: this.join, cap: this.cap, pattern: O(this.pattern) ? this.pattern.clone() : null, marker: O(this.marker) ? this.marker.clone() : null };
    return new Gb(e);
  }
  static fromSimpleLineSymbol(e) {
    var t, n, r;
    const i = { enabled: !0, size: (t = e.width) != null ? t : rc(1), cap: e.cap || "butt", join: e.join || "miter", pattern: e.style && e.style !== "inside-frame" ? new AO({ style: e.style }) : null, material: new ns({ color: (e.color || eg).clone() }), marker: e.marker ? new YT({ placement: e.marker.placement, style: e.marker.style, color: (n = (r = e.marker.color) == null ? void 0 : r.clone()) != null ? n : null }) : null };
    return new Gb(i);
  }
};
u([d({ type: ns, json: { write: !0 } })], Qo.prototype, "material", void 0), u([De({ Line: "line" }, { readOnly: !0 })], Qo.prototype, "type", void 0), u([d({ type: cj, json: { write: !0, default: "miter" } })], Qo.prototype, "join", void 0), u([d({ type: LO, json: { write: !0, default: "butt" } })], Qo.prototype, "cap", void 0), u([d(Ca)], Qo.prototype, "size", void 0), u([d(uj)], Qo.prototype, "pattern", void 0), u([d({ types: { key: "type", base: YT, typeMap: { style: YT } }, json: { write: !0 } })], Qo.prototype, "marker", void 0), Qo = Gb = u([T("geoscene.symbols.LineSymbol3DLayer")], Qo);
const Jf = Qo;
var QT;
const Eee = $r()({ sphere: "sphere", cylinder: "cylinder", cube: "cube", cone: "cone", diamond: "diamond", tetrahedron: "tetrahedron", invertedCone: "inverted-cone" });
let fy = QT = class extends se {
  clone() {
    return new QT({ href: this.href, primitive: this.primitive });
  }
};
u([d({ type: String, json: { read: FO, write: lp } })], fy.prototype, "href", void 0), u([De(Eee)], fy.prototype, "primitive", void 0), fy = QT = u([T("geoscene.symbols.support.ObjectSymbol3DLayerResource")], fy);
var XT;
let vd = XT = class extends ke {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0, this.z = 0;
  }
  clone() {
    return new XT({ x: this.x, y: this.y, z: this.z });
  }
};
u([d({ type: Number })], vd.prototype, "x", void 0), u([d({ type: Number })], vd.prototype, "y", void 0), u([d({ type: Number })], vd.prototype, "z", void 0), vd = XT = u([T("geoscene.symbols.support.Symbol3DAnchorPosition3D")], vd);
var eE;
let Mr = eE = class extends Pa {
  constructor(e) {
    super(e), this.material = null, this.castShadows = !0, this.resource = null, this.type = "object", this.width = void 0, this.height = void 0, this.depth = void 0, this.anchor = void 0, this.anchorPosition = void 0, this.heading = void 0, this.tilt = void 0, this.roll = void 0;
  }
  clone() {
    return new eE({ heading: this.heading, tilt: this.tilt, roll: this.roll, anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), depth: this.depth, enabled: this.enabled, height: this.height, material: O(this.material) ? this.material.clone() : null, castShadows: this.castShadows, resource: this.resource && this.resource.clone(), width: this.width });
  }
  get isPrimitive() {
    return !this.resource || typeof this.resource.href != "string";
  }
};
u([d({ type: ns, json: { write: !0 } })], Mr.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], Mr.prototype, "castShadows", void 0), u([d({ type: fy, json: { write: !0 } })], Mr.prototype, "resource", void 0), u([De({ Object: "object" }, { readOnly: !0 })], Mr.prototype, "type", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "width", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "height", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "depth", void 0), u([De({ center: "center", top: "top", bottom: "bottom", origin: "origin", relative: "relative" }), d({ json: { default: "origin" } })], Mr.prototype, "anchor", void 0), u([d({ type: vd, json: { type: [Number], read: { reader: (e) => new vd({ x: e[0], y: e[1], z: e[2] }) }, write: { writer: (e, t) => {
  t.anchorPosition = [e.x, e.y, e.z];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], Mr.prototype, "anchorPosition", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "heading", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "tilt", void 0), u([d({ type: Number, json: { write: !0 } })], Mr.prototype, "roll", void 0), u([d({ readOnly: !0 })], Mr.prototype, "isPrimitive", null), Mr = eE = u([T("geoscene.symbols.ObjectSymbol3DLayer")], Mr);
const cS = Mr;
var tE;
let zr = tE = class extends Pa {
  constructor(e) {
    super(e), this.material = null, this.castShadows = !0, this.type = "path", this.profile = "circle", this.join = "miter", this.cap = "butt", this.width = void 0, this.height = void 0, this.anchor = "center", this.profileRotation = "all";
  }
  readWidth(e, t) {
    return e ?? (t.height == null && t.size != null ? t.size : void 0);
  }
  readHeight(e, t) {
    return e ?? (t.width == null && t.size != null ? t.size : void 0);
  }
  clone() {
    return new tE({ enabled: this.enabled, material: O(this.material) ? this.material.clone() : null, castShadows: this.castShadows, profile: this.profile, join: this.join, cap: this.cap, width: this.width, height: this.height, profileRotation: this.profileRotation, anchor: this.anchor });
  }
};
u([d({ type: ns, json: { write: !0 } })], zr.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], zr.prototype, "castShadows", void 0), u([De({ Path: "path" }, { readOnly: !0 })], zr.prototype, "type", void 0), u([d({ type: ["circle", "quad"], json: { write: !0, default: "circle" } })], zr.prototype, "profile", void 0), u([d({ type: cj, json: { write: !0, default: "miter" } })], zr.prototype, "join", void 0), u([d({ type: uee, json: { write: !0, default: "butt" } })], zr.prototype, "cap", void 0), u([d({ type: Number, json: { write: { enabled: !0, target: { width: { type: Number }, size: { type: Number } } } } })], zr.prototype, "width", void 0), u([be("width", ["width", "size", "height"])], zr.prototype, "readWidth", null), u([d({ type: Number, json: { write: !0 } })], zr.prototype, "height", void 0), u([be("height", ["height", "size", "width"])], zr.prototype, "readHeight", null), u([d({ type: ["center", "bottom", "top"], json: { write: !0, default: "center" } })], zr.prototype, "anchor", void 0), u([d({ type: ["heading", "all"], json: { write: !0, default: "all" } })], zr.prototype, "profileRotation", void 0), zr = tE = u([T("geoscene.symbols.PathSymbol3DLayer")], zr);
const NO = zr;
var nE;
let zh = nE = class extends se {
  constructor() {
    super(...arguments), this.color = new Fe([0, 0, 0, 1]), this.size = 0;
  }
  clone() {
    const e = { color: q(this.color), size: this.size };
    return new nE(e);
  }
};
u([d(yc)], zh.prototype, "color", void 0), u([d(Ca)], zh.prototype, "size", void 0), zh = nE = u([T("geoscene.symbols.support.Symbol3DHalo")], zh);
let ng = class extends Ra(se) {
  constructor(t) {
    super(t), this.color = null;
  }
};
u([d(yc)], ng.prototype, "color", void 0), ng = u([T("geoscene.symbols.support.Symbol3DTextBackground")], ng);
var Wb;
let ci = Wb = class extends Pa {
  constructor(e) {
    super(e), this._userSize = void 0, this.halo = null, this.horizontalAlignment = "center", this.lineHeight = 1, this.material = null, this.background = null, this.text = null, this.type = "text", this.verticalAlignment = "baseline";
  }
  get font() {
    return this._get("font") || null;
  }
  set font(e) {
    O(e) && O(this._userSize) && (e.size = this._userSize), this._set("font", e);
  }
  writeFont(e, t, n, r) {
    const i = { ...r, textSymbol3D: !0 };
    t.font = e.write({}, i), delete t.font.size;
  }
  get size() {
    return O(this._userSize) ? this._userSize : O(this.font) && this.font.size != null ? this.font.size : 9;
  }
  set size(e) {
    this._userSize = e, O(this.font) && (this.font.size = this._userSize), this.notifyChange("size");
  }
  clone() {
    const e = new Wb({ enabled: this.enabled, font: this.font && q(this.font), halo: this.halo && q(this.halo), horizontalAlignment: this.horizontalAlignment, lineHeight: this.lineHeight, material: O(this.material) ? this.material.clone() : null, text: this.text, verticalAlignment: this.verticalAlignment, background: q(this.background) });
    return e._userSize = this._userSize, e;
  }
  static fromTextSymbol(e) {
    return new Wb({ font: O(e.font) ? e.font.clone() : new uS(), halo: Iee(e.haloColor, e.haloSize), horizontalAlignment: e.horizontalAlignment, lineHeight: e.lineHeight, material: e.color ? new ns({ color: e.color.clone() }) : null, text: e.text, verticalAlignment: e.verticalAlignment, background: e.backgroundColor ? new ng({ color: e.backgroundColor.clone() }) : null });
  }
};
function Iee(e, t) {
  return e && t > 0 ? new zh({ color: q(e), size: t }) : null;
}
u([d({ type: uS, json: { write: !0 } })], ci.prototype, "font", null), u([xe("font")], ci.prototype, "writeFont", null), u([d({ type: zh, json: { write: !0 } })], ci.prototype, "halo", void 0), u([d({ ...gee, json: { default: "center", write: !0 } })], ci.prototype, "horizontalAlignment", void 0), u([d({ ...dj, json: { default: 1, write: !0 } })], ci.prototype, "lineHeight", void 0), u([d({ type: ns, json: { write: !0 } })], ci.prototype, "material", void 0), u([d({ type: ng, json: { write: !0 } })], ci.prototype, "background", void 0), u([d(Ca)], ci.prototype, "size", null), u([d({ type: String, json: { write: !0 } })], ci.prototype, "text", void 0), u([De({ Text: "text" }, { readOnly: !0 })], ci.prototype, "type", void 0), u([d({ ...pj, json: { default: "baseline", write: !0 } })], ci.prototype, "verticalAlignment", void 0), ci = Wb = u([T("geoscene.symbols.TextSymbol3DLayer")], ci);
const Zf = ci;
var rE;
let au = rE = class extends Pa {
  constructor(e) {
    super(e), this.color = iE.clone(), this.type = "water", this.waterbodySize = "medium", this.waveDirection = null, this.waveStrength = "moderate";
  }
  clone() {
    return new rE({ color: q(this.color), waterbodySize: this.waterbodySize, waveDirection: this.waveDirection, waveStrength: this.waveStrength });
  }
};
u([d({ type: Fe, nonNullable: !0, json: { type: [Vt], write: (e, t, n) => t[n] = e.toArray(Fe.AlphaMode.UNLESS_OPAQUE), default: () => iE.clone(), defaultEquals: (e) => e.toCss(!0) === iE.toCss(!0) } })], au.prototype, "color", void 0), u([De({ Water: "water" }, { readOnly: !0 })], au.prototype, "type", void 0), u([d({ type: ["small", "medium", "large"], json: { write: !0, default: "medium" } })], au.prototype, "waterbodySize", void 0), u([d({ type: Number, json: { write: !0, default: null } })], au.prototype, "waveDirection", void 0), u([d({ type: ["calm", "rippled", "slight", "moderate"], json: { write: !0, default: "moderate" } })], au.prototype, "waveStrength", void 0), au = rE = u([T("geoscene.symbols.WaterSymbol3DLayer")], au);
const iE = new Fe([0, 119, 190]), DO = au;
var sE;
let Gc = sE = class extends ke {
  constructor() {
    super(...arguments), this.portal = null;
  }
  clone() {
    return new sE({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
};
u([d({ type: String })], Gc.prototype, "name", void 0), u([d({ type: String })], Gc.prototype, "styleUrl", void 0), u([d({ type: String })], Gc.prototype, "styleName", void 0), u([d({ type: os })], Gc.prototype, "portal", void 0), Gc = sE = u([T("geoscene.symbols.support.StyleOrigin")], Gc);
const oE = Gc;
var aE;
let rg = aE = class extends ke {
  clone() {
    return new aE({ url: this.url });
  }
};
u([d({ type: String })], rg.prototype, "url", void 0), rg = aE = u([T("geoscene.symbols.support.Thumbnail")], rg);
const hj = { icon: Uu, object: cS, line: Jf, path: NO, fill: x0, extrude: kO, text: Zf, water: DO }, Mee = Ne.ofType({ base: Pa, key: "type", typeMap: hj, errorContext: "symbol-layer" }), Cee = we.getLogger("geoscene.symbols.Symbol3D");
let Xo = class extends ki {
  constructor(t) {
    super(t), this.styleOrigin = null, this.thumbnail = null, this.type = null;
    const n = this.__accessor__ && this.__accessor__.metadatas && this.__accessor__.metadatas.symbolLayers, r = n && n.type || Ne;
    this._set("symbolLayers", new r());
  }
  get color() {
    return null;
  }
  set color(t) {
    this.initialized && Cee.error("Symbol3D does not support colors on the symbol level. Colors may be set on individual symbol layer materials instead.");
  }
  set symbolLayers(t) {
    Xd(t, this._get("symbolLayers"));
  }
  readStyleOrigin(t, n, r) {
    if (t.styleUrl && t.name) {
      const i = Hf(t.styleUrl, r);
      return new oE({ styleUrl: i, name: t.name });
    }
    if (t.styleName && t.name)
      return new oE({ portal: r && r.portal || os.getDefault(), styleName: t.styleName, name: t.name });
    r && r.messages && r.messages.push(new Ds("symbol3d:incomplete-style-origin", "Style origin requires either a 'styleUrl' or 'styleName' and a 'name' property", { context: r, definition: t }));
  }
  writeStyleOrigin(t, n, r, i) {
    if (t.styleUrl && t.name) {
      let s = $0(t.styleUrl, i);
      es(s) && (s = Co(s)), n.styleOrigin = { styleUrl: s, name: t.name };
    } else
      t.styleName && t.name && (t.portal && i && i.portal && !j8(t.portal.restUrl, i.portal.restUrl) ? i && i.messages && i.messages.push(new Ds("symbol:cross-portal", "The symbol style origin cannot be persisted because it refers to an item on a different portal than the one being saved to.", { symbol: this })) : n.styleOrigin = { styleName: t.styleName, name: t.name });
  }
  normalizeCtorArgs(t) {
    return t instanceof Pa || t && hj[t.type] ? { symbolLayers: [t] } : Array.isArray(t) ? { symbolLayers: t } : t;
  }
};
u([d({ json: { read: !1, write: !1 } })], Xo.prototype, "color", null), u([d({ type: Mee, nonNullable: !0, json: { write: !0 } }), mt(T8)], Xo.prototype, "symbolLayers", null), u([d({ type: oE })], Xo.prototype, "styleOrigin", void 0), u([be("styleOrigin")], Xo.prototype, "readStyleOrigin", null), u([xe("styleOrigin", { "styleOrigin.styleUrl": { type: String }, "styleOrigin.styleName": { type: String }, "styleOrigin.name": { type: String } })], Xo.prototype, "writeStyleOrigin", null), u([d({ type: rg, json: { read: !1 } })], Xo.prototype, "thumbnail", void 0), u([d({ type: ["point-3d", "line-3d", "polygon-3d", "mesh-3d", "label-3d"], readOnly: !0 })], Xo.prototype, "type", void 0), Xo = u([T("geoscene.symbols.Symbol3D")], Xo);
const Kf = Xo;
let my = class extends se {
  constructor(t) {
    super(t), this.visible = !0;
  }
  clone() {
  }
};
u([d({ type: ["line"], readOnly: !0, json: { read: !1, write: { ignoreOrigin: !0 } } })], my.prototype, "type", void 0), u([d({ readOnly: !0 })], my.prototype, "visible", void 0), my = u([T("geoscene.symbols.callouts.Callout3D")], my);
const fj = my;
var lE;
let Hb = lE = class extends se {
  constructor() {
    super(...arguments), this.color = new Fe("white");
  }
  clone() {
    return new lE({ color: q(this.color) });
  }
};
u([d(yc)], Hb.prototype, "color", void 0), Hb = lE = u([T("geoscene.symbols.callouts.LineCallout3DBorder")], Hb);
const Oee = Hb;
var uE;
let lu = uE = class extends fj {
  constructor(e) {
    super(e), this.type = "line", this.color = new Fe([0, 0, 0, 1]), this.size = rc(1), this.border = null;
  }
  get visible() {
    return this.size > 0 && O(this.color) && this.color.a > 0;
  }
  clone() {
    return new uE({ color: q(this.color), size: this.size, border: q(this.border) });
  }
};
u([De({ line: "line" }, { readOnly: !0 })], lu.prototype, "type", void 0), u([d(yc)], lu.prototype, "color", void 0), u([d(Ca)], lu.prototype, "size", void 0), u([d({ type: Oee, json: { write: !0 } })], lu.prototype, "border", void 0), u([d({ readOnly: !0 })], lu.prototype, "visible", null), lu = uE = u([T("geoscene.symbols.callouts.LineCallout3D")], lu);
const kee = lu;
function jO(e) {
  if (!e)
    return !1;
  const t = e.verticalOffset;
  return !!t && !(t.screenLength <= 0 || t.maxWorldLength <= 0);
}
function mj(e) {
  if (!e || !e.supportsCallout || !e.supportsCallout())
    return !1;
  const t = e.callout;
  return !!t && !!t.visible && !!jO(e);
}
const yj = { types: { key: "type", base: fj, typeMap: { line: kee } }, json: { write: !0 } };
var cE;
let bd = cE = class extends se {
  constructor() {
    super(...arguments), this.screenLength = 0, this.minWorldLength = 0;
  }
  clone() {
    return new cE({ screenLength: this.screenLength, minWorldLength: this.minWorldLength, maxWorldLength: this.maxWorldLength });
  }
};
u([d(Ca)], bd.prototype, "screenLength", void 0), u([d({ type: Number, json: { write: !0, default: 0 } })], bd.prototype, "minWorldLength", void 0), u([d({ type: Number, json: { write: !0 } })], bd.prototype, "maxWorldLength", void 0), bd = cE = u([T("geoscene.symbols.support.Symbol3DVerticalOffset")], bd);
var Jb;
const gj = Ne.ofType({ base: null, key: "type", typeMap: { text: Zf } });
let uu = Jb = class extends Kf {
  constructor(e) {
    super(e), this.verticalOffset = null, this.callout = null, this.styleOrigin = null, this.symbolLayers = new gj(), this.type = "label-3d";
  }
  supportsCallout() {
    return !0;
  }
  hasVisibleCallout() {
    return mj(this);
  }
  hasVisibleVerticalOffset() {
    return jO(this);
  }
  clone() {
    return new Jb({ styleOrigin: q(this.styleOrigin), symbolLayers: q(this.symbolLayers), thumbnail: q(this.thumbnail), callout: q(this.callout), verticalOffset: q(this.verticalOffset) });
  }
  static fromTextSymbol(e) {
    return new Jb({ symbolLayers: [Zf.fromTextSymbol(e)] });
  }
};
u([d({ type: bd, json: { write: !0 } })], uu.prototype, "verticalOffset", void 0), u([d(yj)], uu.prototype, "callout", void 0), u([d({ json: { read: !1, write: !1 } })], uu.prototype, "styleOrigin", void 0), u([d({ type: gj })], uu.prototype, "symbolLayers", void 0), u([De({ LabelSymbol3D: "label-3d" }, { readOnly: !0 })], uu.prototype, "type", void 0), uu = Jb = u([T("geoscene.symbols.LabelSymbol3D")], uu);
const dS = uu;
var Zb;
const vj = Ne.ofType({ base: null, key: "type", typeMap: { line: Jf, path: NO } }), Aee = Ne.ofType({ base: null, key: "type", typeMap: { line: Jf, path: NO } });
let yy = Zb = class extends Kf {
  constructor(e) {
    super(e), this.symbolLayers = new vj(), this.type = "line-3d";
  }
  clone() {
    return new Zb({ styleOrigin: q(this.styleOrigin), symbolLayers: q(this.symbolLayers), thumbnail: q(this.thumbnail) });
  }
  static fromSimpleLineSymbol(e) {
    return new Zb({ symbolLayers: [Jf.fromSimpleLineSymbol(e)] });
  }
};
u([d({ type: vj, json: { type: Aee } })], yy.prototype, "symbolLayers", void 0), u([De({ LineSymbol3D: "line-3d" }, { readOnly: !0 })], yy.prototype, "type", void 0), yy = Zb = u([T("geoscene.symbols.LineSymbol3D")], yy);
const pS = yy;
let cu = class extends ki {
  constructor(t) {
    super(t), this.angle = 0, this.type = null, this.xoffset = 0, this.yoffset = 0, this.size = 9;
  }
  hash() {
    return `${this.type}.${this.angle}.${this.size}.${this.xoffset}.${this.yoffset}`;
  }
};
u([d({ type: Number, json: { read: (e) => e && -1 * e, write: (e, t) => t.angle = e && -1 * e } })], cu.prototype, "angle", void 0), u([d({ type: ["simple-marker", "picture-marker"], readOnly: !0 })], cu.prototype, "type", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], cu.prototype, "xoffset", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], cu.prototype, "yoffset", void 0), u([d({ type: Number, cast: (e) => e === "auto" ? e : $t(e), json: { write: !0 } })], cu.prototype, "size", void 0), cu = u([T("geoscene.symbols.MarkerSymbol")], cu);
const bj = cu;
var dE;
const wj = Ne.ofType({ base: null, key: "type", typeMap: { fill: x0 } });
let gy = dE = class extends Kf {
  constructor(e) {
    super(e), this.symbolLayers = new wj(), this.type = "mesh-3d";
  }
  clone() {
    return new dE({ styleOrigin: q(this.styleOrigin), symbolLayers: q(this.symbolLayers), thumbnail: q(this.thumbnail) });
  }
};
u([d({ type: wj })], gy.prototype, "symbolLayers", void 0), u([De({ MeshSymbol3D: "mesh-3d" }, { readOnly: !0 })], gy.prototype, "type", void 0), gy = dE = u([T("geoscene.symbols.MeshSymbol3D")], gy);
const VO = gy;
function Pee(e, t, n) {
  return t.imageData ? B8({ mediaType: t.contentType || "image/png", isBase64: !0, data: t.imageData }) : _j(t.url, n);
}
function _j(e, t) {
  return Lee(t) && !es(e) && t.layer.parsedUrl ? Xu(t.layer.parsedUrl.path, "images", e) : Hf(e, t);
}
function Ree(e, t, n, r) {
  if (xp(e)) {
    const i = z8(e);
    t.contentType = i.mediaType, t.imageData = i.data, n && n.imageData === t.imageData && n.url && lp(n.url, t, "url", r);
  } else
    lp(e, t, "url", r);
}
const Sj = { json: { read: { source: ["imageData", "url"], reader: Pee }, write: { writer(e, t, n, r) {
  Ree(e, t, this.source, r);
} } } }, xj = { readOnly: !0, json: { read: { source: ["imageData", "url"], reader(e, t, n) {
  const r = {};
  return t.imageData && (r.imageData = t.imageData), t.contentType && (r.contentType = t.contentType), t.url && (r.url = _j(t.url, n)), r;
} } } };
function Lee(e) {
  return e && (e.origin === "service" || e.origin === "portal-item") && e.layer && (e.layer.type === "feature" || e.layer.type === "stream");
}
var pE;
let Ss = pE = class extends sj {
  constructor(...e) {
    super(...e), this.type = "picture-fill", this.url = null, this.xscale = 1, this.yscale = 1, this.width = 12, this.height = 12, this.xoffset = 0, this.yoffset = 0, this.source = null;
  }
  normalizeCtorArgs(e, t, n, r) {
    if (e && typeof e != "string" && e.imageData == null)
      return e;
    const i = {};
    return e && (i.url = e), t && (i.outline = t), n != null && (i.width = $t(n)), r != null && (i.height = $t(r)), i;
  }
  clone() {
    const e = new pE({ color: q(this.color), height: this.height, outline: this.outline && this.outline.clone(), url: this.url, width: this.width, xoffset: this.xoffset, xscale: this.xscale, yoffset: this.yoffset, yscale: this.yscale });
    return e._set("source", q(this.source)), e;
  }
  hash() {
    var e;
    return `${super.hash()}.${(e = this.color) == null ? void 0 : e.hash()}.${this.height}.${this.url}.${this.width}.${this.xoffset}.${this.xscale}.${this.yoffset}.${this.yscale}`;
  }
};
u([De({ esriPFS: "picture-fill" }, { readOnly: !0 })], Ss.prototype, "type", void 0), u([d(Sj)], Ss.prototype, "url", void 0), u([d({ type: Number, json: { write: !0 } })], Ss.prototype, "xscale", void 0), u([d({ type: Number, json: { write: !0 } })], Ss.prototype, "yscale", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Ss.prototype, "width", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Ss.prototype, "height", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Ss.prototype, "xoffset", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Ss.prototype, "yoffset", void 0), u([d(xj)], Ss.prototype, "source", void 0), Ss = pE = u([T("geoscene.symbols.PictureFillSymbol")], Ss);
const $j = Ss;
var hE;
let lo = hE = class extends bj {
  constructor(...e) {
    super(...e), this.color = null, this.type = "picture-marker", this.url = null, this.source = null, this.height = 12, this.width = 12, this.size = null;
  }
  normalizeCtorArgs(e, t, n) {
    if (e && typeof e != "string" && e.imageData == null)
      return e;
    const r = {};
    return e && (r.url = e), t != null && (r.width = $t(t)), n != null && (r.height = $t(n)), r;
  }
  readHeight(e, t) {
    return t.size || e;
  }
  readWidth(e, t) {
    return t.size || e;
  }
  clone() {
    const e = new hE({ angle: this.angle, height: this.height, url: this.url, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
    return e._set("source", q(this.source)), e;
  }
  hash() {
    return `${super.hash()}.${this.height}.${this.url}.${this.width}`;
  }
};
u([d({ json: { write: !1 } })], lo.prototype, "color", void 0), u([De({ esriPMS: "picture-marker" }, { readOnly: !0 })], lo.prototype, "type", void 0), u([d(Sj)], lo.prototype, "url", void 0), u([d(xj)], lo.prototype, "source", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], lo.prototype, "height", void 0), u([be("height", ["height", "size"])], lo.prototype, "readHeight", null), u([d({ type: Number, cast: $t, json: { write: !0 } })], lo.prototype, "width", void 0), u([d({ json: { write: !1 } })], lo.prototype, "size", void 0), lo = hE = u([T("geoscene.symbols.PictureMarkerSymbol")], lo);
const hS = lo;
var du;
const Tj = Ne.ofType({ base: null, key: "type", typeMap: { icon: Uu, object: cS, text: Zf } });
let Wc = du = class extends Kf {
  constructor(e) {
    super(e), this.verticalOffset = null, this.callout = null, this.symbolLayers = new Tj(), this.type = "point-3d";
  }
  supportsCallout() {
    if ((this.symbolLayers ? this.symbolLayers.length : 0) < 1)
      return !1;
    for (const e of this.symbolLayers.items)
      switch (e.type) {
        case "icon":
        case "text":
        case "object":
          continue;
        default:
          return !1;
      }
    return !0;
  }
  hasVisibleCallout() {
    return mj(this);
  }
  hasVisibleVerticalOffset() {
    return jO(this);
  }
  clone() {
    return new du({ verticalOffset: q(this.verticalOffset), callout: q(this.callout), styleOrigin: q(this.styleOrigin), symbolLayers: q(this.symbolLayers), thumbnail: q(this.thumbnail) });
  }
  static fromSimpleMarkerSymbol(e) {
    return new du({ symbolLayers: [Uu.fromSimpleMarkerSymbol(e)] });
  }
  static fromPictureMarkerSymbol(e) {
    return new du({ symbolLayers: [Uu.fromPictureMarkerSymbol(e)] });
  }
  static fromCIMSymbol(e) {
    var t, n;
    return ((t = e.data) == null || (n = t.symbol) == null ? void 0 : n.type) !== "CIMPointSymbol" ? null : e.data.symbol.callout ? new du({ symbolLayers: [Uu.fromCIMSymbol(e)], callout: { type: "line", size: 0.5, color: [0, 0, 0] }, verticalOffset: { screenLength: 40 } }) : new du({ symbolLayers: [Uu.fromCIMSymbol(e)] });
  }
  static fromTextSymbol(e) {
    return new du({ symbolLayers: [Zf.fromTextSymbol(e)] });
  }
};
u([d({ type: bd, json: { write: !0 } })], Wc.prototype, "verticalOffset", void 0), u([d(yj)], Wc.prototype, "callout", void 0), u([d({ type: Tj, json: { origins: { "web-scene": { write: !0 } } } })], Wc.prototype, "symbolLayers", void 0), u([De({ PointSymbol3D: "point-3d" }, { readOnly: !0 })], Wc.prototype, "type", void 0), Wc = du = u([T("geoscene.symbols.PointSymbol3D")], Wc);
const $d = Wc;
var vy;
const Ej = Ne.ofType({ base: null, key: "type", typeMap: { extrude: kO, fill: x0, icon: Uu, line: Jf, object: cS, text: Zf, water: DO } }), Fee = Ne.ofType({ base: null, key: "type", typeMap: { extrude: kO, fill: x0, icon: Uu, line: Jf, object: cS, water: DO } });
let ah = vy = class extends Kf {
  constructor(e) {
    super(e), this.symbolLayers = new Ej(), this.type = "polygon-3d";
  }
  writeSymbolLayers(e, t, n, r) {
    const i = e.filter((s) => s.type !== "text");
    if (r && r.messages && i.length < e.length) {
      const s = e.find((o) => o.type === "text");
      r.messages.push(new D("symbol-layer:unsupported", "Symbol layers of type 'text' cannot be persisted in PolygonSymbol3D", { symbolLayer: s }));
    }
    t[n] = i.map((s) => s.write({}, r)).toArray();
  }
  clone() {
    return new vy({ styleOrigin: q(this.styleOrigin), symbolLayers: q(this.symbolLayers), thumbnail: q(this.thumbnail) });
  }
  static fromJSON(e) {
    const t = new vy();
    if (t.read(e), t.symbolLayers.length === 2 && t.symbolLayers.getItemAt(0).type === "fill" && t.symbolLayers.getItemAt(1).type === "line") {
      const n = t.symbolLayers.getItemAt(0), r = t.symbolLayers.getItemAt(1);
      !r.enabled || e.symbolLayers && e.symbolLayers[1] && e.symbolLayers[1].enable === !1 || (n.outline = { size: r.size, color: O(r.material) ? r.material.color : null }), t.symbolLayers.removeAt(1);
    }
    return t;
  }
  static fromSimpleFillSymbol(e) {
    return new vy({ symbolLayers: [x0.fromSimpleFillSymbol(e)] });
  }
};
u([d({ type: Ej, json: { type: Fee } })], ah.prototype, "symbolLayers", void 0), u([xe("web-scene", "symbolLayers")], ah.prototype, "writeSymbolLayers", null), u([De({ PolygonSymbol3D: "polygon-3d" }, { readOnly: !0 })], ah.prototype, "type", void 0), ah = vy = u([T("geoscene.symbols.PolygonSymbol3D")], ah);
const T0 = ah;
var fE;
const L2 = new st({ esriSFSSolid: "solid", esriSFSNull: "none", esriSFSHorizontal: "horizontal", esriSFSVertical: "vertical", esriSFSForwardDiagonal: "forward-diagonal", esriSFSBackwardDiagonal: "backward-diagonal", esriSFSCross: "cross", esriSFSDiagonalCross: "diagonal-cross" });
let Hc = fE = class extends sj {
  constructor(...e) {
    super(...e), this.color = new Fe([0, 0, 0, 0.25]), this.outline = new Hs(), this.type = "simple-fill", this.style = "solid";
  }
  normalizeCtorArgs(e, t, n) {
    if (e && typeof e != "string")
      return e;
    const r = {};
    return e && (r.style = e), t && (r.outline = t), n && (r.color = n), r;
  }
  clone() {
    return new fE({ color: q(this.color), outline: this.outline && this.outline.clone(), style: this.style });
  }
  hash() {
    return `${super.hash()}${this.style}.${this.color && this.color.hash()}`;
  }
};
u([d()], Hc.prototype, "color", void 0), u([d()], Hc.prototype, "outline", void 0), u([De({ esriSFS: "simple-fill" }, { readOnly: !0 })], Hc.prototype, "type", void 0), u([d({ type: L2.apiValues, json: { read: L2.read, write: L2.write } })], Hc.prototype, "style", void 0), Hc = fE = u([T("geoscene.symbols.SimpleFillSymbol")], Hc);
const Ip = Hc;
var mE;
const F2 = new st({ esriSMSCircle: "circle", esriSMSSquare: "square", esriSMSCross: "cross", esriSMSX: "x", esriSMSDiamond: "diamond", esriSMSTriangle: "triangle", esriSMSPath: "path" });
let ea = mE = class extends bj {
  constructor(...e) {
    super(...e), this.color = new Fe([255, 255, 255, 0.25]), this.type = "simple-marker", this.size = 12, this.style = "circle", this.outline = new Hs();
  }
  normalizeCtorArgs(e, t, n, r) {
    if (e && typeof e != "string")
      return e;
    const i = {};
    return e && (i.style = e), t != null && (i.size = $t(t)), n && (i.outline = n), r && (i.color = r), i;
  }
  writeColor(e, t) {
    e && this.style !== "x" && this.style !== "cross" && (t.color = e.toJSON()), e === null && (t.color = null);
  }
  set path(e) {
    this.style = "path", this._set("path", e);
  }
  clone() {
    return new mE({ angle: this.angle, color: q(this.color), outline: this.outline && this.outline.clone(), path: this.path, size: this.size, style: this.style, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    var e;
    return `${super.hash()}.${this.color && this.color.hash()}.${this.path}.${this.style}.${(e = this.outline) == null ? void 0 : e.hash()}`;
  }
};
u([d()], ea.prototype, "color", void 0), u([xe("color")], ea.prototype, "writeColor", null), u([De({ esriSMS: "simple-marker" }, { readOnly: !0 })], ea.prototype, "type", void 0), u([d()], ea.prototype, "size", void 0), u([d({ type: F2.apiValues, json: { read: F2.read, write: F2.write } })], ea.prototype, "style", void 0), u([d({ type: String, json: { write: !0 } })], ea.prototype, "path", null), u([d({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": Hs } }, json: { default: null, write: !0 } })], ea.prototype, "outline", void 0), ea = mE = u([T("geoscene.symbols.SimpleMarkerSymbol")], ea);
const Yf = ea;
var yE;
let Xt = yE = class extends ki {
  constructor(...e) {
    super(...e), this.backgroundColor = null, this.borderLineColor = null, this.borderLineSize = null, this.font = new uS(), this.horizontalAlignment = "center", this.kerning = !0, this.haloColor = null, this.haloSize = null, this.rightToLeft = null, this.rotated = !1, this.text = "", this.type = "text", this.verticalAlignment = "baseline", this.xoffset = 0, this.yoffset = 0, this.angle = 0, this.width = null, this.lineWidth = 192, this.lineHeight = 1;
  }
  normalizeCtorArgs(e, t, n) {
    if (e && typeof e != "string")
      return e;
    const r = {};
    return e && (r.text = e), t && (r.font = t), n && (r.color = n), r;
  }
  writeLineWidth(e, t, n, r) {
    r && typeof r != "string" ? r.origin : t[n] = e;
  }
  castLineWidth(e) {
    return $t(e);
  }
  writeLineHeight(e, t, n, r) {
    r && typeof r != "string" ? r.origin : t[n] = e;
  }
  clone() {
    return new yE({ angle: this.angle, backgroundColor: q(this.backgroundColor), borderLineColor: q(this.borderLineColor), borderLineSize: this.borderLineSize, color: q(this.color), font: this.font && this.font.clone(), haloColor: q(this.haloColor), haloSize: this.haloSize, horizontalAlignment: this.horizontalAlignment, kerning: this.kerning, lineHeight: this.lineHeight, lineWidth: this.lineWidth, rightToLeft: this.rightToLeft, rotated: this.rotated, text: this.text, verticalAlignment: this.verticalAlignment, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    return `${this.backgroundColor && this.backgroundColor.hash()}.${this.borderLineColor}.${this.borderLineSize}.${this.color.hash()}.${this.font && this.font.hash()}.${this.haloColor && this.haloColor.hash()}.${this.haloSize}.${this.horizontalAlignment}.${this.kerning}.${this.rightToLeft}.${this.rotated}.${this.text}.${this.verticalAlignment}.${this.width}.${this.xoffset}.${this.yoffset}.${this.lineHeight}.${this.lineWidth}.${this.angle}`;
  }
};
u([d({ type: Fe, json: { write: !0 } })], Xt.prototype, "backgroundColor", void 0), u([d({ type: Fe, json: { write: !0 } })], Xt.prototype, "borderLineColor", void 0), u([d({ type: Number, json: { write: !0 } })], Xt.prototype, "borderLineSize", void 0), u([d({ type: uS, json: { write: !0 } })], Xt.prototype, "font", void 0), u([d({ ...yee, json: { write: !0 } })], Xt.prototype, "horizontalAlignment", void 0), u([d({ type: Boolean, json: { write: !0 } })], Xt.prototype, "kerning", void 0), u([d({ type: Fe, json: { write: !0 } })], Xt.prototype, "haloColor", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Xt.prototype, "haloSize", void 0), u([d({ type: Boolean, json: { write: !0 } })], Xt.prototype, "rightToLeft", void 0), u([d({ type: Boolean, json: { write: !0 } })], Xt.prototype, "rotated", void 0), u([d({ type: String, json: { write: !0 } })], Xt.prototype, "text", void 0), u([De({ esriTS: "text" }, { readOnly: !0 })], Xt.prototype, "type", void 0), u([d({ ...pj, json: { write: !0 } })], Xt.prototype, "verticalAlignment", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Xt.prototype, "xoffset", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], Xt.prototype, "yoffset", void 0), u([d({ type: Number, json: { read: (e) => e && -1 * e, write: (e, t) => t.angle = e && -1 * e } })], Xt.prototype, "angle", void 0), u([d({ type: Number, json: { write: !0 } })], Xt.prototype, "width", void 0), u([d({ type: Number })], Xt.prototype, "lineWidth", void 0), u([xe("lineWidth")], Xt.prototype, "writeLineWidth", null), u([mt("lineWidth")], Xt.prototype, "castLineWidth", null), u([d(dj)], Xt.prototype, "lineHeight", void 0), u([xe("lineHeight")], Xt.prototype, "writeLineHeight", null), Xt = yE = u([T("geoscene.symbols.TextSymbol")], Xt);
const Ro = Xt;
var gE;
const Nee = we.getLogger("geoscene.symbols.WebStyleSymbol");
let ta = gE = class extends ki {
  constructor(e) {
    super(e), this.styleName = null, this.portal = null, this.styleUrl = null, this.thumbnail = null, this.name = null, this.type = "web-style";
  }
  read(e, t) {
    this.portal = t ? t.portal : void 0, super.read(e, t);
  }
  clone() {
    return new gE({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
  fetchSymbol(e) {
    return this._fetchSymbol("webRef", e);
  }
  fetchCIMSymbol(e) {
    return this._fetchSymbol("cimRef", e);
  }
  async _fetchSymbol(e, t) {
    const n = await Dee();
    On(t);
    const r = n.resolveWebStyleSymbol(this, { portal: this.portal }, e, t);
    return r.catch((i) => {
      Nee.error("#fetchSymbol()", "Failed to create symbol from style", i);
    }), r;
  }
};
function Dee() {
  return import("./webStyleSymbolUtils-SBflTYR9.js");
}
u([d({ json: { write: !1 } })], ta.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], ta.prototype, "styleName", void 0), u([d({ type: os, json: { write: !1 } })], ta.prototype, "portal", void 0), u([d({ type: String, json: { read: FO, write: lp } })], ta.prototype, "styleUrl", void 0), u([d({ type: rg, json: { read: !1 } })], ta.prototype, "thumbnail", void 0), u([d({ type: String, json: { write: !0 } })], ta.prototype, "name", void 0), u([De({ styleSymbolReference: "web-style" }, { readOnly: !0 })], ta.prototype, "type", void 0), ta = gE = u([T("geoscene.symbols.WebStyleSymbol")], ta);
const Mp = ta;
function zO(e) {
  if (!e)
    return !1;
  switch (e.type) {
    case "picture-fill":
    case "picture-marker":
    case "simple-fill":
    case "simple-line":
    case "simple-marker":
    case "text":
    case "cim":
      return !0;
    default:
      return !1;
  }
}
function Dg(e) {
  if (!e)
    return !1;
  switch (e.type) {
    case "label-3d":
    case "line-3d":
    case "mesh-3d":
    case "point-3d":
    case "polygon-3d":
      return !0;
    default:
      return !1;
  }
}
const Ud = { base: ki, key: "type", typeMap: { "simple-fill": Ip, "picture-fill": $j, "picture-marker": hS, "simple-line": Hs, "simple-marker": Yf, text: Ro, "label-3d": dS, "line-3d": pS, "mesh-3d": VO, "point-3d": $d, "polygon-3d": T0, "web-style": Mp, cim: S0 }, errorContext: "symbol" }, jee = { base: ki, key: "type", typeMap: { "picture-marker": hS, "simple-marker": Yf, text: Ro, "web-style": Mp, cim: S0 }, errorContext: "symbol" }, Vee = zf({ types: Ud }), Ij = { base: ki, key: "type", typeMap: { "simple-fill": Ip, "picture-fill": $j, "picture-marker": hS, "simple-line": Hs, "simple-marker": Yf, text: Ro, "line-3d": pS, "mesh-3d": VO, "point-3d": $d, "polygon-3d": T0, "web-style": Mp, cim: S0 }, errorContext: "symbol" }, zee = { base: ki, key: "type", typeMap: { text: Ro, "label-3d": dS }, errorContext: "symbol" }, MP = { base: ki, key: "type", typeMap: { "line-3d": pS, "mesh-3d": VO, "point-3d": $d, "polygon-3d": T0, "web-style": Mp, cim: S0 }, errorContext: "symbol" }, Bee = { base: ki, key: "type", typeMap: { "label-3d": dS }, errorContext: "symbol" }, Mj = Ia(Ud);
function Uee(e) {
  if (!e)
    return null;
  const t = {};
  for (const n in e) {
    const r = tc(e[n]);
    r && (t[n] = r);
  }
  return Object.keys(t).length !== 0 ? t : null;
}
function qee(e) {
  if (!O(e))
    return null;
  const t = {};
  for (const n in e) {
    const r = e[n];
    r && (t[n] = r.toJSON());
  }
  return Object.keys(t).length !== 0 ? t : null;
}
let di = class extends Ra(se) {
  constructor(...t) {
    super(...t), this.isAggregate = !1, this.layer = null, this.popupTemplate = null, this.sourceLayer = null, Object.defineProperty(this, "uid", { value: Jy(), configurable: !0 });
  }
  normalizeCtorArgs(t, n, r, i) {
    return t && !t.declaredClass ? t : { geometry: t, symbol: n, attributes: r, popupTemplate: i };
  }
  set aggregateGeometries(t) {
    const n = this._get("aggregateGeometries");
    JSON.stringify(n) !== JSON.stringify(t) && this._set("aggregateGeometries", t);
  }
  set attributes(t) {
    const n = this._get("attributes");
    n !== t && (this._set("attributes", t), this._notifyLayer("attributes", n, t));
  }
  set geometry(t) {
    const n = this._get("geometry");
    n !== t && (this._set("geometry", t), this._notifyLayer("geometry", n, t));
  }
  set symbol(t) {
    const n = this._get("symbol");
    n !== t && (this._set("symbol", t), this._notifyLayer("symbol", n, t));
  }
  set visible(t) {
    const n = this._get("visible");
    n !== t && (this._set("visible", t), this._notifyLayer("visible", n, t));
  }
  getEffectivePopupTemplate(t = !1) {
    if (this.popupTemplate)
      return this.popupTemplate;
    for (const n of [this.sourceLayer, this.layer])
      if (n) {
        if ("popupTemplate" in n && n.popupTemplate)
          return n.popupTemplate;
        if (t && "defaultPopupTemplate" in n && O(n.defaultPopupTemplate))
          return n.defaultPopupTemplate;
      }
    return null;
  }
  getAttribute(t) {
    return this.attributes && this.attributes[t];
  }
  setAttribute(t, n) {
    if (this.attributes) {
      const r = this.getAttribute(t);
      this.attributes[t] = n, this._notifyLayer("attributes", r, n, t);
    } else
      this.attributes = { [t]: n }, this._notifyLayer("attributes", void 0, n, t);
  }
  getObjectId() {
    return this.sourceLayer && "objectIdField" in this.sourceLayer && this.sourceLayer.objectIdField ? this.getAttribute(this.sourceLayer.objectIdField) : null;
  }
  toJSON() {
    return { aggregateGeometries: qee(this.aggregateGeometries), geometry: O(this.geometry) ? this.geometry.toJSON() : null, symbol: O(this.symbol) ? this.symbol.toJSON() : null, attributes: { ...this.attributes }, popupTemplate: this.popupTemplate && this.popupTemplate.toJSON() };
  }
  notifyGeometryChanged() {
    this._notifyLayer("geometry", this.geometry, this.geometry);
  }
  notifyMeshTransformChanged() {
    O(this.geometry) && this.geometry.type === "mesh" && this._notifyLayer("transform", this.geometry.transform, this.geometry.transform);
  }
  _notifyLayer(t, n, r, i) {
    if (!this.layer || !("graphicChanged" in this.layer))
      return;
    const s = { graphic: this, property: t, oldValue: n, newValue: r };
    t === "attributes" && (s.attributeName = i), this.layer.graphicChanged(s);
  }
};
u([d({ value: null, json: { read: Uee } })], di.prototype, "aggregateGeometries", null), u([d({ value: null })], di.prototype, "attributes", null), u([d({ value: null, types: Tp, json: { read: tc } })], di.prototype, "geometry", null), u([d({ type: Boolean })], di.prototype, "isAggregate", void 0), u([d({ clonable: "reference" })], di.prototype, "layer", void 0), u([d({ type: lS })], di.prototype, "popupTemplate", void 0), u([d({ clonable: "reference" })], di.prototype, "sourceLayer", void 0), u([d({ value: null, types: Ud })], di.prototype, "symbol", null), u([d({ type: Boolean, value: !0 })], di.prototype, "visible", null), di = u([T("geoscene.Graphic")], di), function(e) {
  e.generateUID = Jy;
}(di || (di = {}));
const Jt = di;
let BO = class {
  constructor(t, n) {
    this.min = t, this.max = n, this.range = n - t;
  }
  ndiff(t, n = 0) {
    return Math.ceil((t - n) / this.range) * this.range + n;
  }
  _normalize(t, n, r, i = 0, s = !1) {
    return (r -= i) < t ? r += this.ndiff(t - r) : r > n && (r -= this.ndiff(r - n)), s && r === n && (r = t), r + i;
  }
  normalize(t, n = 0, r = !1) {
    return this._normalize(this.min, this.max, t, n, r);
  }
  clamp(t, n = 0) {
    return js(t - n, this.min, this.max) + n;
  }
  monotonic(t, n, r) {
    return t < n ? n : n + this.ndiff(t - n, r);
  }
  minimalMonotonic(t, n, r) {
    return this._normalize(t, t + this.range, n, r);
  }
  center(t, n, r) {
    return n = this.monotonic(t, n, r), this.normalize((t + n) / 2, r);
  }
  diff(t, n, r) {
    return this.monotonic(t, n, r) - t;
  }
  shortestSignedDiff(t, n) {
    t = this.normalize(t);
    const r = (n = this.normalize(n)) - t, i = n < t ? this.minimalMonotonic(t, n) - t : n - this.minimalMonotonic(n, t);
    return Math.abs(r) < Math.abs(i) ? r : i;
  }
  contains(t, n, r) {
    return n = this.minimalMonotonic(t, n), (r = this.minimalMonotonic(t, r)) > t && r < n;
  }
};
function UO(e) {
  for (const t in e) {
    const n = e[t];
    n instanceof Function && (e[t] = n.bind(e));
  }
  return e;
}
UO(new BO(0, 2 * Math.PI));
UO(new BO(-Math.PI, Math.PI));
const Gee = UO(new BO(0, 360));
let Ka = class extends Ra(se) {
  constructor(...t) {
    super(...t), this.position = new Oe([0, 0, 0]), this.heading = 0, this.tilt = 0, this.fov = 55;
  }
  normalizeCtorArgs(t, n, r, i) {
    if (t && typeof t == "object" && ("x" in t || Array.isArray(t))) {
      const s = { position: t };
      return n != null && (s.heading = n), r != null && (s.tilt = r), i != null && (s.fov = i), s;
    }
    return t;
  }
  writePosition(t, n, r, i) {
    const s = t.clone();
    s.x = ks(t.x || 0), s.y = ks(t.y || 0), s.z = t.hasZ ? ks(t.z || 0) : t.z, n[r] = s.write({}, i);
  }
  readPosition(t, n) {
    const r = new Oe();
    return r.read(t, n), r.x = ks(r.x || 0), r.y = ks(r.y || 0), r.z = r.hasZ ? ks(r.z || 0) : r.z, r;
  }
  equals(t) {
    return !!t && this.tilt === t.tilt && this.heading === t.heading && this.fov === t.fov && this.position.equals(t.position);
  }
};
u([d({ type: Oe, json: { write: { isRequired: !0 } } })], Ka.prototype, "position", void 0), u([xe("position")], Ka.prototype, "writePosition", null), u([be("position")], Ka.prototype, "readPosition", null), u([d({ type: Number, nonNullable: !0, json: { write: { isRequired: !0 } } }), mt((e) => Gee.normalize(ks(e)))], Ka.prototype, "heading", void 0), u([d({ type: Number, nonNullable: !0, json: { write: { isRequired: !0 } } }), mt((e) => js(ks(e), -180, 180))], Ka.prototype, "tilt", void 0), u([d({ type: Number, nonNullable: !0, json: { read: !1, write: !1 } })], Ka.prototype, "fov", void 0), Ka = u([T("geoscene.Camera")], Ka);
const Wee = Ka;
var vE;
let pu = vE = class extends se {
  constructor(e) {
    super(e), this.rotation = 0, this.scale = 0, this.targetGeometry = null, this.camera = null;
  }
  castRotation(e) {
    return (e %= 360) < 0 && (e += 360), e;
  }
  clone() {
    return new vE({ rotation: this.rotation, scale: this.scale, targetGeometry: O(this.targetGeometry) ? this.targetGeometry.clone() : null, camera: O(this.camera) ? this.camera.clone() : null });
  }
};
function N2() {
  return { enabled: !this.camera };
}
u([d({ type: Number, json: { write: !0, origins: { "web-map": { default: 0, write: !0 }, "web-scene": { write: { overridePolicy: N2 } } } } })], pu.prototype, "rotation", void 0), u([mt("rotation")], pu.prototype, "castRotation", null), u([d({ type: Number, json: { write: !0, origins: { "web-map": { default: 0, write: !0 }, "web-scene": { write: { overridePolicy: N2 } } } } })], pu.prototype, "scale", void 0), u([d({ types: Tp, json: { read: tc, write: !0, origins: { "web-scene": { read: tc, write: { overridePolicy: N2 } } } } })], pu.prototype, "targetGeometry", void 0), u([d({ type: Wee, json: { write: !0 } })], pu.prototype, "camera", void 0), pu = vE = u([T("geoscene.Viewpoint")], pu);
const ba = pu;
function CRe(e) {
  const t = [];
  return function* () {
    yield* t;
    for (const n of e)
      t.push(n), yield n;
  };
}
function ORe(e, t) {
  for (const n of e)
    if (n != null && t(n))
      return n;
}
function CP(e) {
  return e != null && typeof e[Symbol.iterator] == "function";
}
var Yr;
(function(e) {
  e[e.HANDSHAKE = 0] = "HANDSHAKE", e[e.OPEN = 1] = "OPEN", e[e.OPENED = 2] = "OPENED", e[e.RESPONSE = 3] = "RESPONSE", e[e.INVOKE = 4] = "INVOKE", e[e.ABORT = 5] = "ABORT", e[e.CLOSE = 6] = "CLOSE", e[e.OPEN_PORT = 7] = "OPEN_PORT", e[e.ON = 8] = "ON";
})(Yr || (Yr = {}));
let Hee = 0;
function Cj() {
  return Hee++;
}
function Jee(e) {
  return e && typeof e == "object" && ("result" in e || "transferList" in e);
}
function E1(e) {
  return e ? typeof e == "string" ? JSON.stringify({ name: "message", message: e }) : e.toJSON ? JSON.stringify(e) : JSON.stringify({ name: e.name, message: e.message, details: e.details || { stack: e.stack } }) : null;
}
function Oj(e, t, n, r) {
  if (t.type === Yr.OPEN_PORT)
    return void e.postMessage(t, [t.port]);
  if (t.type !== Yr.INVOKE && t.type !== Yr.RESPONSE)
    return void e.postMessage(t);
  let i;
  Jee(n) ? (i = OP(n.transferList), t.data = n.result) : (i = OP(r), t.data = n), i ? e.postMessage(t, i) : e.postMessage(t);
}
function jg(e) {
  if (!e)
    return null;
  const t = e.data;
  return t ? typeof t == "string" ? JSON.parse(t) : t : null;
}
function OP(e) {
  if (!e || !e.length)
    return null;
  if (K("geoscene-workers-arraybuffer-transfer"))
    return e;
  const t = e.filter((n) => !Zee(n));
  return t.length ? t : null;
}
function Zee(e) {
  return e instanceof ArrayBuffer || e && e.constructor && e.constructor.name === "ArrayBuffer";
}
const Kee = { statsWorker: () => import("./statsWorker-FTYzsq68.js"), geometryEngineWorker: () => import("./geometryEngineWorker-o1sv1reB.js"), CSVSourceWorker: () => import("./CSVSourceWorker-qEE7kRE7.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-a_cF-sID.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-KjCNKtfW.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-Sk_Lb0qK.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-3eapm9Ko.js"), LercWorker: () => import("./LercWorker-WkfkcyCC.js"), MemorySourceWorker: () => import("./MemorySourceWorker-US_GSd6_.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-W3rbfiGJ.js"), Pipeline: () => import("./Pipeline-3bxHnTwl.js"), PointCloudWorker: () => import("./PointCloudWorker-CZ8DBbsB.js"), RasterWorker: () => import("./RasterWorker-qwh0J5ul.js"), SceneLayerWorker: () => import("./SceneLayerWorker-D0EFib2K.js"), WFSSourceWorker: () => import("./WFSSourceWorker-lLUbkDMc.js"), WorkerTileHandler: () => import("./WorkerTileHandler-8wVUs5Fq.js") }, { CLOSE: kP, ABORT: AP, INVOKE: PP, RESPONSE: $m, OPEN_PORT: RP, ON: Yee } = Yr;
let Qee = class {
  constructor(t) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = t, this._timer = null, this._process = this._process.bind(this);
  }
  push(t) {
    t.type === Yr.ABORT ? this._cancelledJobIds.add(t.jobId) : (this._invokeMessages.push(t), this._timer === null && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const t of this._invokeMessages)
      this._cancelledJobIds.has(t.jobId) || this._invoke(t);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
}, ic = class lh {
  constructor(t, n) {
    this._port = t, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new Qee((r) => this._onInvokeMessage(r)), this._client = n.client, this._onMessage = this._onMessage.bind(this), this._channel = n.channel, this._schedule = n.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  static connect(t) {
    const n = new MessageChannel();
    let r;
    r = typeof t == "function" ? new t() : "default" in t && typeof t.default == "function" ? new t.default() : t;
    const i = new lh(n.port1, { channel: n, client: r });
    return typeof r == "object" && "remoteClient" in r && (r.remoteClient = i), lh.clients.set(i, r), n.port2;
  }
  static loadWorker(t) {
    const n = Kee[t];
    return n ? n() : Promise.resolve(null);
  }
  close() {
    this._post({ type: kP }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(t, n, r) {
    const i = r && r.signal, s = r && r.transferList;
    if (!this._port)
      return Promise.reject(new D("worker:port-closed", `Cannot call invoke('${t}'), port is closed`, { methodName: t, data: n }));
    const o = Cj();
    return new Promise((a, l) => {
      const c = G_(i, () => {
        var f;
        const m = this._outJobs.get(o);
        m && (this._outJobs.delete(o), (f = m.abortHandle) == null || f.remove(), this._post({ type: AP, jobId: o }), l(Cn()));
      }), p = { resolve: a, reject: l, abortHandle: c, debugInfo: t };
      this._outJobs.set(o, p), this._post({ type: PP, jobId: o, methodName: t, abortable: i != null }, n, s);
    });
  }
  on(t, n) {
    const r = new MessageChannel();
    function i(s) {
      n(s.data);
    }
    return this._port.postMessage({ type: Yr.ON, eventType: t, port: r.port2 }, [r.port2]), r.port1.addEventListener("message", i), r.port1.start(), { remove() {
      r.port1.postMessage({ type: Yr.CLOSE }), r.port1.close(), r.port1.removeEventListener("message", i);
    } };
  }
  openPort() {
    const t = new MessageChannel();
    return this._post({ type: RP, port: t.port2 }), t.port1;
  }
  _close() {
    this._channel && (this._channel = null), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((t) => {
      var n;
      (n = t.abortHandle) == null || n.remove(), t.reject(Cn(`Worker closing, aborting job calling '${t.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = this._client = this._schedule = null;
  }
  _onMessage(t) {
    O(this._schedule) ? this._schedule(() => this._processMessage(t)) : this._processMessage(t);
  }
  _processMessage(t) {
    const n = jg(t);
    if (n)
      switch (n.type) {
        case $m:
          this._onResponseMessage(n);
          break;
        case PP:
          this._invokeQueue.push(n);
          break;
        case AP:
          this._onAbortMessage(n);
          break;
        case kP:
          this._onCloseMessage();
          break;
        case RP:
          this._onOpenPortMessage(n);
          break;
        case Yee:
          this._onOnMessage(n);
      }
  }
  _onAbortMessage(t) {
    const n = this._inJobs, r = t.jobId, i = n.get(r);
    this._invokeQueue.push(t), i && (i.controller && i.controller.abort(), n.delete(r));
  }
  _onCloseMessage() {
    const t = this._client;
    this._close(), t && "destroy" in t && lh.clients.get(this) === t && t.destroy(), lh.clients.delete(this), t && t.remoteClient && (t.remoteClient = null);
  }
  _onInvokeMessage(t) {
    const { methodName: n, jobId: r, data: i, abortable: s } = t, o = s ? new AbortController() : null, a = this._inJobs;
    let l, c = this._client, p = c[n];
    try {
      if (!p && n && n.indexOf(".") !== -1) {
        const f = n.split(".");
        for (let m = 0; m < f.length - 1; m++)
          c = c[f[m]], p = c[f[m + 1]];
      }
      if (typeof p != "function")
        throw new TypeError(`${n} is not a function`);
      l = p.call(c, i, { client: this, signal: o ? o.signal : null });
    } catch (f) {
      return void this._post({ type: $m, jobId: r, error: E1(f) });
    }
    Fl(l) ? (a.set(r, { controller: o, promise: l }), l.then((f) => {
      a.has(r) && (a.delete(r), this._post({ type: $m, jobId: r }, f));
    }, (f) => {
      a.has(r) && (a.delete(r), Ws(f) || this._post({ type: $m, jobId: r, error: E1(f || { message: `Error encountered at method ${n}` }) }));
    })) : this._post({ type: $m, jobId: r }, l);
  }
  _onOpenPortMessage(t) {
    new lh(t.port, { client: this._client });
  }
  _onOnMessage(t) {
    const { port: n } = t, r = this._client.on(t.eventType, (s) => {
      n.postMessage(s);
    }), i = U_(t.port, "message", (s) => {
      jg(s).type === Yr.CLOSE && (i.remove(), r.remove(), n.close());
    });
  }
  _onResponseMessage(t) {
    var n;
    const { jobId: r, error: i, data: s } = t, o = this._outJobs;
    if (!o.has(r))
      return;
    const a = o.get(r);
    o.delete(r), (n = a.abortHandle) == null || n.remove(), i ? a.reject(D.fromJSON(JSON.parse(i))) : a.resolve(s);
  }
  _post(t, n, r) {
    return Oj(this._port, t, n, r);
  }
};
ic.kernelInfo = { revision: Z8, version: K8, buildDate: J8 }, ic.clients = /* @__PURE__ */ new Map();
const Xee = we.getLogger("geoscene.core.workers.Connection");
let ete = class {
  constructor() {
    this._clients = new Array(), this._clientPromises = new Array(), this._clientIdx = 0;
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(t, n) {
    return new Promise((r, i) => {
      let s = !0;
      const o = (a) => {
        On(n.signal), s && (s = !1, a());
      };
      this._clients.length = t.length, this._clientPromises.length = t.length;
      for (let a = 0; a < t.length; ++a) {
        const l = t[a];
        Fl(l) ? this._clientPromises[a] = l.then((c) => (this._clients[a] = new ic(c, n), o(r), this._clients[a]), () => (o(i), null)) : (this._clients[a] = new ic(l, n), this._clientPromises[a] = Promise.resolve(this._clients[a]), o(r));
      }
    });
  }
  broadcast(t, n, r) {
    const i = new Array(this._clientPromises.length);
    for (let s = 0; s < this._clientPromises.length; ++s) {
      const o = this._clientPromises[s];
      i[s] = o.then((a) => a.invoke(t, n, r));
    }
    return i;
  }
  close() {
    for (const t of this._clientPromises)
      t.then((n) => n.close());
    this._clients.length = 0, this._clientPromises.length = 0;
  }
  getAvailableClient() {
    let t;
    for (let n = 0; n < this._clients.length; ++n) {
      const r = this._clients[n];
      if (r) {
        if (!r.isBusy())
          return Promise.resolve(r);
      } else
        t = t || [], t.push(this._clientPromises[n]);
    }
    return t ? Promise.race(t) : (this._clientIdx = (this._clientIdx + 1) % this._clients.length, Promise.resolve(this._clients[this._clientIdx]));
  }
  invoke(t, n, r) {
    let i = null;
    return Array.isArray(r) ? (Xee.warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), i = { transferList: r }) : i = r, this.closed ? Promise.reject(new Error("Connection closed")) : this.getAvailableClient().then((s) => s.invoke(t, n, i));
  }
  on(t, n) {
    return Promise.all(this._clientPromises).then(() => V_(this._clients.map((r) => r.on(t, n))));
  }
  openPorts() {
    return new Promise((t) => {
      const n = new Array(this._clientPromises.length);
      let r = n.length;
      for (let i = 0; i < this._clientPromises.length; ++i)
        this._clientPromises[i].then((s) => {
          n[i] = s.openPort(), --r == 0 && t(n);
        });
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};
const kj = we.getLogger("geoscene.intl");
function Ya(e, t, n = {}) {
  const { format: r = {} } = n;
  return Ta(e, (i) => tte(i, t, r));
}
function tte(e, t, n) {
  let r, i;
  const s = e.indexOf(":");
  if (s === -1 ? r = e.trim() : (r = e.slice(0, s).trim(), i = e.slice(s + 1).trim()), !r)
    return "";
  const o = jf(r, t);
  if (o == null)
    return "";
  const a = n[i] || n[r];
  return a ? nte(o, a) : i ? rte(o, i) : qO(o);
}
function nte(e, t) {
  switch (t.type) {
    case "date":
      return nc(e, t.intlOptions);
    case "number":
      return op(e, t.intlOptions);
    default:
      return kj.warn("missing format descriptor for key {key}"), qO(e);
  }
}
function rte(e, t) {
  switch (t.toLowerCase()) {
    case "dateformat":
      return nc(e);
    case "numberformat":
      return op(e);
    default:
      return kj.warn(`inline format is unsupported since 4.12: ${t}`), /^(dateformat|datestring)/i.test(t) ? nc(e) : /^numberformat/i.test(t) ? op(e) : qO(e);
  }
}
function qO(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "number":
      return op(e);
    case "boolean":
      return "" + e;
    default:
      return e instanceof Date ? nc(e) : "";
  }
}
async function ite(e, t, n, r) {
  const i = t.exec(n);
  if (!i)
    throw new D("esri-intl:invalid-bundle", `Bundle id "${n}" is not compatible with the pattern "${t}"`);
  const s = i[1] ? `${i[1]}/` : "", o = i[2], a = ZY(r), l = `${s}${o}.json`, c = a ? `${s}${o}_${a}.json` : l;
  let p;
  try {
    p = await LP(e(c));
  } catch (f) {
    if (c === l)
      throw new D("intl:unknown-bundle", `Bundle "${n}" cannot be loaded`, { error: f });
    try {
      p = await LP(e(l));
    } catch (m) {
      throw new D("intl:unknown-bundle", `Bundle "${n}" cannot be loaded`, { error: m });
    }
  }
  return p;
}
async function LP(e) {
  if (O(FP.fetchBundleAsset))
    return FP.fetchBundleAsset(e);
  const t = await rn(e, { responseType: "text" });
  return JSON.parse(t.data);
}
let ste = class {
  constructor({ base: t = "", pattern: n, location: r = new URL(window.location.href) }) {
    let i;
    i = typeof r == "string" ? (s) => new URL(s, new URL(r, window.location.href)).href : r instanceof URL ? (s) => new URL(s, r).href : r, this.pattern = typeof n == "string" ? new RegExp(`^${n}`) : n, this.getAssetUrl = i, t = t ? t.endsWith("/") ? t : t + "/" : "", this.matcher = new RegExp(`^${t}(?:(.*)/)?(.*)$`);
  }
  fetchMessageBundle(t, n) {
    return ite(this.getAssetUrl, this.matcher, t, n);
  }
};
function ote(e) {
  return new ste(e);
}
const FP = {};
JY(ote({ pattern: "geoscene/", location: ma }));
const NP = {};
function ate(e, t) {
  for (const n of e)
    if (n.name === t.name)
      return;
  e.push(t);
}
function lte(e) {
  var t;
  const n = { async: e.async, isDebug: e.isDebug, locale: e.locale, baseUrl: e.baseUrl, has: { ...e.has }, map: { ...e.map }, packages: e.packages && e.packages.concat() || [], paths: { ...e.paths } };
  return e.hasOwnProperty("async") || (n.async = !0), e.hasOwnProperty("isDebug") || (n.isDebug = !1), e.baseUrl || (n.baseUrl = NP.baseUrl), (t = NP.packages) == null || t.forEach((r) => {
    ate(n.packages, r);
  }), n;
}
let ute = class {
  constructor() {
    const t = document.createDocumentFragment();
    ["addEventListener", "dispatchEvent", "removeEventListener"].forEach((n) => {
      this[n] = (...r) => t[n](...r);
    });
  }
}, Kb = class {
  constructor() {
    this._dispatcher = new ute(), this._workerPostMessage({ type: Yr.HANDSHAKE });
  }
  terminate() {
  }
  get onmessage() {
    return this._onmessageHandler;
  }
  set onmessage(t) {
    this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler), this._onmessageHandler = t, t && this.addEventListener("message", t);
  }
  get onmessageerror() {
    return this._onmessageerrorHandler;
  }
  set onmessageerror(t) {
    this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler), this._onmessageerrorHandler = t, t && this.addEventListener("messageerror", t);
  }
  get onerror() {
    return this._onerrorHandler;
  }
  set onerror(t) {
    this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler), this._onerrorHandler = t, t && this.addEventListener("error", t);
  }
  postMessage(t) {
    s1(() => {
      this._workerMessageHandler(new MessageEvent("message", { data: t }));
    });
  }
  dispatchEvent(t) {
    return this._dispatcher.dispatchEvent(t);
  }
  addEventListener(t, n, r) {
    this._dispatcher.addEventListener(t, n, r);
  }
  removeEventListener(t, n, r) {
    this._dispatcher.removeEventListener(t, n, r);
  }
  _workerPostMessage(t) {
    s1(() => {
      this.dispatchEvent(new MessageEvent("message", { data: t }));
    });
  }
  async _workerMessageHandler(t) {
    const n = jg(t);
    if (n && n.type === Yr.OPEN) {
      const { modulePath: r, jobId: i } = n;
      let s = await ic.loadWorker(r);
      s || (s = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        r
      ));
      const o = ic.connect(s);
      this._workerPostMessage({ type: Yr.OPENED, jobId: i, data: o });
    }
  }
};
const bE = we.getLogger("geoscene.core.workers"), { HANDSHAKE: cte } = Yr, dte = 'let globalId=0;const outgoing=new Map,configuration=JSON.parse("{CONFIGURATION}");self.geosceneConfig=configuration.geosceneConfig;const workerPath=self.geosceneConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;return new Promise(((r,i)=>{if(t){if(t.aborted)return i(createAbortError());t.addEventListener("abort",(()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:5,jobId:n}),i(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:i}),self.postMessage({type:4,jobId:n,methodName:e,abortable:null!=t,data:o})}))}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,buildDate:r,version:t}=configuration.kernelInfo,{revision:n,buildDate:i,version:s}=e.kernelInfo;o!==n&&console.warn(`[geoscene.core.workers] Version mismatch detected between GeoScene API for JavaScript and assets:\\nAPI version: ${t} [Date: ${r}, Revision: ${o.slice(0,8)}]\nAssets version: ${s} [Date: ${i}, Revision: ${n.slice(0,8)}]`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case 1:let e;function t(o){const t=e.connect(o);self.postMessage({type:2,jobId:r,data:t},[t])}"function"==typeof define&&define.amd?require([workerPath],(r=>{e=r.default||r,checkWorkerRevision(e),e.loadWorker(o.modulePath).then((e=>e||new Promise((e=>{require([o.modulePath],e)})))).then(t)})):"System"in self&&"function"==typeof System.import?System.import(workerPath).then((r=>(e=r.default,checkWorkerRevision(e),e.loadWorker(o.modulePath)))).then((e=>e||System.import(o.modulePath))).then(t):geosceneConfig.workers.useDynamicImport?import(workerPath).then((r=>{e=r.default||r,checkWorkerRevision(e),e.loadWorker(o.modulePath).then((e=>e||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),e=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(e),e.loadWorker(o.modulePath).then(t));break;case 3:if(outgoing.has(r)){const e=outgoing.get(r);outgoing.delete(r),o.error?e.reject(JSON.parse(o.error)):e.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,geosceneConfig.workers.loaderUrl&&(self.importScripts(geosceneConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});';
let fv, mv;
const DP = "Failed to create Worker. Fallback to execute module in main thread";
async function pte() {
  if (!K("geoscene-workers") || (K("mozilla"), 0))
    return jP(new Kb());
  if (!fv && !mv)
    try {
      const t = dte.replace('"{CONFIGURATION}"', `'${hte()}'`);
      fv = URL.createObjectURL(new Blob([t], { type: "text/javascript" }));
    } catch (t) {
      mv = t || {};
    }
  let e;
  if (fv)
    try {
      e = new Worker(fv, { name: "geoscene-worker-" + fte++ });
    } catch {
      bE.warn(DP, mv), e = new Kb();
    }
  else
    bE.warn(DP, mv), e = new Kb();
  return jP(e);
}
async function jP(e) {
  return new Promise((t) => {
    function n(i) {
      const s = jg(i);
      s && s.type === cte && (e.removeEventListener("message", n), e.removeEventListener("error", r), t(e));
    }
    function r(i) {
      i.preventDefault(), e.removeEventListener("message", n), e.removeEventListener("error", r), bE.warn("Failed to create Worker. Fallback to execute module in main thread", i), (e = new Kb()).addEventListener("message", n), e.addEventListener("error", r);
    }
    e.addEventListener("message", n), e.addEventListener("error", r);
  });
}
function hte() {
  let e;
  if (Pt.default != null) {
    const i = { ...Pt };
    delete i.default, e = JSON.parse(JSON.stringify(i));
  } else
    e = JSON.parse(JSON.stringify(Pt));
  e.assetsPath = To(e.assetsPath), e.request.interceptors = [], e.log.interceptors = [], e.locale = ts(), e.has = { "geoscene-csp-restrictions": K("geoscene-csp-restrictions"), "geoscene-2d-debug": !1, "geoscene-2d-update-debug": K("geoscene-2d-update-debug"), "geoscene-2d-query-centroid-enabled": K("geoscene-2d-query-centroid-enabled"), "featurelayer-pbf": K("featurelayer-pbf"), "featurelayer-simplify-thresholds": K("featurelayer-simplify-thresholds"), "featurelayer-simplify-payload-size-factors": K("featurelayer-simplify-payload-size-factors"), "featurelayer-simplify-mobile-factor": K("featurelayer-simplify-mobile-factor"), "geoscene-atomics": K("geoscene-atomics"), "geoscene-shared-array-buffer": K("geoscene-shared-array-buffer"), "geoscene-tiles-debug": K("geoscene-tiles-debug"), "geoscene-workers-arraybuffer-transfer": K("geoscene-workers-arraybuffer-transfer"), "feature-polyline-generalization-factor": K("feature-polyline-generalization-factor"), "host-webworker": 1 }, e.workers.loaderUrl && (e.workers.loaderUrl = To(e.workers.loaderUrl)), e.workers.workerPath ? e.workers.workerPath = To(e.workers.workerPath) : e.workers.workerPath = To(ma("geoscene/core/workers/RemoteClient.js")), e.workers.useDynamicImport = !1;
  const t = Pt.workers.loaderConfig, n = lte({ baseUrl: t == null ? void 0 : t.baseUrl, locale: ts(), has: { "csp-restrictions": 1, "dojo-test-sniff": 0, "host-webworker": 1, ...t == null ? void 0 : t.has }, map: { ...t == null ? void 0 : t.map }, paths: { ...t == null ? void 0 : t.paths }, packages: (t == null ? void 0 : t.packages) || [] });
  return JSON.stringify({ geosceneConfig: e, loaderConfig: n, kernelInfo: { version: K8, buildDate: J8, revision: Z8 } });
}
let fte = 0;
const mte = we.getLogger("geoscene.core.workers"), { ABORT: VP, INVOKE: yte, OPEN: gte, OPENED: vte, RESPONSE: Tm } = Yr;
let bte = class Aj {
  constructor(t, n) {
    this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this.worker = t, this.id = n, t.addEventListener("message", this._onMessage.bind(this)), t.addEventListener("error", (r) => {
      r.preventDefault(), mte.error(r);
    });
  }
  static async create(t) {
    const n = await pte();
    return new Aj(n, t);
  }
  terminate() {
    this.worker.terminate();
  }
  async open(t, n = {}) {
    const { signal: r } = n, i = Cj();
    return new Promise((s, o) => {
      const a = { resolve: s, reject: o, abortHandle: G_(r, () => {
        this._outJobs.delete(i), this._post({ type: VP, jobId: i });
      }) };
      this._outJobs.set(i, a), this._post({ type: gte, jobId: i, modulePath: t });
    });
  }
  _onMessage(t) {
    const n = jg(t);
    if (n)
      switch (n.type) {
        case vte:
          this._onOpenedMessage(n);
          break;
        case Tm:
          this._onResponseMessage(n);
          break;
        case VP:
          this._onAbortMessage(n);
          break;
        case yte:
          this._onInvokeMessage(n);
      }
  }
  _onAbortMessage(t) {
    const n = this._inJobs, r = t.jobId, i = n.get(r);
    i && (i.controller && i.controller.abort(), n.delete(r));
  }
  _onInvokeMessage(t) {
    const { methodName: n, jobId: r, data: i, abortable: s } = t, o = s ? new AbortController() : null, a = this._inJobs, l = XK[n];
    let c;
    try {
      if (typeof l != "function")
        throw new TypeError(`${n} is not a function`);
      c = l.call(null, i, { signal: o ? o.signal : null });
    } catch (p) {
      return void this._post({ type: Tm, jobId: r, error: E1(p) });
    }
    Fl(c) ? (a.set(r, { controller: o, promise: c }), c.then((p) => {
      a.has(r) && (a.delete(r), this._post({ type: Tm, jobId: r }, p));
    }, (p) => {
      a.has(r) && (a.delete(r), p || (p = { message: "Error encountered at method" + n }), Ws(p) || this._post({ type: Tm, jobId: r, error: E1(p || { message: `Error encountered at method ${n}` }) }));
    })) : this._post({ type: Tm, jobId: r }, c);
  }
  _onOpenedMessage(t) {
    var n;
    const { jobId: r, data: i } = t, s = this._outJobs.get(r);
    s && (this._outJobs.delete(r), (n = s.abortHandle) == null || n.remove(), s.resolve(i));
  }
  _onResponseMessage(t) {
    var n;
    const { jobId: r, error: i, data: s } = t, o = this._outJobs.get(r);
    o && (this._outJobs.delete(r), (n = o.abortHandle) == null || n.remove(), i ? o.reject(D.fromJSON(JSON.parse(i))) : o.resolve(s));
  }
  _post(t, n, r) {
    return Oj(this.worker, t, n, r);
  }
}, Td = K("geoscene-workers-debug") ? 1 : K("host-browser") ? navigator.hardwareConcurrency - 1 : 0;
Td || (Td = K("safari") && K("mac") || K("trident") ? 7 : 2);
let zP = 0;
const Yb = [];
function wte() {
  Pj();
}
async function yv(e, t) {
  const n = new ete();
  return await n.open(e, t), n;
}
async function _te(e, t = {}) {
  if (typeof e != "string")
    throw new D("workers:undefined-module", "modulePath is missing");
  let n = t.strategy || "distributed";
  if (K("host-webworker") && !K("geoscene-workers") && (n = "local"), n === "local") {
    let r = await ic.loadWorker(e);
    r || (r = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e
    )), On(t.signal);
    const i = t.client || r;
    return yv([ic.connect(r)], { ...t, client: i });
  }
  if (await Pj(), On(t.signal), n === "dedicated") {
    const r = zP++ % Td;
    return yv([await Yb[r].open(e, t)], t);
  }
  if (t.maxNumWorkers && t.maxNumWorkers > 0) {
    const r = Math.min(t.maxNumWorkers, Td);
    if (r < Td) {
      const i = new Array(r);
      for (let s = 0; s < r; ++s) {
        const o = zP++ % Td;
        i[s] = Yb[o].open(e, t);
      }
      return yv(i, t);
    }
  }
  return yv(Yb.map((r) => r.open(e, t)), t);
}
let gv = null;
async function Pj() {
  if (gv)
    return gv;
  new AbortController();
  const e = [];
  for (let t = 0; t < Td; t++) {
    const n = bte.create(t).then((r) => (Yb[t] = r, r));
    e.push(n);
  }
  return gv = Promise.all(e), gv;
}
function GO(e) {
  return new Qe({ wkt: `GEOCCS["Spherical geocentric",
    DATUM["Not specified",
      SPHEROID["Sphere",${e.radius},0]],
    PRIMEM["Greenwich",0.0,
      AUTHORITY["EPSG","8901"]],
    UNIT["m",1.0],
    AXIS["Geocentric X",OTHER],
    AXIS["Geocentric Y",EAST],
    AXIS["Geocentric Z",NORTH]
  ]` });
}
const Rj = GO(Kt), I1 = GO(Tl), M1 = GO(ec), Ste = new Qe({ wkt: `GEOCCS["WGS 84",
  DATUM["WGS_1984",
    SPHEROID["WGS 84",${Kt.radius},298.257223563,
      AUTHORITY["EPSG","7030"]],
    AUTHORITY["EPSG","6326"]],
  PRIMEM["Greenwich",0,
    AUTHORITY["EPSG","8901"]],
  UNIT["m",1.0,
    AUTHORITY["EPSG","9001"]],
  AXIS["Geocentric X",OTHER],
  AXIS["Geocentric Y",OTHER],
  AXIS["Geocentric Z",NORTH],
  AUTHORITY["EPSG","4978"]
]` });
function FRe(e) {
  return e && (X_(e) || e === I1) ? I1 : e && (eS(e) || e === M1) ? M1 : Rj;
}
function xte(e) {
  return e && (X_(e) || e === I1) ? Tl : e && (eS(e) || e === M1) ? ec : Kt;
}
function NRe(e) {
  return sO(e) ? Tl : oO(e) ? ec : Kt;
}
const DRe = 39.37, $te = Kt.radius * Math.PI / 200, Lj = /UNIT\[([^\]]+)\]\]$/i, qd = x, Fj = /UNIT\[([^\]]+)\]/i, Tte = /* @__PURE__ */ new Set([4261, 4305, 4807, 4810, 4811, 4812, 4816, 4819, 4821, 4901, 4902, 37225, 104139, 104140]), Ete = $r()({ meter: "meters", foot: "feet", foot_us: "us-feet", foot_clarke: "clarke-feet", yard_clarke: "clarke-yards", link_clarke: "clarke-links", yard_sears: "sears-yards", foot_sears: "sears-feet", chain_sears: "sears-chains", chain_benoit_1895_b: "benoit-1895-b-chains", yard_indian: "indian-yards", yard_indian_1937: "indian-1937-yards", foot_gold_coast: "gold-coast-feet", chain_sears_1922_truncated: "sears-1922-truncated-chains", "50_kilometers": "50-kilometers", "150_kilometers": "150-kilometers" }), qo = (e) => e * e, Gl = (e) => e * e * e, Vg = { length: { baseUnit: "meters", units: { millimeters: { inBaseUnits: 1e-3 }, centimeters: { inBaseUnits: 0.01 }, decimeters: { inBaseUnits: 0.1 }, meters: { inBaseUnits: 1 }, kilometers: { inBaseUnits: 1e3 }, inches: { inBaseUnits: 0.0254 }, feet: { inBaseUnits: 0.3048 }, yards: { inBaseUnits: 0.9144 }, miles: { inBaseUnits: 1609.344 }, "nautical-miles": { inBaseUnits: 1852 }, "us-feet": { inBaseUnits: 1200 / 3937 } } }, area: { baseUnit: "square-meters", units: { "square-millimeters": { inBaseUnits: qo(1e-3) }, "square-centimeters": { inBaseUnits: qo(0.01) }, "square-decimeters": { inBaseUnits: qo(0.1) }, "square-meters": { inBaseUnits: 1 }, "square-kilometers": { inBaseUnits: qo(1e3) }, "square-inches": { inBaseUnits: qo(0.0254) }, "square-feet": { inBaseUnits: qo(0.3048) }, "square-yards": { inBaseUnits: qo(0.9144) }, "square-miles": { inBaseUnits: qo(1609.344) }, "square-us-feet": { inBaseUnits: qo(1200 / 3937) }, acres: { inBaseUnits: 15625e-7 * qo(1609.344) }, ares: { inBaseUnits: 100 }, hectares: { inBaseUnits: 1e4 } } }, volume: { baseUnit: "liters", units: { liters: { inBaseUnits: 1 }, "cubic-millimeters": { inBaseUnits: 1e3 * Gl(1e-3) }, "cubic-centimeters": { inBaseUnits: 1e3 * Gl(0.01) }, "cubic-decimeters": { inBaseUnits: 1e3 * Gl(0.1) }, "cubic-meters": { inBaseUnits: 1e3 }, "cubic-kilometers": { inBaseUnits: 1e3 * Gl(1e3) }, "cubic-inches": { inBaseUnits: 1e3 * Gl(0.0254) }, "cubic-feet": { inBaseUnits: 1e3 * Gl(0.3048) }, "cubic-yards": { inBaseUnits: 1e3 * Gl(0.9144) }, "cubic-miles": { inBaseUnits: 1e3 * Gl(1609.344) } } }, angle: { baseUnit: "radians", units: { radians: { inBaseUnits: 1 }, degrees: { inBaseUnits: Math.PI / 180 } } } }, Ite = function() {
  const e = {};
  for (const t in Vg)
    for (const n in Vg[t].units)
      e[n] = t;
  return e;
}();
function Mte(e, t, n) {
  return e * Vg[n].units[t].inBaseUnits;
}
function Cte(e, t, n) {
  return e / Vg[n].units[t].inBaseUnits;
}
function wE(e) {
  const t = Ite[e];
  if (t)
    return t;
  throw new Error("unknown type");
}
function BP(e, t = null) {
  return t = t || wE(e), Vg[t].baseUnit === e;
}
function xs(e, t, n) {
  if (t === n)
    return e;
  const r = wE(t);
  if (r !== wE(n))
    throw new Error("incompatible units");
  const i = BP(t, r) ? e : Mte(e, t, r);
  return BP(n, r) ? i : Cte(i, n, r);
}
function Ote(e, t, n) {
  return xs(e, t, "meters") / (n * Math.PI / 180);
}
function Nj(e) {
  return Ete.fromJSON(e.toLowerCase()) || null;
}
function bf(e) {
  if (e && typeof e == "object" && !HK(e))
    return 1;
  const t = E0(e);
  return t > 1e5 ? 1 : t;
}
function kte(e) {
  return E0(e) >= (e instanceof Qe ? xte(e).metersPerDegree : 1e5) ? "meters" : Pte(e);
}
function E0(e, t = Kt.metersPerDegree) {
  return Ate(e, !0) || t;
}
function Ate(e, t = !1) {
  let n, r, i = null;
  if (e != null && (typeof e == "object" ? (n = e.wkid, r = e.wkt) : typeof e == "number" ? n = e : typeof e == "string" && (r = e)), n) {
    if (sO(n))
      return Tl.metersPerDegree;
    if (oO(n))
      return ec.metersPerDegree;
    i = qd.values[qd[n]], !i && t && Tte.has(n) && (i = $te);
  } else
    r && (Vj(r) ? i = UP(Lj.exec(r), i) : jj(r) && (i = UP(Fj.exec(r), i)));
  return i;
}
function UP(e, t) {
  return e && e[1] ? Dj(e[1]) : t;
}
function Dj(e) {
  return parseFloat(e.split(",")[1]);
}
function Pte(e) {
  let t, n, r = null;
  if (e != null && (typeof e == "object" ? (t = e.wkid, n = e.wkt) : typeof e == "number" ? t = e : typeof e == "string" && (n = e)), t)
    r = qd.units[qd[t]];
  else if (n) {
    const i = Vj(n) ? Lj : jj(n) ? Fj : null;
    if (i) {
      const s = i.exec(n);
      s && s[1] && (r = Lte(s[1]));
    }
  }
  return O(r) ? Nj(r) : null;
}
function jj(e) {
  return /^GEOCCS/i.test(e);
}
function Vj(e) {
  return /^PROJCS/i.test(e);
}
const Rte = 1e-7;
function Lte(e) {
  const t = /[\\"\\']{1}([^\\"\\']+)/.exec(e);
  let n = t && t[1];
  if (!n || qd.units.indexOf(n) === -1) {
    const r = Dj(e);
    n = null;
    const i = qd.values;
    for (let s = 0; s < i.length; ++s)
      if (Math.abs(r - i[s]) < Rte) {
        n = qd.units[s];
        break;
      }
  }
  return n;
}
const zj = { esriAcres: "acres", esriAres: "ares", esriHectares: "hectares", esriSquareCentimeters: "square-centimeters", esriSquareDecimeters: "square-decimeters", esriSquareFeet: "square-feet", esriSquareInches: "square-inches", esriSquareKilometers: "square-kilometers", esriSquareMeters: "square-meters", esriSquareMiles: "square-miles", esriSquareMillimeters: "square-millimeters", esriSquareUsFeet: "square-us-feet", esriSquareYards: "square-yards" }, Bj = { esriCentimeters: "centimeters", esriDecimeters: "decimeters", esriFeet: "feet", esriInches: "inches", esriKilometers: "kilometers", esriMeters: "meters", esriMiles: "miles", esriMillimeters: "millimeters", esriNauticalMiles: "nautical-miles", esriYards: "yards" }, Fte = $r()(zj), Nte = $r()(Bj);
$r()({ ...zj, ...Bj });
function Cp(e, t, n, r, i, s, o, a, l, c, p, f, m, y, g, v, w) {
  return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = s, e[5] = o, e[6] = a, e[7] = l, e[8] = c, e[9] = p, e[10] = f, e[11] = m, e[12] = y, e[13] = g, e[14] = v, e[15] = w, e;
}
function Dte(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function gc(e, t) {
  if (e === t) {
    const n = t[1], r = t[2], i = t[3], s = t[6], o = t[7], a = t[11];
    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = r, e[9] = s, e[11] = t[14], e[12] = i, e[13] = o, e[14] = a;
  } else
    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
  return e;
}
function jRe(e, t) {
  const n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], p = t[8], f = t[9], m = t[10], y = t[11], g = t[12], v = t[13], w = t[14], b = t[15], S = n * a - r * o, $ = n * l - i * o, I = n * c - s * o, M = r * l - i * a, E = r * c - s * a, C = i * c - s * l, A = p * v - f * g, W = p * w - m * g, j = p * b - y * g, G = f * w - m * v, R = f * b - y * v, V = m * b - y * w;
  let Q = S * V - $ * R + I * G + M * j - E * W + C * A;
  return Q ? (Q = 1 / Q, e[0] = (a * V - l * R + c * G) * Q, e[1] = (i * R - r * V - s * G) * Q, e[2] = (v * C - w * E + b * M) * Q, e[3] = (m * E - f * C - y * M) * Q, e[4] = (l * j - o * V - c * W) * Q, e[5] = (n * V - i * j + s * W) * Q, e[6] = (w * I - g * C - b * $) * Q, e[7] = (p * C - m * I + y * $) * Q, e[8] = (o * R - a * j + c * A) * Q, e[9] = (r * j - n * R - s * A) * Q, e[10] = (g * E - v * I + b * S) * Q, e[11] = (f * I - p * E - y * S) * Q, e[12] = (a * W - o * G - l * A) * Q, e[13] = (n * G - r * W + i * A) * Q, e[14] = (v * $ - g * M - w * S) * Q, e[15] = (p * M - f * $ + m * S) * Q, e) : null;
}
function VRe(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], p = t[7], f = t[8], m = t[9], y = t[10], g = t[11], v = t[12], w = t[13], b = t[14], S = t[15];
  let $ = n[0], I = n[1], M = n[2], E = n[3];
  return e[0] = $ * r + I * a + M * f + E * v, e[1] = $ * i + I * l + M * m + E * w, e[2] = $ * s + I * c + M * y + E * b, e[3] = $ * o + I * p + M * g + E * S, $ = n[4], I = n[5], M = n[6], E = n[7], e[4] = $ * r + I * a + M * f + E * v, e[5] = $ * i + I * l + M * m + E * w, e[6] = $ * s + I * c + M * y + E * b, e[7] = $ * o + I * p + M * g + E * S, $ = n[8], I = n[9], M = n[10], E = n[11], e[8] = $ * r + I * a + M * f + E * v, e[9] = $ * i + I * l + M * m + E * w, e[10] = $ * s + I * c + M * y + E * b, e[11] = $ * o + I * p + M * g + E * S, $ = n[12], I = n[13], M = n[14], E = n[15], e[12] = $ * r + I * a + M * f + E * v, e[13] = $ * i + I * l + M * m + E * w, e[14] = $ * s + I * c + M * y + E * b, e[15] = $ * o + I * p + M * g + E * S, e;
}
function zRe(e, t, n) {
  const r = n[0], i = n[1], s = n[2];
  let o, a, l, c, p, f, m, y, g, v, w, b;
  return t === e ? (e[12] = t[0] * r + t[4] * i + t[8] * s + t[12], e[13] = t[1] * r + t[5] * i + t[9] * s + t[13], e[14] = t[2] * r + t[6] * i + t[10] * s + t[14], e[15] = t[3] * r + t[7] * i + t[11] * s + t[15]) : (o = t[0], a = t[1], l = t[2], c = t[3], p = t[4], f = t[5], m = t[6], y = t[7], g = t[8], v = t[9], w = t[10], b = t[11], e[0] = o, e[1] = a, e[2] = l, e[3] = c, e[4] = p, e[5] = f, e[6] = m, e[7] = y, e[8] = g, e[9] = v, e[10] = w, e[11] = b, e[12] = o * r + p * i + g * s + t[12], e[13] = a * r + f * i + v * s + t[13], e[14] = l * r + m * i + w * s + t[14], e[15] = c * r + y * i + b * s + t[15]), e;
}
function BRe(e, t, n) {
  const r = n[0], i = n[1], s = n[2];
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
}
function URe(e, t, n, r) {
  let i, s, o, a, l, c, p, f, m, y, g, v, w, b, S, $, I, M, E, C, A, W, j, G, R = r[0], V = r[1], Q = r[2], de = Math.sqrt(R * R + V * V + Q * Q);
  return de < Dn ? null : (de = 1 / de, R *= de, V *= de, Q *= de, i = Math.sin(n), s = Math.cos(n), o = 1 - s, a = t[0], l = t[1], c = t[2], p = t[3], f = t[4], m = t[5], y = t[6], g = t[7], v = t[8], w = t[9], b = t[10], S = t[11], $ = R * R * o + s, I = V * R * o + Q * i, M = Q * R * o - V * i, E = R * V * o - Q * i, C = V * V * o + s, A = Q * V * o + R * i, W = R * Q * o + V * i, j = V * Q * o - R * i, G = Q * Q * o + s, e[0] = a * $ + f * I + v * M, e[1] = l * $ + m * I + w * M, e[2] = c * $ + y * I + b * M, e[3] = p * $ + g * I + S * M, e[4] = a * E + f * C + v * A, e[5] = l * E + m * C + w * A, e[6] = c * E + y * C + b * A, e[7] = p * E + g * C + S * A, e[8] = a * W + f * j + v * G, e[9] = l * W + m * j + w * G, e[10] = c * W + y * j + b * G, e[11] = p * W + g * j + S * G, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);
}
function jte(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;
}
function qRe(e, t) {
  return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function GRe(e, t, n) {
  let r, i, s, o = n[0], a = n[1], l = n[2], c = Math.sqrt(o * o + a * a + l * l);
  return c < Dn ? null : (c = 1 / c, o *= c, a *= c, l *= c, r = Math.sin(t), i = Math.cos(t), s = 1 - i, e[0] = o * o * s + i, e[1] = a * o * s + l * r, e[2] = l * o * s - a * r, e[3] = 0, e[4] = o * a * s - l * r, e[5] = a * a * s + i, e[6] = l * a * s + o * r, e[7] = 0, e[8] = o * l * s + a * r, e[9] = a * l * s - o * r, e[10] = l * l * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);
}
function WRe(e, t) {
  const n = Math.sin(t), r = Math.cos(t);
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = n, e[7] = 0, e[8] = 0, e[9] = -n, e[10] = r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function HRe(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
}
function JRe(e, t) {
  if (e === t)
    return !0;
  const n = e[0], r = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], p = e[8], f = e[9], m = e[10], y = e[11], g = e[12], v = e[13], w = e[14], b = e[15], S = t[0], $ = t[1], I = t[2], M = t[3], E = t[4], C = t[5], A = t[6], W = t[7], j = t[8], G = t[9], R = t[10], V = t[11], Q = t[12], de = t[13], _e = t[14], ie = t[15];
  return Math.abs(n - S) <= Dn * Math.max(1, Math.abs(n), Math.abs(S)) && Math.abs(r - $) <= Dn * Math.max(1, Math.abs(r), Math.abs($)) && Math.abs(i - I) <= Dn * Math.max(1, Math.abs(i), Math.abs(I)) && Math.abs(s - M) <= Dn * Math.max(1, Math.abs(s), Math.abs(M)) && Math.abs(o - E) <= Dn * Math.max(1, Math.abs(o), Math.abs(E)) && Math.abs(a - C) <= Dn * Math.max(1, Math.abs(a), Math.abs(C)) && Math.abs(l - A) <= Dn * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(c - W) <= Dn * Math.max(1, Math.abs(c), Math.abs(W)) && Math.abs(p - j) <= Dn * Math.max(1, Math.abs(p), Math.abs(j)) && Math.abs(f - G) <= Dn * Math.max(1, Math.abs(f), Math.abs(G)) && Math.abs(m - R) <= Dn * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(y - V) <= Dn * Math.max(1, Math.abs(y), Math.abs(V)) && Math.abs(g - Q) <= Dn * Math.max(1, Math.abs(g), Math.abs(Q)) && Math.abs(v - de) <= Dn * Math.max(1, Math.abs(v), Math.abs(de)) && Math.abs(w - _e) <= Dn * Math.max(1, Math.abs(w), Math.abs(_e)) && Math.abs(b - ie) <= Dn * Math.max(1, Math.abs(b), Math.abs(ie));
}
function ZRe(e) {
  const t = Dn, n = e[0], r = e[1], i = e[2], s = e[4], o = e[5], a = e[6], l = e[8], c = e[9], p = e[10];
  return Math.abs(1 - (n * n + s * s + l * l)) <= t && Math.abs(1 - (r * r + o * o + c * c)) <= t && Math.abs(1 - (i * i + a * a + p * p)) <= t;
}
let D2, N = null;
function Uj() {
  return !!N;
}
function Vte() {
  return !!K("geoscene-wasm");
}
function qj() {
  return D2 || (D2 = import("./pe-wasm-_8VrZRYk.js").then((e) => e.p).then(({ default: e }) => e({ locateFile: (t) => ma(`geoscene/geometry/support/${t}`) })).then((e) => {
    Wj(e);
  }), D2);
}
var _E, tn, SE;
(function(e) {
  function t(s, o, a) {
    N.ensureCache.prepare();
    const l = wd(a), c = a === l, p = N.ensureFloat64(l), f = N._pe_geog_to_proj(N.getPointer(s), o, p);
    return f && Du(a, o, p, c), f;
  }
  function n(s, o, a, l) {
    switch (l) {
      case tn.PE_TRANSFORM_P_TO_G:
        return r(s, o, a);
      case tn.PE_TRANSFORM_G_TO_P:
        return t(s, o, a);
    }
    return 0;
  }
  function r(s, o, a) {
    return i(s, o, a, 0);
  }
  function i(s, o, a, l) {
    N.ensureCache.prepare();
    const c = wd(a), p = a === c, f = N.ensureFloat64(c), m = N._pe_proj_to_geog_center(N.getPointer(s), o, f, l);
    return m && Du(a, o, f, p), m;
  }
  e.geogToProj = t, e.projGeog = n, e.projToGeog = r, e.projToGeogCenter = i;
})(_E || (_E = {})), function(e) {
  function t() {
    e.PE_BUFFER_MAX = N.PeDefs.prototype.PE_BUFFER_MAX, e.PE_NAME_MAX = N.PeDefs.prototype.PE_NAME_MAX, e.PE_MGRS_MAX = N.PeDefs.prototype.PE_MGRS_MAX, e.PE_USNG_MAX = N.PeDefs.prototype.PE_USNG_MAX, e.PE_DD_MAX = N.PeDefs.prototype.PE_DD_MAX, e.PE_DDM_MAX = N.PeDefs.prototype.PE_DDM_MAX, e.PE_DMS_MAX = N.PeDefs.prototype.PE_DMS_MAX, e.PE_UTM_MAX = N.PeDefs.prototype.PE_UTM_MAX, e.PE_PARM_MAX = N.PeDefs.prototype.PE_PARM_MAX, e.PE_TYPE_NONE = N.PeDefs.prototype.PE_TYPE_NONE, e.PE_TYPE_GEOGCS = N.PeDefs.prototype.PE_TYPE_GEOGCS, e.PE_TYPE_PROJCS = N.PeDefs.prototype.PE_TYPE_PROJCS, e.PE_TYPE_GEOGTRAN = N.PeDefs.prototype.PE_TYPE_GEOGTRAN, e.PE_TYPE_COORDSYS = N.PeDefs.prototype.PE_TYPE_COORDSYS, e.PE_TYPE_UNIT = N.PeDefs.prototype.PE_TYPE_UNIT, e.PE_TYPE_LINUNIT = N.PeDefs.prototype.PE_TYPE_LINUNIT, e.PE_STR_OPTS_NONE = N.PeDefs.prototype.PE_STR_OPTS_NONE, e.PE_STR_AUTH_NONE = N.PeDefs.prototype.PE_STR_AUTH_NONE, e.PE_STR_AUTH_TOP = N.PeDefs.prototype.PE_STR_AUTH_TOP, e.PE_STR_NAME_CANON = N.PeDefs.prototype.PE_STR_NAME_CANON, e.PE_PARM_X0 = N.PeDefs.prototype.PE_PARM_X0, e.PE_PARM_ND = N.PeDefs.prototype.PE_PARM_ND, e.PE_TRANSFORM_1_TO_2 = N.PeDefs.prototype.PE_TRANSFORM_1_TO_2, e.PE_TRANSFORM_2_TO_1 = N.PeDefs.prototype.PE_TRANSFORM_2_TO_1, e.PE_TRANSFORM_P_TO_G = N.PeDefs.prototype.PE_TRANSFORM_P_TO_G, e.PE_TRANSFORM_G_TO_P = N.PeDefs.prototype.PE_TRANSFORM_G_TO_P, e.PE_HORIZON_RECT = N.PeDefs.prototype.PE_HORIZON_RECT, e.PE_HORIZON_POLY = N.PeDefs.prototype.PE_HORIZON_POLY, e.PE_HORIZON_LINE = N.PeDefs.prototype.PE_HORIZON_LINE, e.PE_HORIZON_DELTA = N.PeDefs.prototype.PE_HORIZON_DELTA;
  }
  e.init = t;
}(tn || (tn = {})), function(e) {
  const t = {}, n = {}, r = (y) => {
    if (y) {
      const g = y.getType();
      switch (g) {
        case tn.PE_TYPE_GEOGCS:
          y = N.castObject(y, N.PeGeogcs);
          break;
        case tn.PE_TYPE_PROJCS:
          y = N.castObject(y, N.PeProjcs);
          break;
        case tn.PE_TYPE_GEOGTRAN:
          y = N.castObject(y, N.PeGeogtran);
          break;
        default:
          g & tn.PE_TYPE_UNIT && (y = N.castObject(y, N.PeUnit));
      }
    }
    return y;
  };
  function i() {
    N.PeFactory.prototype.initialize(null);
  }
  function s(y) {
    return o(tn.PE_TYPE_COORDSYS, y);
  }
  function o(y, g) {
    let v = null, w = t[y];
    if (w || (w = {}, t[y] = w), w.hasOwnProperty(String(g)))
      v = w[g];
    else {
      const b = N.PeFactory.prototype.factoryByType(y, g);
      N.compare(b, N.NULL) || (v = b, w[g] = v);
    }
    return v = r(v), v;
  }
  function a(y, g) {
    let v = null, w = n[y];
    if (w || (w = {}, n[y] = w), w.hasOwnProperty(g))
      v = w[g];
    else {
      const b = N.PeFactory.prototype.fromString(y, g);
      N.compare(b, N.NULL) || (v = b, w[g] = v);
    }
    return v = r(v), v;
  }
  function l(y) {
    return o(tn.PE_TYPE_GEOGCS, y);
  }
  function c(y) {
    return o(tn.PE_TYPE_GEOGTRAN, y);
  }
  function p(y) {
    return N.PeFactory.prototype.getCode(y);
  }
  function f(y) {
    return o(tn.PE_TYPE_PROJCS, y);
  }
  function m(y) {
    return o(tn.PE_TYPE_UNIT, y);
  }
  e.initialize = i, e.coordsys = s, e.factoryByType = o, e.fromString = a, e.geogcs = l, e.geogtran = c, e.getCode = p, e.projcs = f, e.unit = m;
}(SE || (SE = {}));
let Gj = null;
var C1, xE, $E, TE, O1, EE, k1, A1, IE;
function Wj(e) {
  function t(s, o, a) {
    s[o] = a(s[o]);
  }
  N = e, tn.init(), C1.init(), O1.init(), k1.init(), A1.init(), Gj = class extends N.PeGCSExtent {
    destroy() {
      N.destroy(this);
    }
  };
  const n = [N.PeDatum, N.PeGeogcs, N.PeGeogtran, N.PeObject, N.PeParameter, N.PePrimem, N.PeProjcs, N.PeSpheroid, N.PeUnit];
  for (const s of n)
    t(s.prototype, "getName", (o) => function() {
      return o.call(this, new Array(tn.PE_NAME_MAX));
    });
  for (const s of [N.PeGeogtran, N.PeProjcs])
    t(s.prototype, "getParameters", (o) => function() {
      const a = new Array(tn.PE_PARM_MAX);
      let l = o.call(this);
      for (let c = 0; c < a.length; c++) {
        const p = N.getValue(l, "*");
        a[c] = p ? N.wrapPointer(p, N.PeParameter) : null, l += Int32Array.BYTES_PER_ELEMENT;
      }
      return a;
    });
  t(N.PeHorizon.prototype, "getCoord", (s) => function() {
    const o = this.getSize();
    if (!o)
      return null;
    const a = [];
    return Du(a, o, s.call(this)), a;
  }), t(N.PeGTlistExtendedEntry.prototype, "getEntries", (s) => {
    const o = N._pe_getPeGTlistExtendedGTsSize();
    return function() {
      let a = null;
      const l = s.call(this);
      if (!N.compare(l, N.NULL)) {
        a = [l];
        const c = this.getSteps();
        if (c > 1) {
          const p = N.getPointer(l);
          for (let f = 1; f < c; f++)
            a.push(N.wrapPointer(p + o * f, N.PeGTlistExtendedGTs));
        }
      }
      return a;
    };
  });
  const r = N._pe_getPeHorizonSize(), i = (s) => function() {
    let o = this._cache;
    if (o || (o = /* @__PURE__ */ new Map(), this._cache = o), o.has(s))
      return o.get(s);
    let a = null;
    const l = s.call(this);
    if (!N.compare(l, N.NULL)) {
      a = [l];
      const c = l.getNump();
      if (c > 1) {
        const p = N.getPointer(l);
        for (let f = 1; f < c; f++)
          a.push(N.wrapPointer(p + r * f, N.PeHorizon));
      }
    }
    return o.set(s, a), a;
  };
  t(N.PeProjcs.prototype, "horizonGcsGenerate", i), t(N.PeProjcs.prototype, "horizonPcsGenerate", i), N.PeObject.prototype.toString = function(s = tn.PE_STR_OPTS_NONE) {
    N.ensureCache.prepare();
    const o = N.getPointer(this), a = N.ensureInt8(new Array(tn.PE_BUFFER_MAX));
    return N.UTF8ToString(N._pe_object_to_string_ext(o, s, a));
  };
}
function Da(e) {
  if (!e)
    return;
  const t = N.getClass(e);
  if (!t)
    return;
  const n = N.getCache(t);
  if (!n)
    return;
  const r = N.getPointer(e);
  r && delete n[r];
}
function vv(e, t) {
  const n = [], r = new Array(t);
  for (let i = 0; i < e; i++)
    n.push(N.ensureInt8(r));
  return n;
}
function wd(e) {
  let t;
  return Array.isArray(e[0]) ? (t = [], e.forEach((n) => {
    t.push(n[0], n[1]);
  })) : t = e, t;
}
function Du(e, t, n, r = !1) {
  if (r)
    for (let i = 0; i < 2 * t; i++)
      e[i] = N.getValue(n + i * Float64Array.BYTES_PER_ELEMENT, "double");
  else {
    const i = e.length === 0;
    for (let s = 0; s < t; s++)
      i && (e[s] = new Array(2)), e[s][0] = N.getValue(n, "double"), e[s][1] = N.getValue(n + Float64Array.BYTES_PER_ELEMENT, "double"), n += 2 * Float64Array.BYTES_PER_ELEMENT;
  }
}
(function(e) {
  let t;
  function n() {
    e.PE_GTLIST_OPTS_COMMON = N.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON, t = N._pe_getPeGTlistExtendedEntrySize();
  }
  function r(i, s, o, a, l, c) {
    let p = null;
    const f = new N.PeInteger(c);
    try {
      const m = N.PeGTlistExtended.prototype.getGTlist(i, s, o, a, l, f);
      if ((c = f.val) && (p = [m], c > 1)) {
        const y = N.getPointer(m);
        for (let g = 1; g < c; g++)
          p.push(N.wrapPointer(y + t * g, N.PeGTlistExtendedEntry));
      }
    } finally {
      N.destroy(f);
    }
    return p;
  }
  e.init = n, e.getGTlist = r;
})(C1 || (C1 = {})), function(e) {
  function t(n) {
    if (n && n.length) {
      for (const r of n)
        Da(r), r.getEntries().forEach((i) => {
          Da(i);
          const s = i.getGeogtran();
          Da(s), s.getParameters().forEach(Da), [s.getGeogcs1(), s.getGeogcs2()].forEach((o) => {
            Da(o);
            const a = o.getDatum();
            Da(a), Da(a.getSpheroid()), Da(o.getPrimem()), Da(o.getUnit());
          });
        });
      N.PeGTlistExtendedEntry.prototype.Delete(n[0]);
    }
  }
  e.destroy = t;
}(xE || (xE = {})), function(e) {
  function t(n, r, i, s, o) {
    N.ensureCache.prepare();
    const a = wd(i), l = i === a, c = N.ensureFloat64(a);
    let p = 0;
    s && (p = N.ensureFloat64(s));
    const f = N._pe_geog_to_geog(N.getPointer(n), r, c, p, o);
    return f && Du(i, r, c, l), f;
  }
  e.geogToGeog = t;
}($E || ($E = {})), function(e) {
  const t = (c, p, f, m, y, g) => {
    let v, w;
    switch (N.ensureCache.prepare(), c) {
      case "dd":
        v = N._pe_geog_to_dd, w = tn.PE_DD_MAX;
        break;
      case "ddm":
        v = N._pe_geog_to_ddm, w = tn.PE_DDM_MAX;
        break;
      case "dms":
        v = N._pe_geog_to_dms, w = tn.PE_DMS_MAX;
    }
    let b = 0;
    p && (b = N.getPointer(p));
    const S = wd(m), $ = N.ensureFloat64(S), I = vv(f, w), M = v(b, f, $, y, N.ensureInt32(I));
    if (M)
      for (let E = 0; E < f; E++)
        g[E] = N.UTF8ToString(I[E]);
    return M;
  }, n = (c, p, f, m, y) => {
    let g;
    switch (N.ensureCache.prepare(), c) {
      case "dd":
        g = N._pe_dd_to_geog;
        break;
      case "ddm":
        g = N._pe_ddm_to_geog;
        break;
      case "dms":
        g = N._pe_dms_to_geog;
    }
    let v = 0;
    p && (v = N.getPointer(p));
    const w = m.map((I) => N.ensureString(I)), b = N.ensureInt32(w), S = N.ensureFloat64(new Array(2 * f)), $ = g(v, f, b, S);
    return $ && Du(y, f, S), $;
  };
  function r(c, p, f, m, y) {
    return t("dms", c, p, f, m, y);
  }
  function i(c, p, f, m) {
    return n("dms", c, p, f, m);
  }
  function s(c, p, f, m, y) {
    return t("ddm", c, p, f, m, y);
  }
  function o(c, p, f, m) {
    return n("ddm", c, p, f, m);
  }
  function a(c, p, f, m, y) {
    return t("dd", c, p, f, m, y);
  }
  function l(c, p, f, m) {
    return n("dd", c, p, f, m);
  }
  e.geogToDms = r, e.dmsToGeog = i, e.geogToDdm = s, e.ddmToGeog = o, e.geogToDd = a, e.ddToGeog = l;
}(TE || (TE = {})), function(e) {
  function t() {
    e.PE_MGRS_STYLE_NEW = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW, e.PE_MGRS_STYLE_OLD = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD, e.PE_MGRS_STYLE_AUTO = N.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO, e.PE_MGRS_180_ZONE_1_PLUS = N.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS, e.PE_MGRS_ADD_SPACES = N.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES;
  }
  function n(i, s, o, a, l, c, p) {
    N.ensureCache.prepare();
    let f = 0;
    i && (f = N.getPointer(i));
    const m = wd(o), y = N.ensureFloat64(m), g = vv(s, tn.PE_MGRS_MAX), v = N.ensureInt32(g), w = N._pe_geog_to_mgrs_extended(f, s, y, a, l, c, v);
    if (w)
      for (let b = 0; b < s; b++)
        p[b] = N.UTF8ToString(g[b]);
    return w;
  }
  function r(i, s, o, a, l) {
    N.ensureCache.prepare();
    let c = 0;
    i && (c = N.getPointer(i));
    const p = o.map((g) => N.ensureString(g)), f = N.ensureInt32(p), m = N.ensureFloat64(new Array(2 * s)), y = N._pe_mgrs_to_geog_extended(c, s, f, a, m);
    return y && Du(l, s, m), y;
  }
  e.init = t, e.geogToMgrsExtended = n, e.mgrsToGeogExtended = r;
}(O1 || (O1 = {})), function(e) {
  function t(r, i, s, o, a, l, c) {
    N.ensureCache.prepare();
    let p = 0;
    r && (p = N.getPointer(r));
    const f = wd(s), m = N.ensureFloat64(f), y = vv(i, tn.PE_MGRS_MAX), g = N.ensureInt32(y), v = N._pe_geog_to_usng(p, i, m, o, a, l, g);
    if (v)
      for (let w = 0; w < i; w++)
        c[w] = N.UTF8ToString(y[w]);
    return v;
  }
  function n(r, i, s, o) {
    N.ensureCache.prepare();
    let a = 0;
    r && (a = N.getPointer(r));
    const l = s.map((m) => N.ensureString(m)), c = N.ensureInt32(l), p = N.ensureFloat64(new Array(2 * i)), f = N._pe_usng_to_geog(a, i, c, p);
    return f && Du(o, i, p), f;
  }
  e.geogToUsng = t, e.usngToGeog = n;
}(EE || (EE = {})), function(e) {
  function t() {
    e.PE_UTM_OPTS_NONE = N.PeNotationUtm.prototype.PE_UTM_OPTS_NONE, e.PE_UTM_OPTS_ADD_SPACES = N.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES, e.PE_UTM_OPTS_NS = N.PeNotationUtm.prototype.PE_UTM_OPTS_NS;
  }
  function n(i, s, o, a, l) {
    N.ensureCache.prepare();
    let c = 0;
    i && (c = N.getPointer(i));
    const p = wd(o), f = N.ensureFloat64(p), m = vv(s, tn.PE_UTM_MAX), y = N.ensureInt32(m), g = N._pe_geog_to_utm(c, s, f, a, y);
    if (g)
      for (let v = 0; v < s; v++)
        l[v] = N.UTF8ToString(m[v]);
    return g;
  }
  function r(i, s, o, a, l) {
    N.ensureCache.prepare();
    let c = 0;
    i && (c = N.getPointer(i));
    const p = o.map((g) => N.ensureString(g)), f = N.ensureInt32(p), m = N.ensureFloat64(new Array(2 * s)), y = N._pe_utm_to_geog(c, s, f, a, m);
    return y && Du(l, s, m), y;
  }
  e.init = t, e.geogToUtm = n, e.utmToGeog = r;
}(k1 || (k1 = {})), function(e) {
  const t = /* @__PURE__ */ new Map();
  function n() {
    e.PE_PCSINFO_OPTION_NONE = N.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE, e.PE_PCSINFO_OPTION_DOMAIN = N.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN, e.PE_POLE_OUTSIDE_BOUNDARY = N.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY, e.PE_POLE_POINT = N.PePCSInfo.prototype.PE_POLE_POINT;
  }
  function r(i, s = e.PE_PCSINFO_OPTION_DOMAIN) {
    let o, a;
    return t.has(i) && (a = t.get(i), a[s] && (o = a[s])), o || (o = N.PePCSInfo.prototype.generate(i, s), a || (a = [], t.set(i, a)), a[s] = o), o;
  }
  e.init = n, e.generate = r;
}(A1 || (A1 = {})), function(e) {
  function t() {
    return N.PeVersion.prototype.version_string();
  }
  e.versionString = t;
}(IE || (IE = {}));
const zte = Object.freeze({ __proto__: null, get _pe() {
  return N;
}, isLoaded: Uj, isSupported: Vte, load: qj, get PeCSTransformations() {
  return _E;
}, get PeDefs() {
  return tn;
}, get PeFactory() {
  return SE;
}, get PeGCSExtent() {
  return Gj;
}, get PeGTlistExtended() {
  return C1;
}, get PeGTlistExtendedEntry() {
  return xE;
}, get PeGTTransformations() {
  return $E;
}, get PeNotationDms() {
  return TE;
}, get PeNotationMgrs() {
  return O1;
}, get PeNotationUsng() {
  return EE;
}, get PeNotationUtm() {
  return k1;
}, get PePCSInfo() {
  return A1;
}, get PeVersion() {
  return IE;
}, _init: Wj }), Wl = Kt.radius, Qs = Kt.eccentricitySquared, Bte = { a1: Wl * Qs, a2: Wl * Qs * Wl * Qs, a3: Wl * Qs * Qs / 2, a4: Wl * Qs * Wl * Qs * 2.5, a5: Wl * Qs + Wl * Qs * Qs / 2, a6: 1 - Qs };
1 / 294.9786982, 1 / 298.257222101, Kt.radius, Kt.flattening, ec.radius, ec.flattening, 1 / 192.0430107526882, Tl.radius, Tl.flattening, 1 / 10.2079945799458, 1 / 43.61604095563141, Tl.radius;
let bv = 0, j2 = class ME {
  constructor(t = null) {
    this.uid = bv++, t ? (this._wkt = t.wkt !== void 0 ? t.wkt : null, this._wkid = t.wkid !== void 0 ? t.wkid : -1, this._isInverse = t.isInverse !== void 0 && t.isInverse === !0) : (this._wkt = null, this._wkid = -1, this._isInverse = !1);
  }
  static fromGE(t) {
    const n = new ME();
    return n._wkt = t.wkt, n._wkid = t.wkid, n._isInverse = t.isInverse, n;
  }
  get wkt() {
    return this._wkt;
  }
  set wkt(t) {
    this._wkt = t, this.uid = bv++;
  }
  get wkid() {
    return this._wkid;
  }
  set wkid(t) {
    this._wkid = t, this.uid = bv++;
  }
  get isInverse() {
    return this._isInverse;
  }
  set isInverse(t) {
    this._isInverse = t, this.uid = bv++;
  }
  getInverse() {
    const t = new ME();
    return t._wkt = this.wkt, t._wkid = this._wkid, t._isInverse = !this.isInverse, t;
  }
}, CE = class by {
  constructor(t) {
    if (this.steps = [], this._cached_projection = {}, this._chain = "", this._gtlistentry = null, t && t.steps)
      for (const n of t.steps)
        n instanceof j2 ? this.steps.push(n) : this.steps.push(new j2({ wkid: n.wkid, wkt: n.wkt, isInverse: n.isInverse }));
  }
  static cacheKey(t, n) {
    return [t.wkid !== void 0 && t.wkid !== null ? t.wkid.toString() : "-1", t.wkt !== void 0 && t.wkt !== null ? t.wkt.toString() : "", n.wkid !== void 0 && n.wkid !== null ? n.wkid.toString() : "-1", n.wkt !== void 0 && n.wkt !== null ? n.wkt.toString() : ""].join(",");
  }
  static fromGE(t) {
    const n = new by();
    let r = "";
    for (const i of t.steps) {
      const s = j2.fromGE(i);
      n.steps.push(s), r += s.uid.toString() + ",";
    }
    return n._cached_projection = {}, n._gtlistentry = null, n._chain = r, n;
  }
  getInverse() {
    const t = new by();
    t.steps = [];
    for (let n = this.steps.length - 1; n >= 0; n--) {
      const r = this.steps[n];
      t.steps.push(r.getInverse());
    }
    return t;
  }
  getGTListEntry() {
    let t = "";
    for (const n of this.steps)
      t += n.uid.toString() + ",";
    return t !== this._chain && (this._gtlistentry = null, this._cached_projection = {}, this._chain = t), this._gtlistentry;
  }
  assignCachedGe(t, n, r) {
    this._cached_projection[by.cacheKey(t, n)] = r;
  }
  getCachedGeTransformation(t, n) {
    let r = "";
    for (const s of this.steps)
      r += s.uid.toString() + ",";
    r !== this._chain && (this._gtlistentry = null, this._cached_projection = {}, this._chain = r);
    const i = this._cached_projection[by.cacheKey(t, n)];
    return i === void 0 ? null : i;
  }
};
function Hj(e, t, n) {
  if (H(t) || H(n) || n.vcsWkid || Oi(t, n))
    return null;
  const r = bf(t) / bf(n);
  if (r === 1)
    return null;
  switch (e) {
    case "point":
    case "esriGeometryPoint":
      return (i) => Ute(i, r);
    case "polyline":
    case "esriGeometryPolyline":
      return (i) => Gte(i, r);
    case "polygon":
    case "esriGeometryPolygon":
      return (i) => qte(i, r);
    case "multipoint":
    case "esriGeometryMultipoint":
      return (i) => Wte(i, r);
    case "extent":
    case "esriGeometryExtent":
      return (i) => Hte(i, r);
    default:
      return null;
  }
}
function Ute(e, t) {
  e && e.z != null && (e.z *= t);
}
function qte(e, t) {
  if (e)
    for (const n of e.rings)
      for (const r of n)
        r.length > 2 && (r[2] *= t);
}
function Gte(e, t) {
  if (e)
    for (const n of e.paths)
      for (const r of n)
        r.length > 2 && (r[2] *= t);
}
function Wte(e, t) {
  if (e)
    for (const n of e.points)
      n.length > 2 && (n[2] *= t);
}
function Hte(e, t) {
  e && e.zmin != null && e.zmax != null && (e.zmin *= t, e.zmax *= t);
}
let up = null, P1 = null, V2 = null, z2 = {};
function wf() {
  return !!up && Uj();
}
function _f(e) {
  return H(V2) && (V2 = Promise.all([qj(), import("./geometryEngineBase-JcvP0DtW.js").then((t) => t.g), import("./hydrated-E_sxY9fb.js")])), V2.then(([, t, { hydratedAdapter: n }]) => {
    On(e), P1 = n, up = t.default, up._enableProjection(zte);
  });
}
function I0(e, t, n = null) {
  return Array.isArray(e) ? e.length === 0 ? [] : qP(P1, e, e[0].spatialReference, t, n) : qP(P1, [e], e.spatialReference, t, n)[0];
}
function qP(e, t, n, r, i = null) {
  if (H(n) || H(r))
    return t;
  if (cp(n, r, i))
    return t.map((s) => Zte(s, n, r));
  if (H(i)) {
    const s = CE.cacheKey(n, r);
    z2[s] !== void 0 ? i = z2[s] : (i = Jte(n, r, null), H(i) && (i = new CE()), z2[s] = i);
  }
  if (H(up))
    throw new Jj();
  return up._project(e, t, n, r, i);
}
function Jte(e, t, n = null) {
  if (H(up))
    throw new Jj();
  if (H(e) || H(t))
    return null;
  const r = up._getTransformation(P1, e, t, n, n == null ? void 0 : n.spatialReference);
  return r !== null ? CE.fromGE(r) : null;
}
class Jj extends D {
  constructor() {
    super("projection:not-loaded", "projection engine not fully loaded yet, please call load()");
  }
}
var L;
function cp(e, t, n) {
  return !n && (!!Oi(e, t) || Mi(e) && Mi(t) && !!Qj(e, t, Xj));
}
async function KRe(e, t, n, r) {
  if (!wf()) {
    if (Array.isArray(e)) {
      for (const { source: i, dest: s, geographicTransformation: o } of e)
        if (!cp(i, s, o))
          return _f(r);
    } else if (!cp(e, t, n))
      return _f(r);
  }
}
function Zte(e, t, n) {
  return e ? "x" in e ? Kte(e, t, new Oe(), n, 0) : "xmin" in e ? Xte(e, t, new Mt(), n, 0) : "rings" in e ? Zj(e, t, new Po(), n, 0) : "paths" in e ? Qte(e, t, new Ki(), n, 0) : "points" in e ? Yte(e, t, new Gf(), n, 0) : null : null;
}
function Kte(e, t, n, r, i) {
  zn[0] = e.x, zn[1] = e.y;
  const s = e.z;
  return zn[2] = s !== void 0 ? s : i, M0(zn, t, 0, zn, r, 0, 1) ? (n.x = zn[0], n.y = zn[1], n.spatialReference = r, s === void 0 ? (n.z = void 0, n.hasZ = !1) : (n.z = zn[2], n.hasZ = !0), e.m === void 0 ? (n.m = void 0, n.hasM = !1) : (n.m = e.m, n.hasM = !0), n) : null;
}
function Yte(e, t, n, r, i) {
  const { points: s, hasZ: o, hasM: a } = e, l = [], c = s.length, p = [];
  for (const f of s)
    p.push(f[0], f[1], o ? f[2] : i);
  if (!M0(p, t, 0, p, r, 0, c))
    return null;
  for (let f = 0; f < c; ++f) {
    const m = 3 * f, y = p[m], g = p[m + 1];
    o && a ? l.push([y, g, p[m + 2], s[f][3]]) : o ? l.push([y, g, p[m + 2]]) : a ? l.push([y, g, s[f][2]]) : l.push([y, g]);
  }
  return n.points = l, n.spatialReference = r, n.hasZ = o, n.hasM = a, n;
}
function Qte(e, t, n, r, i) {
  const { paths: s, hasZ: o, hasM: a } = e, l = [];
  return Kj(s, o, a, t, l, r, i) ? (n.paths = l, n.spatialReference = r, n.hasZ = o, n.hasM = a, n) : null;
}
function YRe(e, t, n = t.spatialReference, r = 0) {
  return O(n) && O(Zj(e, e.spatialReference, t, n, r));
}
function Zj(e, t, n, r, i) {
  const { rings: s, hasZ: o, hasM: a } = e, l = [];
  return Kj(s, o, a, t, l, r, i) ? (n.rings = l, n.spatialReference = r, n.hasZ = o, n.hasM = a, n) : null;
}
function Xte(e, t, n, r, i) {
  const { xmin: s, ymin: o, xmax: a, ymax: l, hasZ: c, hasM: p } = e;
  return GP(s, o, c ? e.zmin : i, t, zn, r) ? (n.xmin = zn[0], n.ymin = zn[1], c && (n.zmin = zn[2]), GP(a, l, c ? e.zmax : i, t, zn, r) ? (n.xmax = zn[0], n.ymax = zn[1], c && (n.zmax = zn[2]), p && (n.mmin = e.mmin, n.mmax = e.mmax), n.spatialReference = r, n) : null) : null;
}
function QRe(e, t, n, r = 0) {
  zn[0] = e.x, zn[1] = e.y;
  const i = e.z;
  return zn[2] = i !== void 0 ? i : r, M0(zn, e.spatialReference, 0, t, n, 0, 1);
}
function GP(e, t, n, r, i, s) {
  return wv[0] = e, wv[1] = t, wv[2] = n, M0(wv, r, 0, i, s, 0, 1);
}
function M0(e, t, n, r, i, s, o = 1) {
  const a = Qj(t, i, Xj);
  if (H(a))
    return !1;
  if (a === Rt) {
    if (e === r && n === s)
      return !0;
    const c = n + 3 * o;
    for (let p = n, f = s; p < c; p++, f++)
      r[f] = e[p];
    return !0;
  }
  const l = n + 3 * o;
  for (let c = n, p = s; c < l; c += 3, p += 3)
    a(e, c, r, p);
  return !0;
}
function Kj(e, t, n, r, i, s, o = 0) {
  const a = new Array();
  for (const c of e)
    for (const p of c)
      a.push(p[0], p[1], t ? p[2] : o);
  if (!M0(a, r, 0, a, s, 0, a.length / 3))
    return !1;
  let l = 0;
  i.length = 0;
  for (const c of e) {
    const p = new Array();
    for (const f of c)
      t && n ? p.push([a[l++], a[l++], a[l++], f[3]]) : t ? p.push([a[l++], a[l++], a[l++]]) : n ? (p.push([a[l++], a[l++], f[2]]), l++) : (p.push([a[l++], a[l++]]), l++);
    i.push(p);
  }
  return !0;
}
function XRe(e, t, n, r) {
  if (H(e) || H(r))
    return !1;
  const i = R1(e, yne), s = R1(r, gne);
  if (i === s && !WP(s) && (i !== L.UNKNOWN || Oi(e, r)))
    return jte(n, t), !0;
  if (WP(s)) {
    const o = wy[i][L.LON_LAT], a = wy[L.LON_LAT][s];
    return !H(o) && !H(a) && (o(t, 0, Hl, 0), a(Hl, 0, Jl, 0), Yj(ya * Hl[0], ya * Hl[1], n), n[12] = Jl[0], n[13] = Jl[1], n[14] = Jl[2], !0);
  }
  if ((s === L.WEB_MERCATOR || s === L.PLATE_CARREE) && (i === L.WGS84 || i === L.CGCS2000 && s === L.PLATE_CARREE || i === L.SPHERICAL_ECEF || i === L.WEB_MERCATOR)) {
    const o = wy[i][L.LON_LAT], a = wy[L.LON_LAT][s];
    return !H(o) && !H(a) && (o(t, 0, Hl, 0), a(Hl, 0, Jl, 0), i === L.SPHERICAL_ECEF ? ene(ya * Hl[0], ya * Hl[1], n) : Dte(n), n[12] = Jl[0], n[13] = Jl[1], n[14] = Jl[2], !0);
  }
  return !1;
}
function WP(e) {
  return e === L.SPHERICAL_ECEF || e === L.SPHERICAL_MARS_PCPF || e === L.SPHERICAL_MOON_PCPF;
}
function Yj(e, t, n) {
  const r = Math.sin(e), i = Math.cos(e), s = Math.sin(t), o = Math.cos(t), a = n;
  return a[0] = -r, a[4] = -s * i, a[8] = o * i, a[12] = 0, a[1] = i, a[5] = -s * r, a[9] = o * r, a[13] = 0, a[2] = 0, a[6] = o, a[10] = s, a[14] = 0, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, a;
}
function ene(e, t, n) {
  return Yj(e, t, n), gc(n, n), n;
}
function R1(e, t) {
  return t.spatialReference === e ? t.spatialReferenceId : (t.spatialReference = e, "metersPerUnit" in t && (t.metersPerUnit = E0(e, 1)), e.wkt === Rj.wkt ? t.spatialReferenceId = L.SPHERICAL_ECEF : Og(e) ? t.spatialReferenceId = L.WGS84 : tp(e) ? t.spatialReferenceId = L.WEB_MERCATOR : JK(e) ? t.spatialReferenceId = L.PLATE_CARREE : e.wkt === Ste.wkt ? t.spatialReferenceId = L.WGS84_ECEF : e.wkid === ep.CGCS2000 ? t.spatialReferenceId = L.CGCS2000 : e.wkt === I1.wkt ? t.spatialReferenceId = L.SPHERICAL_MARS_PCPF : e.wkt === M1.wkt ? t.spatialReferenceId = L.SPHERICAL_MOON_PCPF : X_(e) ? t.spatialReferenceId = L.GCSMARS2000 : eS(e) ? t.spatialReferenceId = L.GCSMOON2000 : t.spatialReferenceId = L.UNKNOWN);
}
function Rt(e, t, n, r) {
  e !== n && (n[r++] = e[t++], n[r++] = e[t++], n[r] = e[t]);
}
function nf(e, t, n, r) {
  n[r++] = Sf * (e[t++] / Kt.radius), n[r++] = Sf * (Math.PI / 2 - 2 * Math.atan(Math.exp(-e[t++] / Kt.radius))), n[r] = e[t];
}
function tne(e, t, n, r) {
  nf(e, t, n, r), Md(n, r, n, r);
}
function nne(e, t, n, r) {
  nf(e, t, n, r), Od(n, r, n, r);
}
function rne(e, t, n, r, i) {
  const s = 0.4999999 * Math.PI, o = js(ya * e[t + 1], -s, s), a = Math.sin(o);
  n[r++] = ya * e[t] * i.radius, n[r++] = i.halfSemiMajorAxis * Math.log((1 + a) / (1 - a)), n[r] = e[t + 2];
}
function zg(e, t, n, r) {
  rne(e, t, n, r, Kt);
}
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.SPHERICAL_ECEF = 1] = "SPHERICAL_ECEF", e[e.WGS84 = 2] = "WGS84", e[e.WEB_MERCATOR = 3] = "WEB_MERCATOR", e[e.WGS84_ECEF = 4] = "WGS84_ECEF", e[e.CGCS2000 = 5] = "CGCS2000", e[e.WGS84_COMPARABLE_LON_LAT = 6] = "WGS84_COMPARABLE_LON_LAT", e[e.SPHERICAL_MARS_PCPF = 7] = "SPHERICAL_MARS_PCPF", e[e.GCSMARS2000 = 8] = "GCSMARS2000", e[e.SPHERICAL_MOON_PCPF = 9] = "SPHERICAL_MOON_PCPF", e[e.GCSMOON2000 = 10] = "GCSMOON2000", e[e.LON_LAT = 11] = "LON_LAT", e[e.PLATE_CARREE = 12] = "PLATE_CARREE";
})(L || (L = {}));
const HP = Kt.radius * Math.PI / 180, JP = 180 / (Kt.radius * Math.PI);
function Ed(e, t, n, r) {
  n[r] = e[t] * HP, n[r + 1] = e[t + 1] * HP, n[r + 2] = e[t + 2];
}
function Id(e, t, n, r) {
  n[r] = e[t] * JP, n[r + 1] = e[t + 1] * JP, n[r + 2] = e[t + 2];
}
function ine(e, t, n, r) {
  nf(e, t, n, r), Ed(n, r, n, r);
}
function sne(e, t, n, r) {
  kd(e, t, n, r), Ed(n, r, n, r);
}
function one(e, t, n, r) {
  Cd(e, t, n, r), Ed(n, r, n, r);
}
function ane(e, t, n, r) {
  Id(e, t, n, r), Md(n, r, n, r);
}
function lne(e, t, n, r) {
  Id(e, t, n, r), zg(n, r, n, r);
}
function une(e, t, n, r) {
  Id(e, t, n, r), Od(n, r, n, r);
}
function WO(e, t, n, r, i) {
  const s = i + e[t + 2], o = ya * e[t + 1], a = ya * e[t], l = Math.cos(o);
  n[r++] = Math.cos(a) * l * s, n[r++] = Math.sin(a) * l * s, n[r] = Math.sin(o) * s;
}
function ZP(e, t, n, r) {
  WO(e, t, n, r, ec.radius);
}
function KP(e, t, n, r) {
  WO(e, t, n, r, Tl.radius);
}
function Md(e, t, n, r) {
  WO(e, t, n, r, Kt.radius);
}
function HO(e, t, n, r, i) {
  const s = e[t], o = e[t + 1], a = e[t + 2], l = Math.sqrt(s * s + o * o + a * a), c = mQ(a / (l === 0 ? 1 : l)), p = Math.atan2(o, s);
  n[r++] = Sf * p, n[r++] = Sf * c, n[r] = l - i;
}
function YP(e, t, n, r) {
  HO(e, t, n, r, ec.radius);
}
function QP(e, t, n, r) {
  HO(e, t, n, r, Tl.radius);
}
function Cd(e, t, n, r) {
  HO(e, t, n, r, Kt.radius);
}
function cne(e, t, n, r) {
  Cd(e, t, n, r), zg(n, r, n, r);
}
function dne(e, t, n, r) {
  Cd(e, t, n, r), Od(n, r, n, r);
}
function pne(e, t, n, r, i) {
  const s = ya * e[t], o = ya * e[t + 1], a = e[t + 2], l = Math.sin(o), c = Math.cos(o), p = i.radius / Math.sqrt(1 - i.eccentricitySquared * l * l);
  n[r++] = (p + a) * c * Math.cos(s), n[r++] = (p + a) * c * Math.sin(s), n[r++] = (p * (1 - i.eccentricitySquared) + a) * l;
}
function Od(e, t, n, r) {
  pne(e, t, n, r, Kt);
}
function kd(e, t, n, r) {
  const i = Bte, s = e[t], o = e[t + 1], a = e[t + 2];
  let l, c, p, f, m, y, g, v, w, b, S, $, I, M, E, C, A, W, j, G, R;
  l = Math.abs(a), c = s * s + o * o, p = Math.sqrt(c), f = c + a * a, m = Math.sqrt(f), G = Math.atan2(o, s), y = a * a / f, g = c / f, M = i.a2 / m, E = i.a3 - i.a4 / m, g > 0.3 ? (v = l / m * (1 + g * (i.a1 + M + y * E) / m), j = Math.asin(v), b = v * v, w = Math.sqrt(1 - b)) : (w = p / m * (1 - y * (i.a5 - M - g * E) / m), j = Math.acos(w), b = 1 - w * w, v = Math.sqrt(b)), S = 1 - Kt.eccentricitySquared * b, $ = Kt.radius / Math.sqrt(S), I = i.a6 * $, M = p - $ * w, E = l - I * v, A = w * M + v * E, C = w * E - v * M, W = C / (I / S + A), j += W, R = A + C * W / 2, a < 0 && (j = -j), n[r++] = Sf * G, n[r++] = Sf * j, n[r] = R;
}
function hne(e, t, n, r) {
  kd(e, t, n, r), Md(n, r, n, r);
}
function fne(e, t, n, r) {
  kd(e, t, n, r), zg(n, r, n, r);
}
const wy = { [L.WGS84]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: Rt, [L.SPHERICAL_ECEF]: Md, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: zg, [L.PLATE_CARREE]: Ed, [L.WGS84]: Rt, [L.WGS84_ECEF]: Od }, [L.CGCS2000]: { [L.CGCS2000]: Rt, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: Rt, [L.SPHERICAL_ECEF]: Md, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: Ed, [L.WGS84]: null, [L.WGS84_ECEF]: Od }, [L.GCSMARS2000]: { [L.CGCS2000]: null, [L.GCSMARS2000]: Rt, [L.GCSMOON2000]: null, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: null, [L.SPHERICAL_ECEF]: null, [L.SPHERICAL_MARS_PCPF]: KP, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: null, [L.WGS84]: null, [L.WGS84_ECEF]: null }, [L.GCSMOON2000]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: Rt, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: null, [L.SPHERICAL_ECEF]: null, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: ZP, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: null, [L.WGS84]: null, [L.WGS84_ECEF]: null }, [L.WEB_MERCATOR]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: nf, [L.WGS84_COMPARABLE_LON_LAT]: nf, [L.SPHERICAL_ECEF]: tne, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: Rt, [L.PLATE_CARREE]: ine, [L.WGS84]: nf, [L.WGS84_ECEF]: nne }, [L.WGS84_ECEF]: { [L.CGCS2000]: kd, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: kd, [L.WGS84_COMPARABLE_LON_LAT]: kd, [L.SPHERICAL_ECEF]: hne, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: fne, [L.PLATE_CARREE]: sne, [L.WGS84]: kd, [L.WGS84_ECEF]: Rt }, [L.SPHERICAL_ECEF]: { [L.CGCS2000]: Cd, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: Cd, [L.WGS84_COMPARABLE_LON_LAT]: Cd, [L.SPHERICAL_ECEF]: Rt, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: cne, [L.PLATE_CARREE]: one, [L.WGS84]: Cd, [L.WGS84_ECEF]: dne }, [L.SPHERICAL_MARS_PCPF]: { [L.CGCS2000]: null, [L.GCSMARS2000]: QP, [L.GCSMOON2000]: null, [L.LON_LAT]: QP, [L.WGS84_COMPARABLE_LON_LAT]: null, [L.SPHERICAL_ECEF]: null, [L.SPHERICAL_MARS_PCPF]: Rt, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: null, [L.WGS84]: null, [L.WGS84_ECEF]: null }, [L.SPHERICAL_MOON_PCPF]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: YP, [L.LON_LAT]: YP, [L.WGS84_COMPARABLE_LON_LAT]: null, [L.SPHERICAL_ECEF]: null, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: Rt, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: null, [L.WGS84]: null, [L.WGS84_ECEF]: null }, [L.UNKNOWN]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: null, [L.WGS84_COMPARABLE_LON_LAT]: null, [L.SPHERICAL_ECEF]: null, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: Rt, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: null, [L.WGS84]: null, [L.WGS84_ECEF]: null }, [L.LON_LAT]: { [L.CGCS2000]: Rt, [L.GCSMARS2000]: Rt, [L.GCSMOON2000]: Rt, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: Rt, [L.SPHERICAL_ECEF]: Md, [L.SPHERICAL_MARS_PCPF]: KP, [L.SPHERICAL_MOON_PCPF]: ZP, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: zg, [L.PLATE_CARREE]: Ed, [L.WGS84]: Rt, [L.WGS84_ECEF]: Od }, [L.WGS84_COMPARABLE_LON_LAT]: { [L.CGCS2000]: null, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: Rt, [L.WGS84_COMPARABLE_LON_LAT]: Rt, [L.SPHERICAL_ECEF]: Md, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: null, [L.PLATE_CARREE]: Ed, [L.WGS84]: Rt, [L.WGS84_ECEF]: Od }, [L.PLATE_CARREE]: { [L.CGCS2000]: Id, [L.GCSMARS2000]: null, [L.GCSMOON2000]: null, [L.LON_LAT]: Id, [L.WGS84_COMPARABLE_LON_LAT]: Id, [L.SPHERICAL_ECEF]: ane, [L.SPHERICAL_MARS_PCPF]: null, [L.SPHERICAL_MOON_PCPF]: null, [L.UNKNOWN]: null, [L.WEB_MERCATOR]: lne, [L.PLATE_CARREE]: Rt, [L.WGS84]: Id, [L.WGS84_ECEF]: une } };
function Qj(e, t, n = JO()) {
  return H(e) || H(t) ? null : mne(e, t, n).projector;
}
function mne(e, t, n) {
  if (H(e) || H(t) || n.source.spatialReference === e && n.dest.spatialReference === t)
    return n;
  const r = R1(e, n.source), i = R1(t, n.dest);
  return r === L.UNKNOWN && i === L.UNKNOWN ? Oi(e, t) ? n.projector = Rt : n.projector = null : n.projector = wy[r][i], n;
}
function JO() {
  return { source: { spatialReference: null, spatialReferenceId: L.UNKNOWN, metersPerUnit: 1 }, dest: { spatialReference: null, spatialReferenceId: L.UNKNOWN, metersPerUnit: 1 }, projector: Rt };
}
const yne = { spatialReference: null, spatialReferenceId: L.UNKNOWN }, gne = { spatialReference: null, spatialReferenceId: L.UNKNOWN }, Xj = JO();
JO();
const ya = fQ(1), Sf = p6(1), wv = qf(), Hl = qf(), Jl = qf(), zn = qf();
var OE;
let na = OE = class extends se {
  constructor(e) {
    super(e), this.cols = null, this.level = 0, this.levelValue = null, this.origin = null, this.resolution = 0, this.rows = null, this.scale = 0;
  }
  clone() {
    return new OE({ cols: this.cols, level: this.level, levelValue: this.levelValue, resolution: this.resolution, rows: this.rows, scale: this.scale });
  }
};
u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], na.prototype, "cols", void 0), u([d({ type: Vt, json: { write: !0 } })], na.prototype, "level", void 0), u([d({ type: String, json: { write: !0 } })], na.prototype, "levelValue", void 0), u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], na.prototype, "origin", void 0), u([d({ type: Number, json: { write: !0 } })], na.prototype, "resolution", void 0), u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], na.prototype, "rows", void 0), u([d({ type: Number, json: { write: !0 } })], na.prototype, "scale", void 0), na = OE = u([T("geoscene.layers.support.LOD")], na);
const ZO = na;
var hu;
const XP = new st({ PNG: "png", PNG8: "png8", PNG24: "png24", PNG32: "png32", JPEG: "jpg", JPG: "jpg", DIB: "dib", TIFF: "tiff", EMF: "emf", PS: "ps", PDF: "pdf", GIF: "gif", SVG: "svg", SVGZ: "svgz", Mixed: "mixed", MIXED: "mixed", LERC: "lerc", LERC2D: "lerc2d", RAW: "raw", pbf: "pbf" });
let Hn = hu = class extends se {
  constructor(e) {
    super(e), this.dpi = 96, this.format = null, this.origin = null, this.minScale = 0, this.maxScale = 0, this.size = null, this.spatialReference = null;
  }
  static create(e = {}) {
    const { resolutionFactor: t = 1, scales: n, size: r = 256, spatialReference: i = Qe.WebMercator, numLODs: s = 24 } = e;
    if (!Mi(i)) {
      const f = [];
      if (n)
        for (let m = 0; m < n.length; m++) {
          const y = n[m];
          f.push({ level: m, scale: y, resolution: y });
        }
      else {
        let m = 5e-4;
        for (let y = s - 1; y >= 0; y--)
          f.unshift({ level: y, scale: m, resolution: m }), m *= 2;
      }
      return new hu({ dpi: 96, lods: f, origin: new Oe(0, 0, i), size: [r, r], spatialReference: i });
    }
    const o = Oo(i), a = e.origin ? new Oe({ x: e.origin.x, y: e.origin.y, spatialReference: i }) : new Oe(o ? { x: o.origin[0], y: o.origin[1], spatialReference: i } : { x: 0, y: 0, spatialReference: i }), l = 96, c = 1 / (E0(i) * 39.37 * l), p = [];
    if (n)
      for (let f = 0; f < n.length; f++) {
        const m = n[f], y = m * c;
        p.push({ level: f, scale: m, resolution: y });
      }
    else {
      let f = H8(i) ? 512 / r * 5916575275917094e-7 : 256 / r * 591657527591555e-6;
      const m = Math.ceil(s / t);
      p.push({ level: 0, scale: f, resolution: f * c });
      for (let y = 1; y < m; y++) {
        const g = f / 2 ** t, v = g * c;
        p.push({ level: y, scale: g, resolution: v }), f = g;
      }
    }
    return new hu({ dpi: l, lods: p, origin: a, size: [r, r], spatialReference: i });
  }
  get isWrappable() {
    const { spatialReference: e, origin: t } = this;
    if (e && t) {
      const n = Oo(e);
      return e.isWrappable && Math.abs(n.origin[0] - t.x) <= n.dx;
    }
    return !1;
  }
  readOrigin(e, t) {
    return Oe.fromJSON({ spatialReference: t.spatialReference, ...e });
  }
  set lods(e) {
    let t = 0, n = 0;
    const r = [];
    this._levelToLOD = {}, e && (t = -1 / 0, n = 1 / 0, e.forEach((i) => {
      r.push(i.scale), t = i.scale > t ? i.scale : t, n = i.scale < n ? i.scale : n, this._levelToLOD[i.level] = i;
    })), this._set("scales", r), this._set("minScale", t), this._set("maxScale", n), this._set("lods", e), this._initializeUpsampleLevels();
  }
  readSize(e, t) {
    return [t.cols, t.rows];
  }
  writeSize(e, t) {
    t.cols = e[0], t.rows = e[1];
  }
  zoomToScale(e) {
    const t = this.scales;
    if (e <= 0)
      return t[0];
    if (e >= t.length - 1)
      return t[t.length - 1];
    {
      const n = Math.floor(e), r = n + 1;
      return t[n] / (t[n] / t[r]) ** (e - n);
    }
  }
  scaleToZoom(e) {
    const t = this.scales, n = t.length - 1;
    let r = 0;
    for (; r < n; r++) {
      const i = t[r], s = t[r + 1];
      if (i <= e)
        return r;
      if (s === e)
        return r + 1;
      if (i > e && s < e)
        return r + Math.log(i / e) / Math.log(i / s);
    }
    return r;
  }
  snapScale(e, t = 0.95) {
    const n = this.scaleToZoom(e);
    return n % Math.floor(n) >= t ? this.zoomToScale(Math.ceil(n)) : this.zoomToScale(Math.floor(n));
  }
  tileAt(e, t, n, r) {
    const i = this.lodAt(e);
    if (!i)
      return null;
    let s, o;
    if (typeof t == "number")
      s = t, o = n;
    else if (Oi(t.spatialReference, this.spatialReference))
      s = t.x, o = t.y, r = n;
    else {
      const c = tS(t, this.spatialReference);
      if (H(c))
        return null;
      s = c.x, o = c.y, r = n;
    }
    const a = i.resolution * this.size[0], l = i.resolution * this.size[1];
    return r || (r = { id: null, level: 0, row: 0, col: 0, extent: ap() }), r.level = e, r.row = Math.floor((this.origin.y - o) / l + 1e-3), r.col = Math.floor((s - this.origin.x) / a + 1e-3), this.updateTileInfo(r), r;
  }
  updateTileInfo(e, t = hu.ExtrapolateOptions.NONE) {
    let n = this.lodAt(e.level);
    if (!n && t === hu.ExtrapolateOptions.POWER_OF_TWO) {
      const o = this.lods[this.lods.length - 1];
      o.level < e.level && (n = o);
    }
    if (!n)
      return;
    const r = e.level - n.level, i = n.resolution * this.size[0] / 2 ** r, s = n.resolution * this.size[1] / 2 ** r;
    e.id = `${e.level}/${e.row}/${e.col}`, e.extent || (e.extent = ap()), e.extent[0] = this.origin.x + e.col * i, e.extent[1] = this.origin.y - (e.row + 1) * s, e.extent[2] = e.extent[0] + i, e.extent[3] = e.extent[1] + s;
  }
  upsampleTile(e) {
    const t = this._upsampleLevels[e.level];
    return !(!t || t.parentLevel === -1) && (e.level = t.parentLevel, e.row = Math.floor(e.row / t.factor + 1e-3), e.col = Math.floor(e.col / t.factor + 1e-3), this.updateTileInfo(e), !0);
  }
  getTileBounds(e, t) {
    const { resolution: n } = this.lodAt(t.level), r = n * this.size[0], i = n * this.size[1];
    return e[0] = this.origin.x + t.col * r, e[1] = this.origin.y - (t.row + 1) * i, e[2] = e[0] + r, e[3] = e[1] + i, e;
  }
  lodAt(e) {
    return this._levelToLOD && this._levelToLOD[e] || null;
  }
  clone() {
    return hu.fromJSON(this.write({}));
  }
  getOrCreateCompatible(e, t) {
    if (this.size[0] === 256 && this.size[1] === 256)
      return e === 256 ? this : null;
    const n = [], r = this.lods.length;
    for (let i = 0; i < r; i++) {
      const s = this.lods[i], o = s.resolution * t;
      n.push(new ZO({ level: s.level, scale: s.scale, resolution: o }));
    }
    return new hu({ size: [e, e], dpi: this.dpi, format: this.format, compressionQuality: this.compressionQuality, origin: this.origin, spatialReference: this.spatialReference, lods: n });
  }
  _initializeUpsampleLevels() {
    const e = this.lods;
    this._upsampleLevels = [];
    let t = null;
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      this._upsampleLevels[r.level] = { parentLevel: t ? t.level : -1, factor: t ? t.resolution / r.resolution : 0 }, t = r;
    }
  }
};
u([d({ type: Number, json: { write: !0 } })], Hn.prototype, "compressionQuality", void 0), u([d({ type: Number, json: { write: !0 } })], Hn.prototype, "dpi", void 0), u([d({ type: String, json: { read: XP.read, write: XP.write, origins: { "web-scene": { read: !1, write: !1 } } } })], Hn.prototype, "format", void 0), u([d({ readOnly: !0 })], Hn.prototype, "isWrappable", null), u([d({ type: Oe, json: { write: !0 } })], Hn.prototype, "origin", void 0), u([be("origin")], Hn.prototype, "readOrigin", null), u([d({ type: [ZO], value: null, json: { write: !0 } })], Hn.prototype, "lods", null), u([d({ readOnly: !0 })], Hn.prototype, "minScale", void 0), u([d({ readOnly: !0 })], Hn.prototype, "maxScale", void 0), u([d({ readOnly: !0 })], Hn.prototype, "scales", void 0), u([d({ cast: (e) => Array.isArray(e) ? e : typeof e == "number" ? [e, e] : [256, 256] })], Hn.prototype, "size", void 0), u([be("size", ["rows", "cols"])], Hn.prototype, "readSize", null), u([xe("size", { cols: { type: Vt }, rows: { type: Vt } })], Hn.prototype, "writeSize", null), u([d({ type: Qe, json: { write: !0 } })], Hn.prototype, "spatialReference", void 0), Hn = hu = u([T("geoscene.layers.support.TileInfo")], Hn), function(e) {
  var t;
  (t = e.ExtrapolateOptions || (e.ExtrapolateOptions = {}))[t.NONE = 0] = "NONE", t[t.POWER_OF_TWO = 1] = "POWER_OF_TWO";
}(Hn || (Hn = {}));
const vne = Hn, Qb = { widthBreakpoint: { getValue(e) {
  const t = e.viewSize[0], n = e.breakpoints, r = this.values;
  return t <= n.xsmall ? r.xsmall : t <= n.small ? r.small : t <= n.medium ? r.medium : t <= n.large ? r.large : r.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "geoscene-view-width-xsmall geoscene-view-width-less-than-small geoscene-view-width-less-than-medium geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", small: "geoscene-view-width-small geoscene-view-width-greater-than-xsmall geoscene-view-width-less-than-medium geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", medium: "geoscene-view-width-medium geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", large: "geoscene-view-width-large geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-greater-than-medium geoscene-view-width-less-than-xlarge", xlarge: "geoscene-view-width-xlarge geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-greater-than-medium geoscene-view-width-greater-than-large" } }, heightBreakpoint: { getValue(e) {
  const t = e.viewSize[1], n = e.breakpoints, r = this.values;
  return t <= n.xsmall ? r.xsmall : t <= n.small ? r.small : t <= n.medium ? r.medium : t <= n.large ? r.large : r.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "geoscene-view-height-xsmall geoscene-view-height-less-than-small geoscene-view-height-less-than-medium geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", small: "geoscene-view-height-small geoscene-view-height-greater-than-xsmall geoscene-view-height-less-than-medium geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", medium: "geoscene-view-height-medium geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", large: "geoscene-view-height-large geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-greater-than-medium geoscene-view-height-less-than-xlarge", xlarge: "geoscene-view-height-xlarge geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-greater-than-medium geoscene-view-height-greater-than-large" } }, orientation: { getValue(e) {
  const t = e.viewSize, n = t[0], r = t[1], i = this.values;
  return r >= n ? i.portrait : i.landscape;
}, values: { portrait: "portrait", landscape: "landscape" }, valueToClassName: { portrait: "geoscene-view-orientation-portrait", landscape: "geoscene-view-orientation-landscape" } } }, B2 = { xsmall: 544, small: 768, medium: 992, large: 1200 };
function bne(e) {
  const t = e;
  return t && t.xsmall < t.small && t.small < t.medium && t.medium < t.large;
}
function U2(e, t) {
  return t ? Qb[e].valueToClassName[t].split(" ") : [];
}
const wne = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this._breakpointsHandles = new ei(), this.orientation = null, this.widthBreakpoint = null, this.heightBreakpoint = null, this.breakpoints = B2;
    }
    initialize() {
      this._breakpointsHandles.add(Nt(() => [this.breakpoints, this.size], () => this._updateClassNames(), va));
    }
    destroy() {
      this.destroyed || (this._removeActiveClassNames(), this._breakpointsHandles = pa(this._breakpointsHandles));
    }
    set breakpoints(n) {
      if (n === this._get("breakpoints"))
        return;
      const r = bne(n);
      if (!r) {
        const i = JSON.stringify(B2, null, 2);
        console.warn("provided breakpoints are not valid, using defaults:" + i);
      }
      n = r ? n : B2, this._set("breakpoints", { ...n });
    }
    _updateClassNames() {
      if (!this.container)
        return;
      const n = Hr.acquire(), r = Hr.acquire();
      let i, s = !1;
      for (i in Qb) {
        const o = this[i], a = Qb[i].getValue({ viewSize: this.size, breakpoints: this.breakpoints });
        o !== a && (s = !0, this[i] = a, U2(i, o).forEach((l) => r.push(l)), U2(i, a).forEach((l) => n.push(l)));
      }
      s && (this._applyClassNameChanges(n, r), Hr.release(n), Hr.release(r));
    }
    _applyClassNameChanges(n, r) {
      const i = this.container;
      i && (r.forEach((s) => i.classList.remove(s)), n.forEach((s) => i.classList.add(s)));
    }
    _removeActiveClassNames() {
      const n = this.container;
      if (!n)
        return;
      let r;
      for (r in Qb)
        U2(r, this[r]).forEach((i) => n.classList.remove(i));
    }
  };
  return u([d()], t.prototype, "breakpoints", null), u([d()], t.prototype, "orientation", void 0), u([d()], t.prototype, "widthBreakpoint", void 0), u([d()], t.prototype, "heightBreakpoint", void 0), t = u([T("geoscene.views.BreakpointsOwner")], t), t;
};
function KO(e) {
  return typeof e == "string" ? document.getElementById(e) : e;
}
function e9(e) {
  for (; e.hasChildNodes(); )
    e.removeChild(e.firstChild);
}
function eR(e, t) {
  const n = t.parentNode;
  n && n.insertBefore(e, t);
}
function tR(e, t) {
  for (; ; ) {
    const n = e.firstChild;
    if (!n)
      break;
    t.appendChild(n);
  }
}
/*!
 * @esri/arcgis-html-sanitizer - v2.9.0 - Mon Dec 13 2021 15:07:01 GMT-0500 (Eastern Standard Time)
 * Copyright (c) 2021 - Environmental Systems Research Institute, Inc.
 * Apache-2.0
 * 
 * js-xss
 * Copyright (c) 2012-2017 Zongmin Lei() <leizongmin@gmail.com>
 * http://ucdok.com
 * MIT License, see https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 * 
 * Lodash/isPlainObject
 * Copyright (c) JS Foundation and other contributors <https://js.foundation/>
 * MIT License, see https://raw.githubusercontent.com/lodash/lodash/4.17.10-npm/LICENSE for details
 */
var _ne = "[object Object]";
function Sne(e) {
  var t = !1;
  if (e != null && typeof e.toString != "function")
    try {
      t = !!(e + "");
    } catch {
    }
  return t;
}
function xne(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var $ne = Function.prototype, t9 = Object.prototype, n9 = $ne.toString, Tne = t9.hasOwnProperty, Ene = n9.call(Object), Ine = t9.toString, Mne = xne(Object.getPrototypeOf, Object);
function Cne(e) {
  return !!e && typeof e == "object";
}
function One(e) {
  if (!Cne(e) || Ine.call(e) != _ne || Sne(e))
    return !1;
  var t = Mne(e);
  if (t === null)
    return !0;
  var n = Tne.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && n9.call(n) == Ene;
}
var kne = One, Bh = { exports: {} }, vn = {}, Bg = { exports: {} }, Op = {};
function r9() {
  var e = {};
  return e["align-content"] = !1, e["align-items"] = !1, e["align-self"] = !1, e["alignment-adjust"] = !1, e["alignment-baseline"] = !1, e.all = !1, e["anchor-point"] = !1, e.animation = !1, e["animation-delay"] = !1, e["animation-direction"] = !1, e["animation-duration"] = !1, e["animation-fill-mode"] = !1, e["animation-iteration-count"] = !1, e["animation-name"] = !1, e["animation-play-state"] = !1, e["animation-timing-function"] = !1, e.azimuth = !1, e["backface-visibility"] = !1, e.background = !0, e["background-attachment"] = !0, e["background-clip"] = !0, e["background-color"] = !0, e["background-image"] = !0, e["background-origin"] = !0, e["background-position"] = !0, e["background-repeat"] = !0, e["background-size"] = !0, e["baseline-shift"] = !1, e.binding = !1, e.bleed = !1, e["bookmark-label"] = !1, e["bookmark-level"] = !1, e["bookmark-state"] = !1, e.border = !0, e["border-bottom"] = !0, e["border-bottom-color"] = !0, e["border-bottom-left-radius"] = !0, e["border-bottom-right-radius"] = !0, e["border-bottom-style"] = !0, e["border-bottom-width"] = !0, e["border-collapse"] = !0, e["border-color"] = !0, e["border-image"] = !0, e["border-image-outset"] = !0, e["border-image-repeat"] = !0, e["border-image-slice"] = !0, e["border-image-source"] = !0, e["border-image-width"] = !0, e["border-left"] = !0, e["border-left-color"] = !0, e["border-left-style"] = !0, e["border-left-width"] = !0, e["border-radius"] = !0, e["border-right"] = !0, e["border-right-color"] = !0, e["border-right-style"] = !0, e["border-right-width"] = !0, e["border-spacing"] = !0, e["border-style"] = !0, e["border-top"] = !0, e["border-top-color"] = !0, e["border-top-left-radius"] = !0, e["border-top-right-radius"] = !0, e["border-top-style"] = !0, e["border-top-width"] = !0, e["border-width"] = !0, e.bottom = !1, e["box-decoration-break"] = !0, e["box-shadow"] = !0, e["box-sizing"] = !0, e["box-snap"] = !0, e["box-suppress"] = !0, e["break-after"] = !0, e["break-before"] = !0, e["break-inside"] = !0, e["caption-side"] = !1, e.chains = !1, e.clear = !0, e.clip = !1, e["clip-path"] = !1, e["clip-rule"] = !1, e.color = !0, e["color-interpolation-filters"] = !0, e["column-count"] = !1, e["column-fill"] = !1, e["column-gap"] = !1, e["column-rule"] = !1, e["column-rule-color"] = !1, e["column-rule-style"] = !1, e["column-rule-width"] = !1, e["column-span"] = !1, e["column-width"] = !1, e.columns = !1, e.contain = !1, e.content = !1, e["counter-increment"] = !1, e["counter-reset"] = !1, e["counter-set"] = !1, e.crop = !1, e.cue = !1, e["cue-after"] = !1, e["cue-before"] = !1, e.cursor = !1, e.direction = !1, e.display = !0, e["display-inside"] = !0, e["display-list"] = !0, e["display-outside"] = !0, e["dominant-baseline"] = !1, e.elevation = !1, e["empty-cells"] = !1, e.filter = !1, e.flex = !1, e["flex-basis"] = !1, e["flex-direction"] = !1, e["flex-flow"] = !1, e["flex-grow"] = !1, e["flex-shrink"] = !1, e["flex-wrap"] = !1, e.float = !1, e["float-offset"] = !1, e["flood-color"] = !1, e["flood-opacity"] = !1, e["flow-from"] = !1, e["flow-into"] = !1, e.font = !0, e["font-family"] = !0, e["font-feature-settings"] = !0, e["font-kerning"] = !0, e["font-language-override"] = !0, e["font-size"] = !0, e["font-size-adjust"] = !0, e["font-stretch"] = !0, e["font-style"] = !0, e["font-synthesis"] = !0, e["font-variant"] = !0, e["font-variant-alternates"] = !0, e["font-variant-caps"] = !0, e["font-variant-east-asian"] = !0, e["font-variant-ligatures"] = !0, e["font-variant-numeric"] = !0, e["font-variant-position"] = !0, e["font-weight"] = !0, e.grid = !1, e["grid-area"] = !1, e["grid-auto-columns"] = !1, e["grid-auto-flow"] = !1, e["grid-auto-rows"] = !1, e["grid-column"] = !1, e["grid-column-end"] = !1, e["grid-column-start"] = !1, e["grid-row"] = !1, e["grid-row-end"] = !1, e["grid-row-start"] = !1, e["grid-template"] = !1, e["grid-template-areas"] = !1, e["grid-template-columns"] = !1, e["grid-template-rows"] = !1, e["hanging-punctuation"] = !1, e.height = !0, e.hyphens = !1, e.icon = !1, e["image-orientation"] = !1, e["image-resolution"] = !1, e["ime-mode"] = !1, e["initial-letters"] = !1, e["inline-box-align"] = !1, e["justify-content"] = !1, e["justify-items"] = !1, e["justify-self"] = !1, e.left = !1, e["letter-spacing"] = !0, e["lighting-color"] = !0, e["line-box-contain"] = !1, e["line-break"] = !1, e["line-grid"] = !1, e["line-height"] = !1, e["line-snap"] = !1, e["line-stacking"] = !1, e["line-stacking-ruby"] = !1, e["line-stacking-shift"] = !1, e["line-stacking-strategy"] = !1, e["list-style"] = !0, e["list-style-image"] = !0, e["list-style-position"] = !0, e["list-style-type"] = !0, e.margin = !0, e["margin-bottom"] = !0, e["margin-left"] = !0, e["margin-right"] = !0, e["margin-top"] = !0, e["marker-offset"] = !1, e["marker-side"] = !1, e.marks = !1, e.mask = !1, e["mask-box"] = !1, e["mask-box-outset"] = !1, e["mask-box-repeat"] = !1, e["mask-box-slice"] = !1, e["mask-box-source"] = !1, e["mask-box-width"] = !1, e["mask-clip"] = !1, e["mask-image"] = !1, e["mask-origin"] = !1, e["mask-position"] = !1, e["mask-repeat"] = !1, e["mask-size"] = !1, e["mask-source-type"] = !1, e["mask-type"] = !1, e["max-height"] = !0, e["max-lines"] = !1, e["max-width"] = !0, e["min-height"] = !0, e["min-width"] = !0, e["move-to"] = !1, e["nav-down"] = !1, e["nav-index"] = !1, e["nav-left"] = !1, e["nav-right"] = !1, e["nav-up"] = !1, e["object-fit"] = !1, e["object-position"] = !1, e.opacity = !1, e.order = !1, e.orphans = !1, e.outline = !1, e["outline-color"] = !1, e["outline-offset"] = !1, e["outline-style"] = !1, e["outline-width"] = !1, e.overflow = !1, e["overflow-wrap"] = !1, e["overflow-x"] = !1, e["overflow-y"] = !1, e.padding = !0, e["padding-bottom"] = !0, e["padding-left"] = !0, e["padding-right"] = !0, e["padding-top"] = !0, e.page = !1, e["page-break-after"] = !1, e["page-break-before"] = !1, e["page-break-inside"] = !1, e["page-policy"] = !1, e.pause = !1, e["pause-after"] = !1, e["pause-before"] = !1, e.perspective = !1, e["perspective-origin"] = !1, e.pitch = !1, e["pitch-range"] = !1, e["play-during"] = !1, e.position = !1, e["presentation-level"] = !1, e.quotes = !1, e["region-fragment"] = !1, e.resize = !1, e.rest = !1, e["rest-after"] = !1, e["rest-before"] = !1, e.richness = !1, e.right = !1, e.rotation = !1, e["rotation-point"] = !1, e["ruby-align"] = !1, e["ruby-merge"] = !1, e["ruby-position"] = !1, e["shape-image-threshold"] = !1, e["shape-outside"] = !1, e["shape-margin"] = !1, e.size = !1, e.speak = !1, e["speak-as"] = !1, e["speak-header"] = !1, e["speak-numeral"] = !1, e["speak-punctuation"] = !1, e["speech-rate"] = !1, e.stress = !1, e["string-set"] = !1, e["tab-size"] = !1, e["table-layout"] = !1, e["text-align"] = !0, e["text-align-last"] = !0, e["text-combine-upright"] = !0, e["text-decoration"] = !0, e["text-decoration-color"] = !0, e["text-decoration-line"] = !0, e["text-decoration-skip"] = !0, e["text-decoration-style"] = !0, e["text-emphasis"] = !0, e["text-emphasis-color"] = !0, e["text-emphasis-position"] = !0, e["text-emphasis-style"] = !0, e["text-height"] = !0, e["text-indent"] = !0, e["text-justify"] = !0, e["text-orientation"] = !0, e["text-overflow"] = !0, e["text-shadow"] = !0, e["text-space-collapse"] = !0, e["text-transform"] = !0, e["text-underline-position"] = !0, e["text-wrap"] = !0, e.top = !1, e.transform = !1, e["transform-origin"] = !1, e["transform-style"] = !1, e.transition = !1, e["transition-delay"] = !1, e["transition-duration"] = !1, e["transition-property"] = !1, e["transition-timing-function"] = !1, e["unicode-bidi"] = !1, e["vertical-align"] = !1, e.visibility = !1, e["voice-balance"] = !1, e["voice-duration"] = !1, e["voice-family"] = !1, e["voice-pitch"] = !1, e["voice-range"] = !1, e["voice-rate"] = !1, e["voice-stress"] = !1, e["voice-volume"] = !1, e.volume = !1, e["white-space"] = !1, e.widows = !1, e.width = !0, e["will-change"] = !1, e["word-break"] = !0, e["word-spacing"] = !0, e["word-wrap"] = !0, e["wrap-flow"] = !1, e["wrap-through"] = !1, e["writing-mode"] = !1, e["z-index"] = !1, e;
}
function Ane(e, t, n) {
}
function Pne(e, t, n) {
}
var Rne = /javascript\s*\:/img;
function Lne(e, t) {
  return Rne.test(t) ? "" : t;
}
Op.whiteList = r9();
Op.getDefaultWhiteList = r9;
Op.onAttr = Ane;
Op.onIgnoreAttr = Pne;
Op.safeAttrValue = Lne;
var Fne = {
  indexOf: function(e, t) {
    var n, r;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (n = 0, r = e.length; n < r; n++)
      if (e[n] === t)
        return n;
    return -1;
  },
  forEach: function(e, t, n) {
    var r, i;
    if (Array.prototype.forEach)
      return e.forEach(t, n);
    for (r = 0, i = e.length; r < i; r++)
      t.call(n, e[r], r, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(e) {
    return String.prototype.trimRight ? e.trimRight() : e.replace(/(\s*$)/g, "");
  }
}, Em = Fne;
function Nne(e, t) {
  e = Em.trimRight(e), e[e.length - 1] !== ";" && (e += ";");
  var n = e.length, r = !1, i = 0, s = 0, o = "";
  function a() {
    if (!r) {
      var p = Em.trim(e.slice(i, s)), f = p.indexOf(":");
      if (f !== -1) {
        var m = Em.trim(p.slice(0, f)), y = Em.trim(p.slice(f + 1));
        if (m) {
          var g = t(i, o.length, m, y, p);
          g && (o += g + "; ");
        }
      }
    }
    i = s + 1;
  }
  for (; s < n; s++) {
    var l = e[s];
    if (l === "/" && e[s + 1] === "*") {
      var c = e.indexOf("*/", s + 2);
      if (c === -1)
        break;
      s = c + 1, i = s + 1, r = !1;
    } else
      l === "(" ? r = !0 : l === ")" ? r = !1 : l === ";" ? r || a() : l === `
` && a();
  }
  return Em.trim(o);
}
var Dne = Nne, _v = Op, jne = Dne;
function nR(e) {
  return e == null;
}
function Vne(e) {
  var t = {};
  for (var n in e)
    t[n] = e[n];
  return t;
}
function i9(e) {
  e = Vne(e || {}), e.whiteList = e.whiteList || _v.whiteList, e.onAttr = e.onAttr || _v.onAttr, e.onIgnoreAttr = e.onIgnoreAttr || _v.onIgnoreAttr, e.safeAttrValue = e.safeAttrValue || _v.safeAttrValue, this.options = e;
}
i9.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, n = t.options, r = n.whiteList, i = n.onAttr, s = n.onIgnoreAttr, o = n.safeAttrValue, a = jne(e, function(l, c, p, f, m) {
    var y = r[p], g = !1;
    if (y === !0 ? g = y : typeof y == "function" ? g = y(f) : y instanceof RegExp && (g = y.test(f)), g !== !0 && (g = !1), f = o(p, f), !!f) {
      var v = {
        position: c,
        sourcePosition: l,
        source: m,
        isWhite: g
      };
      if (g) {
        var w = i(p, f, v);
        return nR(w) ? p + ":" + f : w;
      } else {
        var w = s(p, f, v);
        if (!nR(w))
          return w;
      }
    }
  });
  return a;
};
var zne = i9;
(function(e, t) {
  var n = Op, r = zne;
  function i(o, a) {
    var l = new r(a);
    return l.process(o);
  }
  t = e.exports = i, t.FilterCSS = r;
  for (var s in n)
    t[s] = n[s];
})(Bg, Bg.exports);
var YO = {
  indexOf: function(e, t) {
    var n, r;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (n = 0, r = e.length; n < r; n++)
      if (e[n] === t)
        return n;
    return -1;
  },
  forEach: function(e, t, n) {
    var r, i;
    if (Array.prototype.forEach)
      return e.forEach(t, n);
    for (r = 0, i = e.length; r < i; r++)
      t.call(n, e[r], r, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(e) {
    var t = /\s|\n|\t/, n = t.exec(e);
    return n ? n.index : -1;
  }
}, Bne = Bg.exports.FilterCSS, Une = Bg.exports.getDefaultWhiteList, L1 = YO;
function s9() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var o9 = new Bne();
function qne(e, t, n) {
}
function Gne(e, t, n) {
}
function Wne(e, t, n) {
}
function Hne(e, t, n) {
}
function a9(e) {
  return e.replace(Zne, "&lt;").replace(Kne, "&gt;");
}
function Jne(e, t, n, r) {
  if (n = h9(n), t === "href" || t === "src") {
    if (n = L1.trim(n), n === "#")
      return "#";
    if (!(n.substr(0, 7) === "http://" || n.substr(0, 8) === "https://" || n.substr(0, 7) === "mailto:" || n.substr(0, 4) === "tel:" || n.substr(0, 11) === "data:image/" || n.substr(0, 6) === "ftp://" || n.substr(0, 2) === "./" || n.substr(0, 3) === "../" || n[0] === "#" || n[0] === "/"))
      return "";
  } else if (t === "background") {
    if (Sv.lastIndex = 0, Sv.test(n))
      return "";
  } else if (t === "style") {
    if (rR.lastIndex = 0, rR.test(n) || (iR.lastIndex = 0, iR.test(n) && (Sv.lastIndex = 0, Sv.test(n))))
      return "";
    r !== !1 && (r = r || o9, n = r.process(n));
  }
  return n = f9(n), n;
}
var Zne = /</g, Kne = />/g, Yne = /"/g, Qne = /&quot;/g, Xne = /&#([a-zA-Z0-9]*);?/gim, ere = /&colon;?/gim, tre = /&newline;?/gim, Sv = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi, rR = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, iR = /u\s*r\s*l\s*\(.*/gi;
function l9(e) {
  return e.replace(Yne, "&quot;");
}
function u9(e) {
  return e.replace(Qne, '"');
}
function c9(e) {
  return e.replace(Xne, function(n, r) {
    return r[0] === "x" || r[0] === "X" ? String.fromCharCode(parseInt(r.substr(1), 16)) : String.fromCharCode(parseInt(r, 10));
  });
}
function d9(e) {
  return e.replace(ere, ":").replace(tre, " ");
}
function p9(e) {
  for (var t = "", n = 0, r = e.length; n < r; n++)
    t += e.charCodeAt(n) < 32 ? " " : e.charAt(n);
  return L1.trim(t);
}
function h9(e) {
  return e = u9(e), e = c9(e), e = d9(e), e = p9(e), e;
}
function f9(e) {
  return e = l9(e), e = a9(e), e;
}
function nre() {
  return "";
}
function rre(e, t) {
  typeof t != "function" && (t = function() {
  });
  var n = !Array.isArray(e);
  function r(o) {
    return n ? !0 : L1.indexOf(e, o) !== -1;
  }
  var i = [], s = !1;
  return {
    onIgnoreTag: function(o, a, l) {
      if (r(o))
        if (l.isClosing) {
          var c = "[/removed]", p = l.position + c.length;
          return i.push([
            s !== !1 ? s : l.position,
            p
          ]), s = !1, c;
        } else
          return s || (s = l.position), "[removed]";
      else
        return t(o, a, l);
    },
    remove: function(o) {
      var a = "", l = 0;
      return L1.forEach(i, function(c) {
        a += o.slice(l, c[0]), l = c[1];
      }), a += o.slice(l), a;
    }
  };
}
function ire(e) {
  for (var t = "", n = 0; n < e.length; ) {
    var r = e.indexOf("<!--", n);
    if (r === -1) {
      t += e.slice(n);
      break;
    }
    t += e.slice(n, r);
    var i = e.indexOf("-->", r);
    if (i === -1)
      break;
    n = i + 3;
  }
  return t;
}
function sre(e) {
  var t = e.split("");
  return t = t.filter(function(n) {
    var r = n.charCodeAt(0);
    return r === 127 ? !1 : r <= 31 ? r === 10 || r === 13 : !0;
  }), t.join("");
}
vn.whiteList = s9();
vn.getDefaultWhiteList = s9;
vn.onTag = qne;
vn.onIgnoreTag = Gne;
vn.onTagAttr = Wne;
vn.onIgnoreTagAttr = Hne;
vn.safeAttrValue = Jne;
vn.escapeHtml = a9;
vn.escapeQuote = l9;
vn.unescapeQuote = u9;
vn.escapeHtmlEntities = c9;
vn.escapeDangerHtml5Entities = d9;
vn.clearNonPrintableCharacter = p9;
vn.friendlyAttrValue = h9;
vn.escapeAttrValue = f9;
vn.onIgnoreTagStripAll = nre;
vn.StripTagBody = rre;
vn.stripCommentTag = ire;
vn.stripBlankChar = sre;
vn.cssFilter = o9;
vn.getDefaultCSSWhiteList = Une;
var fS = {}, Au = YO;
function ore(e) {
  var t = Au.spaceIndex(e);
  if (t === -1)
    var n = e.slice(1, -1);
  else
    var n = e.slice(1, t + 1);
  return n = Au.trim(n).toLowerCase(), n.slice(0, 1) === "/" && (n = n.slice(1)), n.slice(-1) === "/" && (n = n.slice(0, -1)), n;
}
function are(e) {
  return e.slice(0, 2) === "</";
}
function lre(e, t, n) {
  var r = "", i = 0, s = !1, o = !1, a = 0, l = e.length, c = "", p = "";
  e:
    for (a = 0; a < l; a++) {
      var f = e.charAt(a);
      if (s === !1) {
        if (f === "<") {
          s = a;
          continue;
        }
      } else if (o === !1) {
        if (f === "<") {
          r += n(e.slice(i, a)), s = a, i = a;
          continue;
        }
        if (f === ">") {
          r += n(e.slice(i, s)), p = e.slice(s, a + 1), c = ore(p), r += t(
            s,
            r.length,
            c,
            p,
            are(p)
          ), i = a + 1, s = !1;
          continue;
        }
        if (f === '"' || f === "'")
          for (var m = 1, y = e.charAt(a - m); y.trim() === "" || y === "="; ) {
            if (y === "=") {
              o = f;
              continue e;
            }
            y = e.charAt(a - ++m);
          }
      } else if (f === o) {
        o = !1;
        continue;
      }
    }
  return i < e.length && (r += n(e.substr(i))), r;
}
var ure = /[^a-zA-Z0-9_:\.\-]/gim;
function cre(e, t) {
  var n = 0, r = [], i = !1, s = e.length;
  function o(f, m) {
    if (f = Au.trim(f), f = f.replace(ure, "").toLowerCase(), !(f.length < 1)) {
      var y = t(f, m || "");
      y && r.push(y);
    }
  }
  for (var a = 0; a < s; a++) {
    var l = e.charAt(a), c, p;
    if (i === !1 && l === "=") {
      i = e.slice(n, a), n = a + 1;
      continue;
    }
    if (i !== !1 && a === n && (l === '"' || l === "'") && e.charAt(a - 1) === "=") {
      if (p = e.indexOf(l, a + 1), p === -1)
        break;
      c = Au.trim(e.slice(n + 1, p)), o(i, c), i = !1, a = p, n = a + 1;
      continue;
    }
    if (/\s|\n|\t/.test(l))
      if (e = e.replace(/\s|\n|\t/g, " "), i === !1)
        if (p = dre(e, a), p === -1) {
          c = Au.trim(e.slice(n, a)), o(c), i = !1, n = a + 1;
          continue;
        } else {
          a = p - 1;
          continue;
        }
      else if (p = pre(e, a - 1), p === -1) {
        c = Au.trim(e.slice(n, a)), c = sR(c), o(i, c), i = !1, n = a + 1;
        continue;
      } else
        continue;
  }
  return n < e.length && (i === !1 ? o(e.slice(n)) : o(i, sR(Au.trim(e.slice(n))))), Au.trim(r.join(" "));
}
function dre(e, t) {
  for (; t < e.length; t++) {
    var n = e[t];
    if (n !== " ")
      return n === "=" ? t : -1;
  }
}
function pre(e, t) {
  for (; t > 0; t--) {
    var n = e[t];
    if (n !== " ")
      return n === "=" ? t : -1;
  }
}
function hre(e) {
  return e[0] === '"' && e[e.length - 1] === '"' || e[0] === "'" && e[e.length - 1] === "'";
}
function sR(e) {
  return hre(e) ? e.substr(1, e.length - 2) : e;
}
fS.parseTag = lre;
fS.parseAttr = cre;
var fre = Bg.exports.FilterCSS, _o = vn, m9 = fS, mre = m9.parseTag, yre = m9.parseAttr, Xb = YO;
function xv(e) {
  return e == null;
}
function gre(e) {
  var t = Xb.spaceIndex(e);
  if (t === -1)
    return {
      html: "",
      closing: e[e.length - 2] === "/"
    };
  e = Xb.trim(e.slice(t + 1, -1));
  var n = e[e.length - 1] === "/";
  return n && (e = Xb.trim(e.slice(0, -1))), {
    html: e,
    closing: n
  };
}
function vre(e) {
  var t = {};
  for (var n in e)
    t[n] = e[n];
  return t;
}
function y9(e) {
  e = vre(e || {}), e.stripIgnoreTag && (e.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), e.onIgnoreTag = _o.onIgnoreTagStripAll), e.whiteList = e.whiteList || _o.whiteList, e.onTag = e.onTag || _o.onTag, e.onTagAttr = e.onTagAttr || _o.onTagAttr, e.onIgnoreTag = e.onIgnoreTag || _o.onIgnoreTag, e.onIgnoreTagAttr = e.onIgnoreTagAttr || _o.onIgnoreTagAttr, e.safeAttrValue = e.safeAttrValue || _o.safeAttrValue, e.escapeHtml = e.escapeHtml || _o.escapeHtml, this.options = e, e.css === !1 ? this.cssFilter = !1 : (e.css = e.css || {}, this.cssFilter = new fre(e.css));
}
y9.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, n = t.options, r = n.whiteList, i = n.onTag, s = n.onIgnoreTag, o = n.onTagAttr, a = n.onIgnoreTagAttr, l = n.safeAttrValue, c = n.escapeHtml, p = t.cssFilter;
  n.stripBlankChar && (e = _o.stripBlankChar(e)), n.allowCommentTag || (e = _o.stripCommentTag(e));
  var f = !1;
  if (n.stripIgnoreTagBody) {
    var f = _o.StripTagBody(
      n.stripIgnoreTagBody,
      s
    );
    s = f.onIgnoreTag;
  }
  var m = mre(
    e,
    function(y, g, v, w, b) {
      var S = {
        sourcePosition: y,
        position: g,
        isClosing: b,
        isWhite: r.hasOwnProperty(v)
      }, $ = i(v, w, S);
      if (!xv($))
        return $;
      if (S.isWhite) {
        if (S.isClosing)
          return "</" + v + ">";
        var I = gre(w), M = r[v], E = yre(I.html, function(A, W) {
          var j = Xb.indexOf(M, A) !== -1, G = o(v, A, W, j);
          if (!xv(G))
            return G;
          if (j)
            return W = l(v, A, W, p), W ? A + '="' + W + '"' : A;
          var G = a(v, A, W, j);
          return xv(G) ? void 0 : G;
        }), w = "<" + v;
        return E && (w += " " + E), I.closing && (w += " /"), w += ">", w;
      } else {
        var $ = s(v, w, S);
        return xv($) ? c(w) : $;
      }
    },
    c
  );
  return f && (m = f.remove(m)), m;
};
var bre = y9;
(function(e, t) {
  var n = vn, r = fS, i = bre;
  function s(l, c) {
    var p = new i(c);
    return p.process(l);
  }
  t = e.exports = s, t.filterXSS = s, t.FilterXSS = i;
  for (var o in n)
    t[o] = n[o];
  for (var o in r)
    t[o] = r[o];
  function a() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  a() && (self.filterXSS = e.exports);
})(Bh, Bh.exports);
var wre = (
  /** @class */
  function() {
    function e(t, n) {
      var r = this;
      this.arcgisWhiteList = {
        a: ["href", "style", "target"],
        abbr: ["title"],
        audio: ["autoplay", "controls", "loop", "muted", "preload"],
        b: [],
        br: [],
        dd: ["style"],
        div: ["align", "style"],
        dl: ["style"],
        dt: ["style"],
        em: [],
        figcaption: ["style"],
        figure: ["style"],
        font: ["color", "face", "size", "style"],
        h1: ["style"],
        h2: ["style"],
        h3: ["style"],
        h4: ["style"],
        h5: ["style"],
        h6: ["style"],
        hr: [],
        i: [],
        img: ["alt", "border", "height", "src", "style", "width"],
        li: [],
        ol: [],
        p: ["style"],
        source: ["media", "src", "type"],
        span: ["style"],
        strong: [],
        sub: ["style"],
        sup: ["style"],
        table: ["border", "cellpadding", "cellspacing", "height", "style", "width"],
        tbody: [],
        tr: ["align", "height", "style", "valign"],
        td: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        th: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "height",
          "loop",
          "muted",
          "poster",
          "preload",
          "width"
        ]
      }, this.allowedProtocols = [
        "http",
        "https",
        "mailto",
        "iform",
        "tel",
        "flow",
        "lfmobile",
        "arcgis-navigator",
        "arcgis-appstudio-player",
        "arcgis-survey123",
        "arcgis-collector",
        "arcgis-workforce",
        "arcgis-explorer",
        "arcgis-trek2there",
        "arcgis-quickcapture",
        "mspbi",
        "comgooglemaps",
        "pdfefile",
        "pdfehttp",
        "pdfehttps",
        "boxapp",
        "boxemm",
        "awb",
        "awbs",
        "gropen",
        "radarscope"
      ], this.arcgisFilterOptions = {
        allowCommentTag: !0,
        safeAttrValue: function(s, o, a, l) {
          return s === "a" && o === "href" || (s === "img" || s === "source") && o === "src" ? r.sanitizeUrl(a) : Bh.exports.safeAttrValue(s, o, a, l);
        }
      };
      var i;
      t && !n ? i = t : t && n ? (i = Object.create(this.arcgisFilterOptions), Object.keys(t).forEach(function(s) {
        s === "whiteList" ? i.whiteList = r._extendObjectOfArrays([
          r.arcgisWhiteList,
          t.whiteList || {}
        ]) : i[s] = t[s];
      })) : (i = Object.create(this.arcgisFilterOptions), i.whiteList = this.arcgisWhiteList), this.xssFilterOptions = i, this._xssFilter = new Bh.exports.FilterXSS(i);
    }
    return e.prototype.sanitize = function(t, n) {
      switch (n === void 0 && (n = {}), typeof t) {
        case "number":
          return isNaN(t) || !isFinite(t) ? null : t;
        case "boolean":
          return t;
        case "string":
          return this._xssFilter.process(t);
        case "object":
          return this._iterateOverObject(t, n);
        default:
          return n.allowUndefined && typeof t > "u" ? void 0 : null;
      }
    }, e.prototype.sanitizeUrl = function(t) {
      var n = this._trim(t.substring(0, t.indexOf(":")));
      return t === "/" || t === "#" || t[0] === "#" || this.allowedProtocols.indexOf(n.toLowerCase()) > -1 ? Bh.exports.escapeAttrValue(t) : "";
    }, e.prototype.sanitizeHTMLAttribute = function(t, n, r, i) {
      return typeof this.xssFilterOptions.safeAttrValue == "function" ? this.xssFilterOptions.safeAttrValue(t, n, r, i) : Bh.exports.safeAttrValue(t, n, r, i);
    }, e.prototype.validate = function(t, n) {
      n === void 0 && (n = {});
      var r = this.sanitize(t, n);
      return {
        isValid: t === r,
        sanitized: r
      };
    }, e.prototype._extendObjectOfArrays = function(t) {
      var n = {};
      return t.forEach(function(r) {
        Object.keys(r).forEach(function(i) {
          Array.isArray(r[i]) && Array.isArray(n[i]) ? n[i] = n[i].concat(r[i]) : n[i] = r[i];
        });
      }), n;
    }, e.prototype._iterateOverObject = function(t, n) {
      var r = this;
      n === void 0 && (n = {});
      try {
        var i = !1, s = void 0;
        if (Array.isArray(t))
          s = t.reduce(function(a, l) {
            var c = r.validate(l, n);
            return c.isValid ? a.concat([l]) : (i = !0, a.concat([c.sanitized]));
          }, []);
        else if (kne(t)) {
          var o = Object.keys(t);
          s = o.reduce(function(a, l) {
            var c = t[l], p = r.validate(c, n);
            return p.isValid ? a[l] = c : (i = !0, a[l] = p.sanitized), a;
          }, {});
        } else
          return n.allowUndefined && typeof t > "u" ? void 0 : null;
        return i ? s : t;
      } catch {
        return null;
      }
    }, e.prototype._trim = function(t) {
      return String.prototype.trim ? t.trim() : t.replace(/(^\s*)|(\s*$)/g, "");
    }, e;
  }()
);
const mS = /* @__PURE__ */ new Map();
function g9() {
  mS.clear();
}
function _re(e) {
  return mS.get(e);
}
function Sre(e, t) {
  mS.set(e, t);
}
function q2(e) {
  mS.delete(e);
}
var dp, xf, xre = function(e) {
  if ("WebkitTransition" in e.style)
    dp = "webkitTransitionEnd", xf = "webkitAnimationEnd";
  else {
    if (!("transition" in e.style))
      throw new Error("Your browser is not supported!");
    dp = "transitionend", xf = "animationend";
  }
}, v9 = function(e) {
  dp || xre(e);
}, $re = function(e, t) {
  return t === void 0 && (t = e + "-active"), function(n) {
    v9(n);
    var r = !1, i = function(s) {
      r || (r = !0, n.removeEventListener(dp, i), n.removeEventListener(xf, i), n.classList.remove(e), n.classList.remove(t));
    };
    n.classList.add(e), n.addEventListener(dp, i), n.addEventListener(xf, i), requestAnimationFrame(function() {
      n.classList.add(t);
    });
  };
}, Tre = function(e, t) {
  return t === void 0 && (t = e + "-active"), function(n, r) {
    v9(n);
    var i = !1, s = function(o) {
      i || (i = !0, n.removeEventListener(dp, s), n.removeEventListener(xf, s), r());
    };
    n.classList.add(e), n.addEventListener(dp, s), n.addEventListener(xf, s), requestAnimationFrame(function() {
      n.classList.add(t);
    });
  };
};
const Ere = we.getLogger("geoscene.widgets.support.widgetUtils");
function b9(e) {
  const t = Hr.acquire();
  for (let r = 0; r < arguments.length; r++) {
    const i = arguments[r], s = typeof i;
    if (s === "string")
      t.push(i);
    else if (Array.isArray(i))
      t.push.apply(t, i);
    else if (s === "object")
      for (const o in i)
        i[o] && t.push(o);
  }
  const n = t.join(" ");
  return Hr.release(t), n;
}
(() => {
  const e = /* @__PURE__ */ new Map(), t = new ResizeObserver((n) => {
    g9();
    for (const r of n)
      e.get(r.target)(r);
  });
  return (n, r, i) => (e.has(n) && Ere.error("Already observing element", n), e.set(n, r), t.observe(n, i), Vf(() => {
    t.unobserve(n), e.delete(n);
  }));
})();
function qu(e) {
  const t = e == null ? void 0 : e.closest("[dir]");
  return t !== null && t instanceof HTMLElement && t.dir === "rtl" || document.dir === "rtl";
}
function oR(e) {
  const t = "data-node-ref";
  this[e.getAttribute(t)] = null;
}
function kE(e) {
  const t = "data-node-ref";
  this[e.getAttribute(t)] = e;
}
function Ire(e, t) {
  return (e === "enter" ? $re : Tre)(t);
}
const Mre = ["dd", "dl", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "sub", "sup", "animate", "animatetransform", "circle", "clippath", "defs", "ellipse", "g", "image", "line", "lineargradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "svg", "switch", "symbol", "text", "textpath", "tspan", "use"], Cre = Mre.reduce((e, t) => (e[t] = [], e), {}), Ore = ["align", "alink", "alt", "bgcolor", "border", "cellpadding", "cellspacing", "class", "color", "cols", "colspan", "coords", "d", "dir", "face", "height", "hspace", "ismap", "lang", "marginheight", "marginwidth", "multiple", "nohref", "noresize", "noshade", "nowrap", "ref", "rel", "rev", "rows", "rowspan", "scrolling", "shape", "span", "summary", "tabindex", "title", "usemap", "valign", "value", "vlink", "vspace", "width"], w9 = new wre({ whiteList: Cre, onTagAttr: (e, t, n) => {
  const r = `${t}="${n}"`;
  if (Ore.includes(t))
    return r;
}, stripIgnoreTag: !0, stripIgnoreTagBody: ["script", "style"] }, !0);
function kre(e) {
  return e === "Enter" || e === " ";
}
const _9 = "http://www.w3.org/", yS = `${_9}2000/svg`, S9 = `${_9}1999/xlink`;
let F1, aR = [], QO = (e, t) => {
  let n = {};
  return Object.keys(e).forEach((r) => {
    n[r] = e[r];
  }), t && Object.keys(t).forEach((r) => {
    n[r] = t[r];
  }), n;
}, XO = (e, t) => e.vnodeSelector === t.vnodeSelector && (e.properties && t.properties ? e.properties.key === t.properties.key && e.properties.bind === t.properties.bind : !e.properties && !t.properties), x9 = (e) => {
  if (typeof e != "string")
    throw new Error("Style values must be strings");
}, Are = (e, t, n) => {
  if (t.vnodeSelector !== "") {
    for (let r = n; r < e.length; r++)
      if (XO(e[r], t))
        return r;
  }
  return -1;
}, G2 = (e, t, n, r) => {
  let i = e[t];
  if (i.vnodeSelector === "")
    return;
  let s = i.properties;
  if (!(s && (s.key === void 0 ? s.bind : s.key))) {
    for (let o = 0; o < e.length; o++)
      if (o !== t) {
        let a = e[o];
        if (XO(a, i))
          throw new Error(`${n.vnodeSelector} had a ${i.vnodeSelector} child ${r === "added" ? r : "removed"}, but there is now more than one. You must add unique key properties to make them distinguishable.`);
      }
  }
}, Pre = (e) => {
  if (e.properties) {
    let t = e.properties.enterAnimation;
    t && t(e.domNode, e.properties);
  }
}, AE = [], PE = !1, $9 = (e) => {
  (e.children || []).forEach($9), e.properties && e.properties.afterRemoved && e.properties.afterRemoved.apply(e.properties.bind || e.properties, [e.domNode]);
}, lR = () => {
  PE = !1, AE.forEach($9), AE.length = 0;
}, uR = (e) => {
  AE.push(e), PE || (PE = !0, typeof window < "u" && "requestIdleCallback" in window ? window.requestIdleCallback(lR, { timeout: 16 }) : setTimeout(lR, 16));
}, cR = (e) => {
  let t = e.domNode;
  if (e.properties) {
    let n = e.properties.exitAnimation;
    if (n)
      return t.style.pointerEvents = "none", void n(t, () => {
        t.parentNode && (t.parentNode.removeChild(t), uR(e));
      }, e.properties);
  }
  t.parentNode && (t.parentNode.removeChild(t), uR(e));
}, Rre = (e, t, n) => {
  if (!t)
    return;
  let r = n.eventHandlerInterceptor, i = Object.keys(t), s = i.length;
  for (let o = 0; o < s; o++) {
    let a = i[o], l = t[a];
    if (a === "className")
      throw new Error('Property "className" is not supported, use "class".');
    if (a === "class")
      RE(e, l, !0);
    else if (a === "classes") {
      let c = Object.keys(l), p = c.length;
      for (let f = 0; f < p; f++) {
        let m = c[f];
        l[m] && e.classList.add(m);
      }
    } else if (a === "styles") {
      let c = Object.keys(l), p = c.length;
      for (let f = 0; f < p; f++) {
        let m = c[f], y = l[m];
        y && (x9(y), n.styleApplyer(e, m, y));
      }
    } else if (a !== "key" && l != null) {
      let c = typeof l;
      c === "function" ? (a.lastIndexOf("on", 0) === 0 && (r && (l = r(a, l, e, t)), a === "oninput" && function() {
        let p = l;
        l = function(f) {
          p.apply(this, [f]), f.target["oninput-value"] = f.target.value;
        };
      }()), e[a] = l) : n.namespace === yS ? a === "href" ? e.setAttributeNS(S9, a, l) : e.setAttribute(a, l) : c === "string" && a !== "value" ? a === "innerHTML" ? e[a] = w9.sanitize(l) : e.setAttribute(a, l) : e[a] = l;
    }
  }
}, Lre = (e, t, n) => {
  if (t)
    for (let r of t)
      Uh(r, e, void 0, n);
}, T9 = (e, t, n) => {
  Lre(e, t.children, n), t.text && (e.textContent = t.text), Rre(e, t.properties, n), t.properties && t.properties.afterCreate && t.properties.afterCreate.apply(t.properties.bind || t.properties, [e, n, t.vnodeSelector, t.properties, t.children]);
}, Uh = (e, t, n, r) => {
  let i, s = 0, o = e.vnodeSelector, a = t.ownerDocument;
  if (o === "")
    i = e.domNode = a.createTextNode(e.text), n !== void 0 ? t.insertBefore(i, n) : t.appendChild(i);
  else {
    for (let l = 0; l <= o.length; ++l) {
      let c = o.charAt(l);
      if (l === o.length || c === "." || c === "#") {
        let p = o.charAt(s - 1), f = o.slice(s, l);
        p === "." ? i.classList.add(f) : p === "#" ? i.id = f : (f === "svg" && (r = QO(r, { namespace: yS })), r.namespace !== void 0 ? i = e.domNode = a.createElementNS(r.namespace, f) : (i = e.domNode = e.domNode || a.createElement(f), f === "input" && e.properties && e.properties.type !== void 0 && i.setAttribute("type", e.properties.type)), n !== void 0 ? t.insertBefore(i, n) : i.parentNode !== t && t.appendChild(i)), s = l + 1;
      }
    }
    T9(i, e, r);
  }
}, RE = (e, t, n) => {
  t && t.split(" ").forEach((r) => {
    r && e.classList.toggle(r, n);
  });
}, Fre = (e, t, n, r) => {
  if (!n)
    return;
  let i = !1, s = Object.keys(n), o = s.length;
  for (let a = 0; a < o; a++) {
    let l = s[a], c = n[l], p = t[l];
    if (l === "class")
      p !== c && (RE(e, p, !1), RE(e, c, !0));
    else if (l === "classes") {
      let f = e.classList, m = Object.keys(c), y = m.length;
      for (let g = 0; g < y; g++) {
        let v = m[g], w = !!c[v];
        w !== !!p[v] && (i = !0, w ? f.add(v) : f.remove(v));
      }
    } else if (l === "styles") {
      let f = Object.keys(c), m = f.length;
      for (let y = 0; y < m; y++) {
        let g = f[y], v = c[g];
        v !== p[g] && (i = !0, v ? (x9(v), r.styleApplyer(e, g, v)) : r.styleApplyer(e, g, ""));
      }
    } else if (c || typeof p != "string" || (c = ""), l === "value") {
      let f = e[l];
      f !== c && (e["oninput-value"] ? f === e["oninput-value"] : c !== p) && (e[l] = c, e["oninput-value"] = void 0), c !== p && (i = !0);
    } else if (c !== p) {
      let f = typeof c;
      f === "function" && r.eventHandlerInterceptor || (r.namespace === yS ? l === "href" ? e.setAttributeNS(S9, l, c) : e.setAttribute(l, c) : f === "string" ? l === "innerHTML" ? e[l] = w9.sanitize(c) : l === "role" && c === "" ? e.removeAttribute(l) : e.setAttribute(l, c) : e[l] !== c && (e[l] = c), i = !0);
    }
  }
  return i;
}, Nre = (e, t, n, r, i) => {
  if (n === r)
    return !1;
  r = r || aR;
  let s, o = (n = n || aR).length, a = r.length, l = 0, c = 0, p = !1;
  for (; c < a; ) {
    let f = l < o ? n[l] : void 0, m = r[c];
    if (f !== void 0 && XO(f, m))
      p = F1(f, m, i) || p, l++;
    else {
      let y = Are(n, m, l + 1);
      if (y >= 0) {
        for (s = l; s < y; s++)
          cR(n[s]), G2(n, s, e, "removed");
        p = F1(n[y], m, i) || p, l = y + 1;
      } else
        Uh(m, t, l < o ? n[l].domNode : void 0, i), Pre(m), G2(r, c, e, "added");
    }
    c++;
  }
  if (o > l)
    for (s = l; s < o; s++)
      cR(n[s]), G2(n, s, e, "removed");
  return p;
};
F1 = (e, t, n) => {
  let r = e.domNode, i = !1;
  if (e === t)
    return !1;
  let s = !1;
  if (t.vnodeSelector === "") {
    if (t.text !== e.text) {
      let o = r.ownerDocument.createTextNode(t.text);
      return r.parentNode.replaceChild(o, r), t.domNode = o, i = !0, i;
    }
    t.domNode = r;
  } else
    t.vnodeSelector.lastIndexOf("svg", 0) === 0 && (n = QO(n, { namespace: yS })), e.text !== t.text && (s = !0, t.text === void 0 ? r.removeChild(r.firstChild) : r.textContent = t.text), t.domNode = r, s = Nre(t, r, e.children, t.children, n) || s, s = Fre(r, e.properties, t.properties, n) || s, t.properties && t.properties.afterUpdate && t.properties.afterUpdate.apply(t.properties.bind || t.properties, [r, n, t.vnodeSelector, t.properties, t.children]);
  return s && t.properties && t.properties.updateAnimation && t.properties.updateAnimation(r, t.properties, e.properties), i;
};
let Im = (e, t) => ({ getLastRender: () => e, update: (n) => {
  if (e.vnodeSelector !== n.vnodeSelector)
    throw new Error("The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)");
  let r = e;
  e = n, F1(r, n, t);
}, domNode: e.domNode });
const Dre = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e, t, n) => {
  t.charAt(0) === "-" ? e.style.setProperty(t, n) : e.style[t] = n;
} };
let uh = (e) => QO(Dre, e), Gu = { create: (e, t) => (t = uh(t), Uh(e, document.createElement("div"), void 0, t), Im(e, t)), append: (e, t, n) => (n = uh(n), Uh(t, e, void 0, n), Im(t, n)), insertBefore: (e, t, n) => (n = uh(n), Uh(t, e.parentNode, e, n), Im(t, n)), merge: (e, t, n) => (n = uh(n), t.domNode = e, T9(e, t, n), Im(t, n)), replace: (e, t, n) => (n = uh(n), Uh(t, e.parentNode, e, n), e.parentNode.removeChild(e), Im(t, n)) }, E9, jre = (e, t) => {
  let n = [];
  for (; e && e !== t; )
    n.push(e), e = e.parentNode;
  return n;
};
E9 = Array.prototype.find ? (e, t) => e.find(t) : (e, t) => e.filter(t)[0];
let Vre = (e, t) => {
  let n = e;
  return t.forEach((r) => {
    n = n && n.children ? E9(n.children, (i) => i.domNode === r) : void 0;
  }), n;
}, zre = (e, t, n) => {
  let r = function(i) {
    n("domEvent", i);
    let s = t(), o = jre(i.currentTarget, s.domNode);
    o.reverse();
    let a, l = Vre(s.getLastRender(), o);
    return e.scheduleRender(), l && (a = l.properties[`on${i.type}`].apply(l.properties.bind || this, arguments)), n("domEventProcessed", i), a;
  };
  return (i, s, o, a) => r;
}, dR = (e) => {
  let t, n, r = uh(e), i = r.performanceLogger, s = !0, o = !1, a = [], l = [], c = (f, m, y) => {
    let g, v = () => g;
    r.eventHandlerInterceptor = zre(t, v, i), g = f(m, y(), r), a.push(g), l.push(y);
  }, p = () => {
    if (n = void 0, s) {
      s = !1, i("renderStart", void 0);
      for (let f = 0; f < a.length; f++) {
        let m = l[f]();
        i("rendered", void 0), a[f].update(m), i("patched", void 0);
      }
      i("renderDone", void 0), s = !0;
    }
  };
  return t = { renderNow: p, scheduleRender: () => {
    n || o || (n = requestAnimationFrame(p));
  }, stop: () => {
    n && (cancelAnimationFrame(n), n = void 0), o = !0;
  }, resume: () => {
    o = !1, s = !0, t.scheduleRender();
  }, append: (f, m) => {
    c(Gu.append, f, m);
  }, insertBefore: (f, m) => {
    c(Gu.insertBefore, f, m);
  }, merge: (f, m) => {
    c(Gu.merge, f, m);
  }, replace: (f, m) => {
    c(Gu.replace, f, m);
  }, detach: (f) => {
    for (let m = 0; m < l.length; m++)
      if (l[m] === f)
        return l.splice(m, 1), a.splice(m, 1)[0];
    throw new Error("renderFunction was not found");
  } }, t;
}, fu = class extends ke {
  constructor() {
    super(...arguments), this.items = new Ne(), this._watchUpdatingTracking = new ef(), this._callbacks = /* @__PURE__ */ new Map(), this._projector = dR(), this._hiddenProjector = dR();
  }
  get needsRender() {
    return this.items.length > 0;
  }
  initialize() {
    const t = document.createElement("div");
    t.className = "geoscene-overlay-surface", this._set("surface", t), this._hiddenSurface = document.createElement("div"), this._hiddenSurface.setAttribute("style", "visibility: hidden;"), t.appendChild(this._hiddenSurface), this._watchUpdatingTracking.addOnCollectionChange(() => this.items, (n) => {
      for (const r of n.added) {
        const i = () => r.render();
        this._callbacks.set(r, i), this._projector.append(this.surface, i);
      }
      for (const r of n.removed) {
        const i = this._projector.detach(this._callbacks.get(r));
        this.surface.removeChild(i.domNode), this._callbacks.delete(r);
      }
    });
  }
  addItem(t) {
    this.items.add(t);
  }
  removeItem(t) {
    this.items.remove(t);
  }
  destroy() {
    this.items.removeAll(), this._callbacks.forEach((t) => this._projector.detach(t)), this._callbacks = null, this._projector = null, this._watchUpdatingTracking.destroy();
  }
  render() {
    this._projector.renderNow();
  }
  computeBoundingRect(t) {
    const n = this._hiddenSurface, r = this._hiddenProjector;
    let i = null;
    const s = () => (i = t.render(), i);
    r.append(n, s), r.renderNow();
    const o = { left: 0, top: 0, right: 0, bottom: 0 };
    if (i && i.domNode) {
      const a = i.domNode.getBoundingClientRect();
      o.left = a.left, o.top = a.top, o.right = a.right, o.bottom = a.bottom;
    }
    for (r.detach(s); n.firstChild; )
      n.removeChild(n.firstChild);
    return o;
  }
  overlaps(t, n) {
    const r = this.computeBoundingRect(t), i = this.computeBoundingRect(n);
    return Math.max(r.left, i.left) <= Math.min(r.right, i.right) && Math.max(r.top, i.top) <= Math.min(r.bottom, i.bottom);
  }
  get hasVisibleItems() {
    return this.items.some((t) => t.visible);
  }
  renderCanvas(t) {
    if (!this.items.some((r) => r.visible))
      return;
    const n = t.getContext("2d");
    n.save(), n.font = `10px ${getComputedStyle(this.surface).fontFamily}`, this.items.forEach((r) => {
      n.save(), r.renderCanvas(n), n.restore();
    }), n.restore();
  }
};
u([d({ readOnly: !0 })], fu.prototype, "surface", void 0), u([d({ readOnly: !0 })], fu.prototype, "items", void 0), u([d({ readOnly: !0 })], fu.prototype, "needsRender", null), u([d({ readOnly: !0 })], fu.prototype, "_watchUpdatingTracking", void 0), u([d({ readOnly: !0, aliasOf: "_watchUpdatingTracking.updating" })], fu.prototype, "updating", void 0), fu = u([T("geoscene.views.overlay.ViewOverlay")], fu);
const pR = fu;
function ek(e, t, n, r) {
  let i = null, s = 1e3;
  typeof t == "number" ? (s = t, r = n) : (i = t ?? null, s = n);
  let o, a = 0;
  const l = () => {
    a = 0, e.apply(r, o);
  }, c = (...p) => {
    i && i.apply(r, p), o = p, s ? a || (a = setTimeout(l, s)) : l();
  };
  return c.remove = () => {
    a && (clearTimeout(a), a = 0);
  }, c.forceUpdate = () => {
    a && (clearTimeout(a), l());
  }, c.hasPendingUpdates = () => !!a, c;
}
const Bre = /\?(\.|$)/g;
function gn(e, t, n, r) {
  const i = Array.isArray(t) ? t : t.indexOf(",") > -1 ? t.split(",") : [t], s = Lt(e, t, n, r);
  for (const o of i) {
    const a = o.trim().replace(Bre, "$1"), l = e.get(a);
    n.call(e, l, l, a, e);
  }
  return s;
}
function Lt(e, t, n, r) {
  return e.watch(t, n, r);
}
function I9(e, t, n, r) {
  return C0(e, t, Hre, n, r);
}
function Ure(e, t, n, r) {
  return C0(e, t, M9, n, r);
}
function tLe(e, t, n, r) {
  return Wre(e, t, M9, n, r);
}
function qre(e, t, n, r) {
  return C0(e, t, Jre, n, r);
}
function LE(e, t, n, r) {
  return C0(e, t, Zre, n, r);
}
function Gre(e, t, n, r) {
  let i = !1;
  const s = e.watch(t, (o, a, l, c) => {
    i || n.call(e, o, a, l, c);
  }, r);
  return { remove() {
    s.remove();
  }, pause() {
    i = !0;
  }, resume() {
    i = !1;
  } };
}
function gS(e, t, n, r, i, s, o) {
  const a = {};
  function l(p) {
    const f = a[p];
    f && (s && s(f.target, p, e, n), f.handle.remove(), delete a[p]);
  }
  const c = gn(e, t, (p, f, m) => {
    l(m), B_(p) && (a[m] = { handle: U_(p, n, r), target: p }, i && i(p, m, e, n));
  }, o);
  return { remove() {
    c.remove();
    for (const p in a)
      l(p);
  } };
}
function C0(e, t, n, r, i) {
  const s = e.watch(t, (o, a, l, c) => {
    n && !n(o) || r == null || r.call(e, o, a, l, c);
  }, i);
  if (Array.isArray(t))
    for (const o of t) {
      const a = e.get(o);
      n && n(a) && (r == null || r.call(e, a, a, t, e));
    }
  else {
    const o = e.get(t);
    n && n(o) && (r == null || r.call(e, o, o, t, e));
  }
  return s;
}
function Wre(e, t, n, r, i) {
  const s = typeof r == "function" ? r : null, o = typeof r == "object" ? r : null;
  typeof r == "boolean" && (i = r);
  let a, l = !1;
  function c() {
    a && (a.remove(), a = null);
  }
  const p = Cl();
  Ao(o, () => {
    c(), p.reject(Cn());
  });
  const f = { then: p.promise.then.bind(p.promise), catch: p.promise.catch.bind(p.promise), remove: c };
  return Object.freeze(f), a = C0(e, t, n, (m, y, g, v) => {
    l = !0, c(), s && s.call(e, m, y, g, v), p.resolve({ value: m, oldValue: y, propertyName: g, target: v });
  }, i), l && c(), f;
}
function Hre(e) {
  return !!e;
}
function M9(e) {
  return !e;
}
function Jre(e) {
  return e === !0;
}
function Zre(e) {
  return e === !1;
}
function Le(e, t) {
  const n = t ? { ...t, source: e } : e;
  return d({ aliasOf: n });
}
function Kre() {
  const e = crypto.getRandomValues(new Uint16Array(8));
  e[3] = 4095 & e[3] | 16384, e[4] = 16383 & e[4] | 32768;
  const t = (n) => e[n].toString(16);
  return t(0) + t(1) + "-" + t(2) + "-" + t(3) + "-" + t(4) + "-" + t(5) + t(6) + t(7);
}
const Yre = { handleInterceptedEvent: (e, t, n, r) => (e.scheduleRender(), t.properties[`on${r.type}`].apply(t.properties.bind || n, [r])) }, Qre = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e, t, n) => {
  e.style[t] = n;
} }, Xre = (e) => ({ ...Qre, ...e }), eie = (e, t) => {
  const n = [];
  for (; e && e !== t; )
    n.push(e), e = e.parentNode;
  return n;
}, tie = (e, t) => e.find(t), hR = (e, t, n = !1) => {
  let r = e;
  return t.forEach((i, s) => {
    var o;
    const a = (o = r) != null && o.children ? tie(r.children, (l) => l.domNode === i) : void 0;
    n && !a && s !== t.length - 1 || (r = a);
  }), r;
}, nie = (e) => {
  let t;
  const n = { ...Yre, ...e }, r = Xre(n), i = r.performanceLogger;
  let s, o = !0, a = !1;
  const l = [], c = [], p = (m, y, g) => {
    let v;
    r.eventHandlerInterceptor = (b, S, $, I) => function(M) {
      let E;
      i("domEvent", M);
      const C = eie(M.currentTarget, v.domNode), A = C.some((j) => {
        var G;
        return customElements.get(j == null || (G = j.tagName) == null ? void 0 : G.toLowerCase());
      });
      if (M.eventPhase === Event.CAPTURING_PHASE || !A)
        C.reverse(), E = hR(v.getLastRender(), C);
      else {
        const j = M.composedPath(), G = j.slice(j.indexOf(M.currentTarget), j.indexOf(v.domNode)).filter((R) => R.getRootNode() === R.ownerDocument).reverse();
        E = hR(v.getLastRender(), G, !0);
      }
      let W;
      return E && (W = n.handleInterceptedEvent(t, E, this, M)), i("domEventProcessed", M), W;
    }, n.postProcessProjectionOptions == null || n.postProcessProjectionOptions(r);
    const w = g();
    v = m(y, w, r), l.push(v), c.push(g), n.afterFirstVNodeRendered && n.afterFirstVNodeRendered(v, w);
  };
  let f = () => {
    if (s = void 0, o) {
      o = !1, i("renderStart", void 0);
      for (let m = 0; m < l.length; m++) {
        const y = c[m]();
        i("rendered", void 0), l[m].update(y), i("patched", void 0);
      }
      i("renderDone", void 0), o = !0;
    }
  };
  return n.modifyDoRenderImplementation && (f = n.modifyDoRenderImplementation(f, l, c)), t = { renderNow: f, scheduleRender: () => {
    s || a || (s = requestAnimationFrame(f));
  }, stop: () => {
    s && (cancelAnimationFrame(s), s = void 0), a = !0;
  }, resume: () => {
    a = !1, o = !0, t.scheduleRender();
  }, append: (m, y) => {
    p(Gu.append, m, y);
  }, insertBefore: (m, y) => {
    p(Gu.insertBefore, m, y);
  }, merge: (m, y) => {
    p(Gu.merge, m, y);
  }, replace: (m, y) => {
    p(Gu.replace, m, y);
  }, detach: (m) => {
    for (let y = 0; y < c.length; y++)
      if (c[y] === m)
        return c.splice(y, 1), l.splice(y, 1)[0];
    throw new Error("renderFunction was not found");
  } }, t;
}, ch = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  appendChildSlotFix: !1,
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  safari10: !1,
  scriptDataOpts: !1,
  scopedSlotTextContentFix: !1,
  shadowDomShim: !1,
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  cssVarShim: !1,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  dynamicImportShim: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0
};
let dh, C9, vS, O9 = !1, N1 = !1, tk = !1, Wi = !1, fR = null, FE = !1;
const O0 = typeof window < "u" ? window : {}, wa = O0.document || { head: {} }, nLe = O0.HTMLElement || class {
}, Sr = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, n, r) => e.addEventListener(t, n, r),
  rel: (e, t, n, r) => e.removeEventListener(t, n, r),
  ce: (e, t) => new CustomEvent(e, t)
}, rie = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    wa.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), iie = (e) => Promise.resolve(e), sie = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replace == "function";
  } catch {
  }
  return !1;
})(), k9 = (e, t, n, r) => {
  n && n.map(([i, s, o]) => {
    const a = aie(e, i), l = oie(t, o), c = lie(i);
    Sr.ael(a, s, l, c), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => Sr.rel(a, s, l, c));
  });
}, oie = (e, t) => (n) => {
  try {
    ch.lazyLoad || e.$hostElement$[t](n);
  } catch (r) {
    A0(r);
  }
}, aie = (e, t) => t & 4 ? wa : t & 8 ? O0 : t & 16 ? wa.body : e, lie = (e) => rie ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, mR = "http://www.w3.org/1999/xlink", pp = (e, t = "") => () => {
}, yR = /* @__PURE__ */ new WeakMap(), uie = (e, t, n) => {
  let r = V1.get(e);
  sie && n ? (r = r || new CSSStyleSheet(), r.replace(t)) : r = t, V1.set(e, r);
}, cie = (e, t, n, r) => {
  let i = A9(t, n), s = V1.get(i);
  if (e = e.nodeType === 11 ? e : wa, s)
    if (typeof s == "string") {
      e = e.head || e;
      let o = yR.get(e), a;
      o || yR.set(e, o = /* @__PURE__ */ new Set()), o.has(i) || (a = wa.createElement("style"), a.innerHTML = s, e.insertBefore(a, e.querySelector("link")), o && o.add(i));
    } else
      e.adoptedStyleSheets.includes(s) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, s]);
  return i;
}, die = (e) => {
  const t = e.$cmpMeta$, n = e.$hostElement$, r = t.$flags$, i = pp("attachStyles", t.$tagName$), s = cie(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$);
  r & 10 && (n["s-sc"] = s, n.classList.add(s + "-h"), r & 2 && n.classList.add(s + "-s")), i();
}, A9 = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), pie = (e) => zie.map((t) => t(e)).find((t) => !!t), gR = {}, hie = "http://www.w3.org/2000/svg", fie = "http://www.w3.org/1999/xhtml", mie = (e) => e != null, nk = (e) => (e = typeof e, e === "object" || e === "function"), P9 = (e, t, ...n) => {
  let r = null, i = null, s = null, o = !1, a = !1, l = [];
  const c = (f) => {
    for (let m = 0; m < f.length; m++)
      r = f[m], Array.isArray(r) ? c(r) : r != null && typeof r != "boolean" && ((o = typeof e != "function" && !nk(r)) && (r = String(r)), o && a ? l[l.length - 1].$text$ += r : l.push(o ? D1(null, r) : r), a = o);
  };
  if (c(n), t) {
    t.key && (i = t.key), t.name && (s = t.name);
    {
      const f = t.className || t.class;
      f && (t.class = typeof f != "object" ? f : Object.keys(f).filter((m) => f[m]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, l, vie);
  const p = D1(e, null);
  return p.$attrs$ = t, l.length > 0 && (p.$children$ = l), p.$key$ = i, p.$name$ = s, p;
}, D1 = (e, t) => {
  const n = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, yie = {}, gie = (e) => e && e.$tag$ === yie, vie = {
  forEach: (e, t) => e.map(vR).forEach(t),
  map: (e, t) => e.map(vR).map(t).map(bie)
}, vR = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), bie = (e) => {
  if (typeof e.vtag == "function") {
    const n = Object.assign({}, e.vattrs);
    return e.vkey && (n.key = e.vkey), e.vname && (n.name = e.vname), P9(e.vtag, n, ...e.vchildren || []);
  }
  const t = D1(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, bR = (e, t, n, r, i, s) => {
  if (n !== r) {
    let o = xR(e, t), a = t.toLowerCase();
    if (t === "class") {
      const l = e.classList, c = wR(n), p = wR(r);
      l.remove(...c.filter((f) => f && !p.includes(f))), l.add(...p.filter((f) => f && !c.includes(f)));
    } else if (t === "style") {
      for (const l in n)
        (!r || r[l] == null) && (l.includes("-") ? e.style.removeProperty(l) : e.style[l] = "");
      for (const l in r)
        (!n || r[l] !== n[l]) && (l.includes("-") ? e.style.setProperty(l, r[l]) : e.style[l] = r[l]);
    } else if (t !== "key")
      if (t === "ref")
        r && r(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n")
        t[2] === "-" ? t = t.slice(3) : xR(O0, a) ? t = a.slice(2) : t = a[2] + t.slice(3), n && Sr.rel(e, t, n, !1), r && Sr.ael(e, t, r, !1);
      else {
        const l = nk(r);
        if ((o || l && r !== null) && !i)
          try {
            if (e.tagName.includes("-"))
              e[t] = r;
            else {
              let p = r ?? "";
              t === "list" ? o = !1 : (n == null || e[t] != p) && (e[t] = p);
            }
          } catch {
          }
        let c = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (t = a, c = !0), r == null || r === !1 ? (r !== !1 || e.getAttribute(t) === "") && (c ? e.removeAttributeNS(mR, t) : e.removeAttribute(t)) : (!o || s & 4 || i) && !l && (r = r === !0 ? "" : r, c ? e.setAttributeNS(mR, t, r) : e.setAttribute(t, r));
      }
  }
}, wie = /\s/, wR = (e) => e ? e.split(wie) : [], R9 = (e, t, n, r) => {
  const i = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, s = e && e.$attrs$ || gR, o = t.$attrs$ || gR;
  for (r in s)
    r in o || bR(i, r, s[r], void 0, n, t.$flags$);
  for (r in o)
    bR(i, r, s[r], o[r], n, t.$flags$);
}, j1 = (e, t, n, r) => {
  let i = t.$children$[n], s = 0, o, a, l;
  if (O9 || (tk = !0, i.$tag$ === "slot" && (dh && r.classList.add(dh + "-s"), i.$flags$ |= i.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), i.$text$ !== null)
    o = i.$elm$ = wa.createTextNode(i.$text$);
  else if (i.$flags$ & 1)
    o = i.$elm$ = wa.createTextNode("");
  else {
    if (Wi || (Wi = i.$tag$ === "svg"), o = i.$elm$ = wa.createElementNS(Wi ? hie : fie, i.$flags$ & 2 ? "slot-fb" : i.$tag$), Wi && i.$tag$ === "foreignObject" && (Wi = !1), R9(null, i, Wi), mie(dh) && o["s-si"] !== dh && o.classList.add(o["s-si"] = dh), i.$children$)
      for (s = 0; s < i.$children$.length; ++s)
        a = j1(e, i, s, o), a && o.appendChild(a);
    i.$tag$ === "svg" ? Wi = !1 : o.tagName === "foreignObject" && (Wi = !0);
  }
  return o["s-hn"] = vS, i.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = C9, o["s-sn"] = i.$name$ || "", l = e && e.$children$ && e.$children$[n], l && l.$tag$ === i.$tag$ && e.$elm$ && Ug(e.$elm$, !1)), o;
}, Ug = (e, t) => {
  Sr.$flags$ |= 1;
  const n = e.childNodes;
  for (let r = n.length - 1; r >= 0; r--) {
    const i = n[r];
    i["s-hn"] !== vS && i["s-ol"] && (N9(i).insertBefore(i, rk(i)), i["s-ol"].remove(), i["s-ol"] = void 0, tk = !0), t && Ug(i, t);
  }
  Sr.$flags$ &= -2;
}, L9 = (e, t, n, r, i, s) => {
  let o = e["s-cr"] && e["s-cr"].parentNode || e, a;
  for (o.shadowRoot && o.tagName === vS && (o = o.shadowRoot); i <= s; ++i)
    r[i] && (a = j1(null, n, i, e), a && (r[i].$elm$ = a, o.insertBefore(a, rk(t))));
}, F9 = (e, t, n, r, i) => {
  for (; t <= n; ++t)
    (r = e[t]) && (i = r.$elm$, V9(r), N1 = !0, i["s-ol"] ? i["s-ol"].remove() : Ug(i, !0), i.remove());
}, _ie = (e, t, n, r) => {
  let i = 0, s = 0, o = 0, a = 0, l = t.length - 1, c = t[0], p = t[l], f = r.length - 1, m = r[0], y = r[f], g, v;
  for (; i <= l && s <= f; )
    if (c == null)
      c = t[++i];
    else if (p == null)
      p = t[--l];
    else if (m == null)
      m = r[++s];
    else if (y == null)
      y = r[--f];
    else if ($v(c, m))
      ph(c, m), c = t[++i], m = r[++s];
    else if ($v(p, y))
      ph(p, y), p = t[--l], y = r[--f];
    else if ($v(c, y))
      (c.$tag$ === "slot" || y.$tag$ === "slot") && Ug(c.$elm$.parentNode, !1), ph(c, y), e.insertBefore(c.$elm$, p.$elm$.nextSibling), c = t[++i], y = r[--f];
    else if ($v(p, m))
      (c.$tag$ === "slot" || y.$tag$ === "slot") && Ug(p.$elm$.parentNode, !1), ph(p, m), e.insertBefore(p.$elm$, c.$elm$), p = t[--l], m = r[++s];
    else {
      for (o = -1, a = i; a <= l; ++a)
        if (t[a] && t[a].$key$ !== null && t[a].$key$ === m.$key$) {
          o = a;
          break;
        }
      o >= 0 ? (v = t[o], v.$tag$ !== m.$tag$ ? g = j1(t && t[s], n, o, e) : (ph(v, m), t[o] = void 0, g = v.$elm$), m = r[++s]) : (g = j1(t && t[s], n, s, e), m = r[++s]), g && N9(c.$elm$).insertBefore(g, rk(c.$elm$));
    }
  i > l ? L9(e, r[f + 1] == null ? null : r[f + 1].$elm$, n, r, s, f) : s > f && F9(t, i, l);
}, $v = (e, t) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : e.$key$ === t.$key$ : !1, rk = (e) => e && e["s-ol"] || e, N9 = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, ph = (e, t) => {
  const n = t.$elm$ = e.$elm$, r = e.$children$, i = t.$children$, s = t.$tag$, o = t.$text$;
  let a;
  o === null ? (Wi = s === "svg" ? !0 : s === "foreignObject" ? !1 : Wi, s === "slot" || R9(e, t, Wi), r !== null && i !== null ? _ie(n, r, t, i) : i !== null ? (e.$text$ !== null && (n.textContent = ""), L9(n, null, t, i, 0, i.length - 1)) : r !== null && F9(r, 0, r.length - 1), Wi && s === "svg" && (Wi = !1)) : (a = n["s-cr"]) ? a.parentNode.textContent = o : e.$text$ !== o && (n.data = o);
}, D9 = (e) => {
  let t = e.childNodes, n, r, i, s, o, a;
  for (r = 0, i = t.length; r < i; r++)
    if (n = t[r], n.nodeType === 1) {
      if (n["s-sr"]) {
        for (o = n["s-sn"], n.hidden = !1, s = 0; s < i; s++)
          if (a = t[s].nodeType, t[s]["s-hn"] !== n["s-hn"] || o !== "") {
            if (a === 1 && o === t[s].getAttribute("slot")) {
              n.hidden = !0;
              break;
            }
          } else if (a === 1 || a === 3 && t[s].textContent.trim() !== "") {
            n.hidden = !0;
            break;
          }
      }
      D9(n);
    }
}, xo = [], j9 = (e) => {
  let t, n, r, i, s, o, a = 0, l = e.childNodes, c = l.length;
  for (; a < c; a++) {
    if (t = l[a], t["s-sr"] && (n = t["s-cr"]) && n.parentNode)
      for (r = n.parentNode.childNodes, i = t["s-sn"], o = r.length - 1; o >= 0; o--)
        n = r[o], !n["s-cn"] && !n["s-nr"] && n["s-hn"] !== t["s-hn"] && (_R(n, i) ? (s = xo.find((p) => p.$nodeToRelocate$ === n), N1 = !0, n["s-sn"] = n["s-sn"] || i, s ? s.$slotRefNode$ = t : xo.push({
          $slotRefNode$: t,
          $nodeToRelocate$: n
        }), n["s-sr"] && xo.map((p) => {
          _R(p.$nodeToRelocate$, n["s-sn"]) && (s = xo.find((f) => f.$nodeToRelocate$ === n), s && !p.$slotRefNode$ && (p.$slotRefNode$ = s.$slotRefNode$));
        })) : xo.some((p) => p.$nodeToRelocate$ === n) || xo.push({
          $nodeToRelocate$: n
        }));
    t.nodeType === 1 && j9(t);
  }
}, _R = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", V9 = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(V9);
}, Sie = (e, t) => {
  const n = e.$hostElement$, r = e.$cmpMeta$, i = e.$vnode$ || D1(null, null), s = gie(t) ? t : P9(null, null, t);
  vS = n.tagName, r.$attrsToReflect$ && (s.$attrs$ = s.$attrs$ || {}, r.$attrsToReflect$.map(([o, a]) => s.$attrs$[a] = n[o])), s.$tag$ = null, s.$flags$ |= 4, e.$vnode$ = s, s.$elm$ = i.$elm$ = n.shadowRoot || n, dh = n["s-sc"], C9 = n["s-cr"], O9 = (r.$flags$ & 1) !== 0, N1 = !1, ph(i, s);
  {
    if (Sr.$flags$ |= 1, tk) {
      j9(s.$elm$);
      let o, a, l, c, p, f, m = 0;
      for (; m < xo.length; m++)
        o = xo[m], a = o.$nodeToRelocate$, a["s-ol"] || (l = wa.createTextNode(""), l["s-nr"] = a, a.parentNode.insertBefore(a["s-ol"] = l, a));
      for (m = 0; m < xo.length; m++)
        if (o = xo[m], a = o.$nodeToRelocate$, o.$slotRefNode$) {
          for (c = o.$slotRefNode$.parentNode, p = o.$slotRefNode$.nextSibling, l = a["s-ol"]; l = l.previousSibling; )
            if (f = l["s-nr"], f && f["s-sn"] === a["s-sn"] && c === f.parentNode && (f = f.nextSibling, !f || !f["s-nr"])) {
              p = f;
              break;
            }
          (!p && c !== a.parentNode || a.nextSibling !== p) && a !== p && (!a["s-hn"] && a["s-ol"] && (a["s-hn"] = a["s-ol"].parentNode.nodeName), c.insertBefore(a, p));
        } else
          a.nodeType === 1 && (a.hidden = !0);
    }
    N1 && D9(s.$elm$), Sr.$flags$ &= -2, xo.length = 0;
  }
}, xie = (e) => e, rLe = (e, t, n) => {
  const r = xie(e);
  return {
    emit: (i) => $ie(r, t, {
      bubbles: !!(n & 4),
      composed: !!(n & 2),
      cancelable: !!(n & 1),
      detail: i
    })
  };
}, $ie = (e, t, n) => {
  const r = Sr.ce(t, n);
  return e.dispatchEvent(r), r;
}, Tie = (e, t) => {
}, ik = (e, t) => (e.$flags$ |= 16, Tie(e, e.$ancestorComponent$), qie(() => Eie(e, t))), Eie = (e, t) => {
  const n = e.$hostElement$, r = pp("scheduleUpdate", e.$cmpMeta$.$tagName$), i = n;
  let s;
  return t ? s = rf(i, "componentWillLoad") : s = rf(i, "componentWillUpdate"), s = SR(s, () => rf(i, "componentWillRender")), r(), SR(s, () => Iie(e, i, t));
}, Iie = async (e, t, n) => {
  const r = e.$hostElement$, i = pp("update", e.$cmpMeta$.$tagName$);
  r["s-rc"], n && die(e);
  const s = pp("render", e.$cmpMeta$.$tagName$);
  Mie(e, t, r), s(), i(), Cie(e);
}, Mie = (e, t, n) => {
  try {
    fR = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (ch.hasRenderFn || ch.reflect) && (ch.vdomRender || ch.reflect) && (ch.hydrateServerSide || Sie(e, t));
  } catch (a) {
    A0(a, e.$hostElement$);
  }
  return fR = null, null;
}, Cie = (e) => {
  const t = e.$cmpMeta$.$tagName$, n = e.$hostElement$, r = pp("postUpdate", t), i = n;
  e.$ancestorComponent$, rf(i, "componentDidRender"), e.$flags$ & 64 ? (rf(i, "componentDidUpdate"), r()) : (e.$flags$ |= 64, rf(i, "componentDidLoad"), r());
}, iLe = (e) => {
  {
    const t = k0(e), n = t.$hostElement$.isConnected;
    return n && (t.$flags$ & 18) === 2 && ik(t, !1), n;
  }
}, rf = (e, t, n) => {
  if (e && e[t])
    try {
      return e[t](n);
    } catch (r) {
      A0(r);
    }
}, SR = (e, t) => e && e.then ? e.then(t) : t(), Oie = (e, t) => e != null && !nk(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, kie = (e, t) => k0(e).$instanceValues$.get(t), Aie = (e, t, n, r) => {
  const i = k0(e), s = e, o = i.$instanceValues$.get(t), a = i.$flags$, l = s;
  if (n = Oie(n, r.$members$[t][0]), n !== o) {
    i.$instanceValues$.set(t, n);
    {
      if (r.$watchers$ && a & 128) {
        const c = r.$watchers$[t];
        c && c.map((p) => {
          try {
            l[p](n, o, t);
          } catch (f) {
            A0(f, s);
          }
        });
      }
      if ((a & 18) === 2) {
        if (l.componentShouldUpdate && l.componentShouldUpdate(n, o, t) === !1)
          return;
        ik(i, !1);
      }
    }
  }
}, Pie = (e, t, n) => {
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const r = Object.entries(t.$members$), i = e.prototype;
    r.map(([s, [o]]) => {
      (o & 31 || o & 32) && Object.defineProperty(i, s, {
        get() {
          return kie(this, s);
        },
        set(a) {
          Aie(this, s, a, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const s = /* @__PURE__ */ new Map();
      i.attributeChangedCallback = function(o, a, l) {
        Sr.jmp(() => {
          const c = s.get(o);
          if (this.hasOwnProperty(c))
            l = this[c], delete this[c];
          else if (i.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == l)
            return;
          this[c] = l === null && typeof this[c] == "boolean" ? !1 : l;
        });
      }, e.observedAttributes = r.filter(
        ([o, a]) => a[0] & 15
        /* HasAttribute */
      ).map(([o, a]) => {
        const l = a[1] || o;
        return s.set(l, o), a[0] & 512 && t.$attrsToReflect$.push([o, l]), l;
      });
    }
  }
  return e;
}, Rie = async (e, t, n, r, i) => {
  if (!(t.$flags$ & 32) && (i = e.constructor, t.$flags$ |= 32, customElements.whenDefined(n.$tagName$).then(() => t.$flags$ |= 128), i.style)) {
    let o = i.style;
    typeof o != "string" && (o = o[t.$modeName$ = pie(e)]);
    const a = A9(n, t.$modeName$);
    if (!V1.has(a)) {
      const l = pp("registerStyles", n.$tagName$);
      uie(a, o, !!(n.$flags$ & 1)), l();
    }
  }
  t.$ancestorComponent$, ik(t, !0);
}, Lie = (e) => {
}, Fie = (e) => {
  if (!(Sr.$flags$ & 1)) {
    const t = k0(e), n = t.$cmpMeta$, r = pp("connectedCallback", n.$tagName$);
    t.$flags$ & 1 ? (k9(e, t, n.$listeners$), Lie(t.$lazyInstance$)) : (t.$flags$ |= 1, n.$flags$ & 12 && Nie(e), n.$members$ && Object.entries(n.$members$).map(([i, [s]]) => {
      if (s & 31 && e.hasOwnProperty(i)) {
        const o = e[i];
        delete e[i], e[i] = o;
      }
    }), Rie(e, t, n)), r();
  }
}, Nie = (e) => {
  const t = e["s-cr"] = wa.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Die = (e) => {
  if (!(Sr.$flags$ & 1)) {
    const t = k0(e);
    t.$rmListeners$ && (t.$rmListeners$.map((n) => n()), t.$rmListeners$ = void 0);
  }
}, sLe = (e, t) => {
  const n = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  n.$members$ = t[2], n.$listeners$ = t[3], n.$watchers$ = e.$watchers$, n.$attrsToReflect$ = [];
  const r = e.prototype.connectedCallback, i = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      Vie(this, n);
    },
    connectedCallback() {
      Fie(this), r && r.call(this);
    },
    disconnectedCallback() {
      Die(this), i && i.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      });
    }
  }), e.is = n.$tagName$, Pie(e, n);
}, oLe = (e) => {
  const t = new URL(e, Sr.$resourcesUrl$);
  return t.origin !== O0.location.origin ? t.href : t.pathname;
}, jie = (e) => Sr.$resourcesUrl$ = e, z9 = /* @__PURE__ */ new WeakMap(), k0 = (e) => z9.get(e), Vie = (e, t) => {
  const n = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return k9(e, n, t.$listeners$), z9.set(e, n);
}, xR = (e, t) => t in e, A0 = (e, t) => (0, console.error)(e, t), V1 = /* @__PURE__ */ new Map(), zie = [], $R = [], B9 = [], Bie = (e, t) => (n) => {
  e.push(n), FE || (FE = !0, t && Sr.$flags$ & 4 ? Uie(NE) : Sr.raf(NE));
}, TR = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (n) {
      A0(n);
    }
  e.length = 0;
}, NE = () => {
  TR($R), TR(B9), (FE = $R.length > 0) && Sr.raf(NE);
}, Uie = (e) => iie().then(e), qie = /* @__PURE__ */ Bie(B9, !0);
let U9;
function Gie() {
  jie(To(ma(U9)));
}
U9 = "components/assets";
const q9 = Symbol("widget"), Wie = [], Hie = {}, z1 = /* @__PURE__ */ new WeakMap();
function G9(e, t) {
  let n = t.children;
  if (n && n.length)
    for (let i = 0; i < n.length; ++i)
      n[i] = G9(e, n[i]);
  else
    n = Wie;
  const r = t.vnodeSelector;
  if (sk(r)) {
    const i = t.properties || Hie, s = i.key || r;
    return { vnodeSelector: "div", properties: { key: s, afterCreate: Jie, afterUpdate: Zie, afterRemoved: W9, parentWidget: e, widgetConstructor: r, widgetProperties: { ...i, key: s, children: n } }, children: void 0, text: void 0, domNode: null };
  }
  return t;
}
function Jie(e, t, n, { parentWidget: r, widgetConstructor: i, widgetProperties: s }) {
  const o = new i(s);
  o.container = e, z1.set(e, o), o.afterCreate == null || o.afterCreate(o, e), r._internalHandles.add(Vf(() => W9(e)));
}
function Zie(e, t, n, { widgetProperties: r }) {
  const i = z1.get(e);
  i && (i.set(r), i.afterUpdate == null || i.afterUpdate(i, e));
}
function W9(e) {
  const t = z1.get(e);
  t && (t.destroy(), z1.delete(e));
}
function sk(e) {
  return typeof e == "function" && e[q9];
}
function H9() {
  return getComputedStyle(document.body).getPropertyValue("--geoscene-calcite-theme-name").replace(/\s|'|"/g, "");
}
function J9() {
  return H9().startsWith("dark");
}
function Kie() {
  return "calcite-theme-" + (J9() ? "dark" : "light");
}
const Z9 = "geoscene.widgets.Widget", ER = we.getLogger(Z9);
let Yie = 0;
const Qie = { widgetIcon: "geoscene-icon-checkbox-unchecked" };
function K9(e, t) {
  for (const n in t)
    e[n] != null && (typeof e[n] == "object" && typeof t[n] == "object" ? K9(e[n], t[n]) : e[n] = t[n]);
  return e;
}
const Xie = nie({ postProcessProjectionOptions(e) {
  const t = e.eventHandlerInterceptor, n = /capture$/i;
  e.eventHandlerInterceptor = (r, i, s, o) => {
    const a = t(r, i, s, o), l = n.test(r);
    if (!((r = r.replace(n, "")).toLowerCase() in s) || l) {
      const c = r[2].toLowerCase() + r.slice(3), p = (y) => a.call(s, y);
      s.addEventListener(c, p, l);
      const f = () => s.removeEventListener(c, p, l), m = o.afterRemoved;
      o.afterRemoved = (y) => {
        m == null || m(y), f();
      };
    }
    return a;
  };
}, handleInterceptedEvent(e, t, n, r) {
  const { eventPhase: i, type: s } = r, o = i === Event.CAPTURING_PHASE;
  let a = `on${s}${o ? "capture" : ""}`;
  const l = t.properties;
  (a in l || (a = `on${s[0].toUpperCase()}${s.slice(1)}${o ? "Capture" : ""}`, a in l)) && (g9(), e.scheduleRender(), l[a].call(l.bind || n, r));
} });
let W2 = !1, Fn = class extends Z_(mc.EventedAccessor) {
  constructor(t, n) {
    super(t, n), this._attached = !1, this._internalHandles = new ei(), this._projector = Xie, this._readyForTrueRender = !1, this.domNode = null, this.iconClass = Qie.widgetIcon, this.label = this.declaredClass.split(".").pop(), this.visible = !0, this.key = this, this._loadLocale = QD(async () => {
      if (this._messageBundleProps && this._messageBundleProps.length) {
        const l = await Ii(this._messageBundleProps.map(async ({ bundlePath: c, propertyName: p }) => {
          let f = await o6(c);
          this.uiStrings && Object.keys(this.uiStrings) && (f = K9(q(f), this.uiStrings)), this[p] = f;
        }));
        for (const c of l)
          c.error && ER.error("widget-intl:locale-error", this.declaredClass, c.error);
      }
      await this.loadLocale();
    }), Gie();
    const r = ["light", "dark"], i = H9() || "light";
    r.includes(i) || D_(ER, "The following themes are deprecated: light-blue, dark-blue, light-green, dark-green, light-purple, dark-purple, light-red, and dark-red.", { version: "4.19", warnOnce: !0, see: "https://doc.geoscene.cn/javascript/4.23/styling/" });
    const s = "geoscene-widget-uid-" + Kre(), o = this.render.bind(this);
    this._trackingTarget = new W_(() => this.scheduleRender());
    const a = () => {
      var l;
      if (!this._readyForTrueRender || this.destroyed)
        return null;
      if (!this.visible)
        return { vnodeSelector: "div", properties: { key: s, class: "", styles: { display: "none" } }, domNode: void 0, children: void 0, text: void 0 };
      const c = o();
      let { properties: p } = c;
      p || (c.properties = p = {});
      let { key: f, styles: m } = p;
      f || (p.key = s), m || (p.styles = m = {}), m.display || (m.display = "");
      let y = 0;
      return (l = c.children) == null || l.forEach((g) => {
        if (sk(g.vnodeSelector))
          return;
        let { properties: v } = g;
        v || (g.properties = v = {}), v.key || (v.key = `${this.id}--${y++}`);
      }), G9(this, c);
    };
    this.render = () => {
      if (W2)
        return a();
      let l = _re(this);
      if (l)
        return l;
      this._trackingTarget.clear(), W2 = !0;
      try {
        l = Ml(this._trackingTarget, a);
      } finally {
        W2 = !1;
      }
      return Sre(this, l), l;
    }, this.addResolvingPromise(this._resourcesFetch = this.beforeFirstRender().then(() => {
      this._readyForTrueRender = !0, this._postInitialize();
    }));
  }
  normalizeCtorArgs(t, n) {
    const r = { ...t };
    return n && (r.container = n), r;
  }
  postInitialize() {
  }
  beforeFirstRender() {
    return Promise.all([this.loadDependencies(), this._loadLocale()]).then(() => {
    }).catch(O$);
  }
  async loadDependencies() {
  }
  async loadLocale() {
  }
  destroy() {
    this.destroyed || (this._trackingTarget = pa(this._trackingTarget), this.viewModel = pa(this.viewModel), this._detach(this.container), this._set("container", null), this._internalHandles.destroy(), this._emitter.clear(), this.render = () => null, this._projector = null, q2(this));
  }
  set container(t) {
    this._get("container") || this._set("container", t);
  }
  castContainer(t) {
    return KO(t);
  }
  get id() {
    return this._get("id") || this.get("container.id") || Date.now().toString(16) + "-widget-" + Yie++;
  }
  set id(t) {
    t && this._set("id", t);
  }
  get renderable() {
    return this._resourcesFetch;
  }
  get test() {
    return { projector: this._projector, handles: this._internalHandles };
  }
  render() {
    throw new Error("not implemented");
  }
  scheduleRender() {
    this.destroyed || (q2(this), this._projector.scheduleRender());
  }
  classes(...t) {
    return b9.apply(this, t);
  }
  own(t) {
    arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), this._internalHandles.add(t);
  }
  renderNow() {
    q2(this), this._projector.renderNow();
  }
  _postInitialize() {
    var t;
    if (this.destroyed)
      return;
    this.scheduleRender(), (t = this._delegatedEventNames) != null && t.length && this._internalHandles.add(Nt(() => this.viewModel, (r, i) => {
      i && this._internalHandles.remove("delegated-events"), r && this._internalHandles.add(this._delegatedEventNames.map((s) => r.on(s, (o) => {
        this.emit(s, o);
      })), "delegated-events");
    }, va)), this.postInitialize();
    const n = async () => {
      await this._loadLocale().catch(O$), this.scheduleRender();
    };
    this._internalHandles.add([NY(n), Nt(() => this.uiStrings, n), rS(() => this.container, (r) => {
      this.destroyed || this._attach(r);
    }, { initial: !0, once: !0 })]);
  }
  _attach(t) {
    t && (this._projector.merge(t, this.render), this._attached = !0);
  }
  _detach(t) {
    t && this._attached && (this._projector.detach(this.render), t.parentNode && t.parentNode.removeChild(t), this._attached = !1);
  }
};
Fn[q9] = !0, u([d()], Fn.prototype, "_readyForTrueRender", void 0), u([d({ value: null })], Fn.prototype, "container", null), u([mt("container")], Fn.prototype, "castContainer", null), u([d({ aliasOf: "container" })], Fn.prototype, "domNode", void 0), u([d()], Fn.prototype, "iconClass", void 0), u([d()], Fn.prototype, "id", null), u([d()], Fn.prototype, "label", void 0), u([d()], Fn.prototype, "renderable", null), u([d()], Fn.prototype, "uiStrings", void 0), u([d()], Fn.prototype, "viewModel", void 0), u([d()], Fn.prototype, "visible", void 0), u([d()], Fn.prototype, "key", void 0), u([d()], Fn.prototype, "children", void 0), u([d()], Fn.prototype, "afterCreate", void 0), u([d()], Fn.prototype, "afterUpdate", void 0), u([d()], Fn.prototype, "afterRemoved", void 0), Fn = u([T(Z9)], Fn);
const ti = Fn;
function ese(e) {
  return 32 + e.length;
}
function tse() {
  return 16;
}
function lLe(e) {
  if (!e)
    return 0;
  let t = 32;
  for (const n in e)
    if (e.hasOwnProperty(n)) {
      const r = e[n];
      switch (typeof r) {
        case "string":
          t += ese(r);
          break;
        case "number":
          t += tse();
          break;
        case "boolean":
          t += 4;
      }
    }
  return t;
}
function uLe(e, t) {
  return 32 + e.length * t;
}
var B1;
(function(e) {
  e[e.KILOBYTES = 1024] = "KILOBYTES", e[e.MEGABYTES = 1048576] = "MEGABYTES", e[e.GIGABYTES = 1073741824] = "GIGABYTES";
})(B1 || (B1 = {}));
const IR = ["B", "kB", "MB", "GB", "TB"];
function nse(e, t) {
  let n = t === 0 ? 0 : Math.floor(Math.log(t) / Math.log(B1.KILOBYTES));
  n = js(n, 0, IR.length - 1);
  const r = op(t / B1.KILOBYTES ** n, { maximumFractionDigits: 2 });
  return Ta(e.units.bytes[IR[n]], { fileSize: r });
}
function rse(e) {
  const { exifInfo: t, exifName: n, tagName: r } = e;
  if (!t || !n || !r)
    return null;
  const i = t.find((s) => s.name === n);
  return i ? ise({ tagName: r, tags: i.tags }) : null;
}
function ise(e) {
  const { tagName: t, tags: n } = e;
  if (!n || !t)
    return null;
  const r = n.find((i) => i.name === t);
  return r && r.value || null;
}
var DE;
const sse = { 1: { id: 1, rotation: 0, mirrored: !1 }, 2: { id: 2, rotation: 0, mirrored: !0 }, 3: { id: 3, rotation: 180, mirrored: !1 }, 4: { id: 4, rotation: 180, mirrored: !0 }, 5: { id: 5, rotation: -90, mirrored: !0 }, 6: { id: 6, rotation: 90, mirrored: !1 }, 7: { id: 7, rotation: 90, mirrored: !0 }, 8: { id: 8, rotation: -90, mirrored: !1 } };
let pi = DE = class extends se {
  constructor(e) {
    super(e), this.contentType = null, this.exifInfo = null, this.id = null, this.globalId = null, this.keywords = null, this.name = null, this.parentGlobalId = null, this.parentObjectId = null, this.size = null, this.url = null;
  }
  get orientationInfo() {
    const { exifInfo: e } = this, t = rse({ exifName: "Exif IFD0", tagName: "Orientation", exifInfo: e });
    return sse[t] || null;
  }
  clone() {
    return new DE({ contentType: this.contentType, exifInfo: this.exifInfo, id: this.id, globalId: this.globalId, keywords: this.keywords, name: this.name, parentGlobalId: this.parentGlobalId, parentObjectId: this.parentObjectId, size: this.size, url: this.url });
  }
};
u([d({ type: String })], pi.prototype, "contentType", void 0), u([d()], pi.prototype, "exifInfo", void 0), u([d({ readOnly: !0 })], pi.prototype, "orientationInfo", null), u([d({ type: Vt })], pi.prototype, "id", void 0), u([d({ type: String })], pi.prototype, "globalId", void 0), u([d({ type: String })], pi.prototype, "keywords", void 0), u([d({ type: String })], pi.prototype, "name", void 0), u([d({ json: { read: !1 } })], pi.prototype, "parentGlobalId", void 0), u([d({ json: { read: !1 } })], pi.prototype, "parentObjectId", void 0), u([d({ type: Vt })], pi.prototype, "size", void 0), u([d({ json: { read: !1 } })], pi.prototype, "url", void 0), pi = DE = u([T("geoscene.layers.support.AttachmentInfo")], pi);
const Y9 = pi;
var jE;
let yr = jE = class extends se {
  constructor(e) {
    super(e), this.attachmentTypes = null, this.attachmentsWhere = null, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.returnMetadata = !1, this.size = null, this.start = null, this.where = null;
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10;
  }
  clone() {
    return new jE(q({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
};
u([d({ type: [String], json: { write: !0 } })], yr.prototype, "attachmentTypes", void 0), u([d({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], yr.prototype, "attachmentsWhere", void 0), u([d({ type: [String], json: { write: !0 } })], yr.prototype, "keywords", void 0), u([d({ type: [Number], json: { write: !0 } })], yr.prototype, "globalIds", void 0), u([d({ json: { write: !0 } })], yr.prototype, "name", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], yr.prototype, "num", void 0), u([d({ type: [Number], json: { write: !0 } })], yr.prototype, "objectIds", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], yr.prototype, "returnMetadata", void 0), u([d({ type: [Number], json: { write: !0 } })], yr.prototype, "size", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], yr.prototype, "start", void 0), u([xe("start"), xe("num")], yr.prototype, "writeStart", null), u([d({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], yr.prototype, "where", void 0), yr = jE = u([T("geoscene.rest.support.AttachmentQuery")], yr), yr.from = kn(yr);
const U1 = yr, ose = "geoscene.widgets.Feature.support.featureUtils", MR = we.getLogger(ose), ase = /href=(""|'')/gi, lse = /(\{([^\{\r\n]+)\})/g, use = /\'/g, Q9 = /^\s*expression\//i, cse = /(\n)/gi, dse = /[\u00A0-\u9999<>\&]/gim, pse = /href\s*=\s*(?:\"([^\"]+)\"|\'([^\']+)\')/gi, hse = /^(?:mailto:|tel:)/, X9 = "relationships/", VE = B6("short-date-short-time");
function eV(e) {
  if (!H(e))
    return e.get("sourceLayer") || e.get("layer");
}
async function q1(e, t) {
  return typeof e == "function" ? e.call(null, t) : e;
}
function tV(e = "") {
  if (e)
    return !hse.test(e.trim().toLowerCase());
}
function nV(e) {
  return !!e && Q9.test(e);
}
function fse(e, t) {
  if (!nV(t) || !e)
    return null;
  const n = t.replace(Q9, "").toLowerCase();
  let r;
  return e.some((i) => i.name.toLowerCase() === n && (r = i, !0)), r;
}
function rV(e, t) {
  const n = fse(t, e == null ? void 0 : e.fieldName);
  return n ? n.title || null : e ? e.label || e.fieldName : null;
}
function mse(e, t) {
  const n = t.get(e.toLowerCase());
  return `{${n && n.fieldName || e}}`;
}
function yse(e) {
  return e.replace(ase, "");
}
function G1(e, t) {
  const n = ok(t, e);
  return n ? n.name : e;
}
function gse(e, t) {
  return e && e.map((n) => G1(n, t));
}
function ok(e, t) {
  return e && typeof e.getField == "function" ? e.getField(t) : null;
}
function iV(e) {
  return `${e}`.trim();
}
function Ad({ attributes: e, globalAttributes: t, layer: n, text: r, expressionAttributes: i, fieldInfoMap: s }) {
  return r ? zE({ formattedAttributes: t, template: _se(r, { ...t, ...i, ...e }, n), fieldInfoMap: s }) : "";
}
function zE({ formattedAttributes: e, template: t, fieldInfoMap: n }) {
  return iV(yse(Ta(Ta(t, (r) => mse(r, n)), e)));
}
function vse(e, t, n = !1) {
  const r = t[e];
  if (typeof r == "string") {
    const i = "%27", s = (n ? encodeURIComponent(r) : r).replace(use, i);
    t[e] = s;
  }
}
function bse(e, t = !1) {
  const n = { ...e };
  return Object.keys(n).forEach((r) => vse(r, n, t)), n;
}
function wse(e, t, n) {
  const r = (t = iV(t)) && t[0] !== "{";
  return Ta(e, bse(n, r));
}
function BE(e, t) {
  return e.replace(lse, (n, r, i) => {
    const s = ok(t, i);
    return s ? `{${s.name}}` : r;
  });
}
function _se(e, t, n) {
  const r = BE(e, n);
  return r && r.replace(pse, (i, s, o) => wse(i, s || o, t));
}
function Sse(e, t) {
  if (typeof e == "string" && t && t.dateFormat == null && (t.places != null || t.digitSeparator != null)) {
    const n = Number(e);
    if (!isNaN(n))
      return n;
  }
  return e;
}
function xse(e) {
  return (e == null ? void 0 : e.type) === "feature";
}
function $se(e) {
  return (e == null ? void 0 : e.type) === "map-image";
}
function Tse(e) {
  return !(e == null || !e.layer);
}
function sV(e, t) {
  const n = t.fieldInfos, r = t.fieldName, i = oV(n, r), s = i == null ? void 0 : i.clone(), o = t.preventPlacesFormatting, a = t.layer, l = ok(a, r);
  if (s && (l == null ? void 0 : l.type) === "date") {
    const p = s.format || new Xy();
    p.dateFormat = p.dateFormat || "short-date-short-time", p.dateTimeFormatOptions = xse(a) && a.datesInUnknownTimezone || Tse(a) && $se(a.layer) && a.layer.datesInUnknownTimezone ? { timeZone: "UTC" } : null, s.format = p;
  }
  const c = s && s.format;
  return typeof (e = Sse(e, c)) == "string" || e == null || c == null ? P0(e) : o ? op(e, { ...q6(c), minimumFractionDigits: 0, maximumFractionDigits: 20 }) : c.format(e);
}
function oV(e, t) {
  if (!e || !e.length || !t)
    return;
  const n = t.toLowerCase();
  let r;
  return e.some((i) => !(!i.fieldName || i.fieldName.toLowerCase() !== n) && (r = i, !0)), r;
}
function Ese({ fieldName: e, graphic: t, layer: n }) {
  if (_l(e) || !n || typeof n.getFeatureType != "function")
    return null;
  const { typeIdField: r } = n;
  if (!r || e !== r)
    return null;
  const i = n.getFeatureType(t);
  return i ? i.name : null;
}
function Ise({ fieldName: e, value: t, graphic: n, layer: r }) {
  if (_l(e) || !r || typeof r.getFieldDomain != "function")
    return null;
  const i = r.getFieldDomain(e, { feature: n });
  return i && i.type === "coded-value" ? i.getName(t) : null;
}
function Mse(e, t) {
  const { creatorField: n, creationDateField: r, editorField: i, editDateField: s } = e;
  if (!t)
    return;
  const o = t[s];
  if (typeof o == "number") {
    const l = t[i];
    return { type: "edit", date: nc(o, VE), user: l };
  }
  const a = t[r];
  if (typeof a == "number") {
    const l = t[n];
    return { type: "create", date: nc(a, VE), user: l };
  }
  return null;
}
function Cse(e, t) {
  const n = /* @__PURE__ */ new Map();
  return e && e.forEach((r) => {
    const i = G1(r.fieldName, t);
    r.fieldName = i, n.set(i.toLowerCase(), r);
  }), n;
}
function CR(e) {
  const t = [];
  if (!e)
    return t;
  const { fieldInfos: n, content: r } = e;
  return n && t.push(...n), r && Array.isArray(r) && r.forEach((i) => {
    if (i.type === "fields") {
      const s = i && i.fieldInfos;
      s && t.push(...s);
    }
  }), t;
}
function ak(e) {
  return e.replace(dse, (t) => `&#${t.charCodeAt(0)};`);
}
function P0(e) {
  return typeof e == "string" ? e.replace(cse, '<br class="geoscene-text-new-line" />') : e;
}
function Ose(e) {
  const { value: t, fieldName: n, fieldInfos: r, fieldInfoMap: i, layer: s, graphic: o } = e;
  if (t == null)
    return "";
  const a = Ise({ fieldName: n, value: t, graphic: o, layer: s });
  if (a)
    return a;
  const l = Ese({ fieldName: n, graphic: o, layer: s });
  if (l)
    return l;
  if (i.get(n.toLowerCase()))
    return sV(t, { fieldInfos: r, fieldName: n, layer: s });
  const c = s && s.fieldsIndex;
  return c && c.isDateField(n) ? nc(t, VE) : P0(t);
}
function H2({ fieldInfos: e, attributes: t, layer: n, graphic: r, fieldInfoMap: i, relatedInfos: s }) {
  const o = {};
  return s == null || s.forEach((a) => Lse(o, a)), Object.keys(t).forEach((a) => {
    const l = t[a];
    o[a] = Ose({ fieldName: a, fieldInfos: e, fieldInfoMap: i, layer: n, value: l, graphic: r });
  }), o;
}
async function kse(e, t) {
  var n, r;
  const { layer: i, graphic: s, outFields: o, objectIds: a, returnGeometry: l, spatialReference: c } = e, p = a[0];
  if (typeof p != "number" && typeof p != "string") {
    const m = "Could not query required fields for the specified feature. The feature's ID is invalid.", y = { layer: i, graphic: s, objectId: p, requiredFields: o };
    return MR.warn(m, y), null;
  }
  if ((n = i.capabilities) == null || (r = n.operations) == null || !r.supportsQuery) {
    const m = "The specified layer cannot be queried. The following fields will not be available.", y = { layer: i, graphic: s, requiredFields: o, returnGeometry: l };
    return MR.warn(m, y), null;
  }
  const f = i.createQuery();
  return f.objectIds = a, f.outFields = o != null && o.length ? o : [i.objectIdField], f.returnGeometry = !!l, f.returnZ = !!l, f.returnM = !!l, f.outSpatialReference = c, (await i.queryFeatures(f, t)).features[0];
}
async function Ase(e) {
  var t;
  if ((t = e.expressionInfos) == null || !t.length)
    return !1;
  const n = await kl(), { arcadeUtils: { hasGeometryFunctions: r } } = n;
  return r(e);
}
async function Pse({ graphic: e, popupTemplate: t, layer: n, spatialReference: r }, i) {
  if (!n || !t || (typeof n.load == "function" && await n.load(i), !e.attributes))
    return;
  const s = e.attributes[n.objectIdField];
  if (s == null)
    return;
  const o = [s], a = await t.getRequiredFields(n.fieldsIndex), l = bX(a, e), c = l ? [] : a, p = t.returnGeometry || await Ase(t);
  if (l && !p)
    return;
  const f = await kse({ layer: n, graphic: e, outFields: c, objectIds: o, returnGeometry: p, spatialReference: r }, i);
  f && (f.geometry && (e.geometry = f.geometry), f.attributes && (e.attributes = { ...e.attributes, ...f.attributes }));
}
function _l(e = "") {
  return !!e && e.indexOf(X9) !== -1;
}
function Rse(e) {
  return e ? `${X9}${e.layerId}/${e.fieldName}` : "";
}
function OR({ attributes: e, graphic: t, relatedInfo: n }) {
  e && t && n && Object.keys(t.attributes).forEach((r) => {
    const i = Rse({ layerId: n.relation.id.toString(), fieldName: r });
    e[i] = t.attributes[r];
  });
}
function Lse(e, t) {
  e && t && (t.relatedFeatures && t.relatedFeatures && t.relatedFeatures.forEach((n) => OR({ attributes: e, graphic: n, relatedInfo: t })), t.relatedStatsFeatures && t.relatedStatsFeatures && t.relatedStatsFeatures.forEach((n) => OR({ attributes: e, graphic: n, relatedInfo: t })));
}
const kR = (e) => {
  if (!e)
    return !1;
  const t = e.toUpperCase();
  return t.indexOf("CURRENT_TIMESTAMP") > -1 || t.indexOf("CURRENT_DATE") > -1 || t.indexOf("CURRENT_TIME") > -1;
}, aV = ({ layer: e, method: t, query: n, definitionExpression: r }) => {
  var i, s;
  if ((i = e.capabilities) == null || (s = i.query) == null || !s.supportsCacheHint || t === "attachments")
    return;
  const o = O(n.where) && n.where, a = O(n.geometry) && n.geometry;
  kR(r) || kR(o) || (a == null ? void 0 : a.type) === "extent" || n.resultType === "tile" || (n.cacheHint = !0);
}, Fse = ({ query: e, layer: t, method: n }) => {
  aV({ layer: t, method: n, query: e, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression}` });
}, Nse = ({ queryPayload: e, layer: t, method: n }) => {
  aV({ layer: t, method: n, query: e, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression}` });
}, AR = { editing: !1, operations: { add: !0, update: !0, delete: !0 } }, lV = Ne.ofType(Y9), Dse = "graphic.layer.capabilities.operations.supportsResizeAttachments";
let uo = class extends hf {
  constructor(t) {
    super(t), this._getAttachmentsPromise = null, this._attachmentLayer = null, this.abilities = { ...AR }, this.activeAttachmentInfo = null, this.attachmentInfos = new lV(), this.graphic = null, this.mode = "view", this.handles.add([gn(this, "graphic", () => this._graphicChanged())]);
  }
  destroy() {
    this._attachmentLayer = null, this.graphic = null;
  }
  castAbilities(t) {
    return { ...AR, ...t };
  }
  get state() {
    return this._getAttachmentsPromise ? "loading" : this.graphic ? "ready" : "disabled";
  }
  get supportsResizeAttachments() {
    return this.get(Dse) || !1;
  }
  async getAttachments() {
    const { _attachmentLayer: t, attachmentInfos: n } = this;
    if (!t || typeof t.queryAttachments != "function")
      throw new D("invalid-layer", "getAttachments(): A valid layer is required.");
    const r = this._getFeatureId(), i = new U1({ objectIds: [r], returnMetadata: !0 }), s = [], o = t.queryAttachments(i).then((l) => l[r] || s).catch(() => s);
    this._getAttachmentsPromise = o, this.notifyChange("state");
    const a = await o;
    return n.removeAll(), a.length && n.addMany(a), this._getAttachmentsPromise = null, this.notifyChange("state"), a;
  }
  async addAttachment(t) {
    const { _attachmentLayer: n, attachmentInfos: r, graphic: i, abilities: s } = this;
    if (!t)
      throw new D("invalid-attachment", "addAttachment(): An attachment is required.", { attachment: t });
    if (!s.operations.add)
      throw new D("invalid-abilities", "addAttachment(): add abilities are required.");
    if (!n || typeof n.addAttachment != "function")
      throw new D("invalid-layer", "addAttachment(): A valid layer is required.");
    const o = n.addAttachment(i, t).then((l) => this._queryAttachment(l.objectId)), a = await o;
    return r.add(a), a;
  }
  async deleteAttachment(t) {
    const { _attachmentLayer: n, attachmentInfos: r, graphic: i, abilities: s } = this;
    if (!t)
      throw new D("invalid-attachment-info", "deleteAttachment(): An attachmentInfo is required.", { attachmentInfo: t });
    if (!s.operations.delete)
      throw new D("invalid-abilities", "deleteAttachment(): delete abilities are required.");
    if (!n || typeof n.deleteAttachments != "function")
      throw new D("invalid-layer", "deleteAttachment(): A valid layer is required.");
    const o = n.deleteAttachments(i, [t.id]).then(() => t), a = await o;
    return r.remove(a), a;
  }
  async updateAttachment(t, n = this.activeAttachmentInfo) {
    const { _attachmentLayer: r, attachmentInfos: i, graphic: s, abilities: o } = this;
    if (!t)
      throw new D("invalid-attachment", "updateAttachment(): An attachment is required.", { attachment: t });
    if (!n)
      throw new D("invalid-attachment-info", "updateAttachment(): An attachmentInfo is required.", { attachmentInfo: n });
    if (!o.operations.update)
      throw new D("invalid-abilities", "updateAttachment(): Update abilities are required.");
    const a = i.findIndex((p) => p === n);
    if (!r || typeof r.updateAttachment != "function")
      throw new D("invalid-layer", "updateAttachment(): A valid layer is required.");
    const l = r.updateAttachment(s, n.id, t).then((p) => this._queryAttachment(p.objectId)), c = await l;
    return i.splice(a, 1, c), c;
  }
  async _queryAttachment(t) {
    if (!t)
      throw new D("invalid-attachment-id", "Could not query attachment.");
    const { _attachmentLayer: n } = this, r = this._getFeatureId(), i = new U1({ objectIds: [r], attachmentsWhere: `AttachmentId=${t}`, returnMetadata: !0 });
    return n.queryAttachments(i).then((s) => s[r][0]);
  }
  _getFeatureId() {
    const { _attachmentLayer: t, graphic: n } = this;
    if (!t || !n)
      return null;
    const { objectIdField: r } = t, { attributes: i } = n;
    return i && i[r];
  }
  _graphicChanged() {
    this.graphic && (this._setAttachmentLayer(), this.getAttachments().catch(() => {
    }));
  }
  _setAttachmentLayer() {
    const { graphic: t } = this, n = eV(t);
    this._attachmentLayer = n ? n.type === "scene" && O(n.associatedLayer) ? n.associatedLayer : n : null;
  }
};
u([d()], uo.prototype, "abilities", void 0), u([mt("abilities")], uo.prototype, "castAbilities", null), u([d()], uo.prototype, "activeAttachmentInfo", void 0), u([d({ readOnly: !0, type: lV })], uo.prototype, "attachmentInfos", void 0), u([d({ type: Jt })], uo.prototype, "graphic", void 0), u([d()], uo.prototype, "mode", void 0), u([d({ readOnly: !0 })], uo.prototype, "state", null), u([d({ readOnly: !0 })], uo.prototype, "supportsResizeAttachments", null), uo = u([T("geoscene.widgets.Attachments.AttachmentsViewModel")], uo);
const lk = uo;
function jse(e) {
  const t = e.toLowerCase();
  return t === "image/bmp" || t === "image/emf" || t === "image/exif" || t === "image/gif" || t === "image/x-icon" || t === "image/jpeg" || t === "image/png" || t === "image/tiff" || t === "image/x-wmf";
}
function Vse(e) {
  const t = ma("geoscene/themes/base/images/files/");
  return e ? e === "text/plain" ? `${t}text-32.svg` : e === "application/pdf" ? `${t}pdf-32.svg` : e === "text/csv" ? `${t}csv-32.svg` : e === "application/gpx+xml" ? `${t}gpx-32.svg` : e === "application/x-dwf" ? `${t}cad-32.svg` : e === "application/postscript" || e === "application/json" || e === "text/xml" || e === "model/vrml" ? `${t}code-32.svg` : e === "application/x-zip-compressed" || e === "application/x-7z-compressed" || e === "application/x-gzip" || e === "application/x-tar" || e === "application/x-gtar" || e === "application/x-bzip2" || e === "application/gzip" || e === "application/x-compress" || e === "application/x-apple-diskimage" || e === "application/x-rar-compressed" || e === "application/zip" ? `${t}zip-32.svg` : e.indexOf("image/") !== -1 ? `${t}image-32.svg` : e.indexOf("audio/") !== -1 ? `${t}sound-32.svg` : e.indexOf("video/") !== -1 ? `${t}video-32.svg` : e.indexOf("msexcel") !== -1 || e.indexOf("ms-excel") !== -1 || e.indexOf("spreadsheetml") !== -1 ? `${t}excel-32.svg` : e.indexOf("msword") !== -1 || e.indexOf("ms-word") !== -1 || e.indexOf("wordprocessingml") !== -1 ? `${t}word-32.svg` : e.indexOf("powerpoint") !== -1 || e.indexOf("presentationml") !== -1 ? `${t}report-32.svg` : `${t}generic-32.svg` : `${t}generic-32.svg`;
}
function Si(e) {
  return function(t, n) {
    t.hasOwnProperty("_messageBundleProps") || (t._messageBundleProps = t._messageBundleProps ? t._messageBundleProps.slice() : []), t._messageBundleProps.push({ bundlePath: e, propertyName: n });
  };
}
var zse = function(e) {
  return { vnodeSelector: "", properties: void 0, children: void 0, text: e.toString(), domNode: null };
}, uV = function(e, t) {
  for (var n = 0, r = e.length; n < r; n++) {
    var i = e[n];
    Array.isArray(i) ? uV(i, t) : i != null && i !== !1 && (i.hasOwnProperty("vnodeSelector") || (i = zse(i)), t.push(i));
  }
}, Bse = function(e, t) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (n.length === 1 && typeof n[0] == "string")
    return { vnodeSelector: e, properties: t || void 0, children: void 0, text: n[0], domNode: null };
  var i = [];
  return uV(n, i), { vnodeSelector: e, properties: t || void 0, children: i, text: void 0, domNode: null };
};
function B(e, t, ...n) {
  return typeof e != "function" || sk(e) ? Bse(e, t, ...n) : e(t, ...n);
}
const PR = { addButton: !0, addSubmitButton: !0, cancelAddButton: !0, cancelUpdateButton: !0, deleteButton: !0, errorMessage: !0, progressBar: !0, updateButton: !0 }, Te = { base: "geoscene-attachments", loaderContainer: "geoscene-attachments__loader-container", loader: "geoscene-attachments__loader", fadeIn: "geoscene-attachments--fade-in", container: "geoscene-attachments__container", containerList: "geoscene-attachments__container--list", containerPreview: "geoscene-attachments__container--preview", actions: "geoscene-attachments__actions", deleteButton: "geoscene-attachments__delete-button", addAttachmentButton: "geoscene-attachments__add-attachment-button", errorMessage: "geoscene-attachments__error-message", items: "geoscene-attachments__items", item: "geoscene-attachments__item", itemButton: "geoscene-attachments__item-button", itemMask: "geoscene-attachments__item-mask", itemMaskIcon: "geoscene-attachments__item-mask--icon", itemImage: "geoscene-attachments__image", itemImageResizable: "geoscene-attachments__image--resizable", itemLabel: "geoscene-attachments__label", itemFilename: "geoscene-attachments__filename", itemChevronIcon: "geoscene-attachments__item-chevron-icon", itemLink: "geoscene-attachments__item-link", itemLinkOverlay: "geoscene-attachments__item-link-overlay", itemLinkOverlayIcon: "geoscene-attachments__item-link-overlay-icon", itemEditIcon: "geoscene-attachments__item-edit-icon", itemAddIcon: "geoscene-attachments__item-add-icon", itemAddButton: "geoscene-attachments__item-add-button", formNode: "geoscene-attachments__form-node", fileFieldset: "geoscene-attachments__file-fieldset", fileLabel: "geoscene-attachments__file-label", fileName: "geoscene-attachments__file-name", fileInput: "geoscene-attachments__file-input", metadata: "geoscene-attachments__metadata", metadataFieldset: "geoscene-attachments__metadata-fieldset", progressBar: "geoscene-attachments__progress-bar", geosceneWidget: "geoscene-widget", esriButton: "geoscene-button", buttonDisabled: "geoscene-button--disabled", esriButtonSecondary: "geoscene-button--secondary", esriButtonTertiary: "geoscene-button--tertiary", esriButtonThird: "geoscene-button--third", esriButtonSmall: "geoscene-button--small", esriButtonHalf: "geoscene-button--half", empty: "geoscene-widget__content--empty", iconExternalLink: "geoscene-icon-link-external", iconEdit: "geoscene-icon-edit", iconRight: "geoscene-icon-right", iconLeft: "geoscene-icon-left", iconPlus: "geoscene-icon-plus" }, J2 = window.CSS;
let Cr = class extends ti {
  constructor(t, n) {
    super(t, n), this.abilities = null, this.displayType = "auto", this.graphic = null, this.label = void 0, this.messages = null, this.messagesUnits = null, this.selectedFile = null, this.submitting = !1, this.viewModel = new lk(), this.visibleElements = { ...PR }, this._supportsImageOrientation = J2 && J2.supports && J2.supports("image-orientation", "from-image"), this._addAttachmentForm = null, this._updateAttachmentForm = null;
  }
  initialize() {
    this.own(gS(this, "viewModel.attachmentInfos", "change", () => this.scheduleRender()), gn(this, "viewModel.mode", () => this._modeChanged()));
  }
  get effectiveDisplayType() {
    const { displayType: t } = this;
    return t && t !== "auto" ? t : this.viewModel.supportsResizeAttachments ? "preview" : "list";
  }
  castVisibleElements(t) {
    return { ...PR, ...t };
  }
  addAttachment() {
    const { _addAttachmentForm: t, viewModel: n } = this;
    return this._set("submitting", !0), this._set("error", null), n.addAttachment(t).then((r) => (this._set("submitting", !1), this._set("error", null), n.mode = "view", r)).catch((r) => {
      throw this._set("submitting", !1), this._set("error", new D("attachments:add-attachment", this.messages.addErrorMessage, r)), r;
    });
  }
  deleteAttachment(t) {
    const { viewModel: n } = this;
    return this._set("submitting", !0), this._set("error", null), n.deleteAttachment(t).then((r) => (this._set("submitting", !1), this._set("error", null), n.mode = "view", r)).catch((r) => {
      throw this._set("submitting", !1), this._set("error", new D("attachments:delete-attachment", this.messages.deleteErrorMessage, r)), r;
    });
  }
  updateAttachment() {
    const { viewModel: t } = this, { _updateAttachmentForm: n } = this;
    return this._set("submitting", !0), this._set("error", null), t.updateAttachment(n).then((r) => (this._set("submitting", !1), this._set("error", null), t.mode = "view", r)).catch((r) => {
      throw this._set("submitting", !1), this._set("error", new D("attachments:update-attachment", this.messages.updateErrorMessage, r)), r;
    });
  }
  render() {
    const { submitting: t, viewModel: n } = this, { state: r } = n;
    return B("div", { class: this.classes(Te.base, Te.geosceneWidget) }, t ? this.renderProgressBar() : null, r === "loading" ? this.renderLoading() : this.renderAttachments(), this.renderErrorMessage());
  }
  renderErrorMessage() {
    const { error: t, visibleElements: n } = this;
    return t && n.errorMessage ? B("div", { key: "error-message", class: Te.errorMessage }, t.message) : null;
  }
  renderAttachments() {
    const { mode: t, activeAttachmentInfo: n } = this.viewModel;
    return t === "add" ? this.renderAddForm() : t === "edit" ? this.renderDetailsForm(n) : this.renderAttachmentContainer();
  }
  renderLoading() {
    return B("div", { class: Te.loaderContainer, key: "loader" }, B("div", { class: Te.loader }));
  }
  renderProgressBar() {
    return this.visibleElements.progressBar ? B("div", { class: Te.progressBar, key: "progress-bar" }) : null;
  }
  renderAddForm() {
    const { submitting: t, selectedFile: n } = this, r = t || !n, i = this.visibleElements.cancelAddButton ? B("button", { type: "button", bind: this, disabled: t, onclick: this._cancelForm, class: this.classes(Te.esriButton, Te.esriButtonTertiary, Te.esriButtonSmall, Te.esriButtonHalf, t && Te.buttonDisabled) }, this.messages.cancel) : null, s = this.visibleElements.addSubmitButton ? B("button", { type: "submit", disabled: r, class: this.classes(Te.esriButton, Te.esriButtonSecondary, Te.esriButtonSmall, Te.esriButtonHalf, { [Te.buttonDisabled]: r }) }, this.messages.add) : null, o = n ? B("span", { key: "file-name", class: Te.fileName }, n.name) : null, a = B("form", { bind: this, afterCreate: kE, afterRemoved: oR, "data-node-ref": "_addAttachmentForm", onsubmit: this._submitAddAttachment }, B("fieldset", { class: Te.fileFieldset }, o, B("label", { class: this.classes(Te.fileLabel, Te.esriButton, Te.esriButtonSecondary) }, n ? this.messages.changeFile : this.messages.selectFile, B("input", { class: Te.fileInput, type: "file", name: "attachment", bind: this, onchange: this._handleFileInputChange }))), s, i);
    return B("div", { key: "add-form-container", class: Te.formNode }, a);
  }
  renderDetailsForm(t) {
    const { visibleElements: n, viewModel: r, selectedFile: i, submitting: s } = this, { contentType: o, size: a, url: l } = t, { abilities: c } = r, p = s || !i, f = c.editing && c.operations.delete && n.deleteButton ? B("button", { key: "delete-button", type: "button", disabled: s, bind: this, onclick: ($) => this._submitDeleteAttachment($, t), class: this.classes(Te.esriButton, Te.esriButtonSmall, Te.esriButtonTertiary, Te.deleteButton, { [Te.buttonDisabled]: s }) }, this.messages.delete) : null, m = c.editing && c.operations.update && n.updateButton ? B("button", { disabled: p, key: "update-button", type: "submit", class: this.classes(Te.esriButton, Te.esriButtonSmall, Te.esriButtonThird, { [Te.buttonDisabled]: p }) }, this.messages.update) : null, y = this.visibleElements.cancelUpdateButton ? B("button", { disabled: s, key: "cancel-button", type: "button", bind: this, onclick: this._cancelForm, class: this.classes(Te.esriButton, Te.esriButtonSmall, Te.esriButtonTertiary, Te.esriButtonThird, { [Te.buttonDisabled]: s }) }, this.messages.cancel) : null, g = i ? B("span", { key: "file-name", class: Te.fileName }, i.name) : null, v = c.editing && c.operations.update ? B("fieldset", { key: "file", class: Te.fileFieldset }, g, B("label", { class: this.classes(Te.fileLabel, Te.esriButton, Te.esriButtonSecondary) }, this.messages.changeFile, B("input", { class: Te.fileInput, type: "file", name: "attachment", bind: this, onchange: this._handleFileInputChange }))) : null, w = B("fieldset", { key: "size", class: Te.metadataFieldset }, B("label", null, nse(this.messagesUnits, a))), b = B("fieldset", { key: "content-type", class: Te.metadataFieldset }, B("label", null, o)), S = B("form", { bind: this, afterCreate: kE, afterRemoved: oR, "data-node-ref": "_updateAttachmentForm", onsubmit: this._submitUpdateAttachment }, B("div", { class: Te.metadata }, w, b), v, B("div", { class: Te.actions }, f, y, m));
    return B("div", { key: "edit-form-container", class: Te.formNode }, B("a", { class: Te.itemLink, href: l, rel: "noreferrer", target: "_blank" }, this.renderImageMask({ attachmentInfo: t, size: 400 }), B("div", { class: Te.itemLinkOverlay }, B("span", { class: Te.itemLinkOverlayIcon }, B("svg", { xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32" }, B("path", { d: "M28 13h1v16H3V3h16v1H4v24h24zm-5-9h4.293L15.646 15.638l.707.707L28 4.707V9h1V3h-6z" }), B("path", { fill: "none", d: "M0 0h32v32H0z" }))))), S);
  }
  renderImageMask({ attachmentInfo: t, size: n }) {
    const { supportsResizeAttachments: r } = this.viewModel, { contentType: i, name: s, url: o } = t, a = r && jse(i), l = this._getCSSTransform(t, a), c = l ? { transform: l, "image-orientation": "none" } : {}, p = o.indexOf("?") === -1 ? "?" : "&", f = a ? `${o}${p}w=${n}` : Vse(i), m = { [Te.itemMaskIcon]: !a }, y = { [Te.itemImageResizable]: r };
    return B("div", { class: this.classes(m, Te.itemMask) }, B("img", { styles: c, alt: s, src: f, class: this.classes(y, Te.itemImage) }));
  }
  renderAttachmentInfo({ attachmentInfo: t, displayType: n }) {
    const { viewModel: r } = this, { abilities: i } = r, { name: s, url: o } = t, a = this.renderImageMask({ attachmentInfo: t, size: n === "list" ? 48 : 400 }), l = i.editing ? B("span", { "aria-hidden": "true", class: this.classes(Te.itemChevronIcon, qu(this.container) ? Te.iconLeft : Te.iconRight) }) : null, c = [a, B("label", { class: Te.itemLabel }, B("span", { class: Te.itemFilename }, s || this.messages.noTitle), l)], p = i.editing ? B("button", { key: "details-button", bind: this, class: Te.itemButton, title: this.messages.attachmentDetails, "aria-label": this.messages.attachmentDetails, "data-attachment-info-id": t.id, onclick: () => this._startEditAttachment(t), type: "button" }, c) : B("a", { key: "details-link", class: Te.itemButton, href: o, target: "_blank" }, c);
    return B("li", { class: Te.item, key: t }, p);
  }
  renderAttachmentContainer() {
    const { effectiveDisplayType: t, viewModel: n, visibleElements: r } = this, { attachmentInfos: i, abilities: s } = n, o = i && i.length, a = { [Te.containerList]: t !== "preview", [Te.containerPreview]: t === "preview" }, l = s.editing && s.operations.add && r.addButton ? B("button", { bind: this, onclick: () => this._startAddAttachment(), class: this.classes(Te.esriButton, Te.esriButtonTertiary, Te.addAttachmentButton), type: "button" }, B("span", { "aria-hidden": "true", class: this.classes(Te.itemAddIcon, Te.iconPlus) }), this.messages.add) : null, c = o ? B("ul", { class: Te.items }, i.toArray().map((p) => this.renderAttachmentInfo({ attachmentInfo: p, displayType: t }))) : B("div", { class: Te.empty }, this.messages.noAttachments);
    return B("div", { key: "attachments-container", class: this.classes(Te.container, a) }, c, l);
  }
  _modeChanged() {
    this._set("error", null), this._set("selectedFile", null);
  }
  _handleFileInputChange(t) {
    const n = t.target, r = n && n.files && n.files.item(0);
    this._set("selectedFile", r);
  }
  _submitDeleteAttachment(t, n) {
    t.preventDefault(), this.deleteAttachment(n);
  }
  _submitAddAttachment(t) {
    t.preventDefault(), this.addAttachment();
  }
  _submitUpdateAttachment(t) {
    t.preventDefault(), this.updateAttachment();
  }
  _startEditAttachment(t) {
    const { viewModel: n } = this;
    n.activeAttachmentInfo = t, n.mode = "edit";
  }
  _startAddAttachment() {
    this.viewModel.mode = "add";
  }
  _cancelForm(t) {
    t.preventDefault(), this.viewModel.mode = "view";
  }
  _getCSSTransform(t, n) {
    const { orientationInfo: r } = t;
    return !this._supportsImageOrientation && n && r ? [r.rotation ? `rotate(${r.rotation}deg)` : "", r.mirrored ? "scaleX(-1)" : ""].join(" ") : "";
  }
};
u([Le("viewModel.abilities")], Cr.prototype, "abilities", void 0), u([d()], Cr.prototype, "displayType", void 0), u([d({ readOnly: !0 })], Cr.prototype, "effectiveDisplayType", null), u([Le("viewModel.graphic")], Cr.prototype, "graphic", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], Cr.prototype, "label", void 0), u([d(), Si("geoscene/widgets/Attachments/t9n/Attachments")], Cr.prototype, "messages", void 0), u([d(), Si("geoscene/core/t9n/Units")], Cr.prototype, "messagesUnits", void 0), u([d({ readOnly: !0 })], Cr.prototype, "selectedFile", void 0), u([d({ readOnly: !0 })], Cr.prototype, "submitting", void 0), u([d({ readOnly: !0 })], Cr.prototype, "error", void 0), u([d({ type: lk })], Cr.prototype, "viewModel", void 0), u([d()], Cr.prototype, "visibleElements", void 0), u([mt("visibleElements")], Cr.prototype, "castVisibleElements", null), Cr = u([T("geoscene.widgets.Attachments")], Cr);
const Use = Cr;
let _y = class extends lk {
  constructor(t) {
    super(t), this.description = null, this.title = null;
  }
};
u([d()], _y.prototype, "description", void 0), u([d()], _y.prototype, "title", void 0), _y = u([T("geoscene.widgets.Feature.FeatureAttachments.FeatureAttachmentsViewModel")], _y);
const uk = _y, qse = { heading: "geoscene-widget__heading" };
function ck(e, t) {
  const n = Gse(e.level), r = `h${n}`;
  return delete e.level, B(r, { ...e, class: b9(qse.heading, e.class), role: "heading", "aria-level": String(n) }, t);
}
function Gse(e) {
  return js(Math.ceil(e), 1, 6);
}
const Z2 = { base: "geoscene-feature-element-info", title: "geoscene-feature-element-info__title", description: "geoscene-feature-element-info__description" };
let hh = class extends ti {
  constructor(t, n) {
    super(t, n), this.description = null, this.headingLevel = 2, this.title = null;
  }
  render() {
    return B("div", { class: Z2.base }, this.renderTitle(), this.renderDescription());
  }
  renderTitle() {
    const { title: t } = this;
    return t ? B(ck, { level: this.headingLevel, class: Z2.title }, t) : null;
  }
  renderDescription() {
    const { description: t } = this;
    return t ? B("div", { key: "description", class: Z2.description }, t) : null;
  }
};
u([d()], hh.prototype, "description", void 0), u([d()], hh.prototype, "headingLevel", void 0), u([d()], hh.prototype, "title", void 0), hh = u([T("geoscene.widgets.Feature.support.FeatureElementInfo")], hh);
const dk = hh, Wse = { base: "geoscene-feature-attachments" };
let ra = class extends ti {
  constructor(t, n) {
    super(t, n), this._featureElementInfo = null, this.attachmentsWidget = new Use(), this.description = null, this.displayType = null, this.graphic = null, this.headingLevel = 2, this.title = null, this.viewModel = new uk();
  }
  initialize() {
    this._featureElementInfo = new dk(), gn(this, ["viewModel.description", "viewModel.title", "headingLevel"], () => this._setupFeatureElementInfo()), gn(this, "viewModel.graphic", (t) => this.attachmentsWidget.graphic = t);
  }
  destroy() {
    this.attachmentsWidget.destroy(), this._featureElementInfo.destroy();
  }
  render() {
    var t;
    const { attachmentsWidget: n } = this;
    return B("div", { class: Wse.base }, (t = this._featureElementInfo) == null ? void 0 : t.render(), n == null ? void 0 : n.render());
  }
  _setupFeatureElementInfo() {
    const { description: t, title: n, headingLevel: r } = this;
    this._featureElementInfo.set({ description: t, title: n, headingLevel: r });
  }
};
u([d({ readOnly: !0 })], ra.prototype, "attachmentsWidget", void 0), u([Le("viewModel.description")], ra.prototype, "description", void 0), u([Le("attachmentsWidget.displayType")], ra.prototype, "displayType", void 0), u([Le("viewModel.graphic")], ra.prototype, "graphic", void 0), u([d()], ra.prototype, "headingLevel", void 0), u([Le("viewModel.title")], ra.prototype, "title", void 0), u([d({ type: uk })], ra.prototype, "viewModel", void 0), ra = u([T("geoscene.widgets.Feature.FeatureAttachments")], ra);
const Hse = ra;
let mu = class extends $p(ke) {
  constructor(t) {
    super(t), this._loadingPromise = null, this.created = null, this.creator = null, this.destroyer = null, this.graphic = null, this.handles.add(gn(this, "creator", (n) => {
      this._destroyContent(), this._createContent(n);
    }));
  }
  destroy() {
    this._destroyContent();
  }
  get state() {
    return this._loadingPromise ? "loading" : "ready";
  }
  _destroyContent() {
    const { created: t, graphic: n, destroyer: r } = this;
    t && (q1(r, { graphic: n }).catch(() => null), this._set("created", null));
  }
  async _createContent(t) {
    const { graphic: n } = this, r = q1(t, { graphic: n }).catch(() => null);
    this._loadingPromise = r, this.notifyChange("state");
    const i = await r;
    r === this._loadingPromise && (this._loadingPromise = null, this.notifyChange("state"), this._set("created", i));
  }
};
u([d({ readOnly: !0 })], mu.prototype, "created", void 0), u([d()], mu.prototype, "creator", void 0), u([d()], mu.prototype, "destroyer", void 0), u([d({ type: Jt })], mu.prototype, "graphic", void 0), u([d({ readOnly: !0 })], mu.prototype, "state", null), mu = u([T("geoscene.widgets.Feature.FeatureContent.FeatureContentViewModel")], mu);
const W1 = mu;
function Cs() {
  return function(e, t) {
    if (!e[t])
      throw new TypeError(`Cannot auto bind undefined function '${t}'`);
    return { value: Zse(e[t]) };
  };
}
function Jse(e) {
  const { type: t } = e;
  return e instanceof KeyboardEvent || t === "keyup" || t === "keydown" || t === "keypress";
}
function Zse(e) {
  return function(t, ...n) {
    Jse(t) ? kre(t.key) && (t.preventDefault(), t.stopPropagation(), t.target.click()) : e.call(this, t, ...n);
  };
}
function Kse(e) {
  return e.split(",").map((t) => t.trim());
}
function Yse(e) {
  return (t) => {
    t.hasOwnProperty("_delegatedEventNames") || (t._delegatedEventNames = t._delegatedEventNames ? t._delegatedEventNames.slice() : []);
    const n = t._delegatedEventNames, r = Array.isArray(e) ? e : Kse(e);
    n.push(...r);
  };
}
function cV(e) {
  return e && typeof e.render == "function";
}
function Qse(e) {
  return e && typeof e.postMixInProperties == "function" && typeof e.buildRendering == "function" && typeof e.postCreate == "function" && typeof e.startup == "function";
}
const K2 = { base: "geoscene-feature-content", loaderContainer: "geoscene-feature-content__loader-container", loader: "geoscene-feature-content__loader" };
let fh = class extends ti {
  constructor(t, n) {
    super(t, n), this.creator = null, this.graphic = null, this.viewModel = null, this._addTargetToAnchors = (r) => {
      Array.from(r.querySelectorAll("a")).forEach((i) => {
        tV(i.href) && !i.hasAttribute("target") && i.setAttribute("target", "_blank");
      });
    };
  }
  renderLoading() {
    return B("div", { class: K2.loaderContainer, key: "loader" }, B("div", { class: K2.loader }));
  }
  renderCreated() {
    var t;
    const n = (t = this.viewModel) == null ? void 0 : t.created;
    return n ? n instanceof HTMLElement ? B("div", { key: n, bind: n, afterCreate: this._attachToNode }) : cV(n) ? B("div", { key: n }, !n.destroyed && n.render()) : B("div", { key: n, innerHTML: n, afterCreate: this._addTargetToAnchors }) : null;
  }
  render() {
    var t;
    const n = (t = this.viewModel) == null ? void 0 : t.state;
    return B("div", { class: K2.base }, n === "loading" ? this.renderLoading() : this.renderCreated());
  }
  _attachToNode(t) {
    const n = this;
    t.appendChild(n);
  }
};
u([Le("viewModel.creator")], fh.prototype, "creator", void 0), u([Le("viewModel.graphic")], fh.prototype, "graphic", void 0), u([d({ type: W1 })], fh.prototype, "viewModel", void 0), fh = u([T("geoscene.widgets.Feature.FeatureContent")], fh);
const ew = fh;
let Qa = class extends ke {
  constructor(t) {
    super(t), this.attributes = null, this.expressionInfos = null, this.description = null, this.fieldInfos = null, this.title = null;
  }
  get formattedFieldInfos() {
    const { expressionInfos: t, fieldInfos: n } = this, r = [];
    return n == null || n.forEach((i) => {
      if (!(!i.hasOwnProperty("visible") || i.visible))
        return;
      const s = i.clone();
      s.label = rV(s, t), r.push(s);
    }), r;
  }
};
u([d()], Qa.prototype, "attributes", void 0), u([d({ type: [Q6] })], Qa.prototype, "expressionInfos", void 0), u([d()], Qa.prototype, "description", void 0), u([d({ type: [_0] })], Qa.prototype, "fieldInfos", void 0), u([d({ readOnly: !0 })], Qa.prototype, "formattedFieldInfos", null), u([d()], Qa.prototype, "title", void 0), Qa = u([T("geoscene.widgets.Feature.FeatureFields.FeatureFieldsViewModel")], Qa);
const bS = Qa, Xse = [{ pattern: /^\s*(https?:\/\/([^\s]+))\s*$/i, target: "_blank", label: "{messages.view}" }, { pattern: /^\s*(tel:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(mailto:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(arcgis-appstudio-player:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "App Studio Player" }, { pattern: /^\s*(arcgis-collector:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Collector" }, { pattern: /^\s*(arcgis-explorer:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Explorer" }, { pattern: /^\s*(arcgis-navigator:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Navigator" }, { pattern: /^\s*(arcgis-survey123:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Survey123" }, { pattern: /^\s*(arcgis-trek2there:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Trek2There" }, { pattern: /^\s*(arcgis-workforce:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Workforce" }, { pattern: /^\s*(iform:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "iForm" }, { pattern: /^\s*(flow:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "FlowFinity" }, { pattern: /^\s*(lfmobile:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Laserfische" }, { pattern: /^\s*(mspbi:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Microsoft Power Bi" }];
function eoe(e) {
  let t = null;
  return Xse.some((n) => (n.pattern.test(e) && (t = n), !!t)), t;
}
function toe(e, t) {
  if (typeof t != "string" || !t)
    return t;
  const n = eoe(t);
  if (!n)
    return t;
  const r = t.match(n.pattern), i = r && r[2], s = Ta(Ta(n.label, { messages: e, hierPart: i }), { appName: n.appName }), o = n.target ? ` target="${n.target}"` : "", a = n.target === "_blank" ? ' rel="noreferrer"' : "";
  return t.replace(n.pattern, `<a${o} href="$1"${a}>${s}</a>`);
}
const Mm = { base: "geoscene-feature-fields", fieldHeader: "geoscene-feature-fields__field-header", fieldData: "geoscene-feature-fields__field-data", fieldDataDate: "geoscene-feature-fields__field-data--date", esriTable: "geoscene-widget__table" };
let co = class extends ti {
  constructor(t, n) {
    super(t, n), this._featureElementInfo = null, this.attributes = null, this.description = null, this.expressionInfos = null, this.fieldInfos = null, this.title = null, this.viewModel = new bS(), this.messages = null, this.messagesURIUtils = null;
  }
  initialize() {
    this._featureElementInfo = new dk(), gn(this, ["viewModel.description", "viewModel.title"], () => this._setupFeatureElementInfo());
  }
  destroy() {
    this._featureElementInfo.destroy();
  }
  renderFieldInfo(t, n) {
    const { attributes: r } = this.viewModel, i = t.fieldName, s = t.label || i, o = r ? r[i] == null ? "" : r[i] : "", a = !(!t.format || !t.format.dateFormat), l = typeof o == "number" && !a ? this._forceLTR(o) : toe(this.messagesURIUtils, o), c = { [Mm.fieldDataDate]: a };
    return B("tr", { key: `fields-element-info-row-${i}-${n}` }, B("th", { key: `fields-element-info-row-header-${i}-${n}`, class: Mm.fieldHeader, innerHTML: s }), B("td", { key: `fields-element-info-row-data-${i}-${n}`, class: this.classes(Mm.fieldData, c), innerHTML: l }));
  }
  renderFields() {
    const { formattedFieldInfos: t } = this.viewModel;
    return t != null && t.length ? B("table", { class: Mm.esriTable, summary: this.messages.fieldsSummary }, B("tbody", null, t.map((n, r) => this.renderFieldInfo(n, r)))) : null;
  }
  render() {
    var t;
    return B("div", { class: Mm.base }, (t = this._featureElementInfo) == null ? void 0 : t.render(), this.renderFields());
  }
  _setupFeatureElementInfo() {
    const { description: t, title: n } = this;
    this._featureElementInfo.set({ description: t, title: n });
  }
  _forceLTR(t) {
    return `&lrm;${t}`;
  }
};
u([Le("viewModel.attributes")], co.prototype, "attributes", void 0), u([Le("viewModel.description")], co.prototype, "description", void 0), u([Le("viewModel.expressionInfos")], co.prototype, "expressionInfos", void 0), u([Le("viewModel.fieldInfos")], co.prototype, "fieldInfos", void 0), u([Le("viewModel.title")], co.prototype, "title", void 0), u([d({ type: bS })], co.prototype, "viewModel", void 0), u([d(), Si("geoscene/widgets/Feature/t9n/Feature")], co.prototype, "messages", void 0), u([d(), Si("geoscene/widgets/support/t9n/uriUtils")], co.prototype, "messagesURIUtils", void 0), co = u([T("geoscene.widgets.Feature.FeatureFields")], co);
const dV = co, RR = { milliseconds: 1, seconds: 1e3, minutes: 6e4, hours: 36e5, days: 864e5, weeks: 6048e5, months: 26784e5, years: 31536e6, decades: 31536e7, centuries: 31536e8 }, noe = { milliseconds: { getter: "getMilliseconds", setter: "setMilliseconds", multiplier: 1 }, seconds: { getter: "getSeconds", setter: "setSeconds", multiplier: 1 }, minutes: { getter: "getMinutes", setter: "setMinutes", multiplier: 1 }, hours: { getter: "getHours", setter: "setHours", multiplier: 1 }, days: { getter: "getDate", setter: "setDate", multiplier: 1 }, weeks: { getter: "getDate", setter: "setDate", multiplier: 7 }, months: { getter: "getMonth", setter: "setMonth", multiplier: 1 }, years: { getter: "getFullYear", setter: "setFullYear", multiplier: 1 }, decades: { getter: "getFullYear", setter: "setFullYear", multiplier: 10 }, centuries: { getter: "getFullYear", setter: "setFullYear", multiplier: 100 } };
function roe(e, t) {
  const n = new Date(e, t + 1, 1);
  return n.setDate(0), n.getDate();
}
function Gd(e, t, n) {
  const r = new Date(e.getTime());
  if (t && n) {
    const i = noe[n], { getter: s, setter: o, multiplier: a } = i;
    if (n === "months") {
      const l = roe(r.getFullYear(), r.getMonth() + t);
      r.getDate() > l && r.setDate(l);
    }
    r[o](r[s]() + t * a);
  }
  return r;
}
function LR(e, t) {
  switch (t) {
    case "milliseconds":
      return new Date(e.getTime());
    case "seconds":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds());
    case "minutes":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes());
    case "hours":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours());
    case "days":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate());
    case "weeks":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate() - e.getDay());
    case "months":
      return new Date(e.getFullYear(), e.getMonth(), 1);
    case "years":
      return new Date(e.getFullYear(), 0, 1);
    case "decades":
      return new Date(e.getFullYear() - e.getFullYear() % 10, 0, 1);
    case "centuries":
      return new Date(e.getFullYear() - e.getFullYear() % 100, 0, 1);
    default:
      return /* @__PURE__ */ new Date();
  }
}
function ioe(e, t, n) {
  return e === 0 ? 0 : e * RR[t] / RR[n];
}
var po;
let Gi = po = class extends se {
  constructor(e) {
    super(e), this.end = null, this.start = null;
  }
  static get allTime() {
    return FR;
  }
  static get empty() {
    return soe;
  }
  readEnd(e, t) {
    return t.end != null ? new Date(t.end) : null;
  }
  writeEnd(e, t) {
    t.end = e ? e.getTime() : null;
  }
  get isAllTime() {
    return this.equals(po.allTime);
  }
  get isEmpty() {
    return this.equals(po.empty);
  }
  readStart(e, t) {
    return t.start != null ? new Date(t.start) : null;
  }
  writeStart(e, t) {
    t.start = e ? e.getTime() : null;
  }
  clone() {
    return new po({ end: this.end, start: this.start });
  }
  equals(e) {
    if (!e)
      return !1;
    const t = O(this.start) ? this.start.getTime() : this.start, n = O(this.end) ? this.end.getTime() : this.end, r = O(e.start) ? e.start.getTime() : e.start, i = O(e.end) ? e.end.getTime() : e.end;
    return t === r && n === i;
  }
  expandTo(e) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const t = Nu(this.start, (r) => LR(r, e)), n = Nu(this.end, (r) => Gd(LR(r, e), 1, e));
    return new po({ start: t, end: n });
  }
  intersection(e) {
    if (!e)
      return this.clone();
    if (this.isEmpty || e.isEmpty)
      return po.empty;
    if (this.isAllTime)
      return e.clone();
    if (e.isAllTime)
      return this.clone();
    const t = Jm(this.start, -1 / 0, (a) => a.getTime()), n = Jm(this.end, 1 / 0, (a) => a.getTime()), r = Jm(e.start, -1 / 0, (a) => a.getTime()), i = Jm(e.end, 1 / 0, (a) => a.getTime());
    let s, o;
    if (r >= t && r <= n ? s = r : t >= r && t <= i && (s = t), n >= r && n <= i ? o = n : i >= t && i <= n && (o = i), !isNaN(s) && !isNaN(o)) {
      const a = new po();
      return a.start = s === -1 / 0 ? null : new Date(s), a.end = o === 1 / 0 ? null : new Date(o), a;
    }
    return po.empty;
  }
  offset(e, t) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const n = new po(), { start: r, end: i } = this;
    return O(r) && (n.start = Gd(r, e, t)), O(i) && (n.end = Gd(i, e, t)), n;
  }
  union(e) {
    if (!e || e.isEmpty)
      return this.clone();
    if (this.isEmpty)
      return e.clone();
    if (this.isAllTime || e.isAllTime)
      return FR.clone();
    const t = O(this.start) && O(e.start) ? new Date(Math.min(this.start.getTime(), e.start.getTime())) : null, n = O(this.end) && O(e.end) ? new Date(Math.max(this.end.getTime(), e.end.getTime())) : null;
    return new po({ start: t, end: n });
  }
};
u([d({ type: Date, json: { write: { allowNull: !0 } } })], Gi.prototype, "end", void 0), u([be("end")], Gi.prototype, "readEnd", null), u([xe("end")], Gi.prototype, "writeEnd", null), u([d({ readOnly: !0, json: { read: !1 } })], Gi.prototype, "isAllTime", null), u([d({ readOnly: !0, json: { read: !1 } })], Gi.prototype, "isEmpty", null), u([d({ type: Date, json: { write: { allowNull: !0 } } })], Gi.prototype, "start", void 0), u([be("start")], Gi.prototype, "readStart", null), u([xe("start")], Gi.prototype, "writeStart", null), Gi = po = u([T("geoscene.TimeExtent")], Gi);
const FR = new Gi(), soe = new Gi({ start: void 0, end: void 0 }), La = Gi;
var UE;
let Sy = UE = class extends se {
  constructor(e) {
    super(e), this.name = null, this.code = null;
  }
  clone() {
    return new UE({ name: this.name, code: this.code });
  }
};
u([d({ type: String, json: { write: !0 } })], Sy.prototype, "name", void 0), u([d({ type: [String, Number], json: { write: !0 } })], Sy.prototype, "code", void 0), Sy = UE = u([T("geoscene.layers.support.CodedValue")], Sy);
const ooe = Sy, aoe = new st({ inherited: "inherited", codedValue: "coded-value", range: "range" });
let xy = class extends se {
  constructor(t) {
    super(t), this.name = null, this.type = null;
  }
};
u([d({ type: String, json: { write: !0 } })], xy.prototype, "name", void 0), u([De(aoe)], xy.prototype, "type", void 0), xy = u([T("geoscene.layers.support.Domain")], xy);
const wS = xy;
var qE;
let $y = qE = class extends wS {
  constructor(e) {
    super(e), this.codedValues = null, this.type = "coded-value";
  }
  getName(e) {
    let t = null;
    if (this.codedValues) {
      const n = String(e);
      this.codedValues.some((r) => (String(r.code) === n && (t = r.name), !!t));
    }
    return t;
  }
  clone() {
    return new qE({ codedValues: q(this.codedValues), name: this.name });
  }
};
u([d({ type: [ooe], json: { write: !0 } })], $y.prototype, "codedValues", void 0), u([De({ codedValue: "coded-value" })], $y.prototype, "type", void 0), $y = qE = u([T("geoscene.layers.support.CodedValueDomain")], $y);
const pV = $y;
var GE;
let tw = GE = class extends wS {
  constructor(e) {
    super(e), this.type = "inherited";
  }
  clone() {
    return new GE();
  }
};
u([De({ inherited: "inherited" })], tw.prototype, "type", void 0), tw = GE = u([T("geoscene.layers.support.InheritedDomain")], tw);
const hV = tw;
var WE;
let mh = WE = class extends wS {
  constructor(e) {
    super(e), this.maxValue = null, this.minValue = null, this.type = "range";
  }
  clone() {
    return new WE({ maxValue: this.maxValue, minValue: this.minValue, name: this.name });
  }
};
u([d({ type: Number, json: { type: [Number], read: { source: "range", reader: (e, t) => t.range && t.range[1] }, write: { enabled: !1, overridePolicy() {
  return { enabled: this.maxValue != null && this.minValue == null };
}, target: "range", writer(e, t, n) {
  t[n] = [this.minValue || 0, e];
} } } })], mh.prototype, "maxValue", void 0), u([d({ type: Number, json: { type: [Number], read: { source: "range", reader: (e, t) => t.range && t.range[0] }, write: { target: "range", writer(e, t, n) {
  t[n] = [e, this.maxValue || 0];
} } } })], mh.prototype, "minValue", void 0), u([De({ range: "range" })], mh.prototype, "type", void 0), mh = WE = u([T("geoscene.layers.support.RangeDomain")], mh);
const fV = mh, mV = { key: "type", base: wS, typeMap: { range: fV, "coded-value": pV, inherited: hV } };
function pk(e) {
  if (!e || !e.type)
    return null;
  switch (e.type) {
    case "range":
      return fV.fromJSON(e);
    case "codedValue":
      return pV.fromJSON(e);
    case "inherited":
      return hV.fromJSON(e);
  }
  return null;
}
const loe = new st({ esriFieldTypeSmallInteger: "small-integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "single", esriFieldTypeDouble: "double", esriFieldTypeLong: "long", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "oid", esriFieldTypeGeometry: "geometry", esriFieldTypeBlob: "blob", esriFieldTypeRaster: "raster", esriFieldTypeGUID: "guid", esriFieldTypeGlobalID: "global-id", esriFieldTypeXML: "xml" });
var HE;
const uoe = new st({ binary: "binary", coordinate: "coordinate", countOrAmount: "count-or-amount", dateAndTime: "date-and-time", description: "description", locationOrPlaceName: "location-or-place-name", measurement: "measurement", nameOrTitle: "name-or-title", none: "none", orderedOrRanked: "ordered-or-ranked", percentageOrRatio: "percentage-or-ratio", typeOrCategory: "type-or-category", uniqueIdentifier: "unique-identifier" });
let Br = HE = class extends se {
  constructor(e) {
    super(e), this.alias = null, this.defaultValue = void 0, this.description = null, this.domain = null, this.editable = !0, this.length = -1, this.name = null, this.nullable = !0, this.type = null, this.valueType = null;
  }
  readDescription(e, { description: t }) {
    let n;
    try {
      n = JSON.parse(t);
    } catch {
    }
    return n ? n.value : null;
  }
  readValueType(e, { description: t }) {
    let n;
    try {
      n = JSON.parse(t);
    } catch {
    }
    return n ? uoe.fromJSON(n.fieldValueType) : null;
  }
  clone() {
    return new HE({ alias: this.alias, defaultValue: this.defaultValue, description: this.description, domain: this.domain && this.domain.clone() || null, editable: this.editable, length: this.length, name: this.name, nullable: this.nullable, type: this.type, valueType: this.valueType });
  }
};
u([d({ type: String, json: { write: !0 } })], Br.prototype, "alias", void 0), u([d({ type: [String, Number], json: { write: { allowNull: !0 } } })], Br.prototype, "defaultValue", void 0), u([d()], Br.prototype, "description", void 0), u([be("description")], Br.prototype, "readDescription", null), u([d({ types: mV, json: { read: { reader: pk }, write: !0 } })], Br.prototype, "domain", void 0), u([d({ type: Boolean, json: { write: !0 } })], Br.prototype, "editable", void 0), u([d({ type: Vt, json: { write: !0 } })], Br.prototype, "length", void 0), u([d({ type: String, json: { write: !0 } })], Br.prototype, "name", void 0), u([d({ type: Boolean, json: { write: !0 } })], Br.prototype, "nullable", void 0), u([De(loe)], Br.prototype, "type", void 0), u([d()], Br.prototype, "valueType", void 0), u([be("valueType", ["description"])], Br.prototype, "readValueType", null), Br = HE = u([T("geoscene.layers.support.Field")], Br);
const _S = Br;
var JE;
let yh = JE = class extends se {
  constructor(e) {
    super(e), this.type = "map-layer";
  }
  clone() {
    const { mapLayerId: e, gdbVersion: t } = this;
    return new JE({ mapLayerId: e, gdbVersion: t });
  }
};
u([De({ mapLayer: "map-layer" })], yh.prototype, "type", void 0), u([d({ type: Vt, json: { write: !0 } })], yh.prototype, "mapLayerId", void 0), u([d({ type: String, json: { write: !0 } })], yh.prototype, "gdbVersion", void 0), yh = JE = u([T("geoscene.layers.support.source.MapLayerSource")], yh);
var ZE;
let Xa = ZE = class extends se {
  constructor(e) {
    super(e), this.type = "query-table";
  }
  clone() {
    var e;
    const { workspaceId: t, query: n, oidFields: r, spatialReference: i, geometryType: s } = this, o = { workspaceId: t, query: n, oidFields: r, spatialReference: (e = i == null ? void 0 : i.clone()) != null ? e : void 0, geometryType: s };
    return new ZE(o);
  }
};
u([De({ queryTable: "query-table" })], Xa.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Xa.prototype, "workspaceId", void 0), u([d({ type: String, json: { write: !0 } })], Xa.prototype, "query", void 0), u([d({ type: String, json: { write: !0 } })], Xa.prototype, "oidFields", void 0), u([d({ type: Qe, json: { write: !0 } })], Xa.prototype, "spatialReference", void 0), u([De(BQ)], Xa.prototype, "geometryType", void 0), Xa = ZE = u([T("geoscene.layers.support.source.QueryTableDataSource")], Xa);
var KE;
let gh = KE = class extends se {
  constructor(e) {
    super(e), this.type = "raster";
  }
  clone() {
    const { workspaceId: e, dataSourceName: t } = this;
    return new KE({ workspaceId: e, dataSourceName: t });
  }
};
u([De({ raster: "raster" })], gh.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], gh.prototype, "dataSourceName", void 0), u([d({ type: String, json: { write: !0 } })], gh.prototype, "workspaceId", void 0), gh = KE = u([T("geoscene.layers.support.source.RasterDataSource")], gh);
var YE;
let Jc = YE = class extends se {
  constructor(e) {
    super(e), this.type = "table";
  }
  clone() {
    const { workspaceId: e, gdbVersion: t, dataSourceName: n } = this;
    return new YE({ workspaceId: e, gdbVersion: t, dataSourceName: n });
  }
};
u([De({ table: "table" })], Jc.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Jc.prototype, "workspaceId", void 0), u([d({ type: String, json: { write: !0 } })], Jc.prototype, "gdbVersion", void 0), u([d({ type: String, json: { write: !0 } })], Jc.prototype, "dataSourceName", void 0), Jc = YE = u([T("geoscene.layers.support.source.TableDataSource")], Jc);
var QE, XE;
const coe = $r()({ esriLeftInnerJoin: "left-inner-join", esriLeftOuterJoin: "left-outer-join" });
let Di = QE = class extends se {
  constructor(e) {
    super(e), this.type = "join-table";
  }
  readLeftTableSource(e, t, n) {
    return NR()(e, t, n);
  }
  castLeftTableSource(e) {
    return Ia(eI(), e);
  }
  readRightTableSource(e, t, n) {
    return NR()(e, t, n);
  }
  castRightTableSource(e) {
    return Ia(eI(), e);
  }
  clone() {
    var e, t;
    const { leftTableKey: n, rightTableKey: r, leftTableSource: i, rightTableSource: s, joinType: o } = this, a = { leftTableKey: n, rightTableKey: r, leftTableSource: (e = i == null ? void 0 : i.clone()) != null ? e : void 0, rightTableSource: (t = s == null ? void 0 : s.clone()) != null ? t : void 0, joinType: o };
    return new QE(a);
  }
};
u([De({ joinTable: "join-table" })], Di.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Di.prototype, "leftTableKey", void 0), u([d({ type: String, json: { write: !0 } })], Di.prototype, "rightTableKey", void 0), u([d({ json: { write: !0 } })], Di.prototype, "leftTableSource", void 0), u([be("leftTableSource")], Di.prototype, "readLeftTableSource", null), u([mt("leftTableSource")], Di.prototype, "castLeftTableSource", null), u([d({ json: { write: !0 } })], Di.prototype, "rightTableSource", void 0), u([be("rightTableSource")], Di.prototype, "readRightTableSource", null), u([mt("rightTableSource")], Di.prototype, "castRightTableSource", null), u([De(coe)], Di.prototype, "joinType", void 0), Di = QE = u([T("geoscene.layers.support.source.JoinTableDataSource")], Di);
let Y2 = null;
function NR() {
  return Y2 || (Y2 = zf({ types: eI() })), Y2;
}
let Q2 = null;
function eI() {
  return Q2 || (Q2 = { key: "type", base: null, typeMap: { "data-layer": Hi, "map-layer": yh } }), Q2;
}
const doe = { key: "type", base: null, typeMap: { "join-table": Di, "query-table": Xa, raster: gh, table: Jc } };
let Hi = XE = class extends se {
  constructor(e) {
    super(e), this.type = "data-layer";
  }
  clone() {
    const { fields: e, dataSource: t } = this;
    return new XE({ fields: e, dataSource: t });
  }
};
u([De({ dataLayer: "data-layer" })], Hi.prototype, "type", void 0), u([d({ type: [_S], json: { write: !0 } })], Hi.prototype, "fields", void 0), u([d({ types: doe, json: { write: !0 } })], Hi.prototype, "dataSource", void 0), Hi = XE = u([T("geoscene.layers.support.source.DataLayerSource")], Hi), Hi.from = kn(Hi);
var tI;
const DR = new st({ upperLeft: "upper-left", lowerLeft: "lower-left" });
let Zc = tI = class extends se {
  constructor(e) {
    super(e), this.extent = null, this.mode = "view", this.originPosition = "upper-left", this.tolerance = 1;
  }
  clone() {
    return new tI(q({ extent: this.extent, mode: this.mode, originPosition: this.originPosition, tolerance: this.tolerance }));
  }
};
u([d({ type: Mt, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], Zc.prototype, "extent", void 0), u([d({ type: ["view", "edit"], json: { write: !0 } })], Zc.prototype, "mode", void 0), u([d({ type: String, json: { read: DR.read, write: DR.write } })], Zc.prototype, "originPosition", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], Zc.prototype, "tolerance", void 0), Zc = tI = u([T("geoscene.rest.support.QuantizationParameters")], Zc);
const yV = Zc;
var nI;
const jR = new st({ count: "count", sum: "sum", min: "min", max: "max", avg: "avg", stddev: "stddev", var: "var", exceedslimit: "exceedslimit", percentile_cont: "percentile-continuous", percentile_disc: "percentile-discrete", EnvelopeAggregate: "envelope-aggregate", CentroidAggregate: "centroid-aggregate", ConvexHullAggregate: "convex-hull-aggregate" });
let ho = nI = class extends se {
  constructor(e) {
    super(e), this.maxPointCount = void 0, this.maxRecordCount = void 0, this.maxVertexCount = void 0, this.onStatisticField = null, this.outStatisticFieldName = null, this.statisticType = null, this.statisticParameters = null;
  }
  writeStatisticParameters(e, t) {
    this.statisticType !== "percentile-continuous" && this.statisticType !== "percentile-discrete" || (t.statisticParameters = q(e));
  }
  clone() {
    return new nI({ maxPointCount: this.maxPointCount, maxRecordCount: this.maxRecordCount, maxVertexCount: this.maxVertexCount, onStatisticField: this.onStatisticField, outStatisticFieldName: this.outStatisticFieldName, statisticType: this.statisticType, statisticParameters: q(this.statisticParameters) });
  }
};
u([d({ type: Number, json: { write: !0 } })], ho.prototype, "maxPointCount", void 0), u([d({ type: Number, json: { write: !0 } })], ho.prototype, "maxRecordCount", void 0), u([d({ type: Number, json: { write: !0 } })], ho.prototype, "maxVertexCount", void 0), u([d({ type: String, json: { write: !0 } })], ho.prototype, "onStatisticField", void 0), u([d({ type: String, json: { write: !0 } })], ho.prototype, "outStatisticFieldName", void 0), u([d({ type: String, json: { read: { source: "statisticType", reader: jR.read }, write: { target: "statisticType", writer: jR.write } } })], ho.prototype, "statisticType", void 0), u([d({ type: Object })], ho.prototype, "statisticParameters", void 0), u([xe("statisticParameters")], ho.prototype, "writeStatisticParameters", null), ho = nI = u([T("geoscene.rest.support.StatisticDefinition")], ho);
const gV = ho;
var sf;
const poe = new st({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), hoe = new st({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let Ve = sf = class extends se {
  constructor(e) {
    super(e), this.aggregateIds = null, this.cacheHint = void 0, this.compactGeometryEnabled = !1, this.datumTransformation = null, this.defaultSpatialReferenceEnabled = !1, this.distance = void 0, this.dynamicDataSource = void 0, this.formatOf3DObjects = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = void 0, this.groupByFieldsForStatistics = null, this.having = null, this.historicMoment = null, this.maxAllowableOffset = void 0, this.maxRecordCountFactor = 1, this.multipatchOption = null, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.outStatistics = null, this.parameterValues = null, this.pixelSize = null, this.quantizationParameters = null, this.rangeValues = null, this.relationParameter = null, this.resultType = null, this.returnCentroid = !1, this.returnDistinctValues = !1, this.returnExceededLimitFeatures = !0, this.returnGeometry = !1, this.returnQueryGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.sourceSpatialReference = null, this.spatialRelationship = "intersects", this.start = void 0, this.sqlFormat = null, this.text = null, this.timeExtent = null, this.timeReferenceUnknownClient = !1, this.units = null, this.where = null;
  }
  static from(e) {
    return JC(sf, e);
  }
  castDatumTransformation(e) {
    return typeof e == "number" || typeof e == "object" ? e : null;
  }
  writeHistoricMoment(e, t) {
    t.historicMoment = e && e.getTime();
  }
  writeParameterValues(e, t) {
    if (e) {
      const n = {};
      for (const r in e) {
        const i = e[r];
        Array.isArray(i) ? n[r] = i.map((s) => s instanceof Date ? s.getTime() : s) : i instanceof Date ? n[r] = i.getTime() : n[r] = i;
      }
      t.parameterValues = n;
    }
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10, t.where = "1=1";
  }
  writeWhere(e, t) {
    t.where = e || "1=1";
  }
  clone() {
    return new sf(q({ aggregateIds: this.aggregateIds, cacheHint: this.cacheHint, compactGeometryEnabled: this.compactGeometryEnabled, datumTransformation: this.datumTransformation, defaultSpatialReferenceEnabled: this.defaultSpatialReferenceEnabled, distance: this.distance, gdbVersion: this.gdbVersion, geometry: this.geometry, geometryPrecision: this.geometryPrecision, groupByFieldsForStatistics: this.groupByFieldsForStatistics, having: this.having, historicMoment: O(this.historicMoment) ? new Date(this.historicMoment.getTime()) : null, maxAllowableOffset: this.maxAllowableOffset, maxRecordCountFactor: this.maxRecordCountFactor, multipatchOption: this.multipatchOption, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, outStatistics: this.outStatistics, parameterValues: this.parameterValues, pixelSize: this.pixelSize, quantizationParameters: this.quantizationParameters, rangeValues: this.rangeValues, relationParameter: this.relationParameter, resultType: this.resultType, returnDistinctValues: this.returnDistinctValues, returnGeometry: this.returnGeometry, returnCentroid: this.returnCentroid, returnExceededLimitFeatures: this.returnExceededLimitFeatures, returnQueryGeometry: this.returnQueryGeometry, returnM: this.returnM, returnZ: this.returnZ, dynamicDataSource: this.dynamicDataSource, sourceSpatialReference: this.sourceSpatialReference, spatialRelationship: this.spatialRelationship, start: this.start, sqlFormat: this.sqlFormat, text: this.text, timeExtent: this.timeExtent, timeReferenceUnknownClient: this.timeReferenceUnknownClient, units: this.units, where: this.where }));
  }
};
Ve.MAX_MAX_RECORD_COUNT_FACTOR = 5, u([d({ json: { write: !0 } })], Ve.prototype, "aggregateIds", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ve.prototype, "cacheHint", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "compactGeometryEnabled", void 0), u([d({ json: { write: !0 } })], Ve.prototype, "datumTransformation", void 0), u([mt("datumTransformation")], Ve.prototype, "castDatumTransformation", null), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "defaultSpatialReferenceEnabled", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e) => ({ enabled: e > 0 }) } } })], Ve.prototype, "distance", void 0), u([d({ type: Hi, json: { write: !0 } })], Ve.prototype, "dynamicDataSource", void 0), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "formatOf3DObjects", void 0), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "gdbVersion", void 0), u([d({ types: Tp, json: { read: tc, write: !0 } })], Ve.prototype, "geometry", void 0), u([d({ type: Number, json: { write: !0 } })], Ve.prototype, "geometryPrecision", void 0), u([d({ type: [String], json: { write: !0 } })], Ve.prototype, "groupByFieldsForStatistics", void 0), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "having", void 0), u([d({ type: Date })], Ve.prototype, "historicMoment", void 0), u([xe("historicMoment")], Ve.prototype, "writeHistoricMoment", null), u([d({ type: Number, json: { write: !0 } })], Ve.prototype, "maxAllowableOffset", void 0), u([d({ type: Number, cast: (e) => e < 1 ? 1 : e > sf.MAX_MAX_RECORD_COUNT_FACTOR ? sf.MAX_MAX_RECORD_COUNT_FACTOR : e, json: { write: { overridePolicy: (e) => ({ enabled: e > 1 }) } } })], Ve.prototype, "maxRecordCountFactor", void 0), u([d({ type: ["xyFootprint"], json: { write: !0 } })], Ve.prototype, "multipatchOption", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Ve.prototype, "num", void 0), u([d({ json: { write: !0 } })], Ve.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], Ve.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], Ve.prototype, "outFields", void 0), u([d({ type: Qe, json: { name: "outSR", write: !0 } })], Ve.prototype, "outSpatialReference", void 0), u([d({ type: [gV], json: { write: { enabled: !0, overridePolicy() {
  return { enabled: O(this.outStatistics) && this.outStatistics.length > 0 };
} } } })], Ve.prototype, "outStatistics", void 0), u([d({ json: { write: !0 } })], Ve.prototype, "parameterValues", void 0), u([xe("parameterValues")], Ve.prototype, "writeParameterValues", null), u([d({ type: Oe, json: { write: !0 } })], Ve.prototype, "pixelSize", void 0), u([d({ type: yV, json: { write: !0 } })], Ve.prototype, "quantizationParameters", void 0), u([d({ type: [Object], json: { write: !0 } })], Ve.prototype, "rangeValues", void 0), u([d({ type: String, json: { read: { source: "relationParam" }, write: { target: "relationParam", overridePolicy() {
  return { enabled: this.spatialRelationship === "relation" };
} } } })], Ve.prototype, "relationParameter", void 0), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "resultType", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "returnCentroid", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "returnDistinctValues", void 0), u([d({ type: Boolean, json: { default: !0, write: !0 } })], Ve.prototype, "returnExceededLimitFeatures", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ve.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "returnQueryGeometry", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Ve.prototype, "returnZ", void 0), u([d({ type: Qe, json: { write: !0 } })], Ve.prototype, "sourceSpatialReference", void 0), u([De(poe, { ignoreUnknown: !1, name: "spatialRel" })], Ve.prototype, "spatialRelationship", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Ve.prototype, "start", void 0), u([xe("start"), xe("num")], Ve.prototype, "writeStart", null), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "sqlFormat", void 0), u([d({ type: String, json: { write: !0 } })], Ve.prototype, "text", void 0), u([d({ type: La, json: { write: !0 } })], Ve.prototype, "timeExtent", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ve.prototype, "timeReferenceUnknownClient", void 0), u([De(hoe, { ignoreUnknown: !1 }), d({ json: { write: { overridePolicy(e) {
  return { enabled: e && this.distance > 0 };
} } } })], Ve.prototype, "units", void 0), u([d({ type: String, json: { write: { overridePolicy(e) {
  return { enabled: e != null || this.start > 0 };
} } } })], Ve.prototype, "where", void 0), u([xe("where")], Ve.prototype, "writeWhere", null), Ve = sf = u([T("geoscene.rest.support.Query")], Ve);
const Jr = Ve;
var rI;
let pn = rI = class extends se {
  constructor(e) {
    super(e), this.dynamicDataSource = void 0, this.gdbVersion = null, this.geometryPrecision = void 0, this.historicMoment = null, this.maxAllowableOffset = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.relationshipId = void 0, this.start = void 0, this.num = void 0, this.returnGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.where = null;
  }
  _writeHistoricMoment(e, t) {
    t.historicMoment = e && e.getTime();
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10, this.start > 0 && this.where == null && (t.definitionExpression = "1=1");
  }
  clone() {
    return new rI(q({ dynamicDataSource: this.dynamicDataSource, gdbVersion: this.gdbVersion, geometryPrecision: this.geometryPrecision, historicMoment: this.historicMoment && new Date(this.historicMoment.getTime()), maxAllowableOffset: this.maxAllowableOffset, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, relationshipId: this.relationshipId, start: this.start, num: this.num, returnGeometry: this.returnGeometry, where: this.where, returnZ: this.returnZ, returnM: this.returnM }));
  }
};
u([d({ type: Hi, json: { write: !0 } })], pn.prototype, "dynamicDataSource", void 0), u([d({ type: String, json: { write: !0 } })], pn.prototype, "gdbVersion", void 0), u([d({ type: Number, json: { write: !0 } })], pn.prototype, "geometryPrecision", void 0), u([d({ type: Date })], pn.prototype, "historicMoment", void 0), u([xe("historicMoment")], pn.prototype, "_writeHistoricMoment", null), u([d({ type: Number, json: { write: !0 } })], pn.prototype, "maxAllowableOffset", void 0), u([d({ type: [Number], json: { write: !0 } })], pn.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], pn.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], pn.prototype, "outFields", void 0), u([d({ type: Qe, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], pn.prototype, "outSpatialReference", void 0), u([d({ json: { write: !0 } })], pn.prototype, "relationshipId", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], pn.prototype, "start", void 0), u([xe("start"), xe("num")], pn.prototype, "writeStart", null), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], pn.prototype, "num", void 0), u([d({ json: { write: !0 } })], pn.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], pn.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], pn.prototype, "returnZ", void 0), u([d({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], pn.prototype, "where", void 0), pn = rI = u([T("geoscene.rest.support.RelationshipQuery")], pn), pn.from = kn(pn);
const hp = pn;
function wLe(e, t) {
  return t ? { ...t, query: { ...e, ...t.query } } : { query: e };
}
function Js(e) {
  return typeof e == "string" ? cr(e) : e;
}
function foe(e, t, n) {
  const r = {};
  for (const i in e) {
    if (i === "declaredClass")
      continue;
    const s = e[i];
    if (s != null && typeof s != "function")
      if (Array.isArray(s)) {
        r[i] = [];
        for (let o = 0; o < s.length; o++)
          r[i][o] = foe(s[o]);
      } else if (typeof s == "object")
        if (s.toJSON) {
          const o = s.toJSON(n && n[i]);
          r[i] = t ? o : JSON.stringify(o);
        } else
          r[i] = t ? s : JSON.stringify(s);
      else
        r[i] = s;
  }
  return r;
}
function R0(e) {
  const t = {};
  for (const n in e) {
    if (n === "declaredClass")
      continue;
    const r = e[n];
    if (r != null && typeof r != "function")
      if (Array.isArray(r)) {
        t[n] = [];
        for (let i = 0; i < r.length; i++)
          t[n][i] = R0(r[i]);
      } else
        typeof r == "object" ? r.toJSON && (t[n] = JSON.stringify(r)) : t[n] = r;
  }
  return t;
}
function moe(e) {
  const t = e.toJSON();
  return t.attachmentTypes && (t.attachmentTypes = t.attachmentTypes.join(",")), t.keywords && (t.keywords = t.keywords.join(",")), t.globalIds && (t.globalIds = t.globalIds.join(",")), t.objectIds && (t.objectIds = t.objectIds.join(",")), t.size && (t.size = t.size.join(",")), t;
}
function yoe(e, t) {
  const n = {};
  for (const r of e) {
    const { parentObjectId: i, parentGlobalId: s, attachmentInfos: o } = r;
    for (const a of o) {
      const { id: l } = a, c = IK(eY(`${t}/${i}/attachments/${l}`)), p = Y9.fromJSON(a);
      p.set({ url: c, parentObjectId: i, parentGlobalId: s }), n[i] ? n[i].push(p) : n[i] = [p];
    }
  }
  return n;
}
function goe(e, t, n) {
  let r = { query: R0({ ...e.query, f: "json", ...moe(t) }) };
  return n && (r = { ...n, ...r, query: { ...n.query, ...r.query } }), rn(e.path + "/queryAttachments", r);
}
async function voe(e, t, n) {
  const r = Js(e);
  return goe(r, U1.from(t), { ...n }).then((i) => yoe(i.data.attachmentGroups, r.path));
}
const qh = { 102100: { maxX: 20037508342788905e-9, minX: -20037508342788905e-9, plus180Line: new Ki({ paths: [[[20037508342788905e-9, -20037508342788905e-9], [20037508342788905e-9, 20037508342788905e-9]]], spatialReference: Qe.WebMercator }), minus180Line: new Ki({ paths: [[[-20037508342788905e-9, -20037508342788905e-9], [-20037508342788905e-9, 20037508342788905e-9]]], spatialReference: Qe.WebMercator }) }, 4326: { maxX: 180, minX: -180, plus180Line: new Ki({ paths: [[[180, -180], [180, 180]]], spatialReference: Qe.WGS84 }), minus180Line: new Ki({ paths: [[[-180, -180], [-180, 180]]], spatialReference: Qe.WGS84 }) } };
function Pd(e, t) {
  return Math.ceil((e - t) / (2 * t));
}
function vV(e, t) {
  const n = ig(e);
  for (const r of n)
    for (const i of r)
      i[0] += t;
  return e;
}
function ig(e) {
  return Bd(e) ? e.rings : e.paths;
}
function _Le(e) {
  const t = e != null && e.isWebMercator ? 102100 : 4326;
  return [qh[t].minX, qh[t].maxX];
}
async function boe(e, t, n, r) {
  const i = typeof e == "string" ? cr(e) : e, s = t[0].spatialReference, o = { ...r, query: { ...i.query, f: "json", sr: JSON.stringify(s), target: JSON.stringify({ geometryType: w0(t[0]), geometries: t }), cutter: JSON.stringify(n) } }, a = await rn(i.path + "/cut", o), { cutIndexes: l, geometries: c = [] } = a.data;
  return { cutIndexes: l, geometries: c.map((p) => {
    const f = tc(p);
    return f.spatialReference = s, f;
  }) };
}
async function woe(e, t, n) {
  const r = typeof e == "string" ? cr(e) : e, i = t[0].spatialReference, s = w0(t[0]), o = { ...n, query: { ...r.query, f: "json", sr: i.wkid ? i.wkid : JSON.stringify(i), geometries: JSON.stringify(_oe(t)) } };
  return Soe((await rn(r.path + "/simplify", o)).data, s, i);
}
function _oe(e) {
  return { geometryType: w0(e[0]), geometries: e.map((t) => t.toJSON()) };
}
function Soe(e, t, n) {
  const r = qQ(t);
  return e.map((i) => {
    const s = r.fromJSON(i);
    return s.spatialReference = n, s;
  });
}
const xoe = we.getLogger("geoscene.geometry.support.normalizeUtils");
function $oe(e) {
  return e.type === "polygon";
}
function Toe(e) {
  return e[0].type === "polygon";
}
function Eoe(e) {
  return e[0].type === "polyline";
}
function Ioe(e, t) {
  if (!(e instanceof Ki || e instanceof Po)) {
    const i = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw xoe.error(i), new D(i);
  }
  const n = ig(e), r = [];
  for (const i of n) {
    const s = [];
    r.push(s), s.push([i[0][0], i[0][1]]);
    for (let o = 0; o < i.length - 1; o++) {
      const a = i[o][0], l = i[o][1], c = i[o + 1][0], p = i[o + 1][1], f = Math.sqrt((c - a) * (c - a) + (p - l) * (p - l)), m = (p - l) / f, y = (c - a) / f, g = f / t;
      if (g > 1) {
        for (let S = 1; S <= g - 1; S++) {
          const $ = S * t, I = y * $ + a, M = m * $ + l;
          s.push([I, M]);
        }
        const v = (f + Math.floor(g - 1) * t) / 2, w = y * v + a, b = m * v + l;
        s.push([w, b]);
      }
      s.push([c, p]);
    }
  }
  return $oe(e) ? new Po({ rings: r, spatialReference: e.spatialReference }) : new Ki({ paths: r, spatialReference: e.spatialReference });
}
function VR(e, t, n) {
  if (t) {
    const r = Ioe(e, 1e6);
    e = Ym(r, !0);
  }
  return n && (e = vV(e, n)), e;
}
function zR(e, t, n) {
  if (Array.isArray(e)) {
    const r = e[0];
    if (r > t) {
      const i = Pd(r, t);
      e[0] = r + i * (-2 * t);
    } else if (r < n) {
      const i = Pd(r, n);
      e[0] = r + i * (-2 * n);
    }
  } else {
    const r = e.x;
    if (r > t) {
      const i = Pd(r, t);
      e = e.clone().offset(i * (-2 * t), 0);
    } else if (r < n) {
      const i = Pd(r, n);
      e = e.clone().offset(i * (-2 * n), 0);
    }
  }
  return e;
}
function Moe(e, t) {
  let n = -1;
  for (let r = 0; r < t.cutIndexes.length; r++) {
    const i = t.cutIndexes[r], s = t.geometries[r], o = ig(s);
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      l.some((c) => {
        if (c[0] < 180)
          return !0;
        {
          let p = 0;
          for (let m = 0; m < l.length; m++) {
            const y = l[m][0];
            p = y > p ? y : p;
          }
          p = Number(p.toFixed(9));
          const f = -360 * Pd(p, 180);
          for (let m = 0; m < l.length; m++) {
            const y = s.getPoint(a, m);
            s.setPoint(a, m, y.clone().offset(f, 0));
          }
          return !0;
        }
      });
    }
    if (i === n) {
      if (Toe(e))
        for (const a of ig(s))
          e[i] = e[i].addRing(a);
      else if (Eoe(e))
        for (const a of ig(s))
          e[i] = e[i].addPath(a);
    } else
      n = i, e[i] = s;
  }
  return e;
}
async function hk(e, t, n) {
  var r;
  if (!Array.isArray(e))
    return hk([e], t);
  const i = (r = t == null ? void 0 : t.url) != null ? r : Pt.geometryServiceUrl;
  let s, o, a, l, c, p, f, m, y = 0;
  const g = [], v = [];
  for (const M of e)
    if (H(M))
      v.push(M);
    else if (s || (s = M.spatialReference, o = Oo(s), a = s.isWebMercator, p = a ? 102100 : 4326, l = qh[p].maxX, c = qh[p].minX, f = qh[p].plus180Line, m = qh[p].minus180Line), o)
      if (M.type === "mesh")
        v.push(M);
      else if (M.type === "point")
        v.push(zR(M.clone(), l, c));
      else if (M.type === "multipoint") {
        const E = M.clone();
        E.points = E.points.map((C) => zR(C, l, c)), v.push(E);
      } else if (M.type === "extent") {
        const E = M.clone()._normalize(!1, !1, o);
        v.push(E.rings ? new Po(E) : E);
      } else if (M.extent) {
        const E = M.extent, C = Pd(E.xmin, c) * (2 * l);
        let A = C === 0 ? M.clone() : vV(M.clone(), C);
        E.offset(C, 0), E.intersects(f) && E.xmax !== l ? (y = E.xmax > y ? E.xmax : y, A = VR(A, a), g.push(A), v.push("cut")) : E.intersects(m) && E.xmin !== c ? (y = E.xmax * (2 * l) > y ? E.xmax * (2 * l) : y, A = VR(A, a, 360), g.push(A), v.push("cut")) : v.push(A);
      } else
        v.push(M.clone());
    else
      v.push(M);
  let w = Pd(y, l), b = -90;
  const S = w, $ = new Ki();
  for (; w > 0; ) {
    const M = 360 * w - 180;
    $.addPath([[M, b], [M, -1 * b]]), b *= -1, w--;
  }
  if (g.length > 0 && S > 0) {
    const M = Moe(g, await boe(i, g, $, n)), E = [], C = [];
    for (let j = 0; j < v.length; j++) {
      const G = v[j];
      if (G !== "cut")
        C.push(G);
      else {
        const R = M.shift(), V = e[j];
        O(V) && V.type === "polygon" && V.rings && V.rings.length > 1 && R.rings.length >= V.rings.length ? (E.push(R), C.push("simplify")) : C.push(a ? Zu(R) : R);
      }
    }
    if (!E.length)
      return C;
    const A = await woe(i, E, n), W = [];
    for (let j = 0; j < C.length; j++) {
      const G = C[j];
      G !== "simplify" ? W.push(G) : W.push(a ? Zu(A.shift()) : A.shift());
    }
    return W;
  }
  const I = [];
  for (let M = 0; M < v.length; M++) {
    const E = v[M];
    if (E !== "cut")
      I.push(E);
    else {
      const C = g.shift();
      I.push(a === !0 ? Zu(C) : C);
    }
  }
  return Promise.resolve(I);
}
function SLe(e, t) {
  const n = Oo(t);
  if (n) {
    const [r, i] = n.valid, s = i - r;
    if (e < r)
      for (; e < r; )
        e += s;
    if (e > i)
      for (; e > i; )
        e -= s;
  }
  return e;
}
var Pu;
(function(e) {
  e[e.varint = 0] = "varint", e[e.fixed64 = 1] = "fixed64", e[e.delimited = 2] = "delimited", e[e.fixed32 = 5] = "fixed32", e[e.unknown = 99] = "unknown";
})(Pu || (Pu = {}));
const BR = 4294967296, Coe = new TextDecoder("utf-8"), Ooe = K("safari") || K("ios") ? 6 : K("ff") ? 12 : 32;
let iI = class nw {
  constructor(t, n, r = 0, i = t ? t.byteLength : 0) {
    this._tag = 0, this._dataType = Pu.unknown, this._init(t, n, r, i);
  }
  _init(t, n, r, i) {
    this._data = t, this._dataView = n, this._pos = r, this._end = i;
  }
  clone() {
    return new nw(this._data, this._dataView, this._pos, this._end);
  }
  pos() {
    return this._pos;
  }
  move(t) {
    this._pos = t;
  }
  nextTag(t) {
    for (; ; ) {
      if (this._pos === this._end)
        return !1;
      const n = this._decodeVarint();
      if (this._tag = n >> 3, this._dataType = 7 & n, !t || t === this._tag)
        break;
      this.skip();
    }
    return !0;
  }
  next() {
    if (this._pos === this._end)
      return !1;
    const t = this._decodeVarint();
    return this._tag = t >> 3, this._dataType = 7 & t, !0;
  }
  empty() {
    return this._pos >= this._end;
  }
  tag() {
    return this._tag;
  }
  getInt32() {
    return this._decodeVarint();
  }
  getInt64() {
    return this._decodeVarint();
  }
  getUInt32() {
    let t = 4294967295;
    return t = (127 & this._data[this._pos]) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 7) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 14) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 21) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (15 & this._data[this._pos]) << 28) >>> 0, this._data[this._pos++] < 128 ? t : void 0))));
  }
  getUInt64() {
    return this._decodeVarint();
  }
  getSInt32() {
    const t = this.getUInt32();
    return t >>> 1 ^ -(1 & t) | 0;
  }
  getSInt64() {
    return this._decodeSVarint();
  }
  getBool() {
    const t = this._data[this._pos] !== 0;
    return this._skip(1), t;
  }
  getEnum() {
    return this._decodeVarint();
  }
  getFixed64() {
    const t = this._dataView, n = this._pos, r = t.getUint32(n, !0) + t.getUint32(n + 4, !0) * BR;
    return this._skip(8), r;
  }
  getSFixed64() {
    const t = this._dataView, n = this._pos, r = t.getUint32(n, !0) + t.getInt32(n + 4, !0) * BR;
    return this._skip(8), r;
  }
  getDouble() {
    const t = this._dataView.getFloat64(this._pos, !0);
    return this._skip(8), t;
  }
  getFixed32() {
    const t = this._dataView.getUint32(this._pos, !0);
    return this._skip(4), t;
  }
  getSFixed32() {
    const t = this._dataView.getInt32(this._pos, !0);
    return this._skip(4), t;
  }
  getFloat() {
    const t = this._dataView.getFloat32(this._pos, !0);
    return this._skip(4), t;
  }
  getString() {
    const t = this._getLength(), n = this._pos, r = this._toString(this._data, n, n + t);
    return this._skip(t), r;
  }
  getBytes() {
    const t = this._getLength(), n = this._pos, r = this._toBytes(this._data, n, n + t);
    return this._skip(t), r;
  }
  getLength() {
    return this._getLengthUnsafe();
  }
  processMessageWithArgs(t, n, r, i) {
    const s = this.getMessage(), o = t(s, n, r, i);
    return s.release(), o;
  }
  processMessage(t) {
    const n = this.getMessage(), r = t(n);
    return n.release(), r;
  }
  getMessage() {
    const t = this._getLength(), n = nw.pool.acquire();
    return n._init(this._data, this._dataView, this._pos, this._pos + t), this._skip(t), n;
  }
  release() {
    nw.pool.release(this);
  }
  dataType() {
    return this._dataType;
  }
  skip() {
    switch (this._dataType) {
      case Pu.varint:
        this._decodeVarint();
        break;
      case Pu.fixed64:
        this._skip(8);
        break;
      case Pu.delimited:
        this._skip(this._getLength());
        break;
      case Pu.fixed32:
        this._skip(4);
        break;
      default:
        throw new Error("Invalid data type!");
    }
  }
  skipLen(t) {
    this._skip(t);
  }
  _skip(t) {
    if (this._pos + t > this._end)
      throw new Error("Attempt to skip past the end of buffer!");
    this._pos += t;
  }
  _decodeVarint() {
    const t = this._data;
    let n, r = this._pos, i = 0;
    if (this._end - r >= 10)
      do {
        if (n = t[r++], i |= 127 & n, (128 & n) == 0 || (n = t[r++], i |= (127 & n) << 7, (128 & n) == 0) || (n = t[r++], i |= (127 & n) << 14, (128 & n) == 0) || (n = t[r++], i |= (127 & n) << 21, (128 & n) == 0) || (n = t[r++], i += 268435456 * (127 & n), (128 & n) == 0) || (n = t[r++], i += 34359738368 * (127 & n), (128 & n) == 0) || (n = t[r++], i += 4398046511104 * (127 & n), (128 & n) == 0) || (n = t[r++], i += 562949953421312 * (127 & n), (128 & n) == 0) || (n = t[r++], i += 72057594037927940 * (127 & n), (128 & n) == 0) || (n = t[r++], i += 9223372036854776e3 * (127 & n), (128 & n) == 0))
          break;
        throw new Error("Varint too long!");
      } while (!1);
    else {
      let s = 1;
      for (; r !== this._end && (n = t[r], (128 & n) != 0); )
        ++r, i += (127 & n) * s, s *= 128;
      if (r === this._end)
        throw new Error("Varint overrun!");
      ++r, i += n * s;
    }
    return this._pos = r, i;
  }
  _decodeSVarint() {
    const t = this._decodeVarint();
    return t % 2 ? -(t + 1) / 2 : t / 2;
  }
  _getLength() {
    if (this._dataType !== Pu.delimited)
      throw new Error("Not a delimited data type!");
    return this._decodeVarint();
  }
  _getLengthUnsafe() {
    return this.getUInt32();
  }
  _toString(t, n, r) {
    if ((r = Math.min(this._end, r)) - n > Ooe) {
      const o = t.subarray(n, r);
      return Coe.decode(o);
    }
    let i = "", s = "";
    for (let o = n; o < r; ++o) {
      const a = t[o];
      128 & a ? s += "%" + a.toString(16) : (i += decodeURIComponent(s) + String.fromCharCode(a), s = "");
    }
    return s.length && (i += decodeURIComponent(s)), i;
  }
  _toBytes(t, n, r) {
    return r = Math.min(this._end, r), new Uint8Array(t.buffer, n, r - n);
  }
};
iI.pool = new fc(iI, null, (e) => {
  e._data = null, e._dataView = null;
});
let Lo = class sI {
  constructor(t = [], n = [], r = !1) {
    this.lengths = t ?? [], this.coords = n ?? [], this.hasIndeterminateRingOrder = r;
  }
  get isPoint() {
    return this.lengths.length === 0;
  }
  get maxLength() {
    return Math.max(...this.lengths);
  }
  get size() {
    return this.lengths.reduce((t, n) => t + n);
  }
  forEachVertex(t) {
    let n = 0;
    this.lengths.length || t(this.coords[0], this.coords[1]);
    for (let r = 0; r < this.lengths.length; r++) {
      const i = this.lengths[r];
      for (let s = 0; s < i; s++)
        t(this.coords[2 * (s + n)], this.coords[2 * (s + n) + 1]);
      n += i;
    }
  }
  clone(t) {
    return t ? (t.set(this.coords), new sI(this.lengths.slice(), t, this.hasIndeterminateRingOrder)) : new sI(this.lengths.slice(), this.coords.slice(), this.hasIndeterminateRingOrder);
  }
}, sc = class bV {
  constructor(t = null, n = {}, r, i) {
    this.geometry = t, this.attributes = n, this.centroid = r, this.objectId = i, this.displayId = 0, this.geohashX = 0, this.geohashY = 0;
  }
  weakClone() {
    const t = new bV(this.geometry, this.attributes, this.centroid, this.objectId);
    return t.displayId = this.displayId, t.geohashX = this.geohashX, t.geohashY = this.geohashY, t;
  }
};
function koe(e) {
  return !(H(e.geometry) || !e.geometry.coords || !e.geometry.coords.length);
}
let xLe = class extends sc {
}, wV = class _V {
  constructor() {
    this.objectIdFieldName = null, this.globalIdFieldName = null, this.geohashFieldName = null, this.geometryProperties = null, this.geometryType = null, this.spatialReference = null, this.hasZ = !1, this.hasM = !1, this.features = [], this.fields = [], this.transform = null, this.exceededTransferLimit = !1, this.uniqueIdField = null, this.queryGeometryType = null, this.queryGeometry = null;
  }
  weakClone() {
    const t = new _V();
    return t.objectIdFieldName = this.objectIdFieldName, t.globalIdFieldName = this.globalIdFieldName, t.geohashFieldName = this.geohashFieldName, t.geometryProperties = this.geometryProperties, t.geometryType = this.geometryType, t.spatialReference = this.spatialReference, t.hasZ = this.hasZ, t.hasM = this.hasM, t.features = this.features, t.fields = this.fields, t.transform = this.transform, t.exceededTransferLimit = this.exceededTransferLimit, t.uniqueIdField = this.uniqueIdField, t.queryGeometry = this.queryGeometry, t.queryGeometryType = this.queryGeometryType, t;
  }
};
const SV = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"];
let TLe = class {
  constructor(t) {
    this.options = t, this.geometryTypes = SV, this._coordinatePtr = 0, this._vertexDimension = 0;
  }
  createFeatureResult() {
    return new wV();
  }
  prepareFeatures(t) {
    this._vertexDimension = 2, t.hasZ && this._vertexDimension++, t.hasM && this._vertexDimension++;
  }
  finishFeatureResult(t) {
    if (!t || !t.features || !t.hasZ || !this.options.sourceSpatialReference || !t.spatialReference || Oi(t.spatialReference, this.options.sourceSpatialReference) || t.spatialReference.vcsWkid)
      return;
    const n = bf(this.options.sourceSpatialReference) / bf(t.spatialReference);
    if (n !== 1)
      for (const r of t.features) {
        if (!koe(r))
          continue;
        const i = r.geometry.coords;
        for (let s = 2; s < i.length; s += 3)
          i[s] *= n;
      }
  }
  addFeature(t, n) {
    t.features.push(n);
  }
  createFeature() {
    return new sc();
  }
  createSpatialReference() {
    return { wkid: 0 };
  }
  createGeometry() {
    return new Lo();
  }
  addField(t, n) {
    t.fields.push(n);
  }
  allocateCoordinates(t) {
    t.coords.length = t.lengths.reduce((n, r) => n + r, 0) * this._vertexDimension, this._coordinatePtr = 0;
  }
  addCoordinate(t, n) {
    t.coords[this._coordinatePtr++] = n;
  }
  addCoordinatePoint(t, n) {
    t.coords.push(n);
  }
  addLength(t, n) {
    t.lengths.push(n);
  }
  addQueryGeometry(t, n) {
    t.queryGeometry = n.queryGeometry, t.queryGeometryType = n.queryGeometryType;
  }
  createPointGeometry() {
    return new Lo();
  }
};
const UR = ["esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML"], qR = ["sqlTypeBigInt", "sqlTypeBinary", "sqlTypeBit", "sqlTypeChar", "sqlTypeDate", "sqlTypeDecimal", "sqlTypeDouble", "sqlTypeFloat", "sqlTypeGeometry", "sqlTypeGUID", "sqlTypeInteger", "sqlTypeLongNVarchar", "sqlTypeLongVarbinary", "sqlTypeLongVarchar", "sqlTypeNChar", "sqlTypeNVarchar", "sqlTypeOther", "sqlTypeReal", "sqlTypeSmallInt", "sqlTypeSqlXml", "sqlTypeTime", "sqlTypeTimestamp", "sqlTypeTimestamp2", "sqlTypeTinyInt", "sqlTypeVarbinary", "sqlTypeVarchar"], GR = ["upperLeft", "lowerLeft"];
function WR(e) {
  return e >= UR.length ? null : UR[e];
}
function Aoe(e) {
  return e >= qR.length ? null : qR[e];
}
function HR(e) {
  return e >= GR.length ? null : GR[e];
}
function JR(e, t) {
  return t >= e.geometryTypes.length ? null : e.geometryTypes[t];
}
function Poe(e, t, n) {
  const i = t.createPointGeometry(n);
  for (; e.next(); )
    switch (e.tag()) {
      case 3: {
        const s = e.getUInt32(), o = e.pos() + s;
        let a = 0;
        for (; e.pos() < o; )
          t.addCoordinatePoint(i, e.getSInt64(), a++);
        break;
      }
      default:
        e.skip();
    }
  return i;
}
function Roe(e, t, n) {
  const s = t.createGeometry(n), o = 2 + (n.hasZ ? 1 : 0) + (n.hasM ? 1 : 0);
  for (; e.next(); )
    switch (e.tag()) {
      case 2: {
        const a = e.getUInt32(), l = e.pos() + a;
        let c = 0;
        for (; e.pos() < l; )
          t.addLength(s, e.getUInt32(), c++);
        break;
      }
      case 3: {
        const a = e.getUInt32(), l = e.pos() + a;
        let c = 0;
        for (t.allocateCoordinates(s); e.pos() < l; )
          t.addCoordinate(s, e.getSInt64(), c), c++, c === o && (c = 0);
        break;
      }
      default:
        e.skip();
    }
  return s;
}
function Loe(e) {
  const i = new Lo();
  let s = "esriGeometryPoint";
  for (; e.next(); )
    switch (e.tag()) {
      case 2: {
        const o = e.getUInt32(), a = e.pos() + o;
        for (; e.pos() < a; )
          i.lengths.push(e.getUInt32());
        break;
      }
      case 3: {
        const o = e.getUInt32(), a = e.pos() + o;
        for (; e.pos() < a; )
          i.coords.push(e.getSInt64());
        break;
      }
      case 1:
        s = SV[e.getEnum()];
        break;
      default:
        e.skip();
    }
  return { queryGeometry: i, queryGeometryType: s };
}
function Foe(e) {
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        return e.getString();
      case 2:
        return e.getFloat();
      case 3:
        return e.getDouble();
      case 4:
        return e.getSInt32();
      case 5:
        return e.getUInt32();
      case 6:
        return e.getInt64();
      case 7:
        return e.getUInt64();
      case 8:
        return e.getSInt64();
      case 9:
        return e.getBool();
      default:
        return e.skip(), null;
    }
  return null;
}
function Noe(e) {
  const a = { type: WR(0) };
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        a.name = e.getString();
        break;
      case 2:
        a.type = WR(e.getEnum());
        break;
      case 3:
        a.alias = e.getString();
        break;
      case 4:
        a.sqlType = Aoe(e.getEnum());
        break;
      case 5:
        e.skip();
        break;
      case 6:
        a.defaultValue = e.getString();
        break;
      default:
        e.skip();
    }
  return a;
}
function Doe(e) {
  const r = {};
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        r.name = e.getString();
        break;
      case 2:
        r.isSystemMaintained = e.getBool();
        break;
      default:
        e.skip();
    }
  return r;
}
function joe(e, t, n, r) {
  const a = t.createFeature(n);
  let l = 0;
  for (; e.next(); )
    switch (e.tag()) {
      case 1: {
        const c = r[l++].name;
        a.attributes[c] = e.processMessage(Foe);
        break;
      }
      case 2:
        a.geometry = e.processMessageWithArgs(Roe, t, n);
        break;
      case 4:
        a.centroid = e.processMessageWithArgs(Poe, t, n);
        break;
      default:
        e.skip();
    }
  return a;
}
function Voe(e) {
  const s = [1, 1, 1, 1];
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        s[0] = e.getDouble();
        break;
      case 2:
        s[1] = e.getDouble();
        break;
      case 4:
        s[2] = e.getDouble();
        break;
      case 3:
        s[3] = e.getDouble();
        break;
      default:
        e.skip();
    }
  return s;
}
function zoe(e) {
  const s = [0, 0, 0, 0];
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        s[0] = e.getDouble();
        break;
      case 2:
        s[1] = e.getDouble();
        break;
      case 4:
        s[2] = e.getDouble();
        break;
      case 3:
        s[3] = e.getDouble();
        break;
      default:
        e.skip();
    }
  return s;
}
function Boe(e) {
  const i = { originPosition: HR(0) };
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        i.originPosition = HR(e.getEnum());
        break;
      case 2:
        i.scale = e.processMessage(Voe);
        break;
      case 3:
        i.translate = e.processMessage(zoe);
        break;
      default:
        e.skip();
    }
  return i;
}
function Uoe(e) {
  const i = {};
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        i.shapeAreaFieldName = e.getString();
        break;
      case 2:
        i.shapeLengthFieldName = e.getString();
        break;
      case 3:
        i.units = e.getString();
        break;
      default:
        e.skip();
    }
  return i;
}
function qoe(e, t) {
  const a = t.createSpatialReference();
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        a.wkid = e.getUInt32();
        break;
      case 5:
        a.wkt = e.getString();
        break;
      case 2:
        a.latestWkid = e.getUInt32();
        break;
      case 3:
        a.vcsWkid = e.getUInt32();
        break;
      case 4:
        a.latestVcsWkid = e.getUInt32();
        break;
      default:
        e.skip();
    }
  return a;
}
function Goe(e, t) {
  const v = t.createFeatureResult();
  v.geometryType = JR(t, 0);
  let w = !1;
  for (; e.next(); )
    switch (e.tag()) {
      case 1:
        v.objectIdFieldName = e.getString();
        break;
      case 3:
        v.globalIdFieldName = e.getString();
        break;
      case 4:
        v.geohashFieldName = e.getString();
        break;
      case 5:
        v.geometryProperties = e.processMessage(Uoe);
        break;
      case 7:
        v.geometryType = JR(t, e.getEnum());
        break;
      case 8:
        v.spatialReference = e.processMessageWithArgs(qoe, t);
        break;
      case 10:
        v.hasZ = e.getBool();
        break;
      case 11:
        v.hasM = e.getBool();
        break;
      case 12:
        v.transform = e.processMessage(Boe);
        break;
      case 9: {
        const b = e.getBool();
        v.exceededTransferLimit = b;
        break;
      }
      case 13:
        t.addField(v, e.processMessage(Noe));
        break;
      case 15:
        w || (t.prepareFeatures(v), w = !0), t.addFeature(v, e.processMessageWithArgs(joe, t, v, v.fields));
        break;
      case 2:
        v.uniqueIdField = e.processMessage(Doe);
        break;
      default:
        e.skip();
    }
  return t.finishFeatureResult(v), v;
}
function Woe(e, t) {
  const i = {};
  let s = null;
  for (; e.next(); )
    switch (e.tag()) {
      case 4:
        s = e.processMessageWithArgs(Loe);
        break;
      case 1:
        i.featureResult = e.processMessageWithArgs(Goe, t);
        break;
      default:
        e.skip();
    }
  return O(s) && i.featureResult && t.addQueryGeometry(i, s), i;
}
function Hoe(e, t) {
  try {
    const r = new iI(new Uint8Array(e), new DataView(e)), i = {};
    for (; r.next(); )
      r.tag() === 2 ? i.queryResult = r.processMessageWithArgs(Woe, t) : r.skip();
    return i;
  } catch (n) {
    throw new D("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: n });
  }
}
function Joe(e, t) {
  const n = Hoe(e, t), r = n.queryResult.featureResult, i = n.queryResult.queryGeometry, s = n.queryResult.queryGeometryType;
  if (r && r.features && r.features.length && r.objectIdFieldName) {
    const o = r.objectIdFieldName;
    for (const a of r.features)
      a.attributes && (a.objectId = a.attributes[o]);
  }
  return r && (r.queryGeometry = i, r.queryGeometryType = s), r;
}
function H1(e, t, n) {
  if (!n || !n.features || !n.hasZ)
    return;
  const r = Hj(n.geometryType, t, e.outSpatialReference);
  if (!H(r))
    for (const i of n.features)
      r(i.geometry);
}
const ZR = "Layer does not support extent calculation.";
function xV(e, t) {
  if (t && e.type === "extent")
    return `${e.xmin},${e.ymin},${e.xmax},${e.ymax}`;
  if (t && e.type === "point")
    return `${e.x},${e.y}`;
  const n = e.toJSON();
  return delete n.spatialReference, JSON.stringify(n);
}
function $V(e, t) {
  const n = e.geometry, r = e.toJSON();
  delete r.compactGeometryEnabled, delete r.defaultSpatialReferenceEnabled;
  const i = r, s = e.outSpatialReference;
  let o, a;
  if (O(n) && (o = n.spatialReference, a = n.spatialReference.wkid || JSON.stringify(n.spatialReference), i.geometryType = w0(n), i.geometry = xV(n, e.compactGeometryEnabled), i.inSR = a), r.groupByFieldsForStatistics && (i.groupByFieldsForStatistics = r.groupByFieldsForStatistics.join(",")), r.objectIds && (i.objectIds = r.objectIds.join(",")), r.orderByFields && (i.orderByFields = r.orderByFields.join(",")), !r.outFields || !r.returnDistinctValues && (t != null && t.returnCountOnly || t != null && t.returnExtentOnly || t != null && t.returnIdsOnly) ? delete i.outFields : r.outFields.indexOf("*") !== -1 ? i.outFields = "*" : i.outFields = r.outFields.join(","), r.outSR ? i.outSR = r.outSR.wkid || JSON.stringify(r.outSR) : n && (r.returnGeometry || r.returnCentroid) && (i.outSR = i.inSR), r.returnGeometry && delete r.returnGeometry, r.outStatistics && (i.outStatistics = JSON.stringify(r.outStatistics)), r.pixelSize && (i.pixelSize = JSON.stringify(r.pixelSize)), r.quantizationParameters && (e.defaultSpatialReferenceEnabled && O(o) && O(e.quantizationParameters) && O(e.quantizationParameters.extent) && o.equals(e.quantizationParameters.extent.spatialReference) && delete r.quantizationParameters.extent.spatialReference, i.quantizationParameters = JSON.stringify(r.quantizationParameters)), r.parameterValues && (i.parameterValues = JSON.stringify(r.parameterValues)), r.rangeValues && (i.rangeValues = JSON.stringify(r.rangeValues)), r.dynamicDataSource && (i.layer = JSON.stringify({ source: r.dynamicDataSource }), delete r.dynamicDataSource), r.timeExtent) {
    const l = r.timeExtent, { start: c, end: p } = l;
    c == null && p == null || (i.time = c === p ? c : `${c ?? "null"},${p ?? "null"}`), delete r.timeExtent;
  }
  return e.defaultSpatialReferenceEnabled && O(o) && O(s) && o.equals(s) && (i.defaultSR = i.inSR, delete i.inSR, delete i.outSR), i;
}
async function TV(e, t, n, r) {
  const i = O(t.timeExtent) && t.timeExtent.isEmpty ? { data: { features: [] } } : await Qf(e, t, "json", r);
  return H1(t, n, i.data), i;
}
async function EV(e, t, n, r) {
  if (O(t.timeExtent) && t.timeExtent.isEmpty)
    return Promise.resolve({ data: n.createFeatureResult() });
  const i = await IV(e, t, r), s = i;
  return s.data = Joe(i.data, n), s;
}
function IV(e, t, n) {
  return Qf(e, t, "pbf", n);
}
function MV(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { objectIds: [] } }) : Qf(e, t, "json", n, { returnIdsOnly: !0 });
}
function CV(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : Qf(e, t, "json", n, { returnIdsOnly: !0, returnCountOnly: !0 });
}
function OV(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0, extent: null } }) : Qf(e, t, "json", n, { returnExtentOnly: !0, returnCountOnly: !0 }).then((r) => {
    const i = r.data;
    if (i.hasOwnProperty("extent"))
      return r;
    if (i.features)
      throw new Error(ZR);
    if (i.hasOwnProperty("count"))
      throw new Error(ZR);
    return r;
  });
}
function Qf(e, t, n, r = {}, i = {}) {
  const s = typeof e == "string" ? cr(e) : e, o = t.geometry ? [t.geometry] : [];
  return r.responseType = n === "pbf" ? "array-buffer" : "json", hk(o, null, r).then((a) => {
    const l = a && a[0];
    O(l) && ((t = t.clone()).geometry = l);
    const c = R0({ ...s.query, f: n, ...i, ...$V(t, i) });
    return rn(Xu(s.path, "query"), { ...r, query: { ...c, ...r.query } });
  });
}
const ILe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encodeGeometry: xV,
  executeQuery: TV,
  executeQueryForCount: CV,
  executeQueryForExtent: OV,
  executeQueryForIds: MV,
  executeQueryPBF: EV,
  executeQueryPBFBuffer: IV,
  queryToQueryStringParameters: $V,
  runQuery: Qf
}, Symbol.toStringTag, { value: "Module" }));
async function Zoe(e, t, n) {
  const r = Js(e);
  return CV(r, Jr.from(t), { ...n }).then((i) => i.data.count);
}
async function Koe(e, t, n) {
  const r = Js(e);
  return OV(r, Jr.from(t), { ...n }).then((i) => ({ count: i.data.count, extent: Mt.fromJSON(i.data.extent) }));
}
async function Yoe(e, t, n) {
  const r = Js(e);
  return MV(r, Jr.from(t), { ...n }).then((i) => i.data.objectIds);
}
var oI;
const aI = new st({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh", "": null });
let ar = oI = class extends se {
  constructor(e) {
    super(e), this.displayFieldName = null, this.exceededTransferLimit = !1, this.features = [], this.fields = null, this.geometryType = null, this.hasM = !1, this.hasZ = !1, this.queryGeometry = null, this.spatialReference = null;
  }
  readFeatures(e, t) {
    const n = Qe.fromJSON(t.spatialReference), r = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = Jt.fromJSON(s), a = s.geometry && s.geometry.spatialReference;
      O(o.geometry) && !a && (o.geometry.spatialReference = n);
      const l = s.aggregateGeometries, c = o.aggregateGeometries;
      if (l && O(c))
        for (const p in c) {
          const f = c[p], m = l[p], y = m == null ? void 0 : m.spatialReference;
          O(f) && !y && (f.spatialReference = n);
        }
      r.push(o);
    }
    return r;
  }
  writeGeometryType(e, t, n, r) {
    if (e)
      return void aI.write(e, t, n, r);
    const { features: i } = this;
    if (i) {
      for (const s of i)
        if (s && O(s.geometry))
          return void aI.write(s.geometry.type, t, n, r);
    }
  }
  readQueryGeometry(e, t) {
    if (!e)
      return null;
    const n = !!e.spatialReference, r = tc(e);
    return !n && t.spatialReference && (r.spatialReference = Qe.fromJSON(t.spatialReference)), r;
  }
  writeSpatialReference(e, t) {
    if (e)
      return void (t.spatialReference = e.toJSON());
    const { features: n } = this;
    if (n) {
      for (const r of n)
        if (r && O(r.geometry) && r.geometry.spatialReference)
          return void (t.spatialReference = r.geometry.spatialReference.toJSON());
    }
  }
  clone() {
    return new oI(this.cloneProperties());
  }
  cloneProperties() {
    return q({ displayFieldName: this.displayFieldName, exceededTransferLimit: this.exceededTransferLimit, features: this.features, fields: this.fields, geometryType: this.geometryType, hasM: this.hasM, hasZ: this.hasZ, queryGeometry: this.queryGeometry, spatialReference: this.spatialReference, transform: this.transform });
  }
  toJSON(e) {
    const t = this.write();
    if (t.features && Array.isArray(e) && e.length > 0)
      for (let n = 0; n < t.features.length; n++) {
        const r = t.features[n];
        if (r.geometry) {
          const i = e && e[n];
          r.geometry = i && i.toJSON() || r.geometry;
        }
      }
    return t;
  }
  quantize(e) {
    const { scale: [t, n], translate: [r, i] } = e, s = (c) => Math.round((c - r) / t), o = (c) => Math.round((i - c) / n), a = this.features, l = this._getQuantizationFunction(this.geometryType, s, o);
    for (let c = 0, p = a.length; c < p; c++)
      l(a[c].geometry) || (a.splice(c, 1), c--, p--);
    return this.transform = e, this;
  }
  unquantize() {
    const { geometryType: e, features: t, transform: n } = this;
    if (!n)
      return this;
    const { translate: [r, i], scale: [s, o] } = n, a = (p) => p * s + r, l = (p) => i - p * o, c = this._getHydrationFunction(e, a, l);
    for (const { geometry: p } of t)
      O(p) && c(p);
    return this.transform = null, this;
  }
  _quantizePoints(e, t, n) {
    let r, i;
    const s = [];
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o];
      if (o > 0) {
        const c = t(l[0]), p = n(l[1]);
        c === r && p === i || (s.push([c - r, p - i]), r = c, i = p);
      } else
        r = t(l[0]), i = n(l[1]), s.push([r, i]);
    }
    return s.length > 0 ? s : null;
  }
  _getQuantizationFunction(e, t, n) {
    return e === "point" ? (r) => (r.x = t(r.x), r.y = n(r.y), r) : e === "polyline" || e === "polygon" ? (r) => {
      const i = Bd(r) ? r.rings : r.paths, s = [];
      for (let o = 0, a = i.length; o < a; o++) {
        const l = i[o], c = this._quantizePoints(l, t, n);
        c && s.push(c);
      }
      return s.length > 0 ? (Bd(r) ? r.rings = s : r.paths = s, r) : null;
    } : e === "multipoint" ? (r) => {
      const i = this._quantizePoints(r.points, t, n);
      return i.length > 0 ? (r.points = i, r) : null;
    } : e === "extent" ? (r) => r : null;
  }
  _getHydrationFunction(e, t, n) {
    return e === "point" ? (r) => {
      r.x = t(r.x), r.y = n(r.y);
    } : e === "polyline" || e === "polygon" ? (r) => {
      const i = Bd(r) ? r.rings : r.paths;
      let s, o;
      for (let a = 0, l = i.length; a < l; a++) {
        const c = i[a];
        for (let p = 0, f = c.length; p < f; p++) {
          const m = c[p];
          p > 0 ? (s += m[0], o += m[1]) : (s = m[0], o = m[1]), m[0] = t(s), m[1] = n(o);
        }
      }
    } : e === "extent" ? (r) => {
      r.xmin = t(r.xmin), r.ymin = n(r.ymin), r.xmax = t(r.xmax), r.ymax = n(r.ymax);
    } : e === "multipoint" ? (r) => {
      const i = r.points;
      let s, o;
      for (let a = 0, l = i.length; a < l; a++) {
        const c = i[a];
        a > 0 ? (s += c[0], o += c[1]) : (s = c[0], o = c[1]), c[0] = t(s), c[1] = n(o);
      }
    } : void 0;
  }
};
u([d({ type: String, json: { write: !0 } })], ar.prototype, "displayFieldName", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], ar.prototype, "exceededTransferLimit", void 0), u([d({ type: [Jt], json: { write: !0 } })], ar.prototype, "features", void 0), u([be("features")], ar.prototype, "readFeatures", null), u([d({ type: [_S], json: { write: !0 } })], ar.prototype, "fields", void 0), u([d({ type: ["point", "multipoint", "polyline", "polygon", "extent", "mesh"], json: { read: { reader: aI.read } } })], ar.prototype, "geometryType", void 0), u([xe("geometryType")], ar.prototype, "writeGeometryType", null), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], ar.prototype, "hasM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], ar.prototype, "hasZ", void 0), u([d({ types: Tp, json: { write: !0 } })], ar.prototype, "queryGeometry", void 0), u([be("queryGeometry")], ar.prototype, "readQueryGeometry", null), u([d({ type: Qe, json: { write: !0 } })], ar.prototype, "spatialReference", void 0), u([xe("spatialReference")], ar.prototype, "writeSpatialReference", null), u([d({ json: { write: !0 } })], ar.prototype, "transform", void 0), ar = oI = u([T("geoscene.rest.support.FeatureSet")], ar), ar.prototype.toJSON.isDefaultToJSON = !0;
const kp = ar, MLe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kp
}, Symbol.toStringTag, { value: "Module" }));
async function CLe(e, t, n) {
  const r = await kV(e, t, n);
  return kp.fromJSON(r);
}
async function kV(e, t, n) {
  const r = Js(e), i = { ...n }, s = Jr.from(t), { data: o } = await TV(r, s, s.sourceSpatialReference, i);
  return o;
}
function xr(e, t) {
  return e ? t ? 4 : 3 : t ? 3 : 2;
}
const Xf = we.getLogger("geoscene.layers.graphics.featureConversionUtils"), AV = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0 }, PV = (e, t, n, r, i, s) => {
  e[n] = i, e[n + 1] = s;
}, J1 = (e, t, n, r, i, s) => {
  e[n] = i, e[n + 1] = s, e[n + 2] = t[r + 2];
}, Qoe = (e, t, n, r, i, s) => {
  e[n] = i, e[n + 1] = s, e[n + 2] = t[r + 3];
}, RV = (e, t, n, r, i, s) => {
  e[n] = i, e[n + 1] = s, e[n + 2] = t[r + 2], e[n + 3] = t[r + 3];
};
function fk(e, t, n, r) {
  if (e) {
    if (n)
      return t && r ? RV : J1;
    if (t && r)
      return Qoe;
  } else if (t && r)
    return J1;
  return PV;
}
function X2({ scale: e, translate: t }, n) {
  return Math.round((n - t[0]) / e[0]);
}
function ex({ scale: e, translate: t }, n) {
  return Math.round((t[1] - n) / e[1]);
}
function KR({ scale: e, translate: t }, n) {
  return n * e[0] + t[0];
}
function YR({ scale: e, translate: t }, n) {
  return t[1] - n * e[1];
}
function OLe(e, t, n) {
  return e ? t ? n ? gk(e) : mk(e) : n ? yk(e) : SS(e) : null;
}
function SS(e) {
  const t = e.coords;
  return { x: t[0], y: t[1] };
}
function LV(e, t) {
  return e.coords[0] = t.x, e.coords[1] = t.y, e;
}
function mk(e) {
  const t = e.coords;
  return { x: t[0], y: t[1], z: t[2] };
}
function Xoe(e, t) {
  return e.coords[0] = t.x, e.coords[1] = t.y, e.coords[2] = t.z, e;
}
function yk(e) {
  const t = e.coords;
  return { x: t[0], y: t[1], m: t[2] };
}
function eae(e, t) {
  return e.coords[0] = t.x, e.coords[1] = t.y, e.coords[2] = t.m, e;
}
function gk(e) {
  const t = e.coords;
  return { x: t[0], y: t[1], z: t[2], m: t[3] };
}
function tae(e, t) {
  return e.coords[0] = t.x, e.coords[1] = t.y, e.coords[2] = t.z, e.coords[3] = t.m, e;
}
function nae(e, t, n, r) {
  let i = SS;
  n && r ? i = gk : n ? i = mk : r && (i = yk);
  for (const s of t) {
    const { geometry: o, attributes: a } = s, l = O(o) ? i(o) : null;
    e.push({ attributes: a, geometry: l });
  }
  return e;
}
function FV(e, t) {
  return e && t ? tae : e ? Xoe : t ? eae : LV;
}
function NV(e, t, n, r, i) {
  const s = FV(n, r);
  for (const o of t) {
    const { geometry: a, attributes: l } = o;
    let c;
    a && (c = s(new Lo(), a)), e.push(new sc(c, l, null, l[i]));
  }
  return e;
}
function rae(e, t, n, r) {
  for (const i of t) {
    const { geometry: s, attributes: o } = i;
    let a;
    s && (a = DV(s, n, r)), e.push({ attributes: o, geometry: a });
  }
  return e;
}
function DV(e, t, n) {
  if (H(e))
    return null;
  const r = xr(t, n), i = [];
  for (let s = 0; s < e.coords.length; s += r) {
    const o = [];
    for (let a = 0; a < r; a++)
      o.push(e.coords[s + a]);
    i.push(o);
  }
  return t ? n ? { points: i, hasZ: t, hasM: n } : { points: i, hasZ: t } : n ? { points: i, hasM: n } : { points: i };
}
function jV(e, t, n, r, i) {
  const s = xr(n, r);
  for (const o of t) {
    const a = o.geometry, l = o.attributes;
    let c;
    a && (c = VV(new Lo(), a, s)), e.push(new sc(c, l, null, l[i]));
  }
  return e;
}
function VV(e, t, n = xr(t.hasZ, t.hasM)) {
  e.lengths[0] = t.points.length;
  const r = e.coords;
  let i = 0;
  for (const s of t.points)
    for (let o = 0; o < n; o++)
      r[i++] = s[o];
  return e;
}
function iae(e, t, n, r) {
  for (const i of t) {
    const { geometry: s, attributes: o } = i;
    let a;
    O(s) && (a = zV(s, n, r)), e.push({ attributes: o, geometry: a });
  }
  return e;
}
function zV(e, t, n) {
  if (!e)
    return null;
  const r = xr(t, n), { coords: i, lengths: s } = e, o = [];
  let a = 0;
  for (const l of s) {
    const c = [];
    for (let p = 0; p < l; p++) {
      const f = [];
      for (let m = 0; m < r; m++)
        f.push(i[a++]);
      c.push(f);
    }
    o.push(c);
  }
  return t ? n ? { paths: o, hasZ: t, hasM: n } : { paths: o, hasZ: t } : n ? { paths: o, hasM: n } : { paths: o };
}
function BV(e, t, n, r, i) {
  const s = xr(n, r);
  for (const o of t) {
    const a = o.geometry, l = o.attributes;
    let c;
    a && (c = UV(new Lo(), a, s)), e.push(new sc(c, l, null, l[i]));
  }
  return e;
}
function UV(e, t, n = xr(t.hasZ, t.hasM)) {
  const { lengths: r, coords: i } = e;
  let s = 0;
  for (const o of t.paths) {
    for (const a of o)
      for (let l = 0; l < n; l++)
        i[s++] = a[l];
    r.push(o.length);
  }
  return e;
}
function sae(e, t, n, r) {
  for (const i of t) {
    const { geometry: s, attributes: o, centroid: a } = i;
    let l;
    if (O(s) && (l = qV(s, n, r)), O(a)) {
      const c = SS(a);
      e.push({ attributes: o, centroid: c, geometry: l });
    } else
      e.push({ attributes: o, geometry: l });
  }
  return e;
}
function qV(e, t, n) {
  if (!e)
    return null;
  const r = xr(t, n), { coords: i, lengths: s } = e, o = [];
  let a = 0;
  for (const l of s) {
    const c = [];
    for (let p = 0; p < l; p++) {
      const f = [];
      for (let m = 0; m < r; m++)
        f.push(i[a++]);
      c.push(f);
    }
    o.push(c);
  }
  return t ? n ? { rings: o, hasZ: t, hasM: n } : { rings: o, hasZ: t } : n ? { rings: o, hasM: n } : { rings: o };
}
function GV(e, t, n, r, i) {
  for (const s of t) {
    const o = s.geometry, a = s.centroid, l = s.attributes;
    let c;
    o && (c = WV(new Lo(), o, n, r)), O(a) ? e.push(new sc(c, l, LV(new Lo(), a), l[i])) : e.push(new sc(c, l, null, l[i]));
  }
  return e;
}
function WV(e, t, n = t.hasZ, r = t.hasM) {
  return oae(e, t.rings, n, r), e;
}
function oae(e, t, n, r) {
  const i = xr(n, r), { lengths: s, coords: o } = e;
  let a = 0;
  s.length = o.length = 0;
  for (const l of t) {
    for (const c of l)
      for (let p = 0; p < i; p++)
        o[a++] = c[p];
    s.push(l.length);
  }
  return e;
}
const of = [], sg = [];
function kLe(e, t, n, r, i) {
  of[0] = e;
  const [s] = HV(sg, of, t, n, r, i);
  return of.length = sg.length = 0, s;
}
function HV(e, t, n, r, i, s) {
  if (e.length = 0, !n) {
    for (const o of t) {
      const a = o.attributes[s];
      e.push(new sc(null, o.attributes, null, a));
    }
    return e;
  }
  switch (n) {
    case "esriGeometryPoint":
      return NV(e, t, r, i, s);
    case "esriGeometryMultipoint":
      return jV(e, t, r, i, s);
    case "esriGeometryPolyline":
      return BV(e, t, r, i, s);
    case "esriGeometryPolygon":
      return GV(e, t, r, i, s);
    default:
      Xf.error("convertToFeatureSet:unknown-geometry", new D(`Unable to parse unknown geometry type '${n}'`)), e.length = 0;
  }
  return e;
}
function ALe(e, t, n, r, i, s) {
  const o = e.length;
  switch (n) {
    case "esriGeometryPoint":
      NV(e, t, r, i, s);
      break;
    case "esriGeometryMultipoint":
      jV(e, t, r, i, s);
      break;
    case "esriGeometryPolyline":
      BV(e, t, r, i, s);
      break;
    case "esriGeometryPolygon":
      GV(e, t, r, i, s);
      break;
    default:
      Xf.error("convertToFeatureSet:unknown-geometry", new D(`Unable to parse unknown geometry type '${n}'`));
  }
  for (let a = 0; a < t.length; a++)
    e[a + o].geometryType = n, e[a + o].insertAfter = t[a].insertAfter, e[a + o].groupId = t[a].groupId;
  return e;
}
function PLe(e, t, n, r) {
  sg[0] = e, ZV(of, sg, t, n, r);
  const i = of[0];
  return of.length = sg.length = 0, i;
}
function RLe(e, t, n) {
  if (H(e))
    return null;
  const r = new Lo();
  return "hasZ" in e && t == null && (t = e.hasZ), "hasM" in e && n == null && (n = e.hasM), _O(e) ? FV(t ?? e.z != null, n ?? e.m != null)(r, e) : Bd(e) ? WV(r, e, t, n) : SO(e) ? UV(r, e, xr(t, n)) : wO(e) ? VV(r, e, xr(t, n)) : void Xf.error("convertFromGeometry:unknown-geometry", new D(`Unable to parse unknown geometry type '${e}'`));
}
function JV(e, t, n, r) {
  const i = e && ("coords" in e ? e : e.geometry);
  if (H(i))
    return null;
  switch (t) {
    case "esriGeometryPoint": {
      let s = SS;
      return n && r ? s = gk : n ? s = mk : r && (s = yk), s(i);
    }
    case "esriGeometryMultipoint":
      return DV(i, n, r);
    case "esriGeometryPolyline":
      return zV(i, n, r);
    case "esriGeometryPolygon":
      return qV(i, n, r);
    default:
      return void Xf.error("convertToGeometry:unknown-geometry", new D(`Unable to parse unknown geometry type '${t}'`));
  }
}
function aae(e, t) {
  for (const n of t)
    e.push({ attributes: n.attributes });
  return e;
}
function ZV(e, t, n, r, i) {
  if (e.length = 0, H(n))
    return aae(e, t);
  switch (n) {
    case "esriGeometryPoint":
      return nae(e, t, r, i);
    case "esriGeometryMultipoint":
      return rae(e, t, r, i);
    case "esriGeometryPolyline":
      return iae(e, t, r, i);
    case "esriGeometryPolygon":
      return sae(e, t, r, i);
    default:
      Xf.error("convertToFeatureSet:unknown-geometry", new D(`Unable to parse unknown geometry type '${n}'`));
  }
  return e;
}
function LLe(e) {
  const { objectIdFieldName: t, spatialReference: n, transform: r, fields: i, hasM: s, hasZ: o, features: a, geometryType: l, exceededTransferLimit: c, uniqueIdField: p, queryGeometry: f, queryGeometryType: m } = e, y = { features: ZV([], a, l, o, s), fields: i, geometryType: l, objectIdFieldName: t, spatialReference: n, uniqueIdField: p, queryGeometry: JV(f, m, !1, !1) };
  return r && (y.transform = r), c && (y.exceededTransferLimit = c), s && (y.hasM = s), o && (y.hasZ = o), y;
}
function FLe(e, t) {
  const n = new wV(), { hasM: r, hasZ: i, features: s, objectIdFieldName: o, spatialReference: a, geometryType: l, exceededTransferLimit: c, transform: p, fields: f } = e;
  return f && (n.fields = f), n.geometryType = l, n.objectIdFieldName = o || t, n.spatialReference = a, n.objectIdFieldName ? (s && HV(n.features, s, l, i, r, n.objectIdFieldName), c && (n.exceededTransferLimit = c), r && (n.hasM = r), i && (n.hasZ = i), p && (n.transform = p), n) : (Xf.error(new D("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), n);
}
function NLe(e) {
  const { transform: t, features: n, hasM: r, hasZ: i } = e;
  if (!t)
    return e;
  for (const s of n)
    O(s.geometry) && uI(s.geometry, s.geometry, r, i, t), O(s.centroid) && uI(s.centroid, s.centroid, r, i, t);
  return e.transform = null, e;
}
function DLe(e, t) {
  const { geometryType: n, features: r, hasM: i, hasZ: s } = t;
  if (!e)
    return t;
  for (let o = 0; o < r.length; o++) {
    const a = r[o], l = a.weakClone();
    l.geometry = new Lo(), QR(l.geometry, a.geometry, i, s, n, e), a.centroid && (l.centroid = new Lo(), QR(l.centroid, a.centroid, i, s, "esriGeometryPoint", e)), r[o] = l;
  }
  return t.transform = e, t;
}
function QR(e, t, n, r, i, s, o = n, a = r) {
  if (e.lengths.length && (e.lengths.length = 0), e.coords.length && (e.coords.length = 0), H(t) || !t.coords.length)
    return null;
  const l = AV[i], { coords: c, lengths: p } = t, f = xr(n, r), m = xr(n && o, r && a), y = fk(n, r, o, a);
  if (!p.length)
    return y(e.coords, c, 0, 0, X2(s, c[0]), ex(s, c[1])), e.lengths.length && (e.lengths.length = 0), e.coords.length = f, e;
  let g, v, w, b, S = 0, $ = 0, I = $;
  for (const M of p) {
    if (M < l)
      continue;
    let E = 0;
    $ = I, w = g = X2(s, c[S]), b = v = ex(s, c[S + 1]), y(e.coords, c, $, S, w, b), E++, S += f, $ += m;
    for (let C = 1; C < M; C++, S += f)
      w = X2(s, c[S]), b = ex(s, c[S + 1]), w === g && b === v || (y(e.coords, c, $, S, w - g, b - v), $ += m, E++, g = w, v = b);
    E >= l && (e.lengths.push(E), I = $);
  }
  return e.coords.length = I, e.coords.length ? e : null;
}
function jLe(e, t, n, r, i, s, o = n, a = r) {
  if (e.lengths.length && (e.lengths.length = 0), e.coords.length && (e.coords.length = 0), !t || !t.coords.length)
    return null;
  const l = AV[i], { coords: c, lengths: p } = t, f = xr(n, r), m = xr(n && o, r && a), y = fk(n, r, o, a);
  if (!p.length)
    return y(e.coords, c, 0, 0, c[0], c[1]), e.lengths.length && (e.lengths.length = 0), e.coords.length = f, e;
  let g = 0;
  const v = s * s;
  for (const w of p) {
    if (w < l) {
      g += w * f;
      continue;
    }
    const b = e.coords.length / m, S = g, $ = g + (w - 1) * f;
    y(e.coords, c, e.coords.length, S, c[S], c[S + 1]), lI(e.coords, c, f, v, y, S, $), y(e.coords, c, e.coords.length, $, c[$], c[$ + 1]);
    const I = e.coords.length / m - b;
    I >= l ? e.lengths.push(I) : e.coords.length = b * m, g += w * f;
  }
  return e.coords.length ? e : null;
}
function lae(e, t, n, r) {
  const i = e[t], s = e[t + 1], o = e[n], a = e[n + 1], l = e[r], c = e[r + 1];
  let p = o, f = a, m = l - p, y = c - f;
  if (m !== 0 || y !== 0) {
    const g = ((i - p) * m + (s - f) * y) / (m * m + y * y);
    g > 1 ? (p = l, f = c) : g > 0 && (p += m * g, f += y * g);
  }
  return m = i - p, y = s - f, m * m + y * y;
}
function lI(e, t, n, r, i, s, o) {
  let a, l = r, c = 0;
  for (let p = s + n; p < o; p += n)
    a = lae(t, p, s, o), a > l && (c = p, l = a);
  l > r && (c - s > n && lI(e, t, n, r, i, s, c), i(e, t, e.length, c, t[c], t[c + 1]), o - c > n && lI(e, t, n, r, i, c, o));
}
function VLe(e, t, n, r) {
  if (H(t) || !t.coords || !t.coords.length)
    return null;
  const i = xr(n, r);
  let s = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
  if (t && t.coords) {
    const c = t.coords;
    for (let p = 0; p < c.length; p += i) {
      const f = c[p], m = c[p + 1];
      s = Math.min(s, f), a = Math.max(a, f), o = Math.min(o, m), l = Math.max(l, m);
    }
  }
  return e[0] = s, e[1] = o, e[2] = a, e[3] = l, e;
}
function uI(e, t, n, r, i) {
  const { coords: s, lengths: o } = t, a = n ? r ? RV : J1 : r ? J1 : PV, l = xr(n, r);
  if (!s.length)
    return e !== t && (e.lengths.length = 0, e.coords.length = 0), e;
  if (!o.length)
    return a(e.coords, s, 0, 0, KR(i, s[0]), YR(i, s[1])), e !== t && (e.lengths.length = 0, e.coords.length = l), e;
  const [c, p] = i.scale;
  let f = 0;
  for (let m = 0; m < o.length; m++) {
    const y = o[m];
    e.lengths[m] = y;
    let g = KR(i, s[f]), v = YR(i, s[f + 1]);
    a(e.coords, s, f, f, g, v), f += l;
    for (let w = 1; w < y; w++, f += l)
      g += s[f] * c, v -= s[f + 1] * p, a(e.coords, s, f, f, g, v);
  }
  return e !== t && (e.lengths.length = o.length, e.coords.length = s.length), e;
}
function zLe(e, t, n, r, i, s) {
  const o = xr(n, r), a = fk(n, r, i, s), l = t.coords;
  e.coords.length = 0, e.lengths.length = 0, e.lengths.push(...t.lengths);
  for (let c = 0; c < l.length; c += o)
    a(e.coords, l, e.coords.length, c, l[c], l[c + 1]);
  return e;
}
function uae(e, t, n, r) {
  let i = 0, s = e[r * t], o = e[r * (t + 1)];
  for (let a = 1; a < n; a++) {
    const l = s + e[r * (t + a)], c = o + e[r * (t + a) + 1], p = (l - s) * (c + o);
    s = l, o = c, i += p;
  }
  return 0.5 * i;
}
function BLe(e, t) {
  const { coords: n, lengths: r } = e;
  let i = 0, s = 0;
  for (let o = 0; o < r.length; o++)
    s += uae(n, i, r[o], t), i += o;
  return Math.abs(s);
}
function ULe(e, t) {
  if (H(e))
    return null;
  const n = e.clone(), r = e.coords, i = e.lengths;
  let s = 0;
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    let l = r[t * s], c = r[t * s + 1];
    for (let p = 1; p < a; p++) {
      const f = l + r[t * (s + p)], m = c + r[t * (s + p) + 1];
      n.coords[t * (s + p)] = f, n.coords[t * (s + p) + 1] = m, l = f, c = m;
    }
    s += a;
  }
  return n;
}
function cae(e, t) {
  return t;
}
function vk(e, t, n, r) {
  switch (n) {
    case 0:
      return qg(e, t + r, 0);
    case 1:
      return e.originPosition === "lowerLeft" ? qg(e, t + r, 1) : hae(e, t + r, 1);
  }
}
function KV(e, t, n, r) {
  return n === 2 ? qg(e, t, 2) : vk(e, t, n, r);
}
function dae(e, t, n, r) {
  return n === 2 ? qg(e, t, 3) : vk(e, t, n, r);
}
function pae(e, t, n, r) {
  return n === 3 ? qg(e, t, 3) : KV(e, t, n, r);
}
function qg({ translate: e, scale: t }, n, r) {
  return e[r] + n * t[r];
}
function hae({ translate: e, scale: t }, n, r) {
  return e[r] - n * t[r];
}
let fae = class {
  constructor(t) {
    this.options = t, this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"], this.previousCoordinate = [0, 0], this.transform = null, this.applyTransform = cae, this.lengths = [], this.currentLengthIndex = 0, this.toAddInCurrentPath = 0, this.vertexDimension = 0, this.coordinateBuffer = null, this.coordinateBufferPtr = 0, this._attributesConstructor = function() {
    };
  }
  createFeatureResult() {
    return { fields: [], features: [] };
  }
  finishFeatureResult(t) {
    if (this.options.applyTransform && (t.transform = null), this._attributesConstructor = function() {
    }, this.coordinateBuffer = null, this.lengths.length = 0, !t.hasZ)
      return;
    const n = Hj(t.geometryType, this.options.sourceSpatialReference, t.spatialReference);
    if (!H(n))
      for (const r of t.features)
        n(r.geometry);
  }
  createSpatialReference() {
    return {};
  }
  addField(t, n) {
    t.fields.push(n);
    const r = t.fields.map((i) => i.name);
    this._attributesConstructor = function() {
      for (const i of r)
        this[i] = null;
    };
  }
  addFeature(t, n) {
    t.features.push(n);
  }
  prepareFeatures(t) {
    switch (this.transform = t.transform, this.options.applyTransform && t.transform && (this.applyTransform = this._deriveApplyTransform(t)), this.vertexDimension = 2, t.hasZ && this.vertexDimension++, t.hasM && this.vertexDimension++, t.geometryType) {
      case "esriGeometryPoint":
        this.addCoordinate = (n, r, i) => this.addCoordinatePoint(n, r, i), this.createGeometry = (n) => this.createPointGeometry(n);
        break;
      case "esriGeometryPolygon":
        this.addCoordinate = (n, r, i) => this._addCoordinatePolygon(n, r, i), this.createGeometry = (n) => this._createPolygonGeometry(n);
        break;
      case "esriGeometryPolyline":
        this.addCoordinate = (n, r, i) => this._addCoordinatePolyline(n, r, i), this.createGeometry = (n) => this._createPolylineGeometry(n);
        break;
      case "esriGeometryMultipoint":
        this.addCoordinate = (n, r, i) => this._addCoordinateMultipoint(n, r, i), this.createGeometry = (n) => this._createMultipointGeometry(n);
        break;
      default:
        t.geometryType;
    }
  }
  createFeature() {
    return this.lengths.length = 0, this.currentLengthIndex = 0, this.previousCoordinate[0] = 0, this.previousCoordinate[1] = 0, this.coordinateBuffer = null, this.coordinateBufferPtr = 0, { attributes: new this._attributesConstructor() };
  }
  allocateCoordinates() {
  }
  addLength(t, n, r) {
    this.lengths.length === 0 && (this.toAddInCurrentPath = n), this.lengths.push(n);
  }
  addQueryGeometry(t, n) {
    const { queryGeometry: r, queryGeometryType: i } = n, s = uI(r.clone(), r, !1, !1, this.transform), o = JV(s, i, !1, !1);
    t.queryGeometryType = i, t.queryGeometry = { ...o };
  }
  createPointGeometry(t) {
    const n = { x: 0, y: 0, spatialReference: t.spatialReference };
    return t.hasZ && (n.z = 0), t.hasM && (n.m = 0), n;
  }
  addCoordinatePoint(t, n, r) {
    switch (n = this.applyTransform(this.transform, n, r, 0), r) {
      case 0:
        t.x = n;
        break;
      case 1:
        t.y = n;
        break;
      case 2:
        "z" in t ? t.z = n : t.m = n;
        break;
      case 3:
        t.m = n;
    }
  }
  _transformPathLikeValue(t, n) {
    let r = 0;
    return n <= 1 && (r = this.previousCoordinate[n], this.previousCoordinate[n] += t), this.applyTransform(this.transform, t, n, r);
  }
  _addCoordinatePolyline(t, n, r) {
    this._dehydratedAddPointsCoordinate(t.paths, n, r);
  }
  _addCoordinatePolygon(t, n, r) {
    this._dehydratedAddPointsCoordinate(t.rings, n, r);
  }
  _addCoordinateMultipoint(t, n, r) {
    r === 0 && t.points.push([]);
    const i = this._transformPathLikeValue(n, r);
    t.points[t.points.length - 1].push(i);
  }
  _createPolygonGeometry(t) {
    return { rings: [[]], spatialReference: t.spatialReference, hasZ: !!t.hasZ, hasM: !!t.hasM };
  }
  _createPolylineGeometry(t) {
    return { paths: [[]], spatialReference: t.spatialReference, hasZ: !!t.hasZ, hasM: !!t.hasM };
  }
  _createMultipointGeometry(t) {
    return { points: [], spatialReference: t.spatialReference, hasZ: !!t.hasZ, hasM: !!t.hasM };
  }
  _dehydratedAddPointsCoordinate(t, n, r) {
    r === 0 && this.toAddInCurrentPath-- == 0 && (t.push([]), this.toAddInCurrentPath = this.lengths[++this.currentLengthIndex] - 1, this.previousCoordinate[0] = 0, this.previousCoordinate[1] = 0);
    const i = this._transformPathLikeValue(n, r), s = t[t.length - 1];
    r === 0 && (this.coordinateBufferPtr = 0, this.coordinateBuffer = new Array(this.vertexDimension), s.push(this.coordinateBuffer)), this.coordinateBuffer[this.coordinateBufferPtr++] = i;
  }
  _deriveApplyTransform(t) {
    const { hasZ: n, hasM: r } = t;
    return n && r ? pae : n ? KV : r ? dae : vk;
  }
};
async function mae(e, t, n) {
  const r = Js(e), i = { ...n }, s = Jr.from(t), o = !s.quantizationParameters, { data: a } = await EV(r, s, new fae({ sourceSpatialReference: s.sourceSpatialReference, applyTransform: o }), i);
  return a;
}
function yae(e, t) {
  const n = e.toJSON();
  return n.objectIds && (n.objectIds = n.objectIds.join(",")), n.orderByFields && (n.orderByFields = n.orderByFields.join(",")), !n.outFields || t != null && t.returnCountOnly ? delete n.outFields : n.outFields.indexOf("*") !== -1 ? n.outFields = "*" : n.outFields = n.outFields.join(","), n.outSpatialReference && (n.outSR = n.outSR.wkid || JSON.stringify(n.outSR.toJSON()), delete n.outSpatialReference), n.dynamicDataSource && (n.layer = JSON.stringify({ source: n.dynamicDataSource }), delete n.dynamicDataSource), n;
}
async function gae(e, t, n) {
  const r = await YV(e, t, n), i = r.data, s = i.geometryType, o = i.spatialReference, a = {};
  for (const l of i.relatedRecordGroups) {
    const c = { fields: void 0, objectIdFieldName: void 0, geometryType: s, spatialReference: o, hasZ: !!i.hasZ, hasM: !!i.hasM, features: l.relatedRecords };
    if (l.objectId != null)
      a[l.objectId] = c;
    else
      for (const p in l)
        l.hasOwnProperty(p) && p !== "relatedRecords" && (a[l[p]] = c);
  }
  return { ...r, data: a };
}
async function vae(e, t, n) {
  const r = await YV(e, t, n, { returnCountOnly: !0 }), i = r.data, s = {};
  for (const o of i.relatedRecordGroups)
    o.objectId != null && (s[o.objectId] = o.count);
  return { ...r, data: s };
}
async function YV(e, t, n = {}, r) {
  const i = R0({ ...e.query, f: "json", ...r, ...yae(t, r) });
  return rn(e.path + "/queryRelatedRecords", { ...n, query: { ...n.query, ...i } });
}
async function bae(e, t, n) {
  t = hp.from(t);
  const r = Js(e);
  return gae(r, t, n).then((i) => {
    const s = i.data, o = {};
    return Object.keys(s).forEach((a) => o[a] = kp.fromJSON(s[a])), o;
  });
}
async function wae(e, t, n) {
  t = hp.from(t);
  const r = Js(e);
  return vae(r, t, { ...n }).then((i) => i.data);
}
const XR = "Layer does not support extent calculation.";
function _ae(e, t) {
  var n, r;
  const i = e.geometry, s = e.toJSON(), o = s;
  if (O(i) && (o.geometry = JSON.stringify(i), o.geometryType = w0(i), o.inSR = i.spatialReference.wkid || JSON.stringify(i.spatialReference)), (n = s.topFilter) != null && n.groupByFields && (o.topFilter.groupByFields = s.topFilter.groupByFields.join(",")), (r = s.topFilter) != null && r.orderByFields && (o.topFilter.orderByFields = s.topFilter.orderByFields.join(",")), s.topFilter && (o.topFilter = JSON.stringify(o.topFilter)), s.objectIds && (o.objectIds = s.objectIds.join(",")), s.orderByFields && (o.orderByFields = s.orderByFields.join(",")), s.outFields && !(t != null && t.returnCountOnly || t != null && t.returnExtentOnly || t != null && t.returnIdsOnly) ? s.outFields.indexOf("*") !== -1 ? o.outFields = "*" : o.outFields = s.outFields.join(",") : delete o.outFields, s.outSR ? o.outSR = s.outSR.wkid || JSON.stringify(s.outSR) : i && s.returnGeometry && (o.outSR = o.inSR), s.returnGeometry && delete s.returnGeometry, s.timeExtent) {
    const a = s.timeExtent, { start: l, end: c } = a;
    l == null && c == null || (o.time = l === c ? l : `${l ?? "null"},${c ?? "null"}`), delete s.timeExtent;
  }
  return o;
}
async function Sae(e, t, n, r) {
  const i = await xS(e, t, "json", r);
  return H1(t, n, i.data), i;
}
async function xae(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { objectIds: [] } }) : xS(e, t, "json", n, { returnIdsOnly: !0 });
}
async function $ae(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0, extent: null } }) : xS(e, t, "json", n, { returnExtentOnly: !0, returnCountOnly: !0 }).then((r) => {
    const i = r.data;
    if (i.hasOwnProperty("extent"))
      return r;
    if (i.features)
      throw new Error(XR);
    if (i.hasOwnProperty("count"))
      throw new Error(XR);
    return r;
  });
}
function Tae(e, t, n) {
  return O(t.timeExtent) && t.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : xS(e, t, "json", n, { returnIdsOnly: !0, returnCountOnly: !0 });
}
function xS(e, t, n, r = {}, i = {}) {
  const s = typeof e == "string" ? cr(e) : e, o = t.geometry ? [t.geometry] : [];
  return r.responseType = n === "pbf" ? "array-buffer" : "json", hk(o, null, r).then((a) => {
    const l = a && a[0];
    O(l) && ((t = t.clone()).geometry = l);
    const c = R0({ ...s.query, f: n, ...i, ..._ae(t, i) });
    return rn(Xu(s.path, "queryTopFeatures"), { ...r, query: { ...c, ...r.query } });
  });
}
var cI;
let vh = cI = class extends se {
  constructor(e) {
    super(e), this.groupByFields = void 0, this.topCount = void 0, this.orderByFields = void 0;
  }
  clone() {
    return new cI({ groupByFields: this.groupByFields, topCount: this.topCount, orderByFields: this.orderByFields });
  }
};
u([d({ type: [String], json: { write: !0 } })], vh.prototype, "groupByFields", void 0), u([d({ type: Number, json: { write: !0 } })], vh.prototype, "topCount", void 0), u([d({ type: [String], json: { write: !0 } })], vh.prototype, "orderByFields", void 0), vh = cI = u([T("geoscene.rest.support.TopFilter")], vh);
const Eae = vh;
var dI;
const eL = new st({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), tL = new st({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let Gt = dI = class extends se {
  constructor(e) {
    super(e), this.cacheHint = void 0, this.distance = void 0, this.geometry = null, this.geometryPrecision = void 0, this.maxAllowableOffset = void 0, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.resultType = null, this.returnGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.start = void 0, this.spatialRelationship = "intersects", this.timeExtent = null, this.topFilter = void 0, this.units = null, this.where = "1=1";
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10;
  }
  clone() {
    return new dI(q({ cacheHint: this.cacheHint, distance: this.distance, geometry: this.geometry, geometryPrecision: this.geometryPrecision, maxAllowableOffset: this.maxAllowableOffset, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, resultType: this.resultType, returnGeometry: this.returnGeometry, returnZ: this.returnZ, returnM: this.returnM, start: this.start, spatialRelationship: this.spatialRelationship, timeExtent: this.timeExtent, topFilter: this.topFilter, units: this.units, where: this.where }));
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Gt.prototype, "cacheHint", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e) => ({ enabled: e > 0 }) } } })], Gt.prototype, "distance", void 0), u([d({ types: Tp, json: { read: tc, write: !0 } })], Gt.prototype, "geometry", void 0), u([d({ type: Number, json: { write: !0 } })], Gt.prototype, "geometryPrecision", void 0), u([d({ type: Number, json: { write: !0 } })], Gt.prototype, "maxAllowableOffset", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Gt.prototype, "num", void 0), u([d({ json: { write: !0 } })], Gt.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], Gt.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], Gt.prototype, "outFields", void 0), u([d({ type: Qe, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], Gt.prototype, "outSpatialReference", void 0), u([d({ type: String, json: { write: !0 } })], Gt.prototype, "resultType", void 0), u([d({ json: { write: !0 } })], Gt.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Gt.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Gt.prototype, "returnZ", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Gt.prototype, "start", void 0), u([xe("start"), xe("num")], Gt.prototype, "writeStart", null), u([d({ type: String, json: { read: { source: "spatialRel", reader: eL.read }, write: { target: "spatialRel", writer: eL.write } } })], Gt.prototype, "spatialRelationship", void 0), u([d({ type: La, json: { write: !0 } })], Gt.prototype, "timeExtent", void 0), u([d({ type: Eae, json: { write: !0 } })], Gt.prototype, "topFilter", void 0), u([d({ type: String, json: { read: tL.read, write: { writer: tL.write, overridePolicy(e) {
  return { enabled: e && this.distance > 0 };
} } } })], Gt.prototype, "units", void 0), u([d({ type: String, json: { write: !0 } })], Gt.prototype, "where", void 0), Gt = dI = u([T("geoscene.rest.support.TopFeaturesQuery")], Gt), Gt.from = kn(Gt);
const Wu = Gt;
async function Iae(e, t, n, r) {
  const i = Js(e), s = { ...r }, { data: o } = await Sae(i, Wu.from(t), n, s);
  return kp.fromJSON(o);
}
async function Mae(e, t, n) {
  const r = Js(e);
  return (await xae(r, Wu.from(t), { ...n })).data.objectIds;
}
async function Cae(e, t, n) {
  const r = Js(e), i = await $ae(r, Wu.from(t), { ...n });
  return { count: i.data.count, extent: Mt.fromJSON(i.data.extent) };
}
async function Oae(e, t, n) {
  const r = Js(e);
  return (await Tae(r, Wu.from(t), { ...n })).data.count;
}
let bh = class extends ke {
  constructor(...t) {
    super(...t), this.requestOptions = null, this.url = null;
  }
  normalizeCtorArgs(t, n) {
    return typeof t != "string" ? t : { url: t, ...n };
  }
  get parsedUrl() {
    return this._parseUrl(this.url);
  }
  _parseUrl(t) {
    return t ? cr(t) : null;
  }
  _encode(t, n, r) {
    const i = {};
    for (const s in t) {
      if (s === "declaredClass")
        continue;
      const o = t[s];
      if (o != null && typeof o != "function")
        if (Array.isArray(o)) {
          i[s] = [];
          for (let a = 0; a < o.length; a++)
            i[s][a] = this._encode(o[a]);
        } else if (typeof o == "object")
          if (o.toJSON) {
            const a = o.toJSON(r && r[s]);
            i[s] = n ? a : JSON.stringify(a);
          } else
            i[s] = n ? o : JSON.stringify(o);
        else
          i[s] = o;
    }
    return i;
  }
};
u([d({ readOnly: !0 })], bh.prototype, "parsedUrl", null), u([d()], bh.prototype, "requestOptions", void 0), u([d({ type: String })], bh.prototype, "url", void 0), bh = u([T("geoscene.tasks.Task")], bh);
const kae = bh;
let el = class extends kae {
  constructor(t) {
    super(t), this.dynamicDataSource = null, this.fieldsIndex = null, this.format = "json", this.gdbVersion = null, this.infoFor3D = null, this.sourceSpatialReference = null;
  }
  execute(t, n) {
    return this.executeJSON(t, n).then((r) => this.featureSetFromJSON(t, r, n));
  }
  async executeJSON(t, n) {
    var r;
    const i = { ...this.requestOptions, ...n }, s = this._normalizeQuery(t), o = ((r = t.outStatistics) == null ? void 0 : r[0]) != null, a = K("featurelayer-pbf-statistics"), l = !o || a;
    let c;
    if (this.format === "pbf" && l)
      try {
        c = await mae(this.url, s, i);
      } catch (p) {
        if (p.name !== "query:parsing-pbf")
          throw p;
        this.format = "json";
      }
    return this.format !== "json" && l || (c = await kV(this.url, s, i)), this._normalizeFields(c.fields), c;
  }
  async featureSetFromJSON(t, n, r) {
    if (!(this._queryIs3DObjectFormat(t) && O(this.infoFor3D) && n.features && n.features.length))
      return kp.fromJSON(n);
    const { meshFeatureSetFromJSON: i } = await YD(import("./meshFeatureSet-xd1tbD2h.js").then((s) => s.a), r);
    return i(t, this.infoFor3D, n);
  }
  executeForCount(t, n) {
    const r = { ...this.requestOptions, ...n }, i = this._normalizeQuery(t);
    return Zoe(this.url, i, r);
  }
  executeForExtent(t, n) {
    const r = { ...this.requestOptions, ...n }, i = this._normalizeQuery(t);
    return Koe(this.url, i, r);
  }
  executeForIds(t, n) {
    const r = { ...this.requestOptions, ...n }, i = this._normalizeQuery(t);
    return Yoe(this.url, i, r);
  }
  executeRelationshipQuery(t, n) {
    t = hp.from(t);
    const r = { ...this.requestOptions, ...n };
    return (this.gdbVersion || this.dynamicDataSource) && ((t = t.clone()).gdbVersion = t.gdbVersion || this.gdbVersion, t.dynamicDataSource = t.dynamicDataSource || this.dynamicDataSource), bae(this.url, t, r);
  }
  executeRelationshipQueryForCount(t, n) {
    t = hp.from(t);
    const r = { ...this.requestOptions, ...n };
    return (this.gdbVersion || this.dynamicDataSource) && ((t = t.clone()).gdbVersion = t.gdbVersion || this.gdbVersion, t.dynamicDataSource = t.dynamicDataSource || this.dynamicDataSource), wae(this.url, t, r);
  }
  executeAttachmentQuery(t, n) {
    const r = { ...this.requestOptions, ...n };
    return voe(this.url, t, r);
  }
  executeTopFeaturesQuery(t, n) {
    const r = { ...this.requestOptions, ...n };
    return Iae(this.parsedUrl, t, this.sourceSpatialReference, r);
  }
  executeForTopIds(t, n) {
    const r = { ...this.requestOptions, ...n };
    return Mae(this.parsedUrl, t, r);
  }
  executeForTopExtents(t, n) {
    const r = { ...this.requestOptions, ...n };
    return Cae(this.parsedUrl, t, r);
  }
  executeForTopCount(t, n) {
    const r = { ...this.requestOptions, ...n };
    return Oae(this.parsedUrl, t, r);
  }
  _normalizeQuery(t) {
    let n = Jr.from(t);
    if (n.sourceSpatialReference = n.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (n = n === t ? n.clone() : n, n.gdbVersion = t.gdbVersion || this.gdbVersion, n.dynamicDataSource = t.dynamicDataSource ? Hi.from(t.dynamicDataSource) : this.dynamicDataSource), O(this.infoFor3D) && this._queryIs3DObjectFormat(t)) {
      n = n === t ? n.clone() : n, n.formatOf3DObjects = null;
      for (const r of this.infoFor3D.queryFormats) {
        if (r.id === "3D_glb") {
          n.formatOf3DObjects = r.id;
          break;
        }
        r.id !== "3D_gltf" || n.formatOf3DObjects || (n.formatOf3DObjects = r.id);
      }
      if (!n.formatOf3DObjects)
        throw new D("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (H(n.outFields) || !n.outFields.includes("*")) {
        n = n === t ? n.clone() : n, H(n.outFields) && (n.outFields = []);
        const { originX: r, originY: i, originZ: s, translationX: o, translationY: a, translationZ: l, scaleX: c, scaleY: p, scaleZ: f, rotationX: m, rotationY: y, rotationZ: g, rotationDeg: v } = this.infoFor3D.transformFieldRoles;
        n.outFields.push(r, i, s, o, a, l, c, p, f, m, y, g, v);
      }
    }
    return n;
  }
  _normalizeFields(t) {
    if (O(this.fieldsIndex) && O(t))
      for (const n of t) {
        const r = this.fieldsIndex.get(n.name);
        r && Object.assign(n, r.toJSON());
      }
  }
  _queryIs3DObjectFormat(t) {
    return O(this.infoFor3D) && t.returnGeometry && t.multipatchOption !== "xyFootprint" && !t.outStatistics;
  }
};
u([d({ type: Hi })], el.prototype, "dynamicDataSource", void 0), u([d()], el.prototype, "fieldsIndex", void 0), u([d()], el.prototype, "format", void 0), u([d()], el.prototype, "gdbVersion", void 0), u([d()], el.prototype, "infoFor3D", void 0), u([d()], el.prototype, "sourceSpatialReference", void 0), el = u([T("geoscene.tasks.QueryTask")], el);
const Aae = el, Pae = "geoscene.widgets.Feature.support.relatedFeatureUtils", nL = we.getLogger(Pae), rL = /* @__PURE__ */ new Map();
function Ty(e) {
  if (!_l(e))
    return null;
  const [t, n] = e.split("/").slice(1);
  return { layerId: t, fieldName: n };
}
function Rae(e, t) {
  if (!t.relationships)
    return null;
  let n = null;
  const { relationships: r } = t;
  return r.some((i) => i.id === parseInt(e, 10) && (n = i, !0)), n;
}
function Lae({ originRelationship: e, relationships: t, layerId: n }) {
  let r;
  return t && t.some((i) => (`${i.relatedTableId}` === n && i.id === e.id && (r = i), !!r)), r;
}
function Fae(e, t) {
  const n = t.toLowerCase();
  for (const r in e)
    if (r.toLowerCase() === n)
      return e[r];
  return null;
}
function Nae(e, t) {
  const n = Rae(e, t);
  if (!n)
    return;
  const r = `${t.url}/${n.relatedTableId}`;
  return { url: r, queryTask: new Aae({ url: r, sourceSpatialReference: t.spatialReference }), relation: n, relatedFields: [], outStatistics: [] };
}
function Dae(e, t) {
  if (!t || !e)
    return;
  const { features: n, statsFeatures: r } = e, i = n && n.value;
  t.relatedFeatures = i ? i.features : [];
  const s = r && r.value;
  t.relatedStatsFeatures = s ? s.features : [];
}
function jae(e, t, n, r) {
  const i = new hp();
  return i.outFields = ["*"], i.relationshipId = typeof t.id == "number" ? t.id : parseInt(t.id, 10), i.objectIds = [e.attributes[n.objectIdField]], n.queryRelatedFeatures(i, r);
}
function Vae(e, t, n) {
  let r = 0;
  const i = [];
  for (; r < t.length; )
    i.push(`${e} IN (${t.slice(r, n + r)})`), r += n;
  return i.join(" OR ");
}
async function zae(e, t, n, r) {
  const i = n.layerId.toString(), { layerInfo: s, queryTask: o, relation: a, relatedFields: l, outStatistics: c } = t, p = Lae({ originRelationship: a, relationships: s.relationships, layerId: i });
  if (p.relationshipTableId && p.keyFieldInRelationshipTable) {
    const m = (await jae(e, p, n, r))[e.attributes[n.objectIdField]];
    if (!m)
      return null;
    const y = m.features.map((g) => g.attributes[s.objectIdField]);
    if ((c == null ? void 0 : c.length) > 0 && s.supportsStatistics) {
      const g = new Jr();
      g.where = Vae(s.objectIdField, y, 1e3), g.outFields = l, g.outStatistics = c;
      const v = { features: Promise.resolve(m), statsFeatures: o.execute(g) };
      return Ii(v);
    }
  }
  const f = p == null ? void 0 : p.keyField;
  if (f) {
    const m = EO(Wae(s.fields, f)), y = Fae(e.attributes, a.keyField), g = m ? `${f}=${y}` : `${f}='${y}'`, v = o.execute(new Jr({ where: g, outFields: t.relatedFields }), r), w = t.outStatistics && t.outStatistics.length > 0 && s.supportsStatistics ? o.execute(new Jr({ where: g, outFields: t.relatedFields, outStatistics: t.outStatistics }), r) : null, b = { features: v };
    return w && (b.statsFeatures = w), Ii(b);
  }
  return null;
}
function Bae(e, t) {
  return rn(e, { query: { f: "json" }, signal: t && t.signal });
}
function Uae({ relatedInfos: e, layer: t }, n) {
  const r = {};
  return e.forEach((i, s) => {
    const { relation: o } = i;
    if (!o) {
      const f = new D("relation-required", "A relation is required on a layer to retrieve related records.");
      throw nL.error(f), f;
    }
    const { relatedTableId: a } = o;
    if (typeof a != "number") {
      const f = new D("A related table ID is required on a layer to retrieve related records.");
      throw nL.error(f), f;
    }
    const l = `${t.url}/${a}`, c = rL.get(l), p = c || Bae(l, n);
    c || rL.set(l, p), r[s] = p;
  }), Ii(r);
}
function qae({ graphic: e, relatedInfos: t, layer: n }, r) {
  const i = {};
  return t.forEach((s, o) => {
    s.layerInfo && (i[o] = zae(e, s, n, r));
  }), Ii(i);
}
function Gae({ relatedInfo: e, fieldName: t, fieldInfo: n }) {
  if (e.relatedFields.push(t), n.statisticType) {
    const r = new gV({ statisticType: n.statisticType, onStatisticField: t, outStatisticFieldName: t });
    e.outStatistics.push(r);
  }
}
function Wae(e, t) {
  if (e != null) {
    t = t.toLowerCase();
    for (const n of e)
      if (n && n.name.toLowerCase() === t)
        return n;
  }
  return null;
}
const iL = { chartAnimation: !0 };
let Jn = class extends ke {
  constructor(t) {
    super(t), this.abilities = { ...iL }, this.activeMediaInfoIndex = 0, this.attributes = null, this.description = null, this.fieldInfoMap = null, this.formattedAttributes = null, this.expressionAttributes = null, this.layer = null, this.mediaInfos = null, this.popupTemplate = null, this.relatedInfos = null, this.title = null;
  }
  castAbilities(t) {
    return { ...iL, ...t };
  }
  get activeMediaInfo() {
    return this.formattedMediaInfos[this.activeMediaInfoIndex] || null;
  }
  get formattedMediaInfos() {
    return this._formatMediaInfos() || [];
  }
  get formattedMediaInfoCount() {
    return this.formattedMediaInfos.length;
  }
  setActiveMedia(t) {
    this._setContentElementMedia(t);
  }
  next() {
    this._pageContentElementMedia(1);
  }
  previous() {
    this._pageContentElementMedia(-1);
  }
  _setContentElementMedia(t) {
    const { formattedMediaInfoCount: n } = this, r = (t + n) % n;
    this.activeMediaInfoIndex = r;
  }
  _pageContentElementMedia(t) {
    const { activeMediaInfoIndex: n } = this, r = n + t;
    this._setContentElementMedia(r);
  }
  _formatMediaInfos() {
    const { attributes: t, mediaInfos: n, formattedAttributes: r, expressionAttributes: i, fieldInfoMap: s, layer: o } = this;
    return n == null ? void 0 : n.map((a) => {
      const l = a == null ? void 0 : a.clone();
      if (!l)
        return null;
      if (l.title = Ad({ attributes: t, fieldInfoMap: s, globalAttributes: r, expressionAttributes: i, layer: o, text: l.title }), l.caption = Ad({ attributes: t, fieldInfoMap: s, globalAttributes: r, expressionAttributes: i, layer: o, text: l.caption }), l.altText = Ad({ attributes: t, fieldInfoMap: s, globalAttributes: r, expressionAttributes: i, layer: o, text: l.altText }), l.type === "image") {
        const { value: c } = l;
        return this._setImageValue({ value: c, formattedAttributes: r, layer: o }), l.value.sourceURL ? l : void 0;
      }
      if (l.type === "pie-chart" || l.type === "line-chart" || l.type === "column-chart" || l.type === "bar-chart") {
        const { value: c } = l;
        return this._setChartValue({ value: c, chartType: l.type, attributes: t, formattedAttributes: r, layer: o }), l;
      }
      return null;
    }).filter(Boolean);
  }
  _setImageValue(t) {
    const { fieldInfoMap: n } = this, { value: r, formattedAttributes: i, layer: s } = t, { linkURL: o, sourceURL: a } = r;
    if (a) {
      const l = BE(a, s);
      r.sourceURL = zE({ formattedAttributes: i, template: l, fieldInfoMap: n });
    }
    if (o) {
      const l = BE(o, s);
      r.linkURL = zE({ formattedAttributes: i, template: l, fieldInfoMap: n });
    }
  }
  _setChartValue(t) {
    const { value: n, attributes: r, formattedAttributes: i, chartType: s, layer: o } = t, { popupTemplate: a, relatedInfos: l } = this, { fields: c, normalizeField: p } = n;
    if (n.fields = gse(c, o), p && (n.normalizeField = G1(p, o)), !c.some((m) => !!(i[m] != null || _l(m) && l.size)))
      return;
    const f = a == null ? void 0 : a.fieldInfos;
    c.forEach((m) => {
      if (_l(m))
        return void (n.series = [...n.series, ...this._getRelatedChartInfos({ fieldInfos: f, fieldName: m, formattedAttributes: i, chartType: s, value: n })]);
      const y = this._getChartOption({ value: n, attributes: r, chartType: s, formattedAttributes: i, fieldName: m, fieldInfos: f });
      n.series.push(y);
    });
  }
  _getRelatedChartInfos(t) {
    var n;
    const { fieldInfos: r, fieldName: i, formattedAttributes: s, chartType: o, value: a } = t, l = [], c = Ty(i), { layerId: p, fieldName: f } = c, m = (n = this.relatedInfos) == null ? void 0 : n.get(p.toString());
    if (!m)
      return l;
    const { relatedFeatures: y, relation: g } = m;
    if (!g || !y)
      return l;
    const { cardinality: v } = g;
    return y.forEach((w) => {
      const { attributes: b } = w;
      b && Object.keys(b).forEach((S) => {
        S === f && l.push(this._getChartOption({ value: a, attributes: b, formattedAttributes: s, fieldName: i, chartType: o, relatedFieldName: S, fieldInfos: r }));
      });
    }), v === "one-to-many" || v === "many-to-many" ? l : [l[0]];
  }
  _getTooltip({ label: t, value: n, chartType: r }) {
    return r === "pie-chart" ? t : `${t}: ${n}`;
  }
  _getChartOption(t) {
    var n;
    const { value: r, attributes: i, formattedAttributes: s, fieldName: o, relatedFieldName: a, fieldInfos: l, chartType: c } = t, { layer: p } = this, { normalizeField: f, tooltipField: m } = r, y = f ? _l(f) ? i[Ty(f).fieldName] : i[f] : null, g = a && i[a] !== void 0 ? i[a] : i[o] !== void 0 ? i[o] : s[o], v = g === void 0 ? null : g && y ? g / y : g, w = new G6({ value: v });
    if (_l(o)) {
      const M = Ty(o), E = Ty(m), C = E ? E.fieldName : null, A = sV(v, { fieldInfos: l, fieldName: a, layer: p, preventPlacesFormatting: !!y }), W = M ? M.label || M.fieldName : a, j = C && i[C] !== void 0 ? i[C] : W;
      return w.tooltip = this._getTooltip({ label: j, value: A, chartType: c }), w;
    }
    const b = oV(l, o), S = G1(o, p), $ = m && s[m] !== void 0 ? s[m] : rV(b || new _0({ fieldName: S }), (n = this.popupTemplate) == null ? void 0 : n.expressionInfos), I = s[S];
    return w.tooltip = this._getTooltip({ label: $, value: I, chartType: c }), w;
  }
};
u([d()], Jn.prototype, "abilities", void 0), u([mt("abilities")], Jn.prototype, "castAbilities", null), u([d()], Jn.prototype, "activeMediaInfoIndex", void 0), u([d({ readOnly: !0 })], Jn.prototype, "activeMediaInfo", null), u([d()], Jn.prototype, "attributes", void 0), u([d()], Jn.prototype, "description", void 0), u([d()], Jn.prototype, "fieldInfoMap", void 0), u([d()], Jn.prototype, "formattedAttributes", void 0), u([d()], Jn.prototype, "expressionAttributes", void 0), u([d({ readOnly: !0 })], Jn.prototype, "formattedMediaInfos", null), u([d()], Jn.prototype, "layer", void 0), u([d({ readOnly: !0 })], Jn.prototype, "formattedMediaInfoCount", null), u([d()], Jn.prototype, "mediaInfos", void 0), u([d()], Jn.prototype, "popupTemplate", void 0), u([d()], Jn.prototype, "relatedInfos", void 0), u([d()], Jn.prototype, "title", void 0), Jn = u([T("geoscene.widgets.Feature.FeatureMedia.FeatureMediaViewModel")], Jn);
const Rd = Jn;
var sL = ["#ffffff", "#858585", "#ffbebe", "#ffebbe", "#ffebaf", "#ffffbe", "#e9ffbe", "#d3ffbe", "#beffe8", "#bee8ff", "#bed2ff", "#e8beff", "#ffbee8", "#ebebeb", "#707070", "#ff7f7f", "#ffa77f", "#ffd37f", "#ffff73", "#d1ff73", "#a3ff73", "#73ffdf", "#73dfff", "#73b2ff", "#df73ff", "#ff73df", "#d6d6d6", "#5c5c5c", "#ff0000", "#ff5500", "#ffaa00", "#ffff00", "#aaff00", "#55ff00", "#00ffc5", "#00c5ff", "#0070ff", "#c500ff", "#ff00c5", "#c2c2c2", "#474747", "#e60000", "#e64c00", "#e69800", "#e6e600", "#98e600", "#4ce600", "#00e6a9", "#00a9e6", "#005ce6", "#a900e6", "#e600a9", "#adadad", "#242424", "#a80000", "#a83800", "#a87000", "#a8a800", "#70a800", "#38a800", "#00a884", "#0084a8", "#004da8", "#8400a8", "#a80084", "#999999", "#1a1a1a", "#730000", "#732600", "#734c00", "#737300", "#4c7300", "#267300", "#00734c", "#004c73", "#002673", "#4c0073", "#73004"], Hae = [].concat(sL.slice(30, 39), sL.slice(28, 30).reverse()), Jae = [{ name: "default", colors: Hae }, { name: "cat-dark", colors: ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"] }, { name: "tropical-bliss", colors: ["#fce138", "#ff9399", "#fcd27e", "#f1983c", "#a553b7", "#b1a9d0", "#6ecffc", "#4c81cd", "#fc6f84", "#fc3e5a", "#6af689", "#48885c"] }, { name: "desert-blooms", colors: ["#102432", "#144d59", "#ffc730", "#ed9310", "#a64f1b", "#661510", "#d9351a", "#b31515", "#4a0932", "#8c213f", "#18382e", "#2c6954"] }, { name: "under-the-sea", colors: ["#bf9727", "#607100", "#00734c", "#704489", "#01acca", "#024e76", "#f09100", "#ea311f", "#c6004b", "#7570b3", "#666666", "#333333"] }, { name: "vibrant-rainbow", colors: ["#fffb00", "#f5cb11", "#9fd40c", "#46e39c", "#32b8a6", "#7ff2fa", "#ac08cc", "#dd33ff", "#eb7200", "#e8a784", "#bf2e2e", "#6c7000"] }, { name: "ocean-bay", colors: ["#191921", "#11495c", "#78b1c2", "#454f4b", "#8f8f82", "#9be0c0", "#87b051", "#f7ec88", "#ebdcc1", "#dbb658", "#c43541", "#75351e"] }, { name: "prairie-summer", colors: ["#332424", "#751555", "#d47013", "#d68989", "#211173", "#82aad6", "#7bfaeb", "#6ec9a8", "#6b6408", "#eada40", "#ccc54a", "#1fc235"] }, { name: "pastel-chalk", colors: ["#fffd99", "#f5e6a4", "#c1d48c", "#b8e3d0", "#a0b8b5", "#cbf7fa", "#d791f2", "#dfc1eb", "#f2b983", "#e8c4b2", "#bf8e8e", "#94995c"] }, { name: "seq-yellow-orange-red-bright", colors: ["#910000", "#b1260b", "#c0370f", "#e05919", "#ef6a1d", "#ff7b22", "#ffa143", "#ffb454", "#ffda74", "#ffed85"] }, { name: "seq-reds-bright", colors: ["#57453b", "#7b4238", "#9f4036", "#c23d33", "#d7483c", "#ec5244", "#f3696c", "#f9816c", "#ffc4ae", "#fff0dc"] }, { name: "seq-purples-bright", colors: ["#4e465c", "#5a4a78", "#695291", "#775baa", "#8663c3", "#946bdc", "#aa89e8", "#c1a6f3", "#d7c4ff", "#e6e1ff"] }, { name: "seq-blues-bright", colors: ["#404d54", "#435c6c", "#48799d", "#4b88b6", "#4d96ce", "#50a5e7", "#74bbed", "#98d0f3", "#bce6f9", "#e6faff"] }, { name: "seq-greens-bright", colors: ["#39544c", "#386757", "#368165", "#359b73", "#33b581", "#4bc392", "#64d2a2", "#7ce0b3", "#cbf6d9", "#f4ffea"] }, { name: "seq-browns-bright", colors: ["#524834", "#715b38", "#8f6e3c", "#ae8140", "#cc9444", "#eba748", "#eeb664", "#f0c47f", "#f9e0b7", "#fff8eb"] }];
const oL = "en-us", bk = /* @__PURE__ */ new Map([["ar", () => import("./ar-ejl5TNMi.js").then((e) => e.a)], ["bg-bg", () => import("./bg_BG-sgWyI9bV.js").then((e) => e.b)], ["bs-ba", () => import("./bs_BA-G3DYAwbc.js").then((e) => e.b)], ["ca-es", () => import("./ca_ES-XBT4WxzS.js").then((e) => e.c)], ["cs-cz", () => import("./cs_CZ-Sfigf5FV.js").then((e) => e.c)], ["da-dk", () => import("./da_DK-ZSRK_Cee.js").then((e) => e.d)], ["de-de", () => import("./de_DE-d7IyVDxf.js").then((e) => e.d)], ["de-ch", () => import("./de_CH-wfcBBWtg.js").then((e) => e.d)], ["el-gr", () => import("./el_GR-KO1-JedA.js").then((e) => e.e)], ["en-us", () => import("./en_US-TOC1iOl7.js").then((e) => e.e)], ["en-ca", () => import("./en_CA-TOC1iOl7.js").then((e) => e.e)], ["es-es", () => import("./es_ES-uWMTO-XC.js").then((e) => e.e)], ["et-ee", () => import("./et_EE-CFZC1EvX.js").then((e) => e.e)], ["fi-fi", () => import("./fi_FI-D6ZB-odm.js").then((e) => e.f)], ["fr-fr", () => import("./fr_FR-NH_kjDJL.js").then((e) => e.f)], ["he-il", () => import("./he_IL-6FST46YT.js").then((e) => e.h)], ["hr-hr", () => import("./hr_HR-fPc7KRIl.js").then((e) => e.h)], ["hu-hu", () => import("./hu_HU-6ErJKipH.js").then((e) => e.h)], ["id-id", () => import("./id_ID-8oWU_vdz.js").then((e) => e.i)], ["it-it", () => import("./it_IT-x9GpqWC4.js").then((e) => e.i)], ["ja-jp", () => import("./ja_JP-WKJtbeop.js").then((e) => e.j)], ["ko-kr", () => import("./ko_KR-BLC_rWqN.js").then((e) => e.k)], ["lt-lt", () => import("./lt_LT-TZ9eMcMK.js").then((e) => e.l)], ["lv-lv", () => import("./lv_LV-c2a-Zj4-.js").then((e) => e.l)], ["nb-no", () => import("./nb_NO-pqm1Tl-i.js").then((e) => e.n)], ["nl-nl", () => import("./nl_NL-mBV3faJt.js").then((e) => e.n)], ["pl-pl", () => import("./pl_PL-JrJx2-fS.js").then((e) => e.p)], ["pt-br", () => import("./pt_BR-A_npOS5t.js").then((e) => e.p)], ["pt-pt", () => import("./pt_PT-nt1-TiDr.js").then((e) => e.p)], ["ro-ro", () => import("./ro_RO-eSPY7k88.js").then((e) => e.r)], ["ru-ru", () => import("./ru_RU-1znD_W2h.js").then((e) => e.r)], ["sk-sk", () => import("./sk_SK-vcYV7tq6.js").then((e) => e.s)], ["sl-sl", () => import("./sl_SL-hzD501Gk.js").then((e) => e.s)], ["sr-rs", () => import("./sr_RS-sExyHSoA.js").then((e) => e.s)], ["sv-se", () => import("./sv_SE-CsxZw0NW.js").then((e) => e.s)], ["th-th", () => import("./th_TH-Wrvt60BK.js").then((e) => e.t)], ["tr-tr", () => import("./tr_TR-w38r5j7P.js").then((e) => e.t)], ["uk-ua", () => import("./uk_UA-llR_m6Xm.js").then((e) => e.u)], ["vi-vn", () => import("./vi_VN-n4rJVW_l.js").then((e) => e.v)], ["zh-cn", () => import("./zh_Hans-jj47xwmb.js").then((e) => e.z)], ["zh-hk", () => import("./zh_Hant-iMh-Gah5.js").then((e) => e.z)], ["zh-tw", () => import("./zh_Hant-iMh-Gah5.js").then((e) => e.z)]]);
function Zae(e) {
  const t = e.split("-")[0].toLowerCase();
  let n = null;
  for (const r of bk.keys())
    if (r.startsWith(t)) {
      n = r;
      break;
    }
  return n;
}
function Kae(e) {
  return e ? bk.has(e.toLowerCase()) ? e.toLowerCase() : Zae(e) || oL : oL;
}
let zp, Cm;
async function Yae(e = ts()) {
  if (e = Kae(e), zp && e === Cm)
    return zp;
  zp = import("./index-LjowG6jb.js").then((t) => t.i), Cm = e;
  try {
    const [t, n] = await Promise.all([zp, bk.get(Cm)()]);
    Cm === e && (t.am4core.options.defaultLocale = n.default), t.am4core.options.suppressWarnings = !0, t.am4core.options.autoDispose = !0;
  } catch {
    return zp = null, Cm = null, null;
  }
  return zp;
}
function Qae(e, t = "default") {
  const n = Jae.find((r) => r.name === t);
  return n ? n.colors.map((r) => e.color(r)) : null;
}
const dn = { base: "geoscene-feature-media", mediaContainer: "geoscene-feature-media__container", mediaItemContainer: "geoscene-feature-media__item-container", mediaItem: "geoscene-feature-media__item", mediaItemTitle: "geoscene-feature-media__item-title", mediaItemCaption: "geoscene-feature-media__item-caption", mediaPrevious: "geoscene-feature-media__previous", mediaPreviousIconLTR: "geoscene-feature-media__previous-icon", mediaPreviousIconRTL: "geoscene-feature-media__previous-icon--rtl", mediaNext: "geoscene-feature-media__next", mediaNextIconLTR: "geoscene-feature-media__next-icon", mediaNextIconRTL: "geoscene-feature-media__next-icon--rtl", mediaChart: "geoscene-feature-media__chart", mediaButton: "geoscene-feature-media__button", mediaIcon: "geoscene-feature-media__icon", iconLeftTriangleArrow: "geoscene-icon-left-triangle-arrow", iconRightTriangleArrow: "geoscene-icon-right-triangle-arrow" }, tx = 0.05, nx = 0.95, rx = 15;
let hi = class extends ti {
  constructor(t, n) {
    super(t, n), this._refreshTimer = null, this._refreshIntervalInfo = null, this._featureElementInfo = null, this.attributes = null, this.activeMediaInfoIndex = null, this.description = null, this.fieldInfoMap = null, this.layer = null, this.mediaInfos = null, this.popupTemplate = null, this.relatedInfos = null, this.title = null, this.viewModel = new Rd(), this.messages = null, this._getChartDependencies = async (r) => {
      const i = await Yae(), { destroyed: s, viewModel: o } = this;
      if (s || !o || !r)
        return;
      const { activeMediaInfo: a } = o;
      this._renderChart({ chartDiv: r, mediaInfo: a, chartsModule: i });
    };
  }
  initialize() {
    this._featureElementInfo = new dk(), this.own(gn(this, ["viewModel.activeMediaInfo", "viewModel.activeMediaInfoIndex"], () => this._setupMediaRefreshTimer()), gn(this, ["viewModel.description", "viewModel.title"], () => this._setupFeatureElementInfo()));
  }
  destroy() {
    this._clearMediaRefreshTimer(), this._featureElementInfo.destroy();
  }
  render() {
    var t;
    return B("div", { bind: this, class: dn.base, onkeyup: this._handleMediaKeyup }, (t = this._featureElementInfo) == null ? void 0 : t.render(), this.renderMedia());
  }
  renderMedia() {
    const { formattedMediaInfoCount: t } = this.viewModel;
    return t ? B("div", { key: "media-element-container", class: dn.mediaContainer }, this.renderMediaPageButton("previous"), this.renderMediaInfo(), this.renderMediaPageButton("next")) : null;
  }
  renderImageMediaInfo(t) {
    const { _refreshIntervalInfo: n } = this, { activeMediaInfoIndex: r, formattedMediaInfoCount: i } = this.viewModel, { value: s, refreshInterval: o, altText: a, title: l, type: c } = t, { sourceURL: p, linkURL: f } = s, m = tV(f) ? "_blank" : "_self", y = m === "_blank" ? "noreferrer" : "", g = o ? n : null, v = g ? g.timestamp : 0, w = g ? g.sourceURL : p, b = B("img", { alt: a || l, key: `media-${c}-${r}-${i}-${v}`, src: w });
    return (f ? B("a", { title: l, href: f, rel: y, target: m }, b) : null) || b;
  }
  renderChartMediaInfo(t) {
    const { activeMediaInfoIndex: n, formattedMediaInfoCount: r } = this.viewModel;
    return B("div", { key: `media-${t.type}-${n}-${r}`, bind: this, class: dn.mediaChart, afterCreate: this._getChartDependencies });
  }
  renderMediaInfoType() {
    const { activeMediaInfo: t } = this.viewModel;
    return t ? t.type === "image" ? this.renderImageMediaInfo(t) : t.type.indexOf("chart") !== -1 ? this.renderChartMediaInfo(t) : null : null;
  }
  renderMediaInfo() {
    const { activeMediaInfo: t } = this.viewModel;
    if (!t)
      return null;
    const n = t.title ? B("div", { key: "media-title", class: dn.mediaItemTitle, innerHTML: t.title }) : null, r = t.caption ? B("div", { key: "media-caption", class: dn.mediaItemCaption, innerHTML: t.caption }) : null;
    return B("div", { key: "media-container", class: dn.mediaItemContainer }, B("div", { key: "media-item-container", class: dn.mediaItem }, this.renderMediaInfoType()), n, r);
  }
  renderMediaPageButton(t) {
    if (this.viewModel.formattedMediaInfoCount < 2)
      return null;
    const n = t === "previous", r = n ? this.messages.previous : this.messages.next, i = n ? this.classes(dn.mediaButton, dn.mediaPrevious) : this.classes(dn.mediaButton, dn.mediaNext), s = n ? this.classes(dn.mediaIcon, dn.mediaPreviousIconLTR, dn.iconLeftTriangleArrow) : this.classes(dn.mediaIcon, dn.mediaNextIconLTR, dn.iconRightTriangleArrow), o = n ? this.classes(dn.mediaIcon, dn.mediaPreviousIconRTL, dn.iconRightTriangleArrow) : this.classes(dn.mediaIcon, dn.mediaNextIconRTL, dn.iconLeftTriangleArrow), a = n ? "media-previous" : "media-next", l = n ? this._previous : this._next;
    return B("button", { type: "button", key: a, title: r, "aria-label": r, tabIndex: 0, class: i, bind: this, onclick: l }, B("span", { "aria-hidden": "true", class: s }), B("span", { "aria-hidden": "true", class: o }));
  }
  _setupFeatureElementInfo() {
    const { description: t, title: n } = this;
    this._featureElementInfo.set({ description: t, title: n });
  }
  _next() {
    this.viewModel.next();
  }
  _previous() {
    this.viewModel.previous();
  }
  _handleMediaKeyup(t) {
    const n = yd(t);
    n === "ArrowLeft" && (t.stopPropagation(), this.viewModel.previous()), n === "ArrowRight" && (t.stopPropagation(), this.viewModel.next());
  }
  _renderChart(t) {
    const { abilities: n } = this.viewModel, { chartsModule: r, chartDiv: i, mediaInfo: s } = t, { value: o, type: a } = s, { am4core: l } = r, c = Qae(l);
    function p(y) {
      y instanceof l.ColorSet && c && (y.list = c);
    }
    J9() && l.useTheme(r.am4themes_dark);
    const f = window.matchMedia("(prefers-reduced-motion: reduce)");
    n.chartAnimation && !f.matches ? l.useTheme(r.am4themes_animated) : l.unuseTheme(r.am4themes_animated), l.useTheme(p);
    const m = a === "pie-chart" ? this._createPieChart(t) : this._createXYChart(t);
    i.setAttribute("aria-label", s.altText || s.title), m.data = o.series.map((y) => ({ tooltip: y.tooltip, value: y.value })).filter((y) => a !== "pie-chart" || y.value > 0);
  }
  _customizeChartTooltip(t, n) {
    t.label.wrap = !0, t.label.maxWidth = 200, t.autoTextColor = !1, t.getFillFromObject = !1, t.label.fill = n.color("#ffffff"), t.background.fill = n.color({ r: 0, g: 0, b: 0, a: 0.7 });
  }
  _createPieChart(t) {
    const { chartDiv: n, chartsModule: r } = t, { am4core: i, am4charts: s } = r, o = i.create(n, s.PieChart);
    o.rtl = qu(this.container);
    const a = o.series.push(new s.PieSeries());
    return a.labels.template.disabled = !0, a.ticks.template.disabled = !0, a.dataFields.value = "value", a.dataFields.category = "tooltip", this._customizeChartTooltip(a.tooltip, i), a.slices.template.tooltipText = o.rtl ? "{category}: %{value.percent.formatNumber('#.0')}" : "{category}: {value.percent.formatNumber('#.0')}%", o;
  }
  _getMinSeriesValue(t) {
    let n = 0;
    return t.forEach((r) => n = Math.min(r.value, n)), n;
  }
  _createColumnChart(t, n) {
    const { chartsModule: r, mediaInfo: i } = n, { value: s } = i, { am4core: o, am4charts: a } = r, l = t.xAxes.push(new a.CategoryAxis());
    l.dataFields.category = "tooltip", l.renderer.labels.template.disabled = !0, this._customizeChartTooltip(l.tooltip, o), l.tooltip.events.on("sizechanged", () => {
      l.tooltip.dy = -l.tooltip.contentHeight;
    });
    const c = t.yAxes.push(new a.ValueAxis()), p = c.renderer.labels.template;
    c.renderer.minLabelPosition = tx, c.renderer.maxLabelPosition = nx, c.min = this._getMinSeriesValue(s.series), this._customizeChartTooltip(c.tooltip, o), p.wrap = !0;
    const f = t.series.push(new a.ColumnSeries());
    f.dataFields.valueY = "value", f.dataFields.categoryX = "tooltip", t.cursor = new a.XYCursor(), s.series.length > rx && (t.scrollbarX = new o.Scrollbar());
  }
  _createBarChart(t, n) {
    const { chartsModule: r, mediaInfo: i } = n, { value: s } = i, { am4core: o, am4charts: a } = r, l = t.yAxes.push(new a.CategoryAxis());
    l.dataFields.category = "tooltip", l.renderer.inversed = !0, l.renderer.labels.template.disabled = !0, this._customizeChartTooltip(l.tooltip, o), l.tooltip.events.on("sizechanged", () => {
      l.tooltip.dx = l.tooltip.contentWidth;
    });
    const c = t.xAxes.push(new a.ValueAxis()), p = c.renderer.labels.template;
    c.renderer.minLabelPosition = tx, c.renderer.maxLabelPosition = nx, c.min = this._getMinSeriesValue(s.series), this._customizeChartTooltip(c.tooltip, o), p.wrap = !0;
    const f = t.series.push(new a.ColumnSeries());
    f.dataFields.valueX = "value", f.dataFields.categoryY = "tooltip", t.cursor = new a.XYCursor(), s.series.length > rx && (t.scrollbarY = new o.Scrollbar());
  }
  _createLineChart(t, n) {
    const { chartsModule: r, mediaInfo: i } = n, { value: s } = i, { am4core: o, am4charts: a } = r, l = t.xAxes.push(new a.CategoryAxis());
    l.dataFields.category = "tooltip", l.renderer.labels.template.disabled = !0, this._customizeChartTooltip(l.tooltip, o), l.tooltip.events.on("sizechanged", () => {
      l.tooltip.dy = -l.tooltip.contentHeight;
    });
    const c = t.yAxes.push(new a.ValueAxis()), p = c.renderer.labels.template;
    c.renderer.minLabelPosition = tx, c.renderer.maxLabelPosition = nx, c.min = this._getMinSeriesValue(s.series), this._customizeChartTooltip(c.tooltip, o), p.wrap = !0;
    const f = t.series.push(new a.LineSeries());
    f.dataFields.categoryX = "tooltip", f.dataFields.valueY = "value", t.cursor = new a.XYCursor(), s.series.length > rx && (t.scrollbarX = new o.Scrollbar());
  }
  _createXYChart(t) {
    const { chartDiv: n, chartsModule: r, mediaInfo: i } = t, { type: s } = i, { am4core: o, am4charts: a } = r, l = o.create(n, a.XYChart);
    return l.rtl = qu(this.container), s === "column-chart" && this._createColumnChart(l, t), s === "bar-chart" && this._createBarChart(l, t), s === "line-chart" && this._createLineChart(l, t), l;
  }
  _clearMediaRefreshTimer() {
    const { _refreshTimer: t } = this;
    t && (clearTimeout(t), this._refreshTimer = null);
  }
  _updateMediaInfoTimestamp(t) {
    const n = Date.now();
    this._refreshIntervalInfo = { timestamp: n, sourceURL: this._getImageSource(t, n) }, this.scheduleRender();
  }
  _setupMediaRefreshTimer() {
    this._clearMediaRefreshTimer();
    const { activeMediaInfo: t } = this.viewModel;
    t && t.type === "image" && t.refreshInterval && this._setRefreshTimeout(t);
  }
  _setRefreshTimeout(t) {
    const { refreshInterval: n, value: r } = t;
    if (!n)
      return;
    const i = 6e4 * n;
    this._updateMediaInfoTimestamp(r.sourceURL);
    const s = setInterval(() => {
      this._updateMediaInfoTimestamp(r.sourceURL);
    }, i);
    this._refreshTimer = s;
  }
  _getImageSource(t, n) {
    const r = t.indexOf("?") !== -1 ? "&" : "?", [i, s = ""] = t.split("#");
    return `${i}${r}timestamp=${n}${s ? "#" : ""}${s}`;
  }
};
u([Le("viewModel.attributes")], hi.prototype, "attributes", void 0), u([Le("viewModel.activeMediaInfoIndex")], hi.prototype, "activeMediaInfoIndex", void 0), u([Le("viewModel.description")], hi.prototype, "description", void 0), u([Le("viewModel.fieldInfoMap")], hi.prototype, "fieldInfoMap", void 0), u([Le("viewModel.layer")], hi.prototype, "layer", void 0), u([Le("viewModel.mediaInfos")], hi.prototype, "mediaInfos", void 0), u([Le("viewModel.popupTemplate")], hi.prototype, "popupTemplate", void 0), u([Le("viewModel.relatedInfos")], hi.prototype, "relatedInfos", void 0), u([Le("viewModel.title")], hi.prototype, "title", void 0), u([d({ type: Rd })], hi.prototype, "viewModel", void 0), u([d(), Si("geoscene/widgets/Feature/t9n/Feature")], hi.prototype, "messages", void 0), hi = u([T("geoscene.widgets.Feature.FeatureMedia")], hi);
const QV = hi;
let Xae = class {
  constructor(t, n) {
    this.definition = null, this.context = null, this.definition = t, this.context = n;
  }
}, Fa = class {
  constructor(t = []) {
    this._elements = t;
  }
  length() {
    return this._elements.length;
  }
  get(t) {
    return this._elements[t];
  }
  toArray() {
    const t = [];
    for (let n = 0; n < this.length(); n++)
      t.push(this.get(n));
    return t;
  }
}, L0 = class XV extends Fa {
  constructor(t, n, r, i, s, o) {
    super(t), this._lazyPt = [], this._hasZ = !1, this._hasM = !1, this._spRef = n, this._hasZ = r, this._hasM = i, this._cacheId = s, this._partId = o;
  }
  get(t) {
    if (this._lazyPt[t] === void 0) {
      const n = this._elements[t];
      if (n === void 0)
        return;
      const r = this._hasZ, i = this._hasM;
      let s = null;
      s = r && !i ? new Oe(n[0], n[1], n[2], void 0, this._spRef) : i && !r ? new Oe(n[0], n[1], void 0, n[2], this._spRef) : r && i ? new Oe(n[0], n[1], n[2], n[3], this._spRef) : new Oe(n[0], n[1], this._spRef), s.cache._arcadeCacheId = this._cacheId.toString() + "-" + this._partId.toString() + "-" + t.toString(), this._lazyPt[t] = s;
    }
    return this._lazyPt[t];
  }
  equalityTest(t) {
    return t === this || t !== null && t instanceof XV && t.getUniqueHash() === this.getUniqueHash();
  }
  getUniqueHash() {
    return this._cacheId.toString() + "-" + this._partId.toString();
  }
}, ele = class ez extends Fa {
  constructor(t, n, r, i, s) {
    super(t), this._lazyPath = [], this._hasZ = !1, this._hasM = !1, this._hasZ = r, this._hasM = i, this._spRef = n, this._cacheId = s;
  }
  get(t) {
    if (this._lazyPath[t] === void 0) {
      const n = this._elements[t];
      if (n === void 0)
        return;
      this._lazyPath[t] = new L0(n, this._spRef, this._hasZ, this._hasM, this._cacheId, t);
    }
    return this._lazyPath[t];
  }
  equalityTest(t) {
    return t === this || t !== null && t instanceof ez && t.getUniqueHash() === this.getUniqueHash();
  }
  getUniqueHash() {
    return this._cacheId.toString();
  }
};
class Ap extends Error {
}
class tle extends Ap {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}
class nle extends Ap {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}
class rle extends Ap {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}
class Ey extends Ap {
}
class tz extends Ap {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}
class As extends Ap {
}
class Zl extends Ap {
  constructor() {
    super("Zone is an abstract class");
  }
}
const $e = "numeric", Fo = "short", rs = "long", pI = {
  year: $e,
  month: $e,
  day: $e
}, nz = {
  year: $e,
  month: Fo,
  day: $e
}, ile = {
  year: $e,
  month: Fo,
  day: $e,
  weekday: Fo
}, rz = {
  year: $e,
  month: rs,
  day: $e
}, iz = {
  year: $e,
  month: rs,
  day: $e,
  weekday: rs
}, sz = {
  hour: $e,
  minute: $e
}, oz = {
  hour: $e,
  minute: $e,
  second: $e
}, az = {
  hour: $e,
  minute: $e,
  second: $e,
  timeZoneName: Fo
}, lz = {
  hour: $e,
  minute: $e,
  second: $e,
  timeZoneName: rs
}, uz = {
  hour: $e,
  minute: $e,
  hourCycle: "h23"
}, cz = {
  hour: $e,
  minute: $e,
  second: $e,
  hourCycle: "h23"
}, dz = {
  hour: $e,
  minute: $e,
  second: $e,
  hourCycle: "h23",
  timeZoneName: Fo
}, pz = {
  hour: $e,
  minute: $e,
  second: $e,
  hourCycle: "h23",
  timeZoneName: rs
}, hz = {
  year: $e,
  month: $e,
  day: $e,
  hour: $e,
  minute: $e
}, fz = {
  year: $e,
  month: $e,
  day: $e,
  hour: $e,
  minute: $e,
  second: $e
}, mz = {
  year: $e,
  month: Fo,
  day: $e,
  hour: $e,
  minute: $e
}, yz = {
  year: $e,
  month: Fo,
  day: $e,
  hour: $e,
  minute: $e,
  second: $e
}, sle = {
  year: $e,
  month: Fo,
  day: $e,
  weekday: Fo,
  hour: $e,
  minute: $e
}, gz = {
  year: $e,
  month: rs,
  day: $e,
  hour: $e,
  minute: $e,
  timeZoneName: Fo
}, vz = {
  year: $e,
  month: rs,
  day: $e,
  hour: $e,
  minute: $e,
  second: $e,
  timeZoneName: Fo
}, bz = {
  year: $e,
  month: rs,
  day: $e,
  weekday: rs,
  hour: $e,
  minute: $e,
  timeZoneName: rs
}, wz = {
  year: $e,
  month: rs,
  day: $e,
  weekday: rs,
  hour: $e,
  minute: $e,
  second: $e,
  timeZoneName: rs
};
function gt(e) {
  return typeof e > "u";
}
function Wd(e) {
  return typeof e == "number";
}
function $S(e) {
  return typeof e == "number" && e % 1 === 0;
}
function ole(e) {
  return typeof e == "string";
}
function ale(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function _z() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function lle(e) {
  return Array.isArray(e) ? e : [e];
}
function aL(e, t, n) {
  if (e.length !== 0)
    return e.reduce((r, i) => {
      const s = [t(i), i];
      return r && n(r[0], s[0]) === r[0] ? r : s;
    }, null)[1];
}
function ule(e, t) {
  return t.reduce((n, r) => (n[r] = e[r], n), {});
}
function $f(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Sl(e, t, n) {
  return $S(e) && e >= t && e <= n;
}
function cle(e, t) {
  return e - t * Math.floor(e / t);
}
function jn(e, t = 2) {
  const n = e < 0;
  let r;
  return n ? r = "-" + ("" + -e).padStart(t, "0") : r = ("" + e).padStart(t, "0"), r;
}
function Ru(e) {
  if (!(gt(e) || e === null || e === ""))
    return parseInt(e, 10);
}
function Sc(e) {
  if (!(gt(e) || e === null || e === ""))
    return parseFloat(e);
}
function wk(e) {
  if (!(gt(e) || e === null || e === "")) {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function _k(e, t, n = !1) {
  const r = 10 ** t;
  return (n ? Math.trunc : Math.round)(e * r) / r;
}
function F0(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function og(e) {
  return F0(e) ? 366 : 365;
}
function Z1(e, t) {
  const n = cle(t - 1, 12) + 1, r = e + (t - n) / 12;
  return n === 2 ? F0(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Sk(e) {
  let t = Date.UTC(
    e.year,
    e.month - 1,
    e.day,
    e.hour,
    e.minute,
    e.second,
    e.millisecond
  );
  return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(t.getUTCFullYear() - 1900)), +t;
}
function K1(e) {
  const t = (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7, n = e - 1, r = (n + Math.floor(n / 4) - Math.floor(n / 100) + Math.floor(n / 400)) % 7;
  return t === 4 || r === 3 ? 53 : 52;
}
function hI(e) {
  return e > 99 ? e : e > 60 ? 1900 + e : 2e3 + e;
}
function Sz(e, t, n, r = null) {
  const i = new Date(e), s = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  r && (s.timeZone = r);
  const o = { timeZoneName: t, ...s }, a = new Intl.DateTimeFormat(n, o).formatToParts(i).find((l) => l.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function TS(e, t) {
  let n = parseInt(e, 10);
  Number.isNaN(n) && (n = 0);
  const r = parseInt(t, 10) || 0, i = n < 0 || Object.is(n, -0) ? -r : r;
  return n * 60 + i;
}
function xz(e) {
  const t = Number(e);
  if (typeof e == "boolean" || e === "" || Number.isNaN(t))
    throw new As(`Invalid unit value ${e}`);
  return t;
}
function Y1(e, t) {
  const n = {};
  for (const r in e)
    if ($f(e, r)) {
      const i = e[r];
      if (i == null)
        continue;
      n[t(r)] = xz(i);
    }
  return n;
}
function Q1(e, t) {
  const n = Math.trunc(Math.abs(e / 60)), r = Math.trunc(Math.abs(e % 60)), i = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${i}${jn(n, 2)}:${jn(r, 2)}`;
    case "narrow":
      return `${i}${n}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${i}${jn(n, 2)}${jn(r, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function ES(e) {
  return ule(e, ["hour", "minute", "second", "millisecond"]);
}
const dle = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/, ple = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], $z = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], hle = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Tz(e) {
  switch (e) {
    case "narrow":
      return [...hle];
    case "short":
      return [...$z];
    case "long":
      return [...ple];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const Ez = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], Iz = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], fle = ["M", "T", "W", "T", "F", "S", "S"];
function Mz(e) {
  switch (e) {
    case "narrow":
      return [...fle];
    case "short":
      return [...Iz];
    case "long":
      return [...Ez];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const Cz = ["AM", "PM"], mle = ["Before Christ", "Anno Domini"], yle = ["BC", "AD"], gle = ["B", "A"];
function Oz(e) {
  switch (e) {
    case "narrow":
      return [...gle];
    case "short":
      return [...yle];
    case "long":
      return [...mle];
    default:
      return null;
  }
}
function vle(e) {
  return Cz[e.hour < 12 ? 0 : 1];
}
function ble(e, t) {
  return Mz(t)[e.weekday - 1];
}
function wle(e, t) {
  return Tz(t)[e.month - 1];
}
function _le(e, t) {
  return Oz(t)[e.year < 0 ? 0 : 1];
}
function Sle(e, t, n = "always", r = !1) {
  const i = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, s = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (n === "auto" && s) {
    const f = e === "days";
    switch (t) {
      case 1:
        return f ? "tomorrow" : `next ${i[e][0]}`;
      case -1:
        return f ? "yesterday" : `last ${i[e][0]}`;
      case 0:
        return f ? "today" : `this ${i[e][0]}`;
    }
  }
  const o = Object.is(t, -0) || t < 0, a = Math.abs(t), l = a === 1, c = i[e], p = r ? l ? c[1] : c[2] || c[1] : l ? i[e][0] : e;
  return o ? `${a} ${p} ago` : `in ${a} ${p}`;
}
function lL(e, t) {
  let n = "";
  for (const r of e)
    r.literal ? n += r.val : n += t(r.val);
  return n;
}
const xle = {
  D: pI,
  DD: nz,
  DDD: rz,
  DDDD: iz,
  t: sz,
  tt: oz,
  ttt: az,
  tttt: lz,
  T: uz,
  TT: cz,
  TTT: dz,
  TTTT: pz,
  f: hz,
  ff: mz,
  fff: gz,
  ffff: bz,
  F: fz,
  FF: yz,
  FFF: vz,
  FFFF: wz
};
class _i {
  static create(t, n = {}) {
    return new _i(t, n);
  }
  static parseFormat(t) {
    let n = null, r = "", i = !1;
    const s = [];
    for (let o = 0; o < t.length; o++) {
      const a = t.charAt(o);
      a === "'" ? (r.length > 0 && s.push({ literal: i, val: r }), n = null, r = "", i = !i) : i || a === n ? r += a : (r.length > 0 && s.push({ literal: !1, val: r }), r = a, n = a);
    }
    return r.length > 0 && s.push({ literal: i, val: r }), s;
  }
  static macroTokenToFormatOpts(t) {
    return xle[t];
  }
  constructor(t, n) {
    this.opts = n, this.loc = t, this.systemLoc = null;
  }
  formatWithSystemDefault(t, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, { ...this.opts, ...n }).format();
  }
  formatDateTime(t, n = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...n }).format();
  }
  formatDateTimeParts(t, n = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...n }).formatToParts();
  }
  resolvedOptions(t, n = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...n }).resolvedOptions();
  }
  num(t, n = 0) {
    if (this.opts.forceSimple)
      return jn(t, n);
    const r = { ...this.opts };
    return n > 0 && (r.padTo = n), this.loc.numberFormatter(r).format(t);
  }
  formatDateTimeFromString(t, n) {
    const r = this.loc.listingMode() === "en", i = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (y, g) => this.loc.extract(t, y, g), o = (y) => t.isOffsetFixed && t.offset === 0 && y.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, y.format) : "", a = () => r ? vle(t) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (y, g) => r ? wle(t, y) : s(g ? { month: y } : { month: y, day: "numeric" }, "month"), c = (y, g) => r ? ble(t, y) : s(
      g ? { weekday: y } : { weekday: y, month: "long", day: "numeric" },
      "weekday"
    ), p = (y) => {
      const g = _i.macroTokenToFormatOpts(y);
      return g ? this.formatWithSystemDefault(t, g) : y;
    }, f = (y) => r ? _le(t, y) : s({ era: y }, "era"), m = (y) => {
      switch (y) {
        case "S":
          return this.num(t.millisecond);
        case "u":
        case "SSS":
          return this.num(t.millisecond, 3);
        case "s":
          return this.num(t.second);
        case "ss":
          return this.num(t.second, 2);
        case "uu":
          return this.num(Math.floor(t.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t.millisecond / 100));
        case "m":
          return this.num(t.minute);
        case "mm":
          return this.num(t.minute, 2);
        case "h":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
        case "hh":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
        case "H":
          return this.num(t.hour);
        case "HH":
          return this.num(t.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return t.zoneName;
        case "a":
          return a();
        case "d":
          return i ? s({ day: "numeric" }, "day") : this.num(t.day);
        case "dd":
          return i ? s({ day: "2-digit" }, "day") : this.num(t.day, 2);
        case "c":
          return this.num(t.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        case "E":
          return this.num(t.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        case "L":
          return i ? s({ month: "numeric", day: "numeric" }, "month") : this.num(t.month);
        case "LL":
          return i ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return i ? s({ month: "numeric" }, "month") : this.num(t.month);
        case "MM":
          return i ? s({ month: "2-digit" }, "month") : this.num(t.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year);
        case "yy":
          return i ? s({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2);
        case "yyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year, 4);
        case "yyyyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year, 6);
        case "G":
          return f("short");
        case "GG":
          return f("long");
        case "GGGGG":
          return f("narrow");
        case "kk":
          return this.num(t.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t.weekYear, 4);
        case "W":
          return this.num(t.weekNumber);
        case "WW":
          return this.num(t.weekNumber, 2);
        case "o":
          return this.num(t.ordinal);
        case "ooo":
          return this.num(t.ordinal, 3);
        case "q":
          return this.num(t.quarter);
        case "qq":
          return this.num(t.quarter, 2);
        case "X":
          return this.num(Math.floor(t.ts / 1e3));
        case "x":
          return this.num(t.ts);
        default:
          return p(y);
      }
    };
    return lL(_i.parseFormat(n), m);
  }
  formatDurationFromString(t, n) {
    const r = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, i = (l) => (c) => {
      const p = r(c);
      return p ? this.num(l.get(p), c.length) : c;
    }, s = _i.parseFormat(n), o = s.reduce(
      (l, { literal: c, val: p }) => c ? l : l.concat(p),
      []
    ), a = t.shiftTo(...o.map(r).filter((l) => l));
    return lL(s, i(a));
  }
}
class Io {
  constructor(t, n) {
    this.reason = t, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
class N0 {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new Zl();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new Zl();
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new Zl();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, n) {
    throw new Zl();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, n) {
    throw new Zl();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    throw new Zl();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    throw new Zl();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new Zl();
  }
}
let ix = null;
class xk extends N0 {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return ix === null && (ix = new xk()), ix;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: r }) {
    return Sz(t, n, r);
  }
  /** @override **/
  formatOffset(t, n) {
    return Q1(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    return -new Date(t).getTimezoneOffset();
  }
  /** @override **/
  equals(t) {
    return t.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let rw = {};
function $le(e) {
  return rw[e] || (rw[e] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), rw[e];
}
const Tle = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function Ele(e, t) {
  const n = e.format(t).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, i, s, o, a, l, c, p] = r;
  return [o, i, s, a, l, c, p];
}
function Ile(e, t) {
  const n = e.formatToParts(t), r = [];
  for (let i = 0; i < n.length; i++) {
    const { type: s, value: o } = n[i], a = Tle[s];
    s === "era" ? r[a] = o : gt(a) || (r[a] = parseInt(o, 10));
  }
  return r;
}
let Tv = {};
class Al extends N0 {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    return Tv[t] || (Tv[t] = new Al(t)), Tv[t];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    Tv = {}, rw = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = Al.isValidZone(t);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: n, locale: r }) {
    return Sz(t, n, r, this.name);
  }
  /** @override **/
  formatOffset(t, n) {
    return Q1(this.offset(t), n);
  }
  /** @override **/
  offset(t) {
    const n = new Date(t);
    if (isNaN(n))
      return NaN;
    const r = $le(this.name);
    let [i, s, o, a, l, c, p] = r.formatToParts ? Ile(r, n) : Ele(r, n);
    a === "BC" && (i = -Math.abs(i) + 1);
    const m = Sk({
      year: i,
      month: s,
      day: o,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: p,
      millisecond: 0
    });
    let y = +n;
    const g = y % 1e3;
    return y -= g >= 0 ? g : 1e3 + g, (m - y) / (60 * 1e3);
  }
  /** @override **/
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let sx = null;
class Zr extends N0 {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return sx === null && (sx = new Zr(0)), sx;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(t) {
    return t === 0 ? Zr.utcInstance : new Zr(t);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(t) {
    if (t) {
      const n = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new Zr(TS(n[1], n[2]));
    }
    return null;
  }
  constructor(t) {
    super(), this.fixed = t;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Q1(this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(t, n) {
    return Q1(this.fixed, n);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(t) {
    return t.type === "fixed" && t.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class Mle extends N0 {
  constructor(t) {
    super(), this.zoneName = t;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function ju(e, t) {
  if (gt(e) || e === null)
    return t;
  if (e instanceof N0)
    return e;
  if (ole(e)) {
    const n = e.toLowerCase();
    return n === "local" || n === "system" ? t : n === "utc" || n === "gmt" ? Zr.utcInstance : Zr.parseSpecifier(n) || Al.create(e);
  } else
    return Wd(e) ? Zr.instance(e) : typeof e == "object" && e.offset && typeof e.offset == "number" ? e : new Mle(e);
}
let uL = () => Date.now(), cL = "system", dL = null, pL = null, hL = null, fL;
class Yn {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return uL;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(t) {
    uL = t;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(t) {
    cL = t;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return ju(cL, xk.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return dL;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(t) {
    dL = t;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return pL;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(t) {
    pL = t;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return hL;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(t) {
    hL = t;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return fL;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    fL = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    mn.resetCache(), Al.resetCache();
  }
}
let mL = {};
function Cle(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let r = mL[n];
  return r || (r = new Intl.ListFormat(e, t), mL[n] = r), r;
}
let fI = {};
function mI(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let r = fI[n];
  return r || (r = new Intl.DateTimeFormat(e, t), fI[n] = r), r;
}
let yI = {};
function Ole(e, t = {}) {
  const n = JSON.stringify([e, t]);
  let r = yI[n];
  return r || (r = new Intl.NumberFormat(e, t), yI[n] = r), r;
}
let gI = {};
function kle(e, t = {}) {
  const { base: n, ...r } = t, i = JSON.stringify([e, r]);
  let s = gI[i];
  return s || (s = new Intl.RelativeTimeFormat(e, t), gI[i] = s), s;
}
let Iy = null;
function Ale() {
  return Iy || (Iy = new Intl.DateTimeFormat().resolvedOptions().locale, Iy);
}
function Ple(e) {
  const t = e.indexOf("-u-");
  if (t === -1)
    return [e];
  {
    let n;
    const r = e.substring(0, t);
    try {
      n = mI(e).resolvedOptions();
    } catch {
      n = mI(r).resolvedOptions();
    }
    const { numberingSystem: i, calendar: s } = n;
    return [r, i, s];
  }
}
function Rle(e, t, n) {
  return (n || t) && (e += "-u", n && (e += `-ca-${n}`), t && (e += `-nu-${t}`)), e;
}
function Lle(e) {
  const t = [];
  for (let n = 1; n <= 12; n++) {
    const r = Ke.utc(2016, n, 1);
    t.push(e(r));
  }
  return t;
}
function Fle(e) {
  const t = [];
  for (let n = 1; n <= 7; n++) {
    const r = Ke.utc(2016, 11, 13 + n);
    t.push(e(r));
  }
  return t;
}
function Ev(e, t, n, r, i) {
  const s = e.listingMode(n);
  return s === "error" ? null : s === "en" ? r(t) : i(t);
}
function Nle(e) {
  return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn";
}
class Dle {
  constructor(t, n, r) {
    this.padTo = r.padTo || 0, this.floor = r.floor || !1;
    const { padTo: i, floor: s, ...o } = r;
    if (!n || Object.keys(o).length > 0) {
      const a = { useGrouping: !1, ...r };
      r.padTo > 0 && (a.minimumIntegerDigits = r.padTo), this.inf = Ole(t, a);
    }
  }
  format(t) {
    if (this.inf) {
      const n = this.floor ? Math.floor(t) : t;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(t) : _k(t, 3);
      return jn(n, this.padTo);
    }
  }
}
class jle {
  constructor(t, n, r) {
    this.opts = r;
    let i;
    if (t.zone.isUniversal) {
      const o = -1 * (t.offset / 60), a = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      t.offset !== 0 && Al.create(a).valid ? (i = a, this.dt = t) : (i = "UTC", r.timeZoneName ? this.dt = t : this.dt = t.offset === 0 ? t : Ke.fromMillis(t.ts + t.offset * 60 * 1e3));
    } else
      t.zone.type === "system" ? this.dt = t : (this.dt = t, i = t.zone.name);
    const s = { ...this.opts };
    i && (s.timeZone = i), this.dtf = mI(n, s);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class Vle {
  constructor(t, n, r) {
    this.opts = { style: "long", ...r }, !n && _z() && (this.rtf = kle(t, r));
  }
  format(t, n) {
    return this.rtf ? this.rtf.format(t, n) : Sle(n, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, n) {
    return this.rtf ? this.rtf.formatToParts(t, n) : [];
  }
}
class mn {
  static fromOpts(t) {
    return mn.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN);
  }
  static create(t, n, r, i = !1) {
    const s = t || Yn.defaultLocale, o = s || (i ? "en-US" : Ale()), a = n || Yn.defaultNumberingSystem, l = r || Yn.defaultOutputCalendar;
    return new mn(o, a, l, s);
  }
  static resetCache() {
    Iy = null, fI = {}, yI = {}, gI = {};
  }
  static fromObject({ locale: t, numberingSystem: n, outputCalendar: r } = {}) {
    return mn.create(t, n, r);
  }
  constructor(t, n, r, i) {
    const [s, o, a] = Ple(t);
    this.locale = s, this.numberingSystem = n || o || null, this.outputCalendar = r || a || null, this.intl = Rle(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = Nle(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && n ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : mn.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, n = !1, r = !0) {
    return Ev(this, t, r, Tz, () => {
      const i = n ? { month: t, day: "numeric" } : { month: t }, s = n ? "format" : "standalone";
      return this.monthsCache[s][t] || (this.monthsCache[s][t] = Lle((o) => this.extract(o, i, "month"))), this.monthsCache[s][t];
    });
  }
  weekdays(t, n = !1, r = !0) {
    return Ev(this, t, r, Mz, () => {
      const i = n ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, s = n ? "format" : "standalone";
      return this.weekdaysCache[s][t] || (this.weekdaysCache[s][t] = Fle(
        (o) => this.extract(o, i, "weekday")
      )), this.weekdaysCache[s][t];
    });
  }
  meridiems(t = !0) {
    return Ev(
      this,
      void 0,
      t,
      () => Cz,
      () => {
        if (!this.meridiemCache) {
          const n = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Ke.utc(2016, 11, 13, 9), Ke.utc(2016, 11, 13, 19)].map(
            (r) => this.extract(r, n, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t, n = !0) {
    return Ev(this, t, n, Oz, () => {
      const r = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [Ke.utc(-40, 1, 1), Ke.utc(2017, 1, 1)].map(
        (i) => this.extract(i, r, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, n, r) {
    const i = this.dtFormatter(t, n), s = i.formatToParts(), o = s.find((a) => a.type.toLowerCase() === r);
    return o ? o.value : null;
  }
  numberFormatter(t = {}) {
    return new Dle(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, n = {}) {
    return new jle(t, this.intl, n);
  }
  relFormatter(t = {}) {
    return new Vle(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return Cle(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
}
function em(...e) {
  const t = e.reduce((n, r) => n + r.source, "");
  return RegExp(`^${t}$`);
}
function Pp(...e) {
  return (t) => e.reduce(
    ([n, r, i], s) => {
      const [o, a, l] = s(t, i);
      return [{ ...n, ...o }, r || a, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function tm(e, ...t) {
  if (e == null)
    return [null, null];
  for (const [n, r] of t) {
    const i = n.exec(e);
    if (i)
      return r(i);
  }
  return [null, null];
}
function kz(...e) {
  return (t, n) => {
    const r = {};
    let i;
    for (i = 0; i < e.length; i++)
      r[e[i]] = Ru(t[n + i]);
    return [r, null, n + i];
  };
}
const Az = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, $k = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Pz = RegExp(`${$k.source}${Az.source}?`), Tk = RegExp(`(?:T${Pz.source})?`), zle = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Ble = /(\d{4})-?W(\d\d)(?:-?(\d))?/, Ule = /(\d{4})-?(\d{3})/, qle = kz("weekYear", "weekNumber", "weekDay"), Gle = kz("year", "ordinal"), Wle = /(\d{4})-(\d\d)-(\d\d)/, Rz = RegExp(
  `${$k.source} ?(?:${Az.source}|(${dle.source}))?`
), Hle = RegExp(`(?: ${Rz.source})?`);
function af(e, t, n) {
  const r = e[t];
  return gt(r) ? n : Ru(r);
}
function Lz(e, t) {
  return [{
    year: af(e, t),
    month: af(e, t + 1, 1),
    day: af(e, t + 2, 1)
  }, null, t + 3];
}
function Rp(e, t) {
  return [{
    hours: af(e, t, 0),
    minutes: af(e, t + 1, 0),
    seconds: af(e, t + 2, 0),
    milliseconds: wk(e[t + 3])
  }, null, t + 4];
}
function nm(e, t) {
  const n = !e[t] && !e[t + 1], r = TS(e[t + 1], e[t + 2]), i = n ? null : Zr.instance(r);
  return [{}, i, t + 3];
}
function Fz(e, t) {
  const n = e[t] ? Al.create(e[t]) : null;
  return [{}, n, t + 1];
}
const Jle = RegExp(`^T?${$k.source}$`), Zle = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
function Kle(e) {
  const [t, n, r, i, s, o, a, l, c] = e, p = t[0] === "-", f = l && l[0] === "-", m = (y, g = !1) => y !== void 0 && (g || y && p) ? -y : y;
  return [
    {
      years: m(Sc(n)),
      months: m(Sc(r)),
      weeks: m(Sc(i)),
      days: m(Sc(s)),
      hours: m(Sc(o)),
      minutes: m(Sc(a)),
      seconds: m(Sc(l), l === "-0"),
      milliseconds: m(wk(c), f)
    }
  ];
}
const Yle = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Ek(e, t, n, r, i, s, o) {
  const a = {
    year: t.length === 2 ? hI(Ru(t)) : Ru(t),
    month: $z.indexOf(n) + 1,
    day: Ru(r),
    hour: Ru(i),
    minute: Ru(s)
  };
  return o && (a.second = Ru(o)), e && (a.weekday = e.length > 3 ? Ez.indexOf(e) + 1 : Iz.indexOf(e) + 1), a;
}
const Qle = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function Xle(e) {
  const [
    ,
    t,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    p,
    f
  ] = e, m = Ek(t, i, r, n, s, o, a);
  let y;
  return l ? y = Yle[l] : c ? y = 0 : y = TS(p, f), [m, new Zr(y)];
}
function eue(e) {
  return e.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const tue = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, nue = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, rue = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function yL(e) {
  const [, t, n, r, i, s, o, a] = e;
  return [Ek(t, i, r, n, s, o, a), Zr.utcInstance];
}
function iue(e) {
  const [, t, n, r, i, s, o, a] = e;
  return [Ek(t, a, n, r, i, s, o), Zr.utcInstance];
}
const sue = em(zle, Tk), oue = em(Ble, Tk), aue = em(Ule, Tk), lue = em(Pz), uue = Pp(
  Lz,
  Rp,
  nm
), cue = Pp(
  qle,
  Rp,
  nm
), due = Pp(
  Gle,
  Rp,
  nm
), pue = Pp(Rp, nm);
function hue(e) {
  return tm(
    e,
    [sue, uue],
    [oue, cue],
    [aue, due],
    [lue, pue]
  );
}
function fue(e) {
  return tm(eue(e), [Qle, Xle]);
}
function mue(e) {
  return tm(
    e,
    [tue, yL],
    [nue, yL],
    [rue, iue]
  );
}
function yue(e) {
  return tm(e, [Zle, Kle]);
}
const gue = Pp(Rp);
function vue(e) {
  return tm(e, [Jle, gue]);
}
const bue = em(Wle, Hle), wue = em(Rz), _ue = Pp(
  Lz,
  Rp,
  nm,
  Fz
), Sue = Pp(
  Rp,
  nm,
  Fz
);
function xue(e) {
  return tm(
    e,
    [bue, _ue],
    [wue, Sue]
  );
}
const $ue = "Invalid Duration", Nz = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, Tue = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...Nz
}, ms = 146097 / 400, Bp = 146097 / 4800, Eue = {
  years: {
    quarters: 4,
    months: 12,
    weeks: ms / 7,
    days: ms,
    hours: ms * 24,
    minutes: ms * 24 * 60,
    seconds: ms * 24 * 60 * 60,
    milliseconds: ms * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: ms / 28,
    days: ms / 4,
    hours: ms * 24 / 4,
    minutes: ms * 24 * 60 / 4,
    seconds: ms * 24 * 60 * 60 / 4,
    milliseconds: ms * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: Bp / 7,
    days: Bp,
    hours: Bp * 24,
    minutes: Bp * 24 * 60,
    seconds: Bp * 24 * 60 * 60,
    milliseconds: Bp * 24 * 60 * 60 * 1e3
  },
  ...Nz
}, Kc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], Iue = Kc.slice(0).reverse();
function xc(e, t, n = !1) {
  const r = {
    values: n ? t.values : { ...e.values, ...t.values || {} },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy
  };
  return new St(r);
}
function Mue(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function Dz(e, t, n, r, i) {
  const s = e[i][n], o = t[n] / s, a = Math.sign(o) === Math.sign(r[i]), l = !a && r[i] !== 0 && Math.abs(o) <= 1 ? Mue(o) : Math.trunc(o);
  r[i] += l, t[n] -= l * s;
}
function Cue(e, t) {
  Iue.reduce((n, r) => gt(t[r]) ? n : (n && Dz(e, t, n, t, r), r), null);
}
class St {
  /**
   * @private
   */
  constructor(t) {
    const n = t.conversionAccuracy === "longterm" || !1;
    this.values = t.values, this.loc = t.loc || mn.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = n ? Eue : Tue, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(t, n) {
    return St.fromObject({ milliseconds: t }, n);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(t, n = {}) {
    if (t == null || typeof t != "object")
      throw new As(
        `Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`
      );
    return new St({
      values: Y1(t, St.normalizeUnit),
      loc: mn.fromObject(n),
      conversionAccuracy: n.conversionAccuracy
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(t) {
    if (Wd(t))
      return St.fromMillis(t);
    if (St.isDuration(t))
      return t;
    if (typeof t == "object")
      return St.fromObject(t);
    throw new As(
      `Unknown duration argument ${t} of type ${typeof t}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(t, n) {
    const [r] = yue(t);
    return r ? St.fromObject(r, n) : St.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(t, n) {
    const [r] = vue(t);
    return r ? St.fromObject(r, n) : St.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new As("need to specify a reason the Duration is invalid");
    const r = t instanceof Io ? t : new Io(t, n);
    if (Yn.throwOnInvalid)
      throw new rle(r);
    return new St({ invalid: r });
  }
  /**
   * @private
   */
  static normalizeUnit(t) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[t && t.toLowerCase()];
    if (!n)
      throw new tz(t);
    return n;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(t) {
    return t && t.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(t, n = {}) {
    const r = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? _i.create(this.loc, r).formatDurationFromString(this, t) : $ue;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(t = {}) {
    const n = Kc.map((r) => {
      const i = this.values[r];
      return gt(i) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...t, unit: r.slice(0, -1) }).format(i);
    }).filter((r) => r);
    return this.loc.listFormatter({ type: "conjunction", style: t.listStyle || "narrow", ...t }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let t = "P";
    return this.years !== 0 && (t += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (t += this.weeks + "W"), this.days !== 0 && (t += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"), this.hours !== 0 && (t += this.hours + "H"), this.minutes !== 0 && (t += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (t += _k(this.seconds + this.milliseconds / 1e3, 3) + "S"), t === "P" && (t += "T0S"), t;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(t = {}) {
    if (!this.isValid)
      return null;
    const n = this.toMillis();
    if (n < 0 || n >= 864e5)
      return null;
    t = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...t
    };
    const r = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let i = t.format === "basic" ? "hhmm" : "hh:mm";
    (!t.suppressSeconds || r.seconds !== 0 || r.milliseconds !== 0) && (i += t.format === "basic" ? "ss" : ":ss", (!t.suppressMilliseconds || r.milliseconds !== 0) && (i += ".SSS"));
    let s = r.toFormat(i);
    return t.includePrefix && (s = "T" + s), s;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = St.fromDurationLike(t), r = {};
    for (const i of Kc)
      ($f(n.values, i) || $f(this.values, i)) && (r[i] = n.get(i) + this.get(i));
    return xc(this, { values: r }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = St.fromDurationLike(t);
    return this.plus(n.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(t) {
    if (!this.isValid)
      return this;
    const n = {};
    for (const r of Object.keys(this.values))
      n[r] = xz(t(this.values[r], r));
    return xc(this, { values: n }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(t) {
    return this[St.normalizeUnit(t)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = { ...this.values, ...Y1(t, St.normalizeUnit) };
    return xc(this, { values: n });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: t, numberingSystem: n, conversionAccuracy: r } = {}) {
    const i = this.loc.clone({ locale: t, numberingSystem: n }), s = { loc: i };
    return r && (s.conversionAccuracy = r), xc(this, s);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(t) {
    return this.isValid ? this.shiftTo(t).get(t) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const t = this.toObject();
    return Cue(this.matrix, t), xc(this, { values: t }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...t) {
    if (!this.isValid)
      return this;
    if (t.length === 0)
      return this;
    t = t.map((o) => St.normalizeUnit(o));
    const n = {}, r = {}, i = this.toObject();
    let s;
    for (const o of Kc)
      if (t.indexOf(o) >= 0) {
        s = o;
        let a = 0;
        for (const c in r)
          a += this.matrix[c][o] * r[c], r[c] = 0;
        Wd(i[o]) && (a += i[o]);
        const l = Math.trunc(a);
        n[o] = l, r[o] = (a * 1e3 - l * 1e3) / 1e3;
        for (const c in i)
          Kc.indexOf(c) > Kc.indexOf(o) && Dz(this.matrix, i, c, n, o);
      } else
        Wd(i[o]) && (r[o] = i[o]);
    for (const o in r)
      r[o] !== 0 && (n[s] += o === s ? r[o] : r[o] / this.matrix[s][o]);
    return xc(this, { values: n }, !0).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const t = {};
    for (const n of Object.keys(this.values))
      t[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return xc(this, { values: t }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(t) {
    if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
      return !1;
    function n(r, i) {
      return r === void 0 || r === 0 ? i === void 0 || i === 0 : r === i;
    }
    for (const r of Kc)
      if (!n(this.values[r], t.values[r]))
        return !1;
    return !0;
  }
}
const Om = "Invalid Interval";
function Oue(e, t) {
  return !e || !e.isValid ? Tn.invalid("missing or invalid start") : !t || !t.isValid ? Tn.invalid("missing or invalid end") : t < e ? Tn.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`
  ) : null;
}
class Tn {
  /**
   * @private
   */
  constructor(t) {
    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new As("need to specify a reason the Interval is invalid");
    const r = t instanceof Io ? t : new Io(t, n);
    if (Yn.throwOnInvalid)
      throw new nle(r);
    return new Tn({ invalid: r });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(t, n) {
    const r = Pm(t), i = Pm(n), s = Oue(r, i);
    return s ?? new Tn({
      start: r,
      end: i
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(t, n) {
    const r = St.fromDurationLike(n), i = Pm(t);
    return Tn.fromDateTimes(i, i.plus(r));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(t, n) {
    const r = St.fromDurationLike(n), i = Pm(t);
    return Tn.fromDateTimes(i.minus(r), i);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(t, n) {
    const [r, i] = (t || "").split("/", 2);
    if (r && i) {
      let s, o;
      try {
        s = Ke.fromISO(r, n), o = s.isValid;
      } catch {
        o = !1;
      }
      let a, l;
      try {
        a = Ke.fromISO(i, n), l = a.isValid;
      } catch {
        l = !1;
      }
      if (o && l)
        return Tn.fromDateTimes(s, a);
      if (o) {
        const c = St.fromISO(i, n);
        if (c.isValid)
          return Tn.after(s, c);
      } else if (l) {
        const c = St.fromISO(r, n);
        if (c.isValid)
          return Tn.before(a, c);
      }
    }
    return Tn.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(t) {
    return t && t.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(t = "milliseconds") {
    return this.isValid ? this.toDuration(t).get(t) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(t = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const n = this.start.startOf(t), r = this.end.startOf(t);
    return Math.floor(r.diff(n, t).get(t)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(t) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(t) {
    return this.isValid ? this.s > t : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(t) {
    return this.isValid ? this.e <= t : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(t) {
    return this.isValid ? this.s <= t && this.e > t : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: t, end: n } = {}) {
    return this.isValid ? Tn.fromDateTimes(t || this.s, n || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...t) {
    if (!this.isValid)
      return [];
    const n = t.map(Pm).filter((o) => this.contains(o)).sort(), r = [];
    let { s: i } = this, s = 0;
    for (; i < this.e; ) {
      const o = n[s] || this.e, a = +o > +this.e ? this.e : o;
      r.push(Tn.fromDateTimes(i, a)), i = a, s += 1;
    }
    return r;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(t) {
    const n = St.fromDurationLike(t);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: r } = this, i = 1, s;
    const o = [];
    for (; r < this.e; ) {
      const a = this.start.plus(n.mapUnits((l) => l * i));
      s = +a > +this.e ? this.e : a, o.push(Tn.fromDateTimes(r, s)), r = s, i += 1;
    }
    return o;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(t) {
    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(t) {
    return this.e > t.s && this.s < t.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(t) {
    return this.isValid ? +this.e == +t.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(t) {
    return this.isValid ? +t.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(t) {
    return this.isValid ? this.s <= t.s && this.e >= t.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(t) {
    return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(t) {
    if (!this.isValid)
      return this;
    const n = this.s > t.s ? this.s : t.s, r = this.e < t.e ? this.e : t.e;
    return n >= r ? null : Tn.fromDateTimes(n, r);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(t) {
    if (!this.isValid)
      return this;
    const n = this.s < t.s ? this.s : t.s, r = this.e > t.e ? this.e : t.e;
    return Tn.fromDateTimes(n, r);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(t) {
    const [n, r] = t.sort((i, s) => i.s - s.s).reduce(
      ([i, s], o) => s ? s.overlaps(o) || s.abutsStart(o) ? [i, s.union(o)] : [i.concat([s]), o] : [i, o],
      [[], null]
    );
    return r && n.push(r), n;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(t) {
    let n = null, r = 0;
    const i = [], s = t.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), o = Array.prototype.concat(...s), a = o.sort((l, c) => l.time - c.time);
    for (const l of a)
      r += l.type === "s" ? 1 : -1, r === 1 ? n = l.time : (n && +n != +l.time && i.push(Tn.fromDateTimes(n, l.time)), n = null);
    return Tn.merge(i);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...t) {
    return Tn.xor([this].concat(t)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Om;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(t) {
    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : Om;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Om;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(t) {
    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : Om;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(t, { separator: n = "  " } = {}) {
    return this.isValid ? `${this.s.toFormat(t)}${n}${this.e.toFormat(t)}` : Om;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(t, n) {
    return this.isValid ? this.e.diff(this.s, t, n) : St.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(t) {
    return Tn.fromDateTimes(t(this.s), t(this.e));
  }
}
class Iv {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(t = Yn.defaultZone) {
    const n = Ke.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(t) {
    return Al.isValidZone(t);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(t) {
    return ju(t, Yn.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(t = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || mn.create(n, r, s)).months(t);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(t = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || mn.create(n, r, s)).months(t, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(t = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null } = {}) {
    return (i || mn.create(n, r, null)).weekdays(t);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(t = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null } = {}) {
    return (i || mn.create(n, r, null)).weekdays(t, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale: t = null } = {}) {
    return mn.create(t).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(t = "short", { locale: n = null } = {}) {
    return mn.create(n, null, "gregory").eras(t);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: _z() };
  }
}
function gL(e, t) {
  const n = (i) => i.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = n(t) - n(e);
  return Math.floor(St.fromMillis(r).as("days"));
}
function kue(e, t, n) {
  const r = [
    ["years", (a, l) => l.year - a.year],
    ["quarters", (a, l) => l.quarter - a.quarter],
    ["months", (a, l) => l.month - a.month + (l.year - a.year) * 12],
    [
      "weeks",
      (a, l) => {
        const c = gL(a, l);
        return (c - c % 7) / 7;
      }
    ],
    ["days", gL]
  ], i = {};
  let s, o;
  for (const [a, l] of r)
    if (n.indexOf(a) >= 0) {
      s = a;
      let c = l(e, t);
      o = e.plus({ [a]: c }), o > t ? (e = e.plus({ [a]: c - 1 }), c -= 1) : e = o, i[a] = c;
    }
  return [e, i, o, s];
}
function Aue(e, t, n, r) {
  let [i, s, o, a] = kue(e, t, n);
  const l = t - i, c = n.filter(
    (f) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(f) >= 0
  );
  c.length === 0 && (o < t && (o = i.plus({ [a]: 1 })), o !== i && (s[a] = (s[a] || 0) + l / (o - i)));
  const p = St.fromObject(s, r);
  return c.length > 0 ? St.fromMillis(l, r).shiftTo(...c).plus(p) : p;
}
const Ik = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
}, vL = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, Pue = Ik.hanidec.replace(/[\[|\]]/g, "").split("");
function Rue(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let n = 0; n < e.length; n++) {
      const r = e.charCodeAt(n);
      if (e[n].search(Ik.hanidec) !== -1)
        t += Pue.indexOf(e[n]);
      else
        for (const i in vL) {
          const [s, o] = vL[i];
          r >= s && r <= o && (t += r - s);
        }
    }
    return parseInt(t, 10);
  } else
    return t;
}
function Xs({ numberingSystem: e }, t = "") {
  return new RegExp(`${Ik[e || "latn"]}${t}`);
}
const Lue = "missing Intl.DateTimeFormat.formatToParts support";
function Et(e, t = (n) => n) {
  return { regex: e, deser: ([n]) => t(Rue(n)) };
}
const Fue = "", jz = `( |${Fue})`, Vz = new RegExp(jz, "g");
function Nue(e) {
  return e.replace(/\./g, "\\.?").replace(Vz, jz);
}
function bL(e) {
  return e.replace(/\./g, "").replace(Vz, " ").toLowerCase();
}
function eo(e, t) {
  return e === null ? null : {
    regex: RegExp(e.map(Nue).join("|")),
    deser: ([n]) => e.findIndex((r) => bL(n) === bL(r)) + t
  };
}
function wL(e, t) {
  return { regex: e, deser: ([, n, r]) => TS(n, r), groups: t };
}
function ox(e) {
  return { regex: e, deser: ([t]) => t };
}
function Due(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function jue(e, t) {
  const n = Xs(t), r = Xs(t, "{2}"), i = Xs(t, "{3}"), s = Xs(t, "{4}"), o = Xs(t, "{6}"), a = Xs(t, "{1,2}"), l = Xs(t, "{1,3}"), c = Xs(t, "{1,6}"), p = Xs(t, "{1,9}"), f = Xs(t, "{2,4}"), m = Xs(t, "{4,6}"), y = (w) => ({ regex: RegExp(Due(w.val)), deser: ([b]) => b, literal: !0 }), v = ((w) => {
    if (e.literal)
      return y(w);
    switch (w.val) {
      case "G":
        return eo(t.eras("short", !1), 0);
      case "GG":
        return eo(t.eras("long", !1), 0);
      case "y":
        return Et(c);
      case "yy":
        return Et(f, hI);
      case "yyyy":
        return Et(s);
      case "yyyyy":
        return Et(m);
      case "yyyyyy":
        return Et(o);
      case "M":
        return Et(a);
      case "MM":
        return Et(r);
      case "MMM":
        return eo(t.months("short", !0, !1), 1);
      case "MMMM":
        return eo(t.months("long", !0, !1), 1);
      case "L":
        return Et(a);
      case "LL":
        return Et(r);
      case "LLL":
        return eo(t.months("short", !1, !1), 1);
      case "LLLL":
        return eo(t.months("long", !1, !1), 1);
      case "d":
        return Et(a);
      case "dd":
        return Et(r);
      case "o":
        return Et(l);
      case "ooo":
        return Et(i);
      case "HH":
        return Et(r);
      case "H":
        return Et(a);
      case "hh":
        return Et(r);
      case "h":
        return Et(a);
      case "mm":
        return Et(r);
      case "m":
        return Et(a);
      case "q":
        return Et(a);
      case "qq":
        return Et(r);
      case "s":
        return Et(a);
      case "ss":
        return Et(r);
      case "S":
        return Et(l);
      case "SSS":
        return Et(i);
      case "u":
        return ox(p);
      case "uu":
        return ox(a);
      case "uuu":
        return Et(n);
      case "a":
        return eo(t.meridiems(), 0);
      case "kkkk":
        return Et(s);
      case "kk":
        return Et(f, hI);
      case "W":
        return Et(a);
      case "WW":
        return Et(r);
      case "E":
      case "c":
        return Et(n);
      case "EEE":
        return eo(t.weekdays("short", !1, !1), 1);
      case "EEEE":
        return eo(t.weekdays("long", !1, !1), 1);
      case "ccc":
        return eo(t.weekdays("short", !0, !1), 1);
      case "cccc":
        return eo(t.weekdays("long", !0, !1), 1);
      case "Z":
      case "ZZ":
        return wL(new RegExp(`([+-]${a.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return wL(new RegExp(`([+-]${a.source})(${r.source})?`), 2);
      case "z":
        return ox(/[a-z_+-/]{1,256}?/i);
      default:
        return y(w);
    }
  })(e) || {
    invalidReason: Lue
  };
  return v.token = e, v;
}
const Vue = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};
function zue(e, t, n) {
  const { type: r, value: i } = e;
  if (r === "literal")
    return {
      literal: !0,
      val: i
    };
  const s = n[r];
  let o = Vue[r];
  if (typeof o == "object" && (o = o[s]), o)
    return {
      literal: !1,
      val: o
    };
}
function Bue(e) {
  return [`^${e.map((n) => n.regex).reduce((n, r) => `${n}(${r.source})`, "")}$`, e];
}
function Uue(e, t, n) {
  const r = e.match(t);
  if (r) {
    const i = {};
    let s = 1;
    for (const o in n)
      if ($f(n, o)) {
        const a = n[o], l = a.groups ? a.groups + 1 : 1;
        !a.literal && a.token && (i[a.token.val[0]] = a.deser(r.slice(s, s + l))), s += l;
      }
    return [r, i];
  } else
    return [r, {}];
}
function que(e) {
  const t = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, r;
  return gt(e.z) || (n = Al.create(e.z)), gt(e.Z) || (n || (n = new Zr(e.Z)), r = e.Z), gt(e.q) || (e.M = (e.q - 1) * 3 + 1), gt(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), gt(e.u) || (e.S = wk(e.u)), [Object.keys(e).reduce((s, o) => {
    const a = t(o);
    return a && (s[a] = e[o]), s;
  }, {}), n, r];
}
let ax = null;
function Gue() {
  return ax || (ax = Ke.fromMillis(1555555555555)), ax;
}
function Wue(e, t) {
  if (e.literal)
    return e;
  const n = _i.macroTokenToFormatOpts(e.val);
  if (!n)
    return e;
  const s = _i.create(t, n).formatDateTimeParts(Gue()).map((o) => zue(o, t, n));
  return s.includes(void 0) ? e : s;
}
function Hue(e, t) {
  return Array.prototype.concat(...e.map((n) => Wue(n, t)));
}
function zz(e, t, n) {
  const r = Hue(_i.parseFormat(n), e), i = r.map((o) => jue(o, e)), s = i.find((o) => o.invalidReason);
  if (s)
    return { input: t, tokens: r, invalidReason: s.invalidReason };
  {
    const [o, a] = Bue(i), l = RegExp(o, "i"), [c, p] = Uue(t, l, a), [f, m, y] = p ? que(p) : [null, null, void 0];
    if ($f(p, "a") && $f(p, "H"))
      throw new Ey(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: t, tokens: r, regex: l, rawMatches: c, matches: p, result: f, zone: m, specificOffset: y };
  }
}
function Jue(e, t, n) {
  const { result: r, zone: i, specificOffset: s, invalidReason: o } = zz(e, t, n);
  return [r, i, s, o];
}
const Bz = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Uz = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function Ps(e, t) {
  return new Io(
    "unit out of range",
    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`
  );
}
function qz(e, t, n) {
  const r = new Date(Date.UTC(e, t - 1, n));
  e < 100 && e >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  const i = r.getUTCDay();
  return i === 0 ? 7 : i;
}
function Gz(e, t, n) {
  return n + (F0(e) ? Uz : Bz)[t - 1];
}
function Wz(e, t) {
  const n = F0(e) ? Uz : Bz, r = n.findIndex((s) => s < t), i = t - n[r];
  return { month: r + 1, day: i };
}
function vI(e) {
  const { year: t, month: n, day: r } = e, i = Gz(t, n, r), s = qz(t, n, r);
  let o = Math.floor((i - s + 10) / 7), a;
  return o < 1 ? (a = t - 1, o = K1(a)) : o > K1(t) ? (a = t + 1, o = 1) : a = t, { weekYear: a, weekNumber: o, weekday: s, ...ES(e) };
}
function _L(e) {
  const { weekYear: t, weekNumber: n, weekday: r } = e, i = qz(t, 1, 4), s = og(t);
  let o = n * 7 + r - i - 3, a;
  o < 1 ? (a = t - 1, o += og(a)) : o > s ? (a = t + 1, o -= og(t)) : a = t;
  const { month: l, day: c } = Wz(a, o);
  return { year: a, month: l, day: c, ...ES(e) };
}
function lx(e) {
  const { year: t, month: n, day: r } = e, i = Gz(t, n, r);
  return { year: t, ordinal: i, ...ES(e) };
}
function SL(e) {
  const { year: t, ordinal: n } = e, { month: r, day: i } = Wz(t, n);
  return { year: t, month: r, day: i, ...ES(e) };
}
function Zue(e) {
  const t = $S(e.weekYear), n = Sl(e.weekNumber, 1, K1(e.weekYear)), r = Sl(e.weekday, 1, 7);
  return t ? n ? r ? !1 : Ps("weekday", e.weekday) : Ps("week", e.week) : Ps("weekYear", e.weekYear);
}
function Kue(e) {
  const t = $S(e.year), n = Sl(e.ordinal, 1, og(e.year));
  return t ? n ? !1 : Ps("ordinal", e.ordinal) : Ps("year", e.year);
}
function Hz(e) {
  const t = $S(e.year), n = Sl(e.month, 1, 12), r = Sl(e.day, 1, Z1(e.year, e.month));
  return t ? n ? r ? !1 : Ps("day", e.day) : Ps("month", e.month) : Ps("year", e.year);
}
function Jz(e) {
  const { hour: t, minute: n, second: r, millisecond: i } = e, s = Sl(t, 0, 23) || t === 24 && n === 0 && r === 0 && i === 0, o = Sl(n, 0, 59), a = Sl(r, 0, 59), l = Sl(i, 0, 999);
  return s ? o ? a ? l ? !1 : Ps("millisecond", i) : Ps("second", r) : Ps("minute", n) : Ps("hour", t);
}
const ux = "Invalid DateTime", xL = 864e13;
function Mv(e) {
  return new Io("unsupported zone", `the zone "${e.name}" is not supported`);
}
function cx(e) {
  return e.weekData === null && (e.weekData = vI(e.c)), e.weekData;
}
function km(e, t) {
  const n = {
    ts: e.ts,
    zone: e.zone,
    c: e.c,
    o: e.o,
    loc: e.loc,
    invalid: e.invalid
  };
  return new Ke({ ...n, ...t, old: n });
}
function Zz(e, t, n) {
  let r = e - t * 60 * 1e3;
  const i = n.offset(r);
  if (t === i)
    return [r, t];
  r -= (i - t) * 60 * 1e3;
  const s = n.offset(r);
  return i === s ? [r, i] : [e - Math.min(i, s) * 60 * 1e3, Math.max(i, s)];
}
function $L(e, t) {
  e += t * 60 * 1e3;
  const n = new Date(e);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function iw(e, t, n) {
  return Zz(Sk(e), t, n);
}
function TL(e, t) {
  const n = e.o, r = e.c.year + Math.trunc(t.years), i = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3, s = {
    ...e.c,
    year: r,
    month: i,
    day: Math.min(e.c.day, Z1(r, i)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
  }, o = St.fromObject({
    years: t.years - Math.trunc(t.years),
    quarters: t.quarters - Math.trunc(t.quarters),
    months: t.months - Math.trunc(t.months),
    weeks: t.weeks - Math.trunc(t.weeks),
    days: t.days - Math.trunc(t.days),
    hours: t.hours,
    minutes: t.minutes,
    seconds: t.seconds,
    milliseconds: t.milliseconds
  }).as("milliseconds"), a = Sk(s);
  let [l, c] = Zz(a, n, e.zone);
  return o !== 0 && (l += o, c = e.zone.offset(l)), { ts: l, o: c };
}
function Am(e, t, n, r, i, s) {
  const { setZone: o, zone: a } = n;
  if (e && Object.keys(e).length !== 0) {
    const l = t || a, c = Ke.fromObject(e, {
      ...n,
      zone: l,
      specificOffset: s
    });
    return o ? c : c.setZone(a);
  } else
    return Ke.invalid(
      new Io("unparsable", `the input "${i}" can't be parsed as ${r}`)
    );
}
function Cv(e, t, n = !0) {
  return e.isValid ? _i.create(mn.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(e, t) : null;
}
function dx(e, t) {
  const n = e.c.year > 9999 || e.c.year < 0;
  let r = "";
  return n && e.c.year >= 0 && (r += "+"), r += jn(e.c.year, n ? 6 : 4), t ? (r += "-", r += jn(e.c.month), r += "-", r += jn(e.c.day)) : (r += jn(e.c.month), r += jn(e.c.day)), r;
}
function EL(e, t, n, r, i) {
  let s = jn(e.c.hour);
  return t ? (s += ":", s += jn(e.c.minute), (e.c.second !== 0 || !n) && (s += ":")) : s += jn(e.c.minute), (e.c.second !== 0 || !n) && (s += jn(e.c.second), (e.c.millisecond !== 0 || !r) && (s += ".", s += jn(e.c.millisecond, 3))), i && (e.isOffsetFixed && e.offset === 0 ? s += "Z" : e.o < 0 ? (s += "-", s += jn(Math.trunc(-e.o / 60)), s += ":", s += jn(Math.trunc(-e.o % 60))) : (s += "+", s += jn(Math.trunc(e.o / 60)), s += ":", s += jn(Math.trunc(e.o % 60)))), s;
}
const Kz = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Yue = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Que = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Yz = ["year", "month", "day", "hour", "minute", "second", "millisecond"], Xue = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], ece = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function IL(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[e.toLowerCase()];
  if (!t)
    throw new tz(e);
  return t;
}
function ML(e, t) {
  const n = ju(t.zone, Yn.defaultZone), r = mn.fromObject(t), i = Yn.now();
  let s, o;
  if (gt(e.year))
    s = i;
  else {
    for (const c of Yz)
      gt(e[c]) && (e[c] = Kz[c]);
    const a = Hz(e) || Jz(e);
    if (a)
      return Ke.invalid(a);
    const l = n.offset(i);
    [s, o] = iw(e, l, n);
  }
  return new Ke({ ts: s, zone: n, loc: r, o });
}
function CL(e, t, n) {
  const r = gt(n.round) ? !0 : n.round, i = (o, a) => (o = _k(o, r || n.calendary ? 0 : 2, !0), t.loc.clone(n).relFormatter(n).format(o, a)), s = (o) => n.calendary ? t.hasSame(e, o) ? 0 : t.startOf(o).diff(e.startOf(o), o).get(o) : t.diff(e, o).get(o);
  if (n.unit)
    return i(s(n.unit), n.unit);
  for (const o of n.units) {
    const a = s(o);
    if (Math.abs(a) >= 1)
      return i(a, o);
  }
  return i(e > t ? -0 : 0, n.units[n.units.length - 1]);
}
function OL(e) {
  let t = {}, n;
  return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1], n = Array.from(e).slice(0, e.length - 1)) : n = Array.from(e), [t, n];
}
class Ke {
  /**
   * @access private
   */
  constructor(t) {
    const n = t.zone || Yn.defaultZone;
    let r = t.invalid || (Number.isNaN(t.ts) ? new Io("invalid input") : null) || (n.isValid ? null : Mv(n));
    this.ts = gt(t.ts) ? Yn.now() : t.ts;
    let i = null, s = null;
    if (!r)
      if (t.old && t.old.ts === this.ts && t.old.zone.equals(n))
        [i, s] = [t.old.c, t.old.o];
      else {
        const a = n.offset(this.ts);
        i = $L(this.ts, a), r = Number.isNaN(i.year) ? new Io("invalid input") : null, i = r ? null : i, s = r ? null : a;
      }
    this._zone = n, this.loc = t.loc || mn.create(), this.invalid = r, this.weekData = null, this.c = i, this.o = s, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new Ke({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [t, n] = OL(arguments), [r, i, s, o, a, l, c] = n;
    return ML({ year: r, month: i, day: s, hour: o, minute: a, second: l, millisecond: c }, t);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [t, n] = OL(arguments), [r, i, s, o, a, l, c] = n;
    return t.zone = Zr.utcInstance, ML({ year: r, month: i, day: s, hour: o, minute: a, second: l, millisecond: c }, t);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(t, n = {}) {
    const r = ale(t) ? t.valueOf() : NaN;
    if (Number.isNaN(r))
      return Ke.invalid("invalid input");
    const i = ju(n.zone, Yn.defaultZone);
    return i.isValid ? new Ke({
      ts: r,
      zone: i,
      loc: mn.fromObject(n)
    }) : Ke.invalid(Mv(i));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(t, n = {}) {
    if (Wd(t))
      return t < -xL || t > xL ? Ke.invalid("Timestamp out of range") : new Ke({
        ts: t,
        zone: ju(n.zone, Yn.defaultZone),
        loc: mn.fromObject(n)
      });
    throw new As(
      `fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(t, n = {}) {
    if (Wd(t))
      return new Ke({
        ts: t * 1e3,
        zone: ju(n.zone, Yn.defaultZone),
        loc: mn.fromObject(n)
      });
    throw new As("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(t, n = {}) {
    t = t || {};
    const r = ju(n.zone, Yn.defaultZone);
    if (!r.isValid)
      return Ke.invalid(Mv(r));
    const i = Yn.now(), s = gt(n.specificOffset) ? r.offset(i) : n.specificOffset, o = Y1(t, IL), a = !gt(o.ordinal), l = !gt(o.year), c = !gt(o.month) || !gt(o.day), p = l || c, f = o.weekYear || o.weekNumber, m = mn.fromObject(n);
    if ((p || a) && f)
      throw new Ey(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && a)
      throw new Ey("Can't mix ordinal dates with month/day");
    const y = f || o.weekday && !p;
    let g, v, w = $L(i, s);
    y ? (g = Xue, v = Yue, w = vI(w)) : a ? (g = ece, v = Que, w = lx(w)) : (g = Yz, v = Kz);
    let b = !1;
    for (const A of g) {
      const W = o[A];
      gt(W) ? b ? o[A] = v[A] : o[A] = w[A] : b = !0;
    }
    const S = y ? Zue(o) : a ? Kue(o) : Hz(o), $ = S || Jz(o);
    if ($)
      return Ke.invalid($);
    const I = y ? _L(o) : a ? SL(o) : o, [M, E] = iw(I, s, r), C = new Ke({
      ts: M,
      zone: r,
      o: E,
      loc: m
    });
    return o.weekday && p && t.weekday !== C.weekday ? Ke.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${C.toISO()}`
    ) : C;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(t, n = {}) {
    const [r, i] = hue(t);
    return Am(r, i, n, "ISO 8601", t);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(t, n = {}) {
    const [r, i] = fue(t);
    return Am(r, i, n, "RFC 2822", t);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(t, n = {}) {
    const [r, i] = mue(t);
    return Am(r, i, n, "HTTP", n);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(t, n, r = {}) {
    if (gt(t) || gt(n))
      throw new As("fromFormat requires an input string and a format");
    const { locale: i = null, numberingSystem: s = null } = r, o = mn.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    }), [a, l, c, p] = Jue(o, t, n);
    return p ? Ke.invalid(p) : Am(a, l, r, `format ${n}`, t, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(t, n, r = {}) {
    return Ke.fromFormat(t, n, r);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(t, n = {}) {
    const [r, i] = xue(t);
    return Am(r, i, n, "SQL", t);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(t, n = null) {
    if (!t)
      throw new As("need to specify a reason the DateTime is invalid");
    const r = t instanceof Io ? t : new Io(t, n);
    if (Yn.throwOnInvalid)
      throw new tle(r);
    return new Ke({ invalid: r });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(t) {
    return t && t.isLuxonDateTime || !1;
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(t) {
    return this[t];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? cx(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? cx(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? cx(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? lx(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Iv.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Iv.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Iv.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Iv.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return F0(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return Z1(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? og(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? K1(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(t = {}) {
    const { locale: n, numberingSystem: r, calendar: i } = _i.create(
      this.loc.clone(t),
      t
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: r, outputCalendar: i };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(t = 0, n = {}) {
    return this.setZone(Zr.instance(t), n);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Yn.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(t, { keepLocalTime: n = !1, keepCalendarTime: r = !1 } = {}) {
    if (t = ju(t, Yn.defaultZone), t.equals(this.zone))
      return this;
    if (t.isValid) {
      let i = this.ts;
      if (n || r) {
        const s = t.offset(this.ts), o = this.toObject();
        [i] = iw(o, s, t);
      }
      return km(this, { ts: i, zone: t });
    } else
      return Ke.invalid(Mv(t));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: t, numberingSystem: n, outputCalendar: r } = {}) {
    const i = this.loc.clone({ locale: t, numberingSystem: n, outputCalendar: r });
    return km(this, { loc: i });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(t) {
    return this.reconfigure({ locale: t });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const n = Y1(t, IL), r = !gt(n.weekYear) || !gt(n.weekNumber) || !gt(n.weekday), i = !gt(n.ordinal), s = !gt(n.year), o = !gt(n.month) || !gt(n.day), a = s || o, l = n.weekYear || n.weekNumber;
    if ((a || i) && l)
      throw new Ey(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (o && i)
      throw new Ey("Can't mix ordinal dates with month/day");
    let c;
    r ? c = _L({ ...vI(this.c), ...n }) : gt(n.ordinal) ? (c = { ...this.toObject(), ...n }, gt(n.day) && (c.day = Math.min(Z1(c.year, c.month), c.day))) : c = SL({ ...lx(this.c), ...n });
    const [p, f] = iw(c, this.o, this.zone);
    return km(this, { ts: p, o: f });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const n = St.fromDurationLike(t);
    return km(this, TL(this, n));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const n = St.fromDurationLike(t).negate();
    return km(this, TL(this, n));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(t) {
    if (!this.isValid)
      return this;
    const n = {}, r = St.normalizeUnit(t);
    switch (r) {
      case "years":
        n.month = 1;
      case "quarters":
      case "months":
        n.day = 1;
      case "weeks":
      case "days":
        n.hour = 0;
      case "hours":
        n.minute = 0;
      case "minutes":
        n.second = 0;
      case "seconds":
        n.millisecond = 0;
        break;
    }
    if (r === "weeks" && (n.weekday = 1), r === "quarters") {
      const i = Math.ceil(this.month / 3);
      n.month = (i - 1) * 3 + 1;
    }
    return this.set(n);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(t) {
    return this.isValid ? this.plus({ [t]: 1 }).startOf(t).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(t, n = {}) {
    return this.isValid ? _i.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, t) : ux;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(t = pI, n = {}) {
    return this.isValid ? _i.create(this.loc.clone(n), t).formatDateTime(this) : ux;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(t = {}) {
    return this.isValid ? _i.create(this.loc.clone(t), t).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: t = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: r = !1,
    includeOffset: i = !0
  } = {}) {
    if (!this.isValid)
      return null;
    const s = t === "extended";
    let o = dx(this, s);
    return o += "T", o += EL(this, s, n, r, i), o;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: t = "extended" } = {}) {
    return this.isValid ? dx(this, t === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return Cv(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: t = !1,
    suppressSeconds: n = !1,
    includeOffset: r = !0,
    includePrefix: i = !1,
    format: s = "extended"
  } = {}) {
    return this.isValid ? (i ? "T" : "") + EL(this, s === "extended", n, t, r) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return Cv(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return Cv(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? dx(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: t = !0, includeZone: n = !1, includeOffsetSpace: r = !0 } = {}) {
    let i = "HH:mm:ss.SSS";
    return (n || t) && (r && (i += " "), n ? i += "z" : t && (i += "ZZ")), Cv(this, i, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(t = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : ux;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(t = {}) {
    if (!this.isValid)
      return {};
    const n = { ...this.c };
    return t.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(t, n = "milliseconds", r = {}) {
    if (!this.isValid || !t.isValid)
      return St.invalid("created by diffing an invalid DateTime");
    const i = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, s = lle(n).map(St.normalizeUnit), o = t.valueOf() > this.valueOf(), a = o ? this : t, l = o ? t : this, c = Aue(a, l, s, i);
    return o ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(t = "milliseconds", n = {}) {
    return this.diff(Ke.now(), t, n);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(t) {
    return this.isValid ? Tn.fromDateTimes(this, t) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(t, n) {
    if (!this.isValid)
      return !1;
    const r = t.valueOf(), i = this.setZone(t.zone, { keepLocalTime: !0 });
    return i.startOf(n) <= r && r <= i.endOf(n);
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(t) {
    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(t = {}) {
    if (!this.isValid)
      return null;
    const n = t.base || Ke.fromObject({}, { zone: this.zone }), r = t.padding ? this < n ? -t.padding : t.padding : 0;
    let i = ["years", "months", "days", "hours", "minutes", "seconds"], s = t.unit;
    return Array.isArray(t.unit) && (i = t.unit, s = void 0), CL(n, this.plus(r), {
      ...t,
      numeric: "always",
      units: i,
      unit: s
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(t = {}) {
    return this.isValid ? CL(t.base || Ke.fromObject({}, { zone: this.zone }), this, {
      ...t,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...t) {
    if (!t.every(Ke.isDateTime))
      throw new As("min requires all arguments be DateTimes");
    return aL(t, (n) => n.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...t) {
    if (!t.every(Ke.isDateTime))
      throw new As("max requires all arguments be DateTimes");
    return aL(t, (n) => n.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(t, n, r = {}) {
    const { locale: i = null, numberingSystem: s = null } = r, o = mn.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    });
    return zz(o, t, n);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(t, n, r = {}) {
    return Ke.fromFormatExplain(t, n, r);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return pI;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return nz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return ile;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return rz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return iz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return sz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return oz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return az;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return lz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return uz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return cz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return dz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return pz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return hz;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return fz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return mz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return yz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return sle;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return gz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return vz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return bz;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return wz;
  }
}
function Pm(e) {
  if (Ke.isDateTime(e))
    return e;
  if (e && e.valueOf && Wd(e.valueOf()))
    return Ke.fromJSDate(e);
  if (e && typeof e == "object")
    return Ke.fromObject(e);
  throw new As(
    `Unknown datetime argument: ${e}, of type ${typeof e}`
  );
}
const px = { ar: [".", ","], bg: [",", ""], bs: [",", "."], ca: [",", "."], cs: [",", ""], da: [",", "."], de: [",", "."], "de-ch": [".", ""], el: [",", "."], en: [".", ","], "en-au": [".", ","], es: [",", "."], "es-mx": [".", ","], et: [",", ""], fi: [",", ""], fr: [",", ""], "fr-ch": [",", ""], he: [".", ","], hi: [".", ",", "#,##,##0.###"], hr: [",", "."], hu: [",", ""], id: [",", "."], it: [",", "."], "it-ch": [".", ""], ja: [".", ","], ko: [".", ","], lt: [",", ""], lv: [",", ""], mk: [",", "."], nb: [",", ""], nl: [",", "."], pl: [",", ""], pt: [",", "."], "pt-pt": [",", ""], ro: [",", "."], ru: [",", ""], sk: [",", ""], sl: [",", "."], sr: [",", "."], sv: [",", ""], th: [".", ","], tr: [",", "."], uk: [",", ""], vi: [",", "."], zh: [".", ","] };
function Qz(e) {
  e || (e = ts());
  let t = e in px;
  if (!t) {
    const s = e.split("-");
    s.length > 1 && s[0] in px && (e = s[0], t = !0), t || (e = "en");
  }
  const [n, r, i = "#,##0.###"] = px[e];
  return { decimal: n, group: r, pattern: i };
}
function tce(e, t) {
  const n = Qz((t = { ...t }).locale);
  t.customs = n;
  const r = t.pattern || n.pattern;
  return isNaN(e) || Math.abs(e) === 1 / 0 ? null : nce(e, r, t);
}
const Xz = /[#0,]*[#0](?:\.0*#*)?/;
function nce(e, t, n) {
  const r = (n = n || {}).customs.group, i = n.customs.decimal, s = t.split(";"), o = s[0];
  if ((t = s[e < 0 ? 1 : 0] || "-" + o).indexOf("%") !== -1)
    e *= 100;
  else if (t.indexOf("") !== -1)
    e *= 1e3;
  else {
    if (t.indexOf("") !== -1)
      throw new Error("currency notation not supported");
    if (t.indexOf("E") !== -1)
      throw new Error("exponential notation not supported");
  }
  const a = Xz, l = o.match(a);
  if (!l)
    throw new Error("unable to find a number expression in pattern: " + t);
  return n.fractional === !1 && (n.places = 0), t.replace(a, rce(e, l[0], { decimal: i, group: r, places: n.places, round: n.round }));
}
function rce(e, t, n) {
  (n = n || {}).places === !0 && (n.places = 0), n.places === 1 / 0 && (n.places = 6);
  const r = t.split("."), i = typeof n.places == "string" && n.places.indexOf(",");
  let s = n.places;
  i ? s = n.places.substring(i + 1) : s >= 0 || (s = (r[1] || []).length), n.round < 0 || (e = Number(e.toFixed(Number(s))));
  const o = String(Math.abs(e)).split("."), a = o[1] || "";
  if (r[1] || n.places) {
    i && (n.places = n.places.substring(0, i));
    const g = n.places !== void 0 ? n.places : r[1] && r[1].lastIndexOf("0") + 1;
    g > a.length && (o[1] = a.padEnd(Number(g), "0")), s < a.length && (o[1] = a.substr(0, Number(s)));
  } else
    o[1] && o.pop();
  const l = r[0].replace(",", "");
  let c = l.indexOf("0");
  c !== -1 && (c = l.length - c, c > o[0].length && (o[0] = o[0].padStart(c, "0")), l.indexOf("#") === -1 && (o[0] = o[0].substr(o[0].length - c)));
  let p, f, m = r[0].lastIndexOf(",");
  if (m !== -1) {
    p = r[0].length - m - 1;
    const g = r[0].substr(0, m);
    m = g.lastIndexOf(","), m !== -1 && (f = g.length - m - 1);
  }
  const y = [];
  for (let g = o[0]; g; ) {
    const v = g.length - p;
    y.push(v > 0 ? g.substr(v) : g), g = v > 0 ? g.slice(0, v) : "", f && (p = f, f = void 0);
  }
  return o[0] = y.reverse().join(n.group || ","), o.join(n.decimal || ".");
}
function ice(e) {
  const t = Qz((e = e || {}).locale), n = e.pattern || t.pattern, r = t.group, i = t.decimal;
  let s = 1;
  if (n.indexOf("%") !== -1)
    s /= 100;
  else if (n.indexOf("") !== -1)
    s /= 1e3;
  else if (n.indexOf("") !== -1)
    throw new Error("currency notation not supported");
  const o = n.split(";");
  return o.length === 1 && o.push("-" + o[0]), { regexp: Gg(o, function(l) {
    return (l = "(?:" + LD(l, ".") + ")").replace(Xz, function(c) {
      const p = { signed: !1, separator: e.strict ? r : [r, ""], fractional: e.fractional, decimal: i, exponent: !1 }, f = c.split(".");
      let m = e.places;
      f.length === 1 && s !== 1 && (f[1] = "###"), f.length === 1 || m === 0 ? p.fractional = !1 : (m === void 0 && (m = e.pattern ? f[1].lastIndexOf("0") + 1 : 1 / 0), m && e.fractional == null && (p.fractional = !0), !e.places && m < f[1].length && (m += "," + f[1].length), p.places = m);
      const y = f[0].split(",");
      return y.length > 1 && (p.groupSize = y.pop().length, y.length > 1 && (p.groupSize2 = y.pop().length)), "(" + oce(p) + ")";
    });
  }, !0).replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: r, decimal: i, factor: s };
}
function sce(e, t) {
  const n = ice(t), r = new RegExp("^" + n.regexp + "$").exec(e);
  if (!r)
    return NaN;
  let i = r[1];
  if (!r[1]) {
    if (!r[2])
      return NaN;
    i = r[2], n.factor *= -1;
  }
  return i = i.replace(new RegExp("[" + n.group + "\\s\\xa0]", "g"), "").replace(n.decimal, "."), Number(i) * n.factor;
}
function oce(e) {
  "places" in (e = e || {}) || (e.places = 1 / 0), typeof e.decimal != "string" && (e.decimal = "."), "fractional" in e && !/^0/.test(String(e.places)) || (e.fractional = [!0, !1]), "exponent" in e || (e.exponent = [!0, !1]), "eSigned" in e || (e.eSigned = [!0, !1]);
  const t = kL(e), n = Gg(e.fractional, function(i) {
    let s = "";
    return i && e.places !== 0 && (s = "\\" + e.decimal, e.places === 1 / 0 ? s = "(?:" + s + "\\d+)?" : s += "\\d{" + e.places + "}"), s;
  }, !0);
  let r = t + n;
  return n && (r = "(?:(?:" + r + ")|(?:" + n + "))"), r + Gg(e.exponent, function(i) {
    return i ? "([eE]" + kL({ signed: e.eSigned }) + ")" : "";
  });
}
function kL(e) {
  return "signed" in (e = e || {}) || (e.signed = [!0, !1]), "separator" in e ? "groupSize" in e || (e.groupSize = 3) : e.separator = "", Gg(e.signed, function(t) {
    return t ? "[-+]" : "";
  }, !0) + Gg(e.separator, function(t) {
    if (!t)
      return "(?:\\d+)";
    (t = LD(t)) === " " ? t = "\\s" : t === "" && (t = "\\s\\xa0");
    const n = e.groupSize, r = e.groupSize2;
    if (r) {
      const i = "(?:0|[1-9]\\d{0," + (r - 1) + "}(?:[" + t + "]\\d{" + r + "})*[" + t + "]\\d{" + n + "})";
      return n - r > 0 ? "(?:" + i + "|(?:0|[1-9]\\d{0," + (n - 1) + "}))" : i;
    }
    return "(?:0|[1-9]\\d{0," + (n - 1) + "}(?:[" + t + "]\\d{" + n + "})*)";
  }, !0);
}
const Gg = function(e, t, n) {
  if (!(e instanceof Array))
    return t(e);
  const r = [];
  for (let i = 0; i < e.length; i++)
    r.push(t(e[i]));
  return ace(r.join("|"), n);
}, ace = function(e, t) {
  return "(" + (t ? "?:" : "") + e + ")";
};
var AL, PL;
function YLe(e) {
  return _S.fromJSON(e.toJSON());
}
function lce(e) {
  return e.toJSON ? e.toJSON() : e;
}
function QLe(e) {
  return typeof e == "string" || e instanceof String;
}
function XLe(e) {
  return typeof e == "number";
}
function RL(e) {
  return e instanceof Date;
}
function eFe(e, t) {
  return e === t || !(!RL(e) || !RL(t)) && e.getTime() === t.getTime();
}
function tFe(e) {
  if (e === void 0)
    return null;
  if (typeof e == "number")
    return e;
  switch (e.toLowerCase()) {
    case "meters":
    case "meter":
      return 109404;
    case "miles":
    case "mile":
      return 109413;
    case "kilometers":
    case "kilometer":
    case "km":
      return 109414;
  }
  return null;
}
function nFe(e) {
  if (e === null)
    return null;
  switch (e.type) {
    case "polygon":
    case "multipoint":
    case "polyline":
      return e.extent;
    case "point":
      return new Mt({ xmin: e.x, ymin: e.y, xmax: e.x, ymax: e.y, spatialReference: e.spatialReference });
    case "extent":
      return e;
  }
  return null;
}
function rFe(e) {
  if (e === void 0)
    return null;
  if (typeof e == "number" || typeof e == "number")
    return e;
  switch (e.toLowerCase()) {
    case "meters":
    case "meter":
      return 9001;
    case "miles":
    case "mile":
      return 9035;
    case "kilometers":
    case "kilometer":
    case "km":
      return 9036;
  }
  return null;
}
(function(e) {
  e[e.Standardised = 0] = "Standardised", e[e.StandardisedNoInterval = 1] = "StandardisedNoInterval", e[e.SqlServer = 2] = "SqlServer", e[e.Oracle = 3] = "Oracle", e[e.Postgres = 4] = "Postgres", e[e.PGDB = 5] = "PGDB", e[e.FILEGDB = 6] = "FILEGDB", e[e.NotEvaluated = 7] = "NotEvaluated";
})(AL || (AL = {})), function(e) {
  e[e.InFeatureSet = 0] = "InFeatureSet", e[e.NotInFeatureSet = 1] = "NotInFeatureSet", e[e.Unknown = 2] = "Unknown";
}(PL || (PL = {}));
const iFe = 1e3, sFe = { point: "point", polygon: "polygon", polyline: "polyline", multipoint: "multipoint", extent: "extent", esriGeometryPoint: "point", esriGeometryPolygon: "polygon", esriGeometryPolyline: "polyline", esriGeometryMultipoint: "multipoint", esriGeometryEnvelope: "extent", envelope: "extent" }, LL = { point: "esriGeometryPoint", polygon: "esriGeometryPolygon", polyline: "esriGeometryPolyline", multipoint: "esriGeometryMultipoint", extent: "esriGeometryEnvelope", esriGeometryPoint: "esriGeometryPoint", esriGeometryPolygon: "esriGeometryPolygon", esriGeometryPolyline: "esriGeometryPolyline", esriGeometryMultipoint: "esriGeometryMultipoint", esriGeometryEnvelope: "esriGeometryEnvelope", envelope: "esriGeometryEnvelope" }, oFe = { "small-integer": "esriFieldTypeSmallInteger", integer: "esriFieldTypeInteger", long: "esriFieldTypeLong", single: "esriFieldTypeSingle", double: "esriFieldTypeDouble", string: "esriFieldTypeString", date: "esriFieldTypeDate", oid: "esriFieldTypeOID", geometry: "esriFieldTypeGeometry", blob: "esriFieldTypeBlob", raster: "esriFieldTypeRaster", guid: "esriFieldTypeGUID", "global-id": "esriFieldTypeGlobalID", xml: "eesriFieldTypeXML", esriFieldTypeSmallInteger: "esriFieldTypeSmallInteger", esriFieldTypeInteger: "esriFieldTypeInteger", esriFieldTypeLong: "esriFieldTypeLong", esriFieldTypeSingle: "esriFieldTypeSingle", esriFieldTypeDouble: "esriFieldTypeDouble", esriFieldTypeString: "esriFieldTypeString", esriFieldTypeDate: "esriFieldTypeDate", esriFieldTypeOID: "esriFieldTypeOID", esriFieldTypeGeometry: "esriFieldTypeGeometry", esriFieldTypeBlob: "esriFieldTypeBlob", esriFieldTypeRaster: "esriFieldTypeRaster", esriFieldTypeGUID: "esriFieldTypeGUID", esriFieldTypeGlobalID: "esriFieldTypeGlobalID", esriFieldTypeXML: "eesriFieldTypeXML" };
function aFe(e, t) {
  return GC((n, r) => {
    const i = Dh(!0);
    e.reduce((s, o, a, l) => s.then((c) => {
      try {
        return t(c, o, a, l);
      } catch (p) {
        return OA(p);
      }
    }, (c) => OA(c)), i).then(n, r);
  });
}
function lFe(e) {
  return e === void 0 ? "" : e = (e = (e = e.replace(/\/featureserver\/[0-9]*/i, "/FeatureServer")).replace(/\/mapserver\/[0-9]*/i, "/MapServer")).split("?")[0];
}
function uFe(e, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  const n = typeof t.cycles == "boolean" && t.cycles, r = t.cmp && (i = t.cmp, function(o) {
    return function(a, l) {
      const c = { key: a, value: o[a] }, p = { key: l, value: o[l] };
      return i(c, p);
    };
  });
  var i;
  const s = [];
  return function o(a) {
    if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a === void 0)
      return;
    if (typeof a == "number")
      return isFinite(a) ? "" + a : "null";
    if (typeof a != "object")
      return JSON.stringify(a);
    let l, c;
    if (Array.isArray(a)) {
      for (c = "[", l = 0; l < a.length; l++)
        l && (c += ","), c += o(a[l]) || "null";
      return c + "]";
    }
    if (a === null)
      return "null";
    if (s.indexOf(a) !== -1) {
      if (n)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    const p = s.push(a) - 1, f = Object.keys(a).sort(r && r(a));
    for (c = "", l = 0; l < f.length; l++) {
      const m = f[l], y = o(a[m]);
      y && (c && (c += ","), c += JSON.stringify(m) + ":" + y);
    }
    return s.splice(p, 1), "{" + c + "}";
  }(e);
}
let e7 = class {
  constructor(t) {
    this.value = t;
  }
}, t7 = class {
  constructor(t) {
    this.value = t;
  }
}, Mk = class {
  constructor(t) {
    this.fn = t;
  }
}, Ck = class {
  constructor(t, n) {
    this.paramCount = n, this.fn = t;
  }
};
const uce = Mk, cce = t7, dce = e7, pce = Ck, Ji = { type: "VOID" }, hce = { type: "BREAK" }, fce = { type: "CONTINUE" };
function Wg(e, t, n) {
  return t === "" || t == null || t === n || t === n ? e : e = e.split(t).join(n);
}
function Ok(e) {
  return e instanceof Mk || e instanceof Xae || e instanceof Ck;
}
function X1(e) {
  return !!br(e) || !!Wr(e) || !!Ar(e) || !!Gr(e) || e === null || e === Ji || typeof e == "number";
}
function mce(e, t) {
  return e === void 0 ? t : e;
}
function br(e) {
  return typeof e == "string" || e instanceof String;
}
function Gr(e) {
  return typeof e == "boolean";
}
function Wr(e) {
  return typeof e == "number";
}
function yce(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
function Vs(e) {
  return e instanceof Array;
}
function gce(e) {
  return (e == null ? void 0 : e.arcadeDeclaredClass) === "geoscene.arcade.Feature";
}
function vce(e) {
  return (e && e.declaredRootClass && e.declaredRootClass === "geoscene.arcade.featureset.support.FeatureSet") === !0;
}
function bce(e) {
  return (e && e.declaredRootClass && e.declaredRootClass === "geoscene.arcade.featureSetCollection") === !0;
}
function fp(e) {
  return e instanceof Fa;
}
function Ar(e) {
  return e instanceof Date;
}
function wce(e, t, n) {
  if (e.length < t || e.length > n)
    throw new Error("Function called with wrong number of Parameters");
}
function _ce(e) {
  return e < 0 ? -Math.round(-e) : Math.round(e);
}
function Sce() {
  let e = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
    const n = (e + 16 * Math.random()) % 16 | 0;
    return e = Math.floor(e / 16), (t === "x" ? n : 3 & n | 8).toString(16);
  });
}
function kk(e, t) {
  return isNaN(e) === !1 ? t == null || t === "" ? e.toString() : (t = Wg(t, "", ""), t = Wg(t, "", ""), tce(e, { pattern: t })) : e.toString();
}
function IS(e, t) {
  const n = Ke.fromJSDate(e);
  return t == null || t === "" ? n.toISO({ suppressMilliseconds: !0 }) : n.toFormat(n7(t), { locale: ts(), numberingSystem: "latn" });
}
function n7(e) {
  e = e.replace(/LTS|LT|LL?L?L?|l{1,4}/g, "[$&]");
  let t = "";
  const n = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  for (const r of e.match(n))
    switch (r) {
      case "D":
        t += "d";
        break;
      case "DD":
        t += "dd";
        break;
      case "DDD":
        t += "o";
        break;
      case "d":
        t += "c";
        break;
      case "ddd":
        t += "ccc";
        break;
      case "dddd":
        t += "cccc";
        break;
      case "M":
        t += "L";
        break;
      case "MM":
        t += "LL";
        break;
      case "MMM":
        t += "LLL";
        break;
      case "MMMM":
        t += "LLLL";
        break;
      case "YY":
        t += "yy";
        break;
      case "Y":
      case "YYYY":
        t += "yyyy";
        break;
      case "Q":
        t += "q";
        break;
      case "Z":
        t += "ZZ";
        break;
      case "ZZ":
        t += "ZZZ";
        break;
      case "S":
        t += "'S'";
        break;
      case "SS":
        t += "'SS'";
        break;
      case "SSS":
        t += "u";
        break;
      case "A":
      case "a":
        t += "a";
        break;
      case "m":
      case "mm":
      case "h":
      case "hh":
      case "H":
      case "HH":
      case "s":
      case "ss":
      case "X":
      case "x":
        t += r;
        break;
      default:
        r.length >= 2 && r.slice(0, 1) === "[" && r.slice(-1) === "]" ? t += `'${r.slice(1, -1)}'` : t += `'${r}'`;
    }
  return t;
}
function Ct(e, t, n) {
  switch (n) {
    case ">":
      return e > t;
    case "<":
      return e < t;
    case ">=":
      return e >= t;
    case "<=":
      return e <= t;
  }
  return !1;
}
function xce(e, t, n) {
  if (e === null) {
    if (t === null || t === Ji)
      return Ct(null, null, n);
    if (Wr(t))
      return Ct(0, t, n);
    if (br(t) || Gr(t))
      return Ct(0, fn(t), n);
    if (Ar(t))
      return Ct(0, t.getTime(), n);
  }
  if (e === Ji) {
    if (t === null || t === Ji)
      return Ct(null, null, n);
    if (Wr(t))
      return Ct(0, t, n);
    if (br(t) || Gr(t))
      return Ct(0, fn(t), n);
    if (Ar(t))
      return Ct(0, t.getTime(), n);
  } else if (Wr(e)) {
    if (Wr(t))
      return Ct(e, t, n);
    if (Gr(t))
      return Ct(e, fn(t), n);
    if (t === null || t === Ji)
      return Ct(e, 0, n);
    if (br(t))
      return Ct(e, fn(t), n);
    if (Ar(t))
      return Ct(e, t.getTime(), n);
  } else if (br(e)) {
    if (br(t))
      return Ct(Ku(e), Ku(t), n);
    if (Ar(t))
      return Ct(fn(e), t.getTime(), n);
    if (Wr(t))
      return Ct(fn(e), t, n);
    if (t === null || t === Ji)
      return Ct(fn(e), 0, n);
    if (Gr(t))
      return Ct(fn(e), fn(t), n);
  } else if (Ar(e)) {
    if (Ar(t))
      return Ct(e, t, n);
    if (t === null || t === Ji)
      return Ct(e.getTime(), 0, n);
    if (Wr(t))
      return Ct(e.getTime(), t, n);
    if (Gr(t) || br(t))
      return Ct(e.getTime(), fn(t), n);
  } else if (Gr(e)) {
    if (Gr(t))
      return Ct(e, t, n);
    if (Wr(t))
      return Ct(fn(e), fn(t), n);
    if (Ar(t))
      return Ct(fn(e), t.getTime(), n);
    if (t === null || t === Ji)
      return Ct(fn(e), 0, n);
    if (br(t))
      return Ct(fn(e), fn(t), n);
  }
  return !!r7(e, t) && (n === "<=" || n === ">=");
}
function r7(e, t) {
  if (e === t || e === null && t === Ji || t === null && e === Ji)
    return !0;
  if (Ar(e) && Ar(t))
    return e.getTime() === t.getTime();
  if (e instanceof ele || e instanceof L0)
    return e.equalityTest(t);
  if (e instanceof Oe && t instanceof Oe) {
    const n = e.cache._arcadeCacheId, r = t.cache._arcadeCacheId;
    if (n != null)
      return n === r;
  }
  return e !== void 0 && t !== void 0 && e !== null && t !== null && typeof e == "object" && typeof t == "object" && (e._arcadeCacheId === t._arcadeCacheId && e._arcadeCacheId !== void 0 && e._arcadeCacheId !== null || e._underlyingGraphic === t._underlyingGraphic && e._underlyingGraphic !== void 0 && e._underlyingGraphic !== null);
}
function Ku(e, t) {
  if (br(e))
    return e;
  if (e === null)
    return "";
  if (Wr(e))
    return kk(e, t);
  if (Gr(e))
    return e.toString();
  if (Ar(e))
    return IS(e, t);
  if (e instanceof Ci)
    return JSON.stringify(e.toJSON());
  if (Vs(e)) {
    const n = [];
    for (let r = 0; r < e.length; r++)
      n[r] = e_(e[r]);
    return "[" + n.join(",") + "]";
  }
  if (e instanceof Fa) {
    const n = [];
    for (let r = 0; r < e.length(); r++)
      n[r] = e_(e.get(r));
    return "[" + n.join(",") + "]";
  }
  return e !== null && typeof e == "object" && e.castToText !== void 0 ? e.castToText() : Ok(e) ? "object, Function" : "";
}
function $ce(e) {
  const t = [];
  if (Vs(e) === !1)
    return null;
  if (e instanceof Fa) {
    for (let n = 0; n < e.length(); n++)
      t[n] = fn(e.get(n));
    return t;
  }
  for (let n = 0; n < e.length; n++)
    t[n] = fn(e[n]);
  return t;
}
function sw(e, t) {
  if (br(e))
    return e;
  if (e === null)
    return "";
  if (Wr(e))
    return kk(e, t);
  if (Gr(e))
    return e.toString();
  if (Ar(e))
    return IS(e, t);
  if (e instanceof Ci)
    return e instanceof Mt ? '{"xmin":' + e.xmin.toString() + ',"ymin":' + e.ymin.toString() + "," + (e.hasZ ? '"zmin":' + e.zmin.toString() + "," : "") + (e.hasM ? '"mmin":' + e.mmin.toString() + "," : "") + '"xmax":' + e.xmax.toString() + ',"ymax":' + e.ymax.toString() + "," + (e.hasZ ? '"zmax":' + e.zmax.toString() + "," : "") + (e.hasM ? '"mmax":' + e.mmax.toString() + "," : "") + '"spatialReference":' + bI(e.spatialReference) + "}" : bI(e.toJSON(), (n, r) => n.key === r.key ? 0 : n.key === "spatialReference" ? 1 : r.key === "spatialReference" || n.key < r.key ? -1 : n.key > r.key ? 1 : 0);
  if (Vs(e)) {
    const n = [];
    for (let r = 0; r < e.length; r++)
      n[r] = e_(e[r]);
    return "[" + n.join(",") + "]";
  }
  if (e instanceof Fa) {
    const n = [];
    for (let r = 0; r < e.length(); r++)
      n[r] = e_(e.get(r));
    return "[" + n.join(",") + "]";
  }
  return e !== null && typeof e == "object" && e.castToText !== void 0 ? e.castToText() : Ok(e) ? "object, Function" : "";
}
function e_(e) {
  if (e === null)
    return "null";
  if (Gr(e) || Wr(e) || br(e))
    return JSON.stringify(e);
  if (e instanceof Ci || e instanceof Fa || e instanceof Array)
    return sw(e);
  if (e instanceof Date)
    return JSON.stringify(IS(e, ""));
  if (e !== null && typeof e == "object") {
    if (e.castToText !== void 0)
      return e.castToText();
  } else if (e === Ji)
    return "null";
  return "null";
}
function fn(e, t) {
  return Wr(e) ? e : e === null || e === "" ? 0 : Ar(e) ? NaN : Gr(e) ? e ? 1 : 0 : Vs(e) || e === "" || e === void 0 ? NaN : t !== void 0 && br(e) ? (t = Wg(t, "", ""), t = Wg(t, "", ""), sce(e, { pattern: t })) : e === Ji ? 0 : Number(e);
}
function Tce(e) {
  if (Ar(e))
    return e;
  if (br(e)) {
    const t = i7(e);
    if (t)
      return t.toJSDate();
  }
  return null;
}
function Ece(e) {
  return Ar(e) ? Ke.fromJSDate(e) : br(e) ? i7(e) : null;
}
function i7(e) {
  const t = / (\d\d)/;
  let n = Ke.fromISO(e);
  return n.isValid || t.test(e) && (e = e.replace(t, "T$1"), n = Ke.fromISO(e), n.isValid) ? n : null;
}
function Ice(e) {
  return Gr(e) ? e : br(e) ? (e = e.toLowerCase()) === "true" : !!Wr(e) && e !== 0 && !isNaN(e);
}
function Mce(e, t) {
  return H(e) ? null : (e.spatialReference !== null && e.spatialReference !== void 0 || (e.spatialReference = t), e);
}
function Cce(e) {
  if (e === null)
    return null;
  if (e instanceof Oe)
    return e.x === "NaN" || e.x === null || isNaN(e.x) ? null : e;
  if (e instanceof Po) {
    if (e.rings.length === 0)
      return null;
    for (const t of e.rings)
      if (t.length > 0)
        return e;
    return null;
  }
  if (e instanceof Ki) {
    if (e.paths.length === 0)
      return null;
    for (const t of e.paths)
      if (t.length > 0)
        return e;
    return null;
  }
  return e instanceof Gf ? e.points.length === 0 ? null : e : e instanceof Mt ? e.xmin === "NaN" || e.xmin === null || isNaN(e.xmin) ? null : e : null;
}
function s7(e, t) {
  if (!e || !e.domain)
    return t;
  let n = null;
  if (e.field.type === "string" || e.field.type === "esriFieldTypeString")
    t = Ku(t);
  else {
    if (t == null)
      return null;
    if (t === "")
      return t;
    t = fn(t);
  }
  for (let r = 0; r < e.domain.codedValues.length; r++) {
    const i = e.domain.codedValues[r];
    i.code === t && (n = i);
  }
  return n === null ? t : n.name;
}
function o7(e, t) {
  if (!e || !e.domain)
    return t;
  let n = null;
  t = Ku(t);
  for (let r = 0; r < e.domain.codedValues.length; r++) {
    const i = e.domain.codedValues[r];
    i.name === t && (n = i);
  }
  return n === null ? t : n.code;
}
function MS(e, t, n = null, r = null) {
  if (!t || !t.fields)
    return null;
  let i, s, o = null;
  for (let a = 0; a < t.fields.length; a++) {
    const l = t.fields[a];
    l.name.toLowerCase() === e.toString().toLowerCase() && (o = l);
  }
  if (o === null)
    throw new Error("Field not found");
  return r === null && n && t.typeIdField && (r = n.hasField(t.typeIdField) ? n.field(t.typeIdField) : null), r != null && t.types.some(function(a) {
    return a.id === r && (i = a.domains && a.domains[o.name], i && i.type === "inherited" && (i = FL(o.name, t), s = !0), !0);
  }), s || i || (i = FL(e, t)), { field: o, domain: i };
}
function FL(e, t) {
  let n;
  return t.fields.some(function(r) {
    return r.name.toLowerCase() === e.toLowerCase() && (n = r.domain), !!n;
  }), n;
}
function bI(e, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  const n = typeof t.cycles == "boolean" && t.cycles, r = t.cmp && (i = t.cmp, function(o) {
    return function(a, l) {
      const c = { key: a, value: o[a] }, p = { key: l, value: o[l] };
      return i(c, p);
    };
  });
  var i;
  const s = [];
  return function o(a) {
    if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a === void 0)
      return;
    if (typeof a == "number")
      return isFinite(a) ? "" + a : "null";
    if (typeof a != "object")
      return JSON.stringify(a);
    let l, c;
    if (Array.isArray(a)) {
      for (c = "[", l = 0; l < a.length; l++)
        l && (c += ","), c += o(a[l]) || "null";
      return c + "]";
    }
    if (a === null)
      return "null";
    if (s.indexOf(a) !== -1) {
      if (n)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    const p = s.push(a) - 1, f = Object.keys(a).sort(r && r(a));
    for (c = "", l = 0; l < f.length; l++) {
      const m = f[l], y = o(a[m]);
      y && (c && (c += ","), c += JSON.stringify(m) + ":" + y);
    }
    return s.splice(p, 1), "{" + c + "}";
  }(e);
}
function Oce(e) {
  if (e === null)
    return null;
  const t = [];
  for (const n of e)
    n && n.arcadeDeclaredClass && n.arcadeDeclaredClass === "geoscene.arcade.Feature" ? t.push(n.geometry()) : t.push(n);
  return t;
}
function Tf(e, t) {
  if (!(t instanceof Oe))
    throw new Error("Invalid Argument");
  e.push(t.hasZ ? t.hasM ? [t.x, t.y, t.z, t.m] : [t.x, t.y, t.z] : [t.x, t.y]);
}
function kce(e, t) {
  if (Vs(e) || fp(e)) {
    let n = !1, r = !1, i = [], s = t;
    if (Vs(e)) {
      for (const o of e)
        Tf(i, o);
      i.length > 0 && (s = e[0].spatialReference, n = e[0].hasZ, r = e[0].hasM);
    } else if (e instanceof L0)
      i = e._elements, i.length > 0 && (n = e._hasZ, r = e._hasM, s = e.get(0).spatialReference);
    else {
      if (!fp(e))
        throw new Error("Invalid Argument");
      for (const o of e.toArray())
        Tf(i, o);
      i.length > 0 && (s = e.get(0).spatialReference, n = e.get(0).hasZ === !0, r = e.get(0).hasM === !0);
    }
    return i.length === 0 ? null : (yO(i, r, n) === !1 && (i = i.slice(0).reverse()), new Po({ rings: [i], spatialReference: s, hasZ: n, hasM: r }));
  }
  return e;
}
function Ace(e, t) {
  if (Vs(e) || fp(e)) {
    let n = !1, r = !1, i = [], s = t;
    if (Vs(e)) {
      for (const o of e)
        Tf(i, o);
      i.length > 0 && (s = e[0].spatialReference, n = e[0].hasZ === !0, r = e[0].hasM === !0);
    } else if (e instanceof L0)
      i = e._elements, i.length > 0 && (n = e._hasZ, r = e._hasM, s = e.get(0).spatialReference);
    else if (fp(e)) {
      for (const o of e.toArray())
        Tf(i, o);
      i.length > 0 && (s = e.get(0).spatialReference, n = e.get(0).hasZ === !0, r = e.get(0).hasM === !0);
    }
    return i.length === 0 ? null : new Ki({ paths: [i], spatialReference: s, hasZ: n, hasM: r });
  }
  return e;
}
function Pce(e, t) {
  if (Vs(e) || fp(e)) {
    let n = !1, r = !1, i = [], s = t;
    if (Vs(e)) {
      for (const o of e)
        Tf(i, o);
      i.length > 0 && (s = e[0].spatialReference, n = e[0].hasZ === !0, r = e[0].hasM === !0);
    } else if (e instanceof L0)
      i = e._elements, i.length > 0 && (n = e._hasZ, r = e._hasM, s = e.get(0).spatialReference);
    else if (fp(e)) {
      for (const o of e.toArray())
        Tf(i, o);
      i.length > 0 && (s = e.get(0).spatialReference, n = e.get(0).hasZ === !0, r = e.get(0).hasM === !0);
    }
    return i.length === 0 ? null : new Gf({ points: i, spatialReference: s, hasZ: n, hasM: r });
  }
  return e;
}
function Rce(e, t = !1) {
  const n = [];
  if (e === null)
    return n;
  if (Vs(e) === !0) {
    for (let r = 0; r < e.length; r++) {
      const i = Ku(e[r]);
      i === "" && t !== !0 || n.push(i);
    }
    return n;
  }
  if (e instanceof Fa) {
    for (let r = 0; r < e.length(); r++) {
      const i = Ku(e.get(r));
      i === "" && t !== !0 || n.push(i);
    }
    return n;
  }
  if (X1(e)) {
    const r = Ku(e);
    return r === "" && t !== !0 || n.push(r), n;
  }
  return [];
}
let hx = 0;
function Lce(e) {
  return hx++, hx % 100 == 0 ? (hx = 0, GC((t) => {
    setTimeout(() => {
      t(e);
    }, 0);
  })) : e;
}
function Fce(e, t, n) {
  switch (n) {
    case "&":
      return e & t;
    case "|":
      return e | t;
    case "^":
      return e ^ t;
    case "<<":
      return e << t;
    case ">>":
      return e >> t;
    case ">>>":
      return e >>> t;
  }
}
function Hg(e, t = null) {
  return e == null ? null : Gr(e) || Wr(e) || br(e) ? e : e instanceof Ci ? (t == null ? void 0 : t.keepGeometryType) === !0 ? e : e.toJSON() : e instanceof Fa ? e.toArray().map((n) => Hg(n, t)) : e instanceof Array ? e.map((n) => Hg(n, t)) : e instanceof Date ? e : e !== null && typeof e == "object" && e.castAsJson !== void 0 ? e.castAsJson(t) : null;
}
function Nce(e, t, n, r, i) {
  return Ak(e, t, n).then((s) => {
    i[r] = s;
  });
}
function Ak(e, t = null, n = null) {
  if (e instanceof Fa && (e = e.toArray()), e == null)
    return Dh(null);
  if (X1(e) || e instanceof Ci || e instanceof Date)
    return Dh(Hg(e, n));
  if (e instanceof Array) {
    const r = [], i = [];
    for (const s of e)
      s === null || X1(s) || s instanceof Ci || s instanceof Date ? i.push(Hg(s, n)) : (i.push(null), r.push(Nce(s, t, n, i.length - 1, i)));
    return r.length > 0 ? KD(r).then(() => i) : Dh(i);
  }
  return e !== null && typeof e == "object" && e.castAsJsonAsync !== void 0 ? e.castAsJsonAsync(t, n) : Dh(null);
}
function Dce(e, t, n) {
  const r = e.fullSchema();
  return r === null || !r.fields ? null : MS(t, r, e, n);
}
function jce(e) {
  const t = e.fullSchema();
  return t === null ? null : t.fields && t.typeIdField ? { subtypeField: t.typeIdField, subtypes: t.types ? t.types.map((n) => ({ name: n.name, code: n.id })) : [] } : null;
}
function Vce(e, t, n, r) {
  const i = e.fullSchema();
  if (i === null || !i.fields)
    return null;
  const s = MS(t, i, e, r);
  if (n === void 0)
    try {
      n = e.field(t);
    } catch {
      return null;
    }
  return s7(s, n);
}
function zce(e, t, n, r) {
  const i = e.fullSchema();
  if (i === null || !i.fields)
    return null;
  if (n === void 0) {
    try {
      n = e.field(t);
    } catch {
      return null;
    }
    return n;
  }
  return o7(MS(t, i, e, r), n);
}
function Bce(e) {
  const t = e.fullSchema();
  if (t === null || !t.fields)
    return null;
  const n = [];
  for (const r of t.fields)
    n.push(lce(r));
  return { objectIdField: t.objectIdField, globalIdField: t.globalIdField, geometryType: LL[t.geometryType] === void 0 ? "" : LL[t.geometryType], fields: n };
}
const fFe = Object.freeze({ __proto__: null, ReturnResultE: e7, ImplicitResultE: t7, NativeFunctionE: Mk, SizzleFunctionE: Ck, NativeFunction: uce, ImplicitResult: cce, ReturnResult: dce, SizzleFunction: pce, voidOperation: Ji, breakResult: hce, continueResult: fce, multiReplace: Wg, isFunctionParameter: Ok, isSimpleType: X1, defaultUndefined: mce, isString: br, isBoolean: Gr, isNumber: Wr, isInteger: yce, isArray: Vs, isFeature: gce, isFeatureSet: vce, isFeatureSetCollection: bce, isImmutableArray: fp, isDate: Ar, pcCheck: wce, absRound: _ce, generateUUID: Sce, formatNumber: kk, formatDate: IS, standardiseDateFormat: n7, greaterThanLessThan: xce, equalityTest: r7, toString: Ku, toNumberArray: $ce, toStringExplicit: sw, toNumber: fn, toDate: Tce, toDateTime: Ece, toBoolean: Ice, fixSpatialReference: Mce, fixNullGeometry: Cce, getDomainValue: s7, getDomainCode: o7, getDomain: MS, stableStringify: bI, autoCastFeatureToGeometry: Oce, autoCastArrayOfPointsToPolygon: kce, autoCastArrayOfPointsToPolyline: Ace, autoCastArrayOfPointsToMultiPoint: Pce, toStringArray: Rce, tick: Lce, binaryOperator: Fce, castAsJson: Hg, castAsJsonAsync: Ak, featureFullDomain: Dce, featureSubtypes: jce, featureDomainValueLookup: Vce, featureDomainCodeLookup: zce, featureSchema: Bce });
var wI;
let My = wI = class extends se {
  constructor(e) {
    super(e), this.minValue = 0, this.maxValue = 0;
  }
  clone() {
    return new wI({ minValue: this.minValue, maxValue: this.maxValue });
  }
};
u([d({ type: Number, json: { write: !0 } })], My.prototype, "minValue", void 0), u([d({ type: Number, json: { write: !0 } })], My.prototype, "maxValue", void 0), My = wI = u([T("geoscene.renderer.support.AuthoringInfoClassBreakInfo")], My);
const Uce = My;
var _I;
let Yc = _I = class extends se {
  constructor(e) {
    super(e), this.field = "", this.normalizationField = "", this.label = "", this.classBreakInfos = [];
  }
  clone() {
    return new _I({ field: this.field, normalizationField: this.normalizationField, label: this.label, classBreakInfos: q(this.classBreakInfos) });
  }
};
u([d({ type: String, json: { write: !0 } })], Yc.prototype, "field", void 0), u([d({ type: String, json: { write: !0 } })], Yc.prototype, "normalizationField", void 0), u([d({ type: String, json: { write: !0 } })], Yc.prototype, "label", void 0), u([d({ type: [Uce], json: { write: !0 } })], Yc.prototype, "classBreakInfos", void 0), Yc = _I = u([T("geoscene.renderers.support.AuthoringInfoFieldInfo")], Yc);
const NL = Yc;
var SI;
const Ov = new st({ percentTotal: "percent-of-total", ratio: "ratio", percent: "percent" }), kv = new st({ sizeInfo: "size", colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation" }), DL = { key: (e) => typeof e == "number" ? "number" : "string", typeMap: { number: Number, string: String }, base: null }, jL = ["high-to-low", "above-and-below", "centered-on", "extremes"], VL = [.../* @__PURE__ */ new Set(["high-to-low", "above-and-below", "centered-on", "extremes", "90-10", "above", "below", "high-to-low", "above-and-below", "90-10", "above", "below"])], zL = ["seconds", "minutes", "hours", "days", "months", "years"];
let fi = SI = class extends se {
  constructor(e) {
    super(e), this.endTime = null, this.field = null, this.maxSliderValue = null, this.minSliderValue = null, this.startTime = null, this.type = null, this.units = null;
  }
  castEndTime(e) {
    return typeof e == "string" || typeof e == "number" ? e : null;
  }
  castStartTime(e) {
    return typeof e == "string" || typeof e == "number" ? e : null;
  }
  get style() {
    return this.type === "color" ? this._get("style") : null;
  }
  set style(e) {
    this._set("style", e);
  }
  get theme() {
    return this.type === "color" || this.type === "size" ? this._get("theme") || "high-to-low" : null;
  }
  set theme(e) {
    this._set("theme", e);
  }
  clone() {
    return new SI({ endTime: this.endTime, field: this.field, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, startTime: this.startTime, style: this.style, theme: this.theme, type: this.type, units: this.units });
  }
};
u([d({ types: DL, json: { write: !0 } })], fi.prototype, "endTime", void 0), u([mt("endTime")], fi.prototype, "castEndTime", null), u([d({ type: String, json: { write: !0 } })], fi.prototype, "field", void 0), u([d({ type: Number, json: { write: !0 } })], fi.prototype, "maxSliderValue", void 0), u([d({ type: Number, json: { write: !0 } })], fi.prototype, "minSliderValue", void 0), u([d({ types: DL, json: { write: !0 } })], fi.prototype, "startTime", void 0), u([mt("startTime")], fi.prototype, "castStartTime", null), u([d({ type: Ov.apiValues, value: null, json: { type: Ov.jsonValues, read: Ov.read, write: Ov.write } })], fi.prototype, "style", null), u([d({ type: VL, value: null, json: { type: VL, origins: { "web-scene": { type: jL, write: { writer: (e, t) => {
  jL.indexOf(e) > -1 && (t.theme = e);
} } } }, write: !0 } })], fi.prototype, "theme", null), u([d({ type: kv.apiValues, json: { type: kv.jsonValues, read: kv.read, write: kv.write } })], fi.prototype, "type", void 0), u([d({ type: zL, json: { type: zL, write: !0 } })], fi.prototype, "units", void 0), fi = SI = u([T("geoscene.renderers.support.AuthoringInfoVisualVariable")], fi);
const qce = fi;
let ow = class extends se {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d({ readOnly: !0, json: { read: !1, write: !0 } })], ow.prototype, "type", void 0), ow = u([T("geoscene.rest.support.ColorRamp")], ow);
const Pk = ow;
var xI;
let Qc = xI = class extends Pk {
  constructor(e) {
    super(e), this.algorithm = null, this.fromColor = null, this.toColor = null, this.type = "algorithmic";
  }
  clone() {
    return new xI({ fromColor: q(this.fromColor), toColor: q(this.toColor), algorithm: this.algorithm });
  }
};
u([De({ esriCIELabAlgorithm: "cie-lab", esriHSVAlgorithm: "hsv", esriLabLChAlgorithm: "lab-lch" })], Qc.prototype, "algorithm", void 0), u([d({ type: Fe, json: { type: [Vt], write: !0 } })], Qc.prototype, "fromColor", void 0), u([d({ type: Fe, json: { type: [Vt], write: !0 } })], Qc.prototype, "toColor", void 0), u([d({ type: ["algorithmic"] })], Qc.prototype, "type", void 0), Qc = xI = u([T("geoscene.rest.support.AlgorithmicColorRamp")], Qc);
const Rk = Qc;
var $I;
let Cy = $I = class extends Pk {
  constructor(e) {
    super(e), this.colorRamps = null, this.type = "multipart";
  }
  clone() {
    return new $I({ colorRamps: q(this.colorRamps) });
  }
};
u([d({ type: [Rk], json: { write: !0 } })], Cy.prototype, "colorRamps", void 0), u([d({ type: ["multipart"] })], Cy.prototype, "type", void 0), Cy = $I = u([T("geoscene.rest.support.MultipartColorRamp")], Cy);
const a7 = Cy, Gce = { key: "type", base: Pk, typeMap: { algorithmic: Rk, multipart: a7 } };
function Wce(e) {
  return e && e.type ? e.type === "algorithmic" ? Rk.fromJSON(e) : e.type === "multipart" ? a7.fromJSON(e) : null : null;
}
var TI;
const $c = new st({ esriClassifyDefinedInterval: "defined-interval", esriClassifyEqualInterval: "equal-interval", esriClassifyManual: "manual", esriClassifyNaturalBreaks: "natural-breaks", esriClassifyQuantile: "quantile", esriClassifyStandardDeviation: "standard-deviation" }), Av = new st({ classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density", flow: "flow" }), BL = new st({ classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density" }), UL = ["inches", "feet", "yards", "miles", "nautical-miles", "millimeters", "centimeters", "decimeters", "meters", "kilometers", "decimal-degrees"], Hce = ["high-to-low", "above-and-below", "above", "below", "90-10"], Jce = ["flow-line", "wave-front"], Zce = ["caret", "circle-caret", "arrow", "circle-arrow", "plus-minus", "circle-plus-minus", "square", "circle", "triangle", "happy-sad", "thumb", "custom"];
let In = TI = class extends se {
  constructor(e) {
    super(e), this.colorRamp = null, this.lengthUnit = null, this.maxSliderValue = null, this.minSliderValue = null, this.visualVariables = null;
  }
  get classificationMethod() {
    const e = this._get("classificationMethod"), t = this.type;
    return t && t !== "relationship" ? t === "class-breaks-size" || t === "class-breaks-color" ? e || "manual" : null : e;
  }
  set classificationMethod(e) {
    this._set("classificationMethod", e);
  }
  readColorRamp(e) {
    if (e)
      return Wce(e);
  }
  get fields() {
    return this.type && this.type !== "predominance" ? null : this._get("fields");
  }
  set fields(e) {
    this._set("fields", e);
  }
  get field1() {
    return this.type && this.type !== "relationship" ? null : this._get("field1");
  }
  set field1(e) {
    this._set("field1", e);
  }
  get field2() {
    return this.type && this.type !== "relationship" ? null : this._get("field2");
  }
  set field2(e) {
    this._set("field2", e);
  }
  get flowTheme() {
    return this.type === "flow" ? this._get("flowTheme") : null;
  }
  set flowTheme(e) {
    this._set("flowTheme", e);
  }
  get focus() {
    return this.type && this.type !== "relationship" ? null : this._get("focus");
  }
  set focus(e) {
    this._set("focus", e);
  }
  get numClasses() {
    return this.type && this.type !== "relationship" ? null : this._get("numClasses");
  }
  set numClasses(e) {
    this._set("numClasses", e);
  }
  get statistics() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("statistics") : null;
  }
  set statistics(e) {
    this._set("statistics", e);
  }
  get standardDeviationInterval() {
    const e = this.type;
    return e && e !== "relationship" && e !== "class-breaks-size" && e !== "class-breaks-color" || this.classificationMethod && this.classificationMethod !== "standard-deviation" ? null : this._get("standardDeviationInterval");
  }
  set standardDeviationInterval(e) {
    this._set("standardDeviationInterval", e);
  }
  get type() {
    return this._get("type");
  }
  set type(e) {
    let t = e;
    e === "classed-size" ? t = "class-breaks-size" : e === "classed-color" && (t = "class-breaks-color"), this._set("type", t);
  }
  get univariateSymbolStyle() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("univariateSymbolStyle") : null;
  }
  set univariateSymbolStyle(e) {
    this._set("univariateSymbolStyle", e);
  }
  get univariateTheme() {
    return this.type === "univariate-color-size" ? this._get("univariateTheme") : null;
  }
  set univariateTheme(e) {
    this._set("univariateTheme", e);
  }
  clone() {
    return new TI({ classificationMethod: this.classificationMethod, colorRamp: q(this.colorRamp), fields: this.fields && this.fields.slice(0), field1: q(this.field1), field2: q(this.field2), focus: this.focus, numClasses: this.numClasses, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, lengthUnit: this.lengthUnit, statistics: this.statistics, standardDeviationInterval: this.standardDeviationInterval, type: this.type, visualVariables: this.visualVariables && this.visualVariables.map((e) => e.clone()), univariateSymbolStyle: this.univariateSymbolStyle, univariateTheme: this.univariateTheme, flowTheme: this.flowTheme });
  }
};
u([d({ type: $c.apiValues, value: null, json: { type: $c.jsonValues, read: $c.read, write: $c.write, origins: { "web-document": { default: "manual", type: $c.jsonValues, read: $c.read, write: $c.write } } } })], In.prototype, "classificationMethod", null), u([d({ types: Gce, json: { write: !0 } })], In.prototype, "colorRamp", void 0), u([be("colorRamp")], In.prototype, "readColorRamp", null), u([d({ type: [String], value: null, json: { write: !0 } })], In.prototype, "fields", null), u([d({ type: NL, value: null, json: { write: !0 } })], In.prototype, "field1", null), u([d({ type: NL, value: null, json: { write: !0 } })], In.prototype, "field2", null), u([d({ type: Jce, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], In.prototype, "flowTheme", null), u([d({ type: ["HH", "HL", "LH", "LL"], value: null, json: { write: !0 } })], In.prototype, "focus", null), u([d({ type: Number, value: null, json: { type: Vt, write: !0 } })], In.prototype, "numClasses", null), u([d({ type: UL, json: { type: UL, read: !1, write: !1, origins: { "web-scene": { read: !0, write: !0 } } } })], In.prototype, "lengthUnit", void 0), u([d({ type: Number, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], In.prototype, "maxSliderValue", void 0), u([d({ type: Number, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], In.prototype, "minSliderValue", void 0), u([d({ type: Object, value: null, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], In.prototype, "statistics", null), u([d({ type: [0.25, 0.33, 0.5, 1], value: null, json: { type: [0.25, 0.33, 0.5, 1], write: !0 } })], In.prototype, "standardDeviationInterval", null), u([d({ type: Av.apiValues, value: null, json: { type: Av.jsonValues, read: Av.read, write: Av.write, origins: { "web-scene": { type: BL.jsonValues, write: { writer: BL.write, overridePolicy: (e) => ({ enabled: e !== "flow" }) } } } } })], In.prototype, "type", null), u([d({ type: [qce], json: { write: !0 } })], In.prototype, "visualVariables", void 0), u([d({ type: Zce, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], In.prototype, "univariateSymbolStyle", null), u([d({ type: Hce, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], In.prototype, "univariateTheme", null), In = TI = u([T("geoscene.renderers.support.AuthoringInfo")], In);
const Kce = In, fx = new st({ simple: "simple", uniqueValue: "unique-value", classBreaks: "class-breaks", heatmap: "heatmap", dotDensity: "dot-density", dictionary: "dictionary" }, { ignoreUnknown: !0 });
let Oy = class extends se {
  constructor(t) {
    super(t), this.authoringInfo = null, this.type = null;
  }
  async getRequiredFields(t) {
    if (!this.collectRequiredFields)
      return [];
    const n = /* @__PURE__ */ new Set();
    return await this.collectRequiredFields(n, t), Array.from(n).sort();
  }
  getSymbol(t, n) {
  }
  async getSymbolAsync(t, n) {
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return JSON.stringify(this);
  }
  getMeshHash() {
    return JSON.stringify(this);
  }
};
u([d({ type: Kce, json: { write: !0 } })], Oy.prototype, "authoringInfo", void 0), u([d({ type: fx.apiValues, readOnly: !0, json: { type: fx.jsonValues, read: !1, write: { writer: fx.write, ignoreOrigin: !0 } } })], Oy.prototype, "type", void 0), Oy = u([T("geoscene.renderers.Renderer")], Oy);
const vc = Oy;
var EI;
let aw = EI = class extends se {
  constructor() {
    super(...arguments), this.title = null;
  }
  clone() {
    return new EI({ title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], aw.prototype, "title", void 0), aw = EI = u([T("geoscene.renderers.support.LegendOptions")], aw);
const Lk = aw;
var II;
let lw = II = class extends Lk {
  constructor() {
    super(...arguments), this.showLegend = null;
  }
  clone() {
    return new II({ title: this.title, showLegend: this.showLegend });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], lw.prototype, "showLegend", void 0), lw = II = u([T("geoscene.renderers.visualVariables.support.VisualVariableLegendOptions")], lw);
const l7 = lw, Yce = we.getLogger("geoscene.renderers.visualVariables.VisualVariable"), mx = new st({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" });
let fo = class extends se {
  constructor(t) {
    super(t), this.index = null, this.type = null, this.field = null, this.valueExpression = null, this.valueExpressionTitle = null, this.legendOptions = null;
  }
  castField(t) {
    return t == null ? t : typeof t == "function" ? (Yce.error(".field: field must be a string value"), null) : v0(t);
  }
  get arcadeRequired() {
    return !!this.valueExpression;
  }
  clone() {
  }
  getAttributeHash() {
    return `${this.type}-${this.field}-${this.valueExpression}`;
  }
};
u([d()], fo.prototype, "index", void 0), u([d({ type: mx.apiValues, readOnly: !0, json: { read: mx.read, write: mx.write } })], fo.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], fo.prototype, "field", void 0), u([mt("field")], fo.prototype, "castField", null), u([d({ type: String, json: { write: !0 } })], fo.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], fo.prototype, "valueExpressionTitle", void 0), u([d({ readOnly: !0 })], fo.prototype, "arcadeRequired", null), u([d({ type: l7, json: { write: !0 } })], fo.prototype, "legendOptions", void 0), fo = u([T("geoscene.renderers.visualVariables.VisualVariable")], fo);
const D0 = fo;
var MI;
let Xc = MI = class extends se {
  constructor(e) {
    super(e), this.color = null, this.label = null, this.value = null;
  }
  writeValue(e, t, n) {
    t[n] = e ?? 0;
  }
  clone() {
    return new MI({ color: this.color && this.color.clone(), label: this.label, value: this.value });
  }
};
u([d({ type: Fe, json: { type: [Vt], write: !0 } })], Xc.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], Xc.prototype, "label", void 0), u([d({ type: Number, json: { write: { writerEnsuresNonNull: !0 } } })], Xc.prototype, "value", void 0), u([xe("value")], Xc.prototype, "writeValue", null), Xc = MI = u([T("geoscene.renderers.visualVariables.support.ColorStop")], Xc);
const Qce = Xc;
var CI;
let ed = CI = class extends D0 {
  constructor(e) {
    super(e), this.type = "color", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(e) {
    e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, n) => t.value - n.value), this._set("stops", e);
  }
  clone() {
    return new CI({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((e) => e.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], ed.prototype, "cache", null), u([d({ type: ["color"], json: { type: ["colorInfo"] } })], ed.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], ed.prototype, "normalizationField", void 0), u([d({ type: [Qce], json: { write: !0 } })], ed.prototype, "stops", null), ed = CI = u([T("geoscene.renderers.visualVariables.ColorVariable")], ed);
const u7 = ed;
var OI;
let yu = OI = class extends se {
  constructor(e) {
    super(e), this.label = null, this.opacity = null, this.value = null;
  }
  readOpacity(e, t) {
    return kg(t.transparency);
  }
  writeOpacity(e, t, n) {
    t[n] = hO(e);
  }
  clone() {
    return new OI({ label: this.label, opacity: this.opacity, value: this.value });
  }
};
u([d({ type: String, json: { write: !0 } })], yu.prototype, "label", void 0), u([d({ type: Number, json: { type: Vt, write: { target: "transparency" } } })], yu.prototype, "opacity", void 0), u([be("opacity", ["transparency"])], yu.prototype, "readOpacity", null), u([xe("opacity")], yu.prototype, "writeOpacity", null), u([d({ type: Number, json: { write: !0 } })], yu.prototype, "value", void 0), yu = OI = u([T("geoscene.renderers.visualVariables.support.OpacityStop")], yu);
const Xce = yu;
var kI;
let td = kI = class extends D0 {
  constructor(e) {
    super(e), this.type = "opacity", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(e) {
    e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, n) => t.value - n.value), this._set("stops", e);
  }
  clone() {
    return new kI({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((e) => e.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], td.prototype, "cache", null), u([d({ type: ["opacity"], json: { type: ["transparencyInfo"] } })], td.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], td.prototype, "normalizationField", void 0), u([d({ type: [Xce], json: { write: !0 } })], td.prototype, "stops", null), td = kI = u([T("geoscene.renderers.visualVariables.OpacityVariable")], td);
const c7 = td;
var AI;
let tl = AI = class extends D0 {
  constructor(e) {
    super(e), this.axis = null, this.type = "rotation", this.rotationType = "geographic", this.valueExpressionTitle = null;
  }
  get cache() {
    return { hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  writeValueExpressionTitleWebScene(e, t, n, r) {
    if (r && r.messages) {
      const i = `visualVariables[${this.index}]`;
      r.messages.push(new D("property:unsupported", this.type + "VisualVariable.valueExpressionTitle is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: i + ".valueExpressionTitle", context: r }));
    }
  }
  clone() {
    return new AI({ axis: this.axis, rotationType: this.rotationType, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
};
u([d({ readOnly: !0 })], tl.prototype, "cache", null), u([d({ type: ["heading", "tilt", "roll"], json: { origins: { "web-scene": { default: "heading", write: !0 } } } })], tl.prototype, "axis", void 0), u([d({ type: ["rotation"], json: { type: ["rotationInfo"] } })], tl.prototype, "type", void 0), u([d({ type: ["geographic", "arithmetic"], json: { write: !0, origins: { "web-document": { write: !0, default: "geographic" } } } })], tl.prototype, "rotationType", void 0), u([d({ type: String, json: { write: !0 } })], tl.prototype, "valueExpressionTitle", void 0), u([xe("web-scene", "valueExpressionTitle")], tl.prototype, "writeValueExpressionTitleWebScene", null), tl = AI = u([T("geoscene.renderers.visualVariables.RotationVariable")], tl);
const d7 = tl;
var PI;
let wh = PI = class extends se {
  constructor(e) {
    super(e), this.label = null, this.size = null, this.value = null;
  }
  clone() {
    return new PI({ label: this.label, size: this.size, value: this.value });
  }
};
u([d({ type: String, json: { write: !0 } })], wh.prototype, "label", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], wh.prototype, "size", void 0), u([d({ type: Number, json: { write: !0 } })], wh.prototype, "value", void 0), wh = PI = u([T("geoscene.renderers.visualVariables.support.SizeStop")], wh);
const ede = wh;
var RI;
let uw = RI = class extends l7 {
  constructor() {
    super(...arguments), this.customValues = null;
  }
  clone() {
    return new RI({ title: this.title, showLegend: this.showLegend, customValues: this.customValues && this.customValues.slice(0) });
  }
};
u([d({ type: [Number], json: { write: !0 } })], uw.prototype, "customValues", void 0), uw = RI = u([T("geoscene.renderers.visualVariables.support.SizeVariableLegendOptions")], uw);
const tde = uw;
var El, Qn;
function Gh(e) {
  return e && e.declaredClass === "geoscene.renderers.visualVariables.SizeVariable";
}
function Jg(e) {
  return e != null && !isNaN(e) && isFinite(e);
}
function p7(e) {
  return e.valueExpression ? El.Expression : e.field && typeof e.field == "string" ? El.Field : El.Unknown;
}
function nde(e, t) {
  const n = t || p7(e), r = e.valueUnit || "unknown";
  return n === El.Unknown ? Qn.Constant : e.stops ? Qn.Stops : e.minSize != null && e.maxSize != null && e.minDataValue != null && e.maxDataValue != null ? Qn.ClampedLinear : r === "unknown" ? e.minSize != null && e.minDataValue != null ? e.minSize && e.minDataValue ? Qn.Proportional : Qn.Additive : Qn.Identity : Qn.RealWorldSize;
}
(function(e) {
  e.Unknown = "unknown", e.Expression = "expression", e.Field = "field";
})(El || (El = {})), function(e) {
  e.Unknown = "unknown", e.Stops = "stops", e.ClampedLinear = "clamped-linear", e.Proportional = "proportional", e.Additive = "additive", e.Constant = "constant", e.Identity = "identity", e.RealWorldSize = "real-world-size";
}(Qn || (Qn = {}));
const h7 = { inches: xs(1, "meters", "inches"), feet: xs(1, "meters", "feet"), "us-feet": xs(1, "meters", "us-feet"), yards: xs(1, "meters", "yards"), miles: xs(1, "meters", "miles"), "nautical-miles": xs(1, "meters", "nautical-miles"), millimeters: xs(1, "meters", "millimeters"), centimeters: xs(1, "meters", "centimeters"), decimeters: xs(1, "meters", "decimeters"), meters: xs(1, "meters", "meters"), kilometers: xs(1, "meters", "kilometers"), "decimal-degrees": 1 / Ote(1, "meters", Kt.radius) }, oc = we.getLogger("geoscene.renderers.visualVariables.support.visualVariableUtils"), qL = new Jt(), cw = Math.PI, f7 = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function m7(e, t, n) {
  const r = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((g) => g.type === "color") : e;
  if (!r)
    return;
  if (r.declaredClass !== "geoscene.renderers.visualVariables.ColorVariable")
    return void oc.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.ColorVariable");
  const i = typeof t == "number", s = i ? null : t, o = s && s.attributes;
  let a = i ? t : null;
  const l = r.field, { ipData: c, hasExpression: p } = r.cache;
  let f = r.cache.compiledFunc;
  if (!l && !p) {
    const g = r.stops;
    return g && g[0] && g[0].color;
  }
  if (typeof a != "number")
    if (p) {
      if (!O(n) || !O(n.arcade))
        return void oc.error("Use of arcade expressions requires an arcade context");
      const g = { viewingMode: n.viewingMode, scale: n.scale, spatialReference: n.spatialReference }, v = n.arcade.arcadeUtils, w = v.getViewInfo(g), b = v.createExecContext(s, w);
      if (!f) {
        const S = v.createSyntaxTree(r.valueExpression);
        f = v.createFunction(S), r.cache.compiledFunc = f;
      }
      a = v.executeFunction(f, b);
    } else
      o && (a = o[l]);
  const m = r.normalizationField, y = o ? parseFloat(o[m]) : void 0;
  if (a != null && (!m || i || !isNaN(y) && y !== 0)) {
    isNaN(y) || i || (a /= y);
    const g = Fk(a, c);
    if (g) {
      const v = g[0], w = g[1], b = v === w ? r.stops[v].color : Fe.blendColors(r.stops[v].color, r.stops[w].color, g[2], O(n) ? n.color : void 0);
      return new Fe(b);
    }
  }
}
function y7(e, t, n) {
  const r = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((g) => g.type === "opacity") : e;
  if (!r)
    return;
  if (r.declaredClass !== "geoscene.renderers.visualVariables.OpacityVariable")
    return void oc.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.OpacityVariable");
  const i = typeof t == "number", s = i ? null : t, o = s && s.attributes;
  let a = i ? t : null;
  const l = r.field, { ipData: c, hasExpression: p } = r.cache;
  let f = r.cache.compiledFunc;
  if (!l && !p) {
    const g = r.stops;
    return g && g[0] && g[0].opacity;
  }
  if (typeof a != "number")
    if (p) {
      if (H(n) || H(n.arcade))
        return void oc.error("Use of arcade expressions requires an arcade context");
      const g = { viewingMode: n.viewingMode, scale: n.scale, spatialReference: n.spatialReference }, v = n.arcade.arcadeUtils, w = v.getViewInfo(g), b = v.createExecContext(s, w);
      if (!f) {
        const S = v.createSyntaxTree(r.valueExpression);
        f = v.createFunction(S), r.cache.compiledFunc = f;
      }
      a = v.executeFunction(f, b);
    } else
      o && (a = o[l]);
  const m = r.normalizationField, y = o ? parseFloat(o[m]) : void 0;
  if (a != null && (!m || i || !isNaN(y) && y !== 0)) {
    isNaN(y) || i || (a /= y);
    const g = Fk(a, c);
    if (g) {
      const v = g[0], w = g[1];
      if (v === w)
        return r.stops[v].opacity;
      {
        const b = r.stops[v].opacity;
        return b + (r.stops[w].opacity - b) * g[2];
      }
    }
  }
}
function g7(e, t, n) {
  const r = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((y) => y.type === "rotation") : e;
  if (!r)
    return;
  if (r.declaredClass !== "geoscene.renderers.visualVariables.RotationVariable")
    return void oc.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.RotationVariable");
  const i = r.axis || "heading", s = i === "heading" && r.rotationType === "arithmetic" ? 90 : 0, o = i === "heading" && r.rotationType === "arithmetic" ? -1 : 1, a = typeof t == "number" ? null : t, l = a && a.attributes, c = r.field, { hasExpression: p } = r.cache;
  let f = r.cache.compiledFunc, m = 0;
  if (!c && !p)
    return m;
  if (p) {
    if (H(n) || H(n.arcade))
      return void oc.error("Use of arcade expressions requires an arcade context");
    const y = { viewingMode: n.viewingMode, scale: n.scale, spatialReference: n.spatialReference }, g = n.arcade.arcadeUtils, v = g.getViewInfo(y), w = g.createExecContext(a, v);
    if (!f) {
      const b = g.createSyntaxTree(r.valueExpression);
      f = g.createFunction(b), r.cache.compiledFunc = f;
    }
    m = g.executeFunction(f, w);
  } else
    l && (m = l[c] || 0);
  return m = typeof m != "number" || isNaN(m) ? null : s + o * m, m;
}
function rde(e, t, n) {
  const r = typeof t == "number", i = r ? null : t, s = i && i.attributes;
  let o = r ? t : null;
  const { isScaleDriven: a } = e.cache;
  let l = e.cache.compiledFunc;
  if (a) {
    const p = O(n) ? n.scale : void 0, f = O(n) ? n.view : void 0;
    o = p == null || f === "3d" ? ide(e) : p;
  } else if (!r)
    switch (e.inputValueType) {
      case El.Expression: {
        if (H(n) || H(n.arcade))
          return void oc.error("Use of arcade expressions requires an arcade context");
        const p = { viewingMode: n.viewingMode, scale: n.scale, spatialReference: n.spatialReference }, f = n.arcade.arcadeUtils, m = f.getViewInfo(p), y = f.createExecContext(i, m);
        if (!l) {
          const g = f.createSyntaxTree(e.valueExpression);
          l = f.createFunction(g), e.cache.compiledFunc = l;
        }
        o = f.executeFunction(l, y);
        break;
      }
      case El.Field:
        s && (o = s[e.field]);
        break;
      case El.Unknown:
        o = null;
    }
  if (!Jg(o))
    return null;
  if (r || !e.normalizationField)
    return o;
  const c = s ? parseFloat(s[e.normalizationField]) : null;
  return Jg(c) && c !== 0 ? o / c : null;
}
function ide(e) {
  let t = null, n = null;
  const r = e.stops;
  return r ? (t = r[0].value, n = r[r.length - 1].value) : (t = e.minDataValue || 0, n = e.maxDataValue || 0), (t + n) / 2;
}
function CS(e, t, n) {
  const r = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((s) => s.type === "size") : e;
  if (!r)
    return;
  if (r.declaredClass !== "geoscene.renderers.visualVariables.SizeVariable")
    return void oc.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.SizeVariable");
  const i = b7(rde(r, t, n), r, t, n, r.cache.ipData);
  return i == null || isNaN(i) ? 0 : i;
}
function xi(e, t, n) {
  return e == null ? null : Gh(e) ? CS(e, t, n) : Jg(e) ? e : null;
}
function v7(e, t, n) {
  return Jg(n) && e > n ? n : Jg(t) && e < t ? t : e;
}
function sde(e, t, n, r) {
  return e + (xi(t.minSize, n, r) || t.minDataValue);
}
function ode(e, t, n) {
  const r = e.stops;
  let i = r && r.length && r[0].size;
  return i == null && (i = e.minSize), xi(i, t, n);
}
function ade(e, t, n, r) {
  const i = (e - t.minDataValue) / (t.maxDataValue - t.minDataValue), s = xi(t.minSize, n, r), o = xi(t.maxSize, n, r), a = O(r) ? r.shape : void 0;
  if (e <= t.minDataValue)
    return s;
  if (e >= t.maxDataValue)
    return o;
  if (t.scaleBy === "area" && a) {
    const l = a === "circle", c = l ? cw * (s / 2) ** 2 : s * s, p = c + i * ((l ? cw * (o / 2) ** 2 : o * o) - c);
    return l ? 2 * Math.sqrt(p / cw) : Math.sqrt(p);
  }
  return s + i * (o - s);
}
function lde(e, t, n, r) {
  const i = O(r) ? r.shape : void 0, s = e / t.minDataValue, o = xi(t.minSize, n, r), a = xi(t.maxSize, n, r);
  let l = null;
  return l = i === "circle" ? 2 * Math.sqrt(s * (o / 2) ** 2) : i === "square" || i === "diamond" || i === "image" ? Math.sqrt(s * o ** 2) : s * o, v7(l, o, a);
}
function ude(e, t, n, r, i) {
  const [s, o, a] = Fk(e, i);
  if (s === o)
    return xi(t.stops[s].size, n, r);
  {
    const l = xi(t.stops[s].size, n, r);
    return l + (xi(t.stops[o].size, n, r) - l) * a;
  }
}
function cde(e, t, n, r) {
  const i = (O(r) && r.resolution ? r.resolution : 1) * h7[t.valueUnit], s = xi(t.minSize, n, r), o = xi(t.maxSize, n, r), { valueRepresentation: a } = t;
  let l = null;
  return l = a === "area" ? 2 * Math.sqrt(e / cw) / i : a === "radius" || a === "distance" ? 2 * e / i : e / i, v7(l, s, o);
}
function b7(e, t, n, r, i) {
  switch (t.transformationType) {
    case Qn.Additive:
      return sde(e, t, n, r);
    case Qn.Constant:
      return ode(t, n, r);
    case Qn.ClampedLinear:
      return ade(e, t, n, r);
    case Qn.Proportional:
      return lde(e, t, n, r);
    case Qn.Stops:
      return ude(e, t, n, r, i);
    case Qn.RealWorldSize:
      return cde(e, t, n, r);
    case Qn.Identity:
      return e;
    case Qn.Unknown:
      return null;
  }
}
function dde(e, t, n) {
  const { isScaleDriven: r } = e.cache;
  if (!(r && n === "3d" || t))
    return null;
  const i = { scale: t, view: n };
  let s = xi(e.minSize, qL, i), o = xi(e.maxSize, qL, i);
  if (s != null || o != null) {
    if (s > o) {
      const a = o;
      o = s, s = a;
    }
    return { minSize: s, maxSize: o };
  }
}
function pde(e, t, n) {
  if (!e.visualVariables)
    return;
  const r = [], i = [], s = [], o = [], a = [];
  for (const l of e.visualVariables)
    switch (l.type) {
      case "color":
        i.push(l);
        break;
      case "opacity":
        s.push(l);
        break;
      case "rotation":
        a.push(l);
        break;
      case "size":
        o.push(l);
    }
  return i.forEach((l) => {
    const c = m7(l, t, n);
    r.push({ variable: l, value: c });
  }), s.forEach((l) => {
    const c = y7(l, t, n);
    r.push({ variable: l, value: c });
  }), a.forEach((l) => {
    const c = g7(l, t, n);
    r.push({ variable: l, value: c });
  }), o.forEach((l) => {
    const c = CS(l, t, n);
    r.push({ variable: l, value: c });
  }), r.filter((l) => l.value != null);
}
function Fk(e, t) {
  if (!t)
    return;
  let n = 0, r = t.length - 1;
  return t.some((i, s) => e < i ? (r = s, !0) : (n = s, !1)), [n, r, (e - t[n]) / (t[r] - t[n])];
}
function hde(e, t, n) {
  const r = ["proportional", "proportional", "proportional"];
  for (const i of e) {
    const s = i.useSymbolValue ? "symbol-value" : CS(i, t, n);
    switch (i.axis) {
      case "width":
        r[0] = s;
        break;
      case "depth":
        r[1] = s;
        break;
      case "height":
        r[2] = s;
        break;
      case "width-and-depth":
        r[0] = s, r[1] = s;
        break;
      case "all":
      case void 0:
      case null:
        r[0] = s, r[1] = s, r[2] = s;
        break;
      default:
        i.axis;
    }
  }
  return r;
}
const fde = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAllSizes: hde,
  getColor: m7,
  getOpacity: y7,
  getRotationAngle: g7,
  getSize: CS,
  getSizeForValue: b7,
  getSizeFromNumberOrVariable: xi,
  getSizeRangeAtScale: dde,
  getVisualVariableValues: pde,
  viewScaleRE: f7
}, Symbol.toStringTag, { value: "Module" }));
var LI;
const Up = we.getLogger("geoscene.renderers.visualVariables.SizeVariable"), Pv = new st({ width: "width", depth: "depth", height: "height", widthAndDepth: "width-and-depth", all: "all" }), FI = new st({ unknown: "unknown", inch: "inches", foot: "feet", yard: "yards", mile: "miles", "nautical-mile": "nautical-miles", millimeter: "millimeters", centimeter: "centimeters", decimeter: "decimeters", meter: "meters", kilometer: "kilometers", "decimal-degree": "decimal-degrees" });
function GL(e) {
  if (e != null)
    return typeof e == "string" || typeof e == "number" ? $t(e) : e.type === "size" ? Gh(e) ? e : (delete (e = { ...e }).type, new _t(e)) : void 0;
}
function WL(e, t, n) {
  if (typeof e != "object")
    return e;
  const r = new _t();
  return r.read(e, n), r;
}
let _t = LI = class extends D0 {
  constructor(e) {
    super(e), this.axis = null, this.legendOptions = null, this.normalizationField = null, this.scaleBy = null, this.target = null, this.type = "size", this.useSymbolValue = null, this.valueExpression = null, this.valueRepresentation = null, this.valueUnit = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null, isScaleDriven: f7.test(this.valueExpression) };
  }
  set expression(e) {
    Up.warn("'expression' is deprecated since version 4.2. Use 'valueExpression' instead. The only supported expression is 'view.scale'."), e === "view.scale" ? (this.valueExpression = "$view.scale", this._set("expression", e)) : this._set("expression", null);
  }
  set index(e) {
    Gh(this.maxSize) && (this.maxSize.index = `visualVariables[${e}].maxSize`), Gh(this.minSize) && (this.minSize.index = `visualVariables[${e}].minSize`), this._set("index", e);
  }
  get inputValueType() {
    return p7(this);
  }
  set maxDataValue(e) {
    e && this.stops && (Up.warn("cannot set maxDataValue when stops is not null."), e = null), this._set("maxDataValue", e);
  }
  set maxSize(e) {
    e && this.stops && (Up.warn("cannot set maxSize when stops is not null."), e = null), this._set("maxSize", e);
  }
  castMaxSize(e) {
    return GL(e);
  }
  readMaxSize(e, t, n) {
    return WL(e, t, n);
  }
  set minDataValue(e) {
    e && this.stops && (Up.warn("cannot set minDataValue when stops is not null."), e = null), this._set("minDataValue", e);
  }
  set minSize(e) {
    e && this.stops && (Up.warn("cannot set minSize when stops is not null."), e = null), this._set("minSize", e);
  }
  castMinSize(e) {
    return GL(e);
  }
  readMinSize(e, t, n) {
    return WL(e, t, n);
  }
  get arcadeRequired() {
    return !!this.valueExpression || this.minSize && typeof this.minSize == "object" && this.minSize.arcadeRequired || this.maxSize && typeof this.maxSize == "object" && this.maxSize.arcadeRequired;
  }
  set stops(e) {
    this.minDataValue == null && this.maxDataValue == null && this.minSize == null && this.maxSize == null ? e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, n) => t.value - n.value) : e && (Up.warn("cannot set stops when one of minDataValue, maxDataValue, minSize or maxSize is not null."), e = null), this._set("stops", e);
  }
  get transformationType() {
    return nde(this, this.inputValueType);
  }
  readValueExpression(e, t) {
    return e || t.expression && "$view.scale";
  }
  writeValueExpressionWebScene(e, t, n, r) {
    if (e === "$view.scale") {
      if (r && r.messages) {
        const i = this.index, s = typeof i == "string" ? i : `visualVariables[${i}]`;
        r.messages.push(new D("property:unsupported", this.type + "VisualVariable.valueExpression = '$view.scale' is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: s + ".valueExpression", context: r }));
      }
    } else
      t[n] = e;
  }
  readValueUnit(e) {
    return e ? FI.read(e) : null;
  }
  clone() {
    return new LI({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: Gh(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: Gh(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e) => e.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  flipSizes() {
    if (this.transformationType === Qn.ClampedLinear) {
      const { minSize: e, maxSize: t } = this;
      return this.minSize = t, this.maxSize = e, this;
    }
    if (this.transformationType === Qn.Stops) {
      const e = this.stops, t = e.map((r) => r.size).reverse(), n = e.length;
      for (let r = 0; r < n; r++)
        e[r].size = t[r];
      return this;
    }
    return this;
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.target}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], _t.prototype, "cache", null), u([d({ type: Pv.apiValues, json: { type: Pv.jsonValues, origins: { "web-map": { read: !1 } }, read: Pv.read, write: Pv.write } })], _t.prototype, "axis", void 0), u([d({ type: String, value: null, json: { read: !1 } })], _t.prototype, "expression", null), u([d()], _t.prototype, "index", null), u([d({ type: String, readOnly: !0 })], _t.prototype, "inputValueType", null), u([d({ type: tde, json: { write: !0 } })], _t.prototype, "legendOptions", void 0), u([d({ type: Number, value: null, json: { write: !0 } })], _t.prototype, "maxDataValue", null), u([d({ type: Number, value: null, json: { write: !0 } })], _t.prototype, "maxSize", null), u([mt("maxSize")], _t.prototype, "castMaxSize", null), u([be("maxSize")], _t.prototype, "readMaxSize", null), u([d({ type: Number, value: null, json: { write: !0 } })], _t.prototype, "minDataValue", null), u([d({ type: Number, value: null, json: { write: !0 } })], _t.prototype, "minSize", null), u([mt("minSize")], _t.prototype, "castMinSize", null), u([be("minSize")], _t.prototype, "readMinSize", null), u([d({ type: String, json: { write: !0 } })], _t.prototype, "normalizationField", void 0), u([d({ readOnly: !0 })], _t.prototype, "arcadeRequired", null), u([d({ type: String })], _t.prototype, "scaleBy", void 0), u([d({ type: [ede], value: null, json: { write: !0 } })], _t.prototype, "stops", null), u([d({ type: ["outline"], json: { write: !0 } })], _t.prototype, "target", void 0), u([d({ type: String, readOnly: !0 })], _t.prototype, "transformationType", null), u([d({ type: ["size"], json: { type: ["sizeInfo"] } })], _t.prototype, "type", void 0), u([d({ type: Boolean, json: { write: !0, origins: { "web-map": { read: !1 } } } })], _t.prototype, "useSymbolValue", void 0), u([d({ type: String, json: { write: !0 } })], _t.prototype, "valueExpression", void 0), u([be("valueExpression", ["valueExpression", "expression"])], _t.prototype, "readValueExpression", null), u([xe("web-scene", "valueExpression")], _t.prototype, "writeValueExpressionWebScene", null), u([d({ type: ["radius", "diameter", "area", "width", "distance"], json: { write: !0 } })], _t.prototype, "valueRepresentation", void 0), u([d({ type: FI.apiValues, json: { write: FI.write, origins: { "web-map": { read: !1 }, "web-scene": { write: !0 } } } })], _t.prototype, "valueUnit", void 0), u([be("valueUnit")], _t.prototype, "readValueUnit", null), _t = LI = u([T("geoscene.renderers.visualVariables.SizeVariable")], _t);
const w7 = _t, mde = we.getLogger("geoscene.renderers.visualVariables.VisualVariableFactory"), yde = { color: u7, size: w7, opacity: c7, rotation: d7 }, gde = new st({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" }), vde = /^\[([^\]]+)\]$/i;
let dw = class extends ke {
  constructor() {
    super(...arguments), this.colorVariables = null, this.opacityVariables = null, this.rotationVariables = null, this.sizeVariables = null;
  }
  set visualVariables(t) {
    if (this._resetVariables(), (t = t && t.filter((n) => !!n)) && t.length) {
      for (const n of t)
        switch (n.type) {
          case "color":
            this.colorVariables.push(n);
            break;
          case "opacity":
            this.opacityVariables.push(n);
            break;
          case "rotation":
            this.rotationVariables.push(n);
            break;
          case "size":
            this.sizeVariables.push(n);
        }
      this.sizeVariables.length && this.sizeVariables.some((n) => !!n.target) && t.sort((n, r) => {
        let i = null;
        return i = n.target === r.target ? 0 : n.target ? 1 : -1, i;
      });
      for (let n = 0; n < t.length; n++)
        t[n].index = n;
      this._set("visualVariables", t);
    } else
      this._set("visualVariables", t);
  }
  readVariables(t, n, r) {
    const { rotationExpression: i, rotationType: s } = n, o = i && i.match(vde), a = o && o[1];
    if (a && (t || (t = []), t.push({ type: "rotationInfo", rotationType: s, field: a })), t)
      return t.map((l) => {
        const c = gde.read(l.type), p = yde[c];
        p || (mde.warn(`Unknown variable type: ${c}`), r && r.messages && r.messages.push(new Ds("visual-variable:unsupported", `visualVariable of type '${c}' is not supported`, { definition: l, context: r })));
        const f = new p();
        return f.read(l, r), f;
      });
  }
  writeVariables(t, n) {
    const r = [];
    for (const i of t) {
      const s = i.toJSON(n);
      s && r.push(s);
    }
    return r;
  }
  _resetVariables() {
    this.colorVariables = [], this.opacityVariables = [], this.rotationVariables = [], this.sizeVariables = [];
  }
};
u([d()], dw.prototype, "visualVariables", null), dw = u([T("geoscene.renderers.visualVariables.VisualVariableFactory")], dw);
const bde = dw, wde = { base: D0, key: "type", typeMap: { opacity: c7, color: u7, rotation: d7, size: w7 } }, j0 = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this._vvFactory = new bde();
    }
    set visualVariables(n) {
      this._vvFactory.visualVariables = n, this._set("visualVariables", this._vvFactory.visualVariables);
    }
    readVisualVariables(n, r, i) {
      return this._vvFactory.readVariables(n, r, i);
    }
    writeVisualVariables(n, r, i, s) {
      r[i] = this._vvFactory.writeVariables(n, s);
    }
    get arcadeRequiredForVisualVariables() {
      if (!this.visualVariables)
        return !1;
      for (const n of this.visualVariables)
        if (n.arcadeRequired)
          return !0;
      return !1;
    }
    hasVisualVariables(n, r) {
      return n ? this.getVisualVariablesForType(n, r).length > 0 : this.getVisualVariablesForType("size", r).length > 0 || this.getVisualVariablesForType("color", r).length > 0 || this.getVisualVariablesForType("opacity", r).length > 0 || this.getVisualVariablesForType("rotation", r).length > 0;
    }
    getVisualVariablesForType(n, r) {
      const i = this.visualVariables;
      return i ? i.filter((s) => s.type === n && (typeof r == "string" ? s.target === r : r !== !1 || !s.target)) : [];
    }
    async collectVVRequiredFields(n, r) {
      let i = [];
      this.visualVariables && (i = i.concat(this.visualVariables));
      for (const s of i)
        s && (s.field && Fs(n, r, s.field), s.normalizationField && Fs(n, r, s.normalizationField), s.valueExpression && await as(n, r, s.valueExpression));
    }
  };
  return u([d({ types: [wde], value: null, json: { write: !0 } })], t.prototype, "visualVariables", null), u([be("visualVariables", ["visualVariables", "rotationType", "rotationExpression"])], t.prototype, "readVisualVariables", null), u([xe("visualVariables")], t.prototype, "writeVisualVariables", null), t = u([T("geoscene.renderers.mixins.VisualVariablesMixin")], t), t;
}, Rm = { retainId: !1, ignoreDrivers: !1, hasLabelingContext: !0 };
function _de(e, t = Rm) {
  if (!e)
    return { symbol: null };
  const { retainId: n = Rm.retainId, ignoreDrivers: r = Rm.ignoreDrivers, hasLabelingContext: i = Rm.hasLabelingContext, retainCIM: s = Rm.retainCIM } = t;
  let o;
  if (Dg(e) || e instanceof Mp)
    o = e.clone();
  else if (e.type === "cim") {
    var a, l;
    const c = (a = e.data) == null || (l = a.symbol) == null ? void 0 : l.type;
    if (c !== "CIMPointSymbol")
      return { error: new D("symbol-conversion:unsupported-cim-symbol", `CIM symbol of type '${c || "unknown"}' is unsupported in 3D`, { symbol: e }) };
    o = s ? e.clone() : $d.fromCIMSymbol(e);
  } else if (e instanceof Hs)
    o = pS.fromSimpleLineSymbol(e);
  else if (e instanceof Yf)
    o = $d.fromSimpleMarkerSymbol(e);
  else if (e instanceof hS)
    o = $d.fromPictureMarkerSymbol(e);
  else if (e instanceof Ip)
    o = T0.fromSimpleFillSymbol(e);
  else {
    if (!(e instanceof Ro))
      return { error: new D("symbol-conversion:unsupported-2d-symbol", `2D symbol of type '${e.type || e.declaredClass}' is unsupported in 3D`, { symbol: e }) };
    o = i ? dS.fromTextSymbol(e) : $d.fromTextSymbol(e);
  }
  if (n && o.type !== "cim" && (o.id = e.id), r && Dg(o))
    for (let c = 0; c < o.symbolLayers.length; ++c)
      o.symbolLayers.getItemAt(c)._ignoreDrivers = !0;
  return { symbol: o };
}
function t_(e, t, n, r) {
  const i = _7(e, {}, { context: r, isLabelSymbol: !1 });
  O(i) && (t[n] = i);
}
function HL(e, t, n, r) {
  const i = _7(e, {}, { context: r, isLabelSymbol: !0 });
  O(i) && (t[n] = i);
}
function _7(e, t, n) {
  if (H(e))
    return null;
  const { context: r, isLabelSymbol: i } = n;
  if (r && r.origin === "web-scene" && !(e instanceof Kf) && !(e instanceof Mp)) {
    const s = _de(e, { retainCIM: !0, hasLabelingContext: i });
    return O(s.symbol) ? s.symbol.write(t, r) : (r.messages && r.messages.push(new D("symbol:unsupported", `Symbols of type '${e.declaredClass}' are not supported in scenes. Use 3D symbology instead when working with WebScene and SceneView`, { symbol: e, context: r, error: s.error })), null);
  }
  return r && r.origin === "web-map" && e.type === "web-style" ? (r.messages && r.messages.push(new D("symbol:unsupported", `Symbols of type '${e.declaredClass}' are not supported in webmaps. Use CIMSymbol instead when working with WebMap in MapView.`, { symbol: e, context: r })), null) : e.write(t, r);
}
function bFe(e, t) {
  return Vee(e, null, t);
}
const V0 = { types: Ij, json: { write: { writer: t_ }, origins: { "web-scene": { types: MP, write: { writer: t_ }, read: { reader: zf({ types: MP }) } } } } }, S7 = { types: { base: ki, key: "type", typeMap: { "simple-fill": Ud.typeMap["simple-fill"], "picture-fill": Ud.typeMap["picture-fill"], "polygon-3d": Ud.typeMap["polygon-3d"] } }, json: { write: { writer: t_ }, origins: { "web-scene": { type: T0, write: { writer: t_ } } } } };
var NI;
let gu = NI = class extends se {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new NI({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const e = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${e}`;
  }
};
u([d({ type: String, json: { write: !0 } })], gu.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], gu.prototype, "label", void 0), u([d({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], gu.prototype, "minValue", void 0), u([d({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], gu.prototype, "maxValue", void 0), u([d(V0)], gu.prototype, "symbol", void 0), gu = NI = u([T("geoscene.renderers.support.ClassBreakInfo")], gu);
const n_ = gu;
var DI;
const Rv = we.getLogger("geoscene.renderers.ClassBreaksRenderer"), x7 = "log", pw = "percent-of-total", hw = "field", Lv = new st({ esriNormalizeByLog: x7, esriNormalizeByPercentOfTotal: pw, esriNormalizeByField: hw }), Sde = kn(n_);
let Nn = DI = class extends j0(vc) {
  constructor(e) {
    super(e), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = !0, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e, t, n) {
    if (!Array.isArray(e))
      return;
    let r = t.minValue;
    return e.map((i) => {
      const s = new n_();
      return s.read(i, n), s.minValue == null && (s.minValue = r), s.maxValue == null && (s.maxValue = s.minValue), r = s.maxValue, s;
    });
  }
  writeClassBreakInfos(e, t, n, r) {
    const i = e.map((s) => s.write({}, r));
    this._areClassBreaksConsecutive() && i.forEach((s) => delete s.classMinValue), t[n] = i;
  }
  castField(e) {
    return e == null ? e : typeof e == "function" ? (Rv.error(".field: field must be a string value"), null) : v0(e);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e = this._get("normalizationType");
    const t = !!this.normalizationField, n = this.normalizationTotal != null;
    return t || n ? (e = t && hw || n && pw || null, t && n && Rv.warn("warning: both normalizationField and normalizationTotal are set!")) : e !== hw && e !== pw || (e = null), e;
  }
  set normalizationType(e) {
    this._set("normalizationType", e);
  }
  addClassBreakInfo(e, t, n) {
    let r = null;
    r = typeof e == "number" ? new n_({ minValue: e, maxValue: t, symbol: Mj(n) }) : Sde(q(e)), this.classBreakInfos.push(r), this.classBreakInfos.length === 1 && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e, t) {
    const n = this.classBreakInfos.length;
    for (let r = 0; r < n; r++) {
      const i = [this.classBreakInfos[r].minValue, this.classBreakInfos[r].maxValue];
      if (i[0] === e && i[1] === t) {
        this.classBreakInfos.splice(r, 1);
        break;
      }
    }
  }
  getBreakIndex(e, t) {
    return this.valueExpression && (H(t) || H(t.arcade)) && Rv.warn(""), this.valueExpression ? this._getBreakIndexForExpression(e, t) : this._getBreakIndexForField(e);
  }
  async getClassBreakInfo(e, t) {
    let n = t;
    this.valueExpression && (H(t) || H(t.arcade)) && (n = { ...n, arcade: await kl() });
    const r = this.getBreakIndex(e, n);
    return r !== -1 ? this.classBreakInfos[r] : null;
  }
  getSymbol(e, t) {
    if (this.valueExpression && (H(t) || H(t.arcade)))
      return void Rv.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const n = this.getBreakIndex(e, t);
    return n > -1 ? this.classBreakInfos[n].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e, t) {
    let n = t;
    if (this.valueExpression && (H(t) || H(t.arcade))) {
      const i = await kl(), { arcadeUtils: s } = i;
      s.hasGeometryOperations(this.valueExpression) && await s.enableGeometryOperations(), n = { ...n, arcade: i };
    }
    const r = this.getBreakIndex(e, n);
    return r > -1 ? this.classBreakInfos[r].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e = [];
    return this.classBreakInfos.forEach((t) => {
      t.symbol && e.push(t.symbol);
    }), this.defaultSymbol && e.push(this.defaultSymbol), e;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    const e = JSON.stringify(this.backgroundFillSymbol), t = JSON.stringify(this.defaultSymbol), n = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e}.${t}.${this.classBreakInfos.reduce((r, i) => r + i.getMeshHash(), "")}.${n}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    return new DI({ field: this.field, backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(), defaultLabel: this.defaultLabel, defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: q(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: q(this.visualVariables), legendOptions: q(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e, t) {
    const n = [this.collectVVRequiredFields(e, t), this.collectSymbolFields(e, t)];
    await Promise.all(n);
  }
  async collectSymbolFields(e, t) {
    const n = [...this.getSymbols().map((r) => r.collectRequiredFields(e, t)), as(e, t, this.valueExpression)];
    Fs(e, t, this.field), Fs(e, t, this.normalizationField), await Promise.all(n);
  }
  _getBreakIndexForExpression(e, t) {
    const { viewingMode: n, scale: r, spatialReference: i, arcade: s } = BC(t, {});
    let o = this._compiledValueExpression.valueExpression === this.valueExpression ? this._compiledValueExpression.compiledFunction : null;
    const a = s.arcadeUtils;
    if (!o) {
      const c = a.createSyntaxTree(this.valueExpression);
      o = a.createFunction(c), this._compiledValueExpression.compiledFunction = o;
    }
    this._compiledValueExpression.valueExpression = this.valueExpression;
    const l = a.executeFunction(o, a.createExecContext(e, a.getViewInfo({ viewingMode: n, scale: r, spatialReference: i })));
    return this._getBreakIndexfromInfos(l);
  }
  _getBreakIndexForField(e) {
    const t = this.field, n = e.attributes, r = this.normalizationType;
    let i = parseFloat(n[t]);
    if (r) {
      const s = this.normalizationTotal, o = parseFloat(n[this.normalizationField]);
      if (r === x7)
        i = Math.log(i) * Math.LOG10E;
      else if (r !== pw || isNaN(s)) {
        if (r === hw && !isNaN(o)) {
          if (isNaN(i) || isNaN(o))
            return -1;
          i /= o;
        }
      } else
        i = i / s * 100;
    }
    return this._getBreakIndexfromInfos(i);
  }
  _getBreakIndexfromInfos(e) {
    const t = this.isMaxInclusive;
    if (e != null && typeof e == "number" && !isNaN(e))
      for (let n = 0; n < this.classBreakInfos.length; n++) {
        const r = [this.classBreakInfos[n].minValue, this.classBreakInfos[n].maxValue];
        if (r[0] <= e && (t ? e <= r[1] : e < r[1]))
          return n;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e = this.classBreakInfos, t = e.length;
    for (let n = 1; n < t; n++)
      if (e[n - 1].maxValue !== e[n].minValue)
        return !1;
    return !0;
  }
};
u([d(S7)], Nn.prototype, "backgroundFillSymbol", void 0), u([d({ type: [n_] })], Nn.prototype, "classBreakInfos", void 0), u([be("classBreakInfos")], Nn.prototype, "readClassBreakInfos", null), u([xe("classBreakInfos")], Nn.prototype, "writeClassBreakInfos", null), u([d({ type: String, json: { write: !0 } })], Nn.prototype, "defaultLabel", void 0), u([d(V0)], Nn.prototype, "defaultSymbol", void 0), u([d({ type: String, json: { write: !0 } })], Nn.prototype, "field", void 0), u([mt("field")], Nn.prototype, "castField", null), u([d({ type: Boolean })], Nn.prototype, "isMaxInclusive", void 0), u([d({ type: Lk, json: { write: !0 } })], Nn.prototype, "legendOptions", void 0), u([d({ type: Number, readOnly: !0, value: null, json: { read: !1, write: { overridePolicy() {
  return this.classBreakInfos.length !== 0 && this._areClassBreaksConsecutive() ? { enabled: !0 } : { enabled: !1 };
} } } })], Nn.prototype, "minValue", null), u([d({ type: String, json: { write: !0 } })], Nn.prototype, "normalizationField", void 0), u([d({ type: Number, cast: (e) => ks(e), json: { write: !0 } })], Nn.prototype, "normalizationTotal", void 0), u([d({ type: Lv.apiValues, value: null, json: { type: Lv.jsonValues, read: Lv.read, write: Lv.write } })], Nn.prototype, "normalizationType", null), u([De({ classBreaks: "class-breaks" })], Nn.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Nn.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], Nn.prototype, "valueExpressionTitle", void 0), Nn = DI = u([T("geoscene.renderers.ClassBreaksRenderer")], Nn);
const $7 = Nn, yx = -3;
var Lu;
(function(e) {
  e[e.ALL = 0] = "ALL", e[e.SOME = 1] = "SOME";
})(Lu || (Lu = {}));
let wFe = class {
  constructor(t, n, r) {
    this._namespace = t, this._storage = n, this._removeFunc = !1, this._hit = 0, this._miss = 0, this._storage.register(this), this._namespace += ":", r && (this._storage.registerRemoveFunc(this._namespace, r), this._removeFunc = !0);
  }
  destroy() {
    this._storage.clear(this._namespace), this._removeFunc && this._storage.deregisterRemoveFunc(this._namespace), this._storage.deregister(this), this._storage = null;
  }
  get namespace() {
    return this._namespace.slice(0, -1);
  }
  get hitRate() {
    return this._hit / (this._hit + this._miss);
  }
  get size() {
    return this._storage.size;
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  resetHitRate() {
    this._hit = this._miss = 0;
  }
  put(t, n, r, i = 0) {
    this._storage.put(this._namespace + t, n, r, i);
  }
  get(t) {
    const n = this._storage.get(this._namespace + t);
    return n === void 0 ? ++this._miss : ++this._hit, n;
  }
  pop(t) {
    const n = this._storage.pop(this._namespace + t);
    return n === void 0 ? ++this._miss : ++this._hit, n;
  }
  updateSize(t, n, r) {
    this._storage.updateSize(this._namespace + t, n, r);
  }
  clear() {
    this._storage.clear(this._namespace);
  }
  clearAll() {
    this._storage.clearAll();
  }
  getStats() {
    return this._storage.getStats();
  }
  resetStats() {
    this._storage.resetStats();
  }
}, T7 = class {
  constructor(t = 10485760) {
    this._maxSize = t, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._removeFuncs = new zd(), this._users = new zd();
  }
  destroy() {
    this.clearAll(), this._removeFuncs.clear(), this._users.clear(), this._db = null;
  }
  register(t) {
    this._users.push(t);
  }
  deregister(t) {
    this._users.removeUnordered(t);
  }
  registerRemoveFunc(t, n) {
    this._removeFuncs.push([t, n]);
  }
  deregisterRemoveFunc(t) {
    this._removeFuncs.filterInPlace((n) => n[0] !== t);
  }
  get size() {
    return this._size;
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t) {
    this._maxSize = Math.max(t, 0), this._checkSizeLimit();
  }
  put(t, n, r, i) {
    const s = this._db.get(t);
    if (s && (this._size -= s.size, this._db.delete(t), s.entry !== n && this._notifyRemove(t, s.entry, Lu.ALL)), r > this._maxSize)
      return void this._notifyRemove(t, n, Lu.ALL);
    if (n === void 0)
      return void console.warn("Refusing to cache undefined entry ");
    if (!r || r < 0)
      return void console.warn("Refusing to cache entry with invalid size " + r);
    const o = 1 + Math.max(i, yx) - yx;
    this._db.set(t, { entry: n, size: r, lifetime: o, lives: o }), this._size += r, this._checkSizeLimit();
  }
  updateSize(t, n, r) {
    const i = this._db.get(t);
    if (i && i.entry === n) {
      for (this._size -= i.size; r > this._maxSize; ) {
        const s = this._notifyRemove(t, n, Lu.SOME);
        if (!(O(s) && s > 0))
          return void this._db.delete(t);
        r = s;
      }
      i.size = r, this._size += r, this._checkSizeLimit();
    }
  }
  pop(t) {
    const n = this._db.get(t);
    if (n)
      return this._size -= n.size, this._db.delete(t), ++this._hit, n.entry;
    ++this._miss;
  }
  get(t) {
    const n = this._db.get(t);
    if (n !== void 0)
      return this._db.delete(t), n.lives = n.lifetime, this._db.set(t, n), ++this._hit, n.entry;
    ++this._miss;
  }
  getStats() {
    const t = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, n = {}, r = new Array();
    this._db.forEach((o, a) => {
      const l = o.lifetime;
      r[l] = (r[l] || 0) + o.size, this._users.forAll((c) => {
        const p = c.namespace;
        if (a.startsWith(p)) {
          const f = n[p] || 0;
          n[p] = f + o.size;
        }
      });
    });
    const i = {};
    this._users.forAll((o) => {
      const a = o.namespace;
      if (!isNaN(o.hitRate) && o.hitRate > 0) {
        const l = n[a] || 0;
        n[a] = l, i[a] = Math.round(100 * o.hitRate) + "%";
      } else
        i[a] = "0%";
    });
    const s = Object.keys(n);
    s.sort((o, a) => n[a] - n[o]), s.forEach((o) => t[o] = Math.round(n[o] / 2 ** 20) + "MB / " + i[o]);
    for (let o = r.length - 1; o >= 0; --o) {
      const a = r[o];
      a && (t["Priority " + (o + yx - 1)] = Math.round(a / this.size * 100) + "%");
    }
    return t;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forAll((t) => t.resetHitRate());
  }
  clear(t) {
    this._db.forEach((n, r) => {
      r.startsWith(t) && (this._size -= n.size, this._db.delete(r), this._notifyRemove(r, n.entry, Lu.ALL));
    });
  }
  clearAll() {
    this._db.forEach((t, n) => this._notifyRemove(n, t.entry, Lu.ALL)), this._size = 0, this._db.clear();
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t, n, r) {
    let i;
    return this._removeFuncs.some((s) => {
      if (t.startsWith(s[0])) {
        const o = s[1](n, r);
        return typeof o == "number" && (i = o), !0;
      }
      return !1;
    }), i;
  }
  _checkSizeLimit() {
    if (!(this._size <= this._maxSize))
      for (const [t, n] of this._db) {
        if (this._db.delete(t), n.lives <= 1) {
          this._size -= n.size;
          const r = this._notifyRemove(t, n.entry, Lu.SOME);
          O(r) && r > 0 && (this._size += r, n.lives = n.lifetime, n.size = r, this._db.set(t, n));
        } else
          --n.lives, this._db.set(t, n);
        if (this._size <= 0.9 * this.maxSize)
          return;
      }
  }
}, xde = class {
  constructor(t, n) {
    this._storage = new T7(), this._storage.maxSize = t, n && this._storage.registerRemoveFunc("", n);
  }
  put(t, n, r) {
    this._storage.put(t, n, r, 1);
  }
  pop(t) {
    return this._storage.pop(t);
  }
  get(t) {
    return this._storage.get(t);
  }
  clear() {
    this._storage.clearAll();
  }
  destroy() {
    this._storage.destroy();
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  set maxSize(t) {
    this._storage.maxSize = t;
  }
};
const JL = we.getLogger("geoscene.renderers.support.DictionaryLoader"), $de = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
let Nk = class {
  constructor(t, n, r) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new xde(100), this.url = t, this.config = n, this.fieldMap = r;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t, n) {
    let r;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(n));
    try {
      r = await this._dictionaryPromise;
    } catch (y) {
      if (Ws(y))
        return this._dictionaryPromise = null, null;
    }
    const i = {};
    if (this.fieldMap)
      for (const y of this._symbolFields) {
        const g = this.fieldMap[y];
        if (g && t.attributes[g] != null) {
          const v = "" + t.attributes[g];
          i[y] = v;
        } else
          i[y] = "";
      }
    const s = r(i, n);
    if (!s || typeof s != "string")
      return null;
    const o = UC(s).toString(), a = this._symbolCache.get(o);
    if (a)
      return a.catch(() => {
        this._symbolCache.pop(o);
      }), a;
    const l = s.split(";"), c = [], p = [];
    for (const y of l)
      if (y)
        if (y.includes("po:")) {
          const g = y.substr(3).split("|");
          if (g.length === 3) {
            const v = g[0], w = g[1];
            let b = g[2];
            if (w === "DashTemplate")
              b = b.split(" ").map((S) => Number(S));
            else if (w === "Color") {
              const S = new Fe(b).toRgba();
              b = [S[0], S[1], S[2], 255 * S[3]];
            } else
              b = Number(b);
            p.push({ primitiveName: v, propertyName: w, value: b });
          }
        } else if (y.includes("|")) {
          for (const g of y.split("|"))
            if (this._itemNames.has(g)) {
              c.push(g);
              break;
            }
        } else
          this._itemNames.has(y) && c.push(y);
    const f = !O(t.geometry) || !t.geometry.hasZ && t.geometry.type === "point", m = this._cimPartsToCIMSymbol(c, p, f, n);
    return this._symbolCache.put(o, m, 1), m;
  }
  async fetchResources(t) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void JL.error("no valid URL!");
    const n = O(t) ? t.abortOptions : null, r = rn(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, ...n }), [{ data: i }] = await Promise.all([r, kl()]);
    if (!i)
      throw this._dictionaryPromise = null, new D("geoscene.renderers.DictionaryRenderer", "Bad dictionary data!");
    const s = i.expression, o = i.authoringInfo;
    this._refSymbolUrlTemplate = this.url + "/" + i.cimRefTemplateUrl, this._itemNames = new Set(i.itemsNames), this._symbolFields = o.symbol;
    const a = {};
    if (this.config) {
      const c = this.config;
      for (const p in c)
        a[p] = c[p];
    }
    if (o.configuration)
      for (const c of o.configuration)
        a.hasOwnProperty(c.name) || (a[c.name] = c.value);
    const l = [];
    if (O(t) && t.fields && this.fieldMap)
      for (const c of this._symbolFields) {
        const p = this.fieldMap[c], f = t.fields.filter((m) => m.name === p);
        f.length > 0 && l.push({ ...f[0], name: c });
      }
    return this._dictionaryPromise = XQ(s, O(t) ? t.spatialReference : null, l, a).then((c) => {
      const p = { scale: 0 };
      return (f, m) => {
        const y = c.repurposeFeature({ geometry: null, attributes: f });
        return p.scale = O(m) ? m.scale : void 0, c.evaluate({ $feature: y, $view: p });
      };
    }).catch((c) => (JL.error("Creating dictinoary expression failed:", c), null)), this._dictionaryPromise;
  }
  async _cimPartsToCIMSymbol(t, n, r, i) {
    const s = new Array(t.length);
    for (let l = 0; l < t.length; l++)
      s[l] = this._getSymbolPart(t[l], i);
    const o = await Promise.all(s), a = this.fieldMap;
    for (const l of o)
      E7(l, a);
    return new S0({ data: this._combineSymbolParts(o, n, r) });
  }
  async _getSymbolPart(t, n) {
    if (this._ongoingRequests.has(t))
      return this._ongoingRequests.get(t).then((s) => s.data);
    const r = this._refSymbolUrlTemplate.replace(/\{itemName\}/gi, t), i = rn(r, { responseType: "json", query: { f: "json" }, ...n });
    this._ongoingRequests.set(t, i);
    try {
      return (await i).data;
    } catch (s) {
      return this._ongoingRequests.delete(t), Promise.reject(s);
    }
  }
  _combineSymbolParts(t, n, r) {
    if (!t || t.length === 0)
      return null;
    const i = { ...t[0] };
    if (t.length > 1) {
      i.symbolLayers = [];
      for (const s of t) {
        const o = s;
        i.symbolLayers.unshift(...o.symbolLayers);
      }
    }
    return r && (i.callout = $de), { type: "CIMSymbolReference", symbol: i, primitiveOverrides: n };
  }
};
function E7(e, t) {
  if (!e)
    return;
  const n = e.symbolLayers;
  if (!n)
    return;
  let r = n.length;
  for (; r--; ) {
    const i = n[r];
    i && i.enable !== !1 && i.type === "CIMVectorMarker" && Tde(i, t);
  }
}
function Tde(e, t) {
  const n = e.markerGraphics;
  if (n)
    for (const r of n) {
      if (!r)
        continue;
      const i = r.symbol;
      if (i)
        switch (i.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            E7(i, t);
            break;
          case "CIMTextSymbol":
            i.fieldMap = t;
        }
    }
}
const TFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DictionaryLoader: Nk
}, Symbol.toStringTag, { value: "Module" }));
var jI;
let mo = jI = class extends j0(vc) {
  constructor(e) {
    super(e), this.config = null, this.fieldMap = null, this.scaleExpression = null, this.scaleExpressionTitle = null, this.url = null, this.type = "dictionary";
  }
  get _loader() {
    return new Nk(this.url, this.config, this.fieldMap);
  }
  writeData(e, t) {
    e && (t.scalingExpressionInfo = { expression: e, returnType: "number" });
  }
  writeVisualVariables(e, t, n, r) {
    r != null && r.origin || super.writeVisualVariables(e, t, n, r);
  }
  clone() {
    return new jI({ config: q(this.config), scaleExpression: this.scaleExpression, scaleExpressionTitle: this.scaleExpressionTitle, fieldMap: q(this.fieldMap), url: q(this.url), visualVariables: q(this.visualVariables) });
  }
  async getSymbolAsync(e, t) {
    return this._loader.getSymbolAsync(e, t);
  }
  async collectRequiredFields(e, t) {
    await this.collectVVRequiredFields(e, t), this.scaleExpression && await as(e, t, this.scaleExpression);
    for (const n in this.fieldMap) {
      const r = this.fieldMap[n];
      t.has(r) && e.add(r);
    }
  }
  get arcadeRequired() {
    return !0;
  }
  getSymbol() {
    return null;
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return `${this.url}-${JSON.stringify(this.fieldMap)}`;
  }
  getSymbolFields() {
    return this._loader.getSymbolFields();
  }
};
u([d({ type: Nk })], mo.prototype, "_loader", null), u([d({ type: Object, json: { read: { source: "configuration" }, write: { target: "configuration" } } })], mo.prototype, "config", void 0), u([d({ type: Object, json: { write: !0 } })], mo.prototype, "fieldMap", void 0), u([d({ type: String, json: { read: { source: "scalingExpressionInfo.expression" }, write: !0 } })], mo.prototype, "scaleExpression", void 0), u([xe("scaleExpression")], mo.prototype, "writeData", null), u([d({ type: String, json: { read: { source: "scalingExpressionInfo.title" }, write: { target: "scalingExpressionInfo.title", overridePolicy(e) {
  return { enabled: !!e && !!this.scaleExpression };
} } } })], mo.prototype, "scaleExpressionTitle", void 0), u([d({ type: String, json: { write: !0 } })], mo.prototype, "url", void 0), u([xe("visualVariables")], mo.prototype, "writeVisualVariables", null), mo = jI = u([T("geoscene.renderers.DictionaryRenderer")], mo);
const Ede = mo;
var VI;
const Ide = we.getLogger("geoscene.renderers.support.AttributeColorInfo");
let nl = VI = class extends se {
  constructor(e) {
    super(e), this.color = null, this.field = null, this.label = null, this.valueExpression = null, this.valueExpressionTitle = null;
  }
  castField(e) {
    return e == null ? e : typeof e == "function" ? (Ide.error(".field: field must be a string value"), null) : v0(e);
  }
  getAttributeHash() {
    return `${this.field}-${this.valueExpression}`;
  }
  clone() {
    return new VI({ color: this.color && this.color.clone(), field: this.field, label: this.label, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
u([d({ type: Fe, json: { type: [Number], write: !0 } })], nl.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], nl.prototype, "field", void 0), u([mt("field")], nl.prototype, "castField", null), u([d({ type: String, json: { write: !0 } })], nl.prototype, "label", void 0), u([d({ type: String, json: { write: !0 } })], nl.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], nl.prototype, "valueExpressionTitle", void 0), nl = VI = u([T("geoscene.renderers.support.AttributeColorInfo")], nl);
const Mde = nl;
var zI;
let fw = zI = class extends se {
  constructor() {
    super(...arguments), this.unit = null;
  }
  clone() {
    return new zI({ unit: this.unit });
  }
};
u([d({ type: String, json: { write: !0 } })], fw.prototype, "unit", void 0), fw = zI = u([T("geoscene.renderers.support.DotDensityLegendOptions")], fw);
const Cde = fw;
var BI;
let Or = BI = class extends j0(vc) {
  constructor(e) {
    super(e), this.attributes = null, this.backgroundColor = new Fe([0, 0, 0, 0]), this.blendDots = !0, this.dotBlendingEnabled = !0, this.dotShape = "square", this.dotSize = 1, this.legendOptions = null, this.outline = new Hs(), this.dotValue = null, this.referenceDotValue = null, this.referenceScale = null, this.seed = 1, this.type = "dot-density";
  }
  calculateDotValue(e) {
    if (this.referenceScale == null)
      return this.dotValue;
    const t = e / this.referenceScale * this.dotValue;
    return t < 1 ? 1 : t;
  }
  getSymbol() {
    return new Ip({ outline: this.outline });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  getAttributeHash() {
    return this.attributes && this.attributes.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return JSON.stringify(this.outline);
  }
  clone() {
    return new BI({ attributes: q(this.attributes), backgroundColor: q(this.backgroundColor), dotBlendingEnabled: q(this.dotBlendingEnabled), dotShape: q(this.dotShape), dotSize: q(this.dotSize), dotValue: q(this.dotValue), legendOptions: q(this.legendOptions), outline: q(this.outline), referenceScale: q(this.referenceScale), visualVariables: q(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  getControllerHash() {
    return `${this.attributes.map((e) => e.field || e.valueExpression || "")}-${this.outline && JSON.stringify(this.outline.toJSON()) || ""}`;
  }
  async collectRequiredFields(e, t) {
    await this.collectVVRequiredFields(e, t);
    for (const n of this.attributes)
      n.valueExpression && await as(e, t, n.valueExpression), n.field && e.add(n.field);
  }
};
u([d({ type: [Mde], json: { write: !0 } })], Or.prototype, "attributes", void 0), u([d({ type: Fe, json: { write: !0 } })], Or.prototype, "backgroundColor", void 0), u([d({ type: Boolean }), Le("dotBlendingEnabled")], Or.prototype, "blendDots", void 0), u([d({ type: Boolean, json: { write: !0 } })], Or.prototype, "dotBlendingEnabled", void 0), u([d({ type: String, json: { write: !1 } })], Or.prototype, "dotShape", void 0), u([d({ type: Number, json: { write: !0, origins: { "web-map": { write: !1 }, "web-scene": { write: !1 } } } })], Or.prototype, "dotSize", void 0), u([d({ type: Cde, json: { write: !0 } })], Or.prototype, "legendOptions", void 0), u([d({ type: Hs, json: { default: null, write: !0 } })], Or.prototype, "outline", void 0), u([d({ type: Number, json: { write: !0 } })], Or.prototype, "dotValue", void 0), u([d({ type: Number }), Le("dotValue")], Or.prototype, "referenceDotValue", void 0), u([d({ type: Number, json: { write: !0 } })], Or.prototype, "referenceScale", void 0), u([d({ type: Number, json: { write: !0 } })], Or.prototype, "seed", void 0), u([De({ dotDensity: "dot-density" })], Or.prototype, "type", void 0), Or = BI = u([T("geoscene.renderers.DotDensityRenderer")], Or);
const Ode = Or;
var UI;
let ky = UI = class extends se {
  constructor(e) {
    super(e), this.color = null, this.ratio = null;
  }
  clone() {
    return new UI({ color: this.color, ratio: this.ratio });
  }
};
u([d({ type: Fe, json: { write: !0 } })], ky.prototype, "color", void 0), u([d({ type: Number, json: { write: !0 } })], ky.prototype, "ratio", void 0), ky = UI = u([T("geoscene.renderers.support.HeatmapColorStop")], ky);
const mw = ky;
var qI;
let yo = qI = class extends vc {
  constructor(e) {
    super(e), this.blurRadius = 10, this.referenceScale = 0, this.colorStops = [new mw({ ratio: 0, color: new Fe("rgba(255, 140, 0, 0)") }), new mw({ ratio: 0.75, color: new Fe("rgba(255, 140, 0, 1)") }), new mw({ ratio: 0.9, color: new Fe("rgba(255, 0,   0, 1)") })], this.field = null, this.fieldOffset = 0, this.maxPixelIntensity = 100, this.minPixelIntensity = 0, this.type = "heatmap";
  }
  async collectRequiredFields(e, t) {
    const n = this.field;
    n && typeof n == "string" && Fs(e, t, n);
  }
  getAttributeHash() {
    return null;
  }
  getMeshHash() {
    return `${JSON.stringify(this.colorStops)}.${this.blurRadius}.${this.field}`;
  }
  clone() {
    return new qI({ blurRadius: this.blurRadius, referenceScale: this.referenceScale, colorStops: q(this.colorStops), field: this.field, maxPixelIntensity: this.maxPixelIntensity, minPixelIntensity: this.minPixelIntensity });
  }
};
u([d({ type: Number, json: { write: !0 } })], yo.prototype, "blurRadius", void 0), u([d({ type: Number })], yo.prototype, "referenceScale", void 0), u([d({ type: [mw], json: { write: !0 } })], yo.prototype, "colorStops", void 0), u([d({ type: String, json: { write: !0 } })], yo.prototype, "field", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e, t, n) => ({ enabled: n == null }) } } })], yo.prototype, "fieldOffset", void 0), u([d({ type: Number, json: { write: !0 } })], yo.prototype, "maxPixelIntensity", void 0), u([d({ type: Number, json: { write: !0 } })], yo.prototype, "minPixelIntensity", void 0), u([De({ heatmap: "heatmap" })], yo.prototype, "type", void 0), yo = qI = u([T("geoscene.renderers.HeatmapRenderer")], yo);
const I7 = yo;
var GI;
let nd = GI = class extends j0(vc) {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.symbol = null, this.type = "simple";
  }
  async collectRequiredFields(e, t) {
    await Promise.all([this.collectSymbolFields(e, t), this.collectVVRequiredFields(e, t)]);
  }
  async collectSymbolFields(e, t) {
    await Promise.all(this.getSymbols().map((n) => n.collectRequiredFields(e, t)));
  }
  getSymbol(e, t) {
    return this.symbol;
  }
  async getSymbolAsync(e, t) {
    return this.symbol;
  }
  getSymbols() {
    return this.symbol ? [this.symbol] : [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return this.getSymbols().reduce((e, t) => e + JSON.stringify(t), "");
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables;
  }
  clone() {
    return new GI({ description: this.description, label: this.label, symbol: this.symbol && this.symbol.clone(), visualVariables: q(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
};
u([d({ type: String, json: { write: !0 } })], nd.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], nd.prototype, "label", void 0), u([d(V0)], nd.prototype, "symbol", void 0), u([De({ simple: "simple" })], nd.prototype, "type", void 0), nd = GI = u([T("geoscene.renderers.SimpleRenderer")], nd);
const Dk = nd, kde = ["geoscene.Color", "geoscene.portal.Portal", "geoscene.symbols.support.Symbol3DAnchorPosition2D", "geoscene.symbols.support.Symbol3DAnchorPosition3D"];
function WI(e) {
  return e instanceof ke;
}
function ZL(e) {
  return e instanceof Ne ? Object.keys(e.items) : WI(e) ? Xr(e).keys() : e ? Object.keys(e) : [];
}
function Fv(e, t) {
  return e instanceof Ne ? e.items[t] : e[t];
}
function Ade(e, t) {
  return !(!Array.isArray(e) || !Array.isArray(t)) && e.length !== t.length;
}
function ag(e) {
  return e ? e.declaredClass : null;
}
function M7(e, t) {
  const n = e.diff;
  if (n && typeof n == "function")
    return n(e, t);
  const r = ZL(e), i = ZL(t);
  if (r.length === 0 && i.length === 0)
    return;
  if (!r.length || !i.length || Ade(e, t))
    return { type: "complete", oldValue: e, newValue: t };
  const s = i.filter((f) => r.indexOf(f) === -1), o = r.filter((f) => i.indexOf(f) === -1), a = r.filter((f) => i.indexOf(f) > -1 && Fv(e, f) !== Fv(t, f)).concat(s, o).sort(), l = ag(e);
  if (l && kde.indexOf(l) > -1 && a.length)
    return { type: "complete", oldValue: e, newValue: t };
  let c;
  const p = WI(e) && WI(t);
  for (const f of a) {
    const m = Fv(e, f), y = Fv(t, f);
    let g;
    (p || typeof m != "function" && typeof y != "function") && m !== y && (m == null && y == null || (g = n && n[f] && typeof n[f] == "function" ? n[f](m, y) : typeof m == "object" && typeof y == "object" && ag(m) === ag(y) ? M7(m, y) : { type: "complete", oldValue: m, newValue: y }, O(g) && (O(c) ? c.diff[f] = g : c = { type: "partial", diff: { [f]: g } })));
  }
  return c;
}
function Pde(e, t) {
  if (H(e))
    return !1;
  const n = t.split(".");
  let r = e;
  for (const i of n) {
    if (r.type === "complete")
      return !0;
    if (r.type !== "partial")
      return !1;
    {
      const s = r.diff[i];
      if (!s)
        return !1;
      r = s;
    }
  }
  return !0;
}
function EFe(e, t) {
  for (const n of t)
    if (Pde(e, n))
      return !0;
  return !1;
}
function Rde(e, t) {
  if (!(typeof e == "function" || typeof t == "function" || H(e) && H(t)))
    return H(e) || H(t) || typeof e == "object" && typeof t == "object" && ag(e) !== ag(t) ? { type: "complete", oldValue: e, newValue: t } : M7(e, t);
}
var HI;
let vu = HI = class extends se {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.symbol = null, this.value = null;
  }
  castValue(e) {
    return e == null || typeof e == "string" || typeof e == "number" ? e : `${e}`;
  }
  clone() {
    return new HI({ value: this.value, description: this.description, label: this.label, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const e = JSON.stringify(this.symbol && this.symbol.toJSON());
    return `${this.value}.${e}`;
  }
};
u([d({ type: String, json: { write: !0 } })], vu.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], vu.prototype, "label", void 0), u([d(V0)], vu.prototype, "symbol", void 0), u([d({ json: { type: String, write: { writer: (e, t) => {
  t.value = e == null ? void 0 : e.toString();
} } } })], vu.prototype, "value", void 0), u([mt("value")], vu.prototype, "castValue", null), vu = HI = u([T("geoscene.renderers.support.UniqueValueInfo")], vu);
const r_ = vu, Lde = () => !!K("enable-feature:force-wosr"), gx = {};
async function Fde(e, t) {
  try {
    return { data: (await Vde(e, t)).data, baseUrl: DK(e), styleUrl: e };
  } catch (n) {
    return y0(n), null;
  }
}
function Nde(e, t, n) {
  const r = t && t.portal || os.getDefault();
  let i;
  const s = `${r.url} - ${r.user && r.user.username} - ${e}`;
  return gx[s] || (gx[s] = Dde(e, r, n).then((o) => (i = o, o.fetchData())).then((o) => ({ data: o, baseUrl: i.itemUrl, styleName: e }))), gx[s];
}
function Dde(e, t, n) {
  return t.load(n).then(() => {
    const r = new bl({ disableExtraQuery: !0, query: `owner:${KL} AND type:${YL} AND typekeywords:"${e}"` });
    return t.queryItems(r, n);
  }).then(({ results: r }) => {
    let i = null;
    const s = e.toLowerCase();
    if (r && Array.isArray(r)) {
      for (const o of r)
        if (o.typeKeywords.some((a) => a.toLowerCase() === s) && o.type === YL && o.owner === KL) {
          i = o;
          break;
        }
    }
    if (!i)
      throw new D("symbolstyleutils:style-not-found", `The style '${e}' could not be found`, { styleName: e });
    return i.load(n);
  });
}
function jde(e, t, n) {
  return e.styleUrl ? Fde(e.styleUrl, n) : e.styleName ? Nde(e.styleName, t, n) : Promise.reject(new D("symbolstyleutils:style-url-and-name-missing", "Either styleUrl or styleName is required to resolve a style"));
}
function IFe(e) {
  return e === null || e.type === "CIMSymbolReference" ? e : { type: "CIMSymbolReference", symbol: e };
}
function MFe(e, t) {
  if (t === "cimRef")
    return e.cimRef;
  if (e.formatInfos && !Lde()) {
    for (const n of e.formatInfos)
      if (n.type === "gltf")
        return n.href;
  }
  return e.webRef;
}
function Vde(e, t) {
  const n = { responseType: "json", query: { f: "json" }, ...t };
  return rn(Co(e), n);
}
const KL = "esri_en", YL = "Style", CFe = "https://links.geoscene.cn/geoscene/sharing/rest/content/items/220936cc6ed342c9937abd8f180e7d1e/resources/styles/cim/{SymbolName}.json?f=json";
var Ay;
const Tc = we.getLogger("geoscene.renderers.UniqueValueRenderer"), zde = kn(r_);
let hn = Ay = class extends j0(vc) {
  constructor(e) {
    super(e), this._valueInfoMap = {}, this._isDefaultSymbolDerived = !1, this.type = "unique-value", this.backgroundFillSymbol = null, this.field = null, this.field2 = null, this.field3 = null, this.valueExpression = null, this.valueExpressionTitle = null, this.legendOptions = null, this.defaultLabel = null, this.fieldDelimiter = null, this.portal = null, this.styleOrigin = null, this.diff = { uniqueValueInfos(t, n) {
      if (!t && !n)
        return;
      if (!t || !n)
        return { type: "complete", oldValue: t, newValue: n };
      let r = !1;
      const i = { type: "collection", added: [], removed: [], changed: [], unchanged: [] };
      for (let s = 0; s < n.length; s++) {
        const o = t.find((a) => a.value === n[s].value);
        o ? Rde(o, n[s]) ? (i.changed.push({ type: "complete", oldValue: o, newValue: n[s] }), r = !0) : i.unchanged.push({ oldValue: o, newValue: n[s] }) : (i.added.push(n[s]), r = !0);
      }
      for (let s = 0; s < t.length; s++)
        n.find((o) => o.value === t[s].value) || (i.removed.push(t[s]), r = !0);
      return r ? i : void 0;
    } }, this._set("uniqueValueInfos", []);
  }
  get _cache() {
    return { compiledFunc: null };
  }
  castField(e) {
    return e == null || typeof e == "function" ? e : v0(e);
  }
  writeField(e, t, n, r) {
    typeof e == "string" ? t[n] = e : r && r.messages ? r.messages.push(new D("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : Tc.error(".field: cannot write field to JSON since it's not a string value");
  }
  set defaultSymbol(e) {
    this._isDefaultSymbolDerived = !1, this._set("defaultSymbol", e);
  }
  readPortal(e, t, n) {
    return n.portal || os.getDefault();
  }
  readStyleOrigin(e, t, n) {
    if (t.styleName)
      return Object.freeze({ styleName: t.styleName });
    if (t.styleUrl) {
      const r = Hf(t.styleUrl, n);
      return Object.freeze({ styleUrl: r });
    }
  }
  writeStyleOrigin(e, t, n, r) {
    e.styleName ? t.styleName = e.styleName : e.styleUrl && (t.styleUrl = $0(e.styleUrl, r));
  }
  set uniqueValueInfos(e) {
    this.styleOrigin ? Tc.error("#uniqueValueInfos=", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", e), this._updateValueInfoMap());
  }
  addUniqueValueInfo(e, t) {
    if (this.styleOrigin)
      return void Tc.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    let n;
    n = typeof e == "object" ? zde(e) : new r_({ value: e, symbol: Mj(t) }), this.uniqueValueInfos.push(n), this._valueInfoMap[n.value] = n;
  }
  removeUniqueValueInfo(e) {
    if (this.styleOrigin)
      Tc.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    else
      for (let t = 0; t < this.uniqueValueInfos.length; t++)
        if (this.uniqueValueInfos[t].value === e + "") {
          delete this._valueInfoMap[e], this.uniqueValueInfos.splice(t, 1);
          break;
        }
  }
  async getUniqueValueInfo(e, t) {
    let n = t;
    return this.valueExpression && (H(t) || H(t.arcade)) && (n = { ...n, arcade: await kl() }), this._getUniqueValueInfo(e, n);
  }
  getSymbol(e, t) {
    if (this.valueExpression && (H(t) || H(t.arcade)))
      return void Tc.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const n = this._getUniqueValueInfo(e, t);
    return n && n.symbol || this.defaultSymbol;
  }
  async getSymbolAsync(e, t) {
    let n = t;
    if (this.valueExpression && (H(n) || H(n.arcade))) {
      const i = await kl(), { arcadeUtils: s } = i;
      s.hasGeometryOperations(this.valueExpression) && await s.enableGeometryOperations(), n = { ...n, arcade: i };
    }
    const r = this._getUniqueValueInfo(e, n);
    return r && r.symbol || this.defaultSymbol;
  }
  getSymbols() {
    const e = [];
    for (const t of this.uniqueValueInfos)
      t.symbol && e.push(t.symbol);
    return this.defaultSymbol && e.push(this.defaultSymbol), e;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return `${JSON.stringify(this.backgroundFillSymbol)}.${JSON.stringify(this.defaultSymbol)}.${this.uniqueValueInfos.reduce((e, t) => e + t.getMeshHash(), "")}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`;
  }
  clone() {
    const e = new Ay({ field: this.field, field2: this.field2, field3: this.field3, defaultLabel: this.defaultLabel, defaultSymbol: q(this.defaultSymbol), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, fieldDelimiter: this.fieldDelimiter, visualVariables: q(this.visualVariables), legendOptions: q(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone(), backgroundFillSymbol: q(this.backgroundFillSymbol) });
    this._isDefaultSymbolDerived && (e._isDefaultSymbolDerived = !0), e._set("portal", this.portal);
    const t = q(this.uniqueValueInfos);
    return this.styleOrigin && (e._set("styleOrigin", Object.freeze(q(this.styleOrigin))), Object.freeze(t)), e._set("uniqueValueInfos", t), e._updateValueInfoMap(), e;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  async collectRequiredFields(e, t) {
    const n = [this.collectVVRequiredFields(e, t), this.collectSymbolFields(e, t)];
    await Promise.all(n);
  }
  async collectSymbolFields(e, t) {
    const n = [...this.getSymbols().map((r) => r.collectRequiredFields(e, t)), as(e, t, this.valueExpression)];
    Fs(e, t, this.field), Fs(e, t, this.field2), Fs(e, t, this.field3), await Promise.all(n);
  }
  populateFromStyle() {
    return jde(this.styleOrigin, { portal: this.portal }).then((e) => {
      const t = [];
      return this._valueInfoMap = {}, e && e.data && Array.isArray(e.data.items) && e.data.items.forEach((n) => {
        const r = new Mp({ styleUrl: e.styleUrl, styleName: e.styleName, portal: this.portal, name: n.name });
        this.defaultSymbol || n.name !== e.data.defaultItem || (this.defaultSymbol = r, this._isDefaultSymbolDerived = !0);
        const i = new r_({ value: n.name, symbol: r });
        t.push(i), this._valueInfoMap[n.name] = i;
      }), this._set("uniqueValueInfos", Object.freeze(t)), !this.defaultSymbol && this.uniqueValueInfos.length && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = !0), this;
    });
  }
  _updateValueInfoMap() {
    this._valueInfoMap = {}, this.uniqueValueInfos.forEach((e) => this._valueInfoMap[e.value + ""] = e);
  }
  _getUniqueValueInfo(e, t) {
    return this.valueExpression ? this._getUnqiueValueInfoForExpression(e, t) : this._getUnqiueValueInfoForFields(e);
  }
  _getUnqiueValueInfoForExpression(e, t) {
    const { viewingMode: n, scale: r, spatialReference: i, arcade: s } = BC(t, {});
    let o = this._cache.compiledFunc;
    const a = s.arcadeUtils;
    if (!o) {
      const c = a.createSyntaxTree(this.valueExpression);
      o = a.createFunction(c), this._cache.compiledFunc = o;
    }
    const l = a.executeFunction(o, a.createExecContext(e, a.getViewInfo({ viewingMode: n, scale: r, spatialReference: i })));
    return this._valueInfoMap[l + ""];
  }
  _getUnqiueValueInfoForFields(e) {
    const t = this.field, n = e.attributes;
    let r;
    if (typeof t != "function" && this.field2) {
      const i = this.field2, s = this.field3, o = [];
      t && o.push(n[t]), i && o.push(n[i]), s && o.push(n[s]), r = o.join(this.fieldDelimiter || "");
    } else
      typeof t == "function" ? r = t(e) : t && (r = n[t]);
    return this._valueInfoMap[r + ""];
  }
  static fromPortalStyle(e, t) {
    const n = new Ay(t && t.properties);
    n._set("styleOrigin", Object.freeze({ styleName: e })), n._set("portal", t && t.portal || os.getDefault());
    const r = n.populateFromStyle();
    return r.catch((i) => {
      Tc.error(`#fromPortalStyle('${e}'[, ...])`, "Failed to create unique value renderer from style name", i);
    }), r;
  }
  static fromStyleUrl(e, t) {
    const n = new Ay(t && t.properties);
    n._set("styleOrigin", Object.freeze({ styleUrl: e }));
    const r = n.populateFromStyle();
    return r.catch((i) => {
      Tc.error(`#fromStyleUrl('${e}'[, ...])`, "Failed to create unique value renderer from style URL", i);
    }), r;
  }
};
u([d({ readOnly: !0 })], hn.prototype, "_cache", null), u([De({ uniqueValue: "unique-value" })], hn.prototype, "type", void 0), u([d(S7)], hn.prototype, "backgroundFillSymbol", void 0), u([d({ json: { type: String, read: { source: "field1" }, write: { target: "field1" } } })], hn.prototype, "field", void 0), u([mt("field")], hn.prototype, "castField", null), u([xe("field")], hn.prototype, "writeField", null), u([d({ type: String, json: { write: !0 } })], hn.prototype, "field2", void 0), u([d({ type: String, json: { write: !0 } })], hn.prototype, "field3", void 0), u([d({ type: String, json: { write: !0 } })], hn.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], hn.prototype, "valueExpressionTitle", void 0), u([d({ type: Lk, json: { write: !0 } })], hn.prototype, "legendOptions", void 0), u([d({ type: String, json: { write: !0 } })], hn.prototype, "defaultLabel", void 0), u([d(AD({ ...V0 }, { json: { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} }, origins: { "web-scene": { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} } } } } }))], hn.prototype, "defaultSymbol", null), u([d({ type: String, json: { write: !0 } })], hn.prototype, "fieldDelimiter", void 0), u([d({ type: os, readOnly: !0 })], hn.prototype, "portal", void 0), u([be("portal", ["styleName"])], hn.prototype, "readPortal", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: () => ({ enabled: !0 }) } } })], hn.prototype, "styleOrigin", void 0), u([be("styleOrigin", ["styleName", "styleUrl"])], hn.prototype, "readStyleOrigin", null), u([xe("styleOrigin", { styleName: { type: String }, styleUrl: { type: String } })], hn.prototype, "writeStyleOrigin", null), u([d({ type: [r_], json: { write: { overridePolicy() {
  return this.styleOrigin ? { enabled: !1 } : { enabled: !0 };
} } } })], hn.prototype, "uniqueValueInfos", null), hn = Ay = u([T("geoscene.renderers.UniqueValueRenderer")], hn);
const jk = hn, C7 = { key: "type", base: vc, typeMap: { heatmap: I7, simple: Dk, "unique-value": jk, "class-breaks": $7, "dot-density": Ode, dictionary: Ede }, errorContext: "renderer" }, Bde = { key: "type", base: vc, typeMap: { simple: Dk, "unique-value": jk, "class-breaks": $7 }, errorContext: "renderer" };
function OFe(e, t) {
  return O7(e, null, t);
}
const Ude = zf({ types: C7 });
function O7(e, t, n) {
  return e ? e && (e.styleName || e.styleUrl) && e.type !== "uniqueValue" ? (n && n.messages && n.messages.push(new Ds("renderer:unsupported", "Only UniqueValueRenderer can be referenced from a web style, but found '" + e.type + "'", { definition: e, context: n })), null) : Ude(e, t, n) : null;
}
let qde = class k7 {
  constructor() {
    this._propertyOriginMap = /* @__PURE__ */ new Map(), this._originStores = new Array(M$), this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !0;
  }
  clone(t) {
    const n = new k7(), r = this._originStores[ot.DEFAULTS];
    r && r.forEach((i, s) => {
      n.set(s, q(i), ot.DEFAULTS);
    });
    for (let i = ot.SERVICE; i < M$; i++) {
      const s = this._originStores[i];
      s && s.forEach((o, a) => {
        t && t.has(a) || n.set(a, q(o), i);
      });
    }
    return n;
  }
  get(t, n) {
    const r = n === void 0 ? this._values : this._originStores[n];
    return r ? r.get(t) : void 0;
  }
  keys(t) {
    const n = t == null ? this._values : this._originStores[t];
    return n ? [...n.keys()] : [];
  }
  set(t, n, r = ot.USER) {
    let i = this._originStores[r];
    if (i || (i = /* @__PURE__ */ new Map(), this._originStores[r] = i), i.set(t, n), !this._values.has(t) || this._propertyOriginMap.get(t) <= r) {
      const s = this._values.get(t);
      return this._values.set(t, n), this._propertyOriginMap.set(t, r), s !== n;
    }
    return !1;
  }
  delete(t, n = ot.USER) {
    const r = this._originStores[n];
    if (!r)
      return;
    const i = r.get(t);
    if (r.delete(t), this._values.has(t) && this._propertyOriginMap.get(t) === n) {
      this._values.delete(t);
      for (let s = n - 1; s >= 0; s--) {
        const o = this._originStores[s];
        if (o && o.has(t)) {
          this._values.set(t, o.get(t)), this._propertyOriginMap.set(t, s);
          break;
        }
      }
    }
    return i;
  }
  has(t, n) {
    const r = n === void 0 ? this._values : this._originStores[n];
    return !!r && r.has(t);
  }
  revert(t, n) {
    for (; n > 0 && !this.has(t, n); )
      --n;
    const r = this._originStores[n], i = r && r.get(t), s = this._values.get(t);
    return this._values.set(t, i), this._propertyOriginMap.set(t, n), s !== i;
  }
  originOf(t) {
    return this._propertyOriginMap.get(t) || ot.DEFAULTS;
  }
  forEach(t) {
    this._values.forEach(t);
  }
};
const A7 = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n);
      const r = Xr(this), i = r.store, s = new qde();
      r.store = s, I8(r, i, s);
    }
    read(n, r) {
      C8(this, n, r);
    }
    getAtOrigin(n, r) {
      const i = vx(this), s = Vu(r);
      if (typeof n == "string")
        return i.get(n, s);
      const o = {};
      return n.forEach((a) => {
        o[a] = i.get(a, s);
      }), o;
    }
    originOf(n) {
      return n1(this.originIdOf(n));
    }
    originIdOf(n) {
      return vx(this).originOf(n);
    }
    revert(n, r) {
      const i = vx(this), s = Vu(r), o = Xr(this);
      let a;
      a = typeof n == "string" ? n === "*" ? i.keys(s) : [n] : n, a.forEach((l) => {
        o.invalidate(l), i.revert(l, s), o.commit(l);
      });
    }
  };
  return t = u([T("geoscene.core.ReadOnlyMultiOriginJSONSupport")], t), t;
};
function vx(e) {
  return Xr(e).store;
}
let QL = class extends A7(ke) {
};
QL = u([T("geoscene.core.ReadOnlyMultiOriginJSONSupport")], QL);
const Gde = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n);
    }
    clear(n, r = "user") {
      return bx(this).delete(n, Vu(r));
    }
    write(n = {}, r) {
      return k8(this, n = n || {}, r), n;
    }
    setAtOrigin(n, r, i) {
      Xr(this).setAtOrigin(n, r, Vu(i));
    }
    removeOrigin(n) {
      const r = bx(this), i = Vu(n), s = r.keys(i);
      for (const o of s)
        r.originOf(o) === i && r.set(o, r.get(o, i), ot.USER);
    }
    updateOrigin(n, r) {
      const i = bx(this), s = Vu(r), o = this.get(n);
      for (let a = s + 1; a < M$; ++a)
        i.delete(n, a);
      i.set(n, o, s);
    }
    toJSON(n) {
      return this.write({}, n);
    }
  };
  return t = u([T("geoscene.core.WriteableMultiOriginJSONSupport")], t), t.prototype.toJSON.isDefaultToJSON = !0, t;
};
function bx(e) {
  return Xr(e).store;
}
const P7 = (e) => {
  let t = class extends Gde(A7(e)) {
    constructor(...n) {
      super(...n);
    }
  };
  return t = u([T("geoscene.core.MultiOriginJSONSupport")], t), t;
};
let XL = class extends P7(ke) {
};
XL = u([T("geoscene.core.MultiOriginJSONSupport")], XL);
async function Wde(e, t) {
  const { WhereClause: n } = await import("./WhereClause-tgx5XbAS.js");
  return n.create(e, t);
}
var JI;
let rd = JI = class extends se {
  constructor(e) {
    super(e), this.expression = null, this.name = null, this.returnType = "boolean", this.title = null;
  }
  clone() {
    return new JI({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
u([d({ type: String, json: { write: !0 } })], rd.prototype, "expression", void 0), u([d({ type: String, json: { write: !0 } })], rd.prototype, "name", void 0), u([d({ type: ["boolean", "date", "number", "string"], json: { write: !0 } })], rd.prototype, "returnType", void 0), u([d({ type: String, json: { write: !0 } })], rd.prototype, "title", void 0), rd = JI = u([T("geoscene.form.ExpressionInfo")], rd);
const Hde = rd;
let id = class extends se {
  constructor(t) {
    super(t), this.description = null, this.label = null, this.type = null, this.visibilityExpression = null;
  }
};
u([d({ type: String, json: { write: !0 } })], id.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], id.prototype, "label", void 0), u([d()], id.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], id.prototype, "visibilityExpression", void 0), id = u([T("geoscene.form.elements.Element")], id);
const Ef = id;
var ZI;
let yw = ZI = class extends se {
  constructor(e) {
    super(e), this.type = null;
  }
  clone() {
    return new ZI({ type: this.type });
  }
};
u([d({ type: ["attachment", "audio", "document", "image", "signature", "video"], json: { write: !0 } })], yw.prototype, "type", void 0), yw = ZI = u([T("geoscene.form.elements.inputs.AttachmentInput")], yw);
const Jde = yw;
var KI;
let sd = KI = class extends Ef {
  constructor(e) {
    super(e), this.attachmentKeyword = null, this.editable = !0, this.input = null, this.type = "attachment";
  }
  clone() {
    return new KI({ attachmentKeyword: this.attachmentKeyword, description: this.description, editable: this.editable, input: this.input, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ type: String, json: { write: !0 } })], sd.prototype, "attachmentKeyword", void 0), u([d({ type: Boolean, json: { write: !0 } })], sd.prototype, "editable", void 0), u([d({ type: Jde, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], sd.prototype, "input", void 0), u([d({ type: ["attachment"], json: { read: !1, write: !0 } })], sd.prototype, "type", void 0), sd = KI = u([T("geoscene.form.elements.AttachmentElement")], sd);
const eF = sd;
let gw = class extends se {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d()], gw.prototype, "type", void 0), gw = u([T("geoscene.form.elements.inputs.Input")], gw);
const rm = gw;
let Py = class extends rm {
  constructor(t) {
    super(t), this.maxLength = null, this.minLength = 0;
  }
};
u([d({ type: Number, json: { write: !0 } })], Py.prototype, "maxLength", void 0), u([d({ type: Number, json: { write: !0 } })], Py.prototype, "minLength", void 0), Py = u([T("geoscene.form.elements.inputs.TextInput")], Py);
const Vk = Py;
var YI;
let vw = YI = class extends Vk {
  constructor(e) {
    super(e), this.type = "barcode-scanner";
  }
  clone() {
    return new YI({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["barcode-scanner"], json: { read: !1, write: !0 } })], vw.prototype, "type", void 0), vw = YI = u([T("geoscene.form.elements.inputs.BarcodeScannerInput")], vw);
const Zde = vw;
var QI;
let _h = QI = class extends rm {
  constructor(e) {
    super(e), this.noValueOptionLabel = null, this.showNoValueOption = !1, this.type = "combo-box";
  }
  clone() {
    return new QI({ showNoValueOption: this.showNoValueOption, noValueOptionLabel: this.noValueOptionLabel });
  }
};
u([d({ type: String, json: { write: !0 } })], _h.prototype, "noValueOptionLabel", void 0), u([d({ type: Boolean, json: { write: !0 } })], _h.prototype, "showNoValueOption", void 0), u([d({ type: ["combo-box"], json: { read: !1, write: !0 } })], _h.prototype, "type", void 0), _h = QI = u([T("geoscene.form.elements.inputs.ComboBoxInput")], _h);
const Kde = _h;
var XI;
function tF(e) {
  return e != null ? new Date(e) : null;
}
function nF(e) {
  return e ? e.getTime() : null;
}
let go = XI = class extends rm {
  constructor(e) {
    super(e), this.includeTime = !1, this.max = null, this.min = null, this.type = "datetime-picker";
  }
  readMax(e, t) {
    return tF(t.max);
  }
  writeMax(e, t) {
    t.max = nF(e);
  }
  readMin(e, t) {
    return tF(t.min);
  }
  writeMin(e, t) {
    t.min = nF(e);
  }
  clone() {
    return new XI({ includeTime: this.includeTime, max: this.max, min: this.min, type: this.type });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], go.prototype, "includeTime", void 0), u([d({ type: Date, json: { type: Number, write: !0 } })], go.prototype, "max", void 0), u([be("max")], go.prototype, "readMax", null), u([xe("max")], go.prototype, "writeMax", null), u([d({ type: Date, json: { type: Number, write: !0 } })], go.prototype, "min", void 0), u([be("min")], go.prototype, "readMin", null), u([xe("min")], go.prototype, "writeMin", null), u([d({ type: ["datetime-picker"], json: { read: !1, write: !0 } })], go.prototype, "type", void 0), go = XI = u([T("geoscene.form.elements.inputs.DateTimePickerInput")], go);
const Yde = go;
var eM;
let Sh = eM = class extends rm {
  constructor(e) {
    super(e), this.noValueOptionLabel = null, this.showNoValueOption = !1, this.type = "radio-buttons";
  }
  clone() {
    return new eM({ noValueOptionLabel: this.noValueOptionLabel, showNoValueOption: this.showNoValueOption });
  }
};
u([d({ type: String, json: { write: !0 } })], Sh.prototype, "noValueOptionLabel", void 0), u([d({ type: Boolean, json: { write: !0 } })], Sh.prototype, "showNoValueOption", void 0), u([d({ type: ["radio-buttons"], json: { read: !1, write: !0 } })], Sh.prototype, "type", void 0), Sh = eM = u([T("geoscene.form.elements.inputs.RadioButtonsInput")], Sh);
const Qde = Sh;
var tM;
let xh = tM = class extends rm {
  constructor(e) {
    super(e), this.offValue = null, this.onValue = null, this.type = "switch";
  }
  clone() {
    return new tM({ offValue: this.offValue, onValue: this.onValue });
  }
};
u([d({ type: [String, Number], json: { write: !0 } })], xh.prototype, "offValue", void 0), u([d({ type: [String, Number], json: { write: !0 } })], xh.prototype, "onValue", void 0), u([d({ type: ["switch"], json: { read: !1, write: !0 } })], xh.prototype, "type", void 0), xh = tM = u([T("geoscene.form.elements.inputs.SwitchInput")], xh);
const Xde = xh;
var nM;
let bw = nM = class extends Vk {
  constructor(e) {
    super(e), this.type = "text-area";
  }
  clone() {
    return new nM({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["text-area"], json: { read: !1, write: !0 } })], bw.prototype, "type", void 0), bw = nM = u([T("geoscene.form.elements.inputs.TextAreaInput")], bw);
const epe = bw;
var rM;
let ww = rM = class extends Vk {
  constructor(e) {
    super(e), this.type = "text-box";
  }
  clone() {
    return new rM({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["text-box"], json: { read: !1, write: !0 } })], ww.prototype, "type", void 0), ww = rM = u([T("geoscene.form.elements.inputs.TextBoxInput")], ww);
const tpe = ww, npe = { base: rm, key: "type", typeMap: { "barcode-scanner": Zde, "combo-box": Kde, "datetime-picker": Yde, "radio-buttons": Qde, switch: Xde, "text-area": epe, "text-box": tpe } };
var iM;
let $s = iM = class extends Ef {
  constructor(e) {
    super(e), this.domain = null, this.editable = !0, this.editableExpression = null, this.fieldName = null, this.hint = null, this.input = null, this.requiredExpression = null, this.type = "field", this.valueExpression = null;
  }
  clone() {
    return new iM({ description: this.description, domain: this.domain, editable: this.editable, editableExpression: this.editableExpression, fieldName: this.fieldName, hint: this.hint, input: this.input, label: this.label, requiredExpression: this.requiredExpression, valueExpression: this.valueExpression, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ types: mV, json: { read: { reader: pk }, write: !0 } })], $s.prototype, "domain", void 0), u([d({ type: Boolean, json: { write: !0 } })], $s.prototype, "editable", void 0), u([d({ type: String, json: { write: !0 } })], $s.prototype, "editableExpression", void 0), u([d({ type: String, json: { write: !0 } })], $s.prototype, "fieldName", void 0), u([d({ type: String, json: { write: !0 } })], $s.prototype, "hint", void 0), u([d({ types: npe, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], $s.prototype, "input", void 0), u([d({ type: String, json: { write: !0 } })], $s.prototype, "requiredExpression", void 0), u([d({ type: String, json: { read: !1, write: !0 } })], $s.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], $s.prototype, "valueExpression", void 0), $s = iM = u([T("geoscene.form.elements.FieldElement")], $s);
const rF = $s;
var sM;
let rl = sM = class extends Ef {
  constructor(e) {
    super(e), this.displayCount = null, this.displayType = "list", this.editable = !0, this.orderByFields = null, this.relationshipId = null, this.type = "relationship";
  }
  clone() {
    return new sM({ description: this.description, displayCount: this.displayCount, displayType: this.displayType, editable: this.editable, label: this.label, orderByFields: q(this.orderByFields), relationshipId: this.relationshipId, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ type: Number, json: { write: !0 } })], rl.prototype, "displayCount", void 0), u([d({ type: ["list"], json: { write: !0 } })], rl.prototype, "displayType", void 0), u([d({ type: Boolean, json: { write: !0 } })], rl.prototype, "editable", void 0), u([d({ type: [X6], json: { write: !0 } })], rl.prototype, "orderByFields", void 0), u([d({ type: Number, json: { write: !0 } })], rl.prototype, "relationshipId", void 0), u([d({ type: ["relationship"], json: { read: !1, write: !0 } })], rl.prototype, "type", void 0), rl = sM = u([T("geoscene.form.elements.RelationshipElement")], rl);
const iF = rl;
function R7(e) {
  return { typesWithGroup: { base: Ef, key: "type", typeMap: { attachment: eF, field: rF, group: e, relationship: iF } }, typesWithoutGroup: { base: Ef, key: "type", typeMap: { attachment: eF, field: rF, relationship: iF } } };
}
function L7(e, t, n = !0) {
  if (!e)
    return null;
  const r = n ? t.typesWithGroup.typeMap : t.typesWithoutGroup.typeMap;
  return e.filter((i) => r[i.type]).map((i) => r[i.type].fromJSON(i));
}
function F7(e, t, n = !0) {
  if (!e)
    return null;
  const r = n ? t.typesWithGroup.typeMap : t.typesWithoutGroup.typeMap;
  return e.filter((i) => r[i.type]).map((i) => i.toJSON());
}
function N7(e, t, n = !0) {
  return e ? e.map((r) => Ia(n ? t.typesWithGroup : t.typesWithoutGroup, r)) : null;
}
var oM;
let ca = oM = class extends Ef {
  constructor(e) {
    super(e), this.elements = null, this.initialState = "expanded", this.type = "group";
  }
  castElements(e) {
    return N7(e, wx, !1);
  }
  readElements(e, t) {
    return L7(t.formElements, wx, !1);
  }
  writeElements(e, t) {
    t.formElements = F7(e, wx, !1);
  }
  clone() {
    return new oM({ description: this.description, elements: q(this.elements), initialState: this.initialState, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ json: { write: !0 } })], ca.prototype, "elements", void 0), u([mt("elements")], ca.prototype, "castElements", null), u([be("elements", ["formElements"])], ca.prototype, "readElements", null), u([xe("elements")], ca.prototype, "writeElements", null), u([d({ type: ["collapsed", "expanded"], json: { write: !0 } })], ca.prototype, "initialState", void 0), u([d({ type: String, json: { read: !1, write: !0 } })], ca.prototype, "type", void 0), ca = oM = u([T("geoscene.form.elements.GroupElement")], ca);
const wx = R7(ca), rpe = ca;
var aM;
const _x = R7(rpe);
let ia = aM = class extends se {
  constructor(e) {
    super(e), this.description = null, this.elements = null, this.expressionInfos = null, this.title = null;
  }
  castElements(e) {
    return N7(e, _x);
  }
  readElements(e, t) {
    return L7(t.formElements, _x);
  }
  writeElements(e, t) {
    t.formElements = F7(e, _x);
  }
  clone() {
    return new aM({ description: this.description, expressionInfos: q(this.expressionInfos), elements: q(this.elements), title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], ia.prototype, "description", void 0), u([d({ json: { write: !0 } })], ia.prototype, "elements", void 0), u([mt("elements")], ia.prototype, "castElements", null), u([be("elements", ["formElements"])], ia.prototype, "readElements", null), u([xe("elements")], ia.prototype, "writeElements", null), u([d({ type: [Hde], json: { write: !0 } })], ia.prototype, "expressionInfos", void 0), u([d({ type: String, json: { write: !0 } })], ia.prototype, "title", void 0), ia = aM = u([T("geoscene.form.FormTemplate")], ia);
const ipe = ia;
var Ry;
const i_ = $r()({ orthometric: "gravity-related-height", gravity_related_height: "gravity-related-height", ellipsoidal: "ellipsoidal" }), D7 = i_.jsonValues.slice();
ED(D7, "orthometric");
const lg = $r()({ meter: "meters", foot: "feet", "us-foot": "us-feet", "clarke-foot": "clarke-feet", "clarke-yard": "clarke-yards", "clarke-link": "clarke-links", "sears-yard": "sears-yards", "sears-foot": "sears-feet", "sears-chain": "sears-chains", "benoit-1895-b-chain": "benoit-1895-b-chains", "indian-yard": "indian-yards", "indian-1937-yard": "indian-1937-yards", "gold-coast-foot": "gold-coast-feet", "sears-1922-truncated-chain": "sears-1922-truncated-chains", "50-kilometers": "50-kilometers", "150-kilometers": "150-kilometers" });
let vo = Ry = class extends se {
  constructor(e) {
    super(e), this.heightModel = "gravity-related-height", this.heightUnit = "meters", this.vertCRS = null;
  }
  writeHeightModel(e, t, n) {
    return i_.write(e, t, n);
  }
  readHeightModel(e, t, n) {
    return i_.read(e) || (n && n.messages && n.messages.push(spe(e, { context: n })), null);
  }
  readHeightUnit(e, t, n) {
    return lg.read(e) || (n && n.messages && n.messages.push(sF(e, { context: n })), null);
  }
  readHeightUnitService(e, t, n) {
    return Nj(e) || lg.read(e) || (n && n.messages && n.messages.push(sF(e, { context: n })), null);
  }
  readVertCRS(e, t) {
    return t.vertCRS || t.ellipsoid || t.geoid;
  }
  clone() {
    return new Ry({ heightModel: this.heightModel, heightUnit: this.heightUnit, vertCRS: this.vertCRS });
  }
  equals(e) {
    return !!e && (this === e || this.heightModel === e.heightModel && this.heightUnit === e.heightUnit && this.vertCRS === e.vertCRS);
  }
  static deriveUnitFromSR(e, t) {
    const n = kte(t);
    return new Ry({ heightModel: e.heightModel, heightUnit: n, vertCRS: e.vertCRS });
  }
  write(e, t) {
    return t = { origin: "web-scene", ...t }, super.write(e, t);
  }
  static fromJSON(e) {
    if (!e)
      return null;
    const t = new Ry();
    return t.read(e, { origin: "web-scene" }), t;
  }
};
function sF(e, t) {
  return new Ds("height-unit:unsupported", `Height unit of value '${e}' is not supported`, t);
}
function spe(e, t) {
  return new Ds("height-model:unsupported", `Height model of value '${e}' is not supported`, t);
}
u([d({ type: i_.apiValues, constructOnly: !0, json: { origins: { "web-scene": { type: D7, default: "ellipsoidal" } } } })], vo.prototype, "heightModel", void 0), u([xe("web-scene", "heightModel")], vo.prototype, "writeHeightModel", null), u([be(["web-scene", "service"], "heightModel")], vo.prototype, "readHeightModel", null), u([d({ type: lg.apiValues, constructOnly: !0, json: { origins: { "web-scene": { type: lg.jsonValues, write: lg.write } } } })], vo.prototype, "heightUnit", void 0), u([be("web-scene", "heightUnit")], vo.prototype, "readHeightUnit", null), u([be("service", "heightUnit")], vo.prototype, "readHeightUnitService", null), u([d({ type: String, constructOnly: !0, json: { origins: { "web-scene": { write: !0 } } } })], vo.prototype, "vertCRS", void 0), u([be("service", "vertCRS", ["vertCRS", "ellipsoid", "geoid"])], vo.prototype, "readVertCRS", null), vo = Ry = u([T("geoscene.geometry.HeightModelInfo")], vo);
const OS = vo;
function oF(e, t, n) {
  if (e.hasM == null || e.hasZ)
    for (const r of t)
      for (const i of r)
        i.length > 2 && (i[2] *= n);
}
function ope(e, t, n) {
  if (!e && !t || !n)
    return;
  const r = bf(n);
  aF(e, n, r), aF(t, n, r);
}
function aF(e, t, n) {
  if (e)
    for (const r of e)
      ape(r.geometry, t, n);
}
function ape(e, t, n) {
  if (H(e) || !e.spatialReference || Oi(e.spatialReference, t))
    return;
  const r = bf(e.spatialReference) / n;
  if (r !== 1) {
    if ("x" in e)
      e.z != null && (e.z *= r);
    else if ("rings" in e)
      oF(e, e.rings, r);
    else if ("paths" in e)
      oF(e, e.paths, r);
    else if ("points" in e && (e.hasM == null || e.hasZ))
      for (const i of e.points)
        i.length > 2 && (i[2] *= r);
  }
}
let lpe = 0;
const Sx = we.getLogger("geoscene.layers.graphics.sources.MemorySource");
let bu = class extends Ol.LoadableMixin(Z_($p(Ne))) {
  constructor(t) {
    super(t), this._idToClientGraphic = null, this.type = "memory";
  }
  load(t) {
    const n = O(t) ? t.signal : null;
    return this.addResolvingPromise(this._startWorker(n)), Promise.resolve(this);
  }
  destroy() {
    var t;
    (t = this._connection) == null || t.close(), this._connection = null;
  }
  get workerGeometryType() {
    var t;
    const n = (t = this.layer) == null ? void 0 : t.geometryType;
    return n ? this._geometryTypeRequiresClientGraphicMapping(n) ? "polygon" : n : null;
  }
  applyEdits(t) {
    return this.load().then(() => this._applyEdits(t));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(t, n = {}) {
    await this.load(n);
    const r = await this._connection.invoke("queryFeatures", t ? t.toJSON() : null, n);
    H1(t, this.layer.spatialReference, r);
    const i = kp.fromJSON(r);
    if (!this._requiresClientGraphicMapping())
      return i;
    const s = this.layer.objectIdField;
    for (const o of i.features) {
      const a = o.attributes[s], l = this._idToClientGraphic.get(a);
      l && (o.geometry = l.geometry);
    }
    return i.geometryType = this.layer.geometryType, i;
  }
  async queryFeaturesJSON(t, n = {}) {
    if (this._requiresClientGraphicMapping())
      throw new D("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(n);
    const r = await this._connection.invoke("queryFeatures", t ? t.toJSON() : null, n);
    return H1(t, this.layer.spatialReference, r), r;
  }
  queryFeatureCount(t, n = {}) {
    return this.load(n).then(() => this._connection.invoke("queryFeatureCount", t ? t.toJSON() : null, n));
  }
  queryObjectIds(t, n = {}) {
    return this.load(n).then(() => this._connection.invoke("queryObjectIds", t ? t.toJSON() : null, n));
  }
  queryExtent(t, n = {}) {
    return this.load(n).then(() => this._connection.invoke("queryExtent", t ? t.toJSON() : null, n)).then((r) => ({ count: r.count, extent: Mt.fromJSON(r.extent) }));
  }
  querySnapping(t, n = {}) {
    return this.load(n).then(() => this._connection.invoke("querySnapping", t, n));
  }
  async _applyEdits(t) {
    if (!this._connection)
      throw new D("feature-layer-source:edit-failure", "Memory source not loaded");
    const n = this.layer.objectIdField;
    let r = null;
    const i = [], s = [];
    await Promise.all([this._prepareClientMapping(t.addFeatures, null), this._prepareClientMapping(t.updateFeatures, null)]);
    const o = (p) => "objectId" in p && p.objectId != null ? p.objectId : "attributes" in p && p.attributes[n] != null ? p.attributes[n] : null;
    if (t.addFeatures && (r = this._prepareAddFeatures(t.addFeatures)), t.deleteFeatures)
      for (const p of t.deleteFeatures) {
        const f = o(p);
        f != null && i.push(f);
      }
    const a = t.updateFeatures && this._idToClientGraphic ? /* @__PURE__ */ new Map() : null;
    if (t.updateFeatures) {
      for (const p of t.updateFeatures)
        if (s.push(this._serializeFeature(p)), a) {
          const f = o(p);
          f != null && a.set(f, p);
        }
    }
    ope(r ? r.features : null, s, this.layer.spatialReference);
    const { fullExtent: l, featureEditResults: c } = await this._connection.invoke("applyEdits", { adds: r ? r.features : [], updates: s, deletes: i });
    return this.fullExtent = l, r && r.finish(c.uidToObjectId), this._updateClientGraphicIds(a, c), this._createEditsResult(c);
  }
  async _prepareClientMapping(t, n) {
    if (this.layerOrSourceGeometryType !== "mesh" || H(t))
      return;
    const r = [];
    for (const { geometry: i } of t)
      !O(i) || i.type !== "mesh" || i.hasExtent || i.loaded || r.push(i.load({ signal: n }));
    r.length && await Promise.all(r);
  }
  _updateClientGraphicIds(t, n) {
    if (this._idToClientGraphic) {
      if (t)
        for (const r of n.updateResults) {
          if (!r.success)
            continue;
          const i = t.get(r.objectId);
          i != null && this._addIdToClientGraphic(i);
        }
      for (const r of n.deleteResults)
        r.success && this._idToClientGraphic.delete(r.objectId);
    }
  }
  _createEditsResult(t) {
    return { addFeatureResults: t.addResults ? t.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: t.updateResults ? t.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: t.deleteResults ? t.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(t) {
    const n = t.success === !0 ? null : t.error || { code: void 0, description: void 0 };
    return { objectId: t.objectId, globalId: t.globalId, error: n ? new D("feature-layer-source:edit-failure", n.description, { code: n.code }) : null };
  }
  _prepareAddFeatures(t) {
    const n = /* @__PURE__ */ new Map(), r = new Array(t.length);
    let i = null;
    for (let o = 0; o < t.length; o++) {
      const a = t[o], l = this._serializeFeature(a);
      !i && O(a.geometry) && (i = a.geometry.type), r[o] = l, n.set(`${l.uid}`, a);
    }
    const s = this;
    return { features: r, inferredGeometryType: i, finish(o) {
      const a = s.sourceJSON.objectIdField;
      for (const l in o) {
        const c = o[l], p = n.get(l);
        p && (p.attributes || (p.attributes = {}), c === -1 ? delete p.attributes[a] : p.attributes[a] = c, s._addIdToClientGraphic(p));
      }
    } };
  }
  _addIdToClientGraphic(t) {
    if (!this._idToClientGraphic)
      return;
    const n = this.sourceJSON.objectIdField, r = t.attributes && t.attributes[n];
    r != null && this._idToClientGraphic.set(r, t);
  }
  get layerOrSourceGeometryType() {
    var t, n, r;
    return (t = (n = this.layer) == null ? void 0 : n.geometryType) != null ? t : (r = this.sourceJSON) == null ? void 0 : r.geometryType;
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this.layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(t) {
    return this._geometryTypeRequiresClientGraphicMapping(t.type);
  }
  _geometryTypeRequiresClientGraphicMapping(t) {
    return t === "mesh" || t === "multipatch" || t === "extent";
  }
  _serializeFeature(t) {
    const { attributes: n } = t, r = this._geometryForSerialization(t), i = (lpe++).toString();
    return r ? { uid: i, geometry: r.toJSON(), attributes: n } : { uid: i, attributes: n };
  }
  _geometryForSerialization(t) {
    const { geometry: n } = t;
    return H(n) ? null : this._geometryRequiresClientGraphicMapping(n) ? n.extent ? Po.fromExtent(n.extent) : null : n;
  }
  async _startWorker(t) {
    this._connection = await _te("MemorySourceWorker", { strategy: K("feature-layers-workers") ? "dedicated" : "local", signal: t });
    const { fields: n, spatialReference: r, objectIdField: i, hasM: s, hasZ: o, timeInfo: a } = this.layer, l = this.layer.originOf("spatialReference") === "defaults";
    await this._prepareClientMapping(this.items, t);
    const c = this._prepareAddFeatures(this.items);
    this.handles.add(this.on("before-changes", (y) => {
      Sx.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), y.preventDefault();
    }));
    const p = { features: c.features, fields: n && n.map((y) => y.toJSON()), geometryType: yP.toJSON(this.workerGeometryType), hasM: this.layerOrSourceGeometryType !== "mesh" && s, hasZ: this.layerOrSourceGeometryType === "mesh" || o, objectIdField: i, spatialReference: l ? null : r && r.toJSON(), timeInfo: a ? a.toJSON() : null }, f = await this._connection.invoke("load", p, { signal: t });
    for (const y of f.warnings)
      Sx.warn(y.message, { layer: this.layer, warning: y });
    f.featureErrors.length && Sx.warn(`Encountered ${f.featureErrors.length} validation errors while loading features`, f.featureErrors);
    const m = f.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(c.inferredGeometryType) && (m.geometryType = yP.toJSON(c.inferredGeometryType)), this.sourceJSON = m, this._requiresClientGraphicMapping() && (this._idToClientGraphic = /* @__PURE__ */ new Map()), c.finish(f.assignedObjectIds);
  }
};
u([QC({ Type: Jt, ensureType: kn(Jt) })], bu.prototype, "itemType", void 0), u([d()], bu.prototype, "type", void 0), u([d({ constructOnly: !0 })], bu.prototype, "layer", void 0), u([d({ readOnly: !0 })], bu.prototype, "workerGeometryType", null), u([d()], bu.prototype, "sourceJSON", void 0), bu = u([T("geoscene.layers.graphics.sources.MemorySource")], bu);
const lF = bu;
function upe(e) {
  return "portalItem" in e;
}
const cpe = (e) => {
  let t = class extends e {
    get apiKey() {
      var n;
      return this._isOverridden("apiKey") ? this._get("apiKey") : upe(this) ? (n = this.portalItem) == null ? void 0 : n.apiKey : null;
    }
    set apiKey(n) {
      n != null ? this._override("apiKey", n) : (this._clearOverride("apiKey"), this.clear("apiKey", "user"));
    }
  };
  return u([d({ type: String })], t.prototype, "apiKey", null), t = u([T("geoscene.layers.mixins.APIKeyMixin")], t), t;
}, j7 = { mapserver: "MapServer", imageserver: "ImageServer", featureserver: "FeatureServer", sceneserver: "SceneServer", streamserver: "StreamServer", vectortileserver: "VectorTileServer" }, V7 = Object.values(j7), z7 = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/rest\\/services\\/(.+?)\\/(${V7.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), dpe = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/([^\\/\\n]+)\\/(${V7.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), ppe = /(.*?)\/(?:layers\/)?(\d+)\/?$/i;
function NFe(e) {
  return !!z7.test(e);
}
function z0(e) {
  const t = cr(e), n = t.path.match(z7) || t.path.match(dpe);
  if (!n)
    return null;
  const [, r, i, s, o] = n, a = i.indexOf("/");
  return { title: zk(a !== -1 ? i.slice(a + 1) : i), serverType: j7[s.toLowerCase()], sublayer: o != null && o !== "" ? parseInt(o, 10) : null, url: { path: r } };
}
function hpe(e) {
  const t = cr(e).path.match(ppe);
  return t ? { serviceUrl: t[1], sublayerId: Number(t[2]) } : null;
}
function zk(e) {
  return (e = e.replace(/\s*[/_]+\s*/g, " "))[0].toUpperCase() + e.slice(1);
}
function fpe(e, t) {
  const n = [];
  if (e) {
    const r = z0(e);
    O(r) && r.title && n.push(r.title);
  }
  if (t) {
    const r = zk(t);
    n.push(r);
  }
  if (n.length === 2) {
    if (n[0].toLowerCase().indexOf(n[1].toLowerCase()) !== -1)
      return n[0];
    if (n[1].toLowerCase().indexOf(n[0].toLowerCase()) !== -1)
      return n[1];
  }
  return n.join(" - ");
}
function B7(e) {
  if (!e)
    return !1;
  const t = ".arcgis.com/", n = "//services", r = "//tiles", i = "//features", s = (e = e.toLowerCase()).indexOf(t) !== -1, o = e.indexOf(n) !== -1 || e.indexOf(r) !== -1 || e.indexOf(i) !== -1;
  return s && o;
}
function mpe(e, t) {
  return e && U8(q8(e, t));
}
function ype(e) {
  let { url: t } = e;
  if (!t)
    return { url: t };
  t = q8(t, e.logger);
  const n = cr(t), r = z0(n.path);
  let i;
  if (O(r))
    r.sublayer != null && e.layer.layerId == null && (i = r.sublayer), t = r.url.path;
  else if (e.nonStandardUrlAllowed) {
    const s = hpe(n.path);
    O(s) && (t = s.serviceUrl, i = s.sublayerId);
  }
  return { url: U8(t), layerId: i };
}
function gpe(e, t, n, r, i) {
  lp(t, r, "url", i), r.url && e.layerId != null && (r.url = Xu(r.url, n, e.layerId.toString()));
}
function DFe(e) {
  if (!e)
    return !1;
  const t = e.toLowerCase(), n = t.indexOf("/services/") !== -1, r = t.indexOf("/mapserver/wmsserver") !== -1, i = t.indexOf("/imageserver/wmsserver") !== -1, s = t.indexOf("/wmsserver") !== -1;
  return n && (r || i || s);
}
const vpe = (e) => {
  let t = class extends e {
    get title() {
      if (this._get("title") && this.originOf("title") !== "defaults")
        return this._get("title");
      if (this.url) {
        const n = z0(this.url);
        if (O(n) && n.title)
          return n.title;
      }
      return this._get("title") || "";
    }
    set title(n) {
      this._set("title", n);
    }
    set url(n) {
      this._set("url", mpe(n, we.getLogger(this.declaredClass)));
    }
  };
  return u([d()], t.prototype, "title", null), u([d({ type: String })], t.prototype, "url", null), t = u([T("geoscene.layers.mixins.ArcGISService")], t), t;
};
function Bk() {
  const e = new Float32Array(16);
  return e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;
}
Bk();
const bpe = (e, t) => {
  const n = Cp(e, t, 0, 0, 0, 0, t, 0, 0, 0, 0, t, 0, 0, 0, 0, 1);
  return gc(n, n);
}, wpe = (e, t) => {
  const n = Cp(e, t, 0, 0, 0.5 - 0.5 * t, 0, t, 0, 0.5 - 0.5 * t, 0, 0, t, 0.5 - 0.5 * t, 0, 0, 0, 1);
  return gc(n, n);
}, _pe = (e, t) => {
  const n = 1 - t, r = Cp(e, 0.2126 + 0.7874 * n, 0.7152 - 0.7152 * n, 0.0722 - 0.0722 * n, 0, 0.2126 - 0.2126 * n, 0.7152 + 0.2848 * n, 0.0722 - 0.0722 * n, 0, 0.2126 - 0.2126 * n, 0.7152 - 0.7152 * n, 0.0722 + 0.9278 * n, 0, 0, 0, 0, 1);
  return gc(r, r);
}, Spe = (e, t) => {
  const n = Math.sin(t * Math.PI / 180), r = Math.cos(t * Math.PI / 180), i = Cp(e, 0.213 + 0.787 * r - 0.213 * n, 0.715 - 0.715 * r - 0.715 * n, 0.072 - 0.072 * r + 0.928 * n, 0, 0.213 - 0.213 * r + 0.143 * n, 0.715 + 0.285 * r + 0.14 * n, 0.072 - 0.072 * r - 0.283 * n, 0, 0.213 - 0.213 * r - 0.787 * n, 0.715 - 0.715 * r + 0.715 * n, 0.072 + 0.928 * r + 0.072 * n, 0, 0, 0, 0, 1);
  return gc(i, i);
}, xpe = (e, t) => {
  const n = 1 - 2 * t, r = Cp(e, n, 0, 0, t, 0, n, 0, t, 0, 0, n, t, 0, 0, 0, 1);
  return gc(r, r);
}, $pe = (e, t) => {
  const n = Cp(e, 0.213 + 0.787 * t, 0.715 - 0.715 * t, 0.072 - 0.072 * t, 0, 0.213 - 0.213 * t, 0.715 + 0.285 * t, 0.072 - 0.072 * t, 0, 0.213 - 0.213 * t, 0.715 - 0.715 * t, 0.072 + 0.928 * t, 0, 0, 0, 0, 1);
  return gc(n, n);
}, Tpe = (e, t) => {
  const n = 1 - t, r = Cp(e, 0.393 + 0.607 * n, 0.769 - 0.769 * n, 0.189 - 0.189 * n, 0, 0.349 - 0.349 * n, 0.686 + 0.314 * n, 0.168 - 0.168 * n, 0, 0.272 - 0.272 * n, 0.534 - 0.534 * n, 0.131 + 0.869 * n, 0, 0, 0, 0, 1);
  return gc(r, r);
};
let U7 = class q7 {
  constructor(t, n, r) {
    this.strength = t, this.radius = n, this.threshold = r, this.type = "bloom";
  }
  interpolate(t, n, r) {
    this.strength = gi(t.strength, n.strength, r), this.radius = gi(t.radius, n.radius, r), this.threshold = gi(t.threshold, n.threshold, r);
  }
  clone() {
    return new q7(this.strength, this.radius, this.threshold);
  }
  toJSON() {
    return { type: "bloom", radius: ug(this.radius), strength: this.strength, threshold: this.threshold };
  }
}, G7 = class W7 {
  constructor(t) {
    this.radius = t, this.type = "blur";
  }
  interpolate(t, n, r) {
    this.radius = Math.round(gi(t.radius, n.radius, r));
  }
  clone() {
    return new W7(this.radius);
  }
  toJSON() {
    return { type: "blur", radius: ug(this.radius) };
  }
}, lM = class H7 {
  constructor(t, n) {
    this.type = t, this.amount = n, this.type !== "invert" && this.type !== "grayscale" && this.type !== "sepia" || (this.amount = Math.min(this.amount, 1));
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t, n, r) {
    this.amount = gi(t.amount, n.amount, r), this._updateMatrix();
  }
  clone() {
    return new H7(this.type, this.amount);
  }
  toJSON() {
    return { type: this.type, amount: this.amount };
  }
  _updateMatrix() {
    const t = this._colorMatrix || Bk();
    switch (this.type) {
      case "brightness":
        this._colorMatrix = bpe(t, this.amount);
        break;
      case "contrast":
        this._colorMatrix = wpe(t, this.amount);
        break;
      case "grayscale":
        this._colorMatrix = _pe(t, this.amount);
        break;
      case "invert":
        this._colorMatrix = xpe(t, this.amount);
        break;
      case "saturate":
        this._colorMatrix = $pe(t, this.amount);
        break;
      case "sepia":
        this._colorMatrix = Tpe(t, this.amount);
    }
  }
}, J7 = class Z7 {
  constructor(t, n, r, i) {
    this.offsetX = t, this.offsetY = n, this.blurRadius = r, this.color = i, this.type = "drop-shadow";
  }
  interpolate(t, n, r) {
    this.offsetX = gi(t.offsetX, n.offsetX, r), this.offsetY = gi(t.offsetY, n.offsetY, r), this.blurRadius = gi(t.blurRadius, n.blurRadius, r), this.color[0] = Math.round(gi(t.color[0], n.color[0], r)), this.color[1] = Math.round(gi(t.color[1], n.color[1], r)), this.color[2] = Math.round(gi(t.color[2], n.color[2], r)), this.color[3] = gi(t.color[3], n.color[3], r);
  }
  clone() {
    return new Z7(this.offsetX, this.offsetY, this.blurRadius, [...this.color]);
  }
  toJSON() {
    const t = [...this.color];
    return t[3] *= 255, { type: "drop-shadow", xoffset: ug(this.offsetX), yoffset: ug(this.offsetY), blurRadius: ug(this.blurRadius), color: t };
  }
}, K7 = class Y7 {
  constructor(t) {
    this.angle = t, this.type = "hue-rotate";
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t, n, r) {
    this.angle = gi(t.angle, n.angle, r), this._updateMatrix();
  }
  clone() {
    return new Y7(this.angle);
  }
  toJSON() {
    return { type: "hue-rotate", angle: this.angle };
  }
  _updateMatrix() {
    const t = this._colorMatrix || Bk();
    this._colorMatrix = Spe(t, this.angle);
  }
}, Q7 = class X7 {
  constructor(t) {
    this.amount = t, this.type = "opacity", this.amount = Math.min(this.amount, 1);
  }
  interpolate(t, n, r) {
    this.amount = gi(t.amount, n.amount, r);
  }
  clone() {
    return new X7(this.amount);
  }
  toJSON() {
    return { type: "opacity", amount: this.amount };
  }
};
function gi(e, t, n) {
  return e + (t - e) * n;
}
function ug(e) {
  return Math.round(1e3 * rc(e)) / 1e3;
}
function Epe(e) {
  switch (e.type) {
    case "grayscale":
    case "sepia":
    case "invert":
      return new lM(e.type, 0);
    case "saturate":
    case "brightness":
    case "contrast":
      return new lM(e.type, 1);
    case "opacity":
      return new Q7(1);
    case "hue-rotate":
      return new K7(0);
    case "blur":
      return new G7(0);
    case "drop-shadow":
      return new J7(0, 0, 0, [...pO("transparent")]);
    case "bloom":
      return new U7(0, 0, 1);
  }
}
function Ipe(e, t) {
  const n = e.length > t.length ? e : t;
  return (e.length > t.length ? t : e).every((r, i) => r.type === n[i].type);
}
function Mpe(e, t) {
  const n = e.length > t.length ? e : t, r = e.length > t.length ? t : e;
  for (let i = r.length; i < n.length; i++)
    r.push(Epe(n[i]));
}
function Cpe(e) {
  const t = e[0];
  return !!t && "type" in t;
}
var uF, cF, eB = { exports: {} };
function tB(e) {
  if (!e || e.length === 0)
    return null;
  if (typeof e == "string") {
    const n = dF(e);
    return n && n.length !== 0 ? n : null;
  }
  const t = e.map((n) => {
    if (!Number.isFinite(n.scale) || n.scale <= 0)
      throw new D("effect:invalid-scale", "scale must be finite and greater than 0", { stop: n });
    return { scale: n.scale, effects: dF(n.value) };
  });
  t.sort((n, r) => r.effects.length - n.effects.length);
  for (let n = 0; n < t.length - 1; n++) {
    if (!Ipe(t[n].effects, t[n + 1].effects))
      throw new D("effect:interpolation-impossible", "Cannot interpolate by scale between 2 lists of mixed effects", { a: t[n].effects, b: t[n + 1].effects });
    Mpe(t[n].effects, t[n + 1].effects);
  }
  return t.sort((n, r) => r.scale - n.scale), t;
}
function dF(e) {
  let t;
  if (!e)
    return [];
  try {
    t = eB.exports.parse(e);
  } catch (n) {
    throw new D("effect:invalid-syntax", "Invalid effect syntax", { value: e, error: n });
  }
  return t.map((n) => Ope(n));
}
function Ope(e) {
  try {
    switch (e.name) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
        return kpe(e);
      case "opacity":
        return Ape(e);
      case "hue-rotate":
        return Ppe(e);
      case "blur":
        return Rpe(e);
      case "drop-shadow":
        return Lpe(e);
      case "bloom":
        return Fpe(e);
    }
  } catch (t) {
    throw t.details.filter = e, t;
  }
  throw new D("effect:unknown-effect", `Effect '${e.name}' is not supported`, { effect: e });
}
function kpe(e) {
  let t = 1;
  return im(e.parameters, 1), e.parameters.length === 1 && (t = So(e.parameters[0])), new lM(e.name, t);
}
function Ape(e) {
  let t = 1;
  return im(e.parameters, 1), e.parameters.length === 1 && (t = So(e.parameters[0])), new Q7(t);
}
function Ppe(e) {
  let t = 0;
  return im(e.parameters, 1), e.parameters.length === 1 && (t = Bpe(e.parameters[0])), new K7(t);
}
function Rpe(e) {
  let t = 0;
  return im(e.parameters, 1), e.parameters.length === 1 && (t = Gk(e.parameters[0]), B0(t, e.parameters[0])), new G7(t);
}
function Lpe(e) {
  const t = [];
  let n = null;
  for (const r of e.parameters)
    if (r.type === "color") {
      if (t.length && Object.freeze(t), n)
        throw new D("effect:type-error", "Accepts only one color", {});
      n = Upe(r);
    } else {
      const i = Gk(r);
      if (Object.isFrozen(t))
        throw new D("effect:type-error", "<length> parameters not consecutive", { lengths: t });
      t.push(i), t.length === 3 && B0(i, r);
    }
  if (t.length < 2 || t.length > 3)
    throw new D("effect:type-error", `Expected <length>{2,3}, Actual: <length>{${t.length}}`, { lengths: t });
  return new J7(t[0], t[1], t[2] || 0, n || nB("black"));
}
function Fpe(e) {
  let t = 1, n = 0, r = 0;
  return im(e.parameters, 3), e.parameters[0] && (t = So(e.parameters[0])), e.parameters[1] && (n = Gk(e.parameters[1]), B0(n, e.parameters[1])), e.parameters[2] && (r = So(e.parameters[2])), new U7(t, n, r);
}
function im(e, t) {
  if (e.length > t)
    throw new D("effect:type-error", `Function supports up to ${t} parameters, Actual: ${e.length}`, { parameters: e });
}
function kS(e) {
  if (e.type === "color")
    return "<color>";
  if (e.unit) {
    if (qk[e.unit])
      return "<length>";
    if (Uk[e.unit])
      return "<angle>";
    if (e.unit === "%")
      return "<percentage>";
  }
  return "<double>";
}
function B0(e, t) {
  if (e < 0)
    throw new D("effect:type-error", `Negative values are not allowed, Actual: ${e}`, { term: t });
}
function Npe(e) {
  if (e.type !== "quantity" || e.unit !== null)
    throw new D("effect:type-error", `Expected <double>, Actual: ${kS(e)}`, { term: e });
}
function Dpe(e) {
  if (e.type !== "quantity" || e.unit !== null && e.unit !== "%")
    throw new D("effect:type-error", `Expected <double> or <percentage>, Actual: ${kS(e)}`, { term: e });
}
cF = function() {
  function e(i, s) {
    function o() {
      this.constructor = i;
    }
    o.prototype = s.prototype, i.prototype = new o();
  }
  function t(i, s, o, a) {
    var l = Error.call(this, i);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = o, l.location = a, l.name = "SyntaxError", l;
  }
  function n(i, s, o) {
    return o = o || " ", i.length > s ? i : (s -= i.length, i + (o += o.repeat(s)).slice(0, s));
  }
  function r(i, s) {
    var o, a = {}, l = (s = s !== void 0 ? s : {}).grammarSource, c = { start: tA }, p = tA, f = "none", m = ")", y = ",", g = "(", v = "%", w = "px", b = "cm", S = "mm", $ = "in", I = "pt", M = "pc", E = "deg", C = "rad", A = "grad", W = "turn", j = "#", G = ".", R = "e", V = /^[ \t\n\r]/, Q = /^[a-z\-]/, de = /^[0-9a-fA-F]/, _e = /^[+\-]/, ie = /^[0-9]/, Ae = Na("none"), Pe = rr("none", !1), Bt = rr(")", !1), wt = rr(",", !1), Ut = Na("whitespace"), un = mm([" ", "	", `
`, "\r"], !1, !1), An = Na("function"), Pn = rr("(", !1), Un = Na("identifier"), Me = mm([["a", "z"], "-"], !1, !1), Ue = Na("percentage"), Xe = rr("%", !1), lt = Na("length"), Tt = rr("px", !1), bn = rr("cm", !1), tr = rr("mm", !1), Pi = rr("in", !1), ni = rr("pt", !1), Lr = rr("pc", !1), ri = Na("angle"), Fr = rr("deg", !1), Ri = rr("rad", !1), wn = rr("grad", !1), ii = rr("turn", !1), Nr = Na("number"), si = Na("color"), oi = rr("#", !1), pe = mm([["0", "9"], ["a", "f"], ["A", "F"]], !1, !1), qe = mm(["+", "-"], !1, !1), ht = mm([["0", "9"]], !1, !1), _n = rr(".", !1), Li = rr("e", !1), Zs = function() {
      return [];
    }, zo = function(k, Y) {
      return { type: "function", name: k, parameters: Y || [] };
    }, re = function(k, Y) {
      return Y.length > 0 ? wW(k, Y, 3) : [k];
    }, me = function(k) {
      return { type: "quantity", value: k.value, unit: k.unit };
    }, Ee = function(k) {
      return { type: "color", colorType: k.type, value: k.value };
    }, yt = function(k) {
      return k;
    }, Dr = function() {
      return nv();
    }, nr = function(k) {
      return { value: k, unit: "%" };
    }, Tr = function(k) {
      return { value: k, unit: "px" };
    }, pm = function(k) {
      return { value: k, unit: "cm" };
    }, jp = function(k) {
      return { value: k, unit: "mm" };
    }, hm = function(k) {
      return { value: k, unit: "in" };
    }, fm = function(k) {
      return { value: k, unit: "pt" };
    }, z = function(k) {
      return { value: k, unit: "pc" };
    }, ae = function(k) {
      return { value: k, unit: "deg" };
    }, Se = function(k) {
      return { value: k, unit: "rad" };
    }, Je = function(k) {
      return { value: k, unit: "grad" };
    }, pr = function(k) {
      return { value: k, unit: "turn" };
    }, Er = function(k) {
      return { value: k, unit: null };
    }, ai = function() {
      return { type: "hex", value: nv() };
    }, cs = function(k) {
      return { type: "function", value: k };
    }, li = function() {
      return { type: "named", value: nv() };
    }, Vp = function() {
      return parseFloat(nv());
    }, U = 0, ut = 0, ds = [{ line: 1, column: 1 }], Bo = 0, u2 = [], Ce = 0;
    if ("startRule" in s) {
      if (!(s.startRule in c))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      p = c[s.startRule];
    }
    function nv() {
      return i.substring(ut, U);
    }
    function rr(k, Y) {
      return { type: "literal", text: k, ignoreCase: Y };
    }
    function mm(k, Y, oe) {
      return { type: "class", parts: k, inverted: Y, ignoreCase: oe };
    }
    function lW() {
      return { type: "end" };
    }
    function Na(k) {
      return { type: "other", description: k };
    }
    function X3(k) {
      var Y, oe = ds[k];
      if (oe)
        return oe;
      for (Y = k - 1; !ds[Y]; )
        Y--;
      for (oe = { line: (oe = ds[Y]).line, column: oe.column }; Y < k; )
        i.charCodeAt(Y) === 10 ? (oe.line++, oe.column = 1) : oe.column++, Y++;
      return ds[k] = oe, oe;
    }
    function eA(k, Y) {
      var oe = X3(k), nt = X3(Y);
      return { source: l, start: { offset: k, line: oe.line, column: oe.column }, end: { offset: Y, line: nt.line, column: nt.column } };
    }
    function Ze(k) {
      U < Bo || (U > Bo && (Bo = U, u2 = []), u2.push(k));
    }
    function uW(k, Y, oe) {
      return new t(t.buildMessage(k, Y), k, Y, oe);
    }
    function tA() {
      var k;
      return (k = cW()) === a && (k = dW()), k;
    }
    function cW() {
      var k, Y;
      return Ce++, k = U, ir(), i.substr(U, 4) === f ? (Y = f, U += 4) : (Y = a, Ce === 0 && Ze(Pe)), Y !== a ? (ir(), ut = k, k = Zs()) : (U = k, k = a), Ce--, k === a && Ce === 0 && Ze(Ae), k;
    }
    function dW() {
      var k, Y;
      if (k = [], (Y = c2()) !== a)
        for (; Y !== a; )
          k.push(Y), Y = c2();
      else
        k = a;
      return k;
    }
    function c2() {
      var k, Y, oe, nt;
      return k = U, ir(), (Y = hW()) !== a ? (ir(), (oe = pW()) === a && (oe = null), ir(), i.charCodeAt(U) === 41 ? (nt = m, U++) : (nt = a, Ce === 0 && Ze(Bt)), nt !== a ? (ir(), ut = k, k = zo(Y, oe)) : (U = k, k = a)) : (U = k, k = a), k;
    }
    function pW() {
      var k, Y, oe, nt, hr, cn, hs, rv;
      if (k = U, (Y = d2()) !== a) {
        for (oe = [], nt = U, hr = ir(), i.charCodeAt(U) === 44 ? (cn = y, U++) : (cn = a, Ce === 0 && Ze(wt)), cn === a && (cn = null), hs = ir(), (rv = d2()) !== a ? nt = hr = [hr, cn, hs, rv] : (U = nt, nt = a); nt !== a; )
          oe.push(nt), nt = U, hr = ir(), i.charCodeAt(U) === 44 ? (cn = y, U++) : (cn = a, Ce === 0 && Ze(wt)), cn === a && (cn = null), hs = ir(), (rv = d2()) !== a ? nt = hr = [hr, cn, hs, rv] : (U = nt, nt = a);
        ut = k, k = re(Y, oe);
      } else
        U = k, k = a;
      return k;
    }
    function d2() {
      var k, Y;
      return k = U, (Y = fW()) === a && (Y = mW()) === a && (Y = yW()) === a && (Y = gW()), Y !== a && (ut = k, Y = me(Y)), (k = Y) === a && (k = U, (Y = vW()) !== a && (ut = k, Y = Ee(Y)), k = Y), k;
    }
    function ir() {
      var k, Y;
      for (Ce++, k = [], V.test(i.charAt(U)) ? (Y = i.charAt(U), U++) : (Y = a, Ce === 0 && Ze(un)); Y !== a; )
        k.push(Y), V.test(i.charAt(U)) ? (Y = i.charAt(U), U++) : (Y = a, Ce === 0 && Ze(un));
      return Ce--, Y = a, Ce === 0 && Ze(Ut), k;
    }
    function hW() {
      var k, Y, oe;
      return Ce++, k = U, (Y = nA()) !== a ? (i.charCodeAt(U) === 40 ? (oe = g, U++) : (oe = a, Ce === 0 && Ze(Pn)), oe !== a ? (ut = k, k = yt(Y)) : (U = k, k = a)) : (U = k, k = a), Ce--, k === a && (Y = a, Ce === 0 && Ze(An)), k;
    }
    function nA() {
      var k, Y, oe;
      if (Ce++, k = U, Y = [], Q.test(i.charAt(U)) ? (oe = i.charAt(U), U++) : (oe = a, Ce === 0 && Ze(Me)), oe !== a)
        for (; oe !== a; )
          Y.push(oe), Q.test(i.charAt(U)) ? (oe = i.charAt(U), U++) : (oe = a, Ce === 0 && Ze(Me));
      else
        Y = a;
      return Y !== a && (ut = k, Y = Dr()), Ce--, (k = Y) === a && (Y = a, Ce === 0 && Ze(Un)), k;
    }
    function fW() {
      var k, Y, oe;
      return Ce++, k = U, ir(), (Y = ps()) !== a ? (i.charCodeAt(U) === 37 ? (oe = v, U++) : (oe = a, Ce === 0 && Ze(Xe)), oe !== a ? (ut = k, k = nr(Y)) : (U = k, k = a)) : (U = k, k = a), Ce--, k === a && Ce === 0 && Ze(Ue), k;
    }
    function mW() {
      var k, Y, oe;
      return Ce++, k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === w ? (oe = w, U += 2) : (oe = a, Ce === 0 && Ze(Tt)), oe !== a ? (ut = k, k = Tr(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === b ? (oe = b, U += 2) : (oe = a, Ce === 0 && Ze(bn)), oe !== a ? (ut = k, k = pm(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === S ? (oe = S, U += 2) : (oe = a, Ce === 0 && Ze(tr)), oe !== a ? (ut = k, k = jp(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === $ ? (oe = $, U += 2) : (oe = a, Ce === 0 && Ze(Pi)), oe !== a ? (ut = k, k = hm(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === I ? (oe = I, U += 2) : (oe = a, Ce === 0 && Ze(ni)), oe !== a ? (ut = k, k = fm(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, ir(), (Y = ps()) !== a ? (i.substr(U, 2) === M ? (oe = M, U += 2) : (oe = a, Ce === 0 && Ze(Lr)), oe !== a ? (ut = k, k = z(Y)) : (U = k, k = a)) : (U = k, k = a)))))), Ce--, k === a && Ce === 0 && Ze(lt), k;
    }
    function yW() {
      var k, Y, oe;
      return Ce++, k = U, (Y = ps()) !== a ? (i.substr(U, 3) === E ? (oe = E, U += 3) : (oe = a, Ce === 0 && Ze(Fr)), oe !== a ? (ut = k, k = ae(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, (Y = ps()) !== a ? (i.substr(U, 3) === C ? (oe = C, U += 3) : (oe = a, Ce === 0 && Ze(Ri)), oe !== a ? (ut = k, k = Se(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, (Y = ps()) !== a ? (i.substr(U, 4) === A ? (oe = A, U += 4) : (oe = a, Ce === 0 && Ze(wn)), oe !== a ? (ut = k, k = Je(Y)) : (U = k, k = a)) : (U = k, k = a), k === a && (k = U, (Y = ps()) !== a ? (i.substr(U, 4) === W ? (oe = W, U += 4) : (oe = a, Ce === 0 && Ze(ii)), oe !== a ? (ut = k, k = pr(Y)) : (U = k, k = a)) : (U = k, k = a)))), Ce--, k === a && (Y = a, Ce === 0 && Ze(ri)), k;
    }
    function gW() {
      var k, Y;
      return Ce++, k = U, ir(), (Y = ps()) !== a ? (ut = k, k = Er(Y)) : (U = k, k = a), Ce--, k === a && Ce === 0 && Ze(Nr), k;
    }
    function vW() {
      var k, Y, oe, nt;
      if (Ce++, k = U, i.charCodeAt(U) === 35 ? (Y = j, U++) : (Y = a, Ce === 0 && Ze(oi)), Y !== a) {
        if (oe = [], de.test(i.charAt(U)) ? (nt = i.charAt(U), U++) : (nt = a, Ce === 0 && Ze(pe)), nt !== a)
          for (; nt !== a; )
            oe.push(nt), de.test(i.charAt(U)) ? (nt = i.charAt(U), U++) : (nt = a, Ce === 0 && Ze(pe));
        else
          oe = a;
        oe !== a ? (ut = k, k = ai()) : (U = k, k = a);
      } else
        U = k, k = a;
      return k === a && (k = U, (Y = c2()) !== a && (ut = k, Y = cs(Y)), (k = Y) === a && (k = U, (Y = nA()) !== a && (ut = k, Y = li()), k = Y)), Ce--, k === a && (Y = a, Ce === 0 && Ze(si)), k;
    }
    function ps() {
      var k, Y, oe, nt, hr, cn, hs;
      for (k = U, _e.test(i.charAt(U)) ? (i.charAt(U), U++) : Ce === 0 && Ze(qe), Y = U, oe = [], ie.test(i.charAt(U)) ? (nt = i.charAt(U), U++) : (nt = a, Ce === 0 && Ze(ht)); nt !== a; )
        oe.push(nt), ie.test(i.charAt(U)) ? (nt = i.charAt(U), U++) : (nt = a, Ce === 0 && Ze(ht));
      if (i.charCodeAt(U) === 46 ? (nt = G, U++) : (nt = a, Ce === 0 && Ze(_n)), nt !== a) {
        if (hr = [], ie.test(i.charAt(U)) ? (cn = i.charAt(U), U++) : (cn = a, Ce === 0 && Ze(ht)), cn !== a)
          for (; cn !== a; )
            hr.push(cn), ie.test(i.charAt(U)) ? (cn = i.charAt(U), U++) : (cn = a, Ce === 0 && Ze(ht));
        else
          hr = a;
        hr !== a ? Y = oe = [oe, nt, hr] : (U = Y, Y = a);
      } else
        U = Y, Y = a;
      if (Y === a)
        if (Y = [], ie.test(i.charAt(U)) ? (oe = i.charAt(U), U++) : (oe = a, Ce === 0 && Ze(ht)), oe !== a)
          for (; oe !== a; )
            Y.push(oe), ie.test(i.charAt(U)) ? (oe = i.charAt(U), U++) : (oe = a, Ce === 0 && Ze(ht));
        else
          Y = a;
      if (Y !== a) {
        if (oe = U, i.charCodeAt(U) === 101 ? (nt = R, U++) : (nt = a, Ce === 0 && Ze(Li)), nt !== a) {
          if (_e.test(i.charAt(U)) ? (hr = i.charAt(U), U++) : (hr = a, Ce === 0 && Ze(qe)), hr === a && (hr = null), cn = [], ie.test(i.charAt(U)) ? (hs = i.charAt(U), U++) : (hs = a, Ce === 0 && Ze(ht)), hs !== a)
            for (; hs !== a; )
              cn.push(hs), ie.test(i.charAt(U)) ? (hs = i.charAt(U), U++) : (hs = a, Ce === 0 && Ze(ht));
          else
            cn = a;
          cn !== a ? oe = nt = [nt, hr, cn] : (U = oe, oe = a);
        } else
          U = oe, oe = a;
        oe === a && (oe = null), ut = k, k = Vp();
      } else
        U = k, k = a;
      return k;
    }
    function bW(k, Y) {
      return k.map(function(oe) {
        return oe[Y];
      });
    }
    function wW(k, Y, oe) {
      return [k].concat(bW(Y, oe));
    }
    if ((o = p()) !== a && U === i.length)
      return o;
    throw o !== a && U < i.length && Ze(lW()), uW(u2, Bo < i.length ? i.charAt(Bo) : null, Bo < i.length ? eA(Bo, Bo + 1) : eA(Bo, Bo));
  }
  return e(t, Error), t.prototype.format = function(i) {
    var s = "Error: " + this.message;
    if (this.location) {
      var o, a = null;
      for (o = 0; o < i.length; o++)
        if (i[o].source === this.location.source) {
          a = i[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, c = this.location.source + ":" + l.line + ":" + l.column;
      if (a) {
        var p = this.location.end, f = n("", l.line.toString().length), m = a[l.line - 1], y = l.line === p.line ? p.column : m.length + 1;
        s += `
 --> ` + c + `
` + f + ` |
` + l.line + " | " + m + `
` + f + " | " + n("", l.column - 1) + n("", y - l.column, "^");
      } else
        s += `
 at ` + c;
    }
    return s;
  }, t.buildMessage = function(i, s) {
    var o = { literal: function(y) {
      return '"' + l(y.text) + '"';
    }, class: function(y) {
      var g = y.parts.map(function(v) {
        return Array.isArray(v) ? c(v[0]) + "-" + c(v[1]) : c(v);
      });
      return "[" + (y.inverted ? "^" : "") + g + "]";
    }, any: function() {
      return "any character";
    }, end: function() {
      return "end of input";
    }, other: function(y) {
      return y.description;
    } };
    function a(y) {
      return y.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(y) {
      return y.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(g) {
        return "\\x0" + a(g);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(g) {
        return "\\x" + a(g);
      });
    }
    function c(y) {
      return y.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(g) {
        return "\\x0" + a(g);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(g) {
        return "\\x" + a(g);
      });
    }
    function p(y) {
      return o[y.type](y);
    }
    function f(y) {
      var g, v, w = y.map(p);
      if (w.sort(), w.length > 0) {
        for (g = 1, v = 1; g < w.length; g++)
          w[g - 1] !== w[g] && (w[v] = w[g], v++);
        w.length = v;
      }
      switch (w.length) {
        case 1:
          return w[0];
        case 2:
          return w[0] + " or " + w[1];
        default:
          return w.slice(0, -1).join(", ") + ", or " + w[w.length - 1];
      }
    }
    function m(y) {
      return y ? '"' + l(y) + '"' : "end of input";
    }
    return "Expected " + f(i) + " but " + m(s) + " found.";
  }, { SyntaxError: t, parse: r };
}, (uF = eB).exports && (uF.exports = cF());
const Uk = { deg: 1, grad: 0.9, rad: 180 / Math.PI, turn: 360 };
function jpe(e) {
  if (e.type !== "quantity" || !(e.value === 0 && e.unit === null || e.unit && Uk[e.unit] != null))
    throw new D("effect:type-error", `Expected <angle>, Actual: ${kS(e)}`, { term: e });
}
const qk = { px: 1, cm: 96 / 2.54, mm: 96 / 2.54 / 10, in: 96, pc: 16, pt: 96 / 72 };
function Vpe(e) {
  if (e.type !== "quantity" || !(e.value === 0 && e.unit === null || e.unit && qk[e.unit] != null))
    throw new D("effect:type-error", `Expected <length>, Actual: ${kS(e)}`, { term: e });
}
function So(e) {
  Dpe(e);
  const t = e.value;
  return B0(t, e), e.unit === "%" ? 0.01 * t : t;
}
function zpe(e) {
  return Npe(e), B0(e.value, e), e.value;
}
function Bpe(e) {
  return jpe(e), e.value * Uk[e.unit] || 0;
}
function Gk(e) {
  return Vpe(e), e.value * qk[e.unit] || 0;
}
function Upe(e) {
  switch (e.colorType) {
    case "hex":
      return lQ(e.value);
    case "named":
      return nB(e.value);
    case "function":
      return Wpe(e.value);
  }
}
function nB(e) {
  if (!l6(e))
    throw new D("effect:unknown-color", `color '${e}' isn't valid`, { namedColor: e });
  return aQ(e);
}
const qpe = /^rgba?/i, Gpe = /^hsla?/i;
function Wpe(e) {
  if (im(e.parameters, 4), qpe.test(e.name))
    return [So(e.parameters[0]), So(e.parameters[1]), So(e.parameters[2]), e.parameters[3] ? So(e.parameters[3]) : 1];
  if (Gpe.test(e.name))
    return u6(zpe(e.parameters[0]), So(e.parameters[1]), So(e.parameters[2]), e.parameters[3] ? So(e.parameters[3]) : 1);
  throw new D("effect:syntax-error", `Invalid color function '${e.name}'`, { colorFunction: e });
}
function uM(e, t, n) {
  try {
    return Jpe(e);
  } catch (i) {
    var r;
    n == null || (r = n.messages) == null || r.push(i);
  }
  return null;
}
function cM(e, t, n, r) {
  try {
    const i = Hpe(e);
    ss(n, i, t);
  } catch (i) {
    r.messages && r.messages.push(i);
  }
}
function Hpe(e) {
  const t = tB(e);
  return t ? Cpe(t) ? t.map((n) => n.toJSON()) : t.map(({ scale: n, effects: r }) => ({ scale: n, value: r.map((i) => i.toJSON()) })) : null;
}
function Jpe(e) {
  if (!e || e.length === 0)
    return null;
  if (Zpe(e)) {
    const t = [];
    for (const n of e)
      t.push({ scale: n.scale, value: pF(n.value) });
    return t;
  }
  return pF(e);
}
function Zpe(e) {
  const t = e[0];
  return !!t && "scale" in t;
}
function pF(e) {
  if (!e || !e.length)
    return "";
  const t = [];
  for (const n of e) {
    let r = [];
    switch (n.type) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
      case "opacity":
        r = [ja(n, "amount")];
        break;
      case "blur":
        r = [ja(n, "radius", "pt")];
        break;
      case "hue-rotate":
        r = [ja(n, "angle", "deg")];
        break;
      case "drop-shadow":
        r = [ja(n, "xoffset", "pt"), ja(n, "yoffset", "pt"), ja(n, "blurRadius", "pt"), Kpe(n, "color")];
        break;
      case "bloom":
        r = [ja(n, "strength"), ja(n, "radius", "pt"), ja(n, "threshold")];
    }
    const i = `${n.type}(${r.filter(Boolean).join(" ")})`;
    tB(i), t.push(i);
  }
  return t.join(" ");
}
function ja(e, t, n) {
  if (e[t] == null)
    throw new D("effect:missing-parameter", `Missing parameter '${t}' in ${e.type} effect`, { effect: e });
  return n ? e[t] + n : "" + e[t];
}
function Kpe(e, t) {
  if (e[t] == null)
    throw new D("effect:missing-parameter", `Missing parameter '${t}' in ${e.type} effect`, { effect: e });
  const n = e[t];
  return `rgba(${n[0] || 0}, ${n[1] || 0}, ${n[2] || 0}, ${n[3] / 255 || 0})`;
}
const rB = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.blendMode = "normal", this.effect = null;
    }
  };
  return u([d({ type: ["average", "color-burn", "color-dodge", "color", "darken", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "exclusion", "hard-light", "hue", "invert", "lighten", "lighter", "luminosity", "minus", "multiply", "normal", "overlay", "plus", "reflect", "saturation", "screen", "soft-light", "source-atop", "source-in", "source-out", "vivid-light", "xor"], nonNullable: !0, json: { read: !1, write: !1, origins: { "web-map": { read: !0, write: !0 } } } })], t.prototype, "blendMode", void 0), u([d({ json: { read: !1, write: !1, origins: { "web-map": { read: { reader: uM }, write: { allowNull: !0, writer: cM } } } } })], t.prototype, "effect", void 0), t = u([T("geoscene.layers.mixins.BlendLayer")], t), t;
}, Ype = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.customParameters = null;
    }
  };
  return u([d({ type: Object, json: { write: { overridePolicy: (n) => ({ enabled: !!(n && Object.keys(n).length > 0) }) } } })], t.prototype, "customParameters", void 0), t = u([T("geoscene.layers.mixins.CustomParametersMixin")], t), t;
};
var dM;
const xx = new st({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), $x = new st({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let sa = dM = class extends se {
  constructor(e) {
    super(e), this.where = null, this.geometry = null, this.spatialRelationship = "intersects", this.distance = void 0, this.objectIds = null, this.units = null, this.timeExtent = null;
  }
  createQuery(e = {}) {
    const { where: t, geometry: n, spatialRelationship: r, timeExtent: i, objectIds: s, units: o, distance: a } = this;
    return new Jr({ geometry: q(n), objectIds: q(s), spatialRelationship: r, timeExtent: q(i), where: t, units: o, distance: a, ...e });
  }
  clone() {
    const { where: e, geometry: t, spatialRelationship: n, timeExtent: r, objectIds: i, units: s, distance: o } = this;
    return new dM({ geometry: q(t), objectIds: q(i), spatialRelationship: n, timeExtent: q(r), where: e, units: s, distance: o });
  }
};
u([d({ type: String, json: { write: !0 } })], sa.prototype, "where", void 0), u([d({ types: Tp, json: { write: !0 } })], sa.prototype, "geometry", void 0), u([d({ type: xx.apiValues, json: { name: "spatialRel", read: { reader: xx.read }, write: { allowNull: !1, writer: xx.write, overridePolicy() {
  return { enabled: O(this.geometry) };
} } } })], sa.prototype, "spatialRelationship", void 0), u([d({ type: Number, json: { write: { overridePolicy(e) {
  return { enabled: e != null && this.geometry != null };
} } } })], sa.prototype, "distance", void 0), u([d({ type: [Number], json: { write: !0 } })], sa.prototype, "objectIds", void 0), u([d({ type: $x.apiValues, json: { read: $x.read, write: { writer: $x.write, overridePolicy(e) {
  return { enabled: e != null && this.geometry != null };
} } } })], sa.prototype, "units", void 0), u([d({ type: La, json: { write: !0 } })], sa.prototype, "timeExtent", void 0), sa = dM = u([T("geoscene.layers.support.FeatureFilter")], sa);
const Qpe = sa;
var pM;
let od = pM = class extends se {
  constructor(e) {
    super(e), this.filter = null, this.includedEffect = null, this.excludedEffect = null, this.excludedLabelsVisible = !1;
  }
  write(e, t) {
    const n = super.write(e, t);
    if (t != null && t.origin) {
      if (n.filter) {
        const s = Object.keys(n.filter);
        var r;
        if (s.length > 1 || s[0] !== "where")
          return (r = t.messages) == null || r.push(new D("web-document-write:unsupported-feature-effect", "Invalid feature effect 'filter'. A filter can only contain a 'where' property", { layer: t.layer, effect: this })), null;
      }
      var i;
      if ("showExcludedLabels" in n)
        return (i = t.messages) == null || i.push(new D("web-document-write:unsupported-feature-effect", "Invalid value for property 'excludedLabelsVisible' which should always be 'true'", { layer: t.layer, effect: this })), null;
    }
    return n;
  }
  clone() {
    return new pM({ filter: O(this.filter) && this.filter.clone(), includedEffect: this.includedEffect, excludedEffect: this.excludedEffect, excludedLabelsVisible: this.excludedLabelsVisible });
  }
};
u([d({ type: Qpe, json: { write: { allowNull: !0, writer(e, t, n, r) {
  const i = e == null ? void 0 : e.write({}, r);
  i && Object.keys(i).length !== 0 ? ss(n, i, t) : ss(n, null, t);
} } } })], od.prototype, "filter", void 0), u([d({ json: { write: !0, origins: { "web-map": { read: { reader: uM }, write: { writer: cM, overridePolicy() {
  return { allowNull: this.excludedEffect != null, isRequired: this.excludedEffect == null };
} } } } } })], od.prototype, "includedEffect", void 0), u([d({ json: { write: !0, origins: { "web-map": { read: { reader: uM }, write: { writer: cM, overridePolicy() {
  return { allowNull: this.includedEffect != null, isRequired: this.includedEffect == null };
} } } } } })], od.prototype, "excludedEffect", void 0), u([d({ type: Boolean, json: { write: !0, name: "showExcludedLabels", origins: { "web-map": { name: "showExcludedLabels", default: !0 } } } })], od.prototype, "excludedLabelsVisible", void 0), od = pM = u([T("geoscene.layers.support.FeatureEffect")], od);
const Xpe = od, ehe = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.featureEffect = null;
    }
  };
  return u([d({ type: Xpe, json: { origins: { "web-map": { write: { allowNull: !0 } } } } })], t.prototype, "featureEffect", void 0), t = u([T("geoscene.layers.mixins.FeatureEffectLayer")], t), t;
}, the = { "web-scene/operational-layers": { ArcGISFeatureLayer: !0, ArcGISImageServiceLayer: !0, ArcGISMapServiceLayer: !0, ArcGISSceneServiceLayer: !0, ArcGISTiledElevationServiceLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, BuildingSceneLayer: !0, GroupLayer: !0, IntegratedMeshLayer: !0, OGCFeatureLayer: !0, PointCloudLayer: !0, WebTiledLayer: !0, CSV: !0, GeoJSON: !0, VectorTileLayer: !0, WFS: !0, WMS: !0, KML: !0, RasterDataLayer: !0, Voxel: !0 }, "web-scene/basemap": { ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, WebTiledLayer: !0, OpenStreetMap: !0, VectorTileLayer: !0, ArcGISImageServiceLayer: !0, WMS: !0, ArcGISMapServiceLayer: !0 }, "web-scene/ground": { ArcGISTiledElevationServiceLayer: !0, RasterDataElevationLayer: !0 }, "web-map/operational-layers": { ArcGISFeatureLayer: !0, ArcGISImageServiceLayer: !0, ArcGISImageServiceVectorLayer: !0, ArcGISMapServiceLayer: !0, ArcGISStreamLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, BingMapsAerial: !0, BingMapsHybrid: !0, BingMapsRoad: !0, CSV: !0, GeoRSS: !0, GeoJSON: !0, GroupLayer: !0, KML: !0, OGCFeatureLayer: !0, SubtypeGroupLayer: !0, VectorTileLayer: !0, WFS: !0, WMS: !0, WebTiledLayer: !0 }, "web-map/basemap": { ArcGISImageServiceLayer: !0, ArcGISImageServiceVectorLayer: !0, ArcGISMapServiceLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, OpenStreetMap: !0, VectorTileLayer: !0, WMS: !0, WebTiledLayer: !0, BingMapsAerial: !0, BingMapsRoad: !0, BingMapsHybrid: !0 }, "web-map/tables": { ArcGISFeatureLayer: !0 }, "portal-item/operational-layers": { ArcGISFeatureLayer: !0, ArcGISSceneServiceLayer: !0, PointCloudLayer: !0, BuildingSceneLayer: !0, IntegratedMeshLayer: !0 } };
function nhe(e) {
  if (!e)
    return e;
  const { start: t, end: n } = e;
  return new La({ start: O(t) ? Gd(t, -t.getTimezoneOffset(), "minutes") : t, end: O(n) ? Gd(n, -n.getTimezoneOffset(), "minutes") : n });
}
function rhe(e) {
  if (!e)
    return e;
  const { start: t, end: n } = e;
  return new La({ start: O(t) ? Gd(t, t.getTimezoneOffset(), "minutes") : t, end: O(n) ? Gd(n, n.getTimezoneOffset(), "minutes") : n });
}
var hM;
let Ly = hM = class extends se {
  async collectRequiredFields(e, t) {
    return as(e, t, this.expression);
  }
  clone() {
    return new hM({ expression: this.expression, title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], Ly.prototype, "expression", void 0), u([d({ type: String, json: { write: !0 } })], Ly.prototype, "title", void 0), Ly = hM = u([T("geoscene.layers.support.FeatureExpressionInfo")], Ly);
const hF = Ly;
function ihe() {
  const e = Object.keys(h7);
  return e.sort(), e;
}
const she = ihe();
var fM;
const Nv = $r()({ onTheGround: "on-the-ground", relativeToGround: "relative-to-ground", relativeToScene: "relative-to-scene", absoluteHeight: "absolute-height" }), fF = new st({ foot: "feet", kilometer: "kilometers", meter: "meters", mile: "miles", "us-foot": "us-feet", yard: "yards" });
let il = fM = class extends se {
  constructor() {
    super(...arguments), this.offset = null;
  }
  readFeatureExpressionInfo(e, t) {
    return e ?? (t.featureExpression && t.featureExpression.value === 0 ? { expression: "0" } : void 0);
  }
  writeFeatureExpressionInfo(e, t, n, r) {
    t[n] = e.write({}, r), e.expression === "0" && (t.featureExpression = { value: 0 });
  }
  get mode() {
    const { offset: e, featureExpressionInfo: t } = this;
    return this._isOverridden("mode") ? this._get("mode") : O(e) || t ? "relative-to-ground" : "on-the-ground";
  }
  set mode(e) {
    this._override("mode", e);
  }
  set unit(e) {
    this._set("unit", e);
  }
  write(e, t) {
    return this.offset || this.mode || this.featureExpressionInfo || this.unit ? super.write(e, t) : null;
  }
  clone() {
    return new fM({ mode: this.mode, offset: this.offset, featureExpressionInfo: this.featureExpressionInfo ? this.featureExpressionInfo.clone() : void 0, unit: this.unit });
  }
};
u([d({ type: hF, json: { write: !0 } })], il.prototype, "featureExpressionInfo", void 0), u([be("featureExpressionInfo", ["featureExpressionInfo", "featureExpression"])], il.prototype, "readFeatureExpressionInfo", null), u([xe("featureExpressionInfo", { featureExpressionInfo: { type: hF }, "featureExpression.value": { type: [0] } })], il.prototype, "writeFeatureExpressionInfo", null), u([d({ type: Nv.apiValues, nonNullable: !0, json: { type: Nv.jsonValues, read: Nv.read, write: { writer: Nv.write, isRequired: !0 } } })], il.prototype, "mode", null), u([d({ type: Number, json: { write: !0 } })], il.prototype, "offset", void 0), u([d({ type: she, json: { type: String, read: fF.read, write: fF.write } })], il.prototype, "unit", null), il = fM = u([T("geoscene.layers.support.ElevationInfo")], il);
const iB = il, ohe = { type: Boolean, value: !0, json: { origins: { service: { read: !1, write: !1 }, "web-map": { read: !1, write: !1 } }, name: "screenSizePerspective", write: !0 } }, sB = { type: Boolean, value: !0, json: { name: "disablePopup", read: { reader: (e, t) => !t.disablePopup }, write: { enabled: !0, writer(e, t, n) {
  t[n] = !e;
} } } }, oB = { type: Boolean, value: !0, json: { name: "showLabels", write: !0 } }, ahe = { type: String, json: { origins: { "portal-item": { write: !1 } }, write: { isRequired: !0, ignoreOrigin: !0, writer: lp } } }, lhe = { type: Boolean, value: !0, json: { origins: { service: { read: { enabled: !1 } } }, name: "showLegend", write: !0 } }, uhe = { value: null, type: iB, json: { origins: { service: { name: "elevationInfo", write: !0 } }, name: "layerDefinition.elevationInfo", write: !0 } };
function jFe(e) {
  return { type: e, readOnly: !0, json: { origins: { service: { read: !0 } }, read: !1 } };
}
const _w = { type: Number, json: { origins: { "web-document": { write: !0, read: !0 }, "portal-item": { write: !0 } } } }, che = { ..._w, json: { ..._w.json, origins: { "web-document": { ..._w.json.origins["web-document"], write: { enabled: !0, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } } } }, read: { source: ["layerDefinition.drawingInfo.transparency", "drawingInfo.transparency"], reader: (e, t, n) => n && n.origin !== "service" || !t.drawingInfo || t.drawingInfo.transparency === void 0 ? t.layerDefinition && t.layerDefinition.drawingInfo && t.layerDefinition.drawingInfo.transparency !== void 0 ? kg(t.layerDefinition.drawingInfo.transparency) : void 0 : kg(t.drawingInfo.transparency) } } }, VFe = { type: La, readOnly: !0, get() {
  var e, t;
  if ((e = this.layer) == null || !e.timeInfo)
    return null;
  const { datesInUnknownTimezone: n, timeOffset: r, useViewTime: i } = this.layer, s = (t = this.view) == null ? void 0 : t.timeExtent;
  let o = this.layer.timeExtent;
  n && (o = rhe(o));
  let a = i ? s && o ? s.intersection(o) : s || o : o;
  if (!a || a.isEmpty || a.isAllTime)
    return a;
  r && (a = a.offset(-r.value, r.unit)), n && (a = nhe(a));
  const l = this._get("timeExtent");
  return a.equals(l) ? l : a;
} }, zFe = { type: Mt, readOnly: !0, json: { origins: { service: { read: { source: ["fullExtent", "spatialReference"], reader: (e, t) => {
  const n = Mt.fromJSON(e);
  return t.spatialReference != null && typeof t.spatialReference == "object" && (n.spatialReference = Qe.fromJSON(t.spatialReference)), n;
} } } }, read: !1 } }, dhe = { type: String, json: { origins: { service: { read: !1 }, "portal-item": { read: !1 } } } }, phe = { type: Number, json: { origins: { service: { write: { enabled: !1 } } }, read: { source: "layerDefinition.minScale" }, write: { target: "layerDefinition.minScale" } } }, hhe = { type: Number, json: { origins: { service: { write: { enabled: !1 } } }, read: { source: "layerDefinition.maxScale" }, write: { target: "layerDefinition.maxScale" } } }, fhe = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.title = null;
    }
    writeListMode(n, r, i, s) {
      (s && s.layerContainerType === "ground" || n && oK(this, i, {}, s)) && (r[i] = n);
    }
    writeOperationalLayerType(n, r, i, s) {
      !n || s && s.layerContainerType === "tables" || (r.layerType = n);
    }
    writeTitle(n, r) {
      r.title = n || "Layer";
    }
    read(n, r) {
      r && (r.layer = this), nK(this, n, (i) => super.read(n, i), r);
    }
    write(n, r) {
      if (r != null && r.origin) {
        const l = `${r.origin}/${r.layerContainerType || "operational-layers"}`, c = the[l];
        let p = c && c[this.operationalLayerType];
        var i;
        if (this.operationalLayerType === "ArcGISTiledElevationServiceLayer" && l === "web-scene/operational-layers" && (p = !1), !p)
          return (i = r.messages) == null || i.push(new D("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${l}'`, { layer: this })), null;
      }
      const s = super.write(n, { ...r, layer: this }), o = !!r && !!r.messages && !!r.messages.filter((l) => l instanceof D && l.name === "web-document-write:property-required").length;
      var a;
      return Q_(s == null ? void 0 : s.url) ? (r == null || (a = r.messages) == null || a.push(new D("layer:invalid-url", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a Blob URL cannot be written to web scenes and web maps`, { layer: this })), null) : !this.url && o ? null : s;
    }
    beforeSave() {
    }
  };
  return u([d({ type: String, json: { write: { ignoreOrigin: !0 }, origins: { "web-scene": { write: { isRequired: !0, ignoreOrigin: !0 } }, "portal-item": { write: !1 } } } })], t.prototype, "id", void 0), u([d({ json: { write: { ignoreOrigin: !0 }, origins: { "web-map": { read: !1, write: !1 } } } })], t.prototype, "listMode", void 0), u([xe("listMode")], t.prototype, "writeListMode", null), u([d({ type: String, readOnly: !0, json: { read: !1, write: { target: "layerType", ignoreOrigin: !0 }, origins: { "portal-item": { write: !1 } } } })], t.prototype, "operationalLayerType", void 0), u([xe("operationalLayerType")], t.prototype, "writeOperationalLayerType", null), u([d(_w)], t.prototype, "opacity", void 0), u([d({ type: String, json: { write: { ignoreOrigin: !0, writerEnsuresNonNull: !0 }, origins: { "web-scene": { write: { isRequired: !0, ignoreOrigin: !0, writerEnsuresNonNull: !0 } }, "portal-item": { write: !1 } } }, value: "Layer" })], t.prototype, "title", void 0), u([xe("title")], t.prototype, "writeTitle", null), u([d({ type: Boolean, json: { name: "visibility" } })], t.prototype, "visible", void 0), t = u([T("geoscene.layers.mixins.OperationalLayer")], t), t;
};
var mM;
const Tx = new st({ asc: "ascending", desc: "descending" });
let $h = mM = class extends se {
  constructor(e) {
    super(e), this.field = null, this.valueExpression = null, this.order = "ascending";
  }
  clone() {
    return new mM({ field: this.field, valueExpression: this.valueExpression, order: this.order });
  }
};
u([d({ type: String, json: { write: !0 } })], $h.prototype, "field", void 0), u([d({ type: String, json: { write: !0 } })], $h.prototype, "valueExpression", void 0), u([d({ type: Tx.apiValues, json: { read: Tx.read, write: Tx.write } })], $h.prototype, "order", void 0), $h = mM = u([T("geoscene.layers.support.OrderByInfo")], $h);
const aB = $h;
function mhe(e, t, n) {
  if (!e)
    return null;
  const r = e.find((s) => !!s.field);
  if (!r)
    return null;
  const i = new aB();
  return i.read(r, n), [i];
}
function yhe(e, t, n, r) {
  const i = e.find((s) => !!s.field);
  i && ss(n, [i.toJSON()], t);
}
const ghe = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.orderBy = null;
    }
  };
  return u([d({ type: [aB], json: { origins: { "web-scene": { write: !1, read: !1 } }, read: { source: "layerDefinition.orderBy", reader: mhe }, write: { target: "layerDefinition.orderBy", writer: yhe } } })], t.prototype, "orderBy", void 0), t = u([T("geoscene.layers.mixins.OrderedLayer")], t), t;
}, vhe = we.getLogger("geoscene.layers.mixins.PortalLayer"), bhe = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = !0;
    }
    destroy() {
      var n;
      (n = this.portalItem) == null || n.destroy(), this.portalItem = null;
    }
    set portalItem(n) {
      n !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", n));
    }
    readPortalItem(n, r, i) {
      if (r.itemId)
        return new w1({ id: r.itemId, portal: i && i.portal });
    }
    writePortalItem(n, r) {
      n && n.id && (r.itemId = n.id);
    }
    async loadFromPortal(n, r) {
      if (this.portalItem && this.portalItem.id)
        try {
          const i = await import("./layersLoader-AXd0QYk0.js").then((s) => s.l);
          return On(r), await i.load({ instance: this, supportedTypes: n.supportedTypes, validateItem: n.validateItem, supportsData: n.supportsData }, r);
        } catch (i) {
          throw Ws(i) || vhe.warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${i}`), i;
        }
    }
    async finishLoadEditablePortalLayer(n) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(n).catch((r) => (y0(r), !0)));
    }
    async _fetchUserHasEditingPrivileges(n) {
      const r = this.url ? En == null ? void 0 : En.findCredential(this.url) : null;
      if (!r)
        return !0;
      const i = Dv.credential === r ? Dv.user : await this._fetchEditingUser(n);
      return Dv.credential = r, Dv.user = i, H(i) || i.privileges == null || i.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(n) {
      var r, i;
      const s = (r = this.portalItem) == null || (i = r.portal) == null ? void 0 : i.user;
      if (s)
        return s;
      const o = En.findServerInfo(this.url);
      if (o == null || !o.owningSystemUrl)
        return null;
      const a = `${o.owningSystemUrl}/sharing/rest`, l = os.getDefault();
      if (l && l.loaded && Co(l.restUrl) === Co(a))
        return l.user;
      const c = `${a}/community/self`, p = O(n) ? n.signal : null, f = await K_(rn(c, { authMode: "no-prompt", query: { f: "json" }, signal: p }));
      return f.ok ? cO.fromJSON(f.value.data) : null;
    }
    read(n, r) {
      r && (r.layer = this), super.read(n, r);
    }
    write(n, r) {
      const i = r && r.portal, s = this.portalItem && this.portalItem.id && (this.portalItem.portal || os.getDefault());
      return i && s && !j8(s.restUrl, i.restUrl) ? (r.messages && r.messages.push(new D("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save the scene, set the layer.portalItem to null or save the scene to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(n, { ...r, layer: this });
    }
  };
  return u([d({ type: w1 })], t.prototype, "portalItem", null), u([be("web-document", "portalItem", ["itemId"])], t.prototype, "readPortalItem", null), u([xe("web-document", "portalItem", { itemId: { type: String } })], t.prototype, "writePortalItem", null), u([d({ clonable: !1 })], t.prototype, "resourceReferences", void 0), u([d({ readOnly: !0 })], t.prototype, "userHasEditingPrivileges", void 0), t = u([T("geoscene.layers.mixins.PortalLayer")], t), t;
}, Dv = { credential: null, user: null }, Zg = new Ne(), cg = /* @__PURE__ */ new WeakMap();
function whe(e) {
  lB(e) && Zg.push(e);
}
function _he(e) {
  lB(e) && Zg.includes(e) && Zg.remove(e);
}
function lB(e) {
  return e && typeof e == "object" && "refreshInterval" in e && "refresh" in e;
}
function uB(e, t) {
  return Number.isFinite(e) && Number.isFinite(t) ? t <= 0 ? e : uB(t, e % t) : 0;
}
let Ex = 0, jv = 0;
function She() {
  const e = Date.now();
  for (const n of Zg)
    if (n.refreshInterval) {
      var t;
      e - ((t = cg.get(n)) != null ? t : 0) + 5 >= 6e4 * n.refreshInterval && (cg.set(n, e), n.refresh(e));
    }
}
s8(() => {
  const e = Date.now();
  let t = 0;
  for (const n of Zg)
    t = uB(Math.round(6e4 * n.refreshInterval), t), n.refreshInterval ? cg.get(n) || cg.set(n, e) : cg.delete(n);
  if (t !== jv) {
    if (jv = t, clearInterval(Ex), jv === 0)
      return void (Ex = 0);
    Ex = setInterval(She, jv);
  }
});
const xhe = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this.refreshInterval = 0, this.refreshTimestamp = 0, this._debounceHasDataChanged = QD(() => this.hasDataChanged()), this.when().then(() => {
        whe(this);
      }, () => {
      });
    }
    destroy() {
      _he(this);
    }
    get refreshParameters() {
      return { _ts: this.refreshTimestamp || null };
    }
    refresh(n = Date.now()) {
      k$(this._debounceHasDataChanged()).then((r) => {
        r && this._set("refreshTimestamp", n), this.emit("refresh", { dataChanged: r });
      }, (r) => {
        we.getLogger(this.declaredClass).error(r), this.emit("refresh", { dataChanged: !1, error: r });
      });
    }
    async hasDataChanged() {
      return !0;
    }
  };
  return u([d({ type: Number, cast: (n) => n >= 0.1 ? n : n <= 0 ? 0 : 0.1, json: { write: !0 } })], t.prototype, "refreshInterval", void 0), u([d({ readOnly: !0 })], t.prototype, "refreshTimestamp", void 0), u([d()], t.prototype, "refreshParameters", null), t = u([T("geoscene.layers.mixins.RefreshableLayer")], t), t;
}, cB = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.minScale = 0, this.maxScale = 0;
    }
    get effectiveScaleRange() {
      const n = { minScale: this.minScale, maxScale: this.maxScale }, r = this.parent;
      r && "effectiveScaleRange" in r && $he(n, r.effectiveScaleRange);
      const i = this._get("effectiveScaleRange");
      return i && i.minScale === n.minScale && i.maxScale === n.maxScale ? i : n;
    }
  };
  return u([d({ type: Number, nonNullable: !0, json: { write: !0 } })], t.prototype, "minScale", void 0), u([d({ type: Number, nonNullable: !0, json: { write: !0 } })], t.prototype, "maxScale", void 0), u([d({ readOnly: !0 })], t.prototype, "effectiveScaleRange", null), t = u([T("geoscene.layers.mixins.ScaleRangeLayer")], t), t;
};
function $he(e, t) {
  return e.minScale = e.minScale > 0 ? t.minScale > 0 ? Math.min(e.minScale, t.minScale) : e.minScale : t.minScale, e.maxScale = e.maxScale > 0 ? t.maxScale > 0 ? Math.max(e.maxScale, t.maxScale) : e.maxScale : t.maxScale, e;
}
const Ld = $r()({ esriTimeUnitsMilliseconds: "milliseconds", esriTimeUnitsSeconds: "seconds", esriTimeUnitsMinutes: "minutes", esriTimeUnitsHours: "hours", esriTimeUnitsDays: "days", esriTimeUnitsWeeks: "weeks", esriTimeUnitsMonths: "months", esriTimeUnitsYears: "years", esriTimeUnitsDecades: "decades", esriTimeUnitsCenturies: "centuries", esriTimeUnitsUnknown: void 0 });
var yM;
let Fy = yM = class extends se {
  constructor(e) {
    super(e), this.value = 0, this.unit = "milliseconds";
  }
  toMilliseconds() {
    return ioe(this.value, this.unit, "milliseconds");
  }
  clone() {
    return new yM({ value: this.value, unit: this.unit });
  }
};
u([d({ type: Number, json: { write: !0 }, nonNullable: !0 })], Fy.prototype, "value", void 0), u([d({ type: Ld.apiValues, json: { type: Ld.jsonValues, read: Ld.read, write: Ld.write }, nonNullable: !0 })], Fy.prototype, "unit", void 0), Fy = yM = u([T("geoscene.TimeInterval")], Fy);
const Kg = Fy;
var gM;
let Th = gM = class extends se {
  constructor(e) {
    super(e), this.respectsDaylightSaving = !1, this.timezone = null;
  }
  readRespectsDaylightSaving(e, t) {
    return t.respectsDaylightSaving !== void 0 ? t.respectsDaylightSaving : t.respectDaylightSaving !== void 0 && t.respectDaylightSaving;
  }
  clone() {
    const { respectsDaylightSaving: e, timezone: t } = this;
    return new gM({ respectsDaylightSaving: e, timezone: t });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Th.prototype, "respectsDaylightSaving", void 0), u([be("respectsDaylightSaving", ["respectsDaylightSaving", "respectDaylightSaving"])], Th.prototype, "readRespectsDaylightSaving", null), u([d({ type: String, json: { read: { source: "timeZone" }, write: { target: "timeZone" } } })], Th.prototype, "timezone", void 0), Th = gM = u([T("geoscene.layers.support.TimeReference")], Th);
const The = Th;
var vM;
let kr = vM = class extends se {
  constructor(e) {
    super(e), this.cumulative = !1, this.endField = null, this.fullTimeExtent = null, this.hasLiveData = !1, this.interval = null, this.startField = null, this.timeReference = null, this.trackIdField = null, this.useTime = !0;
  }
  readFullTimeExtent(e, t) {
    if (!t.timeExtent || !Array.isArray(t.timeExtent) || t.timeExtent.length !== 2)
      return null;
    const n = new Date(t.timeExtent[0]), r = new Date(t.timeExtent[1]);
    return new La({ start: n, end: r });
  }
  writeFullTimeExtent(e, t) {
    e && O(e.start) && O(e.end) ? t.timeExtent = [e.start.getTime(), e.end.getTime()] : t.timeExtent = null;
  }
  readInterval(e, t) {
    return t.timeInterval && t.timeIntervalUnits ? new Kg({ value: t.timeInterval, unit: Ld.fromJSON(t.timeIntervalUnits) }) : t.defaultTimeInterval && t.defaultTimeIntervalUnits ? new Kg({ value: t.defaultTimeInterval, unit: Ld.fromJSON(t.defaultTimeIntervalUnits) }) : null;
  }
  writeInterval(e, t) {
    if (e) {
      const n = e.toJSON();
      t.timeInterval = n.value, t.timeIntervalUnits = n.unit;
    } else
      t.timeInterval = null, t.timeIntervalUnits = null;
  }
  clone() {
    const { cumulative: e, endField: t, hasLiveData: n, interval: r, startField: i, timeReference: s, fullTimeExtent: o, trackIdField: a, useTime: l } = this;
    return new vM({ cumulative: e, endField: t, hasLiveData: n, interval: r, startField: i, timeReference: q(s), fullTimeExtent: q(o), trackIdField: a, useTime: l });
  }
};
u([d({ type: Boolean, json: { read: { source: "exportOptions.timeDataCumulative" }, write: { target: "exportOptions.timeDataCumulative" } } })], kr.prototype, "cumulative", void 0), u([d({ type: String, json: { read: { source: "endTimeField" }, write: { target: "endTimeField", allowNull: !0 } } })], kr.prototype, "endField", void 0), u([d({ type: La, json: { write: { enabled: !0, allowNull: !0 } } })], kr.prototype, "fullTimeExtent", void 0), u([be("fullTimeExtent", ["timeExtent"])], kr.prototype, "readFullTimeExtent", null), u([xe("fullTimeExtent")], kr.prototype, "writeFullTimeExtent", null), u([d({ type: Boolean, json: { write: !0 } })], kr.prototype, "hasLiveData", void 0), u([d({ type: Kg, json: { write: { enabled: !0, allowNull: !0 } } })], kr.prototype, "interval", void 0), u([be("interval", ["timeInterval", "timeIntervalUnits", "defaultTimeInterval", "defaultTimeIntervalUnits"])], kr.prototype, "readInterval", null), u([xe("interval")], kr.prototype, "writeInterval", null), u([d({ type: String, json: { read: { source: "startTimeField" }, write: { target: "startTimeField", allowNull: !0 } } })], kr.prototype, "startField", void 0), u([d({ type: The, json: { write: { enabled: !0, allowNull: !0 } } })], kr.prototype, "timeReference", void 0), u([d({ type: String, json: { write: { enabled: !0, allowNull: !0 } } })], kr.prototype, "trackIdField", void 0), u([d({ type: Boolean, json: { read: { source: "exportOptions.useTime" }, write: { target: "exportOptions.useTime" } } })], kr.prototype, "useTime", void 0), kr = vM = u([T("geoscene.layers.support.TimeInfo")], kr);
const dB = kr, Ehe = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.timeExtent = null, this.timeOffset = null, this.useViewTime = !0;
    }
    readOffset(n, r) {
      const i = r.timeInfo.exportOptions;
      if (!i)
        return null;
      const s = i.timeOffset, o = Ld.fromJSON(i.timeOffsetUnits);
      return s && o ? new Kg({ value: s, unit: o }) : null;
    }
    set timeInfo(n) {
      P6(n, this.fieldsIndex), this._set("timeInfo", n);
    }
  };
  return u([d({ type: La, json: { write: !1 } })], t.prototype, "timeExtent", void 0), u([d({ type: Kg })], t.prototype, "timeOffset", void 0), u([be("service", "timeOffset", ["timeInfo.exportOptions"])], t.prototype, "readOffset", null), u([d({ value: null, type: dB, json: { write: !0, origins: { "web-document": { read: !1, write: !1 } } } })], t.prototype, "timeInfo", null), u([d({ type: Boolean, json: { read: { source: "timeAnimation" }, write: { target: "timeAnimation" }, origins: { "web-scene": { read: !1, write: !1 } } } })], t.prototype, "useViewTime", void 0), t = u([T("geoscene.layers.mixins.TemporalLayer")], t), t;
};
var bM;
let hl = bM = class extends se {
  constructor(e) {
    super(e);
  }
  clone() {
    const { name: e, fields: t, isAscending: n, isUnique: r, description: i } = this;
    return new bM({ name: e, fields: t, isAscending: n, isUnique: r, description: i });
  }
};
u([d({ constructOnly: !0 })], hl.prototype, "name", void 0), u([d({ constructOnly: !0 })], hl.prototype, "fields", void 0), u([d({ constructOnly: !0 })], hl.prototype, "isAscending", void 0), u([d({ constructOnly: !0 })], hl.prototype, "isUnique", void 0), u([d({ constructOnly: !0 })], hl.prototype, "description", void 0), hl = bM = u([T("geoscene.layers.support.FeatureIndex")], hl);
let Sw = class extends se {
  constructor() {
    super(...arguments), this.type = null;
  }
};
u([d({ type: ["selection", "cluster"], readOnly: !0, json: { read: !1, write: !0 } })], Sw.prototype, "type", void 0), Sw = u([T("geoscene.layers.support.FeatureReduction")], Sw);
const xw = Sw;
var wM;
let Eh = wM = class extends se {
  constructor() {
    super(...arguments), this.statisticType = null, this.onStatisticField = null, this.onStatisticValueExpression = null;
  }
  clone() {
    return new wM({ statisticType: this.statisticType, onStatisticField: this.onStatisticField, onStatisticValueExpression: this.onStatisticValueExpression });
  }
};
u([d({ type: String, json: { write: !0 } })], Eh.prototype, "statisticType", void 0), u([d({ type: String, json: { write: !0 } })], Eh.prototype, "onStatisticField", void 0), u([d({ type: String, json: { write: !0 } })], Eh.prototype, "onStatisticValueExpression", void 0), Eh = wM = u([T("geoscene.layers.support.OutStatistic")], Eh);
const Ihe = Eh;
var _M;
let Ny = _M = class extends se {
  constructor() {
    super(...arguments), this.name = null;
  }
  clone() {
    return new _M({ name: this.name, outStatistic: this.outStatistic.clone() });
  }
};
u([d({ type: String, json: { write: !0 } })], Ny.prototype, "name", void 0), u([d({ type: Ihe, json: { write: !0 } })], Ny.prototype, "outStatistic", void 0), Ny = _M = u([T("geoscene.layers.support.AggregateField")], Ny);
const Mhe = Ny, Wk = "__begin__", Hk = "__end__", Che = new RegExp(Wk, "ig"), Ohe = new RegExp(Hk, "ig"), mF = new RegExp("^" + Wk, "i"), yF = new RegExp(Hk + "$", "i"), s_ = '"', khe = s_ + " + ", Ahe = " + " + s_;
function Phe(e) {
  return e.replace(new RegExp("\\[", "g"), "{").replace(new RegExp("\\]", "g"), "}");
}
function Rhe(e) {
  return e.replace(new RegExp("\\{", "g"), "[").replace(new RegExp("\\}", "g"), "]");
}
function Jk(e) {
  const t = { expression: "", type: "none" };
  return e.labelExpressionInfo ? e.labelExpressionInfo.value ? (t.expression = e.labelExpressionInfo.value, t.type = "conventional") : e.labelExpressionInfo.expression && (t.expression = e.labelExpressionInfo.expression, t.type = "arcade") : e.labelExpression != null && (t.expression = Phe(e.labelExpression), t.type = "conventional"), t;
}
function Lhe(e) {
  const t = Jk(e);
  if (!t)
    return null;
  switch (t.type) {
    case "conventional":
      return SM(t.expression);
    case "arcade":
      return t.expression;
  }
  return null;
}
function Fhe(e) {
  const t = Jk(e);
  if (!t)
    return null;
  switch (t.type) {
    case "conventional":
      return Dhe(t.expression);
    case "arcade":
      return pB(t.expression);
  }
  return null;
}
function SM(e) {
  let t;
  return e ? (t = Ta(e, (n) => Wk + '$feature["' + n + '"]' + Hk), t = mF.test(t) ? t.replace(mF, "") : s_ + t, t = yF.test(t) ? t.replace(yF, "") : t + s_, t = t.replace(Che, khe).replace(Ohe, Ahe)) : t = '""', t;
}
const Nhe = /^\s*\{([^}]+)\}\s*$/i;
function Dhe(e) {
  const t = e.match(Nhe);
  return t && t[1].trim() || null;
}
const jhe = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*$/i, Vhe = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])(\1|\3)(\5)\s*\));?\s*$/i, zhe = /^\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])([\w\s]+)(\1)\s*\));?\s*$/i;
function pB(e) {
  if (!e)
    return null;
  let t = jhe.exec(e) || Vhe.exec(e);
  return t ? t[1] || t[3] : (t = zhe.exec(e), t ? t[2] : null);
}
var xM;
let wu = xM = class extends se {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(e, t) {
    return t.value ? SM(t.value) : e;
  }
  writeExpression(e, t, n) {
    this.value != null && (e = SM(this.value)), e != null && (t[n] = e);
  }
  clone() {
    return new xM({ expression: this.expression, title: this.title, value: this.value });
  }
};
u([d({ type: String, json: { write: { writerEnsuresNonNull: !0 } } })], wu.prototype, "expression", void 0), u([be("expression", ["expression", "value"])], wu.prototype, "readExpression", null), u([xe("expression")], wu.prototype, "writeExpression", null), u([d({ type: String, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], wu.prototype, "title", void 0), u([d({ json: { read: !1, write: !1 } })], wu.prototype, "value", void 0), wu = xM = u([T("geoscene.layers.support.LabelExpressionInfo")], wu);
const hB = wu, fB = [252, 146, 31, 255], Bhe = { type: "esriSMS", style: "esriSMSCircle", size: 6, color: fB, outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [153, 153, 153, 255] } }, Uhe = { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: fB }, qhe = { type: "esriSFS", style: "esriSFSSolid", color: [252, 146, 31, 196], outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [255, 255, 255, 191] } }, Ghe = { type: "esriTS", color: [255, 255, 255, 255], font: { family: "arial-unicode-ms", size: 10, weight: "bold" }, horizontalAlignment: "center", kerning: !0, haloColor: [0, 0, 0, 255], haloSize: 1, rotated: !1, text: "", xoffset: 0, yoffset: 0, angle: 0 }, Whe = { type: "esriSMS", style: "esriSMSCircle", color: [0, 0, 0, 255], outline: null, size: 10.5 }, Hhe = { type: "esriSLS", style: "esriSLSSolid", color: [0, 0, 0, 255], width: 1.5 }, Jhe = { type: "esriSFS", style: "esriSFSSolid", color: [0, 0, 0, 255], outline: null };
Yf.fromJSON(Bhe);
Hs.fromJSON(Uhe);
Ip.fromJSON(qhe);
const Zhe = Ro.fromJSON(Ghe), UFe = Yf.fromJSON(Whe), qFe = Hs.fromJSON(Hhe), GFe = Ip.fromJSON(Jhe);
var $M;
const Vv = new st({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: !0 });
function mB(e) {
  return !e || e.origin !== "service" && !yB(e.layer);
}
function yB(e) {
  return (e == null ? void 0 : e.type) === "map-image";
}
function gB(e) {
  var t, n;
  return !!yB(e) && !((t = e.capabilities) == null || (n = t.exportMap) == null || !n.supportsArcadeExpressionForLabeling);
}
function Khe(e) {
  return mB(e) || gB(e.layer);
}
let xn = $M = class extends se {
  constructor(e) {
    super(e), this.type = "label", this.name = null, this.allowOverrun = !1, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = !0, this.repeatLabelDistance = null, this.symbol = Zhe, this.useCodedValues = void 0, this.where = null;
  }
  static evaluateWhere(e, t) {
    const n = function(r, i, s) {
      switch (i) {
        case "=":
          return r == s;
        case "<>":
          return r != s;
        case ">":
          return r > s;
        case ">=":
          return r >= s;
        case "<":
          return r < s;
        case "<=":
          return r <= s;
      }
      return !1;
    };
    try {
      if (e == null)
        return !0;
      const r = e.split(" ");
      if (r.length === 3)
        return n(t[r[0]], r[1], r[2]);
      if (r.length === 7) {
        const i = n(t[r[0]], r[1], r[2]), s = r[3], o = n(t[r[4]], r[5], r[6]);
        switch (s) {
          case "AND":
            return i && o;
          case "OR":
            return i || o;
        }
      }
      return !1;
    } catch {
      console.log("Error.: can't parse = " + e);
    }
  }
  readLabelExpression(e, t) {
    const n = t.labelExpressionInfo;
    if (!n || !n.value && !n.expression)
      return e;
  }
  writeLabelExpression(e, t, n) {
    if (this.labelExpressionInfo) {
      if (this.labelExpressionInfo.value != null)
        e = Rhe(this.labelExpressionInfo.value);
      else if (this.labelExpressionInfo.expression != null) {
        const r = pB(this.labelExpressionInfo.expression);
        r && (e = "[" + r + "]");
      }
    }
    e != null && (t[n] = e);
  }
  writeLabelExpressionInfo(e, t, n, r) {
    if (e == null && this.labelExpression != null && mB(r))
      e = new hB({ expression: this.getLabelExpressionArcade() });
    else if (!e)
      return;
    const i = e.toJSON(r);
    i.expression && (t[n] = i);
  }
  writeMaxScale(e, t) {
    (e || this.minScale) && (t.maxScale = e);
  }
  writeMinScale(e, t) {
    (e || this.maxScale) && (t.minScale = e);
  }
  getLabelExpression() {
    return Jk(this);
  }
  getLabelExpressionArcade() {
    return Lhe(this);
  }
  getLabelExpressionSingleField() {
    return Fhe(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new $M({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: q(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: q(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
};
u([d({ type: String, json: { write: !0 } })], xn.prototype, "name", void 0), u([d({ type: Boolean, json: { write: !0, default: !1, origins: { "web-scene": { write: !1 } } } })], xn.prototype, "allowOverrun", void 0), u([d({ type: String, json: { write: !0, default: "static", origins: { "web-scene": { write: !1 } } } })], xn.prototype, "deconflictionStrategy", void 0), u([d({ type: String, json: { write: { overridePolicy(e, t, n) {
  return this.labelExpressionInfo && (n == null ? void 0 : n.origin) === "service" && gB(n.layer) ? { enabled: !1 } : { allowNull: !0 };
} } } })], xn.prototype, "labelExpression", void 0), u([be("labelExpression")], xn.prototype, "readLabelExpression", null), u([xe("labelExpression")], xn.prototype, "writeLabelExpression", null), u([d({ type: hB, json: { write: { overridePolicy: (e, t, n) => Khe(n) ? { allowNull: !0 } : { enabled: !1 } } } })], xn.prototype, "labelExpressionInfo", void 0), u([xe("labelExpressionInfo")], xn.prototype, "writeLabelExpressionInfo", null), u([d({ type: Vv.apiValues, json: { type: Vv.jsonValues, read: Vv.read, write: Vv.write } })], xn.prototype, "labelPlacement", void 0), u([d({ type: ["curved", "parallel"], json: { write: !0, origins: { "web-map": { write: !1 }, "web-scene": { write: !1 }, "portal-item": { write: !1 } } } })], xn.prototype, "labelPosition", void 0), u([d({ type: Number })], xn.prototype, "maxScale", void 0), u([xe("maxScale")], xn.prototype, "writeMaxScale", null), u([d({ type: Number })], xn.prototype, "minScale", void 0), u([xe("minScale")], xn.prototype, "writeMinScale", null), u([d({ type: Boolean, json: { write: !0, origins: { "web-scene": { write: !1 }, "portal-item": { write: !1 } } } })], xn.prototype, "repeatLabel", void 0), u([d({ type: Number, cast: $t, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], xn.prototype, "repeatLabelDistance", void 0), u([d({ types: zee, json: { origins: { "web-scene": { types: Bee, write: HL, default: null } }, write: HL, default: null } })], xn.prototype, "symbol", void 0), u([d({ type: Boolean, json: { write: !0 } })], xn.prototype, "useCodedValues", void 0), u([d({ type: String, json: { write: !0 } })], xn.prototype, "where", void 0), xn = $M = u([T("geoscene.layers.support.LabelClass")], xn);
const Zk = xn;
var TM;
let ji = TM = class extends se {
  constructor(e) {
    super(e), this.type = "cluster", this.clusterRadius = $t("80px"), this.clusterMinSize = $t("12px"), this.clusterMaxSize = $t("50px"), this.popupEnabled = !0, this.popupTemplate = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = !0, this.fields = null;
  }
  clone() {
    return new TM({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: q(this.labelingInfo), labelsVisible: this.labelsVisible, fields: q(this.fields), popupEnabled: this.popupEnabled, popupTemplate: q(this.popupTemplate) });
  }
};
u([d({ type: ["cluster"], readOnly: !0, json: { write: !0 } })], ji.prototype, "type", void 0), u([d({ type: Number, cast: (e) => e === "auto" ? e : $t(e), json: { write: !0 } })], ji.prototype, "clusterRadius", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], ji.prototype, "clusterMinSize", void 0), u([d({ type: Number, cast: $t, json: { write: !0 } })], ji.prototype, "clusterMaxSize", void 0), u([d(sB)], ji.prototype, "popupEnabled", void 0), u([d({ type: lS, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], ji.prototype, "popupTemplate", void 0), u([d({ types: jee })], ji.prototype, "symbol", void 0), u([d({ type: [Zk], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], ji.prototype, "labelingInfo", void 0), u([d(oB)], ji.prototype, "labelsVisible", void 0), u([d({ type: [Mhe], json: { write: !0, origins: { "web-document": { write: !1 }, "portal-item": { write: !1 } } } })], ji.prototype, "fields", void 0), ji = TM = u([T("geoscene.layers.support.FeatureReductionCluster")], ji);
const gF = ji;
var EM;
let $w = EM = class extends xw {
  constructor(e) {
    super(e), this.type = "selection";
  }
  clone() {
    return new EM();
  }
};
u([d({ type: ["selection"] })], $w.prototype, "type", void 0), $w = EM = u([T("geoscene.layers.support.FeatureReductionSelection")], $w);
const vF = $w, Yhe = { types: { key: "type", base: xw, typeMap: { selection: vF, cluster: gF } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: !0 }, origins: { "web-map": { types: { key: "type", base: xw, typeMap: { selection: gF } } }, "web-scene": { types: { key: "type", base: xw, typeMap: { selection: vF } } } } } }, bF = new st({ esriFeatureEditToolAutoCompletePolygon: "auto-complete-polygon", esriFeatureEditToolCircle: "circle", esriFeatureEditToolEllipse: "ellipse", esriFeatureEditToolFreehand: "freehand", esriFeatureEditToolLine: "line", esriFeatureEditToolNone: "none", esriFeatureEditToolPoint: "point", esriFeatureEditToolPolygon: "polygon", esriFeatureEditToolRectangle: "rectangle", esriFeatureEditToolArrow: "arrow", esriFeatureEditToolTriangle: "triangle", esriFeatureEditToolLeftArrow: "left-arrow", esriFeatureEditToolRightArrow: "right-arrow", esriFeatureEditToolUpArrow: "up-arrow", esriFeatureEditToolDownArrow: "down-arrow" });
let _u = class extends Ra(se) {
  constructor(t) {
    super(t), this.name = null, this.description = null, this.drawingTool = null, this.prototype = null, this.thumbnail = null;
  }
};
u([d({ json: { write: !0 } })], _u.prototype, "name", void 0), u([d({ json: { write: !0 } })], _u.prototype, "description", void 0), u([d({ json: { read: bF.read, write: bF.write } })], _u.prototype, "drawingTool", void 0), u([d({ json: { write: !0 } })], _u.prototype, "prototype", void 0), u([d({ json: { write: !0 } })], _u.prototype, "thumbnail", void 0), _u = u([T("geoscene.layers.support.FeatureTemplate")], _u);
const Kk = _u;
let sl = class extends Ra(se) {
  constructor(t) {
    super(t), this.id = null, this.name = null, this.domains = null, this.templates = null;
  }
  readDomains(t) {
    const n = {};
    for (const r of Object.keys(t))
      n[r] = pk(t[r]);
    return n;
  }
  writeDomains(t, n) {
    const r = {};
    for (const s of Object.keys(t)) {
      var i;
      t[s] && (r[s] = (i = t[s]) == null ? void 0 : i.toJSON());
    }
    n.domains = r;
  }
};
u([d({ json: { write: !0 } })], sl.prototype, "id", void 0), u([d({ json: { write: !0 } })], sl.prototype, "name", void 0), u([d({ json: { write: !0 } })], sl.prototype, "domains", void 0), u([be("domains")], sl.prototype, "readDomains", null), u([xe("domains")], sl.prototype, "writeDomains", null), u([d({ type: [Kk], json: { write: !0 } })], sl.prototype, "templates", void 0), sl = u([T("geoscene.layers.support.FeatureType")], sl);
const vB = sl;
function Qhe(e) {
  return e.type === "date" || e.type === "esriFieldTypeDate";
}
function wF(e) {
  return e.type === "oid" || e.type === "esriFieldTypeOID";
}
function _F(e) {
  return e.type === "global-id" || e.type === "esriFieldTypeGlobalID";
}
let Xhe = class {
  constructor(t) {
    if (this.fields = t, this._fieldsMap = /* @__PURE__ */ new Map(), this._dateFieldsSet = /* @__PURE__ */ new Set(), this._numericFieldsSet = /* @__PURE__ */ new Set(), this.dateFields = [], this.numericFields = [], this._requiredFields = null, !t)
      return;
    const n = [];
    for (const r of t) {
      const i = r && r.name;
      if (i) {
        const s = SF(i);
        this._fieldsMap.set(i, r), this._fieldsMap.set(s, r), n.push(s), Qhe(r) ? (this.dateFields.push(r), this._dateFieldsSet.add(r)) : EO(r) && (this._numericFieldsSet.add(r), this.numericFields.push(r)), wF(r) || _F(r) || (r.editable = r.editable == null || !!r.editable, r.nullable = r.nullable == null || !!r.nullable);
      }
    }
    n.sort(), this.uid = n.join(",");
  }
  destroy() {
    this._fieldsMap.clear();
  }
  get requiredFields() {
    if (!this._requiredFields) {
      this._requiredFields = [];
      for (const t of this.fields)
        wF(t) || _F(t) || t.nullable || aX(t) !== void 0 || this._requiredFields.push(t);
    }
    return this._requiredFields;
  }
  has(t) {
    return this.get(t) != null;
  }
  get(t) {
    return t != null ? this._fieldsMap.get(t) || this._fieldsMap.get(SF(t)) : void 0;
  }
  isDateField(t) {
    return this._dateFieldsSet.has(this.get(t));
  }
  isNumericField(t) {
    return this._numericFieldsSet.has(this.get(t));
  }
  normalizeFieldName(t) {
    const n = this.get(t);
    if (n)
      return n.name;
  }
};
function SF(e) {
  return e.toLowerCase().trim();
}
const efe = we.getLogger("geoscene.layers.support.fieldProperties");
function tfe() {
  return { fields: { type: [_S], value: null }, fieldsIndex: { readOnly: !0, get() {
    return new Xhe(this.fields || []);
  } }, outFields: { type: [String], json: { read: !1 }, set: function(e) {
    this._userOutFields = e, this.notifyChange("outFields");
  }, get: function() {
    const e = this._userOutFields;
    if (!e || !e.length)
      return null;
    if (e.includes("*"))
      return ["*"];
    if (!this.fields)
      return e;
    for (const t of e)
      this.fieldsIndex.has(t) || efe.error("field-attributes-layer:invalid-field", `Invalid field ${t} found in outFields`, { layer: this, outFields: e });
    return R6(this.fieldsIndex, e);
  } } };
}
let Ih = class extends Ra(se) {
  constructor(t) {
    super(t), this.shapeAreaField = null, this.shapeLengthField = null, this.units = null;
  }
};
u([d({ type: String, json: { read: { source: "shapeAreaFieldName" } } })], Ih.prototype, "shapeAreaField", void 0), u([d({ type: String, json: { read: { source: "shapeLengthFieldName" } } })], Ih.prototype, "shapeLengthField", void 0), u([d({ type: String, json: { read: (e) => Fte.read(e) || Nte.read(e) } })], Ih.prototype, "units", void 0), Ih = u([T("geoscene.layers.support.GeometryFieldsInfo")], Ih);
const nfe = Ih, rfe = /\[([^\[\]]+)\]/gi;
function xF(e, t, n) {
  return e ? e.map((r) => {
    const i = new Zk();
    if (i.read(r, n), i.labelExpression) {
      const s = t.fields || t.layerDefinition && t.layerDefinition.fields || this.fields;
      i.labelExpression = i.labelExpression.replace(rfe, (o, a) => `[${ife(a, s)}]`);
    }
    return i;
  }) : null;
}
function ife(e, t) {
  if (!t)
    return e;
  const n = e.toLowerCase();
  for (let r = 0; r < t.length; r++) {
    const i = t[r].name;
    if (i.toLowerCase() === n)
      return i;
  }
  return e;
}
var IM;
let Mh = IM = class extends se {
  constructor(e) {
    super(e), this.floorField = null, this.viewAllMode = !1, this.viewAllLevelIds = new Ne();
  }
  clone() {
    return new IM({ floorField: this.floorField, viewAllMode: this.viewAllMode, viewAllLevelIds: this.viewAllLevelIds });
  }
};
u([d({ type: String, json: { write: !0 } })], Mh.prototype, "floorField", void 0), u([d({ json: { read: !1, write: !1 } })], Mh.prototype, "viewAllMode", void 0), u([d({ json: { read: !1, write: !1 } })], Mh.prototype, "viewAllLevelIds", void 0), Mh = IM = u([T("geoscene.layers.support.LayerFloorInfo")], Mh);
const sfe = Mh, $F = new st({ esriRelCardinalityOneToOne: "one-to-one", esriRelCardinalityOneToMany: "one-to-many", esriRelCardinalityManyToMany: "many-to-many" }), TF = new st({ esriRelRoleOrigin: "origin", esriRelRoleDestination: "destination" });
let Ts = class extends Ra(se) {
  constructor(t) {
    super(t), this.cardinality = null, this.composite = null, this.id = null, this.keyField = null, this.keyFieldInRelationshipTable = null, this.name = null, this.relatedTableId = null, this.relationshipTableId = null, this.role = null;
  }
};
u([d({ json: { read: $F.read, write: $F.write } })], Ts.prototype, "cardinality", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "composite", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "id", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "keyField", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "keyFieldInRelationshipTable", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "name", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "relatedTableId", void 0), u([d({ json: { read: !0, write: !0 } })], Ts.prototype, "relationshipTableId", void 0), u([d({ json: { read: TF.read, write: TF.write } })], Ts.prototype, "role", void 0), Ts = u([T("geoscene.layers.support.Relationship")], Ts);
const ofe = Ts, bo = [];
function afe(e, t) {
  if (B7(e.url))
    return !0;
  const { wkid: n } = t;
  for (const r of bo) {
    if (e.version >= r[0])
      return !0;
    if (typeof r[1] == "function" && (r[1] = r[1]()), r[1].has(n))
      return !1;
  }
  return !0;
}
bo.push([10.91, () => {
  const e = /* @__PURE__ */ new Set([9709, 9716, 9741, 9761, 9766]);
  for (let t = 9712; t <= 9713; t++)
    e.add(t);
  for (let t = 9748; t <= 9749; t++)
    e.add(t);
  for (let t = 20904; t <= 20932; t++)
    e.add(t);
  for (let t = 21004; t <= 21032; t++)
    e.add(t);
  for (let t = 21207; t <= 21264; t++)
    e.add(t);
  for (let t = 21307; t <= 21364; t++)
    e.add(t);
  for (let t = 102759; t <= 102760; t++)
    e.add(t);
  for (let t = 102901; t <= 102960; t++)
    e.add(t);
  return e;
}]), bo.push([10.9, () => {
  const e = /* @__PURE__ */ new Set([9300, 9354, 9364, 9367, 9373, 9377, 9387, 9456, 9473, 9498, 9678, 9680, 29874, 103599, 103872, 104028]);
  for (let t = 9356; t <= 9360; t++)
    e.add(t);
  for (let t = 9404; t <= 9407; t++)
    e.add(t);
  for (let t = 9476; t <= 9482; t++)
    e.add(t);
  for (let t = 9487; t <= 9494; t++)
    e.add(t);
  for (let t = 9697; t <= 9699; t++)
    e.add(t);
  return e;
}]), bo.push([10.81, () => {
  const e = /* @__PURE__ */ new Set([9265, 9333, 103598, 103699]);
  for (let t = 9248; t <= 9254; t++)
    e.add(t);
  for (let t = 9271; t <= 9273; t++)
    e.add(t);
  for (let t = 9284; t <= 9285; t++)
    e.add(t);
  for (let t = 21453; t <= 21463; t++)
    e.add(t);
  return e;
}]), bo.push([10.8, () => {
  const e = /* @__PURE__ */ new Set([8088, 8395, 8428, 8433, 8531, 8687, 8692, 8694, 8699, 8900, 9003, 9006, 9009, 9012, 9017, 9191]);
  for (let t = 8035; t <= 8036; t++)
    e.add(t);
  for (let t = 8455; t <= 8456; t++)
    e.add(t);
  for (let t = 8518; t <= 8529; t++)
    e.add(t);
  for (let t = 8533; t <= 8536; t++)
    e.add(t);
  for (let t = 8538; t <= 8540; t++)
    e.add(t);
  for (let t = 8677; t <= 8679; t++)
    e.add(t);
  for (let t = 8902; t <= 8903; t++)
    e.add(t);
  for (let t = 8907; t <= 8910; t++)
    e.add(t);
  for (let t = 8949; t <= 8951; t++)
    e.add(t);
  for (let t = 8972; t <= 8987; t++)
    e.add(t);
  for (let t = 9039; t <= 9040; t++)
    e.add(t);
  for (let t = 9068; t <= 9069; t++)
    e.add(t);
  for (let t = 9140; t <= 9141; t++)
    e.add(t);
  for (let t = 9148; t <= 9150; t++)
    e.add(t);
  for (let t = 9153; t <= 9159; t++)
    e.add(t);
  for (let t = 9205; t <= 9218; t++)
    e.add(t);
  for (let t = 9221; t <= 9222; t++)
    e.add(t);
  for (let t = 54098; t <= 54101; t++)
    e.add(t);
  return e;
}]), bo.push([10.71, () => {
  const e = /* @__PURE__ */ new Set([6316]);
  for (let t = 8351; t <= 8353; t++)
    e.add(t);
  for (let t = 9294; t <= 9297; t++)
    e.add(t);
  for (let t = 103586; t <= 103594; t++)
    e.add(t);
  for (let t = 103696; t <= 103698; t++)
    e.add(t);
  return e;
}]), bo.push([10.7, () => {
  const e = /* @__PURE__ */ new Set([8387, 8391, 8427, 8545, 8682, 8685, 8818, 31370, 104022, 104024, 104975]);
  for (let t = 8065; t <= 8068; t++)
    e.add(t);
  for (let t = 8082; t <= 8083; t++)
    e.add(t);
  for (let t = 8379; t <= 8385; t++)
    e.add(t);
  for (let t = 8836; t <= 8840; t++)
    e.add(t);
  for (let t = 8857; t <= 8860; t++)
    e.add(t);
  for (let t = 53035; t <= 53037; t++)
    e.add(t);
  for (let t = 54090; t <= 54091; t++)
    e.add(t);
  for (let t = 102498; t <= 102499; t++)
    e.add(t);
  return e;
}]), bo.push([10.61, () => /* @__PURE__ */ new Set([102497])]), bo.push([10.6, () => {
  const e = /* @__PURE__ */ new Set([7803, 7805, 7887, 8086, 8232, 8237, 8240, 8246, 8249, 8252, 8255, 9019, 9391]);
  for (let t = 7755; t <= 7787; t++)
    e.add(t);
  for (let t = 7791; t <= 7795; t++)
    e.add(t);
  for (let t = 7799; t <= 7801; t++)
    e.add(t);
  for (let t = 7825; t <= 7831; t++)
    e.add(t);
  for (let t = 7877; t <= 7878; t++)
    e.add(t);
  for (let t = 7882; t <= 7883; t++)
    e.add(t);
  for (let t = 7991; t <= 7992; t++)
    e.add(t);
  for (let t = 8042; t <= 8043; t++)
    e.add(t);
  for (let t = 8058; t <= 8059; t++)
    e.add(t);
  for (let t = 8311; t <= 8348; t++)
    e.add(t);
  for (let t = 9060; t <= 9067; t++)
    e.add(t);
  for (let t = 102562; t <= 102568; t++)
    e.add(t);
  for (let t = 102799; t <= 102900; t++)
    e.add(t);
  return e;
}]), bo.push([10.51, () => {
  const e = /* @__PURE__ */ new Set([7683, 7881, 7886, 7899, 8888, 9e3]);
  for (let t = 8013; t <= 8032; t++)
    e.add(t);
  for (let t = 9053; t <= 9057; t++)
    e.add(t);
  for (let t = 104017; t <= 104018; t++)
    e.add(t);
  for (let t = 104971; t <= 104974; t++)
    e.add(t);
  return e;
}]), bo.push([10.5, () => {
  const e = /* @__PURE__ */ new Set([6962, 7035, 7037, 7039, 7041, 7084, 7086, 7133, 7798, 102399]);
  for (let t = 4087; t <= 4088; t++)
    e.add(t);
  for (let t = 5896; t <= 5899; t++)
    e.add(t);
  for (let t = 7005; t <= 7007; t++)
    e.add(t);
  for (let t = 7057; t <= 7070; t++)
    e.add(t);
  for (let t = 7073; t <= 7082; t++)
    e.add(t);
  for (let t = 7109; t <= 7128; t++)
    e.add(t);
  for (let t = 7844; t <= 7859; t++)
    e.add(t);
  return e;
}]);
async function lfe(e, t, n) {
  const r = e && e.getAtOrigin && e.getAtOrigin("renderer", t.origin);
  if (r && r.type === "unique-value" && r.styleOrigin) {
    const i = await K_(r.populateFromStyle());
    if (On(n), i.ok === !1) {
      const s = i.error;
      t && t.messages && t.messages.push(new Ds("renderer:style-reference", `Failed to create unique value renderer from style reference: ${s.message}`, { error: s, context: t })), e.clear("renderer", t.origin);
    }
  }
}
const ufe = ["oid", "global-id"], cfe = ["oid", "global-id", "guid"];
function dfe({ displayField: e, editFieldsInfo: t, fields: n, objectIdField: r, title: i }, s) {
  if (!n)
    return null;
  const o = gfe({ editFieldsInfo: t, fields: n, objectIdField: r }, s);
  if (!o.length)
    return null;
  const a = wfe({ titleBase: i, fields: n, displayField: e }), l = bfe();
  return new lS({ title: a, content: l, fieldInfos: o });
}
const pfe = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i], hfe = (e, { editFieldsInfo: t, objectIdField: n, visibleFieldNames: r }) => r ? r.has(e.name) : !bB(e.name, t) && (!n || e.name !== n) && !(ufe.indexOf(e.type) > -1) && !pfe.some((i) => i.test(e.name));
function ffe(e, t) {
  const n = e;
  return t && (e = e.filter((r) => t.indexOf(r.type) === -1)), e === n && (e = e.slice()), e.sort(mfe), e;
}
function mfe(e, t) {
  return e.type === "oid" ? -1 : t.type === "oid" ? 1 : EF(e) ? -1 : EF(t) ? 1 : (e.alias || e.name).toLocaleLowerCase().localeCompare((t.alias || t.name).toLocaleLowerCase());
}
function bB(e, t) {
  if (!e || !t)
    return !1;
  const { creationDateField: n, creatorField: r, editDateField: i, editorField: s } = t;
  return [n && n.toLowerCase(), r && r.toLowerCase(), i && i.toLowerCase(), s && s.toLowerCase()].indexOf(e.toLowerCase()) !== -1;
}
function yfe(e, t) {
  return e.editable && cfe.indexOf(e.type) === -1 && !bB(e.name, t);
}
function gfe({ editFieldsInfo: e, fields: t, objectIdField: n }, r) {
  return ffe(t, (r == null ? void 0 : r.ignoreFieldTypes) || _fe).map((i) => new _0({ fieldName: i.name, isEditable: yfe(i, e), label: i.alias, format: vfe(i), visible: hfe(i, { editFieldsInfo: e, objectIdField: n, visibleFieldNames: r == null ? void 0 : r.visibleFieldNames }) }));
}
function vfe(e) {
  switch (e.type) {
    case "small-integer":
    case "integer":
    case "single":
      return new Xy({ digitSeparator: !0, places: 0 });
    case "double":
      return new Xy({ digitSeparator: !0, places: 2 });
    case "date":
      return new Xy({ dateFormat: "long-month-day-year" });
    default:
      return null;
  }
}
function bfe() {
  return [new gf(), new Pg()];
}
function wfe(e) {
  const t = nX(e), { titleBase: n } = e;
  return t ? `${n}: {${t.trim()}}` : n;
}
function EF(e) {
  return (e.name && e.name.toLowerCase()) === "name" ? !0 : (e.alias && e.alias.toLowerCase()) === "name" || void 0;
}
const _fe = ["geometry", "blob", "raster", "guid", "xml"], Ix = new st({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" }), Sfe = { name: "supportsName", size: "supportsSize", contentType: "supportsContentType", keywords: "supportsKeywords", exifInfo: "supportsExifInfo" }, Sn = "FeatureLayer", IF = we.getLogger("geoscene.layers.FeatureLayer");
function MF(e) {
  return e && e instanceof Ne;
}
function He(e, t, n) {
  return !!(e && e.hasOwnProperty(t) ? e[t] : n);
}
function zv(e, t, n) {
  return e && e.hasOwnProperty(t) ? e[t] : n;
}
function xfe(e) {
  var t;
  const n = e == null || (t = e.supportedSpatialAggregationStatistics) == null ? void 0 : t.map((r) => r.toLowerCase());
  return { envelope: !(n == null || !n.includes("envelopeaggregate")), centroid: !(n == null || !n.includes("centroidaggregate")), convexHull: !(n == null || !n.includes("convexhullaggregate")) };
}
const Mx = tfe();
function Cx(e, t, n) {
  const r = !(n == null || !n.writeLayerSchema);
  return { enabled: r, ignoreOrigin: r };
}
let ue = class extends ehe(rB(ghe(Ehe(cB(xhe(vpe(fhe(bhe(P7(Ype(cpe(Ra(iS))))))))))))) {
  constructor(...e) {
    super(...e), this._handles = new ei(), this.capabilities = null, this.charts = null, this.copyright = null, this.datesInUnknownTimezone = !1, this.displayField = null, this.definitionExpression = null, this.dynamicDataSource = null, this.editFieldsInfo = null, this.editingInfo = null, this.elevationInfo = null, this.featureReduction = null, this.fields = null, this.fieldsIndex = null, this.floorInfo = null, this.formTemplate = null, this.fullExtent = null, this.gdbVersion = null, this.geometryFieldsInfo = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.heightModelInfo = null, this.historicMoment = null, this.infoFor3D = null, this.isTable = !1, this.labelsVisible = !0, this.labelingInfo = null, this.layerId = void 0, this.legendEnabled = !0, this.minScale = 0, this.maxScale = 0, this.globalIdField = null, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = !0, this.popupTemplate = null, this.relationships = null, this.sourceJSON = null, this.returnM = void 0, this.returnZ = void 0, this.screenSizePerspectiveEnabled = !0, this.serviceDefinitionExpression = null, this.spatialReference = Qe.WGS84, this.subtypeCode = null, this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.trackIdField = null, this.type = "feature", this.typeIdField = null, this.types = null, this.indexes = new (Ne.ofType(hl))(), this.userIsAdmin = !1, this.version = void 0, this.visible = !0;
  }
  destroy() {
    var e;
    (e = this.source) == null || e.destroy(), this._handles = pa(this._handles);
  }
  normalizeCtorArgs(e, t) {
    return typeof e == "string" ? { url: e, ...t } : e;
  }
  load(e) {
    const t = O(e) ? e.signal : null;
    if (this.portalItem && this.portalItem.loaded && this.source)
      return void this.addResolvingPromise(this.createGraphicsSource(t).then((r) => this._initLayerProperties(r)));
    const n = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection"] }, e).catch(y0).then(async () => {
      if (this.url && this.layerId == null && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const r = await this._fetchFirstLayerId(t);
        r != null && (this.layerId = r);
      }
      if (!this.url && !this._hasMemorySource())
        throw new D("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this._initLayerProperties(await this.createGraphicsSource(t));
    }).then(() => this.finishLoadEditablePortalLayer(e));
    return this.addResolvingPromise(n), Promise.resolve(this);
  }
  readCapabilities(e, t) {
    return t = t.layerDefinition || t, { attachment: this._readAttachmentCapabilities(t.attachmentProperties), data: this._readDataCapabilities(t), metadata: this._readMetadataCapabilities(t), operations: this._readOperationsCapabilities(t.capabilities || e, t), query: this._readQueryCapabilities(t), queryRelated: this._readQueryRelatedCapabilities(t), editing: this._readEditingCapabilities(t) };
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") || 0) + 1;
  }
  get editingEnabled() {
    return !(this.loaded && !this.capabilities.operations.supportsEditing) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e) {
    e != null ? this._override("editingEnabled", e) : this._clearOverride("editingEnabled");
  }
  readEditingEnabled(e, t) {
    return this._readEditingEnabled(t, !1);
  }
  readEditingEnabledFromWebMap(e, t, n) {
    return this._readEditingEnabled(t, !0, n);
  }
  writeEditingEnabled(e, t) {
    this._writeEditingEnabled(e, t, !1);
  }
  writeEditingEnabledToWebMap(e, t, n, r) {
    this._writeEditingEnabled(e, t, !0, r);
  }
  readEditingInfo(e, t) {
    const { editingInfo: n } = t;
    return n ? { lastEditDate: n.lastEditDate != null ? new Date(n.lastEditDate) : null } : null;
  }
  readIsTable(e, t) {
    return (t = t && t.layerDefinition || t).type === "Table" || !t.geometryType;
  }
  writeIsTable(e, t, n, r) {
    r != null && r.writeLayerSchema && ss(n, e ? "Table" : "Feature Layer", t);
  }
  readMinScale(e, t) {
    return t.effectiveMinScale || e || 0;
  }
  readMaxScale(e, t) {
    return t.effectiveMaxScale || e || 0;
  }
  readGlobalIdFieldFromService(e, t) {
    if ((t = t.layerDefinition || t).globalIdField)
      return t.globalIdField;
    if (t.fields) {
      for (const n of t.fields)
        if (n.type === "esriFieldTypeGlobalID")
          return n.name;
    }
  }
  readObjectIdFieldFromService(e, t) {
    if ((t = t.layerDefinition || t).objectIdField)
      return t.objectIdField;
    if (t.fields) {
      for (const n of t.fields)
        if (n.type === "esriFieldTypeOID")
          return n.name;
    }
  }
  get parsedUrl() {
    const e = this.url ? cr(this.url) : null;
    return e != null && (this.dynamicDataSource != null ? e.path = Xu(e.path, "dynamicLayer") : this.layerId != null && (e.path = Xu(e.path, this.layerId.toString()))), e;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e) {
    wP(e, this.fieldsIndex), this._set("renderer", e);
  }
  readRenderer(e, t, n) {
    const r = (t = t.layerDefinition || t).drawingInfo && t.drawingInfo.renderer || void 0;
    if (r) {
      const i = O7(r, t, n) || void 0;
      return i || IF.error("Failed to create renderer", { rendererDefinition: t.drawingInfo.renderer, layer: this, context: n }), i;
    }
    if (t.defaultSymbol)
      return t.types && t.types.length ? new jk({ defaultSymbol: Ox(t.defaultSymbol, t, n), field: t.typeIdField, uniqueValueInfos: t.types.map((i) => ({ id: i.id, symbol: Ox(i.symbol, i, n) })) }) : new Dk({ symbol: Ox(t.defaultSymbol, t, n) });
  }
  set source(e) {
    const t = this._get("source");
    t !== e && (MF(t) && this._resetMemorySource(t), MF(e) && this._initMemorySource(e), this._set("source", e));
  }
  castSource(e) {
    return e ? Array.isArray(e) || e instanceof Ne ? new lF({ layer: this, items: e }) : e : null;
  }
  readSource(e, t) {
    const n = kp.fromJSON(t.featureSet);
    return new lF({ layer: this, items: n && n.features || [] });
  }
  readServiceDefinitionExpression(e, t) {
    return t.definitionQuery || t.definitionExpression;
  }
  readTemplates(e, t) {
    const n = t.editFieldsInfo, r = n && n.creatorField, i = n && n.editorField;
    return e = e && e.map((s) => Kk.fromJSON(s)), this._fixTemplates(e, r), this._fixTemplates(e, i), e;
  }
  readTitle(e, t) {
    const n = t.layerDefinition && t.layerDefinition.name || t.name, r = t.title || t.layerDefinition && t.layerDefinition.title;
    if (n) {
      const i = this.portalItem && this.portalItem.title;
      if (this.sublayerTitleMode === "item-title")
        return this.url ? fpe(this.url, n) : n;
      let s = n;
      if (!s && this.url) {
        const o = z0(this.url);
        O(o) && (s = o.title);
      }
      return s ? (this.sublayerTitleMode === "item-title-and-service-name" && i && i !== s && (s = i + " - " + s), zk(s)) : void 0;
    }
    if (this.sublayerTitleMode === "item-title" && r)
      return r;
  }
  readTitleFromWebMap(e, t) {
    return t.title || t.layerDefinition && t.layerDefinition.name;
  }
  readTypeIdField(e, t) {
    let n = (t = t.layerDefinition || t).typeIdField;
    if (n && t.fields) {
      n = n.toLowerCase();
      const r = t.fields.find((i) => i.name.toLowerCase() === n);
      r && (n = r.name);
    }
    return n;
  }
  readTypes(e, t) {
    e = (t = t.layerDefinition || t).types;
    const n = t.editFieldsInfo, r = n && n.creatorField, i = n && n.editorField;
    return e && e.map((s) => (s = vB.fromJSON(s), this._fixTemplates(s.templates, r), this._fixTemplates(s.templates, i), s));
  }
  set url(e) {
    const t = ype({ layer: this, url: e, nonStandardUrlAllowed: !0, logger: IF });
    this._set("url", t.url), t.layerId != null && this._set("layerId", t.layerId);
  }
  writeUrl(e, t, n, r) {
    gpe(this, e, null, t, r);
  }
  readVersion(e, t) {
    return t.currentVersion ? t.currentVersion : t.hasOwnProperty("capabilities") || t.hasOwnProperty("drawingInfo") || t.hasOwnProperty("hasAttachments") || t.hasOwnProperty("htmlPopupType") || t.hasOwnProperty("relationships") || t.hasOwnProperty("timeInfo") || t.hasOwnProperty("typeIdField") || t.hasOwnProperty("types") ? 10 : 9.3;
  }
  readVisible(e, t) {
    return t.layerDefinition && t.layerDefinition.defaultVisibility != null ? !!t.layerDefinition.defaultVisibility : t.visibility != null ? !!t.visibility : void 0;
  }
  addAttachment(e, t) {
    return this.load().then(() => this._checkAttachmentSupport(e)).then(() => {
      if (!("addAttachment" in this.source))
        throw new D(Sn, "Layer source does not support addAttachment capability");
      return this.source.addAttachment(e, t);
    });
  }
  updateAttachment(e, t, n) {
    return this.load().then(() => this._checkAttachmentSupport(e)).then(() => {
      if (!("updateAttachment" in this.source))
        throw new D(Sn, "Layer source does not support updateAttachment capability");
      return this.source.updateAttachment(e, t, n);
    });
  }
  async applyEdits(e, t) {
    const n = await import("./editingSupport-4-whPc23.js");
    return await this.load(), n.applyEdits(this, this.source, e, t);
  }
  on(e, t) {
    return super.on(e, t);
  }
  createPopupTemplate(e) {
    return dfe(this, e);
  }
  async createGraphicsSource(e) {
    if (this._hasMemorySource())
      return this.source.load({ signal: e });
    const { default: t } = await YD(import("./FeatureLayerSource-Mf_723nT.js"), e);
    return new t({ layer: this }).load({ signal: e });
  }
  createQuery() {
    const e = new Jr(), t = this.get("capabilities.data"), n = this.get("capabilities.query");
    e.dynamicDataSource = this.dynamicDataSource, e.historicMoment = this.historicMoment, e.gdbVersion = this.gdbVersion, e.returnGeometry = !0, n && (e.compactGeometryEnabled = n.supportsCompactGeometry, e.defaultSpatialReferenceEnabled = n.supportsDefaultSpatialReference), t && (t.supportsZ && this.returnZ != null && (e.returnZ = this.returnZ), t.supportsM && this.returnM != null && (e.returnM = this.returnM)), e.outFields = ["*"], e.where = this.definitionExpression || "1=1";
    const { timeOffset: r, timeExtent: i } = this;
    return e.timeExtent = r != null && i != null ? i.offset(-r.value, r.unit) : i || null, e.multipatchOption = this.geometryType === "multipatch" ? "xyFootprint" : null, e;
  }
  deleteAttachments(e, t) {
    return this.load().then(() => this._checkAttachmentSupport(e)).then(() => {
      if (!("deleteAttachments" in this.source))
        throw new D(Sn, "Layer source does not support deleteAttachments capability");
      return this.source.deleteAttachments(e, t);
    });
  }
  fetchRecomputedExtents(e) {
    return this.load({ signal: e == null ? void 0 : e.signal }).then(() => {
      if (this.source.fetchRecomputedExtents)
        return this.source.fetchRecomputedExtents(e);
      throw new D(Sn, "Layer source does not support fetchUpdates capability");
    });
  }
  getFeatureType(e) {
    const { typeIdField: t, types: n } = this;
    if (!t || !e)
      return null;
    const r = e.attributes ? e.attributes[t] : void 0;
    if (r == null)
      return null;
    let i = null;
    return n.some((s) => {
      const { id: o } = s;
      return o != null && (o.toString() === r.toString() && (i = s), !!i);
    }), i;
  }
  getFieldDomain(e, t) {
    const n = t && t.feature, r = this.getFeatureType(n);
    if (r) {
      const i = r.domains && r.domains[e];
      if (i && i.type !== "inherited")
        return i;
    }
    return this._getLayerDomain(e);
  }
  getField(e) {
    return this.fieldsIndex.get(e);
  }
  queryAttachments(e, t) {
    return e = U1.from(e), this.load().then(() => {
      if (!this.get("capabilities.data.supportsAttachment"))
        throw new D(Sn, "this layer doesn't support attachments");
      const { attachmentTypes: n, objectIds: r, globalIds: i, num: s, size: o, start: a, where: l } = e;
      if (!this.get("capabilities.operations.supportsQueryAttachments")) {
        const c = r && r.length > 1, p = n && n.length, f = i && i.length, m = o && o.length;
        if (c || p || f || m || s || a || l)
          throw new D(Sn, "when 'supportsQueryAttachments' is false, only objectIds of length 1 are supported", e);
      }
      if (!(r && r.length || l))
        throw new D(Sn, "'objectIds' or 'where' are required to perform attachment query", e);
      if (!("queryAttachments" in this.source))
        throw new D(Sn, "Layer source does not support queryAttachments capability", e);
      return this.source.queryAttachments(e);
    });
  }
  queryFeatures(e, t) {
    return this.load().then(() => this.source.queryFeatures(Jr.from(e) || this.createQuery(), t)).then((n) => {
      if (n != null && n.features)
        for (const r of n.features)
          r.layer = r.sourceLayer = this;
      return n;
    });
  }
  queryObjectIds(e, t) {
    return this.load().then(() => {
      if (this.source.queryObjectIds)
        return this.source.queryObjectIds(Jr.from(e) || this.createQuery(), t);
      throw new D(Sn, "Layer source does not support queryObjectIds capability");
    });
  }
  queryFeatureCount(e, t) {
    return this.load().then(() => {
      if (this.source.queryFeatureCount)
        return this.source.queryFeatureCount(Jr.from(e) || this.createQuery(), t);
      throw new D(Sn, "Layer source does not support queryFeatureCount capability");
    });
  }
  queryExtent(e, t) {
    return this.load().then(() => {
      if (this.source.queryExtent)
        return this.source.queryExtent(Jr.from(e) || this.createQuery(), t);
      throw new D(Sn, "Layer source does not support queryExtent capability");
    });
  }
  queryRelatedFeatures(e, t) {
    return this.load().then(() => {
      if ("queryRelatedFeatures" in this.source)
        return this.source.queryRelatedFeatures(hp.from(e), t);
      throw new D(Sn, "Layer source does not support queryRelatedFeatures capability");
    });
  }
  queryRelatedFeaturesCount(e, t) {
    return this.load().then(() => {
      if ("queryRelatedFeaturesCount" in this.source)
        return this.source.queryRelatedFeaturesCount(hp.from(e), t);
      throw new D(Sn, "Layer source does not support queryRelatedFeaturesCount capability");
    });
  }
  queryTopFeatures(e, t) {
    return this.load().then(() => {
      if ("queryTopFeatures" in this.source && this.get("capabilities.query.supportsTopFeaturesQuery"))
        return this.source.queryTopFeatures(Wu.from(e), t).then((n) => {
          if (n != null && n.features)
            for (const r of n.features)
              r.layer = r.sourceLayer = this;
          return n;
        });
      throw new D(Sn, "Layer source does not support queryTopFeatures capability");
    });
  }
  queryTopObjectIds(e, t) {
    return this.load().then(() => {
      if ("queryTopObjectIds" in this.source && this.get("capabilities.query.supportsTopFeaturesQuery"))
        return this.source.queryTopObjectIds(Wu.from(e), t);
      throw new D(Sn, "Layer source does not support queryTopObjectIds capability");
    });
  }
  queryTopFeaturesExtent(e, t) {
    return this.load().then(() => {
      if ("queryTopExtents" in this.source && this.get("capabilities.query.supportsTopFeaturesQuery"))
        return this.source.queryTopExtents(Wu.from(e), t);
      throw new D(Sn, "Layer source does not support queryTopExtents capability");
    });
  }
  queryTopFeatureCount(e, t) {
    return this.load().then(() => {
      if ("queryTopCount" in this.source && this.get("capabilities.query.supportsTopFeaturesQuery"))
        return this.source.queryTopCount(Wu.from(e), t);
      throw new D(Sn, "Layer source does not support queryFeatureCount capability");
    });
  }
  read(e, t) {
    const n = e.featureCollection;
    if (n) {
      const r = n.layers;
      r && r.length === 1 && (super.read(r[0], t), n.showLegend != null && super.read({ showLegend: n.showLegend }, t));
    }
    super.read(e, t), t && t.origin === "service" && this.revert(["objectIdField", "fields", "timeInfo", "spatialReference"], "service");
  }
  write(e, t) {
    var n, r;
    const i = (t = { ...t, writeLayerSchema: (n = (r = t) == null ? void 0 : r.writeLayerSchema) != null ? n : this._hasMemorySource() }).origin, s = t.layerContainerType, o = t.messages;
    if (this.isTable) {
      if (i === "web-scene" || i === "web-map" && s !== "tables")
        return o && o.push(new D("layer:unsupported", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a Table source cannot be written to web scenes and web maps`, { layer: this })), null;
      if (this._hasMemorySource())
        return o && o.push(new D("layer:unsupported", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using an in-memory Table source cannot be written to web scenes and web maps`, { layer: this })), null;
    } else if (this.loaded && i === "web-map" && s === "tables")
      return o && o.push(new D("layer:unsupported", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a non-table source cannot be written to tables in web maps`, { layer: this })), null;
    return super.write(e, t);
  }
  clone() {
    if (this._hasMemorySource())
      throw new D(Sn, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e) {
    return !!this.loaded && (this.source.type === "memory" || afe(this, e));
  }
  _readEditingEnabled(e, t, n) {
    var r;
    let i = (r = e.layerDefinition) == null ? void 0 : r.capabilities;
    return i ? this._hasEditingCapability(i) : (i = e.capabilities, t && (n == null ? void 0 : n.origin) === "web-map" && !this._hasMemorySource() && i ? this._hasEditingCapability(i) : void 0);
  }
  _hasEditingCapability(e) {
    return e.toLowerCase().split(",").map((t) => t.trim()).includes("editing");
  }
  _writeEditingEnabled(e, t, n, r) {
    if (!e) {
      var i, s;
      const o = (i = this.capabilities) != null && (s = i.operations) != null && s.supportsSync ? "Query,Sync" : "Query";
      ss("layerDefinition.capabilities", o, t), !n || r != null && r.writeLayerSchema || (t.capabilities = o);
    }
  }
  _checkAttachmentSupport(e) {
    const { attributes: t } = e, { objectIdField: n } = this;
    return this.get("capabilities.data.supportsAttachment") ? e ? t ? t[n] ? void 0 : Promise.reject(new D(Sn, `feature is missing the identifying attribute ${n}`)) : Promise.reject(new D(Sn, "'attributes' are required on a feature to query attachments")) : Promise.reject(new D(Sn, "A feature is required to add/delete/update attachments")) : Promise.reject(new D(Sn, "this layer doesn't support attachments"));
  }
  _getLayerDomain(e) {
    const t = this.fieldsIndex.get(e);
    return t ? t.domain : null;
  }
  _fetchFirstLayerId(e) {
    return rn(this.url, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e }).then((t) => {
      const n = t.data;
      if (n)
        return Array.isArray(n.layers) && n.layers.length > 0 ? n.layers[0].id : Array.isArray(n.tables) && n.tables.length > 0 ? n.tables[0].id : void 0;
    });
  }
  async _initLayerProperties(e) {
    return this._set("source", e), e.sourceJSON && (this.sourceJSON = e.sourceJSON, this.read(e.sourceJSON, { origin: "service", url: this.parsedUrl })), this._verifySource(), this._verifyFields(), wP(this.renderer, this.fieldsIndex), P6(this.timeInfo, this.fieldsIndex), lfe(this, { origin: "service" });
  }
  async hasDataChanged() {
    var e;
    if ((e = this.source) != null && e.refresh)
      try {
        var t;
        const { dataChanged: n, updates: r } = await ((t = this.source) == null ? void 0 : t.refresh());
        if (O(r) && (this.sourceJSON = { ...this.sourceJSON, ...r }, this.read(r, { origin: "service", url: this.parsedUrl })), n)
          return !0;
      } catch {
      }
    if (this.definitionExpression)
      try {
        return (await Wde(this.definitionExpression, this.fieldsIndex)).hasDateFunctions;
      } catch {
      }
    return !1;
  }
  _verifyFields() {
    const e = this.parsedUrl && this.parsedUrl.path || "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e + ")"), this.isTable || this._hasMemorySource() || e.search(/\/FeatureServer\//i) !== -1 || this.fields && this.fields.some(function(t) {
      return t.type === "geometry";
    }) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e + ")");
  }
  _fixTemplates(e, t) {
    e && e.forEach((n) => {
      const r = n.prototype && n.prototype.attributes;
      r && t && delete r[t];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url)
        throw new D("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url)
      throw new D("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e) {
    e.forEach((t) => {
      t.layer = this, t.sourceLayer = this;
    }), this._handles.add([e.on("after-add", (t) => {
      t.item.layer = this, t.item.sourceLayer = this;
    }), e.on("after-remove", (t) => {
      t.item.layer = null, t.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e) {
    e.forEach((t) => {
      t.layer = null, t.sourceLayer = null;
    }), this._handles.remove("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
  _readAttachmentCapabilities(e) {
    const t = { supportsName: !1, supportsSize: !1, supportsContentType: !1, supportsKeywords: !1, supportsExifInfo: !1 };
    return e && Array.isArray(e) && e.forEach((n) => {
      const r = Sfe[n.name];
      r && (t[r] = !!n.isEnabled);
    }), t;
  }
  _readDataCapabilities(e) {
    return { isVersioned: He(e, "isDataVersioned", !1), supportsAttachment: He(e, "hasAttachments", !1), supportsM: He(e, "hasM", !1), supportsZ: He(e, "hasZ", !1) };
  }
  _readMetadataCapabilities(e) {
    return { supportsAdvancedFieldProperties: He(e, "supportsFieldDescriptionProperty", !1) };
  }
  _readOperationsCapabilities(e, t) {
    const n = e ? e.toLowerCase().split(",").map((l) => l.trim()) : [], r = n.includes("editing") && !t.datesInUnknownTimezone;
    let i = r && n.includes("create"), s = r && n.includes("delete"), o = r && n.includes("update");
    const a = n.includes("changetracking");
    return r && !(i || s || o) && (i = s = o = !0), { supportsCalculate: He(t, "supportsCalculate", !1), supportsTruncate: He(t, "supportsTruncate", !1), supportsValidateSql: He(t, "supportsValidateSql", !1), supportsAdd: i, supportsDelete: s, supportsEditing: r, supportsChangeTracking: a, supportsQuery: n.includes("query"), supportsQueryAttachments: He(t.advancedQueryCapabilities, "supportsQueryAttachments", !1), supportsResizeAttachments: He(t, "supportsAttachmentsResizing", !1), supportsSync: n.includes("sync"), supportsUpdate: o, supportsExceedsLimitStatistics: He(t, "supportsExceedsLimitStatistics", !1) };
  }
  _readQueryCapabilities(e) {
    var t;
    const n = e.advancedQueryCapabilities, r = e.ownershipBasedAccessControlForFeatures, i = e.archivingInfo, s = (t = this.url) == null ? void 0 : t.includes("MapServer"), o = !K("mapserver-pbf-enabled") && s && this.version < 10.81, a = B7(this.url), l = (e.supportedQueryFormats || "").split(",").reduce((c, p) => {
      const f = p.toLowerCase().trim();
      return f && c.add(f), c;
    }, /* @__PURE__ */ new Set());
    return { supportsStatistics: He(n, "supportsStatistics", e.supportsStatistics), supportsPercentileStatistics: He(n, "supportsPercentileStatistics", !1), supportsSpatialAggregationStatistics: He(n, "supportsSpatialAggregationStatistics", !1), supportedSpatialAggregationStatistics: xfe(n), supportsCentroid: He(n, "supportsReturningGeometryCentroid", !1), supportsDistance: He(n, "supportsQueryWithDistance", !1), supportsDistinct: He(n, "supportsDistinct", e.supportsAdvancedQueries), supportsExtent: He(n, "supportsReturningQueryExtent", !1), supportsGeometryProperties: He(n, "supportsReturningGeometryProperties", !1), supportsHavingClause: He(n, "supportsHavingClause", !1), supportsOrderBy: He(n, "supportsOrderBy", e.supportsAdvancedQueries), supportsPagination: He(n, "supportsPagination", !1), supportsQuantization: He(e, "supportsCoordinatesQuantization", !1), supportsQuantizationEditMode: He(e, "supportsQuantizationEditMode", !1), supportsQueryGeometry: He(e, "supportsReturningQueryGeometry", !1), supportsResultType: He(n, "supportsQueryWithResultType", !1), supportsMaxRecordCountFactor: He(n, "supportsMaxRecordCountFactor", !1), supportsSqlExpression: He(n, "supportsSqlExpression", !1), supportsStandardizedQueriesOnly: He(e, "useStandardizedQueries", !1), supportsTopFeaturesQuery: He(n, "supportsTopFeaturesQuery", !1), supportsQueryByOthers: He(r, "allowOthersToQuery", !0), supportsHistoricMoment: He(i, "supportsQueryWithHistoricMoment", !1), supportsFormatPBF: !o && l.has("pbf"), supportsDisjointSpatialRelationship: He(n, "supportsDisjointSpatialRel", !1), supportsCacheHint: He(n, "supportsQueryWithCacheHint", !1), supportsDefaultSpatialReference: He(n, "supportsDefaultSR", !1), supportsCompactGeometry: a, maxRecordCountFactor: zv(e, "maxRecordCountFactor", void 0), maxRecordCount: zv(e, "maxRecordCount", void 0), standardMaxRecordCount: zv(e, "standardMaxRecordCount", void 0), tileMaxRecordCount: zv(e, "tileMaxRecordCount", void 0) };
  }
  _readQueryRelatedCapabilities(e) {
    const t = e.advancedQueryCapabilities, n = He(t, "supportsAdvancedQueryRelated", !1);
    return { supportsPagination: He(t, "supportsQueryRelatedPagination", !1), supportsCount: n, supportsOrderBy: n };
  }
  _readEditingCapabilities(e) {
    const t = e.ownershipBasedAccessControlForFeatures;
    return { supportsGeometryUpdate: He(e, "allowGeometryUpdates", !0), supportsGlobalId: He(e, "supportsApplyEditsWithGlobalIds", !1), supportsReturnServiceEditsInSourceSpatialReference: He(e, "supportsReturnServiceEditsInSourceSR", !1), supportsRollbackOnFailure: He(e, "supportsRollbackOnFailureParameter", !1), supportsUpdateWithoutM: He(e, "allowUpdateWithoutMValues", !1), supportsUploadWithItemId: He(e, "supportsAttachmentsByUploadId", !1), supportsDeleteByAnonymous: He(t, "allowAnonymousToDelete", !0), supportsDeleteByOthers: He(t, "allowOthersToDelete", !0), supportsUpdateByAnonymous: He(t, "allowAnonymousToUpdate", !0), supportsUpdateByOthers: He(t, "allowOthersToUpdate", !0) };
  }
};
u([d({ readOnly: !0, json: { read: !1 } })], ue.prototype, "capabilities", void 0), u([be("service", "capabilities", ["advancedQueryCapabilities", "allowGeometryUpdates", "allowUpdateWithoutMValues", "archivingInfo", "capabilities", "datesInUnknownTimezone", "hasAttachments", "hasM", "hasZ", "maxRecordCount", "maxRecordCountFactor", "ownershipBasedAccessControlForFeatures", "standardMaxRecordCount", "supportedQueryFormats", "supportsAdvancedQueries", "supportsApplyEditsWithGlobalIds", "supportsAttachmentsByUploadId", "supportsAttachmentsResizing", "supportsCalculate", "supportsCoordinatesQuantization", "supportsExceedsLimitStatistics", "supportsFieldDescriptionProperty", "supportsQuantizationEditMode", "supportsRollbackOnFailureParameter", "supportsStatistics", "supportsTruncate", "supportsValidateSql", "tileMaxRecordCount", "useStandardizedQueries"])], ue.prototype, "readCapabilities", null), u([d({ json: { origins: { "portal-item": { write: !0 }, "web-map": { write: !0 } } } })], ue.prototype, "charts", void 0), u([d({ readOnly: !0 })], ue.prototype, "createQueryVersion", null), u([d({ type: String, json: { read: { source: "layerDefinition.copyrightText" }, origins: { service: { read: { source: "copyrightText" } } } } })], ue.prototype, "copyright", void 0), u([d({ type: Boolean })], ue.prototype, "datesInUnknownTimezone", void 0), u([d({ type: String, json: { read: { source: "layerDefinition.displayField" }, origins: { service: { read: { source: "displayField" } } } } })], ue.prototype, "displayField", void 0), u([d({ type: String, json: { origins: { service: { read: !1, write: !1 } }, name: "layerDefinition.definitionExpression", write: { enabled: !0, allowNull: !0 } } })], ue.prototype, "definitionExpression", void 0), u([d({ types: Ud, readOnly: !0 })], ue.prototype, "defaultSymbol", void 0), u([d({ type: Hi })], ue.prototype, "dynamicDataSource", void 0), u([d({ readOnly: !0 })], ue.prototype, "editFieldsInfo", void 0), u([d({ type: Boolean })], ue.prototype, "editingEnabled", null), u([be(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], ue.prototype, "readEditingEnabled", null), u([be("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], ue.prototype, "readEditingEnabledFromWebMap", null), u([xe(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], ue.prototype, "writeEditingEnabled", null), u([xe("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], ue.prototype, "writeEditingEnabledToWebMap", null), u([d({ readOnly: !0 })], ue.prototype, "editingInfo", void 0), u([be("editingInfo")], ue.prototype, "readEditingInfo", null), u([d(uhe)], ue.prototype, "elevationInfo", void 0), u([d(Yhe)], ue.prototype, "featureReduction", void 0), u([d({ ...Mx.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: Cx } } } } })], ue.prototype, "fields", void 0), u([d(Mx.fieldsIndex)], ue.prototype, "fieldsIndex", void 0), u([d({ type: sfe, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], ue.prototype, "floorInfo", void 0), u([d({ type: ipe, json: { name: "formInfo", write: !0, origins: { "web-scene": { read: !1, write: !1 } } } })], ue.prototype, "formTemplate", void 0), u([d({ type: Mt, json: { origins: { service: { read: { source: "extent" } } }, read: { source: "layerDefinition.extent" } } })], ue.prototype, "fullExtent", void 0), u([d()], ue.prototype, "gdbVersion", void 0), u([d({ readOnly: !0, type: nfe, json: { read: { source: "geometryProperties" } } })], ue.prototype, "geometryFieldsInfo", void 0), u([d({ type: ["point", "polygon", "polyline", "multipoint", "multipatch", "mesh"], json: { origins: { service: { read: Ix.read }, "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: Cx, writer(e, t, n) {
  const r = e ? Ix.toJSON(e) : null;
  r && ss(n, r, t);
} } } }, read: { source: "layerDefinition.geometryType", reader: Ix.read } } })], ue.prototype, "geometryType", void 0), u([d({ type: Boolean, json: { origins: { service: { read: !0 } }, read: { source: "layerDefinition.hasM" } } })], ue.prototype, "hasM", void 0), u([d({ type: Boolean, json: { origins: { service: { read: !0 } }, read: { source: "layerDefinition.hasZ" } } })], ue.prototype, "hasZ", void 0), u([d({ readOnly: !0, type: OS })], ue.prototype, "heightModelInfo", void 0), u([d({ type: Date })], ue.prototype, "historicMoment", void 0), u([d(dhe)], ue.prototype, "id", void 0), u([d({ readOnly: !0, json: { origins: { service: { read: !0 } }, read: !1 } })], ue.prototype, "infoFor3D", void 0), u([d({ readOnly: !0, json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], ue.prototype, "isTable", void 0), u([be("service", "isTable", ["type", "geometryType"]), be("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], ue.prototype, "readIsTable", null), u([xe("web-map", "isTable")], ue.prototype, "writeIsTable", null), u([d(oB)], ue.prototype, "labelsVisible", void 0), u([d({ type: [Zk], json: { origins: { service: { read: { source: "drawingInfo.labelingInfo", reader: xF }, write: { target: "drawingInfo.labelingInfo", enabled: !1 } } }, read: { source: "layerDefinition.drawingInfo.labelingInfo", reader: xF }, write: { target: "layerDefinition.drawingInfo.labelingInfo" } } })], ue.prototype, "labelingInfo", void 0), u([d(che)], ue.prototype, "opacity", void 0), u([d({ type: Number, json: { origins: { service: { read: { source: "id" } } }, read: !1 } })], ue.prototype, "layerId", void 0), u([d(lhe)], ue.prototype, "legendEnabled", void 0), u([d({ type: ["show", "hide"] })], ue.prototype, "listMode", void 0), u([d(phe)], ue.prototype, "minScale", void 0), u([be("service", "minScale", ["minScale", "effectiveMinScale"])], ue.prototype, "readMinScale", null), u([d(hhe)], ue.prototype, "maxScale", void 0), u([be("service", "maxScale", ["maxScale", "effectiveMaxScale"])], ue.prototype, "readMaxScale", null), u([d({ type: String })], ue.prototype, "globalIdField", void 0), u([be("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"]), be("service", "globalIdField", ["globalIdField", "fields"])], ue.prototype, "readGlobalIdFieldFromService", null), u([d({ type: String, json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: Cx } } } } })], ue.prototype, "objectIdField", void 0), u([be("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"]), be("service", "objectIdField", ["objectIdField", "fields"])], ue.prototype, "readObjectIdFieldFromService", null), u([d({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], ue.prototype, "operationalLayerType", void 0), u([d(Mx.outFields)], ue.prototype, "outFields", void 0), u([d({ readOnly: !0 })], ue.prototype, "parsedUrl", null), u([d({ type: String, json: { origins: { "web-scene": { read: !0, write: !0 } }, read: !1 } })], ue.prototype, "path", void 0), u([d(sB)], ue.prototype, "popupEnabled", void 0), u([d({ type: lS, json: { name: "popupInfo", write: !0 } })], ue.prototype, "popupTemplate", void 0), u([d({ readOnly: !0 })], ue.prototype, "defaultPopupTemplate", null), u([d({ type: [ofe], readOnly: !0 })], ue.prototype, "relationships", void 0), u([d({ types: C7, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: !1 } }, "web-scene": { types: Bde, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e, t, n) => ({ ignoreOrigin: n == null ? void 0 : n.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e, t, n) => ({ ignoreOrigin: n == null ? void 0 : n.writeLayerSchema }) } } })], ue.prototype, "renderer", null), u([be("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), be("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], ue.prototype, "readRenderer", null), u([d()], ue.prototype, "sourceJSON", void 0), u([d({ type: Boolean })], ue.prototype, "returnM", void 0), u([d({ type: Boolean })], ue.prototype, "returnZ", void 0), u([d(ohe)], ue.prototype, "screenSizePerspectiveEnabled", void 0), u([d({ clonable: !1 })], ue.prototype, "source", null), u([mt("source")], ue.prototype, "castSource", null), u([be("portal-item", "source", ["featureSet"]), be("web-map", "source", ["featureSet"])], ue.prototype, "readSource", null), u([d({ readOnly: !0 })], ue.prototype, "serviceDefinitionExpression", void 0), u([be("service", "serviceDefinitionExpression", ["definitionQuery", "definitionExpression"])], ue.prototype, "readServiceDefinitionExpression", null), u([d({ type: Qe, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: { source: "layerDefinition.extent.spatialReference" } } })], ue.prototype, "spatialReference", void 0), u([d({ type: Number })], ue.prototype, "subtypeCode", void 0), u([d({ type: [Kk] })], ue.prototype, "templates", void 0), u([be("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], ue.prototype, "readTemplates", null), u([d({ type: dB })], ue.prototype, "timeInfo", void 0), u([d()], ue.prototype, "title", void 0), u([be("service", "title", ["name"]), be("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], ue.prototype, "readTitle", null), u([be("web-map", "title", ["layerDefinition.name", "title"])], ue.prototype, "readTitleFromWebMap", null), u([d({ type: String })], ue.prototype, "sublayerTitleMode", void 0), u([d({ type: String, json: { read: { source: "timeInfo.trackIdField" } } })], ue.prototype, "trackIdField", void 0), u([d({ json: { read: !1 } })], ue.prototype, "type", void 0), u([d({ type: String })], ue.prototype, "typeIdField", void 0), u([be("service", "typeIdField"), be("typeIdField", ["layerDefinition.typeIdField"])], ue.prototype, "readTypeIdField", null), u([d({ type: [vB] })], ue.prototype, "types", void 0), u([be("service", "types", ["types"]), be("types", ["layerDefinition.types"])], ue.prototype, "readTypes", null), u([d({ readOnly: !0, json: { write: !1 } })], ue.prototype, "serverGens", void 0), u([d({ type: Ne.ofType(hl), readOnly: !0 })], ue.prototype, "indexes", void 0), u([d(ahe)], ue.prototype, "url", null), u([xe("url")], ue.prototype, "writeUrl", null), u([d({ readOnly: !0 })], ue.prototype, "userIsAdmin", void 0), u([d({ json: { origins: { service: { read: !0 } }, read: !1 } })], ue.prototype, "version", void 0), u([be("service", "version", ["currentVersion", "capabilities", "drawingInfo", "hasAttachments", "htmlPopupType", "relationships", "timeInfo", "typeIdField", "types"])], ue.prototype, "readVersion", null), u([d({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], ue.prototype, "visible", void 0), u([be("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], ue.prototype, "readVisible", null), ue = u([T("geoscene.layers.FeatureLayer")], ue);
const Ox = zf({ types: Ij }), Yk = ue, YFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yk
}, Symbol.toStringTag, { value: "Module" })), $fe = ["$datastore", "$map", "$layer", "$aggregatedfeatures"], Tfe = "geoscene.widgets.Feature.support.arcadeFeatureUtils", Efe = we.getLogger(Tfe);
function Ife(e) {
  return typeof e == "string" ? P0(ak(e)) : Array.isArray(e) ? Mfe(e) : (e == null ? void 0 : e.declaredClass) === "geoscene.arcade.Dictionary" ? Cfe(e) : e;
}
function Mfe(e) {
  return `<ul class="geoscene-widget__list">${e.map((t) => `<li>${typeof t == "string" ? P0(ak(t)) : t}</li>`).join("")}</ul>`;
}
function Cfe(e) {
  return `<table class="geoscene-widget__table">${e.keys().map((t) => {
    const n = e.field(t);
    return `<tr><th>${t}</th><td>${typeof n == "string" ? P0(ak(n)) : n}</td></tr>`;
  }).join("")}</table>`;
}
function Ofe({ aggregatedFeatures: e, arcadeUtils: t, featureSetVars: n, context: r, viewInfo: i, map: s, graphic: o, interceptor: a }) {
  n.forEach((l) => {
    const c = l.toLowerCase(), p = { map: s, spatialReference: i.sr, interceptor: a };
    if (c === "$map" && (r.vars[c] = t.convertMapToFeatureSetCollection(p)), c === "$layer" && (r.vars[c] = t.convertFeatureLayerToFeatureSet({ layer: o.sourceLayer, spatialReference: i.sr, interceptor: a })), c === "$datastore" && (r.vars[c] = t.convertServiceUrlToWorkspace({ url: o.sourceLayer.url, spatialReference: i.sr, interceptor: a })), c === "$aggregatedfeatures") {
      const f = o.layer, { fields: m, objectIdField: y, geometryType: g, spatialReference: v, displayField: w } = f, b = new Yk({ fields: m, objectIdField: y, geometryType: g, spatialReference: v, displayField: w, ...f.type === "feature" ? { templates: f.templates, typeIdField: f.typeIdField, types: f.types } : null, source: e });
      r.vars[c] = t.convertFeatureLayerToFeatureSet({ layer: b, spatialReference: i.sr, interceptor: a });
    }
  });
}
function wB() {
  return import("./arcadeUtils-w0rSqD6f.js").then((e) => e.q);
}
async function kfe({ graphic: e, view: t }) {
  const { isAggregate: n, layer: r } = e;
  if (!n || !r || (t == null ? void 0 : t.type) !== "2d")
    return [];
  const i = await t.whenLayerView(r);
  if (!i.createQuery || !i.queryFeatures)
    return [];
  const s = i.createQuery();
  s.aggregateIds = [e.getObjectId()];
  const { features: o } = await i.queryFeatures(s);
  return o;
}
async function _B({ expressionInfo: e, arcadeUtils: t, interceptor: n, spatialReference: r, map: i, graphic: s, view: o }) {
  if (!e || !e.expression)
    return null;
  const a = t.createSyntaxTree(e.expression), l = $fe.filter((y) => t.hasVariable(a, y)), [c] = await KD([kfe({ graphic: s, view: o }), t.loadScriptDependencies(a, !0, l)]), p = t.getViewInfo({ spatialReference: r }), f = t.createExecContext(s, p);
  f.interceptor = n, f.useAsync = !0, Ofe({ aggregatedFeatures: c, arcadeUtils: t, featureSetVars: l, context: f, viewInfo: p, map: i, graphic: s, interceptor: n });
  const m = t.createFunction(a, f);
  return t.executeAsyncFunction(m, f).catch((y) => Efe.error("arcade-execution-error", { error: y, graphic: s, expressionInfo: e }));
}
async function Afe({ expressionInfos: e, spatialReference: t, graphic: n, interceptor: r, map: i, view: s }) {
  if (!e || !e.length)
    return {};
  const o = await wB(), a = {};
  for (const p of e)
    a[`expression/${p.name}`] = _B({ expressionInfo: p, arcadeUtils: o, interceptor: r, spatialReference: t, map: i, graphic: n, view: s });
  const l = await Ii(a), c = {};
  for (const p in l)
    c[p] = Ife(l[p].value);
  return c;
}
const Pfe = 1;
let Vi = class extends $p(ke) {
  constructor(t) {
    super(t), this._abortController = null, this.expressionInfo = null, this.graphic = null, this.contentElement = null, this.contentElementViewModel = null, this.interceptor = null, this.view = null, this._cancelQuery = () => {
      const { _abortController: n } = this;
      n && n.abort(), this._abortController = null;
    }, this._createVM = () => {
      var n, r;
      const i = (n = this.contentElement) == null ? void 0 : n.type;
      (r = this.contentElementViewModel) == null || r.destroy();
      const s = i === "fields" ? new bS() : i === "media" ? new Rd() : i === "text" ? new W1() : null;
      this._set("contentElementViewModel", s);
    }, this._compile = async () => {
      this._cancelQuery();
      const n = new AbortController();
      this._abortController = n, await this._compileExpression(), this._abortController === n && (this._abortController = null);
    }, this._compileThrottled = ek(this._compile, Pfe, this), this._compileExpression = async () => {
      const { expressionInfo: n, graphic: r, interceptor: i, spatialReference: s, map: o, view: a, _abortController: l } = this;
      if (!(n && r && s && o))
        return void this._set("contentElement", null);
      const c = await wB();
      if (l !== this._abortController)
        return;
      const p = await _B({ arcadeUtils: c, expressionInfo: n, graphic: r, interceptor: i, map: o, spatialReference: s, view: a });
      if (!p || p.declaredClass !== "geoscene.arcade.Dictionary")
        return void this._set("contentElement", null);
      const f = await Ak(p, l.signal), m = f == null ? void 0 : f.type, y = m === "media" ? Fg.fromJSON(f) : m === "text" ? vf.fromJSON(f) : m === "fields" ? gf.fromJSON(f) : null;
      this._set("contentElement", y);
    }, this.handles.add([gn(this, ["expressionInfo", "graphic", "map", "spatialReference", "view"], this._compileThrottled), gn(this, "contentElement", this._createVM)]);
  }
  destroy() {
    var t;
    this._cancelQuery(), (t = this.contentElementViewModel) == null || t.destroy(), this._set("contentElementViewModel", null), this._set("contentElement", null);
  }
  get spatialReference() {
    var t;
    return ((t = this.view) == null ? void 0 : t.spatialReference) || null;
  }
  set spatialReference(t) {
    t !== void 0 ? this._override("spatialReference", t) : this._clearOverride("spatialReference");
  }
  get state() {
    const { _abortController: t, contentElement: n, contentElementViewModel: r } = this;
    return t ? "loading" : n || r ? "ready" : "disabled";
  }
  get map() {
    var t;
    return ((t = this.view) == null ? void 0 : t.map) || null;
  }
  set map(t) {
    t !== void 0 ? this._override("map", t) : this._clearOverride("map");
  }
};
u([d()], Vi.prototype, "_abortController", void 0), u([d({ type: V6 })], Vi.prototype, "expressionInfo", void 0), u([d({ type: Jt })], Vi.prototype, "graphic", void 0), u([d({ readOnly: !0 })], Vi.prototype, "contentElement", void 0), u([d({ readOnly: !0 })], Vi.prototype, "contentElementViewModel", void 0), u([d()], Vi.prototype, "interceptor", void 0), u([d()], Vi.prototype, "spatialReference", null), u([d({ readOnly: !0 })], Vi.prototype, "state", null), u([d()], Vi.prototype, "map", null), u([d()], Vi.prototype, "view", void 0), Vi = u([T("geoscene.widgets.Feature.FeatureExpression.FeatureExpressionViewModel")], Vi);
const Qk = Vi, Bv = { iconLoading: "geoscene-icon-loading-indicator geoscene-rotating", base: "geoscene-feature-expression", loadingSpinnerContainer: "geoscene-feature__loading-container", spinner: "geoscene-feature__loading-spinner" };
let Tw = class extends ti {
  constructor(t, n) {
    super(t, n), this.viewModel = new Qk();
  }
  initialize() {
    gn(this, "viewModel.contentElementViewModel", () => this._setupExpressionWidget());
  }
  destroy() {
    this._destroyContentWidget();
  }
  renderLoading() {
    return B("div", { key: "loading-container", class: Bv.loadingSpinnerContainer }, B("span", { class: this.classes(Bv.iconLoading, Bv.spinner) }));
  }
  render() {
    var t;
    const { state: n } = this.viewModel;
    return B("div", { class: Bv.base }, n === "loading" ? this.renderLoading() : n === "disabled" ? null : (t = this._contentWidget) == null ? void 0 : t.render());
  }
  _destroyContentWidget() {
    const { _contentWidget: t } = this;
    t && (t.viewModel = null, t.destroy()), this._contentWidget = null;
  }
  _setupExpressionWidget() {
    const { contentElementViewModel: t, contentElement: n } = this.viewModel, r = n == null ? void 0 : n.type;
    this._destroyContentWidget();
    const i = t ? r === "fields" ? new dV({ viewModel: t }) : r === "media" ? new QV({ viewModel: t }) : r === "text" ? new ew({ viewModel: t }) : null : null;
    this._contentWidget = i, this.scheduleRender();
  }
};
u([d({ type: Qk })], Tw.prototype, "viewModel", void 0), Tw = u([T("geoscene.widgets.Feature.FeatureExpression")], Tw);
const Rfe = Tw;
let Lfe = class {
  constructor(t, n) {
    this.preLayerQueryCallback = t, this.preRequestCallback = n, this.preLayerQueryCallback || (this.preLayerQueryCallback = (r) => {
    }), this.preRequestCallback || (this.preLayerQueryCallback = (r) => {
    });
  }
};
var Ew;
const Ffe = 1, CF = "content-view-models", SB = "geoscene.widgets.FeatureViewModel", Nfe = we.getLogger(SB), OF = { attachmentsContent: !0, chartAnimation: !0, customContent: !0, expressionContent: !0, fieldsContent: !0, mediaContent: !0, textContent: !0 };
let sn = Ew = class extends ke {
  constructor(e) {
    super(e), this._handles = new ei(), this._error = null, this._featureAbortController = null, this.graphicChangedThrottled = ek(this._graphicChanged, Ffe, this), this._expressionAttributes = null, this._graphicExpressionAttributes = null, this.abilities = { ...OF }, this.content = null, this.contentViewModels = [], this.defaultPopupTemplateEnabled = !1, this.formattedAttributes = null, this.lastEditInfo = null, this.relatedInfos = /* @__PURE__ */ new Map(), this.title = "", this.view = null, this._isAllowedContentType = (t) => {
      const { abilities: n } = this;
      return t.type === "attachments" && n.attachmentsContent || t.type === "custom" && n.customContent || t.type === "fields" && n.fieldsContent || t.type === "media" && n.mediaContent || t.type === "text" && n.textContent || t.type === "expression" && n.expressionContent;
    }, this._handles.add(gn(this, ["graphic", "_effectivePopupTemplate", "abilities"], () => this.graphicChangedThrottled()));
  }
  destroy() {
    this._clear(), this._cancelFeatureQuery(), this._error = null, this._handles.destroy(), this._handles = null, this.graphic = null, this._destroyContentViewModels(), this.relatedInfos.clear();
  }
  get _effectivePopupTemplate() {
    return O(this.graphic) ? this.graphic.getEffectivePopupTemplate(this.defaultPopupTemplateEnabled) : null;
  }
  get _fieldInfoMap() {
    return Cse(CR(this._effectivePopupTemplate), this._sourceLayer);
  }
  get _sourceLayer() {
    return eV(this.graphic);
  }
  castAbilities(e) {
    return { ...OF, ...e };
  }
  get state() {
    return this.graphic ? this._error ? "error" : this.waitingForContent ? "loading" : "ready" : "disabled";
  }
  set graphic(e) {
    this._set("graphic", e ? e.clone() : null);
  }
  get spatialReference() {
    return this.get("view.spatialReference") || null;
  }
  set spatialReference(e) {
    e !== void 0 ? this._override("spatialReference", e) : this._clearOverride("spatialReference");
  }
  get map() {
    return this.get("view.map") || null;
  }
  set map(e) {
    e !== void 0 ? this._override("map", e) : this._clearOverride("map");
  }
  get waitingForContent() {
    return !!this._featureAbortController;
  }
  setActiveMedia(e, t) {
    const n = this.contentViewModels[e];
    n instanceof Rd && n.setActiveMedia(t);
  }
  nextMedia(e) {
    const t = this.contentViewModels[e];
    t instanceof Rd && t.next();
  }
  previousMedia(e) {
    const t = this.contentViewModels[e];
    t instanceof Rd && t.previous();
  }
  _clear() {
    this._set("title", ""), this._set("content", null), this._set("formattedAttributes", null);
  }
  async _graphicChanged() {
    this._cancelFeatureQuery(), this._error = null, this._clear();
    const { graphic: e } = this;
    if (!e)
      return;
    const t = new AbortController();
    this._featureAbortController = t;
    try {
      await this._queryFeature({ signal: t.signal });
    } catch (n) {
      Ws(n) || (this._error = n, Nfe.error("error", "The popupTemplate could not be displayed for this feature.", { error: n, graphic: e, popupTemplate: this._effectivePopupTemplate }));
    }
    this._featureAbortController === t && (this._featureAbortController = null);
  }
  _cancelFeatureQuery() {
    const { _featureAbortController: e } = this;
    e && e.abort(), this._featureAbortController = null;
  }
  _compileContentElement(e, t) {
    return e.type === "attachments" ? this._compileAttachments(e, t) : e.type === "custom" ? this._compileCustom(e, t) : e.type === "fields" ? this._compileFields(e, t) : e.type === "media" ? this._compileMedia(e, t) : e.type === "text" ? this._compileText(e, t) : e.type === "expression" ? this._compileExpression(e, t) : void 0;
  }
  _compileContent(e) {
    if (this._destroyContentViewModels(), this.graphic)
      return Array.isArray(e) ? e.filter(this._isAllowedContentType).map((t, n) => this._compileContentElement(t, n)) : typeof e == "string" ? this._compileText(new vf({ text: e }), 0).text : e;
  }
  _destroyContentViewModels() {
    var e;
    (e = this._handles) == null || e.remove(CF), this.contentViewModels.forEach((t) => t && !t.destroyed && t.destroy()), this._set("contentViewModels", []);
  }
  _setExpressionContentVM(e, t) {
    const { formattedAttributes: n } = this, { contentElement: r, contentElementViewModel: i } = e, s = r == null ? void 0 : r.type;
    i && s && (s === "fields" && (this._createFieldsFormattedAttributes({ contentElement: r, contentElementIndex: t, formattedAttributes: n }), i.set(this._createFieldsVMParams(r, t))), s === "media" && (this._createMediaFormattedAttributes({ contentElement: r, contentElementIndex: t, formattedAttributes: n }), i.set(this._createMediaVMParams(r, t))), s === "text" && i.set(this._createTextVMParams(r)));
  }
  _compileExpression(e, t) {
    const { expressionInfo: n } = e, { graphic: r, map: i, spatialReference: s, view: o } = this, a = new Qk({ expressionInfo: n, graphic: r, interceptor: Ew.interceptor, map: i, spatialReference: s, view: o });
    return this.contentViewModels[t] = a, this._handles.add(gn(a, "contentElementViewModel", () => this._setExpressionContentVM(a, t)), CF), e;
  }
  _compileAttachments(e, t) {
    const { graphic: n } = this, { description: r, title: i } = e;
    return this.contentViewModels[t] = new uk({ graphic: n, ...this._compileTitleAndDesc({ title: i, description: r }) }), e;
  }
  _compileCustom(e, t) {
    const { graphic: n } = this, { creator: r, destroyer: i } = e;
    return this.contentViewModels[t] = new W1({ graphic: n, creator: r, destroyer: i }), e;
  }
  _compileTitleAndDesc({ title: e, description: t }) {
    const { _fieldInfoMap: n, _sourceLayer: r, graphic: i, formattedAttributes: s, _expressionAttributes: o } = this, { attributes: a } = i, l = s.global;
    return { title: Ad({ attributes: a, fieldInfoMap: n, globalAttributes: l, expressionAttributes: o, layer: r, text: e }), description: Ad({ attributes: a, fieldInfoMap: n, globalAttributes: l, expressionAttributes: o, layer: r, text: t }) };
  }
  _createFieldsVMParams(e, t) {
    const { _effectivePopupTemplate: n, formattedAttributes: r } = this, i = { ...r.global, ...r.content[t] }, s = (e == null ? void 0 : e.fieldInfos) || (n == null ? void 0 : n.fieldInfos), o = s == null ? void 0 : s.filter(({ fieldName: p }) => nV(p) || _l(p) || i.hasOwnProperty(p)), a = n == null ? void 0 : n.expressionInfos, { description: l, title: c } = e;
    return { attributes: i, expressionInfos: a, fieldInfos: o, ...this._compileTitleAndDesc({ title: c, description: l }) };
  }
  _compileFields(e, t) {
    const n = e.clone(), r = new bS(this._createFieldsVMParams(e, t));
    return this.contentViewModels[t] = r, n.fieldInfos = r.formattedFieldInfos.slice(0), n;
  }
  _createMediaVMParams(e, t) {
    const { abilities: n, graphic: r, _fieldInfoMap: i, formattedAttributes: s, _effectivePopupTemplate: o, relatedInfos: a, _sourceLayer: l, _expressionAttributes: c } = this, { attributes: p } = r, { description: f, mediaInfos: m, title: y } = e;
    return { abilities: { chartAnimation: n.chartAnimation }, activeMediaInfoIndex: e.activeMediaInfoIndex || 0, attributes: p, layer: l, fieldInfoMap: i, formattedAttributes: { ...s.global, ...s.content[t] }, expressionAttributes: c, mediaInfos: m, popupTemplate: o, relatedInfos: a, ...this._compileTitleAndDesc({ title: y, description: f }) };
  }
  _compileMedia(e, t) {
    const n = e.clone(), r = new Rd(this._createMediaVMParams(e, t));
    return n.mediaInfos = r.formattedMediaInfos.slice(0), this.contentViewModels[t] = r, n;
  }
  _createTextVMParams(e) {
    const { graphic: t, _fieldInfoMap: n, _sourceLayer: r, _expressionAttributes: i } = this;
    if (e && e.text) {
      const { attributes: s } = t, o = this.formattedAttributes.global;
      e.text = Ad({ attributes: s, fieldInfoMap: n, globalAttributes: o, expressionAttributes: i, layer: r, text: e.text });
    }
    return { graphic: t, creator: e.text };
  }
  _compileText(e, t) {
    const n = e.clone();
    return this.contentViewModels[t] = new W1(this._createTextVMParams(n)), n;
  }
  _compileLastEditInfo() {
    const { _effectivePopupTemplate: e, _sourceLayer: t, graphic: n } = this;
    if (!e)
      return;
    const { lastEditInfoEnabled: r } = e, i = t == null ? void 0 : t.editFieldsInfo;
    return r && i ? Mse(i, n.attributes) : void 0;
  }
  _compileTitle(e) {
    const { _fieldInfoMap: t, _sourceLayer: n, graphic: r, _expressionAttributes: i } = this, { attributes: s } = r, o = this.formattedAttributes.global;
    return Ad({ attributes: s, fieldInfoMap: t, globalAttributes: o, expressionAttributes: i, layer: n, text: e });
  }
  async _getTitle() {
    const { _effectivePopupTemplate: e, graphic: t } = this, n = e == null ? void 0 : e.title;
    return q1(n, { graphic: t });
  }
  async _getContent() {
    const { _effectivePopupTemplate: e, graphic: t } = this, n = e == null ? void 0 : e.content;
    return q1(n, { graphic: t });
  }
  async _queryFeature(e) {
    const { _featureAbortController: t, _sourceLayer: n, graphic: r, _effectivePopupTemplate: i, spatialReference: s, map: o, view: a } = this, { content: { value: l }, title: { value: c } } = await Ii({ content: this._getContent(), title: this._getTitle() });
    if (t !== this._featureAbortController || !r)
      return;
    await Pse({ graphic: r, popupTemplate: i, layer: n, spatialReference: s }, e);
    const { expressionAttributes: { value: p } } = await Ii({ checkForRelatedFeatures: this._checkForRelatedFeatures(e), expressionAttributes: Afe({ expressionInfos: i == null ? void 0 : i.expressionInfos, spatialReference: s, graphic: r, map: o, interceptor: Ew.interceptor, view: a }) });
    t === this._featureAbortController && r && (this._expressionAttributes = p, this._graphicExpressionAttributes = { ...r.attributes, ...p }, this._set("formattedAttributes", this._createFormattedAttributes(l)), this._set("title", this._compileTitle(c)), this._set("lastEditInfo", this._compileLastEditInfo() || null), this._set("content", this._compileContent(l) || null));
  }
  _createMediaFormattedAttributes({ contentElement: e, contentElementIndex: t, formattedAttributes: n }) {
    const { _effectivePopupTemplate: r, graphic: i, relatedInfos: s, _sourceLayer: o, _fieldInfoMap: a, _graphicExpressionAttributes: l } = this;
    n.content[t] = H2({ fieldInfos: r == null ? void 0 : r.fieldInfos, graphic: i, attributes: { ...l, ...e.attributes }, layer: o, fieldInfoMap: a, relatedInfos: s });
  }
  _createFieldsFormattedAttributes({ contentElement: e, contentElementIndex: t, formattedAttributes: n }) {
    if (e.fieldInfos) {
      const { graphic: r, relatedInfos: i, _sourceLayer: s, _fieldInfoMap: o, _graphicExpressionAttributes: a } = this;
      n.content[t] = H2({ fieldInfos: e.fieldInfos, graphic: r, attributes: { ...a, ...e.attributes }, layer: s, fieldInfoMap: o, relatedInfos: i });
    }
  }
  _createFormattedAttributes(e) {
    const { _effectivePopupTemplate: t, graphic: n, relatedInfos: r, _sourceLayer: i, _fieldInfoMap: s, _graphicExpressionAttributes: o } = this, a = t == null ? void 0 : t.fieldInfos, l = { global: H2({ fieldInfos: a, graphic: n, attributes: o, layer: i, fieldInfoMap: s, relatedInfos: r }), content: [] };
    return Array.isArray(e) && e.forEach((c, p) => {
      c.type === "fields" && this._createFieldsFormattedAttributes({ contentElement: c, contentElementIndex: p, formattedAttributes: l }), c.type === "media" && this._createMediaFormattedAttributes({ contentElement: c, contentElementIndex: p, formattedAttributes: l });
    }), l;
  }
  _checkForRelatedFeatures(e) {
    const { graphic: t, _effectivePopupTemplate: n } = this;
    return this._queryRelatedInfos(t, CR(n), e);
  }
  async _queryRelatedInfos(e, t, n) {
    const { relatedInfos: r, _sourceLayer: i } = this;
    r.clear();
    const s = O(i.associatedLayer) ? await i.associatedLayer.load(n) : i;
    if (!s)
      return;
    const o = t.filter((c) => c && _l(c.fieldName));
    if (!o || !o.length)
      return;
    t.forEach((c) => this._configureRelatedInfo(c, s));
    const a = await Uae({ relatedInfos: r, layer: s }, n);
    Object.keys(a).forEach((c) => {
      var p;
      const f = r.get(c.toString()), m = (p = a[c]) == null ? void 0 : p.value;
      f && m && (f.layerInfo = m.data);
    });
    const l = await qae({ graphic: e, relatedInfos: r, layer: s }, n);
    Object.keys(l).forEach((c) => {
      var p;
      Dae((p = l[c]) == null ? void 0 : p.value, r.get(c.toString()));
    });
  }
  _configureRelatedInfo(e, t) {
    const { relatedInfos: n } = this, r = Ty(e.fieldName);
    if (!r)
      return;
    const { layerId: i, fieldName: s } = r;
    if (!i)
      return;
    const o = n.get(i.toString()) || Nae(i, t);
    o && (Gae({ relatedInfo: o, fieldName: s, fieldInfo: e }), this.relatedInfos.set(i, o));
  }
};
sn.interceptor = new Lfe(Fse, Nse), u([d()], sn.prototype, "_error", void 0), u([d()], sn.prototype, "_featureAbortController", void 0), u([d({ readOnly: !0 })], sn.prototype, "_effectivePopupTemplate", null), u([d({ readOnly: !0 })], sn.prototype, "_fieldInfoMap", null), u([d({ readOnly: !0 })], sn.prototype, "_sourceLayer", null), u([d()], sn.prototype, "abilities", void 0), u([mt("abilities")], sn.prototype, "castAbilities", null), u([d({ readOnly: !0 })], sn.prototype, "content", void 0), u([d({ readOnly: !0 })], sn.prototype, "contentViewModels", void 0), u([d({ type: Boolean })], sn.prototype, "defaultPopupTemplateEnabled", void 0), u([d({ readOnly: !0 })], sn.prototype, "state", null), u([d({ readOnly: !0 })], sn.prototype, "formattedAttributes", void 0), u([d({ type: Jt, value: null })], sn.prototype, "graphic", null), u([d({ readOnly: !0 })], sn.prototype, "lastEditInfo", void 0), u([d({ readOnly: !0 })], sn.prototype, "relatedInfos", void 0), u([d()], sn.prototype, "spatialReference", null), u([d({ readOnly: !0 })], sn.prototype, "title", void 0), u([d()], sn.prototype, "map", null), u([d({ readOnly: !0 })], sn.prototype, "waitingForContent", null), u([d()], sn.prototype, "view", void 0), sn = Ew = u([T(SB)], sn);
const Xk = sn, xB = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.renderNodeContent = (n) => cV(n) && !n.destroyed ? B("div", { key: n }, n.render()) : n instanceof HTMLElement ? B("div", { key: n, bind: n, afterCreate: this._attachToNode }) : Qse(n) ? B("div", { key: n, bind: n.domNode, afterCreate: this._attachToNode }) : null;
    }
    _attachToNode(n) {
      const r = this;
      n.appendChild(r);
    }
  };
  return t = u([T("geoscene.widgets.Feature.ContentMixin")], t), t;
}, fr = { iconText: "geoscene-icon-font-fallback-text", iconLoading: "geoscene-icon-loading-indicator geoscene-rotating", esriTable: "geoscene-widget__table", geosceneWidget: "geoscene-widget", base: "geoscene-feature", container: "geoscene-feature__size-container", title: "geoscene-feature__title", main: "geoscene-feature__main-container", btn: "geoscene-feature__button", icon: "geoscene-feature__icon", content: "geoscene-feature__content", contentElement: "geoscene-feature__content-element", text: "geoscene-feature__text", lastEditedInfo: "geoscene-feature__last-edited-info", fields: "geoscene-feature__fields", fieldHeader: "geoscene-feature__field-header", fieldData: "geoscene-feature__field-data", fieldDataDate: "geoscene-feature__field-data--date", loadingSpinnerContainer: "geoscene-feature__loading-container", spinner: "geoscene-feature__loading-spinner" }, kF = { title: !0, content: !0, lastEditedInfo: !0 };
let gr = class extends xB(ti) {
  constructor(t, n) {
    super(t, n), this._contentWidgets = [], this.graphic = null, this.defaultPopupTemplateEnabled = !1, this.headingLevel = 2, this.label = void 0, this.messages = null, this.messagesCommon = null, this.messagesURIUtils = null, this.spatialReference = null, this.title = null, this.visibleElements = { ...kF }, this.map = null, this.view = null, this.viewModel = new Xk();
  }
  initialize() {
    this.own(gn(this, "viewModel.contentViewModels", () => this._setupContentWidgets()));
  }
  loadDependencies() {
    return import("./calcite-notice-Q4E0_1x7.js");
  }
  destroy() {
    this._destroyContentWidgets();
  }
  castVisibleElements(t) {
    return { ...kF, ...t };
  }
  render() {
    const { state: t } = this.viewModel, n = B("div", { class: fr.container, key: "container" }, this.renderTitle(), t === "error" ? this.renderError() : t === "loading" ? this.renderLoading() : this.renderContentContainer());
    return B("div", { class: this.classes(fr.base, fr.geosceneWidget) }, n);
  }
  setActiveMedia(t, n) {
    this.viewModel.setActiveMedia(t, n);
  }
  nextMedia(t) {
    this.viewModel.nextMedia(t);
  }
  previousMedia(t) {
    this.viewModel.previousMedia(t);
  }
  renderError() {
    const { messagesCommon: t, messages: n, visibleElements: r } = this;
    return B("calcite-notice", { active: !0, color: "red", icon: "exclamation-mark-circle", scale: "s" }, r.title ? B("div", { key: "error-title", slot: "title" }, t.errorMessage) : null, B("div", { key: "error-message", slot: "message" }, n.loadingError));
  }
  renderLoading() {
    return B("div", { key: "loading-container", class: fr.loadingSpinnerContainer }, B("span", { class: this.classes(fr.iconLoading, fr.spinner) }));
  }
  renderContentContainer() {
    const { visibleElements: t } = this;
    return t.content ? B("div", { class: fr.main }, [this.renderContent(), this.renderLastEditInfo()]) : null;
  }
  renderTitle() {
    const { visibleElements: t, title: n } = this;
    return t.title ? B(ck, { level: this.headingLevel, class: fr.title, innerHTML: n }) : null;
  }
  renderContent() {
    const t = this.viewModel.content, n = "content";
    if (!t)
      return null;
    if (Array.isArray(t))
      return t.length ? B("div", { key: `${n}-content-elements` }, t.map(this.renderContentElement, this)) : null;
    if (typeof t == "string") {
      const r = this._contentWidgets[0];
      return !r || r.destroyed ? null : B("div", { key: `${n}-content` }, r.render());
    }
    return this.renderNodeContent(t);
  }
  renderContentElement(t, n) {
    const { visibleElements: r } = this;
    if (typeof r.content != "boolean" && !r.content[t.type])
      return null;
    switch (t.type) {
      case "attachments":
        return this.renderAttachments(n);
      case "custom":
        return this.renderCustom(t, n);
      case "fields":
        return this.renderFields(n);
      case "media":
        return this.renderMedia(n);
      case "text":
        return this.renderText(t, n);
      case "expression":
        return this.renderExpression(n);
      default:
        return null;
    }
  }
  renderAttachments(t) {
    const n = this._contentWidgets[t];
    if (!n || n.destroyed)
      return null;
    const { state: r, attachmentInfos: i } = n.viewModel;
    return r === "loading" || i.length > 0 ? B("div", { key: this._buildKey("attachments-element", t), class: this.classes(fr.contentElement) }, n.render()) : null;
  }
  renderExpression(t) {
    const n = this._contentWidgets[t];
    return !n || n.destroyed ? null : B("div", { key: this._buildKey("expression-element", t), class: fr.contentElement }, n.render());
  }
  renderCustom(t, n) {
    const { creator: r } = t, i = this._contentWidgets[n];
    return !i || i.destroyed ? null : r ? B("div", { key: this._buildKey("custom-element", n), class: fr.contentElement }, i.render()) : null;
  }
  renderFields(t) {
    const n = this._contentWidgets[t];
    return !n || n.destroyed ? null : B("div", { key: this._buildKey("fields-element", t), class: fr.contentElement }, n.render());
  }
  renderMedia(t) {
    const n = this._contentWidgets[t];
    return !n || n.destroyed ? null : B("div", { key: this._buildKey("media-element", t), class: fr.contentElement }, n.render());
  }
  renderLastEditInfo() {
    const { visibleElements: t, messages: n } = this, { lastEditInfo: r } = this.viewModel;
    if (!r || !t.lastEditedInfo)
      return null;
    const { date: i, user: s } = r, o = r.type === "edit" ? s ? n.lastEditedByUser : n.lastEdited : s ? n.lastCreatedByUser : n.lastCreated, a = Ya(o, { date: i, user: s });
    return B("div", { key: "edit-info-element", class: this.classes(fr.lastEditedInfo, fr.contentElement) }, a);
  }
  renderText(t, n) {
    const r = t.text, i = this._contentWidgets[n];
    return !i || i.destroyed ? null : r ? B("div", { key: this._buildKey("text-element", n), class: this.classes(fr.contentElement, fr.text) }, i.render()) : null;
  }
  _buildKey(t, ...n) {
    return `${t}__${this.get("viewModel.graphic.uid") || "0"}-${n.join("-")}`;
  }
  _destroyContentWidget(t) {
    t && (t.viewModel = null, !t.destroyed && t.destroy());
  }
  _destroyContentWidgets() {
    this._contentWidgets.forEach((t) => this._destroyContentWidget(t)), this._contentWidgets = [];
  }
  _setupContentWidgets() {
    this._destroyContentWidgets();
    const { headingLevel: t, visibleElements: n } = this, r = this.get("viewModel.content"), { contentViewModels: i } = this.viewModel;
    if (Array.isArray(r))
      r.forEach((s, o) => {
        s.type === "attachments" && (this._contentWidgets[o] = new Hse({ displayType: s.displayType, headingLevel: n.title ? t + 1 : t, viewModel: i[o] })), s.type === "fields" && (this._contentWidgets[o] = new dV({ viewModel: i[o] })), s.type === "media" && (this._contentWidgets[o] = new QV({ viewModel: i[o] })), s.type === "text" && (this._contentWidgets[o] = new ew({ viewModel: i[o] })), s.type === "custom" && (this._contentWidgets[o] = new ew({ viewModel: i[o] })), s.type === "expression" && (this._contentWidgets[o] = new Rfe({ viewModel: i[o] }));
      }, this);
    else {
      const s = i[0];
      s && !s.destroyed && (this._contentWidgets[0] = new ew({ viewModel: s }));
    }
    this.scheduleRender();
  }
};
u([Le("viewModel.graphic")], gr.prototype, "graphic", void 0), u([Le("viewModel.defaultPopupTemplateEnabled")], gr.prototype, "defaultPopupTemplateEnabled", void 0), u([d()], gr.prototype, "headingLevel", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], gr.prototype, "label", void 0), u([d(), Si("geoscene/widgets/Feature/t9n/Feature")], gr.prototype, "messages", void 0), u([d(), Si("geoscene/t9n/common")], gr.prototype, "messagesCommon", void 0), u([d(), Si("geoscene/widgets/support/t9n/uriUtils")], gr.prototype, "messagesURIUtils", void 0), u([Le("viewModel.spatialReference")], gr.prototype, "spatialReference", void 0), u([Le("viewModel.title")], gr.prototype, "title", void 0), u([d()], gr.prototype, "visibleElements", void 0), u([mt("visibleElements")], gr.prototype, "castVisibleElements", null), u([Le("viewModel.map")], gr.prototype, "map", void 0), u([Le("viewModel.view")], gr.prototype, "view", void 0), u([d({ type: Xk })], gr.prototype, "viewModel", void 0), gr = u([T("geoscene.widgets.Feature")], gr);
const Dfe = gr;
let ad = class extends mc.EventedAccessor {
  constructor(t) {
    super(t), this._anchorHandles = new ei(), this.location = null, this.screenLocation = null, this.screenLocationEnabled = !1, this.view = null, this._anchorHandles.add([Lt(this, ["screenLocationEnabled", "location", "view.size", "view.stationary"], () => this._updateScreenPointAndHandle()), Lt(this, ["view", "view.ready"], () => this._wireUpView())]);
  }
  destroy() {
    this.view = null, this._anchorHandles && this._anchorHandles.destroy(), this._anchorHandles = null, this._viewpointHandle = null;
  }
  _wireUpView() {
    const t = "view";
    if (this._anchorHandles.remove(t), this._viewpointHandle = null, !this.get("view.ready"))
      return;
    this._setScreenLocation();
    const { view: n } = this, r = n.type === "3d" ? "camera" : "viewpoint", i = Gre(n, r, () => this._viewpointChange());
    this._anchorHandles.add(i, t), this._viewpointHandle = i, this._toggleWatchingViewpoint();
  }
  _viewpointChange() {
    this._setScreenLocation(), this.emit("view-change");
  }
  _updateScreenPointAndHandle() {
    this._setScreenLocation(), this._toggleWatchingViewpoint();
  }
  _toggleWatchingViewpoint() {
    const { _viewpointHandle: t, location: n, screenLocationEnabled: r } = this;
    t && (n && r ? t.resume() : t.pause());
  }
  _setScreenLocation() {
    const { location: t, view: n, screenLocationEnabled: r } = this, i = this.get("view.ready"), s = r && i && O(t) ? n.toScreen(t) : null;
    this._set("screenLocation", s);
  }
};
u([d()], ad.prototype, "location", void 0), u([d({ readOnly: !0 })], ad.prototype, "screenLocation", void 0), u([d()], ad.prototype, "screenLocationEnabled", void 0), u([d()], ad.prototype, "view", void 0), ad = u([T("geoscene.widgets.support.AnchorElementViewModel")], ad);
const $B = ad, jfe = "geoscene.widgets.CompassViewModel";
let Iw = class extends $B {
  constructor(t) {
    super(t), this.visible = !1;
  }
};
u([d()], Iw.prototype, "visible", void 0), Iw = u([T(jfe)], Iw);
const TB = Iw, kx = { base: "geoscene-spinner", spinnerStart: "geoscene-spinner--start", spinnerFinish: "geoscene-spinner--finish" };
let ld = class extends ti {
  constructor(t, n) {
    super(t, n), this._animationDelay = 500, this._animationPromise = null, this.location = null, this.view = null, this.viewModel = new TB(), this.visible = !1;
  }
  initialize() {
    this.own([Lt(this, "visible", (t) => this._visibleChange(t))]);
  }
  destroy() {
    this._animationPromise = null;
  }
  show(t) {
    const { location: n, promise: r } = t;
    n && (this.viewModel.location = n), this.visible = !0;
    const i = () => this.hide();
    r && r.catch(() => {
    }).then(i);
  }
  hide() {
    this.visible = !1;
  }
  render() {
    const { visible: t } = this, { screenLocation: n } = this.viewModel, r = !!n, i = t && r, s = !t && r, o = { [kx.spinnerStart]: i, [kx.spinnerFinish]: s }, a = this._getPositionStyles();
    return B("div", { class: this.classes(kx.base, o), styles: a });
  }
  _visibleChange(t) {
    if (t)
      return void (this.viewModel.screenLocationEnabled = !0);
    const n = WC(this._animationDelay);
    this._animationPromise = n, n.catch(() => {
    }).then(() => {
      this._animationPromise === n && (this.viewModel.screenLocationEnabled = !1, this._animationPromise = null);
    });
  }
  _getPositionStyles() {
    const { screenLocation: t, view: n } = this.viewModel;
    if (!n || H(t))
      return {};
    const { padding: r } = n;
    return { left: t.x - r.left + "px", top: t.y - r.top + "px" };
  }
};
u([Le("viewModel.location")], ld.prototype, "location", void 0), u([Le("viewModel.view")], ld.prototype, "view", void 0), u([d({ type: TB })], ld.prototype, "viewModel", void 0), u([Le("viewModel.visible")], ld.prototype, "visible", void 0), ld = u([T("geoscene.widgets.Spinner")], ld);
const Vfe = ld;
var AF;
(function(e) {
  e[e.size = 22] = "size", e[e.lineWidth = 50] = "lineWidth", e[e.maxSize = 120] = "maxSize", e[e.maxOutlineSize = 80] = "maxOutlineSize", e[e.tallSymbolWidth = 20] = "tallSymbolWidth";
})(AF || (AF = {}));
let zfe = class {
  constructor(t, n) {
    this._storage = new T7(), this._storage.maxSize = t, n && this._storage.registerRemoveFunc("", n);
  }
  put(t, n) {
    this._storage.put(t, n, 1, 1);
  }
  pop(t) {
    return this._storage.pop(t);
  }
  get(t) {
    return this._storage.get(t);
  }
  clear() {
    this._storage.clearAll();
  }
  destroy() {
    this._storage.destroy();
  }
};
new zfe(1e3);
new Fe([128, 128, 128]);
const Bfe = new Fe("white");
function o_(e, t) {
  if (t == null)
    return e;
  const n = e.toRgba();
  return n[3] = n[3] * t, new Fe(n);
}
function Ufe(e, t, n) {
  const r = e.symbolLayers;
  if (!r)
    return;
  const i = (s) => {
    const o = O(s) ? s : null;
    return o_(t = t || o || n != null && Bfe, n);
  };
  r.forEach((s) => {
    if (s.type !== "object" || s.resource.href == null || t)
      if (s.type === "water")
        s.color = i(s.color);
      else {
        const o = O(s.material) ? s.material.color : null, a = i(o);
        H(s.material) ? s.material = new ns({ color: a }) : s.material.color = a, n != null && "outline" in s && O(s.outline) && O(s.outline.color) && (s.outline.color = o_(s.outline.color, n));
      }
  });
}
function qfe(e, t, n) {
  (t = t || e.color) && (e.color = o_(t, n)), n != null && "outline" in e && e.outline && e.outline.color && (e.outline.color = o_(e.outline.color, n));
}
function Ax(e, t, n) {
  e && (t || n != null) && (t && (t = new Fe(t)), Dg(e) ? Ufe(e, t, n) : zO(e) && qfe(e, t, n));
}
async function Gfe(e, t) {
  const n = e.symbolLayers;
  n && await pK(n, async (r) => Wfe(r, t));
}
async function Wfe(e, t) {
  switch (e.type) {
    case "extrude":
      Jfe(e, t);
      break;
    case "icon":
    case "line":
    case "text":
      Hfe(e, t);
      break;
    case "path":
      Kfe(e, t);
      break;
    case "object":
      await Zfe(e, t);
  }
}
function Hfe(e, t) {
  const n = EB(t);
  O(n) && (e.size = n);
}
function EB(e) {
  for (const t of e)
    if (typeof t == "number")
      return t;
  return null;
}
function Jfe(e, t) {
  e.size = typeof t[2] == "number" ? t[2] : 0;
}
async function Zfe(e, t) {
  const { resourceSize: n, symbolSize: r } = await Yfe(e), i = IB(t, n, r);
  e.width = dg(t[0], r[0], n[0], i), e.depth = dg(t[1], r[1], n[1], i), e.height = dg(t[2], r[2], n[2], i);
}
function Kfe(e, t) {
  const n = IB(t, dQ, [e.width, void 0, e.height]);
  e.width = dg(t[0], e.width, 1, n), e.height = dg(t[2], e.height, 1, n);
}
function IB(e, t, n) {
  for (let r = 0; r < 3; r++) {
    const i = e[r];
    switch (i) {
      case "symbol-value":
        return n[r] != null ? n[r] / t[r] : 1;
      case "proportional":
        break;
      default:
        if (i && t[r])
          return i / t[r];
    }
  }
  return 1;
}
async function Yfe(e) {
  const t = await import("./symbolLayerUtils-A-gG54zT.js"), n = await t.computeObjectLayerResourceSize(e, 10), { width: r, height: i, depth: s } = e, o = [r, s, i];
  let a = 1;
  for (let l = 0; l < 3; l++)
    if (o[l] != null) {
      a = o[l] / n[l];
      break;
    }
  for (let l = 0; l < 3; l++)
    o[l] == null && (o[l] = n[l] * a);
  return { resourceSize: n, symbolSize: o };
}
function dg(e, t, n, r) {
  switch (e) {
    case "proportional":
      return n * r;
    case "symbol-value":
      return t ?? n;
    default:
      return e;
  }
}
function Qfe(e, t) {
  const n = EB(t);
  if (!H(n))
    switch (e.type) {
      case "simple-marker":
        e.size = n;
        break;
      case "picture-marker": {
        const r = e.width / e.height;
        r > 1 ? (e.width = n, e.height = n * r) : (e.width = n * r, e.height = n);
        break;
      }
      case "simple-line":
        e.width = n;
        break;
      case "text":
        e.font.size = n;
    }
}
async function Xfe(e, t) {
  if (e && t)
    return Dg(e) ? Gfe(e, t) : void (zO(e) && Qfe(e, t));
}
function eme(e, t, n) {
  if (e && t != null)
    if (Dg(e)) {
      const r = e.symbolLayers;
      r && r.forEach((i) => {
        if (i && i.type === "object")
          switch (n) {
            case "tilt":
              i.tilt = t;
              break;
            case "roll":
              i.roll = t;
              break;
            default:
              i.heading = t;
          }
      });
    } else
      zO(e) && (e.type !== "simple-marker" && e.type !== "picture-marker" && e.type !== "text" || (e.angle = t));
}
function MB(e) {
  return e && "opacity" in e ? e.opacity * MB(e.parent) : 1;
}
async function tme(e, t) {
  var n, r;
  if (!e)
    return;
  const i = e.sourceLayer, s = (n = O(t) && (r = t.useSourceLayer) != null && r ? i : e.layer) != null ? n : i, o = MB(s);
  if (O(e.symbol) && (!O(t) || t.ignoreGraphicSymbol !== !0)) {
    const S = e.symbol.type === "web-style" ? await e.symbol.fetchSymbol(O(t) ? t.abortOptions : null) : e.symbol.clone();
    return Ax(S, null, o), S;
  }
  const a = O(t) && t.renderer || s && "renderer" in s && s.renderer;
  let l = a && "getSymbolAsync" in a ? await a.getSymbolAsync(e, t) : null;
  if (!l)
    return;
  if (l = l.type === "web-style" ? await l.fetchSymbol(O(t) ? t.abortOptions : null) : l.clone(), !("visualVariables" in a) || !a.visualVariables || !a.visualVariables.length)
    return Ax(l, null, o), l;
  if ("arcadeRequiredForVisualVariables" in a && a.arcadeRequiredForVisualVariables && (H(t) || H(t.arcade))) {
    const S = { ...t };
    S.arcade = await kl(), t = S;
  }
  const c = await Promise.resolve().then(() => fde), p = [], f = [], m = [], y = [];
  for (const S of a.visualVariables)
    switch (S.type) {
      case "color":
        p.push(S);
        break;
      case "opacity":
        f.push(S);
        break;
      case "rotation":
        y.push(S);
        break;
      case "size":
        S.target || m.push(S);
    }
  const g = !!p.length && p[p.length - 1], v = g ? c.getColor(g, e, t) : null, w = !!f.length && f[f.length - 1];
  let b = w ? c.getOpacity(w, e, t) : null;
  if (o != null && (b = b != null ? b * o : o), Ax(l, v, b), m.length) {
    const S = c.getAllSizes(m, e, t);
    await Xfe(l, S);
  }
  for (const S of y)
    eme(l, c.getRotationAngle(S, e, t), S.axis);
  return l;
}
let MM = class {
  constructor(t = (n) => n.values().next().value) {
    this._peeker = t, this._items = /* @__PURE__ */ new Set();
  }
  get length() {
    return this._items.size;
  }
  clear() {
    this._items.clear();
  }
  last() {
    if (this._items.size === 0)
      return;
    let t;
    for (t of this._items)
      ;
    return t;
  }
  peek() {
    if (this._items.size !== 0)
      return this._peeker(this._items);
  }
  push(t) {
    this.contains(t) || this._items.add(t);
  }
  contains(t) {
    return this._items.has(t);
  }
  pop() {
    if (this.length === 0)
      return;
    const t = this.peek();
    return this._items.delete(t), t;
  }
  popLast() {
    if (this.length === 0)
      return;
    const t = this.last();
    return this._items.delete(t), t;
  }
  remove(t) {
    this._items.delete(t);
  }
  filter(t) {
    return this._items.forEach((n) => {
      t(n) || this._items.delete(n);
    }), this;
  }
};
const nme = K("mac") ? "Meta" : "Ctrl", AS = { 8: "Backspace", 9: "Tab", 13: "Enter", 27: "Escape", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete" };
for (let e = 48; e < 58; e++)
  AS[e] = String.fromCharCode(e);
for (let e = 1; e < 25; e++)
  AS[111 + e] = `F${e}`;
for (let e = 65; e < 91; e++)
  AS[e] = [String.fromCharCode(e + 32), String.fromCharCode(e)];
function rme(e) {
  if (e.key !== void 0)
    return yd(e);
  const t = AS[e.keyCode];
  return Array.isArray(t) ? e.shiftKey ? t[1] : t[0] : t;
}
function ime(e) {
  switch (e) {
    case "Ctrl":
    case "Alt":
    case "Shift":
    case "Meta":
    case "Primary":
      return !0;
  }
  return !1;
}
let sme = class {
  constructor(t, n = []) {
    this.eventType = t, this.keyModifiers = n;
  }
  matches(t) {
    if (t.type !== this.eventType)
      return !1;
    if (this.keyModifiers.length === 0)
      return !0;
    const n = t.modifiers;
    for (const r of this.keyModifiers)
      if (!n.has(r))
        return !1;
    return !0;
  }
};
const PF = we.getLogger("geoscene.views.input.InputHandler");
let dr = class {
  constructor(t) {
    this._manager = null, this._incoming = {}, this._outgoing = {}, this._incomingEventMatches = null, this._incomingEventTypes = null, this._outgoingEventTypes = null, this._hasSideEffects = t;
  }
  get incomingEventMatches() {
    if (!this._incomingEventMatches) {
      this._incomingEventMatches = [];
      for (const t in this._incoming) {
        const n = this._incoming[t];
        for (const r of n)
          this._incomingEventMatches.push(r.match);
      }
    }
    return this._incomingEventMatches;
  }
  get incomingEventTypes() {
    return this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map((t) => t.eventType)), this._incomingEventTypes;
  }
  get outgoingEventTypes() {
    return this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing)), this._outgoingEventTypes;
  }
  get hasSideEffects() {
    return this._hasSideEffects;
  }
  get hasPendingInputs() {
    return !1;
  }
  onInstall(t) {
    this._manager ? PF.error("This InputHandler has already been registered with an InputManager") : (t.setEventCallback((n) => this._handleEvent(n)), t.setUninstallCallback(() => this._onUninstall()), this._manager = t);
  }
  onUninstall() {
  }
  registerIncoming(t, n, r) {
    let i;
    typeof n == "function" ? (r = n, i = []) : i = n || [];
    const s = typeof t == "string" ? new sme(t, i) : t, o = () => {
      this._incomingEventTypes = null, this._incomingEventMatches = null;
    }, a = (p) => {
      const f = this._incoming[p.match.eventType];
      if (f) {
        const m = f.indexOf(p);
        f.splice(m, 1), o(), this._manager && this._manager.updateDependencies();
      }
    }, l = new ome(s, r, { onPause: a, onRemove: a, onResume: (p) => {
      const f = this._incoming[p.match.eventType];
      f && f.indexOf(p) === -1 && (f.push(p), o(), this._manager && this._manager.updateDependencies());
    } });
    let c = this._incoming[s.eventType];
    return c || (c = [], this._incoming[s.eventType] = c), c.push(l), o(), this._manager && this._manager.updateDependencies(), l;
  }
  registerOutgoing(t) {
    if (this._outgoing[t])
      throw Error("There is already a callback registered for this outgoing InputEvent: " + t);
    const n = new ame(t, { onEmit: (r, i, s, o) => {
      this._manager.emit(r.eventType, i, s, o);
    }, onRemove: (r) => {
      delete this._outgoing[r.eventType], this._manager.updateDependencies();
    } });
    return this._outgoing[t] = n, this._outgoingEventTypes = null, this._manager && this._manager.updateDependencies(), n;
  }
  startCapturingPointer(t) {
    this._manager.setPointerCapture(t, !0);
  }
  stopCapturingPointer(t) {
    this._manager.setPointerCapture(t, !1);
  }
  refreshHasPendingInputs() {
    this._manager.refreshHasPendingInputs();
  }
  _onUninstall() {
    this._manager ? (this.onUninstall(), this._manager = null) : PF.error("This InputHandler is not registered with an InputManager");
  }
  _handleEvent(t) {
    const n = this._incoming[t.type];
    if (n) {
      for (const r of n)
        if (r.match.matches(t) && (r.callback(t), t.shouldStopPropagation()))
          break;
    }
  }
}, ome = class {
  constructor(t, n, r) {
    this.match = t, this._callback = n, this._handler = r;
  }
  pause() {
    this._handler.onPause(this);
  }
  resume() {
    this._handler.onResume(this);
  }
  remove() {
    this._handler.onRemove(this);
  }
  get callback() {
    return this._callback;
  }
}, ame = class {
  constructor(t, n) {
    this.eventType = t, this._removed = !1, this._handler = n;
  }
  emit(t, n, r) {
    this._removed || this._handler.onEmit(this, t, n, r);
  }
  remove() {
    this._removed = !0, this._handler.onRemove(this);
  }
}, lme = class extends dr {
  constructor(t) {
    super(!0), this._onChange = t, this._value = "mouse", this.registerIncoming("pointer-down", (n) => {
      const r = n.data.native.pointerType === "touch";
      this._setValue(r ? "touch" : "mouse");
    }), this._moveHandler = this.registerIncoming("pointer-move", (n) => {
      const r = n.data.native.pointerType === "touch";
      this._setValue(r ? "touch" : "mouse");
    }), this._moveHandler.pause();
  }
  _setValue(t) {
    t !== this._value && (t === "touch" ? this._moveHandler.resume() : this._moveHandler.pause(), this._value = t, this._onChange(t));
  }
};
const Px = we.getLogger("geoscene.views.input.InputManager");
let ud = class extends ke {
  constructor(t) {
    super(t), this._pointerCaptures = /* @__PURE__ */ new Map(), this._nameToGroup = {}, this._handlers = [], this._currentPropagation = null, this._updateDependenciesAfterPropagation = !1, this._sourceEvents = /* @__PURE__ */ new Set(), this._keyModifiers = /* @__PURE__ */ new Set(), this._activeKeyModifiers = /* @__PURE__ */ new Set(), this._stoppedPropagationEventIds = /* @__PURE__ */ new Set(), this.primaryKey = nme, this.latestPointerType = "mouse", this.test = { timestamp: void 0, hasCurrentPropagation: () => !!this._currentPropagation };
  }
  initialize() {
    this.eventSource.onEventReceived = this._onEventReceived.bind(this), this._installRecognizers();
  }
  destroy() {
    const t = Object.keys(this._nameToGroup);
    for (const n of t)
      this.uninstallHandlers(n);
    this.eventSource = null, this._currentPropagation = null;
  }
  get hasPendingInputs() {
    return this._handlers.some((t) => t.handler.hasPendingInputs);
  }
  installHandlers(t, n, r = Yu.INTERNAL) {
    if (this._nameToGroup[t])
      return void Px.error("There is already an InputHandler group registered under the name `" + t + "`");
    if (n.length === 0)
      return void Px.error("Can't register a group of zero handlers");
    const i = { name: t, handlers: n.map((s) => ({ handler: s, active: !0, removed: !1, priorityIndex: 0, groupPriority: r, eventCallback: null, uninstallCallback: null })) };
    this._nameToGroup[t] = i;
    for (let s = i.handlers.length - 1; s >= 0; s--) {
      const o = i.handlers[s];
      this._handlers.push(o), o.handler.onInstall({ updateDependencies: () => {
        this.updateDependencies();
      }, emit: (a, l, c, p, f) => {
        this._emitInputEvent(o.priorityIndex + 1, a, l, c, f, p);
      }, setPointerCapture: (a, l) => {
        this._setPointerCapture(i, o, a, l);
      }, setEventCallback: (a) => {
        o.eventCallback = a;
      }, setUninstallCallback: (a) => {
        o.uninstallCallback = a;
      }, refreshHasPendingInputs: () => {
        this.notifyChange("hasPendingInputs");
      } });
    }
    this.updateDependencies();
  }
  uninstallHandlers(t) {
    const n = this._nameToGroup[t];
    n ? (n.handlers.forEach((r) => {
      r.removed = !0, r.uninstallCallback();
    }), delete this._nameToGroup[t], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = !0 : this._garbageCollectRemovedHandlers()) : Px.error("There is no InputHandler group registered under the name `" + t + "`");
  }
  hasHandlers(t) {
    return this._nameToGroup[t] !== void 0;
  }
  updateDependencies() {
    if (this._currentPropagation)
      return void (this._updateDependenciesAfterPropagation = !0);
    this._updateDependenciesAfterPropagation = !1;
    const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
    this._handlersPriority = [];
    for (let r = this._handlers.length - 1; r >= 0; r--) {
      const i = this._handlers[r];
      i.priorityIndex = r, this._handlersPriority.push(i);
    }
    this._handlersPriority = this._sortHandlersPriority(this._handlersPriority);
    for (let r = this._handlersPriority.length - 1; r >= 0; r--) {
      const i = this._handlersPriority[r];
      i.priorityIndex = r;
      let s = i.handler.hasSideEffects;
      if (!s) {
        for (const o of i.handler.outgoingEventTypes)
          if (t.has(o)) {
            s = !0;
            break;
          }
      }
      if (s)
        for (const o of i.handler.incomingEventMatches) {
          t.add(o.eventType);
          for (const a of o.keyModifiers)
            ime(a) || n.add(a);
        }
      i.active = s;
    }
    this._sourceEvents = t, this._keyModifiers = n, this._pointerCaptures.size > 0 && this._sourceEvents.add("pointer-capture-lost"), this._keyModifiers.size > 0 && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up")), this.eventSource && (this.eventSource.activeEvents = this._sourceEvents);
  }
  _setLatestPointerType(t) {
    this._set("latestPointerType", t);
  }
  _onEventReceived(t, n) {
    if (t === "pointer-capture-lost") {
      const s = n;
      this._pointerCaptures.delete(s.native.pointerId);
    }
    this._updateKeyModifiers(t, n);
    const r = this.test.timestamp != null ? this.test.timestamp : n.native ? n.native.timestamp : void 0, i = n.native ? n.native.cancelable : void 0;
    this._emitInputEventFromSource(t, n, r, i);
  }
  _updateKeyModifiers(t, n) {
    if (!n)
      return;
    let r = !1;
    const i = () => {
      if (!r) {
        const a = /* @__PURE__ */ new Set();
        this._activeKeyModifiers.forEach((l) => {
          a.add(l);
        }), this._activeKeyModifiers = a, r = !0;
      }
    }, s = (a, l) => {
      l && !this._activeKeyModifiers.has(a) ? (i(), this._activeKeyModifiers.add(a)) : !l && this._activeKeyModifiers.has(a) && (i(), this._activeKeyModifiers.delete(a));
    };
    if (t === "key-down" || t === "key-up") {
      const a = n.key;
      this._keyModifiers.has(a) && s(a, t === "key-down");
    }
    const o = n.native;
    s("Alt", !(!o || !o.altKey)), s("Ctrl", !(!o || !o.ctrlKey)), s("Shift", !(!o || !o.shiftKey)), s("Meta", !(!o || !o.metaKey)), s("Primary", this._activeKeyModifiers.has(this.primaryKey));
  }
  _installRecognizers() {
    this._latestPointerTypeHandler = new lme((t) => this._setLatestPointerType(t)), this.recognizers.length > 0 && this.installHandlers("default", this.recognizers, Yu.INTERNAL), this.installHandlers("input-manager-logic", [this._latestPointerTypeHandler], Yu.INTERNAL);
  }
  _setPointerCapture(t, n, r, i) {
    const s = t.name + "-" + n.priorityIndex, o = this._pointerCaptures.get(r.pointerId) || /* @__PURE__ */ new Set();
    this._pointerCaptures.set(r.pointerId, o), i ? (o.add(s), o.size === 1 && this.eventSource && this.eventSource.setPointerCapture(r, !0)) : o.has(s) && (o.delete(s), o.size === 0 && (this._pointerCaptures.delete(r.pointerId), this.eventSource && this.eventSource.setPointerCapture(r, !1)));
  }
  _garbageCollectRemovedHandlers() {
    this._handlers = this._handlers.filter((t) => !t.removed), this.updateDependencies();
  }
  _emitInputEventFromSource(t, n, r, i) {
    this._emitInputEvent(0, t, n, r, i);
  }
  _emitInputEvent(t, n, r, i, s, o) {
    const a = i !== void 0 ? i : this._currentPropagation ? this._currentPropagation.timestamp : performance.now(), l = s !== void 0 && s, c = { event: new ume(n, r, a, o || this._activeKeyModifiers, l), priorityIndex: t };
    this._currentPropagation ? this._currentPropagation.events.push(c) : this._doNewPropagation(c);
  }
  _doNewPropagation(t) {
    this._currentPropagation = { events: new MM(), currentHandler: null, needsHandlerGarbageCollect: !1, timestamp: t.event.timestamp }, this._currentPropagation.events.push(t), this._continuePropagation();
  }
  _continuePropagation() {
    const t = this._currentPropagation;
    if (t) {
      for (; this._currentPropagation.events.length > 0; ) {
        const { event: n, priorityIndex: r } = this._currentPropagation.events.pop(), i = n.data && n.data.eventId;
        if (!(i != null && this._stoppedPropagationEventIds.has(i)))
          for (t.currentHandler = this._handlersPriority[r]; t.currentHandler; ) {
            if (t.currentHandler.removed)
              t.needsHandlerGarbageCollect = !0;
            else {
              if (t.currentHandler.active && !n.shouldStopPropagation() && t.currentHandler.eventCallback(n), n.shouldStopPropagation()) {
                i != null && this._stoppedPropagationEventIds.add(i);
                break;
              }
              if (n.shouldPausePropagation(() => this._continuePropagation()))
                return void this._pausePropagation({ event: n, priorityIndex: t.currentHandler.priorityIndex + 1 });
            }
            t.currentHandler = this._handlersPriority[t.currentHandler.priorityIndex + 1];
          }
      }
      t.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers(), this.hasPendingInputs || this._stoppedPropagationEventIds.clear(), this._currentPropagation = null, this._updateDependenciesAfterPropagation && this.updateDependencies();
    }
  }
  _pausePropagation(t) {
    const n = new MM();
    for (n.push(t); this._currentPropagation.events.length; )
      n.push(this._currentPropagation.events.pop());
    this._currentPropagation.events = n, this._currentPropagation.currentHandler = null;
  }
  _compareHandlerPriority(t, n) {
    if (t.handler.hasSideEffects !== n.handler.hasSideEffects)
      return t.handler.hasSideEffects ? 1 : -1;
    if (t.groupPriority !== n.groupPriority)
      return t.groupPriority > n.groupPriority ? -1 : 1;
    for (const r of t.handler.incomingEventMatches)
      for (const i of n.handler.incomingEventMatches) {
        if (r.eventType !== i.eventType)
          continue;
        const s = r.keyModifiers.filter((o) => i.keyModifiers.indexOf(o) !== -1);
        if (s.length === r.keyModifiers.length != (s.length === i.keyModifiers.length))
          return r.keyModifiers.length > i.keyModifiers.length ? -1 : 1;
      }
    return t.priorityIndex > n.priorityIndex ? -1 : 1;
  }
  _sortHandlersPriority(t) {
    const n = [];
    for (const r of t) {
      let i = 0;
      for (; i < n.length && this._compareHandlerPriority(r, n[i]) >= 0; )
        i++;
      n.splice(i, 0, r);
    }
    return n;
  }
  get debug() {
    const t = (n) => {
      const r = this._setPointerCapture;
      this._setPointerCapture = () => {
      }, n(), this._setPointerCapture = r;
    };
    return { injectEvent: (n, r) => {
      t(() => {
        this._onEventReceived(n, r);
      });
    }, disablePointerCapture: t };
  }
};
u([d({ readOnly: !0 })], ud.prototype, "hasPendingInputs", null), u([d()], ud.prototype, "eventSource", void 0), u([d()], ud.prototype, "recognizers", void 0), u([d({ readOnly: !0 })], ud.prototype, "latestPointerType", void 0), ud = u([T("geoscene.views.input.InputManager")], ud);
let ume = class {
  constructor(t, n, r, i, s) {
    this.type = t, this.data = n, this.timestamp = r, this.modifiers = i, this.cancelable = s, this._propagationState = Fu.NONE, this._resumeCallback = null;
  }
  stopPropagation() {
    this._propagationState |= Fu.STOPPED;
  }
  shouldStopPropagation() {
    return (this._propagationState & Fu.STOPPED) != 0;
  }
  async(t) {
    this._propagationState |= Fu.PAUSED;
    const n = (r, i) => {
      this._propagationState &= ~Fu.PAUSED;
      const s = this._resumeCallback;
      if (this._resumeCallback = null, s && s(), i)
        throw r;
      return r;
    };
    return (typeof t == "function" ? t() : t).then((r) => n(r, !1), (r) => n(r, !0));
  }
  shouldPausePropagation(t) {
    return !!(this._propagationState & Fu.PAUSED) && (this._resumeCallback = t, !0);
  }
  preventDefault() {
    this.data.native.preventDefault();
  }
};
var Fu;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.STOPPED = 1] = "STOPPED", e[e.PAUSED = 2] = "PAUSED";
})(Fu || (Fu = {}));
const Yu = { DEFAULT: 0, TOOL: -1, WIDGET: -2, INTERNAL: -3 };
function cme(e) {
  return e && typeof e.highlight == "function";
}
const PS = { iconZoom: "geoscene-icon-zoom-in-magnifying-glass", iconTrash: "geoscene-icon-trash", iconBrowseClusteredFeatures: "geoscene-icon-table" }, Fd = new Wf({ id: "zoom-to-feature", title: "{messages.zoom}", className: PS.iconZoom }), RF = new Wf({ id: "remove-selected-feature", title: "{messages.remove}", className: PS.iconTrash }), Wh = new Wf({ id: "zoom-to-clustered-features", title: "{messages.zoom}", className: PS.iconZoom }), Hh = new Wf({ id: "browse-clustered-features", title: "{messages.browseClusteredFeatures}", className: PS.iconBrowseClusteredFeatures }), dme = "geoscene.widgets.Popup.PopupViewModel", ac = we.getLogger(dme), pme = function(e) {
  const { event: t, view: n } = e, { action: r } = t, i = n && n.popup;
  if (!r)
    return Promise.reject(new D("trigger-action:missing-arguments", "Event has no action"));
  if (!i)
    return Promise.reject(new D("trigger-action:missing-arguments", "view.popup is missing"));
  const { disabled: s, id: o } = r;
  if (!o)
    return Promise.reject(new D("trigger-action:invalid-action", "action.id is missing"));
  if (s)
    return Promise.reject(new D("trigger-action:invalid-action", "Action is disabled"));
  if (o === Fd.id)
    return fme(i.viewModel).catch(O$);
  if (o === Wh.id)
    return mme(i.viewModel);
  if (o === Hh.id)
    return i.featureMenuOpen = !i.featureMenuOpen, i.viewModel.browseClusterEnabled = !i.viewModel.browseClusterEnabled, Promise.resolve();
  if (i.viewModel.browseClusterEnabled = !1, o === RF.id) {
    i.close();
    const { selectedFeature: a } = i;
    if (!a)
      return Promise.reject(new D(`trigger-action:${RF.id}`, "selectedFeature is required", { selectedFeature: a }));
    const { sourceLayer: l } = a;
    return l ? l.remove(a) : n.graphics.remove(a), Promise.resolve();
  }
  return Promise.resolve();
};
function CB(e) {
  const { selectedFeature: t, location: n, view: r } = e;
  return r ? r.type === "3d" ? t || n : e.get("selectedFeature.geometry") || n : null;
}
function hme(e, t) {
  if ((t == null ? void 0 : t.type) !== "3d" || !e || e.declaredClass !== "geoscene.Graphic")
    return !0;
  const n = t.getViewForGraphic(e);
  if (n && "whenGraphicBounds" in n) {
    let r = !1;
    return n.whenGraphicBounds(e, { useViewElevation: !0 }).then((i) => {
      r = !i || !i.boundingBox || i.boundingBox[0] === i.boundingBox[3] && i.boundingBox[1] === i.boundingBox[4] && i.boundingBox[2] === i.boundingBox[5];
    }).catch(() => {
      const i = new D("zoom-to:invalid-graphic", "Could not zoom to the location of the graphic.", { graphic: e });
      ac.error(i);
    }), r;
  }
  return !0;
}
async function fme(e) {
  const { location: t, selectedFeature: n, view: r, zoomFactor: i } = e, s = CB(e);
  if (!s) {
    const c = new D("zoom-to:invalid-target-or-view", "Cannot zoom to location without a target and view.", { target: s, view: r });
    return ac.error(c), Promise.reject(c);
  }
  const o = r.scale / i, a = e.get("selectedFeature.geometry") || t, l = a && a.type === "point" && hme(n, r);
  Fd.active = !0, Fd.disabled = !0;
  try {
    await e.view.goTo({ target: s, scale: l ? o : void 0 });
  } finally {
    Fd.active = !1, Fd.disabled = !1, e.zoomToLocation = null, l && (e.location = a);
  }
}
async function mme(e) {
  const { selectedFeature: t, view: n } = e;
  if ((n == null ? void 0 : n.type) !== "2d") {
    const a = new D("zoomToCluster:invalid-view", "View must be 2d MapView.", { view: n });
    throw ac.error(a), a;
  }
  if (!t.isAggregate) {
    const a = new D("zoomToCluster:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: t });
    throw ac.error(a), a;
  }
  const r = t.sourceLayer, i = await n.whenLayerView(r), s = i.createQuery();
  s.aggregateIds = [t.getObjectId()], Wh.active = !0, Wh.disabled = !0;
  const { extent: o } = await i.queryExtent(s);
  await n.goTo({ target: o }), Wh.active = !1, Wh.disabled = !1;
}
async function yme(e) {
  const { selectedFeature: t, view: n } = e;
  if ((n == null ? void 0 : n.type) !== "2d") {
    const a = new D("displayClusterExtent:invalid-view", "View must be 2d MapView.", { view: n });
    throw ac.error(a), a;
  }
  if (!t.isAggregate) {
    const a = new D("zoomToCluster:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: t });
    throw ac.error(a), a;
  }
  const r = t.sourceLayer, i = await n.whenLayerView(r), s = i.createQuery();
  s.aggregateIds = [t.getObjectId()];
  const { extent: o } = await i.queryExtent(s);
  e.selectedClusterBoundaryFeature.geometry = o, n.graphics.add(e.selectedClusterBoundaryFeature);
}
async function gme(e) {
  const { selectedFeature: t, view: n } = e;
  if ((n == null ? void 0 : n.type) !== "2d") {
    const a = new D("browseAggregateFeatures:invalid-view", "View must be 2d MapView.", { view: n });
    throw ac.error(a), a;
  }
  if (!t.isAggregate) {
    const a = new D("browseAggregateFeatures:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: t });
    throw ac.error(a), a;
  }
  const r = t.sourceLayer, i = await n.whenLayerView(r), s = i.createQuery();
  s.aggregateIds = [t.getObjectId()], Hh.active = !0, Hh.disabled = !0;
  const { features: o } = await i.queryFeatures(s);
  Hh.active = !1, Hh.disabled = !1, n.popup.open({ features: [t].concat(o), featureMenuOpen: !0 });
}
function vme(e) {
  var t;
  (t = e.selectedFeature) != null && t.isAggregate && (e.features = e.features.filter((n) => n.isAggregate));
}
const OB = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this.goToOverride = null, this.view = null;
    }
    callGoTo(n) {
      const { view: r } = this;
      return this.goToOverride ? this.goToOverride(r, n) : r.goTo(n.target, n.options);
    }
  };
  return u([d()], t.prototype, "goToOverride", void 0), u([d()], t.prototype, "view", void 0), t = u([T("geoscene.widgets.support.GoTo")], t), t;
}, pg = Ne.ofType({ key: "type", defaultKeyValue: "button", base: aS, typeMap: { button: Wf, toggle: ej } }), bme = () => [Fd.clone()], wme = () => [Wh.clone(), Hh.clone()], kB = "geoscene.widgets.Popup.PopupViewModel", LF = we.getLogger(kB);
let ct = class extends OB($B) {
  constructor(e) {
    super(e), this._handles = new ei(), this._pendingPromises = /* @__PURE__ */ new Set(), this._fetchFeaturesController = null, this._selectedClusterFeature = null, this.featurePage = null, this.actions = new pg(), this.defaultPopupTemplateEnabled = !1, this.autoCloseEnabled = !1, this.autoOpenEnabled = !0, this.browseClusterEnabled = !1, this.content = null, this.featuresPerPage = 20, this.featureViewModelAbilities = null, this.featureViewModels = [], this.highlightEnabled = !0, this.includeDefaultActions = !0, this.selectedClusterBoundaryFeature = new Jt({ symbol: new Ip({ outline: { width: 1.5, color: "cyan" }, style: "none" }) }), this.title = null, this.updateLocationEnabled = !1, this.view = null, this.visible = !1, this.zoomFactor = 4, this.zoomToLocation = null;
  }
  get isLoadingFeature() {
    return this.featureViewModels.some((e) => e.waitingForContent);
  }
  initialize() {
    this._handles.add([gn(this, ["autoOpenEnabled", "view"], () => this._autoOpenEnabledChange()), this.on("view-change", () => this._autoClose()), Lt(this, ["highlightEnabled", "selectedFeature", "visible", "view"], () => this._highlightFeature()), Lt(this, "view.animation.state", (e) => this._animationStateChange(e)), Lt(this, "location", (e) => this._locationChange(e)), Lt(this, "selectedFeature", (e) => this._selectedFeatureChange(e)), Lt(this, ["selectedFeatureIndex", "featureCount", "featuresPerPage"], () => this._selectedFeatureIndexChange()), Lt(this, ["featurePage", "selectedFeatureIndex", "featureCount", "featuresPerPage, featureViewModels"], () => this._setGraphicOnFeatureViewModels()), Lt(this, "featureViewModels", () => this._featureViewModelsChange()), this.on("trigger-action", (e) => pme({ event: e, view: this.view })), LE(this, "waitingForResult", () => this._waitingForResultChange(), !0), Lt(this, ["features", "view", "view.map", "view.spatialReference"], () => this._updateFeatureVMs()), Lt(this, ["view.scale"], this._viewScaleChange), LE(this, "visible", () => this.browseClusterEnabled = !1), Lt(this, "browseClusterEnabled", (e) => e ? this.enableClusterBrowsing() : this.disableClusterBrowsing())]);
  }
  destroy() {
    this._cancelFetchingFeatures(), this._handles.destroy(), this._handles = null, this._pendingPromises.clear(), this.browseClusterEnabled = !1, this.view = null;
  }
  get active() {
    return !(!this.visible || this.waitingForResult);
  }
  get allActions() {
    const e = this._get("allActions") || new pg();
    e.removeAll();
    const { actions: t, defaultActions: n, defaultPopupTemplateEnabled: r, includeDefaultActions: i, selectedFeature: s } = this, o = i ? n.concat(t) : t, a = s && (typeof s.getEffectivePopupTemplate == "function" && s.getEffectivePopupTemplate(r) || s.popupTemplate), l = a && a.actions, c = a && a.overwriteActions ? l : l ? l.concat(o) : o;
    return c && c.filter(Boolean).forEach((p) => e.add(p)), e;
  }
  get defaultActions() {
    var e;
    const t = this._get("defaultActions") || new pg();
    return t.removeAll(), t.addMany((e = this.selectedFeature) != null && e.isAggregate ? wme() : bme()), t;
  }
  get featureCount() {
    return this.features.length;
  }
  get features() {
    return this._get("features") || [];
  }
  set features(e) {
    const t = e || [];
    this._set("features", t);
    const { pendingPromisesCount: n, promiseCount: r, selectedFeatureIndex: i } = this, s = r && t.length;
    s && n && i === -1 ? this.selectedFeatureIndex = 0 : s && i !== -1 || (this.selectedFeatureIndex = t.length ? 0 : -1);
  }
  get location() {
    return this._get("location") || null;
  }
  set location(e) {
    const t = this.get("view.spatialReference.isWebMercator");
    e && e.get("spatialReference.isWGS84") && t && (e = Zu(e)), this._set("location", e);
  }
  get pendingPromisesCount() {
    return this._pendingPromises.size;
  }
  get waitingForResult() {
    return !(!(this._fetchFeaturesController || this.pendingPromisesCount > 0) || this.featureCount !== 0);
  }
  get promiseCount() {
    return this.promises.length;
  }
  get promises() {
    return this._get("promises") || [];
  }
  set promises(e) {
    if (this._pendingPromises.clear(), this.features = [], !Array.isArray(e) || !e.length)
      return this._set("promises", []), void this.notifyChange("pendingPromisesCount");
    this._set("promises", e), (e = e.slice(0)).forEach((t) => {
      this._pendingPromises.add(t);
      const n = (i) => {
        this._pendingPromises.has(t) && this._updateFeatures(i), this._updatePendingPromises(t);
      }, r = () => this._updatePendingPromises(t);
      t.then(n, r);
    }), this.notifyChange("pendingPromisesCount");
  }
  get selectedFeature() {
    const { features: e, selectedFeatureIndex: t } = this;
    return t === -1 ? null : e[t] || null;
  }
  get selectedFeatureIndex() {
    const e = this._get("selectedFeatureIndex");
    return typeof e == "number" ? e : -1;
  }
  set selectedFeatureIndex(e) {
    const { featureCount: t } = this;
    e = isNaN(e) || e < -1 || !t ? -1 : (e + t) % t, this._set("selectedFeatureIndex", e);
  }
  get selectedFeatureViewModel() {
    return this.featureViewModels[this.selectedFeatureIndex] || null;
  }
  get state() {
    return this.get("view.ready") ? "ready" : "disabled";
  }
  centerAtLocation() {
    const { view: e } = this, t = CB(this);
    if (!t) {
      const n = new D("center-at-location:invalid-target-or-view", "Cannot center at a location without a target and view.", { target: t, view: e });
      return LF.error(n), Promise.reject(n);
    }
    return this.callGoTo({ target: { target: t, scale: e.scale } });
  }
  clear() {
    this.set({ promises: [], features: [], content: null, title: null, location: null });
  }
  fetchFeatures(e, t) {
    const { view: n } = this;
    if (!n || !e) {
      const r = new D("fetch-features:invalid-screenpoint-or-view", "Cannot fetch features without a screenPoint and view.", { screenPoint: e, view: n });
      return LF.error(r), Promise.reject(r);
    }
    return n.fetchPopupFeatures(e, { event: t && t.event, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, signal: t && t.signal });
  }
  open(e) {
    const t = { updateLocationEnabled: !1, promises: [], fetchFeatures: !1, ...e, visible: !0 }, { fetchFeatures: n } = t;
    delete t.fetchFeatures, n && this._setFetchFeaturesPromises(t.location);
    const r = ["actionsMenuOpen", "collapsed", "featureMenuOpen"];
    for (const i of r)
      delete t[i];
    this.set(t);
  }
  triggerAction(e) {
    const t = this.allActions.getItemAt(e);
    t && !t.disabled && this.emit("trigger-action", { action: t });
  }
  next() {
    return this.selectedFeatureIndex = this.selectedFeatureIndex + 1, this;
  }
  previous() {
    return this.selectedFeatureIndex = this.selectedFeatureIndex - 1, this;
  }
  disableClusterBrowsing() {
    vme(this), this._clearBrowsedClusterGraphics();
  }
  async enableClusterBrowsing() {
    await yme(this), await gme(this);
  }
  _animationStateChange(e) {
    this.zoomToLocation || (Fd.disabled = e === "waiting-for-target");
  }
  _clearBrowsedClusterGraphics() {
    var e;
    const t = (e = this.view) == null ? void 0 : e.graphics;
    t && (t.remove(this.selectedClusterBoundaryFeature), t.remove(this._selectedClusterFeature)), this._selectedClusterFeature = null, this.selectedClusterBoundaryFeature.geometry = null;
  }
  _viewScaleChange() {
    var e;
    if ((e = this.selectedFeature) != null && e.isAggregate)
      return this.browseClusterEnabled = !1, this.visible = !1, void this.clear();
    this.browseClusterEnabled && (this.browseClusterEnabled = !1, this.features = [this.selectedFeature]);
  }
  _locationChange(e) {
    const { selectedFeature: t, updateLocationEnabled: n } = this;
    n && e && (!t || t.geometry) && this.centerAtLocation();
  }
  _selectedFeatureIndexChange() {
    this.featurePage = this.featureCount > 1 ? Math.floor(this.selectedFeatureIndex / this.featuresPerPage) + 1 : null;
  }
  _featureViewModelsChange() {
    this.featurePage = this.featureCount > 1 ? 1 : null;
  }
  _setGraphicOnFeatureViewModels() {
    const { features: e, featureCount: t, featurePage: n, featuresPerPage: r, featureViewModels: i } = this;
    if (n === null)
      return;
    const s = ((n - 1) * r + t) % t, o = s + r;
    i.slice(s, o).forEach((a, l) => {
      a && !a.graphic && (a.graphic = e[s + l]);
    });
  }
  async _selectedFeatureChange(e) {
    if (!e)
      return;
    const { location: t, updateLocationEnabled: n, view: r } = this;
    if (this.browseClusterEnabled)
      return this._selectedClusterFeature && (r.graphics.remove(this._selectedClusterFeature), this._selectedClusterFeature = null), e.isAggregate ? void 0 : (e.symbol = await tme(e), this._selectedClusterFeature = e, void r.graphics.add(this._selectedClusterFeature));
    !n && t || !e.geometry ? n && !e.geometry && this.centerAtLocation().then(() => {
      this.location = r.center.clone();
    }) : this.location = this._getPointFromGeometry(e.geometry);
  }
  _waitingForResultChange() {
    !this.featureCount && this.promises && (this.visible = !1);
  }
  _setFetchFeaturesPromises(e) {
    return this._fetchFeaturesWithController(this._getScreenPoint(e || this.location)).then((t) => {
      const { clientOnlyGraphics: n, promisesPerLayerView: r } = t, i = Promise.resolve(n), s = r.map((o) => o.promise);
      this.promises = [i, ...s];
    });
  }
  _destroyFeatureVMs() {
    this.featureViewModels.forEach((e) => e && !e.destroyed && e.destroy()), this._set("featureViewModels", []);
  }
  _updateFeatureVMs() {
    const { selectedFeature: e, features: t, featureViewModels: n } = this;
    if (e != null && e.isAggregate || (this.browseClusterEnabled = !1), this._destroyFeatureVMs(), !t || !t.length)
      return;
    const r = n.slice(0), i = [];
    t.forEach((s, o) => {
      if (!s)
        return;
      let a = null;
      if (r.some((p, f) => (p && p.graphic === s && (a = p, r.splice(f, 1)), !!a)), a)
        i[o] = a;
      else {
        var l, c;
        const p = new Xk({ abilities: this.featureViewModelAbilities, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, spatialReference: (l = this.view) == null ? void 0 : l.spatialReference, graphic: s === e ? s : null, map: (c = this.view) == null ? void 0 : c.map, view: this.view });
        i[o] = p;
      }
    }), r.forEach((s) => s && !s.destroyed && s.destroy()), this._set("featureViewModels", i);
  }
  _getScreenPoint(e) {
    const { view: t } = this;
    return t && e && typeof t.toScreen == "function" ? t.toScreen(e) : null;
  }
  _autoOpenEnabledChange() {
    const e = "auto-fetch-features", { _handles: t, autoOpenEnabled: n } = this;
    if (t.remove(e), n && this.view) {
      const r = this.view.on("click", (i) => {
        i.pointerType === "mouse" && i.button !== 0 || this._fetchFeaturesAndOpen(i);
      }, Yu.WIDGET);
      t.add(r, e);
    }
  }
  _cancelFetchingFeatures() {
    const e = this._fetchFeaturesController;
    e && e.abort(), this._fetchFeaturesController = null, this.notifyChange("waitingForResult");
  }
  _fetchFeaturesWithController(e, t) {
    this._cancelFetchingFeatures();
    const n = new AbortController(), { signal: r } = n;
    this._fetchFeaturesController = n, this.notifyChange("waitingForResult");
    const i = this.fetchFeatures(e, { signal: r, event: t });
    return i.catch(() => {
    }).then(() => {
      this._fetchFeaturesController = null, this.notifyChange("waitingForResult");
    }), i;
  }
  _fetchFeaturesAndOpen(e) {
    const { screenPoint: t, mapPoint: n } = e, { view: r } = this;
    this._fetchFeaturesWithController(t, e).then((i) => {
      const { clientOnlyGraphics: s, promisesPerLayerView: o, location: a } = i, l = [Promise.resolve(s), ...o.map((c) => c.promise)];
      return r.popup.open({ location: a || n, promises: l }), i;
    });
  }
  _updatePendingPromises(e) {
    e && this._pendingPromises.has(e) && (this._pendingPromises.delete(e), this.notifyChange("pendingPromisesCount"));
  }
  _autoClose() {
    this.autoCloseEnabled && (this.visible = !1);
  }
  _getPointFromGeometry(e) {
    return H(e) ? null : e.type === "point" ? e : e.type === "extent" ? e.center : e.type === "polygon" ? e.centroid : e.type === "multipoint" || e.type === "polyline" ? e.extent.center : null;
  }
  async _getLayerView(e, t) {
    return await e.when(), e.whenLayerView(t);
  }
  async _highlightFeature() {
    const e = "highlight";
    this._handles.remove(e);
    const { selectedFeature: t, highlightEnabled: n, view: r, visible: i } = this;
    if (!(t && r && n && i))
      return;
    let { layer: s, sourceLayer: o } = t;
    if ((o == null ? void 0 : o.type) !== "map-notes" && (o == null ? void 0 : o.type) !== "subtype-group" || (s = o), !(s && s instanceof iS))
      return;
    const a = this._getLayerView(r, s);
    this._highlightPromise = a;
    const l = await a;
    if (!(l && cme(l) && this._highlightPromise === a && this.selectedFeature && this.highlightEnabled && this.visible))
      return;
    const c = s.type === "imagery" ? void 0 : "objectIdField" in s && s.objectIdField, p = t.attributes, f = p && c && p[c], m = l.highlight(f || t);
    this._handles.add(m, e);
  }
  _updateFeatures(e) {
    const { features: t } = this;
    if (!e || !e.length)
      return;
    if (!t.length)
      return void (this.features = e);
    const n = e.filter((r) => t.indexOf(r) === -1);
    this.features = t.concat(n);
  }
};
u([d()], ct.prototype, "featurePage", void 0), u([d()], ct.prototype, "isLoadingFeature", null), u([d({ type: pg })], ct.prototype, "actions", void 0), u([d({ readOnly: !0 })], ct.prototype, "active", null), u([d({ readOnly: !0 })], ct.prototype, "allActions", null), u([d({ type: Boolean })], ct.prototype, "defaultPopupTemplateEnabled", void 0), u([d()], ct.prototype, "autoCloseEnabled", void 0), u([d()], ct.prototype, "autoOpenEnabled", void 0), u([d()], ct.prototype, "browseClusterEnabled", void 0), u([d()], ct.prototype, "content", void 0), u([d({ type: pg, readOnly: !0 })], ct.prototype, "defaultActions", null), u([d({ readOnly: !0 })], ct.prototype, "featureCount", null), u([d()], ct.prototype, "features", null), u([d()], ct.prototype, "featuresPerPage", void 0), u([d()], ct.prototype, "featureViewModelAbilities", void 0), u([d({ readOnly: !0 })], ct.prototype, "featureViewModels", void 0), u([d()], ct.prototype, "highlightEnabled", void 0), u([d()], ct.prototype, "includeDefaultActions", void 0), u([d({ type: Oe })], ct.prototype, "location", null), u([d({ readOnly: !0 })], ct.prototype, "pendingPromisesCount", null), u([d({ readOnly: !0 })], ct.prototype, "selectedClusterBoundaryFeature", void 0), u([d({ readOnly: !0 })], ct.prototype, "waitingForResult", null), u([d({ readOnly: !0 })], ct.prototype, "promiseCount", null), u([d()], ct.prototype, "promises", null), u([d({ value: null, readOnly: !0 })], ct.prototype, "selectedFeature", null), u([d({ value: -1 })], ct.prototype, "selectedFeatureIndex", null), u([d({ readOnly: !0 })], ct.prototype, "selectedFeatureViewModel", null), u([d({ readOnly: !0 })], ct.prototype, "state", null), u([d()], ct.prototype, "title", void 0), u([d()], ct.prototype, "updateLocationEnabled", void 0), u([d()], ct.prototype, "view", void 0), u([d()], ct.prototype, "visible", void 0), u([d()], ct.prototype, "zoomFactor", void 0), u([d()], ct.prototype, "zoomToLocation", void 0), u([d()], ct.prototype, "centerAtLocation", null), ct = u([T(kB)], ct);
const AB = ct, FF = "selected-index", _me = 0, NF = "popup-spinner", le = { iconLeftTriangleArrow: "geoscene-icon-left-triangle-arrow", iconRightTriangleArrow: "geoscene-icon-right-triangle-arrow", iconDockToTop: "geoscene-icon-maximize", iconDockToBottom: "geoscene-icon-dock-bottom", iconDockToLeft: "geoscene-icon-dock-left", iconDockToRight: "geoscene-icon-dock-right", iconClose: "geoscene-icon-close", iconUndock: "geoscene-icon-minimize", iconCheckMark: "geoscene-icon-check-mark", iconLoading: "geoscene-icon-loading-indicator", iconDefaultAction: "geoscene-icon-default-action", iconActionsMenu: "geoscene-icon-handle-horizontal", rotating: "geoscene-rotating", base: "geoscene-popup", widget: "geoscene-widget", main: "geoscene-popup__main-container", loadingContainer: "geoscene-popup__loading-container", isCollapsible: "geoscene-popup--is-collapsible", isCollapsed: "geoscene-popup--is-collapsed", shadow: "geoscene-popup--shadow", isDocked: "geoscene-popup--is-docked", isDockedTopLeft: "geoscene-popup--is-docked-top-left", isDockedTopCenter: "geoscene-popup--is-docked-top-center", isDockedTopRight: "geoscene-popup--is-docked-top-right", isDockedBottomLeft: "geoscene-popup--is-docked-bottom-left", isDockedBottomCenter: "geoscene-popup--is-docked-bottom-center", isDockedBottomRight: "geoscene-popup--is-docked-bottom-right", alignTopCenter: "geoscene-popup--aligned-top-center", alignBottomCenter: "geoscene-popup--aligned-bottom-center", alignTopLeft: "geoscene-popup--aligned-top-left", alignBottomLeft: "geoscene-popup--aligned-bottom-left", alignTopRight: "geoscene-popup--aligned-top-right", alignBottomRight: "geoscene-popup--aligned-bottom-right", isFeatureMenuOpen: "geoscene-popup--feature-menu-open", isActionsMenuOpen: "geoscene-popup--actions-menu-open", hasFeatureUpdated: "geoscene-popup--feature-updated", header: "geoscene-popup__header", headerButtons: "geoscene-popup__header-buttons", headerContainer: "geoscene-popup__header-container", headerContainerButton: "geoscene-popup__header-container--button", headerTitle: "geoscene-popup__header-title", content: "geoscene-popup__content", footer: "geoscene-popup__footer", footerHasPagination: "geoscene-popup__footer--has-pagination", footerHasActions: "geoscene-popup__footer--has-actions", footerHasActionsMenu: "geoscene-popup__footer--has-actions-menu", button: "geoscene-popup__button", buttonDisabled: "geoscene-popup__button--disabled", buttonDock: "geoscene-popup__button--dock", icon: "geoscene-popup__icon", iconDock: "geoscene-popup__icon--dock-icon", inlineActionsContainer: "geoscene-popup__inline-actions-container", actionsMenuButton: "geoscene-popup__actions-menu-button", actions: "geoscene-popup__actions", action: "geoscene-popup__action", actionImage: "geoscene-popup__action-image", actionText: "geoscene-popup__action-text", actionToggle: "geoscene-popup__action-toggle", actionToggleOn: "geoscene-popup__action-toggle--on", pointer: "geoscene-popup__pointer", pointerDirection: "geoscene-popup__pointer-direction", navigation: "geoscene-popup__navigation", paginationPrevious: "geoscene-popup__pagination-previous", paginationNext: "geoscene-popup__pagination-next", paginationPreviousIconLTR: "geoscene-popup__pagination-previous-icon", paginationPreviousIconRTL: "geoscene-popup__pagination-previous-icon--rtl", paginationNextIconLTR: "geoscene-popup__pagination-next-icon", paginationNextIconRTL: "geoscene-popup__pagination-next-icon--rtl", featureMenu: "geoscene-popup__feature-menu", featureMenuList: "geoscene-popup__feature-menu-list", featureMenuItem: "geoscene-popup__feature-menu-item", featureMenuViewport: "geoscene-popup__feature-menu-viewport", featureMenuHeader: "geoscene-popup__feature-menu-header", featureMenuNote: "geoscene-popup__feature-menu-note", featureMenuSelected: "geoscene-popup__feature-menu-item--selected", featureMenuButton: "geoscene-popup__feature-menu-button", featureMenuTitle: "geoscene-popup__feature-menu-title", featureMenuObserver: "geoscene-popup__feature-menu-observer", featureMenuLoader: "geoscene-popup__feature-menu-loader", collapseButton: "geoscene-popup__collapse-button" }, DF = { buttonEnabled: !0, position: "auto", breakpoint: { width: 544 } }, jF = "geoscene-popup";
function Va(e, t) {
  return t === void 0 ? `${jF}__${e}` : `${jF}__${e}-${t}`;
}
const PB = "geoscene.widgets.Popup", VF = we.getLogger(PB), zF = { closeButton: !0, featureNavigation: !0 };
let Re = class extends xB(ti) {
  constructor(e, t) {
    super(e, t), this._blurClose = !1, this._blurContainer = !1, this._containerNode = null, this._mainContainerNode = null, this._featureMenuNode = null, this._actionsMenuNode = null, this._focusClose = !1, this._focusContainer = !1, this._focusDockButton = !1, this._focusFeatureMenuButton = !1, this._focusActionsMenuButton = !1, this._focusFirstFeature = !1, this._focusFirstAction = !1, this._handles = new ei(), this._pointerOffsetInPx = 16, this._spinner = null, this._feature = null, this._featureMenuIntersectionObserverCallback = ([n]) => {
      n != null && n.isIntersecting && this.viewModel.featurePage++;
    }, this._featureMenuIntersectionObserver = new IntersectionObserver(this._featureMenuIntersectionObserverCallback, { root: window.document }), this._displaySpinnerThrottled = ek(() => this._displaySpinner(), _me), this.actions = null, this.alignment = "auto", this.autoCloseEnabled = null, this.autoOpenEnabled = null, this.defaultPopupTemplateEnabled = null, this.content = null, this.collapsed = !1, this.collapseEnabled = !0, this.dockEnabled = !1, this.featureCount = null, this.featureMenuOpen = !1, this.features = null, this.goToOverride = null, this.headingLevel = 2, this.highlightEnabled = null, this.location = null, this.label = void 0, this.maxInlineActions = 3, this.messages = null, this.messagesCommon = null, this.promises = null, this.selectedFeature = null, this.selectedFeatureIndex = null, this.spinnerEnabled = !0, this.title = null, this.updateLocationEnabled = null, this.view = null, this.viewModel = new AB(), this.visible = null, this.visibleElements = { ...zF }, this._addSelectedFeatureIndexHandle(), this.own([Lt(this, "viewModel.screenLocation", () => this._positionContainer()), Lt(this, ["viewModel.active", "dockEnabled"], () => this._toggleScreenLocationEnabled()), Lt(this, "viewModel.screenLocation", (n, r) => {
      !!n != !!r && this.reposition();
    }), Lt(this, ["viewModel.view.padding", "viewModel.view.size", "viewModel.active", "viewModel.location", "alignment"], () => this.reposition()), Lt(this, "spinnerEnabled", (n) => this._spinnerEnabledChange(n)), Lt(this, "viewModel.view.size", (n, r) => this._updateDockEnabledForViewSize(n, r)), Lt(this, "viewModel.view", (n, r) => this._viewChange(n, r)), Lt(this, "viewModel.view.ready", (n, r) => this._viewReadyChange(n, r)), Lt(this, ["viewModel.waitingForResult", "viewModel.location"], () => {
      this._hideSpinner(), this._displaySpinnerThrottled();
    }), Lt(this, ["selectedFeatureWidget.viewModel.title", "selectedFeatureWidget.viewModel.state"], () => this._setTitleFromFeatureWidget()), Lt(this, ["selectedFeatureWidget.viewModel.content", "selectedFeatureWidget.viewModel.state"], () => this._setContentFromFeatureWidget()), LE(this, "collapsed", () => {
      var n, r;
      ((n = this.viewModel) == null || (r = n.view) == null ? void 0 : r.widthBreakpoint) === "xsmall" && this.viewModel.active && this.collapseEnabled && this.viewModel.centerAtLocation();
    }), gS(this, "viewModel.allActions", "change", () => this._watchActions()), gn(this, "viewModel.allActions", () => this._watchActions()), Lt(this, "viewModel.featureViewModels", () => this._featureMenuViewportScrollTop())]);
  }
  destroy() {
    var e, t;
    this._destroySelectedFeatureWidget(), this._destroySpinner(), (e = this._handles) == null || e.destroy(), this._unobserveFeatureMenuObserver(), (t = this._featureMenuIntersectionObserver) == null || t.disconnect(), this._handles = null;
  }
  get actionsMenuId() {
    return `${this.id}-actions-menu`;
  }
  get actionsMenuButtonId() {
    return `${this.id}-actions-menu-button`;
  }
  get featureMenuId() {
    return `${this.id}-feature-menu`;
  }
  get titleId() {
    return `${this.id}-popup-title`;
  }
  get contentId() {
    return `${this.id}-popup-content`;
  }
  get hasContent() {
    var e, t, n, r, i, s, o;
    return !!(this.selectedFeatureWidget ? !((e = this.selectedFeatureWidget) == null || (t = e.viewModel) == null) && t.waitingForContent || ((n = this.selectedFeatureWidget) == null || (r = n.viewModel) == null ? void 0 : r.state) === "error" || !((i = this.selectedFeatureWidget) == null || (s = i.viewModel) == null) && s.content : (o = this.viewModel) != null && o.content);
  }
  get featureNavigationVisible() {
    return this.viewModel.active && this.viewModel.featureCount > 1 && this.visibleElements.featureNavigation;
  }
  get collapsible() {
    return !!(this.collapseEnabled && this.viewModel.title && this.hasContent);
  }
  get featureMenuVisible() {
    return this.featureNavigationVisible && this.featureMenuOpen;
  }
  get contentCollapsed() {
    return this.collapsible && !this.featureMenuVisible && this.collapsed;
  }
  get dividedActions() {
    return this._divideActions();
  }
  set actionsMenuOpen(e) {
    this._set("actionsMenuOpen", !!e);
  }
  get actionsMenuOpen() {
    return !!this.viewModel.active && this._get("actionsMenuOpen");
  }
  get currentAlignment() {
    return this._getCurrentAlignment();
  }
  get currentDockPosition() {
    return this._getCurrentDockPosition();
  }
  get dockOptions() {
    return this._get("dockOptions") || DF;
  }
  set dockOptions(e) {
    const t = { ...DF }, n = this.get("viewModel.view.breakpoints"), r = {};
    n && (r.width = n.xsmall, r.height = n.xsmall);
    const i = { ...t, ...e }, s = { ...t.breakpoint, ...r }, { breakpoint: o } = i;
    o === !0 ? i.breakpoint = s : typeof o == "object" && (i.breakpoint = { ...s, ...o }), this._set("dockOptions", i), this._setCurrentDockPosition(), this.reposition();
  }
  get selectedFeatureWidget() {
    const { _feature: e, visibleElements: t, headingLevel: n } = this, { selectedFeatureViewModel: r } = this.viewModel, i = { ...t, title: !1 };
    return r ? (e ? (e.viewModel = r, e.visibleElements = i) : this._feature = new Dfe({ headingLevel: n + 1, viewModel: r, visibleElements: i }), this._feature) : null;
  }
  castVisibleElements(e) {
    return { ...zF, ...e };
  }
  blur() {
    const { active: e } = this.viewModel;
    e || VF.warn("Popup can only be blurred when currently active."), this.visibleElements.closeButton ? this._blurClose = !0 : this._blurContainer = !0, this.scheduleRender();
  }
  clear() {
    this.viewModel.clear();
  }
  close() {
    this.visible = !1;
  }
  fetchFeatures(e, t) {
    return this.viewModel.fetchFeatures(e, t);
  }
  focus() {
    const { active: e } = this.viewModel;
    e || VF.warn("Popup can only be focused when currently active."), this.visibleElements.closeButton ? this._focusClose = !0 : this._focusContainer = !0, this.scheduleRender();
  }
  next() {
    return this.viewModel.next();
  }
  open(e) {
    var t, n;
    this._handles.remove(FF);
    const r = !!e && !!e.featureMenuOpen, i = !!e && !!e.actionsMenuOpen, s = { collapsed: !!e && !!e.collapsed, actionsMenuOpen: i, featureMenuOpen: r };
    ((t = this.viewModel) == null || (n = t.view) == null ? void 0 : n.widthBreakpoint) === "xsmall" && (s.collapsed = !0), this.set(s), this.viewModel.open(e), this._shouldFocus(e), this._addSelectedFeatureIndexHandle();
  }
  previous() {
    return this.viewModel.previous();
  }
  reposition() {
    this.renderNow(), this._positionContainer(), this._setCurrentAlignment();
  }
  triggerAction(e) {
    this.viewModel.triggerAction(e);
  }
  render() {
    var e, t, n, r;
    const { actionsMenuOpen: i, dockEnabled: s, featureMenuVisible: o, dividedActions: a, currentAlignment: l, currentDockPosition: c } = this, { active: p } = this.viewModel, { menuActions: f } = a, m = p && f.length > 1 && i, y = p && s, g = p && !s, v = (e = this.selectedFeature) == null || (t = e.layer) == null ? void 0 : t.title, w = (n = this.selectedFeature) == null || (r = n.layer) == null ? void 0 : r.id, b = { [le.alignTopCenter]: l === "top-center", [le.alignBottomCenter]: l === "bottom-center", [le.alignTopLeft]: l === "top-left", [le.alignBottomLeft]: l === "bottom-left", [le.alignTopRight]: l === "top-right", [le.alignBottomRight]: l === "bottom-right", [le.isDocked]: y, [le.shadow]: g, [le.isDockedTopLeft]: c === "top-left", [le.isDockedTopCenter]: c === "top-center", [le.isDockedTopRight]: c === "top-right", [le.isDockedBottomLeft]: c === "bottom-left", [le.isDockedBottomCenter]: c === "bottom-center", [le.isDockedBottomRight]: c === "bottom-right", [le.isFeatureMenuOpen]: o, [le.isActionsMenuOpen]: m };
    return B("div", { class: this.classes(le.base, b), role: "presentation", "data-layer-title": v, "data-layer-id": w, bind: this, afterCreate: this._positionContainer, afterUpdate: this._positionContainer }, p ? [this.renderMainContainer(), this.renderPointer()] : null);
  }
  renderLoadingIcon() {
    return B("span", { "aria-hidden": "true", class: this.classes(le.icon, le.iconLoading, le.rotating) });
  }
  renderNavigationLoading() {
    const { messagesCommon: e } = this;
    return this.viewModel.pendingPromisesCount ? B("div", { key: Va("loading-container"), role: "presentation", class: le.loadingContainer, "aria-label": e.loading, title: e.loading }, this.renderLoadingIcon()) : null;
  }
  renderPreviousIcon() {
    const e = qu(this.container), t = { [le.iconRightTriangleArrow]: e, [le.paginationPreviousIconRTL]: e, [le.iconLeftTriangleArrow]: !e, [le.paginationPreviousIconLTR]: !e };
    return B("span", { "aria-hidden": "true", class: this.classes(le.icon, t) });
  }
  renderPreviousButton() {
    const { messages: e } = this;
    return B("div", { role: "button", tabIndex: 0, bind: this, onclick: this._previous, onkeydown: this._previous, class: this.classes(le.button, le.paginationPrevious), "aria-label": e.previous, title: e.previous }, this.renderPreviousIcon());
  }
  renderNextIcon() {
    const e = qu(this.container), t = { [le.iconLeftTriangleArrow]: e, [le.paginationNextIconRTL]: e, [le.iconRightTriangleArrow]: !e, [le.paginationNextIconLTR]: !e };
    return B("span", { "aria-hidden": "true", class: this.classes(le.icon, t) });
  }
  renderNextButton() {
    const { messages: e } = this;
    return B("div", { role: "button", tabIndex: 0, bind: this, onclick: this._next, onkeydown: this._next, class: this.classes(le.button, le.paginationNext), "aria-label": e.next, title: e.next }, this.renderNextIcon());
  }
  renderFeatureMenuButton() {
    const { featureMenuOpen: e, featureMenuId: t, messagesCommon: n } = this, { featureCount: r, selectedFeatureIndex: i } = this.viewModel;
    return B("div", { role: "button", tabIndex: 0, bind: this, onclick: this._toggleFeatureMenu, onkeydown: this._toggleFeatureMenu, afterCreate: this._focusFeatureMenuButtonNode, afterUpdate: this._focusFeatureMenuButtonNode, class: this.classes(le.button, le.featureMenuButton), "aria-haspopup": "true", "aria-controls": t, "aria-expanded": e.toString(), "aria-label": n.menu, title: n.menu }, this._getPageText(r, i));
  }
  renderNavigationButtons() {
    return this.featureNavigationVisible ? [this.renderPreviousButton(), this.renderNavigationLoading() || this.renderFeatureMenuButton(), this.renderNextButton()] : null;
  }
  renderDockIcon() {
    const { dockEnabled: e } = this, t = this._wouldDockTo(), n = { [le.iconUndock]: e, [le.iconDock]: !e, [le.iconDockToRight]: !e && (t === "top-right" || t === "bottom-right"), [le.iconDockToLeft]: !e && (t === "top-left" || t === "bottom-left"), [le.iconDockToTop]: !e && t === "top-center", [le.iconDockToBottom]: !e && t === "bottom-center" };
    return B("span", { "aria-hidden": "true", class: this.classes(n, le.icon) });
  }
  renderDockButton() {
    var e, t, n;
    const { dockEnabled: r, messages: i } = this, s = (e = this.viewModel) == null || (t = e.view) == null ? void 0 : t.widthBreakpoint, o = r ? i.undock : i.dock;
    return s !== "xsmall" && (n = this.dockOptions) != null && n.buttonEnabled ? B("div", { role: "button", "aria-label": o, title: o, tabIndex: 0, bind: this, onclick: this._toggleDockEnabled, onkeydown: this._toggleDockEnabled, afterCreate: this._focusDockButtonNode, afterUpdate: this._focusDockButtonNode, class: this.classes(le.button, le.buttonDock) }, this.renderDockIcon()) : null;
  }
  renderTitle() {
    const { title: e } = this.viewModel, { titleId: t, collapsible: n, contentCollapsed: r, messagesCommon: i } = this, s = { [le.headerContainerButton]: n }, o = B(ck, { level: this.headingLevel, class: le.headerTitle, innerHTML: e }), a = n ? B("button", { key: `${e}--collapsible`, id: t, title: r ? i.expand : i.collapse, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes(le.headerContainer, s), "aria-expanded": r ? "false" : "true", onclick: this._toggleCollapsed, type: "button" }, o) : B("div", { key: e, id: t, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes(le.headerContainer, s) }, o);
    return e ? a : null;
  }
  renderCloseIcon() {
    return B("span", { "aria-hidden": "true", class: this.classes(le.icon, le.iconClose) });
  }
  renderCloseButton() {
    const { visibleElements: e, messagesCommon: t } = this;
    return e.closeButton ? B("div", { role: "button", tabIndex: 0, bind: this, onclick: this._close, onkeydown: this._close, class: le.button, "aria-label": t.close, title: t.close, afterCreate: this._closeButtonNodeUpdated, afterUpdate: this._closeButtonNodeUpdated }, this.renderCloseIcon()) : null;
  }
  renderHeader() {
    return B("header", { class: le.header }, this.renderTitle(), B("div", { class: le.headerButtons }, this.renderDockButton(), this.renderCloseButton()));
  }
  renderContentContainer() {
    const { contentId: e, hasContent: t, contentCollapsed: n } = this, { content: r } = this.viewModel;
    return t && !n ? B("article", { key: r, enterAnimation: this._createFeatureUpdatedAnimation(), id: e, class: le.content }, this.renderContent()) : null;
  }
  renderActionsMenuButton() {
    const { actionsMenuId: e, actionsMenuButtonId: t, actionsMenuOpen: n, dividedActions: r, messagesCommon: i } = this, s = n ? i.close : i.open, { menuActions: o } = r;
    return o.length ? B("div", { key: Va("actions-menu-button"), class: this.classes(le.button, le.actionsMenuButton), role: "button", id: t, "aria-haspopup": "true", "aria-controls": n ? e : null, tabIndex: 0, bind: this, onclick: this._toggleActionsMenu, onkeydown: this._toggleActionsMenu, afterCreate: this._focusActionsMenuButtonNode, afterUpdate: this._focusActionsMenuButtonNode, "aria-label": s, title: s }, B("span", { "aria-hidden": "true", class: le.iconActionsMenu })) : null;
  }
  renderMenuActions() {
    const { actionsMenuId: e, actionsMenuButtonId: t, actionsMenuOpen: n, dividedActions: r } = this, { menuActions: i } = r;
    return i.length && n ? B("ul", { id: e, role: "menu", "aria-labelledby": t, key: Va("actions"), class: le.actions, bind: this, onkeyup: this._handleActionMenuKeyup, afterCreate: this._actionsMenuNodeUpdated, afterUpdate: this._actionsMenuNodeUpdated }, i.toArray().map((s) => this.renderAction({ action: s, type: "menu-item" }))) : null;
  }
  renderInlineActions() {
    const { inlineActions: e } = this.dividedActions;
    return !!e.length && e.toArray().map((t) => this.renderAction({ action: t, type: "inline" }));
  }
  renderInlineActionsContainer() {
    const { inlineActions: e, menuActions: t } = this.dividedActions, n = !!e.length, r = !!t.length;
    return n || r ? B("div", { key: "inline-actions-container", "data-inline-actions": n.toString(), "data-menu-actions": r.toString(), class: le.inlineActionsContainer }, this.renderInlineActions(), this.renderActionsMenuButton(), this.renderMenuActions()) : null;
  }
  renderNavigation() {
    return this.featureNavigationVisible ? B("section", { key: Va("navigation"), class: this.classes(le.navigation) }, this.renderNavigationButtons()) : null;
  }
  renderFooter() {
    const { featureNavigationVisible: e, dividedActions: t } = this, { inlineActions: n, menuActions: r } = t, i = !!n.length, s = !!r.length, o = { [le.footerHasPagination]: e, [le.footerHasActions]: i, [le.footerHasActionsMenu]: s };
    return e || i ? B("div", { key: Va("feature-buttons"), class: this.classes(le.footer, o) }, this.renderInlineActionsContainer(), this.renderNavigation()) : null;
  }
  renderFeatureMenuContainer() {
    const { messages: e } = this, { featureViewModels: t, isLoadingFeature: n } = this.viewModel, r = Ya(e.selectedFeatures, { total: t.length });
    return B("section", { key: Va("menu"), class: le.featureMenu }, B("strong", { class: le.featureMenuHeader }, r), B("nav", { bind: this, class: le.featureMenuViewport, "data-node-ref": "_featureMenuViewportNode", afterCreate: kE }, this.renderFeatureMenu(), B("div", { class: le.featureMenuObserver, bind: this, afterCreate: this._featureMenuIntersectionObserverCreated }), n ? B("div", { class: le.featureMenuLoader }, this.renderLoadingIcon()) : null));
  }
  renderPointer() {
    return this.dockEnabled ? null : B("div", { key: Va("pointer"), class: le.pointer, role: "presentation" }, B("div", { class: this.classes(le.pointerDirection, le.shadow) }));
  }
  renderMainContainer() {
    const { dockEnabled: e, currentAlignment: t, currentDockPosition: n, titleId: r, contentId: i, collapsible: s, hasContent: o, contentCollapsed: a, visibleElements: l } = this, { title: c } = this.viewModel, p = t === "bottom-left" || t === "bottom-center" || t === "bottom-right" || n === "top-left" || n === "top-center" || n === "top-right", f = t === "top-left" || t === "top-center" || t === "top-right" || n === "bottom-left" || n === "bottom-center" || n === "bottom-right", m = { [le.shadow]: e, [le.isCollapsible]: s, [le.isCollapsed]: a };
    return B("div", { class: this.classes(le.main, le.widget, m), tabIndex: l.closeButton ? null : -1, role: "dialog", "aria-labelledby": c ? r : "", "aria-describedby": o && !a ? i : "", bind: this, onkeyup: this._handleMainKeyup, afterCreate: this._mainContainerNodeUpdated, afterUpdate: this._mainContainerNodeUpdated }, p ? this.renderFooter() : null, p ? this.renderFeatureMenuContainer() : null, this.renderHeader(), this.renderContentContainer(), f ? this.renderFooter() : null, f ? this.renderFeatureMenuContainer() : null);
  }
  renderContent() {
    var e;
    const t = (e = this.viewModel) == null ? void 0 : e.content;
    return t ? typeof t == "string" ? B("div", { key: t, innerHTML: t }) : this.renderNodeContent(t) : null;
  }
  renderActionText(e) {
    return B("span", { key: "text", class: le.actionText }, e);
  }
  renderActionIcon(e) {
    const t = this._getActionClass(e), n = this._getActionImage(e), r = { [le.iconLoading]: e.active, [le.rotating]: e.active, [le.icon]: !!t, [le.actionImage]: !e.active && !!n };
    return t && (r[t] = !e.active), B("span", { key: "icon", "aria-hidden": "true", class: this.classes(le.icon, r), styles: this._getIconStyles(n) });
  }
  renderAction(e) {
    const { action: t, type: n } = e, r = this._getActionTitle(t), i = { [le.action]: t.type !== "toggle", [le.actionToggle]: t.type === "toggle", [le.actionToggleOn]: t.type === "toggle" && t.value, [le.buttonDisabled]: t.disabled }, s = [this.renderActionIcon(t), this.renderActionText(r)], o = n === "menu-item" ? B("li", { key: t.uid, role: "menuitem", tabIndex: 0, title: r, "aria-label": r, class: this.classes(le.button, i), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": t.uid, onclick: this._triggerAction, onkeydown: this._triggerAction }, s) : B("div", { key: t.uid, role: "button", tabIndex: 0, title: r, "aria-label": r, class: this.classes(le.button, i), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": t.uid, onclick: this._triggerAction, onkeydown: this._triggerAction }, s);
    return t.visible ? o : null;
  }
  renderFeatureMenuItem(e, t) {
    const { messages: n, messagesCommon: r } = this, { selectedFeatureIndex: i, selectedFeatureViewModel: s } = this.viewModel, o = e === s, a = { [le.featureMenuSelected]: o }, l = o ? B("span", { key: Va(`feature-menu-selected-feature-${i}`), title: n.selectedFeature, "aria-label": n.selectedFeature, class: le.iconCheckMark }) : null, c = B("span", { innerHTML: e.title || r.untitled });
    return B("li", { role: "menuitem", tabIndex: -1, key: Va(`feature-menu-feature-${i}`), class: this.classes(a, le.featureMenuItem), bind: this, "data-feature-index": t, onkeyup: this._handleFeatureMenuItemKeyup, onclick: this._selectFeature, onkeydown: this._selectFeature }, B("span", { class: le.featureMenuTitle }, c, l));
  }
  renderFeatureMenu() {
    const { featureMenuId: e } = this, { featureViewModels: t } = this.viewModel;
    return t.length > 1 ? B("ol", { class: le.featureMenuList, id: e, bind: this, afterCreate: this._featureMenuNodeUpdated, afterUpdate: this._featureMenuNodeUpdated, onkeyup: this._handleFeatureMenuKeyup, role: "menu" }, t.filter((n) => !!n.graphic).map((n, r) => this.renderFeatureMenuItem(n, r))) : null;
  }
  _getActionTitle(e) {
    const { messages: t, selectedFeature: n, messagesCommon: r } = this, { id: i } = e, s = n == null ? void 0 : n.attributes, o = i === "zoom-to-feature" ? Ya(e.title, { messages: t }) : i === "remove-selected-feature" ? Ya(e.title, { messages: r }) : i === "zoom-to-clustered-features" || i === "browse-clustered-features" ? Ya(e.title, { messages: t }) : e.title;
    return o && s ? Ya(o, s) : o;
  }
  _getActionClass(e) {
    const { selectedFeature: t } = this, n = t == null ? void 0 : t.attributes, { className: r, image: i } = e, s = i || r ? r : le.iconDefaultAction;
    return s && n ? Ya(s, n) : s;
  }
  _getActionImage(e) {
    const { selectedFeature: t } = this, n = t == null ? void 0 : t.attributes, { image: r } = e;
    return r && n ? Ya(r, n) : r;
  }
  _createFeatureUpdatedAnimation() {
    return Ire("enter", le.hasFeatureUpdated);
  }
  _getInlineActionCount() {
    const { maxInlineActions: e, featureNavigationVisible: t } = this;
    if (typeof e != "number")
      return null;
    const n = Math.round(e);
    return Math.max(t ? n - 1 : n, 0);
  }
  _watchActions() {
    const { allActions: e } = this.viewModel;
    this.notifyChange("dividedActions");
    const t = "actions";
    this._handles.remove(t), e && e.forEach((n) => {
      this._handles.add(Lt(n, ["uid", "active", "className", "disabled", "id", "title", "image", "visible"], () => this.scheduleRender()), t);
    });
  }
  _divideActions() {
    const { allActions: e } = this.viewModel, t = e.filter((s) => s.visible), n = this._getInlineActionCount(), r = n === null, i = n === 0;
    return { inlineActions: r ? t.slice(0) : i ? new Ne() : t.slice(0, n), menuActions: r ? new Ne() : i ? t.slice(0) : t.slice(n) };
  }
  _featureMenuOpenChanged(e) {
    e ? this._focusFirstFeature = !0 : this._focusFeatureMenuButton = !0;
  }
  _actionsMenuOpenChanged(e) {
    e ? this._focusFirstAction = !0 : this._focusActionsMenuButton = !0;
  }
  _setTitleFromFeatureWidget() {
    const { selectedFeatureWidget: e, messagesCommon: t } = this;
    var n, r;
    e && (this.viewModel.title = ((n = e.viewModel) == null ? void 0 : n.state) === "error" ? t.errorMessage : ((r = e.viewModel) == null ? void 0 : r.title) || "");
  }
  _setContentFromFeatureWidget() {
    const { selectedFeatureWidget: e } = this;
    e && (this.viewModel.content = e);
  }
  _unobserveFeatureMenuObserver() {
    this._featureMenuIntersectionObserverNode && this._featureMenuIntersectionObserver.unobserve(this._featureMenuIntersectionObserverNode);
  }
  _featureMenuIntersectionObserverCreated(e) {
    this._unobserveFeatureMenuObserver(), this._featureMenuIntersectionObserver.observe(e), this._featureMenuIntersectionObserverNode = e;
  }
  _handleFeatureMenuKeyup(e) {
    yd(e) === "Escape" && (e.stopPropagation(), this._focusFeatureMenuButton = !0, this.featureMenuOpen = !1, this.scheduleRender());
  }
  _handleActionMenuKeyup(e) {
    yd(e) === "Escape" && (e.stopPropagation(), this._focusActionsMenuButton = !0, this.actionsMenuOpen = !1, this.scheduleRender());
  }
  _handleFeatureMenuItemKeyup(e) {
    const t = yd(e), { _featureMenuNode: n } = this, r = e.currentTarget["data-feature-index"];
    if (!n)
      return;
    const i = n.querySelectorAll("li"), s = i.length;
    t !== "ArrowUp" ? t !== "ArrowDown" ? t !== "Home" ? t !== "End" || (e.stopPropagation(), i[i.length - 1].focus()) : (e.stopPropagation(), i[0].focus()) : (e.stopPropagation(), i[(r + 1 + s) % s].focus()) : (e.stopPropagation(), i[(r - 1 + s) % s].focus());
  }
  _handleActionMenuItemKeyup(e) {
    const t = yd(e), { _actionsMenuNode: n } = this, r = e.currentTarget.dataset.actionUid, { menuActions: i } = this.dividedActions, s = i.findIndex((l) => l.uid === r);
    if (!n)
      return;
    const o = n.querySelectorAll("li"), a = o.length;
    t !== "ArrowUp" ? t !== "ArrowDown" ? t !== "Home" ? t !== "End" || (e.stopPropagation(), o[o.length - 1].focus()) : (e.stopPropagation(), o[0].focus()) : (e.stopPropagation(), o[(s + 1 + a) % a].focus()) : (e.stopPropagation(), o[(s - 1 + a) % a].focus());
  }
  _handleMainKeyup(e) {
    const t = yd(e);
    t === "ArrowLeft" && (e.stopPropagation(), this.previous()), t === "ArrowRight" && (e.stopPropagation(), this.next());
  }
  _spinnerEnabledChange(e) {
    if (this._destroySpinner(), !e)
      return;
    const t = this.get("viewModel.view");
    this._createSpinner(t);
  }
  _hideSpinner() {
    const { _spinner: e } = this;
    e && (e.location = null, e.hide());
  }
  _displaySpinner() {
    const { _spinner: e } = this;
    if (!e)
      return;
    const { location: t, waitingForResult: n } = this.viewModel;
    n ? e.show({ location: t }) : e.hide();
  }
  _getIconStyles(e) {
    return { "background-image": e ? `url(${e})` : "" };
  }
  async _shouldFocus(e) {
    e.shouldFocus && (await mO(() => {
      var t;
      return ((t = this.viewModel) == null ? void 0 : t.active) === !0;
    }), this.focus());
  }
  _addSelectedFeatureIndexHandle() {
    const e = Lt(this, "viewModel.selectedFeatureIndex", (t, n) => this._selectedFeatureIndexUpdated(t, n));
    this._handles.add(e, FF);
  }
  _selectedFeatureIndexUpdated(e, t) {
    const { featureCount: n } = this;
    n && e !== t && e !== -1 && (this.actionsMenuOpen = !1, this.featureMenuOpen = !1);
  }
  _destroySelectedFeatureWidget() {
    const { _feature: e } = this;
    e && (e.viewModel = null, e && !e.destroyed && e.destroy()), this._feature = null;
  }
  _isScreenLocationWithinView(e, t) {
    return e.x > -1 && e.y > -1 && e.x <= t.width && e.y <= t.height;
  }
  _isOutsideView(e) {
    const { popupHeight: t, popupWidth: n, screenLocation: r, side: i, view: s } = e;
    if (isNaN(n) || isNaN(t) || !s || !r)
      return !1;
    const o = s.padding;
    return i === "right" && r.x + n / 2 > s.width - o.right || i === "left" && r.x - n / 2 < o.left || i === "top" && r.y - t < o.top || i === "bottom" && r.y + t > s.height - o.bottom;
  }
  _calculateAutoAlignment(e) {
    if (e !== "auto")
      return e;
    const { _pointerOffsetInPx: t, _containerNode: n, _mainContainerNode: r, viewModel: i } = this, { screenLocation: s, view: o } = i;
    if (H(s) || !o || !n)
      return "top-center";
    if (!this._isScreenLocationWithinView(s, o))
      return this._get("currentAlignment") || "top-center";
    function a($) {
      return parseInt($.replace(/[^-\d\.]/g, ""), 10);
    }
    const l = r ? window.getComputedStyle(r, null) : null, c = l ? a(l.getPropertyValue("max-height")) : 0, p = l ? a(l.getPropertyValue("height")) : 0, { height: f, width: m } = n.getBoundingClientRect(), y = m + t, g = Math.max(f, c, p) + t, v = this._isOutsideView({ popupHeight: g, popupWidth: y, screenLocation: s, side: "right", view: o }), w = this._isOutsideView({ popupHeight: g, popupWidth: y, screenLocation: s, side: "left", view: o }), b = this._isOutsideView({ popupHeight: g, popupWidth: y, screenLocation: s, side: "top", view: o }), S = this._isOutsideView({ popupHeight: g, popupWidth: y, screenLocation: s, side: "bottom", view: o });
    return w ? b ? "bottom-right" : "top-right" : v ? b ? "bottom-left" : "top-left" : b ? S ? "top-center" : "bottom-center" : "top-center";
  }
  _callCurrentAlignment(e) {
    return typeof e == "function" ? e.call(this) : e;
  }
  _getCurrentAlignment() {
    const { alignment: e, dockEnabled: t } = this;
    return t || !this.viewModel.active ? null : this._calculatePositionResult(this._calculateAutoAlignment(this._callCurrentAlignment(e)));
  }
  _setCurrentAlignment() {
    this._set("currentAlignment", this._getCurrentAlignment());
  }
  _setCurrentDockPosition() {
    this._set("currentDockPosition", this._getCurrentDockPosition());
  }
  _calculatePositionResult(e) {
    const t = ["left", "right"];
    return qu(this.container) && t.reverse(), e.replace(/leading/gi, t[0]).replace(/trailing/gi, t[1]);
  }
  _callDockPosition(e) {
    return typeof e == "function" ? e.call(this) : e;
  }
  _getDockPosition() {
    var e;
    return this._calculatePositionResult(this._calculateAutoDockPosition(this._callDockPosition((e = this.dockOptions) == null ? void 0 : e.position)));
  }
  _getCurrentDockPosition() {
    return this.dockEnabled && this.viewModel.active ? this._getDockPosition() : null;
  }
  _wouldDockTo() {
    return this.dockEnabled ? null : this._getDockPosition();
  }
  _calculateAutoDockPosition(e) {
    var t;
    if (e !== "auto")
      return e;
    const n = (t = this.viewModel) == null ? void 0 : t.view, r = qu(this.container) ? "top-left" : "top-right";
    if (!n)
      return r;
    const i = n.padding || { left: 0, right: 0, top: 0, bottom: 0 }, s = n.width - i.left - i.right, { breakpoints: o } = n;
    return o && s <= o.xsmall ? "bottom-center" : r;
  }
  _positionContainer(e = this._containerNode) {
    if (e && (this._containerNode = e), !e)
      return;
    const { screenLocation: t } = this.viewModel, { width: n } = e.getBoundingClientRect(), r = this._calculatePositionStyle(t, n);
    r && (e.style.top = r.top, e.style.left = r.left, e.style.bottom = r.bottom, e.style.right = r.right);
  }
  _calculateFullWidth(e) {
    const { currentAlignment: t, _pointerOffsetInPx: n } = this;
    return t === "top-left" || t === "bottom-left" || t === "top-right" || t === "bottom-right" ? e + n : e;
  }
  _calculateAlignmentPosition(e, t, n, r) {
    const { currentAlignment: i, _pointerOffsetInPx: s } = this, o = r / 2, a = n.height - t, l = n.width - e, { padding: c } = this.view;
    return i === "bottom-center" ? { top: t + s - c.top, left: e - o - c.left } : i === "top-left" ? { bottom: a + s - c.bottom, right: l + s - c.right } : i === "bottom-left" ? { top: t + s - c.top, right: l + s - c.right } : i === "top-right" ? { bottom: a + s - c.bottom, left: e + s - c.left } : i === "bottom-right" ? { top: t + s - c.top, left: e + s - c.left } : i === "top-center" ? { bottom: a + s - c.bottom, left: e - o - c.left } : void 0;
  }
  _calculatePositionStyle(e, t) {
    const { dockEnabled: n, view: r } = this;
    if (!r)
      return;
    if (n)
      return { left: "", top: "", right: "", bottom: "" };
    if (H(e) || !t)
      return;
    const i = this._calculateFullWidth(t), s = this._calculateAlignmentPosition(e.x, e.y, r, i);
    return s ? { top: s.top !== void 0 ? `${s.top}px` : "auto", left: s.left !== void 0 ? `${s.left}px` : "auto", bottom: s.bottom !== void 0 ? `${s.bottom}px` : "auto", right: s.right !== void 0 ? `${s.right}px` : "auto" } : void 0;
  }
  _viewChange(e, t) {
    e && t && (this.close(), this.clear());
  }
  _viewReadyChange(e, t) {
    if (e) {
      const n = this.get("viewModel.view");
      this._wireUpView(n);
    } else
      t && (this.close(), this.clear());
  }
  _wireUpView(e) {
    if (this._destroySpinner(), !e)
      return;
    const { spinnerEnabled: t } = this;
    t && this._createSpinner(e), this._setDockEnabledForViewSize(this.dockOptions);
  }
  _dockingThresholdCrossed(e, t, n) {
    const [r, i] = e, [s, o] = t, { width: a, height: l } = n;
    return r <= a && s > a || r > a && s <= a || i <= l && o > l || i > l && o <= l;
  }
  _updateDockEnabledForViewSize(e, t) {
    if (!e || !t)
      return;
    const n = this.get("viewModel.view.padding") || { left: 0, right: 0, top: 0, bottom: 0 }, r = n.left + n.right, i = n.top + n.bottom, s = [], o = [];
    s[0] = e[0] - r, s[1] = e[1] - i, o[0] = t[0] - r, o[1] = t[1] - i;
    const { dockOptions: a } = this, l = a.breakpoint;
    this._dockingThresholdCrossed(s, o, l) && this._setDockEnabledForViewSize(a), this._setCurrentDockPosition();
  }
  _focusDockButtonNode(e) {
    this._focusDockButton && (this._focusDockButton = !1, e.focus());
  }
  _closeButtonNodeUpdated(e) {
    return this._focusClose ? (this._focusClose = !1, void e.focus()) : this._blurClose ? (this._blurClose = !1, void e.blur()) : void 0;
  }
  _mainContainerNodeUpdated(e) {
    return this._mainContainerNode = e, this._focusContainer ? (this._focusContainer = !1, void e.focus()) : this._blurContainer ? (this._blurContainer = !1, void e.blur()) : void 0;
  }
  _featureMenuNodeUpdated(e) {
    if (this._featureMenuNode = e, !e || !this._focusFirstFeature)
      return;
    this._focusFirstFeature = !1;
    const t = e.querySelectorAll("li");
    t.length && t[0].focus();
  }
  _actionsMenuNodeUpdated(e) {
    if (this._actionsMenuNode = e, !e || !this._focusFirstAction)
      return;
    this._focusFirstAction = !1;
    const t = e.querySelectorAll("li");
    t.length && t[0].focus();
  }
  _focusFeatureMenuButtonNode(e) {
    this._focusFeatureMenuButton && (this._focusFeatureMenuButton = !1, e.focus());
  }
  _focusActionsMenuButtonNode(e) {
    this._focusActionsMenuButton && (this._focusActionsMenuButton = !1, e.focus());
  }
  _featureMenuViewportScrollTop() {
    this._featureMenuViewportNode && (this._featureMenuViewportNode.scrollTop = 0);
  }
  _toggleScreenLocationEnabled() {
    const { dockEnabled: e, viewModel: t } = this;
    if (!t)
      return;
    const n = t.active && !e;
    t.screenLocationEnabled = n;
  }
  _shouldDockAtCurrentViewSize(e) {
    var t, n;
    const r = e.breakpoint, i = (t = this.viewModel) == null || (n = t.view) == null ? void 0 : n.ui;
    if (!i)
      return !1;
    const { width: s, height: o } = i;
    if (isNaN(s) || isNaN(o))
      return !1;
    const a = r.hasOwnProperty("width") && s <= r.width, l = r.hasOwnProperty("height") && o <= r.height;
    return a || l;
  }
  _setDockEnabledForViewSize(e) {
    e.breakpoint && (this.dockEnabled = this._shouldDockAtCurrentViewSize(e));
  }
  _getPageText(e, t) {
    return this.featureNavigationVisible ? Ya(this.messages.pageText, { index: t + 1, total: e }) : null;
  }
  _destroySpinner() {
    const { _spinner: e, view: t } = this;
    e && (t && t.ui && t.ui.remove(this._spinner, NF), e.destroy(), this._spinner = null);
  }
  _createSpinner(e) {
    e && (this._spinner = new Vfe({ view: e }), e.ui.add(this._spinner, { key: NF, position: "manual" }));
  }
  _toggleCollapsed() {
    this.collapsed = !this.collapsed;
  }
  _close() {
    this.close(), this.view && this.view.focus();
  }
  _toggleDockEnabled() {
    this.dockEnabled = !this.dockEnabled, this._focusDockButton = !0, this.scheduleRender();
  }
  _toggleFeatureMenu() {
    const e = !this.featureMenuOpen;
    this._featureMenuOpenChanged(e), this.actionsMenuOpen = !1, this.featureMenuOpen = e;
  }
  _toggleActionsMenu() {
    const e = !this.actionsMenuOpen;
    this._actionsMenuOpenChanged(e), this.featureMenuOpen = !1, this.actionsMenuOpen = e;
  }
  _triggerAction(e) {
    const t = e.currentTarget.dataset.actionUid, { allActions: n } = this.viewModel, r = n.findIndex((s) => s.uid === t), i = n.getItemAt(r);
    i && i.type === "toggle" && (i.value = !i.value), this.actionsMenuOpen = !1, this.viewModel.triggerAction(r);
  }
  _selectFeature(e) {
    const t = e.currentTarget["data-feature-index"];
    isNaN(t) || (this.viewModel.selectedFeatureIndex = t), this.featureMenuOpen = !1, this._focusFeatureMenuButton = !0, this.scheduleRender();
  }
  _next() {
    this.next();
  }
  _previous() {
    this.previous();
  }
};
u([d({ readOnly: !0 })], Re.prototype, "actionsMenuId", null), u([d({ readOnly: !0 })], Re.prototype, "actionsMenuButtonId", null), u([d({ readOnly: !0 })], Re.prototype, "featureMenuId", null), u([d({ readOnly: !0 })], Re.prototype, "titleId", null), u([d({ readOnly: !0 })], Re.prototype, "contentId", null), u([d({ readOnly: !0 })], Re.prototype, "hasContent", null), u([d({ readOnly: !0 })], Re.prototype, "featureNavigationVisible", null), u([d({ readOnly: !0 })], Re.prototype, "collapsible", null), u([d({ readOnly: !0 })], Re.prototype, "featureMenuVisible", null), u([d({ readOnly: !0 })], Re.prototype, "contentCollapsed", null), u([d({ readOnly: !0 })], Re.prototype, "dividedActions", null), u([Le("viewModel.actions")], Re.prototype, "actions", void 0), u([d()], Re.prototype, "actionsMenuOpen", null), u([d()], Re.prototype, "alignment", void 0), u([Le("viewModel.autoCloseEnabled")], Re.prototype, "autoCloseEnabled", void 0), u([Le("viewModel.autoOpenEnabled")], Re.prototype, "autoOpenEnabled", void 0), u([Le("viewModel.defaultPopupTemplateEnabled")], Re.prototype, "defaultPopupTemplateEnabled", void 0), u([Le("viewModel.content")], Re.prototype, "content", void 0), u([d()], Re.prototype, "collapsed", void 0), u([d()], Re.prototype, "collapseEnabled", void 0), u([d({ readOnly: !0 })], Re.prototype, "currentAlignment", null), u([d({ readOnly: !0 })], Re.prototype, "currentDockPosition", null), u([d()], Re.prototype, "dockOptions", null), u([d()], Re.prototype, "dockEnabled", void 0), u([Le("viewModel.featureCount")], Re.prototype, "featureCount", void 0), u([d()], Re.prototype, "featureMenuOpen", void 0), u([Le("viewModel.features")], Re.prototype, "features", void 0), u([Le("viewModel.goToOverride")], Re.prototype, "goToOverride", void 0), u([d()], Re.prototype, "headingLevel", void 0), u([Le("viewModel.highlightEnabled")], Re.prototype, "highlightEnabled", void 0), u([Le("viewModel.location")], Re.prototype, "location", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], Re.prototype, "label", void 0), u([d()], Re.prototype, "maxInlineActions", void 0), u([d(), Si("geoscene/widgets/Popup/t9n/Popup")], Re.prototype, "messages", void 0), u([d(), Si("geoscene/t9n/common")], Re.prototype, "messagesCommon", void 0), u([Le("viewModel.promises")], Re.prototype, "promises", void 0), u([Le("viewModel.selectedFeature")], Re.prototype, "selectedFeature", void 0), u([Le("viewModel.selectedFeatureIndex")], Re.prototype, "selectedFeatureIndex", void 0), u([d({ readOnly: !0 })], Re.prototype, "selectedFeatureWidget", null), u([d()], Re.prototype, "spinnerEnabled", void 0), u([Le("viewModel.title")], Re.prototype, "title", void 0), u([Le("viewModel.updateLocationEnabled")], Re.prototype, "updateLocationEnabled", void 0), u([Le("viewModel.view")], Re.prototype, "view", void 0), u([d({ type: AB }), Yse(["triggerAction", "trigger-action"])], Re.prototype, "viewModel", void 0), u([Le("viewModel.visible")], Re.prototype, "visible", void 0), u([d()], Re.prototype, "visibleElements", void 0), u([mt("visibleElements")], Re.prototype, "castVisibleElements", null), u([Cs()], Re.prototype, "_close", null), u([Cs()], Re.prototype, "_toggleDockEnabled", null), u([Cs()], Re.prototype, "_toggleFeatureMenu", null), u([Cs()], Re.prototype, "_toggleActionsMenu", null), u([Cs()], Re.prototype, "_triggerAction", null), u([Cs()], Re.prototype, "_selectFeature", null), u([Cs()], Re.prototype, "_next", null), u([Cs()], Re.prototype, "_previous", null), Re = u([T(PB)], Re);
const BF = Re, Rx = [0, 0];
function Sme(e) {
  const t = (e.ownerDocument || window.document).defaultView, n = e.getBoundingClientRect();
  return Rx[0] = n.left + t.pageXOffset, Rx[1] = n.top + t.pageYOffset, Rx;
}
function UF(e) {
  e && (e9(e), e.parentNode && e.parentNode.removeChild(e));
}
function xme(e) {
  const t = document.createElement("div");
  return e.appendChild(t), t;
}
const Lm = 16, Uv = 750, $me = 512, Tme = 2, Eme = (e) => {
  let t = class extends e {
    constructor(...n) {
      super(...n), this._freqInfo = { freq: Lm, time: Uv }, this._overlayRenderTaskHandle = null, this.height = 0, this.position = null, this.resizing = !1, this.root = null, this.surface = null, this.suspended = !0, this.ui = null, this.userContent = null, this.width = 0, this.widthBreakpoint = null, this.handles.add([this.watch("cursor", (r) => {
        const i = this.surface;
        i && i.setAttribute("data-cursor", r);
      }), this.watch("interacting", (r) => {
        const i = this.surface;
        i && i.setAttribute("data-interacting", r.toString());
      })]);
    }
    initialize() {
      this.handles.add(this.watch("ui", (n, r) => this._handleUIChange(n, r))), this._wireUI(this.ui), this.handles.add([this.on("focus", () => this.notifyChange("focused")), this.on("blur", () => this.notifyChange("focused"))]);
    }
    destroy() {
      this.destroyed || (this.ui && (this.ui.destroy(), this.ui = null), this.popup && !this.popup.destroyed && this.popup.destroy(), this.container = null);
    }
    set container(n) {
      const r = this._get("container");
      if (r === n)
        return;
      const i = "dom-size";
      if (this.handles.remove(i), this._stopMeasuring(), r && (r.classList.remove("geoscene-view"), this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null), this.overlay.destroy(), this._set("overlay", null), UF(this.root), this._set("root", null), tR(this.userContent, r), UF(this.userContent), this._set("userContent", null)), n) {
        n.classList.add("geoscene-view");
        const s = document.createElement("div");
        s.className = "geoscene-view-user-storage", tR(n, s), n.appendChild(s), this._set("userContent", s);
        const o = document.createElement("div");
        o.className = "geoscene-view-root", n.insertBefore(o, n.firstChild), this._set("root", o);
        const a = document.createElement("div");
        a.className = "geoscene-view-surface", a.setAttribute("role", "application"), a.tabIndex = 0, o.appendChild(a), this._set("surface", a);
        const l = new pR();
        o.appendChild(l.surface), this._set("overlay", l), l.watch("needsRender", (c) => {
          c && !this._overlayRenderTaskHandle ? this._overlayRenderTaskHandle = df({ render: () => {
            this.overlay.render();
          } }) : this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null);
        }), this.forceDOMReadyCycle(), this.handles.add(Nt(() => this.size, (c) => {
          const [p, f] = c, m = "geoscene-view-surface--inset-outline";
          p >= document.body.clientWidth || f >= document.body.clientHeight ? a.classList.add(m) : a.classList.remove(m);
        }, va), i), this._set("container", n), this._startMeasuring();
      } else
        this._set("width", 0), this._set("height", 0), this._set("position", null), this._set("suspended", !0), this._set("surface", null), this._set("container", null);
    }
    get focused() {
      const n = document.activeElement === this.surface;
      return document.hasFocus() && n;
    }
    get popup() {
      return this._get("popup") || new BF({ view: this });
    }
    set popup(n) {
      const r = this._get("popup");
      r && r !== n && r.destroy(), this._set("popup", n);
    }
    get size() {
      return [this.width, this.height];
    }
    blur() {
      this.surface && this.surface.blur();
    }
    focus() {
      this.surface && this.surface.focus();
    }
    pageToContainer(n, r, i) {
      const s = this.position;
      return n -= s[0], r -= s[1], i ? (i[0] = n, i[1] = r) : i = [n, r], i;
    }
    containerToPage(n, r, i) {
      const s = this.position;
      return n += s[0], r += s[1], i ? (i[0] = n, i[1] = r) : i = [n, r], i;
    }
    _handleUIChange(n, r) {
      r && (this.handles.remove("ui"), r.destroy()), n && this._wireUI(n), this._set("ui", n);
    }
    _wireUI(n) {
      this.handles.remove("ui"), n && (n.view = this, this.handles.add([Nt(() => this.root, (r) => {
        n.container = r ? xme(r) : null;
      }, va), Nt(() => this.popup, (r, i) => {
        const s = "popup", o = "manual";
        i && n.remove(i, s), r && (r.view = n.view, n.add(r, { key: s, position: o }));
      }, va)], "ui"));
    }
    _stopMeasuring() {
      this.handles.remove("measuring"), this._get("resizing") && this._set("resizing", !1);
    }
    _startMeasuring() {
      const n = this._freqInfo;
      n.freq = Lm, n.time = Uv, this.handles.add([(() => {
        const r = () => {
          n.freq = Lm, n.time = Uv;
        };
        return window.addEventListener("resize", r), { remove() {
          window.removeEventListener("resize", r);
        } };
      })(), df({ prepare: (r) => {
        const i = this._measure(), s = this._freqInfo;
        if (s.time += r.deltaTime, i && (s.freq = Lm, this._get("resizing") || this._set("resizing", !0)), s.time < s.freq)
          return;
        s.time = 0;
        const o = this._position();
        s.freq = o || i ? Lm : Math.min(Uv, s.freq * Tme), !i && s.freq >= $me && this._get("resizing") && this._set("resizing", !1);
      } })], "measuring"), this._measure(), this._position();
    }
    _measure() {
      const n = this.container, r = n ? n.clientWidth : 0, i = n ? n.clientHeight : 0;
      if (r === 0 || i === 0)
        return this.suspended || this._set("suspended", !0), !1;
      const s = this.width, o = this.height;
      return r === s && i === o ? (this.suspended && this._set("suspended", !1), !1) : (this._set("width", r), this._set("height", i), this.suspended && this._set("suspended", !1), this.emit("resize", { oldWidth: s, oldHeight: o, width: r, height: i }), !0);
    }
    _position() {
      const n = this.container, r = this.position, i = Sme(n);
      return (!r || i[0] !== r[0] || i[1] !== r[1]) && (this._set("position", [i[0], i[1]]), !0);
    }
    forceDOMReadyCycle() {
    }
  };
  return u([d({ value: null, cast: (n) => KO(n) })], t.prototype, "container", null), u([d({ readOnly: !0 })], t.prototype, "focused", null), u([d({ readOnly: !0 })], t.prototype, "height", void 0), u([d({ type: BF })], t.prototype, "popup", null), u([d({ type: pR })], t.prototype, "overlay", void 0), u([d({ readOnly: !0 })], t.prototype, "position", void 0), u([d({ readOnly: !0 })], t.prototype, "resizing", void 0), u([d({ readOnly: !0 })], t.prototype, "root", void 0), u([d({ value: null, readOnly: !0 })], t.prototype, "size", null), u([d({ readOnly: !0 })], t.prototype, "surface", void 0), u([d({ readOnly: !0 })], t.prototype, "suspended", void 0), u([d()], t.prototype, "ui", void 0), u([d({ readOnly: !0 })], t.prototype, "userContent", void 0), u([d({ readOnly: !0 })], t.prototype, "width", void 0), u([d()], t.prototype, "widthBreakpoint", void 0), t = u([T("geoscene.views.DOMContainer")], t), t;
}, Ime = (e) => {
  let t = class extends e {
    async fetchPopupFeatures(n, r) {
      await this.when();
      const { location: i, queryArea: s, layerViewsAndGraphics: o, clientOnlyGraphics: a } = await this._prepareFetchPopupFeatures(n, r), l = Promise.resolve(a), c = this._queryLayerPopupFeatures(s, o, r), p = c.map((f) => f.promise);
      return { location: i, clientOnlyGraphics: a, allGraphicsPromise: WJ([l, ...p]).then((f) => Array.from(new Set(f.flat()))), promisesPerLayerView: c };
    }
    _queryLayerPopupFeatures(n, r, i) {
      return r.map(({ layerView: s, graphics: o }) => {
        const a = { clientGraphics: o, event: O(i) ? i.event : null, signal: O(i) ? i.signal : null, defaultPopupTemplateEnabled: !!O(i) && !!i.defaultPopupTemplateEnabled }, l = s.fetchPopupFeatures(n, a);
        return { layerView: s, promise: l };
      });
    }
    _isValidPopupGraphic(n, r) {
      return n && !!n.getEffectivePopupTemplate(O(r) && r.defaultPopupTemplateEnabled);
    }
    async _prepareFetchPopupFeatures(n, r) {
      const { clientGraphics: i, queryArea: s, location: o } = await this._popupHitTestGraphics(n, r), a = this._getFetchPopupLayerViews(), { layerViewsAndGraphics: l, clientOnlyGraphics: c } = this._graphicsPerFetchPopupLayerView(i, a);
      return { clientOnlyGraphics: c, layerViewsAndGraphics: l, queryArea: s, location: o };
    }
    async _popupHitTestGraphics(n, r) {
      const { results: i, mapPoint: s } = await this.popupHitTest(n), o = i.filter((l) => this._isValidPopupGraphic(l.graphic, r)), a = o.length ? o[0].mapPoint : null;
      return { clientGraphics: o.map((l) => l.graphic), queryArea: s, location: s || a };
    }
    _getFetchPopupLayerViews() {
      const n = [];
      return this.allLayerViews.forEach((r) => {
        this._isValidPopupLayerView(r) && n.push(r);
      }), O(this.graphicsView) && this._isValidPopupLayerView(this.graphicsView) && n.push(this.graphicsView), n.reverse();
    }
    _isValidPopupLayerView(n) {
      return O(n) && (!("layer" in n) || !n.suspended) && "fetchPopupFeatures" in n;
    }
    _graphicsPerFetchPopupLayerView(n, r) {
      const i = [], s = /* @__PURE__ */ new Map(), o = r.map((a) => {
        const l = [];
        return "layer" in a ? s.set(a.layer, l) : s.set(a.graphics, l), { layerView: a, graphics: l };
      });
      for (const a of n) {
        const l = s.get(a.layer) || s.get(a.sourceLayer) || null;
        l ? l.push(a) : i.push(a);
      }
      return { layerViewsAndGraphics: o, clientOnlyGraphics: i };
    }
  };
  return t = u([T("geoscene.views.PopupView")], t), t;
};
we.getLogger("geoscene.core.support.OwningCollection");
let hg = class extends $p(Ne) {
  constructor(t) {
    super(t), this.handles.add([this.on("before-add", (n) => {
      H(n.item) && n.preventDefault();
    }), this.on("after-add", (n) => this._own(n.item)), this.on("after-remove", (n) => this._release(n.item))]);
  }
  get owner() {
    return this._get("owner");
  }
  set owner(t) {
    t !== this._get("owner") && (this._releaseAll(), this._set("owner", t), this._ownAll());
  }
  _ownAll() {
    for (const t of this.items)
      this._own(t);
  }
  _releaseAll() {
    for (const t of this.items)
      this._release(t);
  }
  _createNewInstance(t) {
    return this.itemType ? new (Ne.ofType(this.itemType.Type))(t) : new Ne(t);
  }
};
function CM(e, t) {
  return { type: e, cast: T8, set(n) {
    const r = Xd(n, this._get(t), e);
    r.owner = this, this._set(t, r);
  } };
}
u([d()], hg.prototype, "owner", null), hg = u([T("geoscene.core.support.OwningCollection")], hg);
const Mme = we.getLogger("geoscene.support.AnalysesCollection");
let a_ = class extends hg {
  constructor(t) {
    super(t), this.handles.add(this.on("before-add", (n) => {
      H(n.item) || n.item.parent === this.owner && (Mme.warn("Analysis inside the collection must be unique. Not adding this element again."), n.preventDefault());
    }));
  }
  _own(t) {
    t.parent = this.owner;
  }
  _release(t) {
    t.parent = null;
  }
};
a_ = u([T("geoscene.support.AnalysesCollection")], a_);
let Hd = class extends hg {
  _own(t) {
    t.layer && "remove" in t.layer && t.layer !== this.owner && t.layer.remove(t), t.layer = this.owner;
  }
  _release(t) {
    t.layer === this.owner && (t.layer = null);
  }
};
u([QC({ Type: Jt, ensureType: kn(Jt) })], Hd.prototype, "itemType", void 0), Hd = u([T("geoscene.support.GraphicsCollection")], Hd);
let Su = class extends ke {
  constructor(t) {
    super(t), this.view = null, this.baseLayerViews = new Ne(), this.referenceLayerViews = new Ne(), this._loadingHandle = gn(this, "view.map.basemap", (n) => {
      n && n.load().catch(() => {
      });
    });
  }
  destroy() {
    this._set("view", null), this._loadingHandle && (this._loadingHandle.remove(), this._loadingHandle = null);
  }
  get suspended() {
    return !this.view || this.view.suspended;
  }
  get updating() {
    var t, n;
    if (this.view && this.view.suspended)
      return !1;
    const r = (t = this.view) == null || (n = t.map) == null ? void 0 : n.basemap;
    return !!r && !!r.loaded && (this.baseLayerViews.some((i) => i.updating) || this.referenceLayerViews.some((i) => i.updating));
  }
};
u([d({ constructOnly: !0 })], Su.prototype, "view", void 0), u([d({ readOnly: !0 })], Su.prototype, "baseLayerViews", void 0), u([d({ readOnly: !0 })], Su.prototype, "referenceLayerViews", void 0), u([d({ readOnly: !0 })], Su.prototype, "suspended", null), u([d({ type: Boolean, readOnly: !0 })], Su.prototype, "updating", null), Su = u([T("geoscene.views.BasemapView")], Su);
const Cme = we.getLogger("geoscene.views.LayerViewManager");
let Ome = class {
  constructor(t, n, r) {
    this.layer = t, this.view = n, this.layerViewImporter = r, this._controller = new AbortController(), this._deferred = Cl(), this._started = !1, this.done = !1, Ao(this._controller.signal, () => {
      const i = new D("cancelled:layerview-create", "layerview creation cancelled", { layer: t });
      this._deferred.reject(i);
    });
  }
  get promise() {
    return this._deferred.promise;
  }
  destroy() {
    this._controller.abort();
    const { layerView: t } = this;
    if (!t)
      return;
    const { layer: n, view: r } = this;
    n.emit("layerview-destroy", { view: r, layerView: t }), r.emit("layerview-destroy", { layer: n, layerView: t }), this.done = !0, this.layer = null, this.layerView = null, this.view = null, this.layerViewImporter = null;
  }
  async start() {
    if (this._started)
      return;
    this._started = !0;
    const { _controller: { signal: t }, layer: n, view: r } = this;
    this._map = r.map;
    try {
      var i, s;
      let o, a;
      if (await n.load({ signal: t }), "prefetchResources" in n && await n.prefetchResources({ signal: t }), n.createLayerView)
        o = await n.createLayerView(r, { signal: t });
      else {
        if (!this.layerViewImporter.hasLayerViewModule(n))
          throw new D("layer:view-not-supported", "No layerview implementation was found");
        const c = await this.layerViewImporter.importLayerView(n);
        On(t), o = "default" in c ? new c.default({ layer: n, view: r }) : new c({ layer: n, view: r });
      }
      const l = () => {
        a = Sp(a), o.destroyed || o.destroy(), o.layer = null, o.parent = null, o.view = null, this.done = !0;
      };
      a = Ao(t, l), On(t);
      try {
        await o.when();
      } catch (c) {
        throw l(), c;
      }
      if (!(!((i = this._map) == null || (s = i.allLayers) == null) && s.includes(n)))
        return l(), void this._deferred.reject(new D("view:no-layerview-for-layer", "The layer has been removed from the map", { layer: n }));
      this.layerView = o, n.emit("layerview-create", { view: r, layerView: o }), r.emit("layerview-create", { layer: n, layerView: o }), this.done = !0, this._deferred.resolve(o);
    } catch (o) {
      n.emit("layerview-create-error", { view: r, error: o }), r.emit("layerview-create-error", { layer: n, error: o }), this.done = !0, this._deferred.reject(new D("layerview:create-error", "layerview creation failed", { layer: n, error: o }));
    }
  }
}, Es = class extends hf {
  constructor(t) {
    super(t), this._layerLayerViewInfoMap = /* @__PURE__ */ new Map(), this._watchUpdatingTracking = new ef(), this.supportsGround = !0, this._preloadLayerViewModules = () => {
      var n;
      const r = (n = this.view.map) == null ? void 0 : n.allLayers;
      if (r)
        for (const i of r)
          this.layerViewImporter.hasLayerViewModule(i) && this.layerViewImporter.importLayerView(i);
    }, this._reschedule = () => (H(this._workPromise) && (this._workPromise = Cl()), this.handles.remove("reschedule"), this.handles.add(g0(this._doWork), "reschedule"), this._workPromise.promise), this._doWork = () => {
      var n, r, i;
      const s = this.view.map;
      if (this._map !== s && (this.clear(), this._map = s), H(this._workPromise))
        return void this.notifyChange("updating");
      this.handles.remove("reschedule"), this.handles.remove("collection-change");
      const o = new tf({ getCollections: () => this._rootCollectionNames.map((c) => this.get(c)), getChildrenFunction: (c) => c && "layers" in c ? c.layers : null });
      if (!o)
        return this._workPromise.resolve(), void (this._workPromise = null);
      for (const c of o)
        this._createLayerView(c);
      this._refreshCollections();
      for (const [c, p] of this._layerLayerViewInfoMap)
        o.includes(c) || (this._layerLayerViewInfoMap.delete(p.layer), p.destroy());
      const a = o.filter((c) => c.type === "group").map((c) => c.layers), l = [s == null || (n = s.ground) == null ? void 0 : n.layers, s == null || (r = s.basemap) == null ? void 0 : r.baseLayers, s == null || (i = s.basemap) == null ? void 0 : i.referenceLayers, s == null ? void 0 : s.layers, ...a].filter((c) => !!c);
      this.handles.add(l.map((c) => this._watchUpdatingTracking.addOnCollectionChange(() => c, this._reschedule)), "collection-change"), this._workPromise.resolve(), this._workPromise = null;
    };
  }
  initialize() {
    this.handles.add([iT(() => {
      var t, n;
      return (t = this.view) == null || (n = t.map) == null ? void 0 : n.allLayers;
    }, "change", this._preloadLayerViewModules, { onListenerAdd: this._preloadLayerViewModules }), Nt(() => {
      const t = this.view, n = t == null ? void 0 : t.map;
      return [n == null ? void 0 : n.basemap, n == null ? void 0 : n.ground, n == null ? void 0 : n.layers, t == null ? void 0 : t.ready];
    }, () => this._reschedule(), Rc)]), this._preloadLayerViewModules(), this._reschedule();
  }
  destroy() {
    this.clear(), this._watchUpdatingTracking.destroy(), this._map = null;
  }
  get _layersToLayerViews() {
    const t = [["view.map.basemap.baseLayers", "view.basemapView.baseLayerViews"], ["view.map.layers", "view.layerViews"], ["view.map.basemap.referenceLayers", "view.basemapView.referenceLayerViews"]];
    return this.supportsGround && t.push(["view.map.ground.layers", "view.groundView.layerViews"]), new Map(t);
  }
  get _rootCollectionNames() {
    return Array.from(this._layersToLayerViews.keys());
  }
  get updating() {
    return O(this._workPromise) || this._watchUpdatingTracking.updating || H_(this._layerLayerViewInfoMap, (t) => !t.done);
  }
  get updatingRemaining() {
    let t = 0;
    for (const n of this._layerLayerViewInfoMap.values())
      n.done || ++t;
    return t;
  }
  clear() {
    if (!this.destroyed) {
      for (const t of this._layerLayerViewInfoMap.values())
        t.destroy();
      this._layerLayerViewInfoMap.clear(), this._refreshCollections();
    }
  }
  async whenLayerView(t) {
    if (await this._reschedule(), !this._layerLayerViewInfoMap.has(t))
      throw new D("view:no-layerview-for-layer", "No layerview has been found for the layer", { layer: t });
    return this._layerLayerViewInfoMap.get(t).promise;
  }
  _refreshCollections() {
    for (const [t, n] of this._layersToLayerViews)
      this._populateLayerViewsOwners(this.get(t), this.get(n), this.view);
    this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  _populateLayerViewsOwners(t, n, r) {
    if (!t || !n)
      return void (n && n.removeAll());
    let i = 0;
    for (const s of t) {
      const o = this._layerLayerViewInfoMap.get(s);
      if (!o || !o.layerView)
        continue;
      const a = o.layerView;
      a.layer = s, a.parent = r, n.getItemAt(i) !== a && n.splice(i, 0, a), s.layers && this._populateLayerViewsOwners(s.layers, a.layerViews, a), i += 1;
    }
    i < n.length && n.splice(i, n.length);
  }
  _createLayerView(t) {
    if (this._layerLayerViewInfoMap.has(t))
      return this.view.ready && this._layerLayerViewInfoMap.get(t).start(), this.notifyChange("updating"), void this.notifyChange("updatingRemaining");
    t.load().catch(() => {
    }), this.layerViewImporter.hasLayerViewModule(t) && this.layerViewImporter.importLayerView(t);
    const n = new Ome(t, this.view, this.layerViewImporter);
    n.promise.then(() => this._refreshCollections(), (r) => {
      var i, s;
      r && (Ws(r) || r.name === "cancelled:layerview-create") || Cme.error(`Failed to create layerview for layer title:'${(i = t.title) != null ? i : "no title"}', id:'${(s = t.id) != null ? s : "no id"}' of type '${t.type}'.`, { layer: t, error: r }), this._refreshCollections();
    }), this._layerLayerViewInfoMap.set(t, n), this.view.ready && n.start(), this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
};
u([d()], Es.prototype, "_workPromise", void 0), u([d({ readOnly: !0 })], Es.prototype, "_watchUpdatingTracking", void 0), u([d({ readOnly: !0 })], Es.prototype, "_layersToLayerViews", null), u([d({ readOnly: !0 })], Es.prototype, "_rootCollectionNames", null), u([d()], Es.prototype, "layerViewImporter", void 0), u([d()], Es.prototype, "supportsGround", void 0), u([d({ readOnly: !0 })], Es.prototype, "updating", null), u([d({ readOnly: !0 })], Es.prototype, "updatingRemaining", null), u([d({ constructOnly: !0 })], Es.prototype, "view", void 0), Es = u([T("geoscene.views.LayerViewManager")], Es);
const kme = Es;
let zi = class extends ke {
  constructor(t) {
    super(t), this.factor = 1.5, this.offset = wi(0, 0), this.position = null, this.size = 120, this.maskUrl = null, this.maskEnabled = !0, this.overlayUrl = null, this.overlayEnabled = !0, this.visible = !0;
  }
  get version() {
    return this.commitProperty("factor"), this.commitProperty("offset"), this.commitProperty("position"), this.commitProperty("visible"), this.commitProperty("size"), this.commitProperty("maskUrl"), this.commitProperty("maskEnabled"), this.commitProperty("overlayUrl"), this.commitProperty("overlayEnabled"), (this._get("version") || 0) + 1;
  }
};
u([d({ type: Number })], zi.prototype, "factor", void 0), u([d({ nonNullable: !0 })], zi.prototype, "offset", void 0), u([d()], zi.prototype, "position", void 0), u([d({ type: Number, range: { min: 0 } })], zi.prototype, "size", void 0), u([d()], zi.prototype, "maskUrl", void 0), u([d()], zi.prototype, "maskEnabled", void 0), u([d()], zi.prototype, "overlayUrl", void 0), u([d()], zi.prototype, "overlayEnabled", void 0), u([d({ readOnly: !0 })], zi.prototype, "version", null), u([d({ type: Boolean })], zi.prototype, "visible", void 0), zi = u([T("geoscene.views.Magnifier")], zi);
const RB = zi;
let Mw = class extends ke {
  constructor() {
    super(...arguments), this._tasks = new Array(), this.running = !1;
  }
  get length() {
    return this._tasks.length;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(t) {
    for (; !t.done && this._process(t); )
      t.madeProgress();
  }
  push(t, n, r) {
    return this.running = !0, new Promise((i, s) => this._tasks.push(new qF(i, s, t, n, r)));
  }
  unshift(t, n, r) {
    return this.running = !0, new Promise((i, s) => this._tasks.unshift(new qF(i, s, t, n, r)));
  }
  _process(t) {
    if (this._tasks.length === 0)
      return !1;
    const n = this._tasks.shift();
    try {
      const r = Ea(n.signal);
      if (r && !n.abortCallback)
        n.reject(Cn());
      else {
        const i = r ? n.abortCallback(Cn()) : n.callback(t);
        Fl(i) ? i.then(n.resolve, n.reject) : n.resolve(i);
      }
    } catch (r) {
      n.reject(r);
    }
    return this.running = this._tasks.length > 0, !0;
  }
  cancelAll() {
    const t = Cn();
    for (const n of this._tasks)
      if (n.abortCallback) {
        const r = n.abortCallback(t);
        n.resolve(r);
      } else
        n.reject(t);
    this._tasks.length = 0, this.running = !1;
  }
};
u([d()], Mw.prototype, "running", void 0), Mw = u([T("geoscene.layers.support.PromiseQueue")], Mw);
let qF = class {
  constructor(t, n, r, i, s) {
    this.resolve = t, this.reject = n, this.callback = r, this.signal = i, this.abortCallback = s;
  }
}, Dy = class extends ke {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = !1, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = !1;
  }
};
u([d()], Dy.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), u([d()], Dy.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), Dy = u([T("geoscene.views.support.DebugFlags")], Dy);
const Ame = new Dy(), Pme = we.getLogger("geoscene.views.support.Scheduler");
var dt;
(function(e) {
  e.RESOURCE_CONTROLLER = "schedule", e.SLIDE = "slide", e.STREAM_DATA_LOADER = "stream loader", e.ELEVATION_QUERY = "elevation query", e.TERRAIN_SURFACE = "terrain", e.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e.GRAPHICS_CORE = "Graphics3D", e.I3S_CONTROLLER = "I3S", e.POINT_CLOUD_LAYER = "point cloud", e.FEATURE_TILE_FETCHER = "feature fetcher", e.OVERLAY = "overlay", e.STAGE = "stage", e.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e.FILTER_VISIBILITY = "Graphics3D filter visibility", e.SCALE_VISIBILITY = "Graphics3D scale visibility", e.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e.POINT_OF_INTEREST_FREQUENT = "POI frequent", e.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e.LABELER = "labeler", e.FEATURE_QUERY_ENGINE = "feature query", e.FEATURE_TILE_TREE = "feature tile tree", e.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e.ELEVATION_ALIGNMENT = "elevation alignment", e.TEXT_TEXTURE_ATLAS = "text texture atlas", e.TEXTURE_UNLOAD = "texture unload", e.LINE_OF_SIGHT_TOOL = "line of sight tool", e.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e.ELEVATION_PROFILE = "elevation profile", e.SNAPPING = "snapping", e.SHADOW_ACCUMULATOR = "shadow accumulator", e.CLOUDS_GENERATOR = "cloud generator", e[e.TEST_PRIO = 1] = "TEST_PRIO";
})(dt || (dt = {}));
const da = 0, GF = /* @__PURE__ */ new Map([[dt.RESOURCE_CONTROLLER, da], [dt.SLIDE, da], [dt.STREAM_DATA_LOADER, da], [dt.ELEVATION_QUERY, da], [dt.TERRAIN_SURFACE, 1], [dt.SURFACE_GEOMETRY_UPDATES, 1], [dt.GRAPHICS_CORE, 2], [dt.I3S_CONTROLLER, 2], [dt.POINT_CLOUD_LAYER, 2], [dt.FEATURE_TILE_FETCHER, 2], [dt.OVERLAY, 4], [dt.STAGE, 4], [dt.GRAPHICS_DECONFLICTOR, 4], [dt.FILTER_VISIBILITY, 4], [dt.SCALE_VISIBILITY, 4], [dt.FRUSTUM_VISIBILITY, 4], [dt.POINT_OF_INTEREST_FREQUENT, 6], [dt.POINT_OF_INTEREST_INFREQUENT, 30], [dt.LABELER, 8], [dt.FEATURE_QUERY_ENGINE, 8], [dt.FEATURE_TILE_TREE, 16], [dt.FEATURE_TILE_TREE_ACTIVE, da], [dt.ELEVATION_ALIGNMENT, 12], [dt.TEXT_TEXTURE_ATLAS, 12], [dt.CLOUDS_GENERATOR, 12], [dt.TEXTURE_UNLOAD, 12], [dt.LINE_OF_SIGHT_TOOL, 16], [dt.LINE_OF_SIGHT_TOOL_INTERACTIVE, da], [dt.SNAPPING, da], [dt.SHADOW_ACCUMULATOR, 30]]);
function WF(e) {
  return GF.has(e) ? GF.get(e) : typeof e == "number" ? e : 1;
}
var qi;
(function(e) {
  e[e.ANIMATING = 0] = "ANIMATING", e[e.INTERACTING = 1] = "INTERACTING", e[e.IDLE = 2] = "IDLE";
})(qi || (qi = {}));
const HF = 6.5, JF = 1, Rme = 30, ZF = 1e3 / 30, KF = 100, YF = 0.9;
var OM, Ec;
(function(e) {
  let t = class extends ke {
    constructor(i) {
      super(i), this.updating = !0, this._microTaskQueued = !1, this.performanceInfo = { total: new Hy("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = null, this._state = qi.INTERACTING, this._tasks = new zd(), this._runQueue = new zd(), this._load = 0, this._idleStateCallbacks = new zd(), this._idleUpdatesStartFired = !1, this._maxReschedule = qv, this._forceTask = !1, this._debug = !1, this._debugHandle = Nt(() => Ame.SCHEDULER_LOG_SLOW_TASKS, (a) => this._debug = a, va), this._budget = new r(i.nowFunc);
      for (const a of Object.keys(dt))
        this.performanceInfo.tasks.set(dt[a], new Hy(dt[a]));
      let s;
      const o = this;
      this._test = { get state() {
        return BC(s, o._state);
      }, set state(a) {
        s = a;
      }, FRAME_SAFETY_BUDGET: HF, INTERACTING_BUDGET: ZF, IDLE_BUDGET: KF, get budget() {
        return o._budget.budget;
      }, usedBudget: 0, setBudget: (a) => o._budget = a, updateTask: (a) => this._updateTask(a), getState: (a) => this._getState(a), getRuntime: (a) => this._getRuntime(a), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    destroy() {
      this._tasks.toArray().forEach((i) => i.remove()), this._tasks.clear(), Sp(this._debugHandle), this._microTaskQueued = !1, this.updating = !1;
    }
    activate() {
      this._budget.done || this._microTaskQueued || (this._microTaskQueued = !0, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = !1, this._budget.done || (this._maxReschedule = qv, this._schedule(), this.frame()));
      }));
    }
    registerTask(i, s) {
      const o = WF(i), a = new n(this, i, s, o);
      return this._tasks.push(a), this.performanceInfo.tasks.has(i) || this.performanceInfo.tasks.set(i, new Hy(i)), a;
    }
    registerIdleStateCallbacks(i, s) {
      const o = { idleBegin: i, idleEnd: s };
      this._idleStateCallbacks.push(o), this.state === qi.IDLE && this._idleUpdatesStartFired && o.idleBegin();
      const a = this;
      return { remove: () => this._removeIdleStateCallbacks(o), set idleBegin(l) {
        a._idleUpdatesStartFired && (o.idleEnd(), a._state === qi.IDLE && l()), o.idleBegin = l;
      }, set idleEnd(l) {
        o.idleEnd = l;
      } };
    }
    get now() {
      return this.nowFunc();
    }
    get load() {
      return this._load;
    }
    set state(i) {
      this._state !== i && (this._state = i, this.state !== qi.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = !1, this._idleStateCallbacks.forAll((s) => s.idleEnd())));
    }
    get state() {
      return H(this._test.state) ? this._state : this._test.state;
    }
    updateBudget(i) {
      this._test.usedBudget = 0;
      let s = HF, o = i.frameDuration, a = JF;
      switch (this.state) {
        case qi.IDLE:
          s = 0, o = Math.max(KF, i.frameDuration), a = Rme;
          break;
        case qi.INTERACTING:
          o = Math.max(ZF, i.frameDuration);
        case qi.ANIMATING:
      }
      return o = o - i.elapsedFrameTime - s, this.state !== qi.IDLE && o < JF && !this._forceTask ? (this._forceTask = !0, !1) : (o = Math.max(o, a), this._budget.reset(o, this.state), this._maxReschedule = qv, this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = !1, this._microTaskQueued = !1, this.state) {
        case qi.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = !0, this._idleStateCallbacks.forAll((i) => i.idleBegin())), this._runIdle();
          break;
        case qi.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(0, this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(i) {
      this._idleUpdatesStartFired && i.idleEnd(), this._idleStateCallbacks.removeUnordered(i);
    }
    removeTask(i) {
      this._tasks.removeUnordered(i), this._runQueue.removeUnordered(i);
    }
    _updateTask(i) {
      this._tasks.forAll((s) => {
        s.name === i && s.setPriority(i);
      });
    }
    _getState(i) {
      if (this._runQueue.some((o) => o.name === i))
        return Ec.SCHEDULED;
      let s = Ec.IDLE;
      return this._tasks.forAll((o) => {
        o.name === i && o.needsUpdate && (o.schedulePriority <= 1 ? s = Ec.READY : s !== Ec.READY && (s = Ec.WAITING));
      }), s;
    }
    _getRuntime(i) {
      let s = 0;
      return this._tasks.forAll((o) => {
        o.name === i && (s += o.runtime);
      }), s;
    }
    _resetRuntimes() {
      this._tasks.forAll((i) => i.runtime = 0);
    }
    _getRunning() {
      const i = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((o) => {
        o.needsUpdate && i.set(o.name, (i.get(o.name) || 0) + 1);
      }), i.size === 0)
        return null;
      let s = "";
      return i.forEach((o, a) => {
        s += o > 1 ? ` ${o}x ${a}` : ` ${a}`;
      }), s;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const i = this._tasks.reduce((s, o) => o.needsUpdate ? ++s : s, 0);
      this._load = this._load * YF + i * (1 - YF);
    }
    _schedule() {
      if (this._maxReschedule <= 0)
        return !1;
      for (this._runQueue.filterInPlace((i) => !!i.needsUpdate || (i.schedulePriority = i.basePriority, !1)), this._tasks.forAll((i) => {
        i.basePriority === da && i.needsUpdate && !this._runQueue.some((s) => s === i) && this._runQueue.unshift(i);
      }); this._runQueue.length === 0; ) {
        let i = !1, s = 0;
        if (this._tasks.forAll((o) => {
          o.needsUpdate && o.schedulePriority !== 0 && o.basePriority !== da && (i = !0, s = Math.max(s, o.basePriority), o.schedulePriority === 1 ? (o.schedulePriority = 0, this._runQueue.push(o)) : --o.schedulePriority);
        }), !i)
          return this.updating = !1, !1;
        this._maxReschedule === qv && (this._maxReschedule = s), --this._maxReschedule;
      }
      return this.updating = !0, !0;
    }
    _run() {
      const i = this._budget.now();
      this._startFrameTaskTimes();
      do
        for (; this._runQueue.length > 0; ) {
          const s = this._budget.now(), o = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            o.task.runTask(this._budget);
          } catch (l) {
            Pme.error(`Exception in task "${o.name}"`, l);
          }
          o.schedulePriority = o.basePriority;
          const a = this._budget.now() - s;
          if (o.runtime += a, this._frameTaskTimes.set(o.priority, this._frameTaskTimes.get(o.priority) + a), this._debug && this._budget.elapsed > 2 * this._budget.budget && console.log("Task", o.name, "used", this._budget.elapsed, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this.updating = this._tasks.some((l) => l.needsUpdate), void this._recordFrameTaskTimes(this._budget.now() - i);
        }
      while (this._schedule());
      this.updating = this._tasks.some((s) => s.needsUpdate), this._recordFrameTaskTimes(this._budget.now() - i);
    }
    _startFrameTaskTimes() {
      for (const i of Object.keys(dt))
        this._frameTaskTimes.set(dt[i], 0);
    }
    _recordFrameTaskTimes(i) {
      this._frameTaskTimes.forEach((s, o) => this.performanceInfo.tasks.get(o).record(s)), this.performanceInfo.total.record(i);
    }
    get test() {
      return this._test;
    }
  };
  u([d()], t.prototype, "updating", void 0), u([d()], t.prototype, "nowFunc", void 0), t = u([T("geoscene.views.support.Scheduler")], t), e.Scheduler = t;
  let n = class extends ke {
    constructor(i, s, o, a) {
      super({}), this._scheduler = i, this.name = s, this._basePriority = a, this.runtime = 0, this._queue = new Mw(), this._handles = new ei(), this.schedulePriority = this._basePriority, this.task = O(o) ? o : this._queue, this._handles.add(rS(() => this.task.running, () => i.activate()));
    }
    get updating() {
      return this._queue.running;
    }
    normalizeCtorArgs() {
      return {};
    }
    remove() {
      this.processQueue(LB), this._scheduler.removeTask(this), this.schedule = kM.schedule, this.reschedule = kM.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(i) {
      this.name = i;
      const s = WF(i);
      this._basePriority !== da && this.schedulePriority === 0 || (this.schedulePriority = s), this._basePriority = s;
    }
    get priority() {
      return this.name;
    }
    set priority(i) {
      this.setPriority(i);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(i, s, o) {
      return this._queue.push(i, s, o);
    }
    reschedule(i, s, o) {
      return this._queue.unshift(i, s, o);
    }
    processQueue(i) {
      this._queue.runTask(i);
    }
  };
  u([d({ constructOnly: !0 })], n.prototype, "task", void 0), u([d({ readOnly: !0 })], n.prototype, "updating", null), n = u([T("geoscene.views.support.SchedulerTask")], n);
  class r {
    constructor(s) {
      this.now = s, this._begin = 0, this._budget = 0, this._state = qi.IDLE, this._didWork = !1, this._enabled = !0;
    }
    run(s) {
      return !this.done && (s() === !0 && (this._didWork = !0), !0);
    }
    get done() {
      return this._didWork && this.elapsed >= this._budget && this._enabled;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      this._didWork = !0;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(s) {
      this._enabled = s;
    }
    reset(s, o) {
      this._begin = this.now(), this._budget = s, this._state = o, this._didWork = !1;
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    get elapsed() {
      return this.now() - this._begin;
    }
    resetProgress() {
      this._didWork = !1;
    }
    get hasProgressed() {
      return this._didWork;
    }
  }
  e.Budget = r;
})(OM || (OM = {})), function(e) {
  e.SCHEDULED = "s", e.READY = "r", e.WAITING = "w", e.IDLE = "i";
}(Ec || (Ec = {}));
const LB = (() => {
  const e = new OM.Budget(() => performance.now());
  return e.enabled = !1, e;
})();
let Lme = class {
  remove() {
  }
  processQueue() {
  }
  schedule(t, n, r) {
    try {
      if (Ea(n)) {
        const i = Cn();
        return r ? Promise.resolve(r(i)) : Promise.reject(i);
      }
      return A$(t(LB));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  reschedule(t, n, r) {
    return this.schedule(t, n, r);
  }
};
const kM = new Lme(), qv = Number.MAX_SAFE_INTEGER;
let jy = class extends ke {
  constructor(t, n) {
    var r;
    super({}), this._stage = t, this._textureRequests = /* @__PURE__ */ new Map(), this._frameTask = (r = n == null ? void 0 : n.registerTask(dt.TEXTURE_UNLOAD)) != null ? r : kM;
  }
  normalizeCtorArgs() {
    return {};
  }
  destroy() {
    super.destroy(), this._frameTask.remove(), this._textureRequests.forEach((t) => this._releaseTextureRequest(t)), this._textureRequests.clear();
  }
  get updating() {
    return this._frameTask.updating;
  }
  fromData(t, n, r) {
    const i = this.makeUid(t);
    let s = this._textureRequests.get(i);
    return s || (s = { referenceCount: 0, texture: n(), textureAsync: null, abortController: null, onRemove: r }, this._stage && (this._stage.add(s.texture), this._stage.loadImmediate(s.texture)), this._textureRequests.set(i, s)), s.referenceCount++, { uid: i, texture: s.texture, release: () => this._release(i) };
  }
  _release(t) {
    const n = this._textureRequests.get(t);
    n ? (n.referenceCount < 1 && console.warn("TextureCollection: reference count is < 1 for " + t), n.referenceCount--, n.referenceCount < 1 && this._frameTask.schedule(() => this._releaseNow(t))) : console.warn(`TextureCollection: texture doesn't exist: '${t}'`);
  }
  get test() {
    return { textureRequests: this._textureRequests };
  }
  _releaseNow(t) {
    if (!this._textureRequests)
      return;
    const n = this._textureRequests.get(t);
    !n || n.referenceCount > 0 || (this._releaseTextureRequest(n), this._textureRequests.delete(t));
  }
  _releaseTextureRequest(t) {
    var n;
    t.onRemove && t.onRemove(), t.texture ? (n = this._stage) == null || n.remove(t.texture) : t.abortController && (t.abortController.abort(), t.abortController = null);
  }
  makeUid(t, n = null) {
    return O(n) ? `${t}.${n}px` : t;
  }
};
u([d()], jy.prototype, "_frameTask", void 0), u([d()], jy.prototype, "updating", null), jy = u([T("geoscene.views.3d.support.TextureCollection")], jy);
var QF;
(function(e) {
  e[e.Left = 0] = "Left", e[e.Middle = 1] = "Middle", e[e.Right = 2] = "Right";
})(QF || (QF = {}));
const FB = ["click", "double-click", "immediate-click", "immediate-double-click", "hold", "drag", "key-down", "key-up", "pointer-down", "pointer-move", "pointer-up", "pointer-drag", "mouse-wheel", "pointer-enter", "pointer-leave", "gamepad", "focus", "blur"], NB = {};
function DB(e) {
  return !!NB[e];
}
function Fme(e) {
  for (const t of e)
    if (!DB(t))
      return !1;
  return !0;
}
FB.forEach((e) => {
  NB[e] = !0;
});
let Nme = class {
  constructor(t) {
    this.handlers = /* @__PURE__ */ new Map(), this.counter = 0, this.handlerCounts = /* @__PURE__ */ new Map(), this.view = t, this.inputManager = null;
  }
  connect(t) {
    t && this.disconnect(), this.inputManager = t, this.handlers.forEach(({ handler: n, priority: r }, i) => this.inputManager.installHandlers(i, [n], r));
  }
  disconnect() {
    this.inputManager && this.handlers.forEach((t, n) => this.inputManager.uninstallHandlers(n)), this.inputManager = null;
  }
  destroy() {
    this.disconnect(), this.handlers.clear(), this.view = null;
  }
  on(t, n, r, i) {
    const s = Array.isArray(t) ? t : t.split(",");
    if (!Fme(s))
      return s.some(DB) && console.error("Error: registering input events and other events on the view at the same time is not supported."), null;
    let o, a;
    Array.isArray(n) ? a = n : (o = n, a = []), typeof r == "function" ? o = r : i = r, i = i ?? Yu.DEFAULT;
    const l = this._createUniqueGroupName(), c = new Dme(this.view, s, a, o);
    this.handlers.set(l, { handler: c, priority: i });
    for (const p of s) {
      const f = this.handlerCounts.get(p) || 0;
      this.handlerCounts.set(p, f + 1);
    }
    return this.inputManager && this.inputManager.installHandlers(l, [c], i), { remove: () => this._removeHandler(l, s) };
  }
  hasHandler(t) {
    return !!this.handlerCounts.get(t);
  }
  _removeHandler(t, n) {
    if (this.handlers.has(t)) {
      this.handlers.delete(t);
      for (const r of n) {
        const i = this.handlerCounts.get(r);
        i === void 0 ? console.error("Trying to remove handler for event that has no handlers registered: ", r) : i === 1 ? this.handlerCounts.delete(r) : this.handlerCounts.set(r, i - 1);
      }
    }
    this.inputManager && this.inputManager.uninstallHandlers(t);
  }
  _createUniqueGroupName() {
    return this.counter += 1, `viewEvents_${this.counter}`;
  }
}, Dme = class extends dr {
  constructor(t, n, r, i) {
    super(!0), this.view = t;
    for (const s of n)
      switch (s) {
        case "click":
          this.registerIncoming("click", r, (o) => i(this._wrapClick(o)));
          break;
        case "double-click":
          this.registerIncoming("double-click", r, (o) => i(this._wrapDoubleClick(o)));
          break;
        case "immediate-click":
          this.registerIncoming("immediate-click", r, (o) => i(this._wrapImmediateClick(o)));
          break;
        case "immediate-double-click":
          this.registerIncoming("immediate-double-click", r, (o) => i(this._wrapImmediateDoubleClick(o)));
          break;
        case "hold":
          this.registerIncoming("hold", r, (o) => i(this._wrapHold(o)));
          break;
        case "drag":
          this.registerIncoming("drag", r, (o) => {
            const a = this._wrapDrag(o);
            a && i(a);
          });
          break;
        case "key-down":
          this.registerIncoming("key-down", r, (o) => i(this._wrapKeyDown(o)));
          break;
        case "key-up":
          this.registerIncoming("key-up", r, (o) => i(this._wrapKeyUp(o)));
          break;
        case "pointer-down":
          this.registerIncoming("pointer-down", r, (o) => i(this._wrapPointer(o, "pointer-down")));
          break;
        case "pointer-move":
          this.registerIncoming("pointer-move", r, (o) => i(this._wrapPointer(o, "pointer-move")));
          break;
        case "pointer-up":
          this.registerIncoming("pointer-up", r, (o) => i(this._wrapPointer(o, "pointer-up")));
          break;
        case "pointer-drag":
          this.registerIncoming("pointer-drag", r, (o) => i(this._wrapPointerDrag(o)));
          break;
        case "mouse-wheel":
          this.registerIncoming("mouse-wheel", r, (o) => i(this._wrapMouseWheel(o)));
          break;
        case "pointer-enter":
          this.registerIncoming("pointer-enter", r, (o) => i(this._wrapPointer(o, "pointer-enter")));
          break;
        case "pointer-leave":
          this.registerIncoming("pointer-leave", r, (o) => i(this._wrapPointer(o, "pointer-leave")));
          break;
        case "gamepad":
          this.registerIncoming("gamepad", r, (o) => {
            i(this._wrapGamepad(o));
          });
          break;
        case "focus":
          this.registerIncoming("focus", r, (o) => {
            i(this._wrapFocus(o));
          });
          break;
        case "blur":
          this.registerIncoming("blur", r, (o) => {
            i(this._wrapBlur(o));
          });
      }
  }
  _wrapFocus(t) {
    return { type: "focus", timestamp: t.timestamp, native: t.data.native, cancelable: t.cancelable, stopPropagation: () => t.stopPropagation(), async: (n) => t.async(n), preventDefault: () => t.preventDefault() };
  }
  _wrapBlur(t) {
    return { type: "blur", timestamp: t.timestamp, native: t.data.native, cancelable: t.cancelable, stopPropagation: () => t.stopPropagation(), async: (n) => t.async(n), preventDefault: () => t.preventDefault() };
  }
  _wrapClick(t) {
    const { pointerType: n, button: r, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, { cancelable: c, timestamp: p } = t;
    return { type: "click", pointerType: n, button: r, buttons: i, x: s, y: o, native: a, timestamp: p, screenPoint: wi(s, o), mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: c, stopPropagation: () => t.stopPropagation(), async: (f) => t.async(f), preventDefault: () => t.preventDefault() };
  }
  _wrapDoubleClick(t) {
    const { pointerType: n, button: r, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, { cancelable: c, timestamp: p } = t;
    return { type: "double-click", pointerType: n, button: r, buttons: i, x: s, y: o, native: a, timestamp: p, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: c, stopPropagation: () => t.stopPropagation(), async: (f) => t.async(f), preventDefault: () => t.preventDefault() };
  }
  _wrapImmediateClick(t) {
    const { pointerType: n, button: r, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, c = a.pointerId, { cancelable: p, timestamp: f } = t;
    return { type: "immediate-click", pointerId: c, pointerType: n, button: r, buttons: i, x: s, y: o, native: a, timestamp: f, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: p, stopPropagation: () => t.stopPropagation(), async: (m) => t.async(m), preventDefault: () => t.preventDefault() };
  }
  _wrapImmediateDoubleClick(t) {
    const { pointerType: n, button: r, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, c = a.pointerId, { cancelable: p, timestamp: f } = t;
    return { type: "immediate-double-click", pointerId: c, pointerType: n, button: r, buttons: i, x: s, y: o, native: a, timestamp: f, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: p, stopPropagation: () => t.stopPropagation(), async: (m) => t.async(m), preventDefault: () => t.preventDefault() };
  }
  _wrapHold(t) {
    const { pointerType: n, button: r, buttons: i, x: s, y: o, native: a } = t.data, { cancelable: l, timestamp: c } = t;
    return { type: "hold", pointerType: n, button: r, buttons: i, x: s, y: o, native: a, timestamp: c, mapPoint: this._getMapPoint(s, o), cancelable: l, stopPropagation: () => t.stopPropagation(), async: (p) => t.async(p), preventDefault: () => t.preventDefault() };
  }
  _getMapPoint(t, n) {
    return this.view.toMap(wi(t, n), { exclude: [] });
  }
  _wrapDrag(t) {
    const n = t.data, { x: r, y: i } = n.center, { action: s, pointerType: o, button: a } = n;
    if (s === "start" && (this.latestDragStart = n), !this.latestDragStart)
      return;
    const l = n.pointer.native, c = n.buttons, { cancelable: p, timestamp: f } = t, m = { x: this.latestDragStart.center.x, y: this.latestDragStart.center.y };
    return s === "end" && (this.latestDragStart = void 0), { type: "drag", action: s, x: r, y: i, origin: m, pointerType: o, button: a, buttons: c, radius: n.radius, angle: p6(n.angle), native: l, timestamp: f, cancelable: p, stopPropagation: () => t.stopPropagation(), async: (y) => t.async(y), preventDefault: () => t.preventDefault() };
  }
  _wrapKeyDown(t) {
    const { key: n, repeat: r, native: i } = t.data, { cancelable: s, timestamp: o } = t;
    return { type: "key-down", key: n, repeat: r, native: i, timestamp: o, cancelable: s, stopPropagation: () => t.stopPropagation(), async: (a) => t.async(a), preventDefault: () => t.preventDefault() };
  }
  _wrapKeyUp(t) {
    const { key: n, native: r } = t.data, { cancelable: i, timestamp: s } = t;
    return { type: "key-up", key: n, native: r, timestamp: s, cancelable: i, stopPropagation: () => t.stopPropagation(), async: (o) => t.async(o), preventDefault: () => t.preventDefault() };
  }
  _wrapPointer(t, n) {
    const { x: r, y: i, button: s, buttons: o, native: a, eventId: l } = t.data, c = a.pointerId, p = a.pointerType, { cancelable: f, timestamp: m } = t;
    return { type: n, x: r, y: i, pointerId: c, pointerType: p, button: s, buttons: o, native: a, timestamp: m, eventId: l, cancelable: f, stopPropagation: () => t.stopPropagation(), async: (y) => t.async(y), preventDefault: () => t.preventDefault() };
  }
  _wrapPointerDrag(t) {
    const { x: n, y: r, buttons: i, native: s, eventId: o } = t.data.currentEvent, { button: a } = t.data.startEvent, l = t.data.startEvent.native.pointerId, c = t.data.startEvent.native.pointerType, p = t.data.action, f = { x: t.data.startEvent.x, y: t.data.startEvent.y }, { cancelable: m, timestamp: y } = t;
    return { type: "pointer-drag", x: n, y: r, pointerId: l, pointerType: c, button: a, buttons: i, action: p, origin: f, native: s, timestamp: y, eventId: o, cancelable: m, stopPropagation: () => t.stopPropagation(), async: (g) => t.async(g), preventDefault: () => t.preventDefault() };
  }
  _wrapMouseWheel(t) {
    const { cancelable: n, data: r, timestamp: i } = t, { x: s, y: o, deltaY: a, native: l } = r;
    return { type: "mouse-wheel", x: s, y: o, deltaY: a, native: l, timestamp: i, cancelable: n, stopPropagation: () => t.stopPropagation(), async: (c) => t.async(c), preventDefault: () => t.preventDefault() };
  }
  _wrapGamepad(t) {
    const { action: n, state: r, device: i } = t.data, { cancelable: s, timestamp: o } = t, { buttons: a, axes: l } = r;
    return { type: "gamepad", device: i, timestamp: o, action: n, buttons: a, axes: l, cancelable: s, stopPropagation: () => t.stopPropagation(), async: (c) => t.async(c), preventDefault: () => t.preventDefault() };
  }
};
var Yg, XF, eN;
(function(e) {
  e[e.USER = 0] = "USER", e[e.MANAGER = 1] = "MANAGER";
})(Yg || (Yg = {})), function(e) {
  e[e.None = 0] = "None", e[e.Unfocused = 1] = "Unfocused", e[e.Focused = 2] = "Focused", e[e.Unselected = 4] = "Unselected", e[e.Selected = 8] = "Selected", e[e.All = 15] = "All";
}(XF || (XF = {})), function(e) {
  e[e.None = 0] = "None", e[e.Custom1 = 16] = "Custom1", e[e.Custom2 = 32] = "Custom2", e[e.Custom3 = 64] = "Custom3", e[e.Custom4 = 128] = "Custom4", e[e.Custom5 = 256] = "Custom5", e[e.Custom6 = 512] = "Custom6", e[e.Custom7 = 1024] = "Custom7", e[e.Custom8 = 2048] = "Custom8", e[e.Custom9 = 4096] = "Custom9", e[e.Custom10 = 8192] = "Custom10", e[e.Custom11 = 16384] = "Custom11", e[e.Custom12 = 32768] = "Custom12", e[e.All = 65520] = "All";
}(eN || (eN = {}));
const jme = we.getLogger("geoscene.views.interactive.interactiveToolUtils");
function Vme(e) {
  return [e.on("before-add", (t) => {
    const n = t.item;
    if (n == null || e.includes(n))
      return jme.warn("Tool is either already in the list of tools or tool is `null`. Not adding tool."), void t.preventDefault();
  }), e.on("after-remove", (t) => {
    const n = t.item;
    n.visible = !1, n.active && (n.view.activeTool = null), n.destroy();
  })];
}
function l_(e) {
  return e.visible && e.getEditableFlag(Yg.USER) && e.getEditableFlag(Yg.MANAGER);
}
function oa(e) {
  return wi(e.x, e.y);
}
function jB(e, t) {
  const n = (e instanceof HTMLElement ? e : e.surface).getBoundingClientRect();
  return wi(t.clientX - n.left, t.clientY - n.top);
}
function tN(e, t) {
  return t instanceof Event ? jB(e, t) : oa(t);
}
function nN(e) {
  if (e instanceof Event)
    return !0;
  if (typeof e == "object" && "type" in e)
    switch (e.type) {
      case "click":
      case "double-click":
      case "pointer-down":
      case "pointer-drag":
      case "pointer-enter":
      case "pointer-leave":
      case "pointer-up":
      case "pointer-move":
      case "immediate-click":
      case "immediate-double-click":
      case "hold":
      case "drag":
      case "mouse-wheel":
        return !0;
      default:
        return !1;
    }
  return !1;
}
let zme = class {
  constructor() {
    this._pointerLocations = /* @__PURE__ */ new Map(), this._hoveredManipulators = /* @__PURE__ */ new Map(), this._grabbedManipulators = /* @__PURE__ */ new Map(), this._draggedManipulators = /* @__PURE__ */ new Map(), this._stopDrag = !1, this._currentlyActiveTool = null, this._revertToActiveTool = !1, this._cursor = null;
  }
  get cursor() {
    return this._cursor;
  }
  handleInputEvent(t, n) {
    const r = () => t.stopPropagation();
    switch (t.type) {
      case "pointer-move":
        rN(t.pointerType) && this._pointerLocations.set(t.pointerId, { x: t.x, y: t.y, pointerType: t.pointerType });
        break;
      case "drag":
        this._grabbedManipulators.size > 0 && (this._stopDrag = !0), this._stopDrag && (r(), t.action === "end" && (this._stopDrag = !1));
        break;
      case "pointer-down": {
        if (!iN(t))
          break;
        const i = oa(t), s = this._intersect(i, t.pointerType, n.forEachTool);
        if (H(s))
          break;
        const o = this._findToolAndManipulatorByKey(s, n.forEachTool, Gv), a = Nu(o, (c) => c.manipulator), l = Nu(o, (c) => c.tool);
        !(O(a) && O(l) && a.interactive) || a.grabbable && a.grabbableForEvent(t) || !a.grabbing || a.dragging || this._ungrabManipulatorBeforeDragging(a, l, t), O(a) && a.interactive && a.grabbable && a.grabbableForEvent(t) && !a.grabbing && (this._grabbedManipulators.set(t.pointerId, { key: s, start: i, pointerType: t.pointerType }), this._grabbedManipulators.size === 1 && n.activeTool !== s.tool && (this._currentlyActiveTool = n.activeTool, this._revertToActiveTool = !0, n.setActiveTool(s.tool)), a.grabbing = !0, a.events.emit("grab-changed", { action: "start", pointerType: t.pointerType, screenPoint: i }), r());
        break;
      }
      case "pointer-up":
        this._handlePointerEnd(t, n);
        break;
      case "pointer-drag": {
        if (!iN(t))
          break;
        const i = this._grabbedManipulators.get(t.pointerId), s = this._draggedManipulators.get(t.pointerId), o = Nu(i || s, ({ key: p }) => p), a = this._findManipulatorByKey(o, n.forEachTool);
        if (H(a))
          break;
        const l = oa(t);
        l.x = js(l.x, 0, n.view.width), l.y = js(l.y, 0, n.view.height);
        const c = (i || s).start;
        switch (t.action) {
          case "start":
          case "update":
            t.action !== "update" && this._grabbedManipulators.size !== 1 || (a.dragging = !0, s ? a.events.emit("drag", { action: "update", start: c, screenPoint: l }) : a.events.emit("drag", { action: "start", start: c, screenPoint: l, pointerType: t.pointerType }), this._draggedManipulators.set(t.pointerId, { key: o, start: c }));
            break;
          case "end":
            a.dragging = !1, s && a.events.emit("drag", { action: "end", start: c, screenPoint: l }), this._draggedManipulators.delete(t.pointerId), this._handlePointerEnd(t, n);
        }
        r();
        break;
      }
      case "immediate-click": {
        const i = oa(t), s = this._intersect(i, t.pointerType, n.forEachTool), o = this._findToolAndManipulatorByKey(s, n.forEachTool, Gv);
        if (Bme(t) || n.forEachTool((p) => {
          if ((!O(o) || o.tool !== p || p.automaticManipulatorSelection) && p.manipulators) {
            let f = !1;
            p.manipulators.forEach(({ manipulator: m }) => {
              m.selected && (m.selected = !1, f = !0);
            }), f && p.manipulatorSelectionChanged && p.manipulatorSelectionChanged();
          }
        }), H(o))
          break;
        const { manipulator: a, tool: l } = o;
        if (!a.interactive)
          break;
        a.selectable && l.automaticManipulatorSelection && (a.selected = !a.selected, l.manipulatorSelectionChanged && l.manipulatorSelectionChanged());
        const c = t.native.shiftKey;
        a.events.emit("immediate-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: c, stopPropagation: r });
        break;
      }
      case "click": {
        const i = oa(t), s = this._intersect(i, t.pointerType, n.forEachTool), o = this._findManipulatorByKey(s, n.forEachTool);
        if (H(o) || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit(t.type, { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a }), r();
        break;
      }
      case "double-click": {
        const i = oa(t), s = this._intersect(i, t.pointerType, n.forEachTool), o = this._findManipulatorByKey(s, n.forEachTool);
        if (H(o) || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit("double-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a, stopPropagation: r });
        break;
      }
      case "immediate-double-click": {
        const i = oa(t), s = this._intersect(i, t.pointerType, n.forEachTool), o = this._findManipulatorByKey(s, n.forEachTool);
        if (H(o) || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit("immediate-double-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a, stopPropagation: r });
        break;
      }
    }
    this._updateCursor(n.forEachTool);
  }
  _ungrabManipulatorBeforeDragging(t, n, r) {
    t.grabbing = !1, t.events.emit("grab-changed", { action: "end", pointerType: r.pointerType, screenPoint: oa(r) }), this._grabbedManipulators.forEach(({ key: i }, s) => {
      i.tool === n && n.manipulators.findById(i.manipulatorId) === t && this._grabbedManipulators.delete(s);
    });
  }
  _handlePointerEnd(t, n) {
    const r = Nu(this._grabbedManipulators.get(t.pointerId), ({ key: s }) => s), i = this._findManipulatorByKey(r, n.forEachTool);
    O(i) && !i.dragging && (this._grabbedManipulators.size === 1 && this._draggedManipulators.size === 0 && this._revertToActiveTool && (n.setActiveTool(this._currentlyActiveTool), this._revertToActiveTool = !1, this._currentlyActiveTool = null), i.grabbing && (i.grabbing = !1, i.events.emit("grab-changed", { action: "end", pointerType: t.pointerType, screenPoint: oa(t) })), this._grabbedManipulators.delete(t.pointerId));
  }
  _cursorFromMap(t, n) {
    let r = null;
    return H_(t, ({ key: i }) => {
      const s = this._findManipulatorByKey(i, n);
      return !!(O(s) && s.interactive && "cursor" in s && s.cursor) && (r = s.cursor, !0);
    }), r;
  }
  _updateCursor(t) {
    this._grabbedManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._grabbedManipulators, t) || "grabbing" : this._hoveredManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._hoveredManipulators, t) || "pointer" : this._cursor = null;
  }
  clearPointers(t, n, r = !0, i) {
    const s = (o) => o.tool === t && (H(i) || o.manipulatorId === i);
    this._grabbedManipulators.forEach(({ key: o, pointerType: a }, l) => {
      if (s(o)) {
        this._grabbedManipulators.delete(l);
        const c = this._findManipulatorByKey(o, n);
        O(c) && (c.grabbing = !1, c.events.emit("grab-changed", { action: "end", screenPoint: null, pointerType: a }));
      }
    }), this._draggedManipulators.forEach(({ key: o }, a) => {
      if (s(o)) {
        this._draggedManipulators.delete(a);
        const l = this._findManipulatorByKey(o, n);
        O(l) && (l.dragging = !1, l.events.emit("drag", { action: "cancel" }));
      }
    }), r && this._hoveredManipulators.forEach(({ key: o }, a) => {
      if (s(o)) {
        this._hoveredManipulators.delete(a);
        const l = this._findManipulatorByKey(o, n);
        O(l) && (l.hovering = !1);
      }
    }), this._updateCursor(n);
  }
  _intersect(t, n, r) {
    let i = null;
    return r((s) => {
      if (s.manipulators == null || !l_(s))
        return !1;
      const o = s.manipulators.intersect(t, n);
      return !H(o) && (i = { manipulatorId: o.id, tool: s }, !0);
    }), i;
  }
  updateHoveredStateFromKnownPointers(t) {
    this._pointerLocations.forEach((n, r) => {
      this._updateHoveredStateForPointerAtScreenPosition(wi(n.x, n.y), r, n.pointerType, t);
    });
  }
  handleHoverEvent(t, n) {
    t.type !== "pointer-up" && t.type !== "immediate-click" && t.type !== "pointer-move" || !rN(t.pointerType) || this._updateHoveredStateForPointerAtScreenPosition(oa(t), t.pointerId, t.pointerType, n);
  }
  _updateHoveredStateForPointerAtScreenPosition(t, n, r, i) {
    const s = this._intersect(t, r, i);
    let o = this._findManipulatorByKey(s, i);
    const a = Nu(this._hoveredManipulators.get(n), ({ key: c }) => c), l = this._findManipulatorByKey(a, i);
    O(o) && !o.interactive && (o = null), l !== o && (O(l) && (l.hovering = !1), O(o) ? (o.hovering = !0, this._hoveredManipulators.set(n, { key: s })) : this._hoveredManipulators.delete(n), this._updateCursor(i));
  }
  _findManipulatorByKey(t, n) {
    return this._findToolAndManipulatorByKey(t, n, Gv) ? Gv.manipulator : null;
  }
  _findToolAndManipulatorByKey(t, n, r) {
    return H(t) ? null : (r.tool = null, r.manipulator = null, n((i) => {
      if (i !== t.tool || i.manipulators == null || !l_(i))
        return !1;
      const s = i.manipulators.findById(t.manipulatorId);
      return !!O(s) && (r.manipulator = s, r.tool = i, !0);
    }), r.manipulator ? r : null);
  }
};
function rN(e) {
  return e === "mouse";
}
function iN(e) {
  return e.pointerType !== "mouse" || e.button === 0;
}
function Bme(e) {
  return !!e.native.shiftKey;
}
const Gv = { manipulator: null, tool: null }, sN = we.getLogger("geoscene.views.ToolViewManager"), oN = "attached", Lx = "tools";
let ol = class extends hf {
  constructor(t) {
    super(t), this._manipulatorState = new zme(), this.tools = new Ne(), this.cursor = null, this._forEachTool = (n) => {
      for (const r of this.tools.items)
        if (n(r))
          return;
    };
  }
  initialize() {
    this.handles.add([this.view.on(FB, (t) => {
      this._handleInputEvent(t);
    }, Yu.TOOL), ...Vme(this.tools), this.tools.on("before-remove", ({ item: t }) => {
      this._manipulatorState.clearPointers(t, this._forEachTool);
    }), this.tools.on("change", () => {
      this._refreshToolWatchers();
    })]);
  }
  destroy() {
    this.detach(), this.handles.removeAll();
  }
  set activeTool(t) {
    if (O(t) && !this.view.ready)
      return void sN.error("Cannot set active tool while view is not ready.");
    if (t === this.activeTool)
      return void (O(t) && sN.warn("Tool is already active - ignoring activation request."));
    const n = this.activeTool;
    this._set("activeTool", t), O(n) && n.deactivate(), O(t) && t.activate(), this._removeIncompleteTools(t);
    const r = H(this.activeTool);
    for (const i of this.tools) {
      i.setEditableFlag(Yg.MANAGER, r || i === this.activeTool);
      const s = l_(i);
      !r && s || this._manipulatorState.clearPointers(i, this._forEachTool, !s);
    }
    this._updateCursor();
  }
  get updating() {
    var t, n;
    return this.updatingHandles.updating || this.tools.some((r) => r.updating) || (t = (n = this.textures) == null ? void 0 : n.updating) != null && t;
  }
  attach() {
    this.view.type === "3d" ? (this._set("textures", new jy(this.view._stage, this.view.resourceController.scheduler)), this.handles.add([this.view.state.watch("camera", () => {
      this._forEachManipulator((t) => {
        t.onViewChange != null && t.onViewChange();
      });
    }), this.view.elevationProvider.on("elevation-change", (t) => {
      this._forEachManipulator((n) => {
        n.onElevationChange != null && n.onElevationChange(t);
      });
    }), Vf(() => this._set("textures", pa(this.textures)))], oN)) : this.handles.add(this.view.watch("extent", () => {
      this._forEachManipulator((t) => {
        t.onViewChange != null && t.onViewChange();
      });
    }));
  }
  detach() {
    O(this.activeTool) && (this.activeTool = null), this.tools.removeAll(), this.handles.remove(oN);
  }
  _forEachManipulator(t) {
    this._forEachTool((n) => {
      n.manipulators && n.manipulators.forEach(({ manipulator: r }) => t(r, n));
    });
  }
  _handleInputEvent(t) {
    let n = !1;
    const r = { ...t, stopPropagation: () => {
      n = !0, t.stopPropagation();
    } };
    O(this.activeTool) ? this.activeTool.handleInputEvent && this.activeTool.handleInputEvent(r) : this._forEachTool((i) => {
      !n && i.visible && i.handleInputEvent(r);
    }), !n && t.type === "key-down" && t.key === "Escape" && this.activeTool && (t.stopPropagation(), this.activeTool = null), this._manipulatorState.handleInputEvent(r, { forEachTool: this._forEachTool, activeTool: this.activeTool, setActiveTool: (i) => {
      this.activeTool = i;
    }, view: this.view }), !n && O(this.activeTool) && this.activeTool.handleInputEventAfter(r), this._manipulatorState.handleHoverEvent(r, this._forEachTool), this._updateCursor();
  }
  _refreshToolWatchers() {
    this.handles.remove(Lx), this._forEachTool((t) => {
      if (t instanceof ke) {
        const n = Lt(t, ["cursor", "visible", "editable"], () => {
          l_(t) || this._manipulatorState.clearPointers(t, this._forEachTool), this._updateCursor();
        });
        this.handles.add(n, Lx);
      }
      t.manipulators && this.handles.add(t.manipulators.on("change", (n) => {
        n.removed.forEach(({ id: r }) => {
          this._manipulatorState.clearPointers(t, this._forEachTool, !0, r);
        }), this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
      }), Lx);
    }), this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
  }
  _updateCursor() {
    let t = this._manipulatorState.cursor;
    this._forEachTool((n) => !(!O(n.cursor) || !n.visible) && (t = n.cursor, !0)), this._get("cursor") !== t && this._set("cursor", t);
  }
  _removeIncompleteTools(t) {
    this.tools.filter((n) => (H(t) || n !== t) && !n.created).forEach((n) => {
      this.tools.remove(n);
    });
  }
};
u([d({ constructOnly: !0, nonNullable: !0 })], ol.prototype, "view", void 0), u([d({ readOnly: !0, nonNullable: !0 })], ol.prototype, "textures", void 0), u([d({ value: null })], ol.prototype, "activeTool", null), u([d({ readOnly: !0, type: Ne })], ol.prototype, "tools", void 0), u([d({ readOnly: !0 })], ol.prototype, "cursor", void 0), u([d({ readOnly: !0 })], ol.prototype, "updating", null), ol = u([T("geoscene.views.ToolViewManager")], ol);
const Ume = ol;
let Ch = class extends ke {
  constructor(t) {
    super(), this.nativeIndex = null, this._detectedDeviceType = "unknown", t.mapping === "standard" ? this._detectedDeviceType = "standard" : qme.test(t.id) ? this._detectedDeviceType = "spacemouse" : this._detectedDeviceType = "unknown", this.nativeIndex = t.index;
  }
  get native() {
    return (navigator.getGamepads ? navigator.getGamepads() : [])[this.nativeIndex];
  }
  get deviceType() {
    return this._detectedDeviceType;
  }
  get axisThreshold() {
    return Gme[this.deviceType];
  }
};
u([d({ nonNullable: !0, readOnly: !0 })], Ch.prototype, "nativeIndex", void 0), u([d({ type: String, readOnly: !0 })], Ch.prototype, "deviceType", null), u([d({ type: Number, readOnly: !0 })], Ch.prototype, "axisThreshold", null), Ch = u([T("geoscene.views.input.gamepad.GamepadInputDevice")], Ch);
const qme = new RegExp("^(3dconnexion|space(mouse|navigator|pilot|explorer))", "i"), Gme = { standard: 0.15, spacemouse: 0.025, unknown: 0 }, e3 = Ch;
let Vy = class extends ke {
  constructor(...t) {
    super(...t), this.devices = new Ne(), this.enabledFocusMode = "document";
  }
};
u([d({ type: Ne.ofType(e3), readOnly: !0 })], Vy.prototype, "devices", void 0), u([d({ type: ["document", "view", "none"] })], Vy.prototype, "enabledFocusMode", void 0), Vy = u([T("geoscene.views.input.gamepad.GamepadSettings")], Vy);
const Wme = Vy;
let Cw = class extends ke {
  constructor() {
    super(...arguments), this.gamepad = new Wme();
  }
};
u([d({ readOnly: !0 })], Cw.prototype, "gamepad", void 0), Cw = u([T("geoscene.views.input.Input")], Cw);
const Hme = Cw;
let xu = class extends ke {
  constructor(t) {
    super(t), this.enabled = !0, this.device = null, this.mode = "pan", this.tiltDirection = "forward-down", this.velocityFactor = 1;
  }
};
u([d({ type: Boolean, nonNullable: !0 })], xu.prototype, "enabled", void 0), u([d({ type: e3 })], xu.prototype, "device", void 0), u([d({ type: ["pan", "zoom"], nonNullable: !0 })], xu.prototype, "mode", void 0), u([d({ type: ["forward-down", "forward-up"], nonNullable: !0 })], xu.prototype, "tiltDirection", void 0), u([d({ type: Number, nonNullable: !0 })], xu.prototype, "velocityFactor", void 0), xu = u([T("geoscene.views.navigation.gamepad.GamepadSettings")], xu);
const VB = xu;
let cd = class extends ke {
  constructor(t) {
    super(t), this.browserTouchPanEnabled = !0, this.gamepad = new VB(), this.momentumEnabled = !0, this.mouseWheelZoomEnabled = !0;
  }
};
u([d({ type: Boolean })], cd.prototype, "browserTouchPanEnabled", void 0), u([d({ type: VB, nonNullable: !0 })], cd.prototype, "gamepad", void 0), u([d({ type: Boolean })], cd.prototype, "momentumEnabled", void 0), u([d({ type: Boolean })], cd.prototype, "mouseWheelZoomEnabled", void 0), cd = u([T("geoscene.views.navigation.Navigation")], cd);
const zB = cd;
var aN;
function Jme(e) {
  const t = e.url && z0(e.url);
  return !((e.spatialReference && e.spatialReference.vcsWkid) == null && O(t) && t.serverType === "ImageServer") && BB(e) && e.heightModelInfo ? e.heightModelInfo : Zme(e) ? OS.deriveUnitFromSR(Yme, e.spatialReference) : null;
}
function BB(e) {
  return "heightModelInfo" in e;
}
function UB(e) {
  if (e.type === "unknown" || !("capabilities" in e))
    return !1;
  switch (e.type) {
    case "csv":
    case "feature":
    case "geojson":
    case "subtype-group":
    case "ogc-feature":
    case "wfs":
      return !0;
    default:
      return !1;
  }
}
function Zme(e) {
  return UB(e) ? !!(e.capabilities && e.capabilities.data && e.capabilities.data.supportsZ) : qB(e);
}
function Kme(e) {
  return e.layers != null || qB(e) || UB(e) || BB(e);
}
function qB(e) {
  switch (e.type) {
    case "building-scene":
    case "elevation":
    case "integrated-mesh":
    case "point-cloud":
    case "scene":
    case "voxel":
      return !0;
    case "analysis":
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "csv":
    case "geojson":
    case "feature":
    case "subtype-group":
    case "geo-rss":
    case "graphics":
    case "group":
    case "imagery":
    case "imagery-tile":
    case "kml":
    case "map-image":
    case "map-notes":
    case "ogc-feature":
    case "open-street-map":
    case "route":
    case "stream":
    case "tile":
    case "unknown":
    case "unsupported":
    case "vector-tile":
    case "wcs":
    case "web-tile":
    case "wfs":
    case "wms":
    case "wmts":
    case null:
      return !1;
  }
  return !1;
}
(function(e) {
  e[e.Ok = 0] = "Ok", e[e.Units = 1] = "Units", e[e.HeightModel = 2] = "HeightModel", e[e.CRS = 3] = "CRS", e[e.Unsupported = 4] = "Unsupported";
})(aN || (aN = {}));
const Yme = new OS({ heightModel: "gravity-related-height" });
var Qg;
function lN(e) {
  return e === Qg.Global ? "global" : "local";
}
(function(e) {
  e[e.Global = 1] = "Global", e[e.Local = 2] = "Local";
})(Qg || (Qg = {}));
let AM, Fx = null;
async function Qme(e) {
  Fx || (Fx = import("./geometryServiceUtils-tZDVvxCZ.js").then((t) => AM = t)), await Fx, On(e);
}
async function GB(e, t, n, r) {
  if (!e)
    return null;
  const i = e.spatialReference;
  return wf() || cp(i, t) ? I0(e, t) : AM ? AM.projectGeometry(e, t, n, r) : (await Promise.race([Qme(r), _f(r)]), GB(e, t, n, r));
}
const WB = we.getLogger("geoscene.views.support.DefaultsFromMap");
WB.level = "info";
let kt = class extends ke {
  constructor(t) {
    super(t), this.required = { tileInfo: !1, heightModelInfo: !1, extent: !1 }, this.defaultSpatialReference = null, this.userSpatialReference = null, this.sourcePreloadCount = 10, this.priorityCollection = null, this.logDebugInformation = !1, this.requiresExtentInSpatialReference = !0, this.suspended = !1, this._projectExtentTask = { task: null, input: null, output: null, spatialReference: null };
  }
  destroy() {
    this._projectExtentTask.task && (this._debug("Aborting project extent task"), this._projectExtentTask.task = E$(this._projectExtentTask.task)), this._set("map", null);
  }
  get ready() {
    return !this._spatialReferenceTask.updating && !this._tileInfoTask.updating && !this._extentTask.updating;
  }
  get heightModelInfoReady() {
    return !this._heightModelInfoTask.updating;
  }
  get spatialReference() {
    return O(this.userSpatialReference) ? this.userSpatialReference : this._spatialReferenceTask.spatialReference;
  }
  get extent() {
    return this._extentTask.extent;
  }
  get heightModelInfo() {
    return this._heightModelInfoTask.heightModelInfo;
  }
  get vcsWkid() {
    return this._heightModelInfoTask.vcsWkid;
  }
  get latestVcsWkid() {
    return this._heightModelInfoTask.latestVcsWkid;
  }
  get viewingMode() {
    return H(this.userSpatialReference) || this.userSpatialReference.equals(this._spatialReferenceTask.spatialReference) ? this._spatialReferenceTask.viewingMode : null;
  }
  get tileInfo() {
    return this._tileInfoTask.tileInfo;
  }
  get mapCollections() {
    var t, n, r, i;
    const s = (t = this.map) == null ? void 0 : t.call(this), o = [];
    return O(this.priorityCollection) && o.push(this.priorityCollection), o.push({ parent: s == null ? void 0 : s.basemap, layers: s == null || (n = s.basemap) == null ? void 0 : n.baseLayers }, { layers: s == null ? void 0 : s.layers }, { parent: s == null ? void 0 : s.ground, layers: s == null || (r = s.ground) == null ? void 0 : r.layers }, { parent: s == null ? void 0 : s.basemap, layers: s == null || (i = s.basemap) == null ? void 0 : i.referenceLayers }), o;
  }
  get _allLayers() {
    var t, n;
    const r = this._collectLayers(this.mapCollections);
    return this._debug("Collected", (t = (n = r.layers) == null ? void 0 : n.length) != null ? t : 0, "layers, updating", r.updating), r;
  }
  get _spatialReferenceTask() {
    var t, n;
    if (this.suspended)
      return (n = this._get("_spatialReferenceTask")) != null ? n : { updating: !1 };
    const { layers: r, updating: i } = this._allLayers, s = { candidates: null };
    for (const a of r)
      if (this._processSpatialReferenceCandidates(a, s), s.candidates && s.candidates.length === 1)
        break;
    if (((t = s.candidates) == null ? void 0 : t.length) !== 1 && i)
      return { updating: !0 };
    const o = this._pickSpatialReferenceCandidate(s.candidates);
    return this._debug("Finished spatial reference", O(o) ? `${o.spatialReference.wkid}:${O(o.viewingMode) ? lN(o.viewingMode) : "global/local"}` : "none available"), { spatialReference: O(o) ? o.spatialReference : null, viewingMode: O(o) ? o.viewingMode : null, updating: !1 };
  }
  get _tileInfoTask() {
    var t, n, r, i, s, o, a, l;
    if (!this.required.tileInfo)
      return (l = this._get("_tileInfoTask")) != null ? l : { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const { layers: c, updating: p } = this._collectLayers([{ parent: (t = this.map) == null || (n = t.call(this)) == null ? void 0 : n.basemap, layers: (r = this.map) == null || (i = r.call(this)) == null || (s = i.basemap) == null ? void 0 : s.baseLayers }, { layers: (o = this.map) == null || (a = o.call(this)) == null ? void 0 : a.layers }]);
    if (c && c.length > 0 && "tileInfo" in c[0]) {
      const f = c[0].tileInfo;
      return { tileInfo: f && f.spatialReference.equals(this.spatialReference) ? f : null, updating: !1 };
    }
    return { updating: p };
  }
  get _heightModelInfoTask() {
    var t, n;
    if (!this.required.heightModelInfo || this.suspended && (t = this._get("_heightModelInfoTask")) != null && t.heightModelInfo)
      return (n = this._get("_heightModelInfoTask")) != null ? n : { updating: !1 };
    const { layers: r, updating: i } = this._allLayers;
    for (const c of r) {
      var s, o;
      if (this._debug("Considering", (s = (o = c.title) != null ? o : c.id) != null ? s : c.declaredClass, "for height model info"), Kme(c)) {
        const p = Jme(c);
        var a, l;
        if (p)
          return this._debug("Derived height model info", p), { heightModelInfo: p, vcsWkid: (a = c.spatialReference) == null ? void 0 : a.vcsWkid, latestVcsWkid: (l = c.spatialReference) == null ? void 0 : l.latestVcsWkid, updating: !1 };
      }
      this._debug("Layer does not support height models");
    }
    return this._debug("No height model info found,", "updating", i), { updating: i };
  }
  get _extentCandidatesTask() {
    var t;
    if (this.suspended || !this.required.extent)
      return (t = this._get("_extentCandidatesTask")) != null ? t : { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const n = this._allLayers, r = n.updating, i = [];
    for (const o of n.layers) {
      var s;
      const a = "fullExtents" in o && o.fullExtents || (O(o.fullExtent) ? [o.fullExtent] : []), l = this.requiresExtentInSpatialReference ? null : a[0], c = (s = a.find((p) => p.spatialReference.equals(this.spatialReference))) != null ? s : l;
      if (c)
        return { candidates: [{ extent: c, layer: o }], updating: !1 };
      if (this._getSupportedSpatialReferences(o).length > 0)
        for (const p of a)
          i.push({ extent: p, layer: o });
    }
    return { candidates: i, updating: r };
  }
  get _extentTask() {
    const { candidates: t, updating: n } = this._extentCandidatesTask;
    if (n)
      return { updating: n };
    if (H(t) || t.length === 0)
      return { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const r = this._pickExtentCandidate(t), i = this.spatialReference;
    return r.extent.equals(this._projectExtentTask.input) && i.equals(this._projectExtentTask.spatialReference) ? { extent: this._projectExtentTask.output, updating: O(this._projectExtentTask.task) && !this._projectExtentTask.task.finished } : (O(this._projectExtentTask.task) && (this._debug("Aborting project extent task"), this._projectExtentTask.task = E$(this._projectExtentTask.task)), this._debug("Starting project extent task for", r.extent), this._projectExtentTask = { input: r.extent.clone(), output: null, spatialReference: i.clone(), task: XD(async (s) => {
      try {
        const o = await GB(r.extent, i, r.layer.portalItem, s);
        this._debug("Project extent task finished", o), this._projectExtentTask = { ...this._projectExtentTask, task: null, output: o };
      } catch {
        if (Ea(s))
          return;
        this._projectExtentTask = { ...this._projectExtentTask, task: null };
      }
    }) }, { updating: !0 });
  }
  _processSpatialReferenceCandidates(t, n) {
    var r;
    const i = this._getSupportedSpatialReferences(t);
    if (i.length !== 0)
      if (this._debug("Spatial reference candidates from", (r = t.title) != null ? r : t.id, ":", i.map((s) => `${s.spatialReference.wkid}:${O(s.viewingMode) ? lN(s.viewingMode) : "global/local"}`).join(", ")), n.candidates) {
        const s = [], o = (a, l) => H(a.viewingMode) ? l.viewingMode : (H(l.viewingMode) || a.viewingMode === l.viewingMode) && a.viewingMode;
        for (const a of n.candidates)
          for (const l of i) {
            if (!a.spatialReference.equals(l.spatialReference))
              continue;
            const c = o(a, l);
            if (c !== !1) {
              s.push({ spatialReference: a.spatialReference, viewingMode: c });
              break;
            }
          }
        s.length > 0 && (n.candidates = s);
      } else
        n.candidates = i;
  }
  _pickSpatialReferenceCandidate(t) {
    const n = this.defaultSpatialReference;
    return !t || t.length < 1 ? O(n) ? { spatialReference: n, viewingMode: null } : null : (O(n) && t.length > 1 && t.some(({ spatialReference: r }) => r.equals(n)) && (t = t.filter(({ spatialReference: r }) => r.equals(n))), t.length > 1 && t.some(({ viewingMode: r }) => r !== Qg.Local) && (t = t.filter(({ viewingMode: r }) => r !== Qg.Local)), t[0]);
  }
  _getSupportedSpatialReferences(t) {
    const n = "supportedSpatialReferences" in t && t.supportedSpatialReferences || (t.spatialReference ? [t.spatialReference] : []);
    if (n.length === 0)
      return [];
    const r = [];
    for (const i of n) {
      const s = this.getSpatialReferenceSupport({ spatialReference: i, layer: t });
      if (O(s)) {
        const o = O(s.constraints) ? s.constraints : [{ spatialReference: i }];
        for (const { spatialReference: a, viewingMode: l } of o)
          (!this.requiresExtentInSpatialReference || H(this.userSpatialReference) || a.equals(this.userSpatialReference)) && r.push({ spatialReference: a, viewingMode: l });
      }
    }
    return r;
  }
  _pickExtentCandidate(t) {
    const n = this.spatialReference;
    return t.find(({ extent: r }) => n.equals(r.spatialReference)) || t[0];
  }
  _collectLayers(t) {
    var n;
    if (this._loadMaybe((n = this.map) == null ? void 0 : n.call(this)) !== "loaded")
      return { layers: [], updating: !0 };
    const r = { layers: [], preloading: -1, updating: !1 };
    for (const i of t)
      if (this._collectCollection(i, r), r.preloading === this.sourcePreloadCount)
        break;
    return { layers: r.layers, updating: r.updating };
  }
  _collectCollection(t, n) {
    if (t.layers) {
      switch (this._loadMaybe(t.parent)) {
        case "loading":
          return n.updating = !0, void ++n.preloading;
        case "failed":
          return;
      }
      for (const s of t.layers) {
        switch (this._loadMaybe(s)) {
          case "failed":
            continue;
          case "loading":
            n.updating = !0, ++n.preloading;
            break;
          case "loaded":
            var r, i;
            n.updating || (this._debug("Considering layer", (r = (i = s.title) != null ? i : s.id) != null ? r : s.declaredClass), n.layers.push(s)), "layers" in s && this._collectCollection({ layers: s.layers }, n);
        }
        if (n.preloading === this.sourcePreloadCount)
          break;
      }
    }
  }
  _loadMaybe(t) {
    return t && "loadStatus" in t ? t.loadStatus === "not-loaded" ? (this._debug("Triggering load", (n = (r = t.title) != null ? r : t.id) != null ? n : t.declaredClass), t.load(), "loading") : t.loadStatus : "loaded";
    var n, r;
  }
  _debug(...t) {
    this.logDebugInformation && WB.info(...t);
  }
};
u([d()], kt.prototype, "required", void 0), u([d({ constructOnly: !0 })], kt.prototype, "map", void 0), u([d({ constructOnly: !0 })], kt.prototype, "getSpatialReferenceSupport", void 0), u([d()], kt.prototype, "defaultSpatialReference", void 0), u([d()], kt.prototype, "userSpatialReference", void 0), u([d()], kt.prototype, "sourcePreloadCount", void 0), u([d()], kt.prototype, "priorityCollection", void 0), u([d()], kt.prototype, "logDebugInformation", void 0), u([d()], kt.prototype, "requiresExtentInSpatialReference", void 0), u([d()], kt.prototype, "suspended", void 0), u([d({ readOnly: !0 })], kt.prototype, "ready", null), u([d({ readOnly: !0 })], kt.prototype, "heightModelInfoReady", null), u([d({ readOnly: !0 })], kt.prototype, "spatialReference", null), u([d({ readOnly: !0 })], kt.prototype, "extent", null), u([d({ readOnly: !0 })], kt.prototype, "heightModelInfo", null), u([d({ readOnly: !0 })], kt.prototype, "vcsWkid", null), u([d({ readOnly: !0 })], kt.prototype, "latestVcsWkid", null), u([d({ readOnly: !0 })], kt.prototype, "viewingMode", null), u([d({ readOnly: !0 })], kt.prototype, "tileInfo", null), u([d({ readOnly: !0 })], kt.prototype, "mapCollections", null), u([d({ readOnly: !0 })], kt.prototype, "_allLayers", null), u([d({ readOnly: !0 })], kt.prototype, "_spatialReferenceTask", null), u([d({ readOnly: !0 })], kt.prototype, "_tileInfoTask", null), u([d({ readOnly: !0 })], kt.prototype, "_heightModelInfoTask", null), u([d({ readOnly: !0 })], kt.prototype, "_extentCandidatesTask", null), u([d()], kt.prototype, "_extentTask", null), u([d()], kt.prototype, "_projectExtentTask", void 0), kt = u([T("geoscene.views.support.DefaultsFromMap")], kt);
const Xme = kt;
var Ow;
const Wv = we.getLogger("geoscene.views.View");
let ze = Ow = class extends $p(mc.EventedMixin(Z_(ke))) {
  constructor(e) {
    super(e), this._userSpatialReference = null, this._cursor = null, this.allLayerViews = new tf({ getCollections: () => {
      var t, n, r;
      return [(t = this.basemapView) == null ? void 0 : t.baseLayerViews, (n = this.groundView) == null ? void 0 : n.layerViews, this.layerViews, (r = this.basemapView) == null ? void 0 : r.referenceLayerViews];
    }, getChildrenFunction: (t) => t.layerViews }), this.groundView = null, this.animation = null, this.basemapView = null, this.fatalError = null, this.extent = null, this.graphics = new Hd(), this.analyses = new a_(), this.navigating = !1, this.typeSpecificPreconditionsReady = !0, this.layerViews = new Ne(), this.magnifier = new RB(), this.padding = { left: 0, top: 0, right: 0, bottom: 0 }, this.ready = !1, this.spatialReferenceWarningDelay = 1e3, this.supportsGround = !0, this.timeExtent = null, this.type = null, this.scale = null, this.updating = !1, this.initialExtentRequired = !0, this.input = new Hme(), this.navigation = new zB(), this.layerViewManager = null, this.analysisViewManager = null, this.isHeightModelInfoRequired = !1, this.width = null, this.height = null, this.resizing = !1, this.suspended = !1, this.viewEvents = new Nme(this), this.persistableViewModels = new Ne(), this._isValid = !1, this._readyCycleForced = !1, this.handles.add(this.watch("preconditionsReady", (t) => {
      var n, r;
      t ? (this._currentSpatialReference = this.spatialReference, Ow.views.add(this)) : (this._currentSpatialReference = null, Ow.views.remove(this)), this.notifyChange("spatialReference"), !t && this.ready ? ((n = this.layerViewManager) == null || n.clear(), (r = this.toolViewManager) == null || r.detach(), O(this.analysisViewManager) && this.analysisViewManager.detach(), this._teardown()) : t && !this.ready && (O(this.analysisViewManager) && this.analysisViewManager.attach(), this._startup(), this.toolViewManager.attach());
    }, !0));
  }
  initialize() {
    this.addResolvingPromise(this.validate().then(() => (this._isValid = !0, mO(() => this.ready)))), this.basemapView = new Su({ view: this }), this.layerViewManager = new kme({ view: this, layerViewImporter: { importLayerView: (e) => this.importLayerView(e), hasLayerViewModule: (e) => this.hasLayerViewModule(e) }, supportsGround: this.supportsGround }), this.toolViewManager = new Ume({ view: this }), this._setupSpatialReferenceLogger(), this.handles.add([Nt(() => this.initialExtentRequired, (e) => this.defaultsFromMap.required = { ...this.defaultsFromMap.required, extent: e }, { sync: !0, initial: !0 }), Nt(() => this.ready, (e) => {
      this.defaultsFromMap && (this.defaultsFromMap.suspended = e, this.defaultsFromMap.userSpatialReference = e ? this.spatialReference : this._userSpatialReference);
    }, { sync: !0 }), Nt(() => this._userSpatialReference, (e) => {
      this.defaultsFromMap && (this.defaultsFromMap.userSpatialReference = e);
    }, { sync: !0, initial: !0 })]);
  }
  _setupSpatialReferenceLogger() {
    let e = null;
    this.handles.add([Nt(() => {
      var t;
      return (t = this.defaultsFromMap) == null ? void 0 : t.ready;
    }, (t) => {
      var n;
      const r = ((n = this.map) == null ? void 0 : n.allLayers.length) > 0;
      if (t && !this.spatialReference && r) {
        if (O(e))
          return;
        const i = Vf(() => e = E$(e));
        e = XD(async (s) => {
          try {
            await WC(this.spatialReferenceWarningDelay, null, s);
          } catch {
            return;
          } finally {
            e = null;
          }
          Wv.warn("#spatialReference", "no spatial reference could be derived from the currently added map layers");
        }), this.handles.add(i, "spatial-reference-logger-task");
      } else
        this.handles.remove("spatial-reference-logger-task");
    }, { sync: !0 })]);
  }
  destroy() {
    if (this.destroyed)
      return;
    this.viewEvents.destroy(), this.allLayerViews.destroy(), this.navigation && (this.navigation.destroy(), this._set("navigation", null)), this.graphics = pa(this.graphics), this.analyses = pa(this.analyses), this.handles.remove("defaultsFromMap"), this.defaultsFromMap.destroy(), this._set("defaultsFromMap", null), this.toolViewManager = pa(this.toolViewManager), this.layerViewManager = pa(this.layerViewManager), this.basemapView = pa(this.basemapView), this.invalidate(), this._emitter.clear(), this.handles.removeAll();
    const e = this.map;
    this.map = null, e == null || e.destroy();
  }
  _startup() {
    this._set("ready", !0);
  }
  _teardown() {
    this._set("ready", !1);
  }
  whenReady() {
    return Promise.resolve(this);
  }
  toMap() {
    return Wv.error("#toMap()", "Not implemented on this instance of View"), null;
  }
  get _defaultsFromMapSettings() {
    return {};
  }
  get defaultsFromMap() {
    return new Xme({ required: { tileInfo: !1, heightModelInfo: !1, extent: !1 }, map: () => this.map, getSpatialReferenceSupport: (e) => this.getSpatialReferenceSupport(e), ...this._defaultsFromMapSettings });
  }
  get heightModelInfo() {
    return this.getDefaultHeightModelInfo();
  }
  get interacting() {
    return this.navigating;
  }
  get preconditionsReady() {
    var e;
    return !(this.fatalError || !this._isValid || this._readyCycleForced || !this.map || Ol.isLoadable(this.map) && !this.map.loaded || this.width === 0 || this.height === 0 || !this.spatialReference || !this._validateSpatialReference(this.spatialReference) || !(this._currentSpatialReference || (e = this.defaultsFromMap) != null && e.ready) || !this.typeSpecificPreconditionsReady);
  }
  set map(e) {
    var t;
    e !== this._get("map") && ((t = e) != null && t.destroyed && (Wv.warn("#map", "The provided map is already destroyed", { map: e }), e = null), Ol.isLoadable(e) && e.load().catch(() => {
    }), this.initialized && (this.forceReadyCycle(), this._currentSpatialReference = null), this._set("map", e));
  }
  get spatialReference() {
    var e, t;
    let n = this._userSpatialReference || this._currentSpatialReference || this.getDefaultSpatialReference() || null;
    return n && (e = this.defaultsFromMap) != null && (t = e.required) != null && t.heightModelInfo && (n = n.clone(), n.vcsWkid = this.defaultsFromMap.vcsWkid, n.latestVcsWkid = this.defaultsFromMap.latestVcsWkid), n;
  }
  set spatialReference(e) {
    const t = !Oi(e, this._get("spatialReference"));
    this._set("_userSpatialReference", e), t && (this._set("spatialReference", e), this._spatialReferenceChanged(e));
  }
  _spatialReferenceChanged(e) {
  }
  get stationary() {
    return !this.animation && !this.navigating && !this.resizing;
  }
  get initialExtent() {
    var e;
    return (e = this.defaultsFromMap) == null ? void 0 : e.extent;
  }
  get cursor() {
    const e = this.toolViewManager ? this.toolViewManager.cursor : null;
    return O(e) ? e : this._cursor || "default";
  }
  set cursor(e) {
    this._cursor = e, this.notifyChange("cursor");
  }
  get size() {
    return [this.width, this.height];
  }
  whenLayerView(e) {
    return this.layerViewManager.whenLayerView(e);
  }
  getDefaultSpatialReference() {
    var e;
    return (e = this.defaultsFromMap) == null ? void 0 : e.spatialReference;
  }
  getDefaultHeightModelInfo() {
    var e, t, n;
    return (e = (t = this.map && "heightModelInfo" in this.map ? this.map.heightModelInfo : void 0) != null ? t : (n = this.defaultsFromMap) == null ? void 0 : n.heightModelInfo) != null ? e : null;
  }
  importLayerView(e) {
    throw new D("importLayerView() not implemented");
  }
  hasLayerViewModule(e) {
    return !1;
  }
  async validate() {
  }
  invalidate() {
    this._isValid = !1;
  }
  getSpatialReferenceSupport() {
    return {};
  }
  _validateSpatialReference(e) {
    return O(this.getSpatialReferenceSupport({ spatialReference: e }));
  }
  when(e, t) {
    return this.isResolved() && !this.ready && Wv.warn("#when()", "Calling view.when() while the view is no longer ready but was already resolved once will resolve immediately. Use reactiveUtils.whenOnce(() => view.ready).then(...) instead."), super.when(e, t);
  }
  forceReadyCycle() {
    this.ready && (rS(() => this.preconditionsReady === !1, () => this._readyCycleForced = !1, { once: !0 }), this._readyCycleForced = !0);
  }
  addAndActivateTool(e) {
    this.toolViewManager.tools.add(e), this.activeTool = e;
  }
  tryFatalErrorRecovery() {
    this.fatalError = null;
  }
};
ze.views = new Ne(), u([d()], ze.prototype, "_userSpatialReference", void 0), u([Le("toolViewManager.activeTool")], ze.prototype, "activeTool", void 0), u([d({ readOnly: !0 })], ze.prototype, "allLayerViews", void 0), u([d()], ze.prototype, "groundView", void 0), u([d()], ze.prototype, "animation", void 0), u([d()], ze.prototype, "basemapView", void 0), u([d({ readOnly: !0 })], ze.prototype, "_defaultsFromMapSettings", null), u([d()], ze.prototype, "defaultsFromMap", null), u([d()], ze.prototype, "fatalError", void 0), u([d({ type: Mt })], ze.prototype, "extent", void 0), u([d(CM(Hd, "graphics"))], ze.prototype, "graphics", void 0), u([d(CM(a_, "analyses"))], ze.prototype, "analyses", void 0), u([d({ readOnly: !0, type: OS })], ze.prototype, "heightModelInfo", null), u([d({ readOnly: !0 })], ze.prototype, "interacting", null), u([d({ readOnly: !0 })], ze.prototype, "navigating", void 0), u([d({ readOnly: !0, dependsOn: ["fatalError", "_isValid", "_readyCycleForced", "map", "map.loaded?", "width", "height", "spatialReference", "_currentSpatialReference", "defaultsFromMap.ready", "typeSpecificPreconditionsReady"] })], ze.prototype, "preconditionsReady", null), u([d({ readOnly: !0 })], ze.prototype, "typeSpecificPreconditionsReady", void 0), u([d({ type: Ne, readOnly: !0 })], ze.prototype, "layerViews", void 0), u([d({ type: RB })], ze.prototype, "magnifier", void 0), u([d({ value: null, type: k6 })], ze.prototype, "map", null), u([d()], ze.prototype, "padding", void 0), u([d({ readOnly: !0 })], ze.prototype, "ready", void 0), u([d({ type: Qe })], ze.prototype, "spatialReference", null), u([d()], ze.prototype, "spatialReferenceWarningDelay", void 0), u([d()], ze.prototype, "stationary", null), u([d({ readOnly: !0 })], ze.prototype, "supportsGround", void 0), u([d({ type: La })], ze.prototype, "timeExtent", void 0), u([Le("toolViewManager.tools")], ze.prototype, "tools", void 0), u([d()], ze.prototype, "toolViewManager", void 0), u([d({ readOnly: !0 })], ze.prototype, "type", void 0), u([d({ type: Number })], ze.prototype, "scale", void 0), u([d({ readOnly: !0 })], ze.prototype, "updating", void 0), u([d({ readOnly: !0 })], ze.prototype, "initialExtentRequired", void 0), u([d({ readOnly: !0 })], ze.prototype, "initialExtent", null), u([d()], ze.prototype, "cursor", null), u([d({ readOnly: !0 })], ze.prototype, "input", void 0), u([d({ type: zB, nonNullable: !0 })], ze.prototype, "navigation", void 0), u([d()], ze.prototype, "layerViewManager", void 0), u([d()], ze.prototype, "analysisViewManager", void 0), u([d()], ze.prototype, "width", void 0), u([d()], ze.prototype, "height", void 0), u([d({ readOnly: !0 })], ze.prototype, "resizing", void 0), u([d({ value: null, readOnly: !0 })], ze.prototype, "size", null), u([d({ readOnly: !0 })], ze.prototype, "suspended", void 0), u([d({ readOnly: !0 })], ze.prototype, "viewEvents", void 0), u([d({ readOnly: !0 })], ze.prototype, "persistableViewModels", void 0), u([d()], ze.prototype, "_isValid", void 0), u([d()], ze.prototype, "_readyCycleForced", void 0), u([d()], ze.prototype, "_currentSpatialReference", void 0), ze = Ow = u([T("geoscene.views.View")], ze);
const eye = ze;
let $u = class extends m1 {
  constructor(t) {
    super(t), this.state = "running", this.target = null;
  }
  initialize() {
    this.addResolvingPromise(new Promise((t, n) => this._dfd = { resolve: t, reject: n }));
  }
  get done() {
    return this.state === "finished" || this.state === "stopped";
  }
  stop() {
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "stopped"), this._dfd.reject(new D("ViewAnimation stopped")));
  }
  finish() {
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "finished"), this._dfd.resolve());
  }
  update(t, n) {
    n || (n = Fl(t) ? "waiting-for-target" : "running"), this._set("target", t), this._set("state", n);
  }
};
u([d({ readOnly: !0 })], $u.prototype, "done", null), u([d({ readOnly: !0, type: String })], $u.prototype, "state", void 0), u([d()], $u.prototype, "target", void 0), $u = u([T("geoscene.views.ViewAnimation")], $u), function(e) {
  e.State = { RUNNING: "running", STOPPED: "stopped", FINISHED: "finished", WAITING_FOR_TARGET: "waiting-for-target" };
}($u || ($u = {}));
const PM = $u;
function _d(e, t, n, r) {
  const i = 3 * e, s = 3 * (n - e) - i, o = 1 - i - s, a = 3 * t, l = 3 * (r - t) - a, c = 1 - a - l;
  function p(g) {
    return ((o * g + s) * g + i) * g;
  }
  function f(g) {
    return ((c * g + l) * g + a) * g;
  }
  function m(g) {
    return (3 * o * g + 2 * s) * g + i;
  }
  function y(g, v) {
    let w, b, S, $, I, M;
    for (S = g, M = 0; M < 8; M++) {
      if ($ = p(S) - g, Math.abs($) < v)
        return S;
      if (I = m(S), Math.abs(I) < 1e-6)
        break;
      S -= $ / I;
    }
    if (w = 0, b = 1, S = g, S < w)
      return w;
    if (S > b)
      return b;
    for (; w < b; ) {
      if ($ = p(S), Math.abs($ - g) < v)
        return S;
      g > $ ? w = S : b = S, S = 0.5 * (b - w) + w;
    }
    return S;
  }
  return function(g, v = 1e-6) {
    return f(y(g, v));
  };
}
const tye = /^cubic-bezier\((.*)\)/, Os = {};
function nye(e) {
  let t = Os[e] || null;
  if (!t) {
    const n = tye.exec(e);
    if (n) {
      const r = n[1].split(",").map((i) => parseFloat(i.trim()));
      r.length !== 4 || r.some((i) => isNaN(i)) || (t = _d.apply(_d, r));
    }
  }
  return t;
}
Os.ease = _d(0.25, 0.1, 0.25, 1), Os.linear = _d(0, 0, 1, 1), Os.easeIn = Os["ease-in"] = _d(0.42, 0, 1, 1), Os.easeOut = Os["ease-out"] = _d(0, 0, 0.58, 1), Os.easeInOut = Os["ease-in-out"] = _d(0.42, 0, 0.58, 1);
function HB(e, t) {
  const n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], a = t[5];
  let l = n * s - r * i;
  return l ? (l = 1 / l, e[0] = s * l, e[1] = -r * l, e[2] = -i * l, e[3] = n * l, e[4] = (i * a - s * o) * l, e[5] = (r * o - n * a) * l, e) : null;
}
function NNe(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = n[0], p = n[1], f = n[2], m = n[3], y = n[4], g = n[5];
  return e[0] = r * c + s * p, e[1] = i * c + o * p, e[2] = r * f + s * m, e[3] = i * f + o * m, e[4] = r * y + s * g + a, e[5] = i * y + o * g + l, e;
}
function t3(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = Math.sin(n), p = Math.cos(n);
  return e[0] = r * p + s * c, e[1] = i * p + o * c, e[2] = r * -c + s * p, e[3] = i * -c + o * p, e[4] = a, e[5] = l, e;
}
function JB(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = n[0], p = n[1];
  return e[0] = r * c, e[1] = i * c, e[2] = s * p, e[3] = o * p, e[4] = a, e[5] = l, e;
}
function u_(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = n[0], p = n[1];
  return e[0] = r, e[1] = i, e[2] = s, e[3] = o, e[4] = r * c + s * p + a, e[5] = i * c + o * p + l, e;
}
function rye(e, t) {
  const n = Math.sin(t), r = Math.cos(t);
  return e[0] = r, e[1] = n, e[2] = -n, e[3] = r, e[4] = 0, e[5] = 0, e;
}
function iye(e, t) {
  return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e;
}
function ZB(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e;
}
function Jd() {
  return [1, 0, 0, 1, 0, 0];
}
function c_(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function vr(e, t, n) {
  return e[0] = t, e[1] = n, e;
}
function sye(e, t, n) {
  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e;
}
function d_(e, t, n) {
  return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e;
}
function RS(e, t, n) {
  return e[0] = t[0] * n, e[1] = t[1] * n, e;
}
function n3(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1];
  return Math.sqrt(n * n + r * r);
}
function uN(e, t) {
  const n = t[0] - e[0], r = t[1] - e[1];
  return n * n + r * r;
}
function cN(e) {
  const t = e[0], n = e[1];
  return Math.sqrt(t * t + n * n);
}
function oye(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e;
}
function dN(e, t) {
  const n = t[0], r = t[1];
  let i = n * n + r * r;
  return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i), e;
}
function aye(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function lye(e, t, n) {
  const r = t[0] * n[1] - t[1] * n[0];
  return e[0] = e[1] = 0, e[2] = r, e;
}
function yl(e, t, n) {
  const r = t[0], i = t[1];
  return e[0] = n[0] * r + n[2] * i + n[4], e[1] = n[1] * r + n[3] * i + n[5], e;
}
const KB = d_;
function Xn() {
  return [0, 0];
}
function uye(e, t) {
  return [e, t];
}
function DNe(e, t) {
  return new Float64Array(e, t, 2);
}
const YB = 96, QB = 39.37, cye = 180 / Math.PI;
function XB(e) {
  return e.wkid ? e : e.spatialReference || Qe.WGS84;
}
function r3(e, t) {
  return t.type ? vr(e, t.x, t.y) : c_(e, t);
}
function eU(e) {
  return E0(e);
}
function fg(e, t) {
  return Math.max(e.width / t[0], e.height / t[1]) * bye(e.spatialReference);
}
async function zy(e, t, n, r) {
  let i, s;
  if (!e || Array.isArray(e) && !e.length)
    return null;
  if (Ne.isCollection(e) && (e = e.toArray()), Array.isArray(e) && e.length && typeof e[0] == "object") {
    const a = e.every((p) => "attributes" in p), l = e.some((p) => !p.geometry);
    let c = e;
    if (a && l && t && t.allLayerViews) {
      const p = /* @__PURE__ */ new Map();
      for (const g of e) {
        const v = g.layer, w = p.get(v) || [], b = g.attributes[v.objectIdField];
        b != null && w.push(b), p.set(v, w);
      }
      const f = [];
      p.forEach((g, v) => {
        const w = t.allLayerViews.find((b) => b.layer.id === v.id);
        if ("queryFeatures" in w) {
          const b = v.createQuery();
          b.objectIds = g, b.returnGeometry = !0, f.push(w.queryFeatures(b));
        }
      });
      const m = await Promise.all(f), y = [];
      for (const g of m)
        if (g && g.features && g.features.length)
          for (const v of g.features)
            O(v.geometry) && y.push(v.geometry);
      c = y;
    }
    for (const p of c)
      r = await zy(p, t, n, r);
    return r;
  }
  if (Array.isArray(e) && e.length === 2 && typeof e[0] == "number" && typeof e[1] == "number")
    i = new Oe(e);
  else if (e instanceof Ci)
    i = e;
  else if ("geometry" in e) {
    if (e.geometry)
      i = e.geometry;
    else if (e.layer) {
      const a = e.layer, l = t.allLayerViews.find((c) => c.layer.id === a.id);
      if ("queryFeatures" in l) {
        const c = a.createQuery();
        c.objectIds = [e.attributes[a.objectIdField]], c.returnGeometry = !0;
        const p = await l.queryFeatures(c);
        i = _D(p, "features", 0, "geometry");
      }
    }
  }
  if (H(i) || (s = i.type === "point" ? new Mt({ xmin: i.x, ymin: i.y, xmax: i.x, ymax: i.y, spatialReference: i.spatialReference }) : i.extent, !s))
    return null;
  wf() || cp(s.spatialReference, n) || await _f();
  const o = I0(s, n);
  return o ? r = r ? r.union(o) : o : null;
}
function dye(e) {
  if (e && (!Array.isArray(e) || typeof e[0] != "number") && (typeof e == "object" || Array.isArray(e) && typeof e[0] == "object")) {
    if ("layer" in e && e.layer && e.layer.minScale && e.layer.maxScale) {
      const t = e.layer;
      return { min: t.minScale, max: t.maxScale };
    }
    if (Array.isArray(e) && e.length && e.every((t) => "layer" in t)) {
      let t = 0, n = 0;
      for (const r of e) {
        const i = r.layer;
        i && i.minScale && i.maxScale && (t = i.minScale < t ? i.minScale : t, n = i.maxScale > n ? i.maxScale : n);
      }
      return t && n ? { min: t, max: n } : null;
    }
  }
}
function Nx(e, t) {
  return Oi(XB(e), t) ? e : I0(e, t);
}
async function pye(e, t) {
  if (!e || !t)
    return new ba({ targetGeometry: new Oe(), scale: 0, rotation: 0 });
  let n = t.spatialReference;
  const { constraints: r, padding: i, viewpoint: s, size: o } = t, a = [i ? o[0] - i.left - i.right : o[0], i ? o[1] - i.top - i.bottom : o[1]];
  let l = null;
  e instanceof ba ? l = e : e.viewpoint ? l = e.viewpoint : e.target && e.target.declaredClass === "geoscene.Viewpoint" && (l = e.target);
  let c = null;
  l && l.targetGeometry ? c = l.targetGeometry : e instanceof Mt ? c = e : (e || e && ("center" in e || "extent" in e || "target" in e)) && (c = await zy(e.center, t, n) || await zy(e.extent, t, n) || await zy(e.target, t, n) || await zy(e, t, n)), !c && s && s.targetGeometry ? c = s.targetGeometry : !c && t.extent && (c = t.extent), n || (n = XB(t.spatialReference || t.extent || c)), wf() || Oi(c.spatialReference, n) || cp(c, n) || await _f();
  const p = Nx(c.center ? c.center : c, n);
  let f = null;
  if (l && O(l.targetGeometry) && l.targetGeometry.type === "point")
    f = l.scale;
  else if ("scale" in e && e.scale)
    f = e.scale;
  else if ("zoom" in e && e.zoom !== -1 && r && r.effectiveLODs)
    f = r.zoomToScale(e.zoom);
  else if (Array.isArray(c) || c.type === "point" || c.type === "extent" && c.width === 0 && c.height === 0) {
    const v = Nx(t.extent, n);
    f = O(v) ? fg(v, a) : t.extent ? fg(t.extent, a) : s.scale;
  } else
    f = fg(Nx(c.extent, n), a);
  const m = dye(e);
  m && (m.min && m.min > f ? f = m.min : m.max && m.max < f && (f = m.max));
  let y = 0;
  l ? y = l.rotation : e.hasOwnProperty("rotation") ? y = e.rotation : s && (y = s.rotation);
  let g = new ba({ targetGeometry: p, scale: f, rotation: y });
  return r && (g = r.fit(g), r.constrainByGeometry(g), r.rotationEnabled || (g.rotation = y)), g;
}
function jo(e, t) {
  const n = e.targetGeometry, r = t.targetGeometry;
  return n.x = r.x, n.y = r.y, n.spatialReference = r.spatialReference, e.scale = t.scale, e.rotation = t.rotation, e;
}
function hye(e, t, n) {
  return n ? vr(e, 0.5 * (t[0] - n.right + n.left), 0.5 * (t[1] - n.bottom + n.top)) : RS(e, t, 0.5);
}
const fye = function() {
  const e = Xn();
  return function(t, n, r) {
    const i = n.targetGeometry;
    r3(e, i);
    const s = 0.5 * sm(n);
    return t.xmin = e[0] - s * r[0], t.ymin = e[1] - s * r[1], t.xmax = e[0] + s * r[0], t.ymax = e[1] + s * r[1], t.spatialReference = i.spatialReference, t;
  };
}();
function mye(e, t, n, r, i) {
  return RM(e, t, n.center), e.scale = fg(n, r), i && i.constraints && i.constraints.constrain(e), e;
}
function yye(e, t, n, r) {
  return o3(e, t, n, r), HB(e, e);
}
const tU = function() {
  const e = Xn();
  return function(t, n, r) {
    return KB(t, wye(t, n), hye(e, n, r));
  };
}(), gye = function() {
  const e = Jd(), t = Xn();
  return function(n, r, i, s) {
    const o = sm(r), a = i3(r);
    return vr(t, o, o), iye(e, t), t3(e, e, a), u_(e, e, tU(t, i, s)), u_(e, e, [0, s.top - s.bottom]), vr(n, e[4], e[5]);
  };
}();
function sm(e) {
  return e.scale * vye(e.targetGeometry);
}
function vye(e) {
  return O(e) && Mi(e.spatialReference) ? 1 / (eU(e.spatialReference) * QB * YB) : 1;
}
function i3(e) {
  return d6(e.rotation) || 0;
}
function bye(e) {
  return Mi(e) ? eU(e) * QB * YB : 1;
}
function wye(e, t) {
  return RS(e, t, 0.5);
}
const s3 = function() {
  const e = Xn(), t = Xn(), n = Xn();
  return function(r, i, s, o, a, l) {
    return oye(e, i), RS(t, s, 0.5 * l), vr(n, 1 / o * l, -1 / o * l), ZB(r, t), a && t3(r, r, a), JB(r, r, n), u_(r, r, e), r;
  };
}(), o3 = function() {
  const e = Xn();
  return function(t, n, r, i) {
    const s = sm(n), o = i3(n);
    return r3(e, n.targetGeometry), s3(t, e, r, s, o, i);
  };
}(), _ye = function() {
  const e = Xn();
  return function(t, n, r, i) {
    const s = sm(n);
    return r3(e, n.targetGeometry), s3(t, e, r, s, 0, i);
  };
}();
function Sye(e) {
  if (e.isWrappable) {
    const t = Oo(e);
    return t.valid[1] - t.valid[0];
  }
  return 0;
}
function xye(e, t) {
  return Math.round(Sye(e) / t);
}
const $ye = function() {
  const e = Xn(), t = Xn(), n = [0, 0, 0];
  return function(r, i, s) {
    d_(e, r, i), dN(e, e), d_(t, r, s), dN(t, t), lye(n, e, t);
    let o = Math.acos(aye(e, t) / (cN(e) * cN(t))) * cye;
    return n[2] < 0 && (o = -o), isNaN(o) && (o = 0), o;
  };
}(), Tye = function() {
  const e = Xn();
  return function(t, n, r, i) {
    const s = t.targetGeometry;
    return jo(t, n), gye(e, n, r, i), s.x += e[0], s.y += e[1], t;
  };
}(), RM = function(e, t, n) {
  jo(e, t);
  const r = e.targetGeometry;
  return r.x = n.x, r.y = n.y, r.spatialReference = n.spatialReference, e;
}, Eye = function() {
  const e = Xn();
  return function(t, n, r, i, s) {
    s || (s = "center"), KB(e, r, i), RS(e, e, 0.5);
    const o = e[0], a = e[1];
    switch (s) {
      case "center":
        vr(e, 0, 0);
        break;
      case "left":
        vr(e, -o, 0);
        break;
      case "top":
        vr(e, 0, a);
        break;
      case "right":
        vr(e, o, 0);
        break;
      case "bottom":
        vr(e, 0, -a);
        break;
      case "top-left":
        vr(e, -o, a);
        break;
      case "bottom-left":
        vr(e, -o, -a);
        break;
      case "top-right":
        vr(e, o, a);
        break;
      case "bottom-right":
        vr(e, o, -a);
    }
    return LS(t, n, e), t;
  };
}();
function jNe(e, t, n) {
  return jo(e, t), e.rotation += n, e;
}
function Iye(e, t, n) {
  return jo(e, t), e.rotation = n, e;
}
const Mye = function() {
  const e = Xn();
  return function(t, n, r, i, s) {
    return jo(t, n), isNaN(r) || r === 0 || (rU(e, i, n, s), t.scale = n.scale * r, iU(e, e, t, s), LS(t, t, vr(e, e[0] - i[0], i[1] - e[1]))), t;
  };
}();
function pN(e, t, n) {
  return jo(e, t), e.scale = n, e;
}
const nU = function() {
  const e = Xn();
  return function(t, n, r, i, s, o) {
    return jo(t, n), isNaN(r) || r === 0 || (rU(e, s, n, o), t.scale = n.scale * r, t.rotation += i, iU(e, e, t, o), LS(t, t, vr(e, e[0] - s[0], s[1] - e[1]))), t;
  };
}(), VNe = function() {
  const e = Xn(), t = Xn();
  return function(n, r, i, s, o, a, l) {
    return tU(t, a, l), sye(e, o, t), s ? nU(n, r, i, s, e, a) : Mye(n, r, i, e, a);
  };
}(), rU = function() {
  const e = Jd();
  return function(t, n, r, i) {
    return yl(t, n, yye(e, r, i, 1));
  };
}(), iU = function() {
  const e = Jd();
  return function(t, n, r, i) {
    return yl(t, n, o3(e, r, i, 1));
  };
}(), LS = function() {
  const e = Xn(), t = Jd();
  return function(n, r, i) {
    jo(n, r);
    const s = sm(r), o = n.targetGeometry;
    return rye(t, i3(r)), JB(t, t, uye(s, s)), yl(e, i, t), o.x += e[0], o.y += e[1], n;
  };
}();
let Cye = class {
  constructor(t, n, r, i) {
    const s = t.targetGeometry, o = n.targetGeometry;
    i ? typeof i == "string" && (i = nye(i) || Os.ease) : i = Os.ease, this.easing = i, this.duration = r, this.sCenterX = s.x, this.sCenterY = s.y, this.sScale = t.scale, this.sRotation = t.rotation, this.tCenterX = o.x, this.tCenterY = o.y, this.tScale = n.scale, this.tRotation = n.rotation, this.dCenterX = this.tCenterX - this.sCenterX, this.dCenterY = this.tCenterY - this.sCenterY, this.dScale = this.tScale - this.sScale, this.dRotation = this.tRotation - this.sRotation, this.dRotation > 180 ? this.dRotation -= 360 : this.dRotation < -180 && (this.dRotation += 360);
  }
  applyRatio(t, n) {
    const r = this.easing(n);
    let i, s, o, a;
    n >= 1 ? (i = this.tCenterX, s = this.tCenterY, o = this.tRotation, a = this.tScale) : (i = this.sCenterX + r * this.dCenterX, s = this.sCenterY + r * this.dCenterY, o = this.sRotation + r * this.dRotation, a = this.sScale + r * this.dScale), t.targetGeometry.x = i, t.targetGeometry.y = s, t.scale = a, t.rotation = o;
  }
}, al = class extends ke {
  constructor(t) {
    super(t), this.duration = 200, this.transition = null, this.easing = Os.ease, this.view = null, this.viewpoint = null, this.viewpoint = new ba({ targetGeometry: new Oe(), scale: 0, rotation: 0 }), this._updateTask = df({ postRender: this._postRender.bind(this) }), this._updateTask.pause();
  }
  destroy() {
    this._updateTask.remove(), this._updateTask = null;
  }
  animate(t, n, r) {
    this.stop();
    const i = this.viewpoint;
    jo(i, n), this.transition = new Cye(this.viewpoint, t.target, r && r.duration || this.duration, r && r.easing || this.easing);
    const s = () => {
      this.animation === t && this._updateTask && (t.state === "finished" && (this.transition.applyRatio(this.viewpoint, 1), this.view.state && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t.when(s, s), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t, t;
  }
  animateContinous(t, n) {
    this.stop(), this.updateFunction = n, this.viewpoint = t;
    const r = new PM({ target: t.clone() }), i = () => {
      this.animation === r && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return r.when(i, i), this._startTime = performance.now(), this._updateTask.resume(), this.animation = r, r;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t) {
    const n = this.animation;
    if (n && n.state !== PM.State.STOPPED) {
      if (this.updateFunction)
        this.updateFunction(this.viewpoint, t.deltaTime);
      else {
        const r = (performance.now() - this._startTime) / this.transition.duration, i = r >= 1;
        this.transition.applyRatio(this.viewpoint, r), i && this.animation.finish();
      }
      this.view.state && (this.view.state.viewpoint = this.viewpoint.clone());
    } else
      this._updateTask.pause();
  }
};
u([d()], al.prototype, "animation", void 0), u([d()], al.prototype, "duration", void 0), u([d()], al.prototype, "transition", void 0), u([d()], al.prototype, "easing", void 0), u([d()], al.prototype, "view", void 0), u([d()], al.prototype, "viewpoint", void 0), al = u([T("geoscene.views.2d.AnimationManager")], al);
const Oye = al;
let kye = class {
  constructor(t) {
    this.view = t, this._frameTaskHandle = null, this._updateRequested = !1, this.stationary = !0, this.animationInProgress = !1, this.prepare = () => {
      this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions;
    }, this.update = () => {
      this._updateRequested = !1;
      const { basemapView: n, graphicsView: r, labelManager: i, layerViews: s, state: { id: o } } = this.view;
      n.baseLayerViews.forEach(this._updateLayerView, this), s.forEach(this._updateLayerView, this), n.referenceLayerViews.forEach(this._updateLayerView, this), O(i) && (i.lastUpdateId !== o && (i.viewChange(), i.lastUpdateId = o), i.updateRequested && i.processUpdate(this._updateParameters)), O(r) && (r.lastUpdateId !== o && (r.viewChange(), r.lastUpdateId = o), r.updateRequested && r.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || this._frameTaskHandle.pause();
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    this._frameTaskHandle || (this.stationary = this.view.stationary, this._updateParameters = { state: this.view.state, pixelRatio: window.devicePixelRatio, stationary: this.stationary, renderingOptions: this.view.renderingOptions }, this._stationaryHandle = this.view.watch("stationary", (t) => {
      this.stationary = t, this.requestFrame();
    }), this._frameTaskHandle = df(this), this.requestUpdate());
  }
  stop() {
    this._frameTaskHandle && (this._updateRequested = !1, this._stationaryHandle.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = !0, this.animationInProgress = !1);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = !0, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(t) {
    const n = this.view.state, r = t.lastUpdateId;
    r != null && (this.stationary || t.moving) || (t.moving = !0, t.moveStart()), r !== n.id && t.viewChange(), this.stationary && t.moving && (t.moving = !1, t.moveEnd()), t.lastUpdateId = n.id, t.updateRequested && t.processUpdate(this._updateParameters), "layerViews" in t && t.layerViews.forEach(this._updateLayerView, this);
  }
};
function Zn() {
  return Promise.all([import("./webglDeps-w3kmhubo.js"), import("./mapViewDeps-9h4i8lEV.js")]);
}
const Fm = () => Zn().then(() => import("./TileLayerView2D-A7O_FVhu.js")), Hv = () => Zn().then(() => import("./FeatureLayerView2D-uPKEZCL1.js")), hN = { "base-dynamic": () => Zn().then(() => import("./BaseDynamicLayerView2D-vEIIElUF.js")), "base-tile": Fm, "bing-maps": Fm, csv: Hv, "geo-rss": () => Zn().then(() => import("./GeoRSSLayerView2D-gXhPRDCk.js")), feature: Hv, geojson: Hv, graphics: () => Zn().then(() => import("./GraphicsLayerView2D-rjmV1NOY.js")), group: () => Zn().then(() => import("./GroupLayerView2D-zzPZkdcw.js")), imagery: () => Zn().then(() => import("./ImageryLayerView2D-4gAaqGEa.js")), "imagery-tile": () => Zn().then(() => import("./ImageryTileLayerView2D-arn4YXQj.js")), kml: () => Zn().then(() => import("./KMLLayerView2D-0-RjIPM_.js")), "map-image": () => Zn().then(() => import("./MapImageLayerView2D-t5GnhLZ-.js")), "map-notes": () => Zn().then(() => import("./MapNotesLayerView2D-We_-oL4O.js")), "ogc-feature": () => Zn().then(() => import("./OGCFeatureLayerView2D-vW5IAj6l.js")), "open-street-map": Fm, route: () => Zn().then(() => import("./RouteLayerView2D-RIrQ5mWH.js")), stream: () => Zn().then(() => import("./StreamLayerView2D-LecnWYq5.js")), "subtype-group": () => Zn().then(() => import("./SubtypeGroupLayerView2D-psHxBtlY.js")), tile: Fm, "vector-tile": () => Zn().then(() => import("./VectorTileLayerView2D-yASWZyOT.js")), wcs: () => Zn().then(() => import("./ImageryTileLayerView2D-arn4YXQj.js")), "web-tile": Fm, wfs: Hv, wms: () => Zn().then(() => import("./WMSLayerView2D-CKaMy-JO.js")), wmts: () => Zn().then(() => import("./WMTSLayerView2D-9cC7hKRJ.js")), analysis: null, "base-elevation": null, "building-scene": null, elevation: null, "integrated-mesh": null, "point-cloud": null, voxel: null, scene: null, unknown: null, unsupported: null };
function Aye(e) {
  const t = e.declaredClass ? e.declaredClass.slice(e.declaredClass.lastIndexOf(".") + 1) : "Unknown", n = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new D(`${n}:view-not-supported`, `${t} is not supported in 2D`);
}
const fN = { hasLayerViewModule: (e) => O(hN[e.type]), importLayerView: (e) => {
  const t = hN[e.type];
  if (!O(t))
    throw Aye(e);
  return t(e);
} };
function Pye(e, t) {
  const { spatialReference: n } = t, r = [t.x, t.y];
  let i = Number.POSITIVE_INFINITY, s = 0, o = 0;
  const a = [0, 0], l = e.type === "extent" ? [[[e.xmin, e.ymin], [e.xmin, e.ymax], [e.xmax, e.ymax], [e.xmax, e.ymin], [e.xmin, e.ymin]]] : e.rings;
  for (const c of l)
    for (let p = 0; p < c.length - 1; p++) {
      MQ(a, r, c, p);
      const f = n3(r, a);
      f < i && (i = f, s = a[0], o = a[1]);
    }
  return { coordinate: new Oe({ x: s, y: o, spatialReference: n }), distance: i };
}
var LM;
const Rye = we.getLogger("geoscene.views.MapView");
let Sd = LM = class extends ke {
  constructor(e) {
    super(e), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (H(this.geometry) || !this.spatialReference)
      return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference))
      try {
        return I0(this.geometry, this.spatialReference);
      } catch (e) {
        return Rye.error("#constraints.geometry", "could not project the geometry to the view's spatial reference", { geometry: this.geometry, spatialReference: this.spatialReference, error: e }), null;
      }
    return this.geometry;
  }
  constrain(e, t) {
    if (H(this.normalizedGeometry))
      return e;
    const n = e.targetGeometry;
    if (this.normalizedGeometry.type === "extent" ? nS(this.normalizedGeometry, n) : e6(this.normalizedGeometry, n))
      return e;
    const { coordinate: r } = Pye(this.normalizedGeometry, n);
    return r && (e.targetGeometry = r), e;
  }
  clone() {
    var e, t;
    return new LM({ geometry: (e = this.geometry) == null ? void 0 : e.clone(), spatialReference: (t = this.spatialReference) == null ? void 0 : t.clone() });
  }
};
u([d({ constructOnly: !0 })], Sd.prototype, "geometry", void 0), u([d({ readOnly: !0 })], Sd.prototype, "normalizedGeometry", null), u([d({ constructOnly: !0 })], Sd.prototype, "spatialReference", void 0), Sd = LM = u([T("geoscene.views.2d.constraints.GeometryConstraint")], Sd);
var FM;
let By = FM = class extends ke {
  constructor() {
    super(...arguments), this.enabled = !0, this.rotationEnabled = !0;
  }
  constrain(e, t) {
    return this.enabled && t && (this.rotationEnabled || (e.rotation = t.rotation)), e;
  }
  clone() {
    return new FM({ enabled: this.enabled, rotationEnabled: this.rotationEnabled });
  }
};
u([d()], By.prototype, "enabled", void 0), u([d()], By.prototype, "rotationEnabled", void 0), By = FM = u([T("geoscene.views.2d.constraints.RotationConstraint")], By);
const sU = By;
var NM;
let mi = NM = class extends ke {
  constructor(e) {
    super(e), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = !0;
  }
  initialize() {
    let e, { lods: t, minScale: n, maxScale: r, minZoom: i, maxZoom: s } = this, o = -1, a = -1, l = !1, c = !1;
    if (n !== 0 && r !== 0 && n < r && ([n, r] = [r, n]), !t || !t.length)
      return this._set("effectiveMinScale", n), void this._set("effectiveMaxScale", r);
    t = t.map((p) => p.clone()), t.sort((p, f) => f.scale - p.scale), t.forEach((p, f) => p.level = f);
    for (const p of t)
      !l && n > 0 && n >= p.scale && (o = p.level, l = !0), !c && r > 0 && r >= p.scale && (a = e ? e.level : -1, c = !0), e = p;
    i === -1 && (i = n === 0 ? 0 : o), s === -1 && (s = r === 0 ? t.length - 1 : a), i = Math.max(i, 0), i = Math.min(i, t.length - 1), s = Math.max(s, 0), s = Math.min(s, t.length - 1), i > s && ([i, s] = [s, i]), n = t[i].scale, r = t[s].scale, t.splice(0, i), t.splice(s - i + 1, t.length), t.forEach((p, f) => {
      this._lodByScale[p.scale] = p, this._scales[f] = p.scale;
    }), this._set("effectiveLODs", t), this._set("effectiveMinZoom", i), this._set("effectiveMaxZoom", s), this._set("effectiveMinScale", n), this._set("effectiveMaxScale", r);
  }
  constrain(e, t) {
    if (t && e.scale === t.scale)
      return e;
    const n = this.effectiveMinScale, r = this.effectiveMaxScale, i = e.targetGeometry, s = t && t.targetGeometry, o = r !== 0 && e.scale < r, a = n !== 0 && e.scale > n;
    if (o || a) {
      const l = a ? n : r;
      if (s) {
        const c = (l - t.scale) / (e.scale - t.scale);
        i.x = s.x + (i.x - s.x) * c, i.y = s.y + (i.y - s.y) * c;
      }
      e.scale = l;
    }
    return this.snapToZoom && this.effectiveLODs && (e.scale = this._getClosestScale(e.scale)), e;
  }
  fit(e) {
    if (!this.effectiveLODs || !this.snapToZoom)
      return this.constrain(e, null);
    const t = this.scaleToZoom(e.scale), n = Math.abs(t - Math.floor(t));
    return e.scale = this.zoomToScale(n > 0.99 ? Math.round(t) : Math.floor(t)), e;
  }
  zoomToScale(e) {
    if (!this.effectiveLODs)
      return 0;
    e -= this.effectiveMinZoom, e = Math.max(0, e);
    const t = this._scales;
    if (e <= 0)
      return t[0];
    if (e >= t.length)
      return t[t.length - 1];
    const n = Math.round(e - 0.5), r = Math.round(e);
    return t[r] + (r - e) * (t[n] - t[r]);
  }
  scaleToZoom(e) {
    if (!this.effectiveLODs)
      return -1;
    const t = this._scales;
    let n, r;
    if (e >= t[0])
      return this.effectiveMinZoom;
    if (e <= t[t.length - 1])
      return this.effectiveMaxZoom;
    for (let i = 0; i < t.length - 1; i++) {
      if (n = t[i], r = t[i + 1], r === e)
        return i + this.effectiveMinZoom + 1;
      if (n > e && r < e)
        return i + this.effectiveMinZoom + 1 - (e - r) / (n - r);
    }
  }
  snapToClosestScale(e) {
    if (!this.effectiveLODs)
      return e;
    const t = this.scaleToZoom(e);
    return this.zoomToScale(Math.round(t));
  }
  snapToNextScale(e, t = 0.5) {
    if (!this.effectiveLODs)
      return e * t;
    const n = Math.round(this.scaleToZoom(e));
    return this.zoomToScale(n + 1);
  }
  snapToPreviousScale(e, t = 2) {
    if (!this.effectiveLODs)
      return e * t;
    const n = Math.round(this.scaleToZoom(e));
    return this.zoomToScale(n - 1);
  }
  clone() {
    return new NM({ lods: this.lods, minZoom: this.minZoom, maxZoom: this.maxZoom, minScale: this.minScale, maxScale: this.maxScale });
  }
  _getClosestScale(e) {
    return this._lodByScale[e] || (e = this._scales.reduce((t, n) => Math.abs(n - e) <= Math.abs(t - e) ? n : t, this._scales[0])), this._lodByScale[e].scale;
  }
};
u([d({ readOnly: !0 })], mi.prototype, "effectiveLODs", void 0), u([d({ readOnly: !0 })], mi.prototype, "effectiveMinZoom", void 0), u([d({ readOnly: !0 })], mi.prototype, "effectiveMaxZoom", void 0), u([d({ readOnly: !0 })], mi.prototype, "effectiveMinScale", void 0), u([d({ readOnly: !0 })], mi.prototype, "effectiveMaxScale", void 0), u([d()], mi.prototype, "lods", void 0), u([d()], mi.prototype, "minZoom", void 0), u([d()], mi.prototype, "maxZoom", void 0), u([d()], mi.prototype, "minScale", void 0), u([d()], mi.prototype, "maxScale", void 0), u([d()], mi.prototype, "snapToZoom", void 0), mi = NM = u([T("geoscene.views.2d.constraints.ZoomConstraint")], mi);
const oU = mi, Lye = { base: null, key: "type", typeMap: { extent: Mt, polygon: Po } };
let $n = class extends ke {
  constructor(t) {
    super(t), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = !0, this.snapToZoom = !0;
  }
  destroy() {
    this.view = null, this._set("_zoom", null), this._set("_rotation", null), this._set("_geometry", null);
  }
  set geometry(t) {
    t ? this._set("geometry", t) : this._set("geometry", null);
  }
  get version() {
    var t;
    return this.commitProperty("_zoom"), this.commitProperty("_rotation"), this.commitProperty("_geometry"), ((t = this._get("version")) != null ? t : 0) + 1;
  }
  get _defaultLODs() {
    var t, n, r;
    const i = (t = this.view) == null || (n = t.defaultsFromMap) == null ? void 0 : n.tileInfo, s = (r = this.view) == null ? void 0 : r.spatialReference;
    return i && s && i.spatialReference.equals(s) ? i.lods : null;
  }
  get _geometry() {
    var t;
    return new Sd({ geometry: this.geometry, spatialReference: (t = this.view) == null ? void 0 : t.spatialReference });
  }
  get _rotation() {
    return new sU({ rotationEnabled: this.rotationEnabled });
  }
  get _zoom() {
    const t = this._get("_zoom"), n = this.lods || this._defaultLODs, r = this.minZoom, i = this.maxZoom, s = this.minScale, o = this.maxScale, a = this.snapToZoom;
    return t && t.lods === n && t.minZoom === r && t.maxZoom === i && t.minScale === s && t.maxScale === o && t.snapToZoom === a ? t : new oU({ lods: n, minZoom: r, maxZoom: i, minScale: s, maxScale: o, snapToZoom: a });
  }
  canZoomInTo(t) {
    const n = this.effectiveMaxScale;
    return n === 0 || t >= n;
  }
  canZoomOutTo(t) {
    const n = this.effectiveMinScale;
    return n === 0 || t <= n;
  }
  constrain(t, n) {
    return this._zoom.constrain(t, n), this._rotation.constrain(t, n), this._geometry.constrain(t, n), t;
  }
  constrainByGeometry(t) {
    return this._geometry.constrain(t);
  }
  fit(t) {
    return this._zoom.fit(t);
  }
  zoomToScale(t) {
    return this._zoom.zoomToScale(t);
  }
  scaleToZoom(t) {
    return this._zoom.scaleToZoom(t);
  }
  snapScale(t) {
    return this._zoom.snapToClosestScale(t);
  }
  snapToNextScale(t) {
    return this._zoom.snapToNextScale(t);
  }
  snapToPreviousScale(t) {
    return this._zoom.snapToPreviousScale(t);
  }
};
u([d({ readOnly: !0, aliasOf: "_zoom.effectiveLODs" })], $n.prototype, "effectiveLODs", void 0), u([d({ readOnly: !0, aliasOf: "_zoom.effectiveMinScale" })], $n.prototype, "effectiveMinScale", void 0), u([d({ readOnly: !0, aliasOf: "_zoom.effectiveMaxScale" })], $n.prototype, "effectiveMaxScale", void 0), u([d({ readOnly: !0, aliasOf: "_zoom.effectiveMinZoom" })], $n.prototype, "effectiveMinZoom", void 0), u([d({ readOnly: !0, aliasOf: "_zoom.effectiveMaxZoom" })], $n.prototype, "effectiveMaxZoom", void 0), u([d({ types: Lye, value: null })], $n.prototype, "geometry", null), u([d({ type: [ZO] })], $n.prototype, "lods", void 0), u([d()], $n.prototype, "minScale", void 0), u([d()], $n.prototype, "maxScale", void 0), u([d()], $n.prototype, "minZoom", void 0), u([d()], $n.prototype, "maxZoom", void 0), u([d()], $n.prototype, "rotationEnabled", void 0), u([d()], $n.prototype, "snapToZoom", void 0), u([d()], $n.prototype, "view", void 0), u([d({ readOnly: !0 })], $n.prototype, "version", null), u([d()], $n.prototype, "_defaultLODs", null), u([d({ type: Sd })], $n.prototype, "_geometry", null), u([d({ type: sU })], $n.prototype, "_rotation", null), u([d({ readOnly: !0, type: oU })], $n.prototype, "_zoom", null), $n = u([T("geoscene.views.2d.MapViewConstraints")], $n);
const aU = $n;
function Fye() {
  const e = new Float32Array(6);
  return e[0] = 1, e[3] = 1, e;
}
function Nye(e, t, n, r) {
  const i = t[r], s = t[r + 1];
  e[r] = n[0] * i + n[2] * s + n[4], e[r + 1] = n[1] * i + n[3] * s + n[5];
}
function GNe(e, t, n, r = 0, i = 0, s = 2) {
  const o = i || t.length / s;
  for (let a = r; a < o; a++)
    Nye(e, t, n, a * s);
}
function WNe(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;
}
function Dye(e, t, n, r, i, s, o, a, l, c) {
  return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = s, e[5] = o, e[6] = a, e[7] = l, e[8] = c, e;
}
function jye(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
}
function HNe(e, t) {
  if (e === t) {
    const n = t[1], r = t[2], i = t[5];
    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = r, e[7] = i;
  } else
    e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
  return e;
}
function Vye(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], p = t[7], f = t[8], m = n[0], y = n[1], g = n[2], v = n[3], w = n[4], b = n[5], S = n[6], $ = n[7], I = n[8];
  return e[0] = m * r + y * o + g * c, e[1] = m * i + y * a + g * p, e[2] = m * s + y * l + g * f, e[3] = v * r + w * o + b * c, e[4] = v * i + w * a + b * p, e[5] = v * s + w * l + b * f, e[6] = S * r + $ * o + I * c, e[7] = S * i + $ * a + I * p, e[8] = S * s + $ * l + I * f, e;
}
function mN(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], p = t[7], f = t[8], m = n[0], y = n[1];
  return e[0] = r, e[1] = i, e[2] = s, e[3] = o, e[4] = a, e[5] = l, e[6] = m * r + y * o + c, e[7] = m * i + y * a + p, e[8] = m * s + y * l + f, e;
}
function zye(e, t, n) {
  const r = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], p = t[7], f = t[8], m = Math.sin(n), y = Math.cos(n);
  return e[0] = y * r + m * o, e[1] = y * i + m * a, e[2] = y * s + m * l, e[3] = y * o - m * r, e[4] = y * a - m * i, e[5] = y * l - m * s, e[6] = c, e[7] = p, e[8] = f, e;
}
function JNe(e, t, n) {
  const r = n[0], i = n[1], s = n[2];
  return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e[6] = s * t[6], e[7] = s * t[7], e[8] = s * t[8], e;
}
function ZNe(e, t, n) {
  const r = n[0], i = n[1];
  return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e;
}
function KNe(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;
}
function YNe(e, t) {
  const n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], p = t[8], f = t[9], m = t[10], y = t[11], g = t[12], v = t[13], w = t[14], b = t[15], S = n * a - r * o, $ = n * l - i * o, I = n * c - s * o, M = r * l - i * a, E = r * c - s * a, C = i * c - s * l, A = p * v - f * g, W = p * w - m * g, j = p * b - y * g, G = f * w - m * v, R = f * b - y * v, V = m * b - y * w;
  let Q = S * V - $ * R + I * G + M * j - E * W + C * A;
  return Q ? (Q = 1 / Q, e[0] = (a * V - l * R + c * G) * Q, e[1] = (l * j - o * V - c * W) * Q, e[2] = (o * R - a * j + c * A) * Q, e[3] = (i * R - r * V - s * G) * Q, e[4] = (n * V - i * j + s * W) * Q, e[5] = (r * j - n * R - s * A) * Q, e[6] = (v * C - w * E + b * M) * Q, e[7] = (w * I - g * C - b * $) * Q, e[8] = (g * E - v * I + b * S) * Q, e) : null;
}
function QNe(e) {
  const t = Dn, n = e[0], r = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], p = e[8];
  return Math.abs(1 - (n * n + s * s + l * l)) <= t && Math.abs(1 - (r * r + o * o + c * c)) <= t && Math.abs(1 - (i * i + a * a + p * p)) <= t;
}
function Dx() {
  const e = new Float32Array(9);
  return e[0] = 1, e[4] = 1, e[8] = 1, e;
}
function XNe(e) {
  const t = new Float32Array(9);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function e4e() {
  return new Float32Array(2);
}
function Xg(e, t) {
  const n = new Float32Array(2);
  return n[0] = e, n[1] = t, n;
}
function Bye() {
  return Xg(1, 1);
}
function Uye() {
  return Xg(1, 0);
}
function qye() {
  return Xg(0, 1);
}
Bye();
Uye();
qye();
function Gye(e) {
  return e instanceof Float32Array && e.length >= 2;
}
function Wye(e) {
  return Array.isArray(e) && e.length >= 2;
}
function jx(e) {
  return Gye(e) || Wye(e);
}
var DM;
const za = [0, 0];
let Tu = DM = class extends se {
  constructor(e) {
    super(e), this._viewpoint2D = { center: Xn(), rotation: 0, scale: 0, spatialReference: null }, this.center = [0, 0], this.extent = new Mt(), this.id = 0, this.inverseTransform = Jd(), this.resolution = 0, this.rotation = 0, this.scale = 0, this.transform = Jd(), this.transformNoRotation = Jd(), this.displayMat3 = Dx(), this.displayViewMat3 = Dx(), this.viewMat3 = Dx(), this.viewMat2d = Fye(), this.worldScreenWidth = 0, this.size = [0, 0];
  }
  set pixelRatio(e) {
    this._set("pixelRatio", e), this._update();
  }
  set size(e) {
    this._set("size", e), this._update();
  }
  set viewpoint(e) {
    if (e) {
      const t = this._viewpoint2D, n = e.targetGeometry;
      t.center[0] = n.x, t.center[1] = n.y, t.rotation = e.rotation, t.scale = e.scale, t.spatialReference = n.spatialReference;
    }
    this._update();
  }
  copy(e) {
    const t = this.size, n = this.viewpoint;
    return n && t ? (this.viewpoint = jo(n, e.viewpoint), this._set("size", c_(t, e.size))) : (this.viewpoint = e.viewpoint.clone(), this._set("size", [e.size[0], e.size[1]])), this._set("pixelRatio", e.pixelRatio), this;
  }
  clone() {
    return new DM({ size: this.size, viewpoint: this.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
  toMap(e, t, n) {
    return jx(t) ? yl(e, t, this.inverseTransform) : (za[0] = t, za[1] = n, yl(e, za, this.inverseTransform));
  }
  toScreen(e, t, n) {
    return jx(t) ? yl(e, t, this.transform) : (za[0] = t, za[1] = n, yl(e, za, this.transform));
  }
  toScreenNoRotation(e, t, n) {
    return jx(t) ? yl(e, t, this.transformNoRotation) : (za[0] = t, za[1] = n, yl(e, za, this.transformNoRotation));
  }
  getScreenTransform(e, t) {
    const { center: n } = this._viewpoint2D, r = this._get("pixelRatio") || 1, i = this._get("size");
    return s3(e, n, i, t, 0, r), e;
  }
  _update() {
    const { center: e, spatialReference: t, scale: n, rotation: r } = this._viewpoint2D, i = this._get("pixelRatio") || 1, s = this._get("size"), o = new ba({ targetGeometry: new Oe(e[0], e[1], t), scale: n, rotation: r });
    if (this._set("viewpoint", o), !s || !t || !n)
      return;
    this.resolution = sm(o), this.rotation = r, this.scale = n, this.spatialReference = t, c_(this.center, e);
    const a = s[0] !== 0 ? 2 / s[0] : 0, l = s[1] !== 0 ? -2 / s[1] : 0;
    Dye(this.displayMat3, a, 0, 0, 0, l, 0, -1, 1, 1);
    const c = jye(this.viewMat3), p = Xg(s[0] / 2, s[1] / 2), f = Xg(-s[0] / 2, -s[1] / 2), m = d6(r);
    mN(c, c, p), zye(c, c, m), mN(c, c, f), Vye(this.displayViewMat3, this.displayMat3, c);
    const y = ZB(this.viewMat2d, p);
    return t3(y, y, m), u_(y, y, f), fye(this.extent, o, s), o3(this.transform, o, s, i), HB(this.inverseTransform, this.transform), _ye(this.transformNoRotation, o, s, i), this.worldScreenWidth = xye(this.spatialReference, this.resolution), this._set("id", this.id + 1), this;
  }
};
u([d({ readOnly: !0 })], Tu.prototype, "id", void 0), u([d({ value: 1, json: { write: !0 } })], Tu.prototype, "pixelRatio", null), u([d({ json: { write: !0 } })], Tu.prototype, "size", null), u([d()], Tu.prototype, "spatialReference", void 0), u([d({ type: ba, json: { write: !0 } })], Tu.prototype, "viewpoint", null), Tu = DM = u([T("geoscene.views.2d.ViewState")], Tu);
const yN = Tu;
var jM, VM;
let gl = jM = class extends ke {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new jM({ left: this.left, top: this.top, right: this.right, bottom: this.bottom });
  }
};
u([d()], gl.prototype, "left", void 0), u([d()], gl.prototype, "top", void 0), u([d()], gl.prototype, "right", void 0), u([d()], gl.prototype, "bottom", void 0), gl = jM = u([T("geoscene.views.2d.PaddedViewState.Padding")], gl);
let Oh = VM = class extends yN {
  constructor(...e) {
    super(...e), this.paddedViewState = new yN(), this._updateContent = (() => {
      const t = Xn();
      return () => {
        const n = this._get("size"), r = this._get("padding");
        if (!n || !r)
          return;
        const i = this.paddedViewState;
        vr(t, r.left + r.right, r.top + r.bottom), d_(t, n, t), c_(i.size, t);
        const s = i.viewpoint;
        s && (this.viewpoint = s);
      };
    })(), this.watch(["size", "padding"], this._updateContent, !0), this.padding = new gl(), this.size = [0, 0];
  }
  set padding(e) {
    this._set("padding", e || new gl());
  }
  set viewpoint(e) {
    if (e) {
      const t = e.clone();
      this.paddedViewState.viewpoint = e, Tye(t, e, this._get("size"), this._get("padding"));
      const n = this._viewpoint2D, r = t.targetGeometry;
      n.center[0] = r.x, n.center[1] = r.y, n.rotation = t.rotation, n.scale = t.scale, n.spatialReference = r.spatialReference, this._update();
    }
  }
  clone() {
    return new VM({ padding: this.padding.clone(), size: this.size.slice(), viewpoint: this.paddedViewState.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
};
u([d()], Oh.prototype, "paddedViewState", void 0), u([d({ type: gl })], Oh.prototype, "padding", null), u([d()], Oh.prototype, "viewpoint", null), Oh = VM = u([T("geoscene.views.2d.PaddedViewState")], Oh);
const Hye = Oh;
let Jye = class {
  constructor(t, n) {
    this.item = t, this.controller = n, this.promise = null;
  }
}, lU = class {
  constructor(t) {
    this._deferreds = /* @__PURE__ */ new Map(), this._controllers = /* @__PURE__ */ new Map(), this._processingItems = /* @__PURE__ */ new Map(), this._isPaused = !1, this._schedule = null, this._task = null, this.concurrency = 1, t.concurrency && (this.concurrency = t.concurrency), this._queue = new MM(t.peeker), this.process = t.process;
    const n = t.scheduler;
    t.priority && O(n) && (this._task = n.registerTask(t.priority, this));
  }
  destroy() {
    this.clear(), this._schedule && (this._schedule.remove(), this._schedule = null), this._task && (this._task.remove(), this._task = null);
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(t) {
    const n = this._controllers.get(t);
    n && n.abort();
  }
  clear() {
    this._queue.clear();
    const t = [];
    this._controllers.forEach((n) => t.push(n)), this._controllers.clear(), t.forEach((n) => n.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(t) {
    this._deferreds.forEach((n, r) => t(r));
  }
  get(t) {
    const n = this._deferreds.get(t);
    return n ? n.promise : void 0;
  }
  isOngoing(t) {
    return this._processingItems.has(t);
  }
  has(t) {
    return this._deferreds.has(t);
  }
  pause() {
    this._isPaused || (this._isPaused = !0, this._cancelNext());
  }
  push(t, n) {
    const r = this.get(t);
    if (r)
      return r;
    const i = new AbortController();
    let s = null;
    n && (s = Ao(n, () => i.abort()));
    const o = () => {
      const p = this._processingItems.get(t);
      p && p.controller.abort(), a(), c.reject(Cn());
    }, a = () => {
      l.remove(), O(s) && s.remove(), this._deferreds.delete(t), this._controllers.delete(t), this._queue.remove(t), this._processingItems.delete(t), this._scheduleNext();
    }, l = G_(i.signal, o), c = Cl();
    return this._deferreds.set(t, c), this._controllers.set(t, i), c.promise.then(a, a), this._queue.push(t), this._scheduleNext(), c.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const t = [];
    this._processingItems.forEach((n) => t.push(n)), this._processingItems.clear();
    for (const n of t)
      this._queue.push(n.item), n.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._isPaused && (this._isPaused = !1, this._scheduleNext());
  }
  takeAll() {
    const t = [];
    for (; this._queue.length; )
      t.push(this._queue.pop());
    return this.clear(), t;
  }
  get running() {
    return !this._isPaused && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(t) {
    for (; !t.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), t.madeProgress();
  }
  _scheduleNext() {
    this._task || this._isPaused || this._schedule || (this._schedule = g0(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(t, n) {
    this._canProcessFulfillment(t) && (this._scheduleNext(), this._deferreds.get(t.item).resolve(n));
  }
  _processError(t, n) {
    this._canProcessFulfillment(t) && (this._scheduleNext(), this._deferreds.get(t.item).reject(n));
  }
  _canProcessFulfillment(t) {
    return !!this._deferreds.get(t.item) && this._processingItems.get(t.item) === t;
  }
  _process(t) {
    if (H(t))
      return;
    let n;
    const r = new AbortController(), i = new Jye(t, r);
    this._processingItems.set(t, i);
    try {
      n = this.process(t, r.signal);
    } catch (s) {
      this._processError(i, s);
    }
    Fl(n) ? (i.promise = n, n.then((s) => this._processResult(i, s), (s) => this._processError(i, s))) : this._processResult(i, n);
  }
  get test() {
    return { update: (t) => this.runTask(t) };
  }
};
function Zye(e, t) {
  return e.length = 0, t.forEach((n) => e.push(n)), e;
}
const Vx = /* @__PURE__ */ new Set(), Jv = [], qp = /* @__PURE__ */ new Map(), gN = [0, 0];
let Kl = class extends ke {
  constructor(t) {
    super(t), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: t, process: n } = this;
    this._queue = new lU({ concurrency: t, process: (r, i) => {
      const s = this._keyToItem.get(r);
      return n(s, { signal: i });
    }, peeker: (r) => r.values().next().value });
  }
  destroy() {
    this.clear(), this._queue.destroy(), this._queue = null;
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(t) {
    const n = typeof t == "string" ? t : t.id;
    this._queue.abort(n);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(t) {
    return typeof t == "string" ? this._keyToItem.has(t) : this._keyToItem.has(t.id);
  }
  isOngoing(t) {
    const n = typeof t == "string" ? t : t.id;
    return this.has(n) && this._queue.isOngoing(n);
  }
  pause() {
    this._queue.pause();
  }
  push(t, n) {
    const r = t.key.id + "-" + n;
    if (this.has(r))
      return this.get(r);
    const i = this._queue.push(r), s = () => {
      this._keyToItem.delete(r), this.notifyChange("updating");
    };
    return this._keyToItem.set(r, t), i.then(s, s), this.notifyChange("updating"), i;
  }
  reset() {
    this._queue.reset(), this.notifyChange("updating");
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const n = this.tileInfoView;
    let r = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    t.forEach((p) => {
      const f = this._keyToItem.get(p), m = this.tileInfoView.getTileScale(f.key);
      qp.has(m) || (qp.set(m, []), r = Math.max(m, r), i = Math.min(m, i)), qp.get(m).push(f.key), Vx.add(m);
    });
    let s = this.state.scale;
    qp.has(s) || (Zye(Jv, Vx), Jv.sort((p, f) => p - f), s = Jv.reduce((p, f) => Math.abs(f - s) < Math.abs(p - s) ? f : p, Jv[0])), s = Math.min(s, r), s = Math.max(s, i);
    const o = qp.get(s), a = n.getClosestInfoForScale(s), l = a.getColumnForX(this.state.center[0]), c = a.getRowForY(this.state.center[1]);
    return o.sort((p, f) => {
      const m = a.denormalizeCol(p.col, p.world), y = a.denormalizeCol(f.col, f.world);
      return Math.sqrt((l - m) * (l - m) + (c - p.row) * (c - p.row)) - Math.sqrt((l - y) * (l - y) + (c - f.row) * (c - f.row));
    }), Vx.clear(), qp.clear(), o[0].id;
  }
  _peekByCenterFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const n = this.tileInfoView, r = this.state.center;
    let i = Number.POSITIVE_INFINITY, s = null;
    return t.forEach((o) => {
      const a = this._keyToItem.get(o);
      n.getTileCoords(gN, a.key);
      const l = n3(gN, r);
      l < i && (i = l, s = a.key);
    }), s.id;
  }
};
u([d({ constructOnly: !0 })], Kl.prototype, "concurrency", void 0), u([d({ constructOnly: !0 })], Kl.prototype, "process", void 0), u([d()], Kl.prototype, "state", void 0), u([d({ constructOnly: !0 })], Kl.prototype, "strategy", void 0), u([d({ constructOnly: !0 })], Kl.prototype, "tileInfoView", void 0), u([d({ readOnly: !0 })], Kl.prototype, "updating", null), Kl = u([T("geoscene.views.2d.tiling.PagedTileQueue")], Kl);
let mp = class dd {
  constructor(t, n, r, i) {
    this.set(t, n, r, i);
  }
  static getId(t, n, r, i) {
    return typeof t == "object" ? `${t.level}/${t.row}/${t.col}/${t.world}` : `${t}/${n}/${r}/${i}`;
  }
  get key() {
    return this;
  }
  get id() {
    return this.toString();
  }
  set id(t) {
    this.set(t);
  }
  get hash() {
    const t = 4095 & this.row, n = 4095 & this.col, r = 63 & this.level;
    return (3 & this.world) << 30 | n << 22 | t << 8 | r;
  }
  acquire(t, n, r, i) {
    this.set(t, n, r, i);
  }
  contains(t) {
    const n = t.level - this.level;
    return this.row === t.row >> n && this.col === t.col >> n && this.world === t.world;
  }
  equals(t) {
    return this.level === t.level && this.row === t.row && this.col === t.col && this.world === t.world;
  }
  clone() {
    return new dd(this);
  }
  release() {
    this.level = 0, this.row = 0, this.col = 0, this.world = 0;
  }
  set(t, n, r, i) {
    if (t == null)
      this.level = 0, this.row = 0, this.col = 0, this.world = 0;
    else if (typeof t == "object")
      this.level = t.level || 0, this.row = t.row || 0, this.col = t.col || 0, this.world = t.world || 0;
    else if (typeof t == "string") {
      const [s, o, a, l] = t.split("/");
      this.level = parseFloat(s), this.row = parseFloat(o), this.col = parseFloat(a), this.world = parseFloat(l);
    } else
      this.level = +t, this.row = +n, this.col = +r, this.world = +i || 0;
    return this;
  }
  toString() {
    return `${this.level}/${this.row}/${this.col}/${this.world}`;
  }
  getParentKey() {
    return this.level <= 0 ? null : new dd(this.level - 1, this.row >> 1, this.col >> 1, this.world);
  }
  getChildKeys() {
    const t = this.level + 1, n = this.row << 1, r = this.col << 1, i = this.world;
    return [new dd(t, n, r, i), new dd(t, n, r + 1, i), new dd(t, n + 1, r, i), new dd(t, n + 1, r + 1, i)];
  }
  compareRowMajor(t) {
    return this.row < t.row ? -1 : this.row > t.row ? 1 : this.col < t.col ? -1 : this.col > t.col ? 1 : 0;
  }
};
mp.pool = new fc(mp, null, null, 25, 50);
function Yl(e, t) {
  return [e, t];
}
function Ic(e, t, n) {
  return e[0] = t, e[1] = n, e;
}
function Kye(e, t, n, r, i) {
  return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e;
}
const to = new mp("0/0/0/0");
let Yye = class uU {
  constructor(t, n, r, i, s, o, a, l, c, p, f, m) {
    this.level = t, this.resolution = n, this.scale = r, this.origin = i, this.first = s, this.last = o, this.size = a, this.norm = l, this.worldStart = c, this.worldEnd = p, this.worldSize = f, this.wrap = m;
  }
  static create(t, n, r = null) {
    const i = Oo(t.spatialReference), s = n.origin || Yl(t.origin.x, t.origin.y), o = Yl(t.size[0] * n.resolution, t.size[1] * n.resolution), a = Yl(-1 / 0, -1 / 0), l = Yl(1 / 0, 1 / 0), c = Yl(1 / 0, 1 / 0);
    O(r) && (Ic(a, Math.max(0, Math.floor((r.xmin - s[0]) / o[0])), Math.max(0, Math.floor((s[1] - r.ymax) / o[1]))), Ic(l, Math.max(0, Math.floor((r.xmax - s[0]) / o[0])), Math.max(0, Math.floor((s[1] - r.ymin) / o[1]))), Ic(c, l[0] - a[0] + 1, l[1] - a[1] + 1));
    const { cols: p, rows: f } = n;
    let m, y, g, v;
    return !r && p && f && (Ic(a, p[0], f[0]), Ic(l, p[1], f[1]), Ic(c, p[1] - p[0] + 1, f[1] - f[0] + 1)), t.isWrappable ? (m = Yl(Math.ceil(Math.round((i.valid[1] - i.valid[0]) / n.resolution) / t.size[0]), c[1]), y = Yl(Math.floor((i.origin[0] - s[0]) / o[0]), a[1]), g = Yl(m[0] + y[0] - 1, l[1]), v = !0) : (y = a, g = l, m = c, v = !1), new uU(n.level, n.resolution, n.scale, s, a, l, c, o, y, g, m, v);
  }
  normalizeCol(t) {
    if (!this.wrap)
      return t;
    const n = this.worldSize[0];
    return t < 0 ? n - 1 - Math.abs((t + 1) % n) : t % n;
  }
  denormalizeCol(t, n) {
    return this.wrap ? this.worldSize[0] * n + t : t;
  }
  getWorldForColumn(t) {
    return this.wrap ? Math.floor(t / this.worldSize[0]) : 0;
  }
  getFirstColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0];
  }
  getLastColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0] + this.size[0] - 1;
  }
  getColumnForX(t) {
    return (t - this.origin[0]) / this.norm[0];
  }
  getXForColumn(t) {
    return this.origin[0] + t * this.norm[0];
  }
  getRowForY(t) {
    return (this.origin[1] - t) / this.norm[1];
  }
  getYForRow(t) {
    return this.origin[1] - t * this.norm[1];
  }
  getTileBounds(t, n, r = !1) {
    to.set(n);
    const i = r ? to.col : this.denormalizeCol(to.col, to.world), s = to.row;
    return Kye(t, this.getXForColumn(i), this.getYForRow(s + 1), this.getXForColumn(i + 1), this.getYForRow(s)), t;
  }
  getTileCoords(t, n, r = !1) {
    to.set(n);
    const i = r ? to.col : this.denormalizeCol(to.col, to.world);
    return Array.isArray(t) ? Ic(t, this.getXForColumn(i), this.getYForRow(to.row)) : (t.x = this.getXForColumn(i), t.y = this.getYForRow(to.row)), t;
  }
}, If = class {
  constructor() {
    this.spans = [];
  }
  acquire(t) {
    this.lodInfo = t;
  }
  release() {
    this.lodInfo = null, this.spans.length = 0;
  }
  forEach(t, n) {
    const { spans: r, lodInfo: i } = this, { level: s } = i;
    if (r.length !== 0)
      for (const { row: o, colFrom: a, colTo: l } of r)
        for (let c = a; c <= l; c++)
          t.call(n, s, o, i.normalizeCol(c), i.getWorldForColumn(c));
  }
};
If.pool = new fc(If);
let zx = class {
  constructor(t, n, r) {
    this.row = t, this.colFrom = n, this.colTo = r;
  }
};
const Qt = new mp("0/0/0/0");
let Qye = class cU {
  constructor(t, n, r, i, s, o, a, l) {
    this.x = t, this.ymin = n, this.ymax = r, this.invM = i, this.leftAdjust = s, this.rightAdjust = o, this.leftBound = a, this.rightBound = l;
  }
  static create(t, n) {
    t[1] > n[1] && ([t, n] = [n, t]);
    const [r, i] = t, [s, o] = n, a = s - r, l = o - i, c = l !== 0 ? a / l : 0, p = (Math.ceil(i) - i) * c, f = (Math.floor(i) - i) * c;
    return new cU(r, Math.floor(i), Math.ceil(o), c, a < 0 ? p : f, a < 0 ? f : p, a < 0 ? s : r, a < 0 ? r : s);
  }
  incrRow() {
    this.x += this.invM;
  }
  getLeftCol() {
    return Math.max(this.x + this.leftAdjust, this.leftBound);
  }
  getRightCol() {
    return Math.min(this.x + this.rightAdjust, this.rightBound);
  }
};
const Fi = [[0, 0], [0, 0], [0, 0], [0, 0]], Xye = 1e-6;
let ege = class {
  constructor(t, n = null) {
    this.tileInfo = t, this.fullExtent = n, this.scales = [], this._lodInfos = null, this._infoByScale = {}, this._infoByLevel = {};
    const r = t.lods.slice();
    r.sort(function(s, o) {
      return o.scale - s.scale;
    });
    const i = this._lodInfos = r.map((s) => Yye.create(t, s, n));
    r.forEach((s, o) => {
      this._infoByLevel[s.level] = i[o], this._infoByScale[s.scale] = i[o], this.scales[o] = s.scale;
    }, this), this._wrap = t.isWrappable;
  }
  get spatialReference() {
    return this.tileInfo.spatialReference;
  }
  getLODInfoAt(t) {
    return this._infoByLevel[typeof t == "number" ? t : t.level];
  }
  getTileBounds(t, n, r = !1) {
    Qt.set(n);
    const i = this._infoByLevel[Qt.level];
    return i ? i.getTileBounds(t, Qt, r) : t;
  }
  getTileCoords(t, n, r = !1) {
    Qt.set(n);
    const i = this._infoByLevel[Qt.level];
    return i ? i.getTileCoords(t, Qt, r) : t;
  }
  getTileCoverage(t, n = 192, r = "closest") {
    const i = r === "closest" ? this.getClosestInfoForScale(t.scale) : this.getSmallestInfoForScale(t.scale), s = If.pool.acquire(i), o = this._wrap;
    let a, l, c, p = 1 / 0, f = -1 / 0;
    const m = s.spans;
    Fi[0][0] = Fi[0][1] = Fi[1][1] = Fi[3][0] = -n, Fi[1][0] = Fi[2][0] = t.size[0] + n, Fi[2][1] = Fi[3][1] = t.size[1] + n;
    for (const w of Fi)
      t.toMap(w, w), w[0] = i.getColumnForX(w[0]), w[1] = i.getRowForY(w[1]);
    const y = [];
    let g = 3;
    for (let w = 0; w < 4; w++) {
      if (Fi[w][1] === Fi[g][1]) {
        g = w;
        continue;
      }
      const b = Qye.create(Fi[w], Fi[g]);
      p = Math.min(b.ymin, p), f = Math.max(b.ymax, f), y[b.ymin] === void 0 && (y[b.ymin] = []), y[b.ymin].push(b), g = w;
    }
    if (p == null || f == null || f - p > 100)
      return null;
    let v = [];
    for (a = p; a < f; ) {
      y[a] != null && (v = v.concat(y[a])), l = 1 / 0, c = -1 / 0;
      for (let w = v.length - 1; w >= 0; w--) {
        const b = v[w];
        l = Math.min(l, b.getLeftCol()), c = Math.max(c, b.getRightCol());
      }
      if (l = Math.floor(l), c = Math.floor(c), a >= i.first[1] && a <= i.last[1])
        if (o)
          if (i.size[0] < i.worldSize[0]) {
            const w = Math.floor(c / i.worldSize[0]);
            for (let b = Math.floor(l / i.worldSize[0]); b <= w; b++)
              m.push(new zx(a, Math.max(i.getFirstColumnForWorld(b), l), Math.min(i.getLastColumnForWorld(b), c)));
          } else
            m.push(new zx(a, l, c));
        else
          l > i.last[0] || c < i.first[0] || (l = Math.max(l, i.first[0]), c = Math.min(c, i.last[0]), m.push(new zx(a, l, c)));
      a += 1;
      for (let w = v.length - 1; w >= 0; w--) {
        const b = v[w];
        b.ymax >= a ? b.incrRow() : v.splice(w, 1);
      }
    }
    return s;
  }
  getTileParentId(t) {
    Qt.set(t);
    const n = this._infoByLevel[Qt.level], r = this._lodInfos.indexOf(n) - 1;
    return r < 0 ? null : (this._getTileIdAtLOD(Qt, this._lodInfos[r], Qt), Qt.id);
  }
  getTileResolution(t) {
    const n = this._infoByLevel[typeof t == "object" ? t.level : t];
    return n ? n.resolution : -1;
  }
  getTileScale(t) {
    const n = this._infoByLevel[t.level];
    return n ? n.scale : -1;
  }
  intersects(t, n) {
    Qt.set(n);
    const r = this._infoByLevel[Qt.level], i = t.lodInfo;
    if (i.resolution > r.resolution) {
      this._getTileIdAtLOD(Qt, i, Qt);
      const o = i.denormalizeCol(Qt.col, Qt.world);
      for (const a of t.spans)
        if (a.row === Qt.row && a.colFrom <= o && a.colTo >= o)
          return !0;
    }
    if (i.resolution < r.resolution) {
      const [o, a, l, c] = t.spans.reduce((v, w) => (v[0] = Math.min(v[0], w.row), v[1] = Math.max(v[1], w.row), v[2] = Math.min(v[2], w.colFrom), v[3] = Math.max(v[3], w.colTo), v), [1 / 0, -1 / 0, 1 / 0, -1 / 0]), p = r.denormalizeCol(Qt.col, Qt.world), f = i.getColumnForX(r.getXForColumn(p)), m = i.getRowForY(r.getYForRow(Qt.row)), y = i.getColumnForX(r.getXForColumn(p + 1)) - 1, g = i.getRowForY(r.getYForRow(Qt.row + 1)) - 1;
      return !(f > c || y < l || m > a || g < o);
    }
    const s = i.denormalizeCol(Qt.col, Qt.world);
    return t.spans.some((o) => o.row === Qt.row && o.colFrom <= s && o.colTo >= s);
  }
  normalizeBounds(t, n, r) {
    if (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], this._wrap) {
      const i = Oo(this.tileInfo.spatialReference), s = -r * (i.valid[1] - i.valid[0]);
      t[0] += s, t[2] += s;
    }
    return t;
  }
  getSmallestInfoForScale(t) {
    const n = this.scales;
    if (this._infoByScale[t])
      return this._infoByScale[t];
    if (t > n[0])
      return this._infoByScale[n[0]];
    for (let r = 1; r < n.length - 1; r++)
      if (t > n[r] + Xye)
        return this._infoByScale[n[r - 1]];
    return this._infoByScale[n[n.length - 1]];
  }
  getClosestInfoForScale(t) {
    const n = this.scales;
    return this._infoByScale[t] || (t = n.reduce((r, i) => Math.abs(i - t) < Math.abs(r - t) ? i : r, n[0])), this._infoByScale[t];
  }
  scaleToLevel(t) {
    const n = this.scales;
    if (this._infoByScale[t])
      return this._infoByScale[t].level;
    for (let r = n.length - 1; r >= 0; r--)
      if (t < n[r])
        return r === n.length - 1 ? this._infoByScale[n[n.length - 1]].level : this._infoByScale[n[r]].level + (n[r] - t) / (n[r] - n[r + 1]);
    return this._infoByScale[n[0]].level;
  }
  scaleToZoom(t) {
    return this.tileInfo.scaleToZoom(t);
  }
  _getTileIdAtLOD(t, n, r) {
    const i = this._infoByLevel[r.level];
    return t.set(r), n.resolution < i.resolution ? null : (n.resolution === i.resolution || (t.level = n.level, t.col = Math.floor(r.col * i.resolution / n.resolution + 0.01), t.row = Math.floor(r.row * i.resolution / n.resolution + 0.01)), t);
  }
};
function tge(e, t) {
  return e.length = 0, t.forEach((n) => e.push(n)), e;
}
const Bx = /* @__PURE__ */ new Set(), Zv = [], Gp = /* @__PURE__ */ new Map(), vN = [0, 0];
let ll = class extends ke {
  constructor(t) {
    super(t), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: t, process: n, strategy: r } = this;
    this._queue = new lU({ concurrency: t, process: (i, s) => {
      const o = this._keyToItem.get(i);
      return n(o, { signal: s });
    }, peeker: r === "scale-first" ? (i) => this._peekByScaleFirst(i) : (i) => this._peekByCenterFirst(i) });
  }
  destroy() {
    this.clear(), this._queue.destroy(), this._queue = null;
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(t) {
    const n = typeof t == "string" ? t : t.id;
    this._queue.abort(n);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(t) {
    return typeof t == "string" ? this._keyToItem.has(t) : this._keyToItem.has(t.id);
  }
  isOngoing(t) {
    const n = typeof t == "string" ? t : t.id;
    return this.has(n) && this._queue.isOngoing(n);
  }
  pause() {
    this._queue.pause();
  }
  push(t) {
    const n = t.key.id;
    if (this._queue.has(n))
      return this._queue.get(n);
    const r = this._queue.push(n), i = () => {
      this._keyToItem.delete(n), this.notifyChange("updating");
    };
    return this._keyToItem.set(n, t), r.then(i, i), this.notifyChange("updating"), r;
  }
  reset() {
    this._queue.reset();
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const n = this.tileInfoView;
    let r = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    t.forEach((p) => {
      const f = this._keyToItem.get(p), m = this.tileInfoView.getTileScale(f.key);
      Gp.has(m) || (Gp.set(m, []), r = Math.max(m, r), i = Math.min(m, i)), Gp.get(m).push(f.key), Bx.add(m);
    });
    let s = this.state.scale;
    Gp.has(s) || (tge(Zv, Bx), Zv.sort((p, f) => p - f), s = Zv.reduce((p, f) => Math.abs(f - s) < Math.abs(p - s) ? f : p, Zv[0])), s = Math.min(s, r), s = Math.max(s, i);
    const o = Gp.get(s), a = n.getClosestInfoForScale(s), l = a.getColumnForX(this.state.center[0]), c = a.getRowForY(this.state.center[1]);
    return o.sort((p, f) => {
      const m = a.denormalizeCol(p.col, p.world), y = a.denormalizeCol(f.col, f.world);
      return Math.sqrt((l - m) * (l - m) + (c - p.row) * (c - p.row)) - Math.sqrt((l - y) * (l - y) + (c - f.row) * (c - f.row));
    }), Bx.clear(), Gp.clear(), o[0].id;
  }
  _peekByCenterFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const n = this.tileInfoView, r = this.state.center;
    let i = Number.POSITIVE_INFINITY, s = null;
    return t.forEach((o) => {
      const a = this._keyToItem.get(o);
      n.getTileCoords(vN, a.key);
      const l = n3(vN, r);
      l < i && (i = l, s = a.key);
    }), s.id;
  }
};
u([d({ constructOnly: !0 })], ll.prototype, "concurrency", void 0), u([d({ constructOnly: !0 })], ll.prototype, "process", void 0), u([d()], ll.prototype, "state", void 0), u([d({ constructOnly: !0 })], ll.prototype, "strategy", void 0), u([d({ constructOnly: !0 })], ll.prototype, "tileInfoView", void 0), u([d({ readOnly: !0 })], ll.prototype, "updating", null), ll = u([T("geoscene.views.2d.tiling.TileQueue")], ll);
const l4e = ll;
let nge = class {
  constructor(t, n, r) {
    this.maxSize = t, this.tileInfoView = n, this.removedFunc = r, this._tilePerId = /* @__PURE__ */ new Map(), this._tileKeysPerLevel = [];
  }
  has(t) {
    return this._tilePerId.has(t);
  }
  get(t) {
    return this._tilePerId.get(t);
  }
  pop(t) {
    const n = this._tilePerId.get(t);
    if (!n)
      return null;
    const r = n.key.level, i = this._tileKeysPerLevel[r];
    bN(this._tilePerId, t);
    for (let s = 0; s < i.length; s++)
      if (i[s].id === t) {
        i.splice(s, 1);
        break;
      }
    return n.visible = !0, n;
  }
  add(t) {
    t.visible = !1;
    const n = t.key, r = n.id;
    if (this._tilePerId.has(r))
      return;
    this._tilePerId.set(r, t);
    const i = n.level;
    this._tileKeysPerLevel[i] || (this._tileKeysPerLevel[i] = []), this._tileKeysPerLevel[i].push(n);
  }
  prune(t, n, r) {
    let i = this._tilePerId.size;
    if (i <= this.maxSize)
      return;
    let s = this._tileKeysPerLevel.length - 1;
    for (; i > this.maxSize && s >= 0; )
      s !== t && (i = this._pruneAroundCenterTile(i, n, r, s)), s--;
    i > this.maxSize && (i = this._pruneAroundCenterTile(i, n, r, t));
  }
  _pruneAroundCenterTile(t, n, r, i) {
    const s = this._tileKeysPerLevel[i];
    if (!s || s.length === 0)
      return t;
    const { size: o, origin: a } = this.tileInfoView.tileInfo, l = r * o[0], c = r * o[1], p = [0, 0], f = [0, 0];
    for (s.sort((m, y) => (p[0] = a.x + l * (m.col + 0.5), p[1] = a.y - c * (m.row + 0.5), f[0] = a.x + l * (y.col + 0.5), f[1] = a.y - c * (y.row + 0.5), uN(p, n) - uN(f, n))); s.length > 0; ) {
      const m = s.pop();
      if (this._removeTile(m.id), --t === this.maxSize)
        break;
    }
    return t;
  }
  _removeTile(t) {
    const n = this._tilePerId.get(t);
    this.removedFunc && this.removedFunc(n), bN(this._tilePerId, t);
  }
};
function bN(e, t) {
  e.delete(t);
}
const Mc = new mp(0, 0, 0, 0), ys = /* @__PURE__ */ new Map(), Wp = [], Kv = [];
let c4e = class {
  constructor(t) {
    this._previousScale = Number.POSITIVE_INFINITY, this.cachePolicy = "keep", this.coveragePolicy = "closest", this.resampling = !0, this.tileIndex = /* @__PURE__ */ new Map(), this.tiles = [], this.buffer = 192, this.acquireTile = t.acquireTile, this.releaseTile = t.releaseTile, this.tileInfoView = t.tileInfoView, this.resampling = t.resampling == null || !!t.resampling, t.cachePolicy && (this.cachePolicy = t.cachePolicy), t.coveragePolicy && (this.coveragePolicy = t.coveragePolicy), t.buffer != null && (this.buffer = t.buffer), t.cacheSize && (this._tileCache = new nge(t.cacheSize, this.tileInfoView, (n) => {
      this.releaseTile(n);
    }));
  }
  destroy() {
    this.tileIndex.clear();
  }
  update(t) {
    const { resampling: n, tileIndex: r } = this, i = this.tileInfoView.getTileCoverage(t.state, this.buffer, this.coveragePolicy);
    if (Kv.length = 0, Wp.length = 0, ys.clear(), !i)
      return;
    const { minScale: s, maxScale: o } = this.tileInfoView.tileInfo, { spans: a, lodInfo: l } = i, { level: c } = l, { scale: p, center: f, resolution: m } = t.state, y = !t.stationary && p > this._previousScale;
    if (this._previousScale = p, this.tiles.length = 0, !n && (p > s || p < o))
      return this.tiles.length = 0, ys.clear(), r.forEach((b) => {
        this.releaseTile(b);
      }), r.clear(), Kv.length = 0, Wp.length = 0, ys.clear(), If.pool.release(i), !0;
    r.forEach((b) => b.visible = !0);
    let g = 0, v = 0;
    if (a.length > 0)
      for (const { row: b, colFrom: S, colTo: $ } of a)
        for (let I = S; I <= $; I++) {
          g++;
          const M = Mc.set(c, b, l.normalizeCol(I), l.getWorldForColumn(I)).id;
          if (r.has(M)) {
            const E = r.get(M);
            E.isReady ? (ys.set(M, E), v++) : y || this._addParentTile(M, ys);
          } else {
            let E;
            if (this._tileCache && this._tileCache.has(M)) {
              if (E = this._tileCache.pop(M), this.tileIndex.set(M, E), E.isReady) {
                ys.set(M, E), v++;
                continue;
              }
            } else
              E = this.acquireTile(Mc), this.tileIndex.set(M, E);
            y || this._addParentTile(M, ys);
          }
        }
    const w = v === g;
    r.forEach((b, S) => {
      if (Mc.set(S), ys.has(S))
        return;
      const $ = this.tileInfoView.intersects(i, Mc), I = this.cachePolicy === "purge" ? Mc.level !== c : Mc.level > c;
      !$ || !y && w ? !I && $ || Wp.push(S) : b.isReady ? I && this.cachePolicy === "purge" && this._hasReadyAncestor(Mc, c) ? Wp.push(S) : Kv.push(S) : I && Wp.push(S);
    });
    for (const b of Kv) {
      const S = r.get(b);
      S && S.isReady && ys.set(b, S);
    }
    for (const b of Wp) {
      const S = r.get(b);
      this._tileCache ? this._tileCache.add(S) : this.releaseTile(S), r.delete(b);
    }
    return ys.forEach((b) => this.tiles.push(b)), r.forEach((b) => {
      ys.has(b.key.id) || (b.visible = !1);
    }), this._tileCache && this._tileCache.prune(c, f, m), If.pool.release(i), ys.clear(), w;
  }
  clear(t = !0) {
    const { tileIndex: n } = this;
    t && n.forEach((r) => {
      this.releaseTile(r);
    }), n.clear();
  }
  updateCacheSize(t) {
    this._tileCache && (this._tileCache.maxSize = t);
  }
  _addParentTile(t, n) {
    let r = t, i = null;
    for (; r = this.tileInfoView.getTileParentId(r), r; )
      if (this.tileIndex.has(r)) {
        if (i = this.tileIndex.get(r), i && i.isReady) {
          n.has(i.key.id) || n.set(i.key.id, i);
          break;
        }
      } else if (this._tileCache && this._tileCache.has(r) && (i = this._tileCache.pop(r), this.tileIndex.set(r, i), i && i.isReady)) {
        n.has(i.key.id) || n.set(i.key.id, i);
        break;
      }
  }
  _hasReadyAncestor(t, n) {
    const r = ap();
    this.tileInfoView.getTileBounds(r, t, !0);
    for (const i of this.tileIndex.values())
      if (i.isReady && i.key.level >= n && i.key.level < t.level) {
        const s = ap();
        if (this.tileInfoView.getTileBounds(s, i.key, !0), XX(s, r))
          return !0;
      }
    return !1;
  }
};
function a3(e, t) {
  switch (t) {
    case "primary":
      return e.pointerType === "touch" || e.button === 0;
    case "secondary":
      return e.pointerType !== "touch" && e.button === 2;
    case "tertiary":
      return e.pointerType !== "touch" && e.button === 1;
  }
}
let wN = class extends dr {
  constructor(t, n) {
    super(!0), this.view = t, this.registerIncoming("double-click", n, (r) => this._handleDoubleClick(r, n));
  }
  _handleDoubleClick(t, n) {
    a3(t.data, "primary") && (t.stopPropagation(), n ? this.view.mapViewNavigation.zoomOut([t.data.x, t.data.y]) : this.view.mapViewNavigation.zoomIn([t.data.x, t.data.y]));
  }
}, rge = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.pointerType = n, this.registerIncoming("double-tap-drag", r, (i) => this._handleDoubleTapDrag(i));
  }
  _handleDoubleTapDrag(t) {
    const { data: n } = t, { pointerType: r } = n;
    if (r !== this.pointerType)
      return;
    t.stopPropagation();
    const { action: i, delta: s } = n, { view: o } = this, { mapViewNavigation: a } = o;
    switch (i) {
      case "begin": {
        const { scale: l } = o;
        this._startScale = l, this._currentScale = l, this._previousDelta = s, a.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === s.y)
          return;
        this._previousDelta = s;
        const l = 1.015 ** s.y, c = this._startScale * l, p = c / this._currentScale;
        a.setViewpointImmediate(p), this._currentScale = c;
        break;
      }
      case "end": {
        const { constraints: l } = o, { effectiveLODs: c, snapToZoom: p } = l;
        if (!p || !c)
          return void a.end();
        const f = l.snapScale(this._currentScale), m = (s.y > 0 ? Math.max(f, l.snapToPreviousScale(this._startScale)) : Math.min(f, l.snapToNextScale(this._startScale))) / this._currentScale;
        a.zoom(m);
        break;
      }
    }
  }
}, FS = class {
  constructor(t) {
    this.callbacks = t, this.currentCount = 0, this.callbacks.condition || (this.callbacks.condition = () => !0);
  }
  handle(t) {
    const n = t.data, r = n.pointers.size;
    switch (n.action) {
      case "start":
        this.currentCount = r, this._emitStart(t);
        break;
      case "added":
        this._emitEnd(this.previousEvent), this.currentCount = r, this._emitStart(t);
        break;
      case "update":
        this._emitUpdate(t);
        break;
      case "removed":
        this.startEvent && this._emitEnd(this.previousEvent), this.currentCount = r, this._emitStart(t);
        break;
      case "end":
        this._emitEnd(t), this.currentCount = 0;
    }
    this.previousEvent = t;
  }
  _emitStart(t) {
    this.startEvent = t, this.callbacks.condition(this.currentCount, t) && this.callbacks.start(this.currentCount, t, this.startEvent);
  }
  _emitUpdate(t) {
    this.callbacks.condition(this.currentCount, t) && this.callbacks.update(this.currentCount, t, this.startEvent);
  }
  _emitEnd(t) {
    this.callbacks.condition(this.currentCount, t) && this.callbacks.end(this.currentCount, t, this.startEvent), this.startEvent = null;
  }
}, ige = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.pointerAction = n, this.registerIncoming("drag", r, (i) => this._handleDrag(i)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(t) {
    super.onInstall(t), this.dragEventSeparator = new FS({ start: (n, r) => {
      this.view.mapViewNavigation.pan.begin(this.view, r.data), r.stopPropagation();
    }, update: (n, r) => {
      this.view.mapViewNavigation.pan.update(this.view, r.data), r.stopPropagation();
    }, end: (n, r) => {
      this.view.mapViewNavigation.pan.end(this.view, r.data), r.stopPropagation();
    }, condition: (n, r) => n === 1 && a3(r.data, this.pointerAction) });
  }
  _handleDrag(t) {
    const n = this.view.mapViewNavigation;
    n.pinch.zoomMomentum || n.pinch.rotateMomentum ? this.stopMomentumNavigation() : this.dragEventSeparator.handle(t);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
}, sge = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.pointerAction = n;
    const i = this.view.mapViewNavigation;
    this.dragEventSeparator = new FS({ start: (s, o) => {
      i.rotate.begin(this.view, o.data), o.stopPropagation();
    }, update: (s, o) => {
      i.rotate.update(this.view, o.data), o.stopPropagation();
    }, end: (s, o) => {
      i.rotate.end(), o.stopPropagation();
    }, condition: (s, o) => s === 1 && a3(o.data, this.pointerAction) }), this.registerIncoming("drag", r, (s) => this.dragEventSeparator.handle(s));
  }
};
function no(e) {
  let t = e * e;
  return e < 0 && (t *= -1), t;
}
function oge(e) {
  return e.translation[0] = 0, e.translation[1] = 0, e.translation[2] = 0, e.heading = 0, e.tilt = 0, e;
}
function age(e, t, n) {
  const r = n, i = e.state, s = e.device, o = t.tiltDirection === "forward-down" ? 1 : -1, a = 1;
  return s.deviceType === "standard" ? (r.translation[0] = no(i.axes[0]), r.translation[1] = no(i.axes[1]), r.translation[2] = no(i.buttons[7]) - no(i.buttons[6]), r.heading = no(i.axes[2]), r.tilt = no(i.axes[3])) : s.deviceType === "spacemouse" && (r.translation[0] = 1.2 * no(i.axes[0]), r.translation[1] = 1.2 * no(i.axes[1]), r.translation[2] = 2 * -no(i.axes[2]), r.heading = 1.2 * no(i.axes[5]), r.tilt = 1.2 * no(i.axes[3])), r.tilt *= o, hQ(r.translation, r.translation, a), r;
}
function lge(e) {
  return e.translation[0] === 0 && e.translation[1] === 0 && e.translation[2] === 0 && e.heading === 0 && e.tilt === 0 && e.zoom === 0;
}
let uge = class extends dr {
  constructor(t) {
    super(!0), this.view = t, this.frameTask = null, this.watchHandles = new ei(), this.currentDevice = null, this.transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, this.handle = this.registerIncoming("gamepad", (n) => this._handleGamePadEvent(n)), this.handle.pause();
  }
  onInstall(t) {
    super.onInstall(t), this.watchHandles.add([gn(this.view.navigation.gamepad, "enabled", (n) => {
      n ? (this.handle.resume(), this.frameTask || (this.frameTask = df({ update: (r) => this._frameUpdate(r.deltaTime) }))) : (this.handle.pause(), this.frameTask && (this.frameTask.remove(), this.frameTask = null));
    })]);
  }
  onUninstall() {
    this.watchHandles.removeAll(), this.frameTask && (this.frameTask.remove(), this.frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t) {
    const n = this.view.navigation.gamepad.device;
    n && t.data.device !== n || this.currentDevice && this.currentDevice !== t.data.device || (t.data.action === "end" ? (this.currentDevice = null, oge(this.transformation)) : (this.currentDevice = t.data.device, age(t.data, this.view.navigation.gamepad, this.transformation)));
  }
  _frameUpdate(t) {
    const n = this.transformation;
    if (lge(n))
      return;
    const r = this.view.viewpoint.clone(), i = this.view.navigation.gamepad.velocityFactor, s = dge * i * t;
    LS(r, r, [n.translation[0] * s, -n.translation[1] * s]);
    const o = 1 + n.translation[2] * pge * t, a = this.view.constraints.rotationEnabled ? -n.heading * cge * t : 0, l = this.view.size, c = [l[0] / 2, l[1]];
    nU(r, r, o, a, c, l);
    const p = this.view.constraints.constrain(r, this.view.viewpoint);
    this.view.viewpoint = p;
  }
};
const cge = 0.06, dge = 0.7, pge = 6e-4;
let hge = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.keys = n, this._pressed = !1, this._keyMap = { [n.left]: "left", [n.right]: "right", [n.up]: "up", [n.down]: "down" }, this.registerIncoming("key-down", r, (i) => this._handleKeyDown(i)), this.registerIncoming("key-up", r, (i) => this._handleKeyUp(i)), this.registerIncoming("blur", r, () => this._handleBlur());
  }
  _handleKeyDown(t) {
    t.data.repeat || this._handleKey(t, !0);
  }
  _handleKeyUp(t) {
    this._handleKey(t, !1);
  }
  _handleBlur() {
    this._pressed && (this._pressed = !1, this.view.mapViewNavigation.stop());
  }
  _handleKey(t, n) {
    const r = this._keyMap[t.data.key];
    if (this._pressed = r != null, this._pressed) {
      if (n)
        switch (this.view.mapViewNavigation.begin(), r) {
          case "left":
            this.view.mapViewNavigation.continousPanLeft();
            break;
          case "right":
            this.view.mapViewNavigation.continousPanRight();
            break;
          case "up":
            this.view.mapViewNavigation.continousPanUp();
            break;
          case "down":
            this.view.mapViewNavigation.continousPanDown();
        }
      else
        this._pressed = !1, this.view.mapViewNavigation.stop();
      t.stopPropagation();
    }
  }
}, fge = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.keys = n, this._pressed = !1, this._keyToDirection = { [n.clockwiseOption1]: "clockwise", [n.clockwiseOption2]: "clockwise", [n.counterClockwiseOption1]: "counterClockwise", [n.counterClockwiseOption2]: "counterClockwise", [n.resetOption1]: "reset", [n.resetOption2]: "reset" }, this.registerIncoming("key-down", r, (i) => this._handleKeyDown(i)), this.registerIncoming("key-up", r, (i) => this._handleKeyUp(i)), this.registerIncoming("blur", r, () => this._handleBlur());
  }
  _handleKeyDown(t) {
    t.data.repeat || this._handleKey(t, !0);
  }
  _handleKeyUp(t) {
    this._handleKey(t, !1);
  }
  _handleBlur() {
    this._pressed && (this._pressed = !1, this.view.mapViewNavigation.stop());
  }
  _handleKey(t, n) {
    const r = t.modifiers;
    if (r.size > 0 && !r.has("Shift") || !this.view.constraints.rotationEnabled)
      return;
    const i = this._keyToDirection[t.data.key];
    if (this._pressed = i != null, this._pressed) {
      if (n)
        switch (this.view.mapViewNavigation.begin(), i) {
          case "clockwise":
            this.view.mapViewNavigation.continousRotateClockwise();
            break;
          case "counterClockwise":
            this.view.mapViewNavigation.continousRotateCounterclockwise();
            break;
          case "reset":
            this.view.mapViewNavigation.resetRotation();
        }
      else
        this._pressed = !1, this.view.mapViewNavigation.stop();
      t.stopPropagation();
    }
  }
};
var Jh;
(function(e) {
  e[e.IN = 0] = "IN", e[e.OUT = 1] = "OUT";
})(Jh || (Jh = {}));
let mge = class extends dr {
  constructor(t, n, r) {
    super(!0), this.view = t, this.keys = n, this._keysToZoomAction = {}, this.registerIncoming("key-down", r, (i) => this._handleKeyDown(i)), n.zoomIn.forEach((i) => this._keysToZoomAction[i] = Jh.IN), n.zoomOut.forEach((i) => this._keysToZoomAction[i] = Jh.OUT);
  }
  _handleKeyDown(t) {
    this._handleKey(t);
  }
  _handleKey(t) {
    const n = t.modifiers;
    if (n.size > 0 && !n.has("Shift"))
      return;
    const { key: r } = t.data;
    if (!(r in this._keysToZoomAction))
      return;
    const i = this._keysToZoomAction[r], { mapViewNavigation: s } = this.view;
    let o = null;
    switch (i) {
      case Jh.IN:
        o = s.zoomIn();
        break;
      case Jh.OUT:
        o = s.zoomOut();
        break;
      default:
        return;
    }
    s.begin(), o.then(() => s.end()), t.stopPropagation();
  }
};
const yge = 0.6;
let gge = class extends dr {
  constructor(t, n) {
    super(!0), this.view = t, this._canZoom = !0, this.registerIncoming("mouse-wheel", n, (r) => this._handleMouseWheel(r));
  }
  _handleMouseWheel(t) {
    if (!this.view.navigation.mouseWheelZoomEnabled || (t.preventDefault(), t.stopPropagation(), !this._canZoom))
      return;
    const n = this.view.mapViewNavigation, { x: r, y: i, deltaY: s } = t.data, o = 1 / yge ** (1 / 60 * s), a = n.zoom(o, [r, i]);
    a && (this._canZoom = !1, a.catch(() => {
    }).then(() => {
      this._canZoom = !0, n.end();
    }));
  }
}, vge = class extends dr {
  constructor(t) {
    super(!0), this.view = t, this.registerIncoming("drag", (r) => this._handleDrag(r)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const n = this.view.mapViewNavigation;
    this.dragEventSeparator = new FS({ start: (r, i) => {
      n.pinch.begin(this.view, i.data), i.stopPropagation();
    }, update: (r, i) => {
      n.pinch.update(this.view, i.data), i.stopPropagation();
    }, end: (r, i) => {
      n.pinch.end(this.view), i.stopPropagation();
    }, condition: (r) => r >= 2 });
  }
  _handleDrag(t) {
    this.dragEventSeparator.handle(t);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
};
function _N(e) {
  const t = e.native;
  return t ? { buttons: t.buttons.map((n) => n.pressed ? n.value ? n.value : 1 : 0), axes: t.axes.map((n) => _ge(n, e.axisThreshold)) } : { buttons: [], axes: [] };
}
function bge(e, t) {
  if (e.axes.length !== t.axes.length || e.buttons.length !== t.buttons.length)
    return !1;
  for (let n = 0; n < e.axes.length; n++)
    if (e.axes[n] !== t.axes[n])
      return !1;
  for (let n = 0; n < e.buttons.length; n++)
    if (e.buttons[n] !== t.buttons[n])
      return !1;
  return !0;
}
function wge(e) {
  for (let t = 0; t < e.axes.length; t++)
    if (e.axes[t] !== 0)
      return !1;
  for (let t = 0; t < e.buttons.length; t++)
    if (e.buttons[t] !== 0)
      return !1;
  return !0;
}
function _ge(e, t) {
  const n = Math.abs(e);
  return n < t ? 0 : Math.sign(e) * (n - t) / (1 - t);
}
let Sge = class {
  constructor(t, n) {
    this.element = t, this.input = n, this._hasEventListeners = !1, this._onConnectGamepad = (s) => {
      this._connectGamepad(s.gamepad);
    }, this._onDisconnectGamepad = (s) => {
      const o = s.gamepad, a = o.index, l = this.inputDevices[a];
      l && (this._emitGamepadEvent(o, _N(l), !1), this.inputDevices.splice(a, 1), this.latestUpdate.splice(a, 1), this.input.gamepad.devices.remove(l), this.ensurePollingState());
    }, this.frameTask = null, this.latestUpdate = new Array(), this.inputDevices = new Array(), this.callback = null;
    const r = "getGamepads" in window.navigator, i = window.isSecureContext;
    this.supported = r && i, this.supported && (this._forEachGamepad((s) => this._connectGamepad(s)), window.addEventListener("gamepadconnected", this._onConnectGamepad), window.addEventListener("gamepaddisconnected", this._onDisconnectGamepad), this.ensurePollingState());
  }
  destroy() {
    this.hasEventListeners = !1, this.supported && (window.removeEventListener("gamepadconnected", this._onConnectGamepad), window.removeEventListener("gamepaddisconnected", this._onDisconnectGamepad));
  }
  set hasEventListeners(t) {
    this._hasEventListeners !== t && (this._hasEventListeners = t, this.ensurePollingState());
  }
  get eventsEnabled() {
    return this.supported && this.inputDevices.length > 0 && this._hasEventListeners;
  }
  set onEvent(t) {
    this.callback = t;
  }
  _connectGamepad(t) {
    const n = new e3(t);
    n.deviceType !== "unknown" && (this.inputDevices[t.index] = n, this.input.gamepad.devices.add(n)), this.ensurePollingState();
  }
  ensurePollingState() {
    this.eventsEnabled ? this._startPolling() : this._stopPolling();
  }
  _startPolling() {
    this.frameTask == null && (this.frameTask = df({ update: () => this._readGamepadState() }));
  }
  _stopPolling() {
    this.frameTask != null && (this.frameTask.remove(), this.frameTask = null, this.latestUpdate = new Array());
  }
  _readGamepadState() {
    const t = document.hasFocus(), n = this.element.contains(document.activeElement), r = this.input.gamepad.enabledFocusMode === "document" && !t || this.input.gamepad.enabledFocusMode === "view" && !n;
    this._forEachGamepad((i) => {
      const s = this.inputDevices[i.index];
      if (!s)
        return;
      const o = this.latestUpdate[i.index], a = _N(s), l = r || wge(a);
      o && (o.timestamp === i.timestamp || !o.active && l || bge(o.state, a)) || this._emitGamepadEvent(i, a, !l);
    });
  }
  _forEachGamepad(t) {
    const n = window.navigator.getGamepads();
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      this._validate(i) && t(i);
    }
  }
  _emitGamepadEvent(t, n, r) {
    const i = this.latestUpdate[t.index], s = i && i.active;
    if (!s && !r)
      return;
    const o = !s && r ? "start" : s && r ? "update" : "end";
    this.latestUpdate[t.index] = { timestamp: t.timestamp, state: n, active: r }, this.callback && this.callback({ device: this.inputDevices[t.index], state: n, action: o });
  }
  _validate(t) {
    if (!t || !t.connected)
      return !1;
    for (let n = 0; n < t.axes.length; n++)
      if (isNaN(t.axes[n]))
        return !1;
    return !0;
  }
};
const SN = K("trident"), xN = K("edge"), xge = K("chrome"), $ge = K("ff"), Tge = K("safari"), Hp = { touchNone: "geoscene-view-surface--touch-none", touchPan: "geoscene-view-surface--touch-pan" };
let dU = class pU {
  constructor(t, n) {
    this.input = n, this._active = {}, this._activePointerCaptures = /* @__PURE__ */ new Set(), this._keyDownState = /* @__PURE__ */ new Set(), this._eventId = 1, this._browserTouchPanningEnabled = !1, this._element = t, t.getAttribute("tabindex") || t.setAttribute("tabindex", "0"), this._eventHandlers = { "key-down": this._handleKey, "key-up": this._handleKey, "pointer-down": this._handlePointer, "pointer-move": this._handlePointerPreventDefault, "pointer-up": this._handlePointerPreventDefault, "pointer-enter": this._handlePointer, "pointer-leave": this._handlePointer, "pointer-cancel": this._handlePointer, "mouse-wheel": this._handleMouseWheel, "pointer-capture-lost": this._handlePointerCaptureLost }, this._updateTouchAction(), this._element.addEventListener("keydown", this._preventAltKeyDefault), this._gamepadSource = new Sge(t, this.input), this._gamepadSource.onEvent = (r) => this._callback("gamepad", r);
  }
  destroy() {
    this._callback = null, this.activeEvents = null, this._activePointerCaptures.forEach((t) => {
      this._releasePointerCaptureSafe(t);
    }), this._gamepadSource && (this._gamepadSource.destroy(), this._gamepadSource = null), this._activePointerCaptures = null, this._removeTouchAction(), this._element.removeEventListener("keydown", this._preventAltKeyDefault);
  }
  get browserTouchPanningEnabled() {
    return this._browserTouchPanningEnabled;
  }
  set browserTouchPanningEnabled(t) {
    this._browserTouchPanningEnabled = t, this._updateTouchAction(), this._updateTouchEventHandling();
  }
  set onEventReceived(t) {
    this._callback = t;
  }
  set activeEvents(t) {
    for (const n in this._active)
      if (!t || !t.has(n)) {
        const r = this._active[n];
        this._element.removeEventListener(Ux[n], r), delete this._active[n];
      }
    t && t.forEach((n) => {
      if (!this._active[n] && Ux[n]) {
        const r = (this._eventHandlers[n] || this._handleDefault).bind(this, n);
        this._element.addEventListener(Ux[n], r), this._active[n] = r;
      }
    }), this._gamepadSource.hasEventListeners = t && t.has("gamepad");
  }
  setPointerCapture(t, n) {
    n ? (this._element.setPointerCapture(t.pointerId), this._activePointerCaptures.add(t.pointerId)) : (this._releasePointerCaptureSafe(t.pointerId), this._activePointerCaptures.delete(t.pointerId));
  }
  _updateTouchAction() {
    this._element.classList.remove(this._browserTouchPanningEnabled ? Hp.touchNone : Hp.touchPan), this._element.classList.add(this._browserTouchPanningEnabled ? Hp.touchPan : Hp.touchNone);
  }
  _updateTouchEventHandling() {
    this._browserTouchPanningEnabled ? this._element.addEventListener("touchmove", this._preventMultiTouchPanning) : this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _removeTouchAction() {
    this._element.classList.remove(Hp.touchNone), this._element.classList.remove(Hp.touchPan), this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _releasePointerCaptureSafe(t) {
    try {
      if (this._element.hasPointerCapture && !this._element.hasPointerCapture(t))
        return;
      this._element.releasePointerCapture(t);
    } catch {
    }
  }
  _updateNormalizedPointerLikeEvent(t, n) {
    const r = jB(this._element, t);
    return pU.test.disableSubpixelCoordinates && (r.x = Math.round(r.x), r.y = Math.round(r.y)), n.x = r.x, n.y = r.y, n;
  }
  _handleKey(t, n) {
    const r = rme(n);
    r && t === "key-up" && this._keyDownState.delete(r);
    const i = { native: n, key: r, repeat: r && this._keyDownState.has(r) };
    r && t === "key-down" && this._keyDownState.add(i.key), this._callback(t, i);
  }
  _handlePointer(t, n) {
    const r = this._updateNormalizedPointerLikeEvent(n, { native: n, x: 0, y: 0, pointerType: n.pointerType, button: n.button, buttons: n.buttons, eventId: this._eventId++ });
    this._callback(t, r);
  }
  _handlePointerPreventDefault(t, n) {
    const r = this._updateNormalizedPointerLikeEvent(n, { native: n, x: 0, y: 0, pointerType: n.pointerType, button: n.button, buttons: n.buttons, eventId: this._eventId++ });
    n.preventDefault(), this._callback(t, r);
  }
  _handleMouseWheel(t, n) {
    let r = n.deltaY;
    switch (n.deltaMode) {
      case 0:
        (SN || xN) && (r = r / document.documentElement.clientHeight * 600);
        break;
      case 1:
        r *= 30;
        break;
      case 2:
        r *= 900;
    }
    SN || xN ? r *= 0.7 : xge || Tge ? r *= 0.6 : $ge && (r *= 1.375);
    const i = 100, s = Math.abs(r);
    s > i && (r = r / s * 200 / (1 + Math.exp(-0.02 * (s - i))));
    const o = this._updateNormalizedPointerLikeEvent(n, { native: n, x: 0, y: 0, deltaY: r });
    this._callback(t, o);
  }
  _handlePointerCaptureLost(t, n) {
    this._activePointerCaptures.delete(n.pointerId), this._handleDefault(t, n);
  }
  _handleDefault(t, n) {
    const r = { native: n };
    n.preventDefault(), this._callback(t, r);
  }
  _preventAltKeyDefault(t) {
    t.key === "Alt" && t.preventDefault();
  }
  _preventMultiTouchPanning(t) {
    t.touches.length > 1 && t.preventDefault();
  }
};
dU.test = { disableSubpixelCoordinates: !1 };
const Ux = { "key-down": "keydown", "key-up": "keyup", "pointer-down": "pointerdown", "pointer-up": "pointerup", "pointer-move": "pointermove", "mouse-wheel": "wheel", "pointer-capture-got": "gotpointercapture", "pointer-capture-lost": "lostpointercapture", "context-menu": "contextmenu", "pointer-enter": "pointerenter", "pointer-leave": "pointerleave", "pointer-cancel": "pointercancel", focus: "focus", blur: "blur" };
let Ege = class extends dr {
  constructor() {
    super(!0), this.registerIncoming("context-menu", (t) => {
      t.data.native.preventDefault();
    });
  }
};
function l3(e, t) {
  return Math.abs(t.x - e.x) + Math.abs(t.y - e.y);
}
function Ige(e, t) {
  const n = t.x - e.x, r = t.y - e.y;
  return Math.sqrt(n * n + r * r);
}
function Mge(e, t) {
  if (t ? (t.radius = 0, t.center.x = 0, t.center.y = 0) : t = { radius: 0, center: wi() }, e.length === 0)
    return t;
  if (e.length === 1)
    return t.center.x = e[0].x, t.center.y = e[0].y, t;
  if (e.length === 2) {
    const [$, I] = e, [M, E] = [I.x - $.x, I.y - $.y];
    return t.radius = Math.sqrt(M * M + E * E) / 2, t.center.x = ($.x + I.x) / 2, t.center.y = ($.y + I.y) / 2, t;
  }
  let n = 0, r = 0;
  for (let $ = 0; $ < e.length; $++)
    n += e[$].x, r += e[$].y;
  n /= e.length, r /= e.length;
  const i = e.map(($) => $.x - n), s = e.map(($) => $.y - r);
  let o = 0, a = 0, l = 0, c = 0, p = 0, f = 0, m = 0;
  for (let $ = 0; $ < i.length; $++) {
    const I = i[$], M = s[$], E = I * I, C = M * M;
    o += E, a += C, l += I * M, c += E * I, p += C * M, f += I * C, m += M * E;
  }
  const y = 0.5 * (c + f), g = 0.5 * (p + m), v = o * a - l * l, w = (y * a - g * l) / v, b = (o * g - l * y) / v, S = wi(w + n, b + r);
  return { radius: Math.sqrt(w * w + b * b + (o + a) / e.length), center: S };
}
const Rs = { maximumDoubleClickDelay: 250, maximumDoubleClickDistance: 10, maximumDoubleTouchDelay: 350, maximumDoubleTouchDistance: 35 };
let Cge = class extends dr {
  constructor(t = Rs.maximumDoubleClickDelay, n = Rs.maximumDoubleClickDistance, r = Rs.maximumDoubleTouchDelay, i = Rs.maximumDoubleTouchDistance, s = m0) {
    super(!1), this.maximumDoubleClickDelay = t, this.maximumDoubleClickDistance = n, this.maximumDoubleTouchDelay = r, this.maximumDoubleTouchDistance = i, this._clock = s, this._pointerState = /* @__PURE__ */ new Map(), this._click = this.registerOutgoing("click"), this._doubleClick = this.registerOutgoing("double-click"), this.registerIncoming("immediate-click", this._handleImmediateClick.bind(this)), this.registerIncoming("pointer-drag", this._handlePointerDrag.bind(this)), this.registerIncoming("drag", this._handleDrag.bind(this));
  }
  onUninstall() {
    this._pointerState.forEach((t) => t.doubleClickTimeout = Sp(t.doubleClickTimeout));
  }
  get hasPendingInputs() {
    return H_(this._pointerState, (t) => t.doubleClickTimeout != null);
  }
  _pointerId(t) {
    const n = t.native;
    return n.pointerType === "mouse" ? `${n.pointerId}:${n.button}` : `${n.pointerType}`;
  }
  _handleImmediateClick(t) {
    const n = t.data, r = this._pointerId(n), i = this._pointerState.get(r);
    if (i) {
      const s = n.native.pointerType === "touch" ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance;
      l3(i.event.data, n) > s ? (this._clearDoubleClickTimeout(r, !0), this._startClick(t)) : (this._clearDoubleClickTimeout(r, !1), this._doubleClick.emit(i.event.data, void 0, i.event.modifiers));
    } else
      this._startClick(t);
  }
  _startClick(t) {
    const n = this._pointerId(t.data), r = t.data.native.pointerType === "touch" ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay;
    this._pointerState.set(n, { event: t, doubleClickTimeout: this._clock.setTimeout(() => this._doubleClickTimeoutExceeded(n), r) }), this.refreshHasPendingInputs();
  }
  _handlePointerDrag(t) {
    const n = this._pointerId(t.data.currentEvent);
    this._clearDoubleClickTimeout(n, !0);
  }
  _handleDrag(t) {
    const n = this._pointerId(t.data.pointer);
    this._clearDoubleClickTimeout(n, !0);
  }
  _clearDoubleClickTimeout(t, n) {
    const r = this._pointerState.get(t);
    r && (r.doubleClickTimeout.remove(), r.doubleClickTimeout = null, n && this._doubleClickTimeoutExceeded(t), this._pointerState.delete(t), this.refreshHasPendingInputs());
  }
  _doubleClickTimeoutExceeded(t) {
    const n = this._pointerState.get(t);
    this._click.emit(n.event.data, void 0, n.event.modifiers), n.doubleClickTimeout = null, this._pointerState.delete(t), this.refreshHasPendingInputs();
  }
}, Oge = class extends dr {
  constructor(t = Rs.maximumDoubleClickDelay, n = Rs.maximumDoubleClickDistance, r = Rs.maximumDoubleTouchDelay, i = Rs.maximumDoubleTouchDistance, s = m0) {
    super(!1), this.maximumDoubleClickDelay = t, this.maximumDoubleClickDistance = n, this.maximumDoubleTouchDelay = r, this.maximumDoubleTouchDistance = i, this._clock = s, this._doubleTapDragReady = !1, this._doubleTapDragActive = !1, this._dragStartCenter = wi(0, 0), this._pointerState = /* @__PURE__ */ new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new FS({ start: (o, a) => this._dragStart(o, a), update: (o, a) => this._dragUpdate(a), end: (o, a) => this._dragEnd(a) }), this.registerIncoming("drag", (o) => this._dragEventSeparator.handle(o)), this.registerIncoming("pointer-down", (o) => this._handlePointerDown(o)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.doubleTapTimeout != null && (t.doubleTapTimeout.remove(), t.doubleTapTimeout = null);
    });
  }
  get hasPendingInputs() {
    return H_(this._pointerState, (t) => t.doubleTapTimeout != null);
  }
  _clearPointerDown(t) {
    const n = this._pointerState.get(t);
    n && (n.doubleTapTimeout.remove(), n.doubleTapTimeout = null, this._pointerState.delete(t), this.refreshHasPendingInputs());
  }
  _createDoubleTapDragData(t, n, r) {
    const { button: i, buttons: s, pointer: o, pointers: a, pointerType: l, timestamp: c } = r;
    return { action: t, delta: n, button: i, buttons: s, pointer: o, pointers: a, pointerType: l, timestamp: c };
  }
  _dragStart(t, n) {
    if (!this._doubleTapDragReady || t !== 1)
      return;
    this._doubleTapDragReady = !1, this._doubleTapDragActive = !0;
    const { data: r, modifiers: i } = n, { center: s } = r;
    this._dragStartCenter = s;
    const o = this._createDoubleTapDragData("begin", wi(0, 0), r);
    this._doubleTapDrag.emit(o, void 0, i), n.stopPropagation();
  }
  _dragUpdate(t) {
    if (!this._doubleTapDragActive)
      return;
    const { data: n, modifiers: r } = t, { center: i } = n, s = wi(i.x - this._dragStartCenter.x, i.y - this._dragStartCenter.y), o = this._createDoubleTapDragData("update", s, n);
    this._doubleTapDrag.emit(o, void 0, r), t.stopPropagation();
  }
  _dragEnd(t) {
    if (!this._doubleTapDragActive)
      return;
    const { data: n, modifiers: r } = t, { center: i } = n, s = wi(i.x - this._dragStartCenter.x, i.y - this._dragStartCenter.y), o = this._createDoubleTapDragData("end", s, n);
    this._doubleTapDrag.emit(o, void 0, r), this._doubleTapDragActive = !1, t.stopPropagation();
  }
  _handlePointerDown(t) {
    const { data: n } = t, r = this._pointerId(n), i = this._pointerState.get(r), { pointerType: s } = n.native;
    if (i) {
      const o = s === "touch" ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance;
      this._clearPointerDown(r), l3(i.event.data, n) > o ? this._storePointerDown(t) : this._doubleTapDragReady = !0;
    } else
      this._storePointerDown(t);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = !1;
  }
  _pointerId(t) {
    const { native: n } = t, { pointerId: r, button: i, pointerType: s } = n;
    return s === "mouse" ? `${r}:${i}` : `${s}`;
  }
  _storePointerDown(t) {
    const { data: n } = t, { pointerType: r } = n.native, i = this._pointerId(n), s = r === "touch" ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay, o = this._clock.setTimeout(() => this._clearPointerDown(i), s);
    this._pointerState.set(i, { event: t, doubleTapTimeout: o }), this.refreshHasPendingInputs();
  }
}, kge = class extends dr {
  constructor(t) {
    super(!1), this.navigationTouch = t, this.startStateModifiers = /* @__PURE__ */ new Set(), this.activePointerMap = /* @__PURE__ */ new Map(), this.isDragging = !1, this.isCurrentDragSuppressed = !1, this.drag = this.registerOutgoing("drag"), this.registerIncoming("pointer-drag", this._handlePointerDrag.bind(this)), this.registerIncoming("pointer-up", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-capture-lost", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-cancel", this._handlePointerUpAndPointerLost.bind(this));
  }
  _createPayload(t, n, r, i) {
    return { action: t, pointerType: this.pointerType, button: this.mouseButton, buttons: n.buttons, timestamp: i, pointers: Age(this.activePointerMap), pointer: n, angle: r.angle, radius: r.radius, center: r.center };
  }
  _addPointer(t) {
    const n = t.native.pointerId, r = Yv(this.activePointerMap).angle, i = { event: t, initialAngle: 0, lastAngle: 0 };
    this.activePointerMap.set(n, i);
    const s = kw(i, hU(this.activePointerMap));
    i.initialAngle = s, i.lastAngle = s, this._updatePointerAngles(r);
  }
  _updatePointer(t) {
    if (t && t.x == null && t.y == null)
      return;
    const n = t.native.pointerId, r = this.activePointerMap.get(n);
    r ? r.event = t : this._addPointer(t);
  }
  _removePointer(t) {
    const n = Yv(this.activePointerMap).angle;
    this.activePointerMap.delete(t), this._updatePointerAngles(n);
  }
  _updatePointerAngles(t) {
    const n = Yv(this.activePointerMap);
    this.activePointerMap.forEach((r) => {
      r.initialAngle = kw(r, n) - t, r.lastAngle = kw(r, n) - t;
    });
  }
  _emitEvent(t, n, r) {
    const i = Yv(this.activePointerMap);
    this.drag.emit(this._createPayload(t, n, i, r), void 0, this.startStateModifiers);
  }
  _handlePointerUpAndPointerLost(t) {
    const n = t.data.native.pointerId, r = t.timestamp;
    this.activePointerMap.get(n) && (this.activePointerMap.size === 1 ? (this._updatePointer(t.data), !this.isCurrentDragSuppressed && this._emitEvent("end", t.data, r), this.isDragging = !1, this.isCurrentDragSuppressed = !1, this._removePointer(n)) : (this._removePointer(n), this._emitEvent("removed", t.data, t.timestamp)));
  }
  _handlePointerDrag(t) {
    const n = t.data, r = n.currentEvent, i = t.timestamp;
    switch (n.action) {
      case "start":
      case "update":
        this.isDragging ? this.activePointerMap.has(r.native.pointerId) ? (this._updatePointer(r), !this.isCurrentDragSuppressed && this._emitEvent("update", r, i)) : (this._addPointer(r), this._emitEvent("added", r, i), this.isCurrentDragSuppressed = this.isSuppressed) : (this._updatePointer(r), this.pointerType = t.data.startEvent.pointerType, this.mouseButton = t.data.startEvent.button, this.startStateModifiers = t.modifiers, this.isDragging = !0, this.isCurrentDragSuppressed = this.isSuppressed, !this.isCurrentDragSuppressed && this._emitEvent("start", r, i));
    }
  }
  get isSuppressed() {
    return this.navigationTouch && !this.navigationTouch.browserTouchPanEnabled && this.pointerType === "touch" && this.activePointerMap.size === 1;
  }
};
function hU(e) {
  const t = [];
  return e.forEach((n) => {
    t.push(wi(n.event.x, n.event.y));
  }), Mge(t);
}
function Yv(e) {
  const t = hU(e);
  let n = 0;
  return e.forEach((r) => {
    let i = kw(r, t), s = i - r.lastAngle;
    for (; s > Math.PI; )
      s -= 2 * Math.PI;
    for (; s < -Math.PI; )
      s += 2 * Math.PI;
    i = r.lastAngle + s, r.lastAngle = i;
    const o = i - r.initialAngle;
    n += o;
  }), n /= e.size || 1, { angle: n, radius: t.radius, center: t.center };
}
function Age(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((n, r) => t.set(r, n.event)), t;
}
function kw(e, t) {
  const n = e.event, r = n.x - t.center.x, i = n.y - t.center.y;
  return Math.atan2(i, r);
}
var $N;
(function(e) {
  e[e.Left = 0] = "Left", e[e.Middle = 1] = "Middle", e[e.Right = 2] = "Right", e[e.Back = 3] = "Back", e[e.Forward = 4] = "Forward", e[e.Undefined = -1] = "Undefined";
})($N || ($N = {}));
let Pge = class extends dr {
  constructor(t = Rs.maximumDoubleClickDelay, n = Rs.maximumDoubleClickDistance, r = Rs.maximumDoubleTouchDelay, i = Rs.maximumDoubleTouchDistance, s = m0) {
    super(!1), this.maximumDoubleClickDelay = t, this.maximumDoubleClickDistance = n, this.maximumDoubleTouchDelay = r, this.maximumDoubleTouchDistance = i, this._clock = s, this._pointerState = /* @__PURE__ */ new Map(), this._immediateDoubleClick = this.registerOutgoing("immediate-double-click"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", (o) => {
      this._handlePointerLoss(o, "pointer-up");
    }), this.registerIncoming("pointer-capture-lost", (o) => {
      this._handlePointerLoss(o, "pointer-capture-lost");
    }), this.registerIncoming("pointer-cancel", (o) => {
      this._handlePointerLoss(o, "pointer-cancel");
    });
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.immediateDoubleClick && t.immediateDoubleClick.timeoutHandle.remove();
    }), super.onUninstall();
  }
  _handlePointerDown(t) {
    const n = t.data, r = this._pointerId(n);
    if (!this._pointerState.has(r)) {
      const i = { downButton: n.native.button, immediateDoubleClick: null };
      this._pointerState.set(r, i), this.startCapturingPointer(n.native);
    }
  }
  _handlePointerLoss(t, n) {
    const r = t.data, i = this._pointerId(r), s = this._pointerState.get(i);
    if (s && n === "pointer-up" && s.downButton === r.native.button) {
      const o = s.immediateDoubleClick;
      if (o) {
        o.timeoutHandle.remove();
        const a = t.data.native.pointerType === "touch" ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance;
        l3(o, t.data) > a ? this._startImmediateDoubleClick(t, s) : (this._immediateDoubleClick.emit(t.data, void 0, o.modifiers), this._removeState(r));
      } else
        this._startImmediateDoubleClick(t, s);
    }
  }
  _startImmediateDoubleClick(t, n) {
    const r = t.data.native.pointerType === "touch" ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay;
    n.immediateDoubleClick = { x: t.data.x, y: t.data.y, modifiers: t.modifiers, timeoutHandle: this._clock.setTimeout(() => this._removeState(t.data), r) };
  }
  _pointerId(t) {
    const n = t.native;
    return n.pointerType === "mouse" ? `${n.pointerId}:${n.button}` : `${n.pointerType}`;
  }
  _removeState(t) {
    const n = this._pointerId(t);
    this._pointerState.delete(n), this.stopCapturingPointer(t.native), this.refreshHasPendingInputs();
  }
};
const Nm = { maximumClickDelay: 300, movementUntilMouseDrag: 1.5, movementUntilPenDrag: 6, movementUntilTouchDrag: 6, holdDelay: 500 };
let Rge = class extends dr {
  constructor(t = Nm.maximumClickDelay, n = Nm.movementUntilMouseDrag, r = Nm.movementUntilPenDrag, i = Nm.movementUntilTouchDrag, s = Nm.holdDelay, o = m0) {
    super(!1), this.maximumClickDelay = t, this.movementUntilMouseDrag = n, this.movementUntilPenDrag = r, this.movementUntilTouchDrag = i, this.holdDelay = s, this._clock = o, this._pointerState = /* @__PURE__ */ new Map(), this._pointerDrag = this.registerOutgoing("pointer-drag"), this._immediateClick = this.registerOutgoing("immediate-click"), this._pointerHold = this.registerOutgoing("hold"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", (a) => {
      this._handlePointerLoss(a, "pointer-up");
    }), this.registerIncoming("pointer-capture-lost", (a) => {
      this._handlePointerLoss(a, "pointer-capture-lost");
    }), this.registerIncoming("pointer-cancel", (a) => {
      this._handlePointerLoss(a, "pointer-cancel");
    }), this._moveHandle = this.registerIncoming("pointer-move", this._handlePointerMove.bind(this)), this._moveHandle.pause();
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.holdTimeout != null && (t.holdTimeout.remove(), t.holdTimeout = null);
    }), super.onUninstall();
  }
  _handlePointerDown(t) {
    const n = t.data, r = n.native.pointerId;
    let i = null;
    this._pointerState.size === 0 && (i = this._clock.setTimeout(() => {
      const o = this._pointerState.get(r);
      if (o) {
        if (!o.isDragging) {
          const a = o.previousEvent;
          this._pointerHold.emit(a, void 0, t.modifiers), o.holdEmitted = !0;
        }
        o.holdTimeout = null;
      }
    }, this.holdDelay));
    const s = { startEvent: n, previousEvent: n, startTimestamp: t.timestamp, isDragging: !1, downButton: n.native.button, holdTimeout: i, modifiers: /* @__PURE__ */ new Set() };
    this._pointerState.set(r, s), this.startCapturingPointer(n.native), this._moveHandle.resume(), this._pointerState.size > 1 && this._startDragging(t);
  }
  _createPointerDragData(t, n, r) {
    return { action: t, startEvent: n.startEvent, previousEvent: n.previousEvent, currentEvent: r };
  }
  _handlePointerMove(t) {
    const n = t.data, r = n.native.pointerId, i = this._pointerState.get(r);
    i && (i.isDragging ? this._pointerDrag.emit(this._createPointerDragData("update", i, n), void 0, i.modifiers) : Ige(n, i.startEvent) > this._getDragThreshold(n.native.pointerType) && this._startDragging(t), i.previousEvent = n);
  }
  _getDragThreshold(t) {
    switch (t) {
      case "touch":
        return this.movementUntilTouchDrag;
      case "pen":
        return this.movementUntilPenDrag;
      default:
        return this.movementUntilMouseDrag;
    }
  }
  _startDragging(t) {
    const n = t.data, r = n.native.pointerId;
    this._pointerState.forEach((i) => {
      i.holdTimeout != null && (i.holdTimeout.remove(), i.holdTimeout = null), i.isDragging || (i.modifiers = t.modifiers, i.isDragging = !0, r === i.startEvent.native.pointerId ? this._pointerDrag.emit(this._createPointerDragData("start", i, n)) : this._pointerDrag.emit(this._createPointerDragData("start", i, i.previousEvent), t.timestamp));
    });
  }
  _handlePointerLoss(t, n) {
    const r = t.data, i = r.native.pointerId, s = this._pointerState.get(i);
    s && (s.holdTimeout != null && (s.holdTimeout.remove(), s.holdTimeout = null), s.isDragging ? this._pointerDrag.emit(this._createPointerDragData("end", s, n === "pointer-up" ? r : s.previousEvent), void 0, s.modifiers) : n === "pointer-up" && s.downButton === r.native.button && t.timestamp - s.startTimestamp <= this.maximumClickDelay && !s.holdEmitted && this._immediateClick.emit(r), this._pointerState.delete(i), this.stopCapturingPointer(r.native), this._pointerState.size === 0 && this._moveHandle.pause());
  }
};
const Qv = { counter: "Ctrl", pan: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }, zoom: { zoomIn: ["=", "+"], zoomOut: ["-", "_"] }, rotate: { clockwiseOption1: "a", clockwiseOption2: "A", counterClockwiseOption1: "d", counterClockwiseOption2: "D", resetOption1: "n", resetOption2: "N" } };
let Aw = class extends ke {
  constructor() {
    super(...arguments), this._handles = new ei();
  }
  initialize() {
    this._handles.add([Ure(this.view, "ready", () => this._disconnect()), I9(this.view, "ready", () => this._connect())]);
  }
  destroy() {
    this._handles && (this._handles.removeAll(), this._handles = null), this._disconnect();
  }
  _disconnect() {
    this._inputManager && (this.view.viewEvents.disconnect(), this._inputManager.destroy(), this._inputManager = null, this._source.destroy(), this._source = null);
  }
  _connect() {
    const t = this.view.surface, n = new dU(t, this.view.input), r = [new Pge(), new Rge(), new Cge(), new kge(this.view.navigation), new Oge()], i = new ud({ eventSource: n, recognizers: r });
    i.installHandlers("prevent-context-menu", [new Ege()], Yu.INTERNAL), i.installHandlers("navigation", [new vge(this.view), new uge(this.view), new gge(this.view), new wN(this.view), new wN(this.view, [Qv.counter]), new ige(this.view, "primary"), new hge(this.view, Qv.pan), new mge(this.view, Qv.zoom), new fge(this.view, Qv.rotate), new sge(this.view, "secondary"), new rge(this.view, "touch")], Yu.INTERNAL), this.view.viewEvents.connect(i), this._source = n, this._inputManager = i, gn(this.view.navigation, "browserTouchPanEnabled", (s) => {
      this._source.browserTouchPanningEnabled = !s;
    });
  }
  get test() {
    return { inputManager: this._inputManager };
  }
};
u([d()], Aw.prototype, "view", void 0), Aw = u([T("geoscene.views.2d.input.MapViewInputManager")], Aw);
const Lge = Aw;
var TN, EN, IN, fU = { exports: {} };
TN = fU, EN = function() {
  function e(i, s, o, a, l) {
    t(i, s, o || 0, a || i.length - 1, l || r);
  }
  function t(i, s, o, a, l) {
    for (; a > o; ) {
      if (a - o > 600) {
        var c = a - o + 1, p = s - o + 1, f = Math.log(c), m = 0.5 * Math.exp(2 * f / 3), y = 0.5 * Math.sqrt(f * m * (c - m) / c) * (p - c / 2 < 0 ? -1 : 1);
        t(i, s, Math.max(o, Math.floor(s - p * m / c + y)), Math.min(a, Math.floor(s + (c - p) * m / c + y)), l);
      }
      var g = i[s], v = o, w = a;
      for (n(i, o, s), l(i[a], g) > 0 && n(i, o, a); v < w; ) {
        for (n(i, v, w), v++, w--; l(i[v], g) < 0; )
          v++;
        for (; l(i[w], g) > 0; )
          w--;
      }
      l(i[o], g) === 0 ? n(i, o, w) : n(i, ++w, a), w <= s && (o = w + 1), s <= w && (a = w - 1);
    }
  }
  function n(i, s, o) {
    var a = i[s];
    i[s] = i[o], i[o] = a;
  }
  function r(i, s) {
    return i < s ? -1 : i > s ? 1 : 0;
  }
  return e;
}, (IN = EN()) !== void 0 && (TN.exports = IN);
const Fge = fU.exports;
function p_(e, t) {
  if (!(this instanceof p_))
    return new p_(e, t);
  this._maxEntries = Math.max(4, e || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), t && (typeof t == "function" ? this.toBBox = t : this._initFormat(t)), this.clear();
}
function Nge(e, t, n) {
  if (!n)
    return t.indexOf(e);
  for (var r = 0; r < t.length; r++)
    if (n(e, t[r]))
      return r;
  return -1;
}
function Jp(e, t) {
  Uy(e, 0, e.children.length, t, e);
}
function Uy(e, t, n, r, i) {
  i || (i = kh(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (var s, o = t; o < n; o++)
    s = e.children[o], qy(i, e.leaf ? r(s) : s);
  return i;
}
function qy(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function MN(e, t) {
  return e.minX - t.minX;
}
function CN(e, t) {
  return e.minY - t.minY;
}
function qx(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function Xv(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Dge(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function jge(e, t) {
  var n = Math.max(e.minX, t.minX), r = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);
  return Math.max(0, i - n) * Math.max(0, s - r);
}
function Gx(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function eb(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function kh(e) {
  return { children: e, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function ON(e, t, n, r, i) {
  for (var s, o = [t, n]; o.length; )
    (n = o.pop()) - (t = o.pop()) <= r || (s = t + Math.ceil((n - t) / r / 2) * r, Fge(e, s, t, n, i), o.push(t, s, s, n));
}
p_.prototype = { all: function() {
  return this._all(this.data, []);
}, search: function(e) {
  var t = this.data, n = [], r = this.toBBox;
  if (!eb(e, t))
    return n;
  for (var i, s, o, a, l = []; t; ) {
    for (i = 0, s = t.children.length; i < s; i++)
      o = t.children[i], eb(e, a = t.leaf ? r(o) : o) && (t.leaf ? n.push(o) : Gx(e, a) ? this._all(o, n) : l.push(o));
    t = l.pop();
  }
  return n;
}, collides: function(e) {
  var t = this.data, n = this.toBBox;
  if (!eb(e, t))
    return !1;
  for (var r, i, s, o, a = []; t; ) {
    for (r = 0, i = t.children.length; r < i; r++)
      if (s = t.children[r], eb(e, o = t.leaf ? n(s) : s)) {
        if (t.leaf || Gx(e, o))
          return !0;
        a.push(s);
      }
    t = a.pop();
  }
  return !1;
}, load: function(e) {
  if (!e || !e.length)
    return this;
  if (e.length < this._minEntries) {
    for (var t = 0, n = e.length; t < n; t++)
      this.insert(e[t]);
    return this;
  }
  var r = this._build(e.slice(), 0, e.length - 1, 0);
  if (this.data.children.length)
    if (this.data.height === r.height)
      this._splitRoot(this.data, r);
    else {
      if (this.data.height < r.height) {
        var i = this.data;
        this.data = r, r = i;
      }
      this._insert(r, this.data.height - r.height - 1, !0);
    }
  else
    this.data = r;
  return this;
}, insert: function(e) {
  return e && this._insert(e, this.data.height - 1), this;
}, clear: function() {
  return this.data = kh([]), this;
}, remove: function(e, t) {
  if (!e)
    return this;
  for (var n, r, i, s, o = this.data, a = this.toBBox(e), l = [], c = []; o || l.length; ) {
    if (o || (o = l.pop(), r = l[l.length - 1], n = c.pop(), s = !0), o.leaf && (i = Nge(e, o.children, t)) !== -1)
      return o.children.splice(i, 1), l.push(o), this._condense(l), this;
    s || o.leaf || !Gx(o, a) ? r ? (n++, o = r.children[n], s = !1) : o = null : (l.push(o), c.push(n), n = 0, r = o, o = o.children[0]);
  }
  return this;
}, toBBox: function(e) {
  return e;
}, compareMinX: MN, compareMinY: CN, toJSON: function() {
  return this.data;
}, fromJSON: function(e) {
  return this.data = e, this;
}, _all: function(e, t) {
  for (var n = []; e; )
    e.leaf ? t.push.apply(t, e.children) : n.push.apply(n, e.children), e = n.pop();
  return t;
}, _build: function(e, t, n, r) {
  var i, s = n - t + 1, o = this._maxEntries;
  if (s <= o)
    return Jp(i = kh(e.slice(t, n + 1)), this.toBBox), i;
  r || (r = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, r - 1))), (i = kh([])).leaf = !1, i.height = r;
  var a, l, c, p, f = Math.ceil(s / o), m = f * Math.ceil(Math.sqrt(o));
  for (ON(e, t, n, m, this.compareMinX), a = t; a <= n; a += m)
    for (ON(e, a, c = Math.min(a + m - 1, n), f, this.compareMinY), l = a; l <= c; l += f)
      p = Math.min(l + f - 1, c), i.children.push(this._build(e, l, p, r - 1));
  return Jp(i, this.toBBox), i;
}, _chooseSubtree: function(e, t, n, r) {
  for (var i, s, o, a, l, c, p, f; r.push(t), !t.leaf && r.length - 1 !== n; ) {
    for (p = f = 1 / 0, i = 0, s = t.children.length; i < s; i++)
      l = qx(o = t.children[i]), (c = Dge(e, o) - l) < f ? (f = c, p = l < p ? l : p, a = o) : c === f && l < p && (p = l, a = o);
    t = a || t.children[0];
  }
  return t;
}, _insert: function(e, t, n) {
  var r = this.toBBox, i = n ? e : r(e), s = [], o = this._chooseSubtree(i, this.data, t, s);
  for (o.children.push(e), qy(o, i); t >= 0 && s[t].children.length > this._maxEntries; )
    this._split(s, t), t--;
  this._adjustParentBBoxes(i, s, t);
}, _split: function(e, t) {
  var n = e[t], r = n.children.length, i = this._minEntries;
  this._chooseSplitAxis(n, i, r);
  var s = this._chooseSplitIndex(n, i, r), o = kh(n.children.splice(s, n.children.length - s));
  o.height = n.height, o.leaf = n.leaf, Jp(n, this.toBBox), Jp(o, this.toBBox), t ? e[t - 1].children.push(o) : this._splitRoot(n, o);
}, _splitRoot: function(e, t) {
  this.data = kh([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, Jp(this.data, this.toBBox);
}, _chooseSplitIndex: function(e, t, n) {
  var r, i, s, o, a, l, c, p;
  for (l = c = 1 / 0, r = t; r <= n - t; r++)
    o = jge(i = Uy(e, 0, r, this.toBBox), s = Uy(e, r, n, this.toBBox)), a = qx(i) + qx(s), o < l ? (l = o, p = r, c = a < c ? a : c) : o === l && a < c && (c = a, p = r);
  return p;
}, _chooseSplitAxis: function(e, t, n) {
  var r = e.leaf ? this.compareMinX : MN, i = e.leaf ? this.compareMinY : CN;
  this._allDistMargin(e, t, n, r) < this._allDistMargin(e, t, n, i) && e.children.sort(r);
}, _allDistMargin: function(e, t, n, r) {
  e.children.sort(r);
  var i, s, o = this.toBBox, a = Uy(e, 0, t, o), l = Uy(e, n - t, n, o), c = Xv(a) + Xv(l);
  for (i = t; i < n - t; i++)
    s = e.children[i], qy(a, e.leaf ? o(s) : s), c += Xv(a);
  for (i = n - t - 1; i >= t; i--)
    s = e.children[i], qy(l, e.leaf ? o(s) : s), c += Xv(l);
  return c;
}, _adjustParentBBoxes: function(e, t, n) {
  for (var r = n; r >= 0; r--)
    qy(t[r], e);
}, _condense: function(e) {
  for (var t, n = e.length - 1; n >= 0; n--)
    e[n].children.length === 0 ? n > 0 ? (t = e[n - 1].children).splice(t.indexOf(e[n]), 1) : this.clear() : Jp(e[n], this.toBBox);
}, _initFormat: function(e) {
  var t = ["return a", " - b", ";"];
  this.compareMinX = new Function("a", "b", t.join(e[0])), this.compareMinY = new Function("a", "b", t.join(e[1])), this.toBBox = new Function("a", "return {minX: a" + e[0] + ", minY: a" + e[1] + ", maxX: a" + e[2] + ", maxY: a" + e[3] + "};");
} };
let kN = class mU {
  constructor(t, n) {
    this.key = new mp(0, 0, 0, 0), this.bounds = ap(), this.objectIds = /* @__PURE__ */ new Set(), this.key.set(n);
    const r = t.getLODInfoAt(this.key);
    this.tileInfoView = t, this.tileInfoView.getTileBounds(this.bounds, this.key, !0), this.resolution = r.resolution, this.scale = r.scale, this.level = r.level;
  }
  get id() {
    return this.key.id;
  }
  get extent() {
    return Mt.fromBounds(this.bounds, this.tileInfoView.tileInfo.spatialReference);
  }
  get transform() {
    return { originPosition: "upperLeft", scale: [this.resolution, this.resolution], translate: [this.bounds[0], this.bounds[3]] };
  }
  createChildTiles() {
    const t = this.key.getChildKeys(), n = Hr.acquire();
    for (let r = 0; r < t.length; r++)
      n[r] = new mU(this.tileInfoView, t[r]);
    return n;
  }
  getQuantizationParameters() {
    return yV.fromJSON({ mode: "view", originPosition: "upperLeft", tolerance: this.resolution, extent: { xmin: this.bounds[0], ymin: this.bounds[1], xmax: this.bounds[2], ymax: this.bounds[3], spatialReference: this.tileInfoView.tileInfo.spatialReference } });
  }
};
const Cc = { added: [], removed: [] }, Wx = /* @__PURE__ */ new Set(), Vge = new mp(0, 0, 0, 0);
let zge = class extends mc {
  constructor(t) {
    super(), this._tiles = /* @__PURE__ */ new Map(), this._index = p_(9, K("geoscene-csp-restrictions") ? (n) => ({ minX: n.bounds[0], minY: n.bounds[1], maxX: n.bounds[2], maxY: n.bounds[3] }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = t;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(t) {
    return this._tiles.has(t);
  }
  get(t) {
    return this._tiles.get(t);
  }
  boundsIntersections(t) {
    return this._index.search({ minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] });
  }
  updateTiles(t) {
    const n = { added: [], removed: [] };
    for (const r of t.added)
      if (!this.has(r)) {
        const i = new kN(this.tileScheme, r);
        this._tiles.set(r, i), this._index.insert(i), n.added.push(i);
      }
    for (const r of t.removed)
      if (this.has(r)) {
        const i = this.get(r);
        this._tiles.delete(r), this._index.remove(i), n.removed.push(i);
      }
    this.tiles.length = 0, this._tiles.forEach((r) => this.tiles.push(r)), (n.added.length || n.removed.length) && this.emit("update", n);
  }
  setViewState(t) {
    const n = this.tileScheme.getTileCoverage(t, 0);
    if (!n)
      return;
    const { spans: r, lodInfo: i } = n, { level: s } = i;
    if (r.length > 0)
      for (const { row: o, colFrom: a, colTo: l } of r)
        for (let c = a; c <= l; c++) {
          const p = Vge.set(s, o, i.normalizeCol(c), i.getWorldForColumn(c)).id;
          if (Wx.add(p), !this.has(p)) {
            const f = new kN(this.tileScheme, p);
            this._tiles.set(p, f), this._index.insert(f), this.tiles.push(f), Cc.added.push(f);
          }
        }
    for (let o = this.tiles.length - 1; o >= 0; o--) {
      const a = this.tiles[o];
      Wx.has(a.id) || (this._tiles.delete(a.id), this.tiles.splice(o, 1), this._index.remove(a), Cc.removed.push(a));
    }
    (Cc.added.length || Cc.removed.length) && this.emit("update", Cc), If.pool.release(n), Wx.clear(), Cc.added.length = 0, Cc.removed.length = 0;
  }
}, Bge = 0, Eu = class extends ke {
  constructor() {
    super(...arguments), this.color = new Fe([0, 255, 255]), this.haloOpacity = 1, this.fillOpacity = 0.25;
  }
  get version() {
    return Bge++;
  }
};
u([d({ readOnly: !0 })], Eu.prototype, "version", null), u([d({ type: Fe })], Eu.prototype, "color", void 0), u([d({ type: Fe })], Eu.prototype, "haloColor", void 0), u([d()], Eu.prototype, "haloOpacity", void 0), u([d()], Eu.prototype, "fillOpacity", void 0), Eu = u([T("geoscene.views.2d.support.HighlightOptions")], Eu);
const yU = Eu, Uge = (e) => e.indexOf("Brush") !== -1;
let gU = class {
  constructor() {
    this._names = /* @__PURE__ */ new Map();
  }
  begin(t) {
    this._names.has(t) || (this._names.set(t, !1), Uge(t) && this.record("Esri.FirstDraw"), performance.mark(`Esri.${t}.Start`));
  }
  end(t) {
    this._names.has(t) && !this._names.get(t) && (this._names.set(t, !0), performance.mark(`Esri.${t}.End`));
  }
  record(t) {
    this._names.has(t) || (this._names.set(t, !0), performance.mark(`Esri.${t}`));
  }
};
function qge(e, t, n, r, i, s, o, a) {
  let l;
  e.ignorePadding && (r = { left: 0, right: 0, top: 0, bottom: 0 }), e.width != null && e.height != null ? l = [e.width, e.height] : e.width == null && e.height != null ? l = [e.height, e.height] : e.width != null && e.height == null ? l = [e.width, e.width] : e.width == null && e.height == null && (l = null);
  const c = n[0] - (r.left + r.right), p = n[1] - (r.top + r.bottom);
  let f, m, y = e.area || { x: 0, y: 0, width: c, height: p };
  if (l) {
    const g = c / p, v = l[0] / l[1];
    if (v > g) {
      const w = y.width / v;
      y = { x: y.x, y: Math.round(y.y + (y.height - w) / 2), width: y.width, height: Math.round(w) };
    } else {
      const w = y.height * v;
      y = { x: Math.round(y.x + (y.width - w) / 2), y: y.y, width: Math.round(w), height: y.height };
    }
  } else
    l = [y.width, y.height];
  return l[0] > y.width ? (f = Math.min(l[0] / y.width, t), m = l[0] / y.width / f) : (f = 1, m = l[0] / y.width), { resolutionScale: f, cropArea: { x: Math.round((y.x + r.left) * f), y: Math.round((y.y + r.top) * f), width: Math.round(y.width * f), height: Math.round(y.height * f) }, outputScale: m, format: i, quality: s, children: o, rotation: a };
}
function R4e(e, t, n, r) {
  r.premultipliedAlpha && Yge(e), n.width = e.width, n.height = e.height;
  const i = n.getContext("2d");
  i.putImageData(e, 0, 0), r.flipY && Kge(i);
  const s = i.getImageData(0, 0, e.width, e.height), o = Gge(n, t);
  return n.width = 0, n.height = 0, { dataUrl: o, data: s };
}
function Gge(e, t) {
  const n = Qge[t.format], r = t.quality / 100;
  return e.toDataURL(n, r);
}
function Wge(e, t) {
  const n = Zge(e), r = e0e[n];
  return { format: n, quality: js(t ?? r, 0, 100) };
}
function Hge(e, t) {
  return t / Math.max(e[0], e[1]);
}
function L4e(e, t, n) {
  if (!e || !t)
    throw new Error("Cannot construct image data without dimensions");
  if (h_)
    try {
      return new ImageData(e, t);
    } catch {
      h_ = !1;
    }
  return vU(e, t, n);
}
function F4e(e, t, n, r) {
  if (!t || !n)
    throw new Error("Cannot construct image data without dimensions");
  if (h_)
    try {
      return new ImageData(e, t, n);
    } catch {
      h_ = !1;
    }
  const i = vU(t, n, r);
  return i.data.set(e, 0), i;
}
function N4e(e, t, n, r = 0, i = 0, s = e.width - r, o = e.height - i, a = !1) {
  const { data: l } = e, { width: c, height: p, data: f } = t, m = s / c, y = o / p, g = Math.ceil(m / 2), v = Math.ceil(y / 2), w = e.width;
  for (let b = 0; b < p; b++)
    for (let S = 0; S < c; S++) {
      const $ = 4 * (S + (a ? p - b - 1 : b) * c);
      let I = 0, M = 0, E = 0, C = 0, A = 0, W = 0;
      const j = (b + 0.5) * y;
      for (let G = Math.floor(b * y); G < (b + 1) * y; G++) {
        const R = Math.abs(j - (G + 0.5)) / v, V = (S + 0.5) * m, Q = R * R;
        for (let de = Math.floor(S * m); de < (S + 1) * m; de++) {
          const _e = Math.abs(V - (de + 0.5)) / g, ie = Math.sqrt(Q + _e * _e);
          if (ie >= 1)
            continue;
          let Ae = 2 * ie * ie * ie - 3 * ie * ie + 1;
          const Pe = 4 * (r + de + (i + G) * w);
          W += Ae * l[Pe + 3], M += Ae, !n && l[Pe + 3] < 255 && (Ae = Ae * l[Pe + 3] / 255), E += Ae * l[Pe], C += Ae * l[Pe + 1], A += Ae * l[Pe + 2], I += Ae;
        }
      }
      f[$] = E / I, f[$ + 1] = C / I, f[$ + 2] = A / I, f[$ + 3] = W / M;
    }
  return t;
}
function vU(e, t, n) {
  return n || (n = Jge()), n.getContext("2d").createImageData(e, t);
}
let Dm = null, h_ = !0;
function Jge() {
  return Dm || (Dm = document.createElement("canvas"), Dm.width = 1, Dm.height = 1), Dm;
}
function Zge(e) {
  switch (e) {
    case "png":
    case "jpg":
    case "jpeg":
      return e;
    default:
      return Xge;
  }
}
function Kge(e) {
  e.save(), e.globalCompositeOperation = "copy", e.scale(1, -1), e.translate(0, -e.canvas.height), e.drawImage(e.canvas, 0, 0), e.restore();
}
function Yge(e) {
  const t = e.data, n = t.length;
  for (let r = 0; r < n; r += 4) {
    const i = t[r + 3];
    if (i > 0) {
      const s = i / 255;
      t[r + 0] = t[r + 0] / s, t[r + 1] = t[r + 1] / s, t[r + 2] = t[r + 2] / s;
    }
  }
}
const Qge = { png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg" }, AN = 98, Xge = "png", e0e = { png: 100, jpg: AN, jpeg: AN };
var lr;
function D4e(e, t, n = {}) {
  const r = bU(e);
  for (; r.length > 1; ) {
    const i = f_(t, r.shift(), n);
    if (O(i))
      return i;
  }
  return t0e(t, r.shift(), n);
}
function bU(e) {
  const t = K("geoscene-force-webgl");
  if (t === lr.WEBGL1 || t === lr.WEBGL2)
    return [t];
  switch (e) {
    case "2d":
      return [lr.WEBGL1];
    case "3d":
      return [lr.WEBGL2, lr.WEBGL1];
  }
}
function t0e(e, t, n = {}) {
  if (!window.WebGLRenderingContext)
    return PN(e, n0e), null;
  const r = f_(e, t, n);
  return H(r) && PN(e, r0e), r;
}
function f_(e, t, n = {}) {
  const r = t === lr.WEBGL1 ? ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"] : ["webgl2"];
  let i = null;
  for (const s of r) {
    try {
      i = e.getContext(s, n);
    } catch {
    }
    if (i)
      break;
  }
  return i;
}
function PN(e, t) {
  const n = e.parentNode;
  n && (n.innerHTML = '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr><td align="center"><div style="display: table-cell; vertical-align: middle;"><div style="">' + t + "</div></div></td></tr></table>");
}
(function(e) {
  e[e.WEBGL1 = 1] = "WEBGL1", e[e.WEBGL2 = 2] = "WEBGL2";
})(lr || (lr = {}));
const n0e = 'This page requires a browser that supports WebGL.<br/><a href="http://get.webgl.org">Click here to upgrade your browser.</a>', r0e = `It doesn't appear your computer can support WebGL.<br/><a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>`;
let Hx, Jx;
function RN(e) {
  switch (e) {
    case lr.WEBGL1:
      return i0e();
    case lr.WEBGL2:
      return s0e();
  }
}
function i0e() {
  return Hx || (Hx = l0e()), Hx;
}
function s0e() {
  return Jx || (Jx = u0e()), Jx;
}
let wU = class {
  constructor() {
    this.available = !1, this.majorPerformanceCaveat = !1, this.maxTextureSize = 0, this.supportsVertexShaderSamplers = !1, this.supportsHighPrecisionFragment = !1;
  }
}, o0e = class extends wU {
  constructor() {
    super(...arguments), this.type = lr.WEBGL1, this.supportsElementIndexUint = !1, this.supportsStandardDerivatives = !1, this.supportsInstancedArrays = !1, this.supportsTextureFloat = !1;
  }
}, a0e = class extends wU {
  constructor() {
    super(...arguments), this.type = lr.WEBGL2;
  }
};
function _U(e, t) {
  if (e === lr.WEBGL1 && typeof WebGLRenderingContext === void 0 || e === lr.WEBGL2 && typeof WebGL2RenderingContext === void 0)
    return null;
  const n = document.createElement("canvas");
  if (!n)
    return null;
  let r = f_(n, e, { failIfMajorPerformanceCaveat: !0 });
  if (H(r) && (r = f_(n, e), O(r) && (t.majorPerformanceCaveat = !0)), H(r))
    return r;
  if (e === lr.WEBGL1) {
    const s = r.getParameter(r.VERSION), o = s == null ? void 0 : s.match(/^WebGL\s+([\d.]*)/);
    if (o) {
      const a = parseFloat(o[1]);
      t.available = a >= 0.94;
    }
  } else
    t.available = !0;
  t.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), t.supportsVertexShaderSamplers = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
  const i = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
  return i && (t.supportsHighPrecisionFragment = i.precision > 0), r;
}
function l0e() {
  const e = new o0e(), t = _U(lr.WEBGL1, e);
  return H(t) || (e.supportsElementIndexUint = t.getExtension("OES_element_index_uint") !== null, e.supportsStandardDerivatives = t.getExtension("OES_standard_derivatives") !== null, e.supportsInstancedArrays = t.getExtension("ANGLE_instanced_arrays") !== null, e.supportsTextureFloat = t.getExtension("OES_texture_float") !== null), e;
}
function u0e() {
  const e = new a0e();
  return _U(lr.WEBGL2, e), e;
}
function c0e(e) {
  const t = d0e(e);
  if (!t.available)
    return new D("webgl:required", "WebGL is required but not supported.");
  if (e === "3d" && t.majorPerformanceCaveat)
    return new D("webgl:major-performance-caveat-detected", "Your WebGL implementation doesn't seem to support hardware accelerated rendering. Check your browser settings or if your GPU is in a blocklist.");
  if (!t.supportsHighPrecisionFragment)
    return new D("webgl:high-precision-fragment-required", "WebGL support for high precision fragment shaders is required but not supported.");
  if (!t.supportsVertexShaderSamplers)
    return new D("webgl:vertex-shader-samplers-required", "WebGL support for vertex shader samplers is required but not supported.");
  if (t.type === lr.WEBGL1) {
    if (!t.supportsElementIndexUint)
      return new D("webgl:element-index-uint-required", "WebGL support for uint vertex indices is required but not supported.");
    if (!t.supportsStandardDerivatives)
      return new D("webgl:standard-derivatives-required", "WebGL support for standard derivatives is required but not supported.");
    if (!t.supportsInstancedArrays)
      return new D("webgl:instanced-arrays-required", "WebGL support for instanced rendering is required but not supported.");
  }
  return null;
}
function d0e(e) {
  const t = bU(e);
  for (; t.length > 1; ) {
    const n = RN(t.shift());
    if (n.available)
      return n;
  }
  return RN(t.shift());
}
function p0e(e) {
  return e && "nodeType" in e;
}
function h0e(e) {
  return e && typeof e.render == "function";
}
const LN = { component: "geoscene-component" };
let pd = class extends ke {
  constructor() {
    super(...arguments), this.widget = null;
  }
  destroy() {
    this.widget && this.widget.destroy(), this.node = null;
  }
  get id() {
    return this.get("widget.id") || this.get("node.id");
  }
  set node(t) {
    const n = this._get("node");
    t !== n && (t && t.classList.add(LN.component), n && n.classList.remove(LN.component), this._set("node", t));
  }
  castNode(t) {
    return t ? typeof t == "string" || p0e(t) ? (this._set("widget", null), KO(t)) : (h0e(t) && !t.domNode && (t.domNode = document.createElement("div")), this._set("widget", t), t.domNode) : (this._set("widget", null), null);
  }
};
u([d({ dependsOn: [] })], pd.prototype, "id", null), u([d()], pd.prototype, "node", null), u([mt("node")], pd.prototype, "castNode", null), u([d({ readOnly: !0 })], pd.prototype, "widget", void 0), pd = u([T("geoscene.views.ui.Component")], pd);
const Pw = pd, f0e = { left: 0, top: 0, bottom: 0, right: 0 }, SU = { bottom: 30, top: 15, right: 15, left: 15 }, Zx = "manual", jr = { ui: "geoscene-ui", corner: "geoscene-ui-corner", innerContainer: "geoscene-ui-inner-container", manualContainer: "geoscene-ui-manual-container", cornerContainer: "geoscene-ui-corner-container", topLeft: "geoscene-ui-top-left", topRight: "geoscene-ui-top-right", bottomLeft: "geoscene-ui-bottom-left", bottomRight: "geoscene-ui-bottom-right" };
function m0e(e) {
  return e && !e._started && typeof e.postMixInProperties == "function" && typeof e.buildRendering == "function" && typeof e.postCreate == "function" && typeof e.startup == "function";
}
function Kx(e) {
  const t = e, n = typeof t == "object" && t !== null && Object.getPrototypeOf(t);
  return (n === null || n === Object.prototype) && ("component" in t || "index" in t || "position" in t) ? e : null;
}
function Yx(e, { top: t, bottom: n, left: r, right: i }) {
  e.style.top = t, e.style.bottom = n, e.style.left = r, e.style.right = i;
}
let ul = class extends mc.EventedAccessor {
  constructor(e) {
    super(e), this._cornerNameToContainerLookup = {}, this._positionNameToContainerLookup = {}, this._components = new Array(), this._componentToKey = /* @__PURE__ */ new Map(), this._handles = new ei(), this.view = null, this._applyViewPadding = () => {
      const t = this.container;
      t && Yx(t, this._toPxPosition(this._getViewPadding()));
    }, this._applyUIPadding = () => {
      const t = this._innerContainer;
      t && Yx(t, this._toPxPosition(this.padding));
    }, this._initContainers();
  }
  initialize() {
    this._handles.add([Nt(() => {
      var e;
      return [(e = this.view) == null ? void 0 : e.padding, this.container];
    }, this._applyViewPadding, va), Nt(() => this.padding, this._applyUIPadding, va)]);
  }
  destroy() {
    this.container = null;
    for (const e of this._components)
      e.destroy();
    this._components.length = 0, this._handles.destroy(), this._componentToKey.clear();
  }
  set container(e) {
    const t = this._get("container");
    e !== t && (e && (e.classList.add(jr.ui), e.classList.add(Kie()), this._attachContainers(e)), t && (t.classList.remove(jr.ui), Yx(t, { top: "", bottom: "", left: "", right: "" }), e9(t)), this._set("container", e));
  }
  get height() {
    const e = this.get("view.height") || 0;
    if (e === 0)
      return e;
    const t = this._getViewPadding(), n = t.top + t.bottom;
    return Math.max(e - n, 0);
  }
  get padding() {
    return this._get("padding");
  }
  set padding(e) {
    e ? this._override("padding", e) : this._clearOverride("padding");
  }
  castPadding(e) {
    return typeof e == "number" ? { bottom: e, top: e, right: e, left: e } : { ...SU, ...e };
  }
  get width() {
    const e = this.get("view.width") || 0;
    if (e === 0)
      return e;
    const t = this._getViewPadding(), n = t.left + t.right;
    return Math.max(e - n, 0);
  }
  add(e, t) {
    let n, r;
    if (Array.isArray(e))
      return void e.forEach((s) => this.add(s, t));
    const i = Kx(e);
    i && ({ index: n, position: t, component: e, key: r } = i), t && typeof t == "object" && ({ index: n, key: r, position: t } = t), !e || t && !this._isValidPosition(t) || this._add(e, t, n, r);
  }
  remove(e, t) {
    if (!e)
      return;
    if (Array.isArray(e))
      return e.map((r) => this.remove(r, t));
    const n = this._find(e);
    if (n) {
      const r = this._componentToKey;
      if (r.has(e) && r.get(e) !== t)
        return;
      const i = this._components.indexOf(n);
      return n.node.parentNode && n.node.parentNode.removeChild(n.node), this._componentToKey.delete(e), this._components.splice(i, 1)[0];
    }
  }
  empty(e) {
    return Array.isArray(e) ? e.map((t) => this.empty(t)).reduce((t, n) => t.concat(n)) : (e = e || Zx) === Zx ? Array.prototype.slice.call(this._manualContainer.children).filter((t) => !t.classList.contains(jr.corner)).map((t) => this.remove(t)) : this._isValidPosition(e) ? Array.prototype.slice.call(this._cornerNameToContainerLookup[e].children).map(this.remove, this) : null;
  }
  move(e, t) {
    if (Array.isArray(e) && e.forEach((s) => this.move(s, t)), !e)
      return;
    let n;
    const r = Kx(e) || Kx(t);
    if (r && (n = r.index, t = r.position, e = r.component || e), t && !this._isValidPosition(t))
      return;
    const i = this.remove(e);
    i && this.add(i, { position: t, index: n });
  }
  find(e) {
    if (!e)
      return null;
    const t = this._findById(e);
    return t && (t.widget || t.node);
  }
  getPosition(e) {
    for (const t in this._positionNameToContainerLookup)
      if (this._positionNameToContainerLookup[t].contains(e))
        return t;
    return null;
  }
  _add(e, t, n, r) {
    e instanceof Pw || (e = new Pw({ node: e })), this._place({ component: e, position: t, index: n }), this._components.push(e), r && this._componentToKey.set(e, r);
  }
  _find(e) {
    return e ? e instanceof Pw ? this._findByComponent(e) : typeof e == "string" ? this._findById(e) : this._findByNode(e.domNode || e) : null;
  }
  _getViewPadding() {
    return this.get("view.padding") || f0e;
  }
  _attachContainers(e) {
    e.appendChild(this._innerContainer), e.appendChild(this._manualContainer);
  }
  _initContainers() {
    const e = document.createElement("div");
    e.classList.add(jr.innerContainer), e.classList.add(jr.cornerContainer);
    const t = document.createElement("div");
    t.classList.add(jr.innerContainer), t.classList.add(jr.manualContainer);
    const n = document.createElement("div");
    n.classList.add(jr.topLeft), n.classList.add(jr.corner), e.appendChild(n);
    const r = document.createElement("div");
    r.classList.add(jr.topRight), r.classList.add(jr.corner), e.appendChild(r);
    const i = document.createElement("div");
    i.classList.add(jr.bottomLeft), i.classList.add(jr.corner), e.appendChild(i);
    const s = document.createElement("div");
    s.classList.add(jr.bottomRight), s.classList.add(jr.corner), e.appendChild(s), this._innerContainer = e, this._manualContainer = t;
    const o = qu();
    this._cornerNameToContainerLookup = { "top-left": n, "top-right": r, "bottom-left": i, "bottom-right": s, "top-leading": o ? r : n, "top-trailing": o ? n : r, "bottom-leading": o ? s : i, "bottom-trailing": o ? i : s }, this._positionNameToContainerLookup = { manual: t, ...this._cornerNameToContainerLookup };
  }
  _isValidPosition(e) {
    return !!this._positionNameToContainerLookup[e];
  }
  _place(e) {
    const t = e.component, n = e.position || Zx, r = e.index, i = this._positionNameToContainerLookup[n], s = r > -1;
    if (m0e(t.widget) && t.widget.startup(), !s)
      return void i.appendChild(t.node);
    const o = Array.prototype.slice.call(i.children);
    if (r === 0)
      return void (i.firstChild ? eR(t.node, i.firstChild) : i.appendChild(t.node));
    r >= o.length ? i.appendChild(t.node) : eR(t.node, o[r]);
  }
  _toPxPosition(e) {
    return { top: this._toPxUnit(e.top), left: this._toPxUnit(e.left), right: this._toPxUnit(e.right), bottom: this._toPxUnit(e.bottom) };
  }
  _toPxUnit(e) {
    return e === 0 ? "0" : e + "px";
  }
  _findByComponent(e) {
    let t, n = null;
    return this._components.some((r) => (t = r === e, t && (n = r), t)), n;
  }
  _findById(e) {
    let t, n = null;
    return this._components.some((r) => (t = r.id === e, t && (n = r), t)), n;
  }
  _findByNode(e) {
    let t, n = null;
    return this._components.some((r) => (t = r.node === e, t && (n = r), t)), n;
  }
};
u([d()], ul.prototype, "container", null), u([d()], ul.prototype, "height", null), u([d({ value: SU })], ul.prototype, "padding", null), u([mt("padding")], ul.prototype, "castPadding", null), u([d()], ul.prototype, "view", void 0), u([d()], ul.prototype, "width", null), ul = u([T("geoscene.views.ui.UI")], ul);
const y0e = ul;
function FN(e, t) {
  return e && "copyright" in e && (!t || typeof e.originOf == "function" && e.originOf("copyright") === "user");
}
function g0e(e, t) {
  return e.length !== t.length || e.some((n, r) => n.text !== t[r].text);
}
function tb(e, t, n) {
  !n || !t || e.find((r) => r.layerView === t && r.text === n) || e.push({ text: n, layerView: t });
}
function v0e(e) {
  return e.type === "bing-maps";
}
const Ql = [];
let Ah = class extends hf {
  constructor(e) {
    super(e), this._clear = () => {
      this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.handles.remove("suspension"), this.notifyChange("state");
    }, this._pendingAttributions = /* @__PURE__ */ new Set(), this._fetchedAttributionData = /* @__PURE__ */ new Map(), this.items = new Ne(), this.view = null, this._allLayerViewsChange = (t) => {
      this.handles.remove("suspension");
      const n = this.get("view.allLayerViews");
      n && this.handles.add(n.map((r) => r.watch(["suspended", "attributionVisible"], this._updateAttributionItems)), "suspension"), t && t.removed && t.removed.forEach((r) => {
        this._pendingAttributions.delete(r), this._fetchedAttributionData.delete(r);
      }), this._updateAttributionItems();
    }, this._updateAttributionItems = () => {
      const t = this.get("view.allLayerViews");
      Ql.length = 0, t ? (t.forEach((n) => {
        if (n.suspended || !n.get("layer.attributionVisible"))
          return;
        const r = n.layer;
        if (FN(r, "user"))
          return void tb(Ql, n, r.copyright);
        if (r.hasAttributionData) {
          if (this._fetchedAttributionData.has(n)) {
            const s = this._fetchedAttributionData.get(n);
            return void (s ? tb(Ql, n, this._getDynamicAttribution(s, this.view, r)) : FN(r) && tb(Ql, n, r.copyright));
          }
          return void this._fetchAttributionData(n);
        }
        const i = r.get("portalItem.accessInformation");
        tb(Ql, n, i || r.copyright);
      }), g0e(this.items, Ql) && (this.items.removeAll(), this.items.addMany(Ql)), Ql.length = 0, this.notifyChange("state")) : this._clear();
    }, this.handles.add([gS(this, "view.allLayerViews", "change", this._allLayerViewsChange, this._allLayerViewsChange, this._clear), qre(this, "view.stationary", () => this._updateAttributionItems())]);
  }
  destroy() {
    this.view = null, this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.items.removeAll();
  }
  get state() {
    return this.get("view.ready") ? this._pendingAttributions.size > 0 ? "loading" : "ready" : "disabled";
  }
  async _fetchAttributionData(e) {
    if (this._pendingAttributions.has(e))
      return;
    this._pendingAttributions.add(e);
    const t = await K_(e.layer.fetchAttributionData());
    if (this._pendingAttributions.has(e)) {
      const n = t.ok ? this._createContributionIndex(t.value, v0e(e.layer)) : null;
      this._pendingAttributions.delete(e), this._fetchedAttributionData.set(e, n);
    }
    this._updateAttributionItems();
  }
  _createContributionIndex(e, t) {
    const n = e.contributors, r = {};
    if (!n)
      return r;
    for (let i = 0; i < n.length; i++) {
      const s = n[i], o = s.coverageAreas;
      if (!o)
        return;
      for (const a of o) {
        const l = a.bbox, c = a.zoomMin - (t && a.zoomMin ? 1 : 0), p = a.zoomMax - (t && a.zoomMax ? 1 : 0), f = { xmin: l[1], ymin: l[0], xmax: l[3], ymax: l[2], spatialReference: Qe.WGS84 }, m = { extent: Zu(f), attribution: s.attribution || "", score: a.score != null ? a.score : 100, id: i };
        for (let y = c; y <= p; y++)
          r[y] = r[y] || [], r[y].push(m);
      }
    }
    return r.maxKey = Math.max.apply(null, Object.keys(r)), r;
  }
  _getDynamicAttribution(e, t, n) {
    const { extent: r, scale: i } = t;
    let s = n.tileInfo.scaleToZoom(i);
    if (s = Math.min(e.maxKey, Math.round(s)), !r || s == null || s <= -1)
      return "";
    const o = e[s], a = tS(r.center.clone().normalize(), t.spatialReference), l = {};
    return o ? o.filter((c) => {
      const p = !l[c.id] && a && nS(c.extent, a);
      return p && (l[c.id] = !0), p;
    }).sort((c, p) => p.score - c.score || c.objectId - p.objectId).map((c) => c.attribution).join(", ") : "";
  }
};
u([d({ readOnly: !0, type: Ne })], Ah.prototype, "items", void 0), u([d({ readOnly: !0 })], Ah.prototype, "state", null), u([d()], Ah.prototype, "view", void 0), Ah = u([T("geoscene.widgets.Attribution.AttributionViewModel")], Ah);
const xU = Ah, Xl = { base: "geoscene-attribution geoscene-widget", poweredBy: "geoscene-attribution__powered-by", sources: "geoscene-attribution__sources", open: "geoscene-attribution--open", sourcesOpen: "geoscene-attribution__sources--open", link: "geoscene-attribution__link", widgetIcon: "geoscene-icon-description", interactive: "geoscene-interactive" };
let Ur = class extends ti {
  constructor(t, n) {
    super(t, n), this._isOpen = !1, this._attributionTextOverflowed = !1, this._prevSourceNodeHeight = 0, this.iconClass = Xl.widgetIcon, this.itemDelimiter = " | ", this.label = void 0, this.messages = null, this.view = null, this.viewModel = new xU();
  }
  initialize() {
    this.own(gS(this, "viewModel.items", "change", () => this.scheduleRender()));
  }
  get _isInteractive() {
    return this._isOpen || this._attributionTextOverflowed;
  }
  get attributionText() {
    return this.viewModel.items.reduce((t, n) => (t.indexOf(n.text) === -1 && t.push(n.text), t), []).join(this.itemDelimiter);
  }
  render() {
    const t = { [Xl.open]: this._isOpen };
    return B("div", { bind: this, class: this.classes(Xl.base, t), onclick: this._toggleState, onkeydown: this._toggleState }, this.renderSourcesNode(), this.renderPoweredBy());
  }
  renderPoweredBy() {
    return B("div", { class: Xl.poweredBy }, "Powered by", " ", B("a", { class: Xl.link, href: "https://www.geoscene.cn/", target: "_blank", rel: "noreferrer" }, "GeoScene"));
  }
  renderSourcesNode() {
    const t = this._isOpen, n = this._isInteractive, r = n ? 0 : -1, { attributionText: i } = this, s = n ? "button" : void 0, o = { [Xl.sourcesOpen]: t, [Xl.interactive]: n };
    return B("div", { afterCreate: this._afterSourcesNodeCreate, afterUpdate: this._afterSourcesNodeUpdate, bind: this, class: this.classes(Xl.sources, o), innerHTML: i, role: s, tabIndex: r });
  }
  _afterSourcesNodeCreate(t) {
    this._prevSourceNodeHeight = t.clientWidth;
  }
  _afterSourcesNodeUpdate(t) {
    let n = !1;
    const { clientHeight: r, clientWidth: i, scrollWidth: s } = t, o = s >= i, a = this._attributionTextOverflowed !== o;
    if (this._attributionTextOverflowed = o, a && (n = !0), this._isOpen) {
      const l = r < this._prevSourceNodeHeight;
      this._prevSourceNodeHeight = r, l && (this._isOpen = !1, n = !0);
    }
    n && this.scheduleRender();
  }
  _toggleState() {
    this._isInteractive && (this._isOpen = !this._isOpen);
  }
};
u([d()], Ur.prototype, "_isOpen", void 0), u([d()], Ur.prototype, "_isInteractive", null), u([d()], Ur.prototype, "_attributionTextOverflowed", void 0), u([d()], Ur.prototype, "_prevSourceNodeHeight", void 0), u([d({ readOnly: !0, dependsOn: ["viewModel.items.length", "itemDelimiter"] })], Ur.prototype, "attributionText", null), u([d()], Ur.prototype, "iconClass", void 0), u([d()], Ur.prototype, "itemDelimiter", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], Ur.prototype, "label", void 0), u([d(), Si("geoscene/widgets/Attribution/t9n/Attribution")], Ur.prototype, "messages", void 0), u([Le("viewModel.view")], Ur.prototype, "view", void 0), u([d({ type: xU })], Ur.prototype, "viewModel", void 0), u([Cs()], Ur.prototype, "_toggleState", null), Ur = u([T("geoscene.widgets.Attribution")], Ur);
const b0e = Ur, w0e = "geoscene.widgets.CompassViewModel";
let hd = class extends OB(ke) {
  constructor(t) {
    super(t), this._handles = new ei(), this.orientation = { x: 0, y: 0, z: 0 }, this.view = null, this._updateForCamera = this._updateForCamera.bind(this), this._updateForRotation = this._updateForRotation.bind(this), this._updateRotationWatcher = this._updateRotationWatcher.bind(this);
  }
  initialize() {
    this._handles.add(gn(this, "view", this._updateRotationWatcher));
  }
  destroy() {
    this._handles.destroy(), this._handles = null, this.view = null;
  }
  get canShowNorth() {
    const t = this.get("view.spatialReference");
    return !(!t || !t.isWebMercator && !t.isGeographic);
  }
  get state() {
    return this.get("view.ready") ? this.canShowNorth ? "compass" : "rotation" : "disabled";
  }
  reset() {
    if (!this.get("view.ready"))
      return;
    const t = {};
    this.view.type === "2d" ? t.rotation = 0 : t.heading = 0, this.callGoTo({ target: t });
  }
  _updateForRotation(t) {
    t != null && (this.orientation = { z: t });
  }
  _updateForCamera(t) {
    if (!t)
      return;
    const n = -t.heading;
    this.orientation = { x: 0, y: 0, z: n };
  }
  _updateRotationWatcher(t) {
    this._handles.removeAll(), t && (t.type === "2d" ? this._handles.add(gn(this, "view.rotation", this._updateForRotation)) : this._handles.add(gn(this, "view.camera", this._updateForCamera)));
  }
};
u([d({ readOnly: !0 })], hd.prototype, "canShowNorth", null), u([d()], hd.prototype, "orientation", void 0), u([d({ readOnly: !0 })], hd.prototype, "state", null), u([d()], hd.prototype, "view", void 0), hd = u([T(w0e)], hd);
const $U = hd, eu = { base: "geoscene-compass geoscene-widget--button geoscene-widget", text: "geoscene-icon-font-fallback-text", icon: "geoscene-compass__icon", rotationIcon: "geoscene-icon-dial", northIcon: "geoscene-icon-compass", widgetIcon: "geoscene-icon-locate-circled", interactive: "geoscene-interactive", disabled: "geoscene-disabled" };
let aa = class extends ti {
  constructor(t, n) {
    super(t, n), this.goToOverride = null, this.iconClass = eu.widgetIcon, this.label = void 0, this.messages = null, this.view = null, this.viewModel = new $U();
  }
  reset() {
    return this.viewModel.reset();
  }
  render() {
    const { orientation: t, state: n } = this.viewModel, r = n === "disabled", i = (n === "rotation" ? "rotation" : "compass") == "compass", s = r ? -1 : 0, o = { [eu.disabled]: r, [eu.interactive]: !r }, a = { [eu.northIcon]: i, [eu.rotationIcon]: !i }, { messages: l } = this;
    return B("div", { bind: this, class: this.classes(eu.base, o), onclick: this._reset, onkeydown: this._reset, role: "button", tabIndex: s, "aria-label": l.reset, title: l.reset }, B("span", { "aria-hidden": "true", class: this.classes(eu.icon, a), styles: this._toRotationTransform(t) }), B("span", { class: eu.text }, l.reset));
  }
  _reset() {
    this.viewModel.reset();
  }
  _toRotationTransform(t) {
    return { transform: `rotateZ(${t.z}deg)` };
  }
};
u([Le("viewModel.goToOverride")], aa.prototype, "goToOverride", void 0), u([d()], aa.prototype, "iconClass", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], aa.prototype, "label", void 0), u([d(), Si("geoscene/widgets/Compass/t9n/Compass")], aa.prototype, "messages", void 0), u([Le("viewModel.view")], aa.prototype, "view", void 0), u([d({ type: $U })], aa.prototype, "viewModel", void 0), u([Cs()], aa.prototype, "_reset", null), aa = u([T("geoscene.widgets.Compass")], aa);
const _0e = aa;
let Ph = class extends ke {
  constructor(t) {
    super(t), this._handles = new ei(), this.navigationMode = "pan", this.view = null;
  }
  initialize() {
    this._handles.add(I9(this, "view.inputManager", this._setNavigationMode.bind(this)));
  }
  destroy() {
    this._handles.destroy(), this._handles = null, this.view = null;
  }
  get state() {
    return this.get("view.ready") && this.view.type === "3d" ? "ready" : "disabled";
  }
  toggle() {
    this.state !== "disabled" && (this.navigationMode = this.navigationMode !== "pan" ? "pan" : "rotate", this._setNavigationMode());
  }
  _setNavigationMode() {
    this.get("view.inputManager").primaryDragAction = this.navigationMode === "pan" ? "pan" : "rotate";
  }
};
u([d({ readOnly: !0 })], Ph.prototype, "state", null), u([d()], Ph.prototype, "navigationMode", void 0), u([d()], Ph.prototype, "view", void 0), Ph = u([T("geoscene.widgets.NavigationToggleViewModel")], Ph);
const TU = Ph, gs = { base: "geoscene-navigation-toggle geoscene-widget", button: "geoscene-navigation-toggle__button geoscene-widget--button", activeButton: "geoscene-navigation-toggle__button--active", panButton: "geoscene-navigation-toggle__button--pan", rotateButton: "geoscene-navigation-toggle__button--rotate", isLayoutHorizontal: "geoscene-navigation-toggle--horizontal", rotationIcon: "geoscene-icon-rotate", panIcon: "geoscene-icon-pan", widgetIcon: "geoscene-icon-pan2", disabled: "geoscene-disabled" };
let la = class extends ti {
  constructor(t, n) {
    super(t, n), this.iconClass = gs.widgetIcon, this.label = void 0, this.messages = null, this.view = null, this.viewModel = new TU();
  }
  set layout(t) {
    t !== "horizontal" && (t = "vertical"), this._set("layout", t);
  }
  toggle() {
    return this.viewModel.toggle();
  }
  render() {
    const t = this.get("viewModel.state") === "disabled", n = this.get("viewModel.navigationMode") === "pan", r = { [gs.disabled]: t, [gs.isLayoutHorizontal]: this.layout === "horizontal" }, i = { [gs.activeButton]: n }, s = { [gs.activeButton]: !n }, o = t ? -1 : 0, a = this.messages.toggle;
    return B("div", { bind: this, class: this.classes(gs.base, r), onclick: this._toggle, onkeydown: this._toggle, tabIndex: o, "aria-label": a, title: a }, B("div", { class: this.classes(gs.button, gs.panButton, i) }, B("span", { class: gs.panIcon })), B("div", { class: this.classes(gs.button, gs.rotateButton, s) }, B("span", { class: gs.rotationIcon })));
  }
  _toggle() {
    this.toggle();
  }
};
u([d()], la.prototype, "iconClass", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], la.prototype, "label", void 0), u([d({ value: "vertical" })], la.prototype, "layout", null), u([d(), Si("geoscene/widgets/NavigationToggle/t9n/NavigationToggle")], la.prototype, "messages", void 0), u([Le("viewModel.view")], la.prototype, "view", void 0), u([d({ type: TU })], la.prototype, "viewModel", void 0), u([Cs()], la.prototype, "_toggle", null), la = u([T("geoscene.widgets.NavigationToggle")], la);
const S0e = la, jm = { button: "geoscene-widget--button geoscene-widget", disabled: "geoscene-disabled", interactive: "geoscene-interactive", iconText: "geoscene-icon-font-fallback-text", icon: "geoscene-icon" };
let Iu = class extends ti {
  constructor() {
    super(...arguments), this.enabled = !0, this.iconClass = "", this.title = "";
  }
  render() {
    const t = this.enabled ? 0 : -1, n = { [jm.disabled]: !this.enabled, [jm.interactive]: this.enabled }, r = { [this.iconClass]: !!this.iconClass };
    return B("div", { bind: this, class: this.classes(jm.button, n), onclick: this._triggerAction, onkeydown: this._triggerAction, role: "button", tabIndex: t, title: this.title }, B("span", { "aria-hidden": "true", role: "presentation", class: this.classes(jm.icon, r) }), B("span", { class: jm.iconText }, this.title));
  }
  _triggerAction() {
    this.action.call(this);
  }
};
u([d()], Iu.prototype, "action", void 0), u([d()], Iu.prototype, "enabled", void 0), u([d()], Iu.prototype, "iconClass", void 0), u([d()], Iu.prototype, "title", void 0), u([Cs()], Iu.prototype, "_triggerAction", null), Iu = u([T("geoscene.widgets.IconButton")], Iu);
const NN = Iu;
let Rh = class extends ke {
  get canZoomIn() {
    if (!this.get("view.ready"))
      return !1;
    const t = this.get("view.animation.target.scale") || this.get("view.scale"), n = this.get("view.constraints.effectiveMaxScale");
    return n === 0 || t > n;
  }
  get canZoomOut() {
    if (!this.get("view.ready"))
      return !1;
    const t = this.get("view.animation.target.scale") || this.get("view.scale"), n = this.get("view.constraints.effectiveMinScale");
    return n === 0 || t < n;
  }
};
u([d({ readOnly: !0 })], Rh.prototype, "canZoomIn", null), u([d({ readOnly: !0 })], Rh.prototype, "canZoomOut", null), u([d()], Rh.prototype, "view", void 0), Rh = u([T("geoscene.widgets.Zoom.ZoomConditions2D")], Rh);
const x0e = Rh;
let Lh = class extends ke {
  get canZoomIn() {
    return !!this.get("view.ready");
  }
  get canZoomOut() {
    return !!this.get("view.ready");
  }
};
u([d({ readOnly: !0 })], Lh.prototype, "canZoomIn", null), u([d({ readOnly: !0 })], Lh.prototype, "canZoomOut", null), u([d()], Lh.prototype, "view", void 0), Lh = u([T("geoscene.widgets.Zoom.ZoomConditions3D")], Lh);
const $0e = Lh;
let Mu = class extends ke {
  constructor(t) {
    super(t), this.canZoomIn = !1, this.canZoomOut = !1;
  }
  destroy() {
    this.view = null;
  }
  get state() {
    return this.get("view.ready") ? "ready" : "disabled";
  }
  set view(t) {
    t ? t.type === "2d" ? this._zoomConditions = new x0e({ view: t }) : t.type === "3d" && (this._zoomConditions = new $0e({ view: t })) : this._zoomConditions = null, this._set("view", t);
  }
  zoomIn() {
    if (!this.canZoomIn)
      return;
    const t = this.view;
    t.type === "2d" ? t.mapViewNavigation.zoomIn() : k$(t.goTo({ zoomFactor: 2 }));
  }
  zoomOut() {
    if (!this.canZoomOut)
      return;
    const t = this.view;
    t.type === "2d" ? t.mapViewNavigation.zoomOut() : k$(t.goTo({ zoomFactor: 0.5 }));
  }
};
u([d()], Mu.prototype, "_zoomConditions", void 0), u([d({ aliasOf: "_zoomConditions.canZoomIn", readOnly: !0 })], Mu.prototype, "canZoomIn", void 0), u([d({ aliasOf: "_zoomConditions.canZoomOut", readOnly: !0 })], Mu.prototype, "canZoomOut", void 0), u([d({ readOnly: !0 })], Mu.prototype, "state", null), u([d()], Mu.prototype, "view", null), Mu = u([T("geoscene.widgets.Zoom.ZoomViewModel")], Mu);
const EU = Mu, Vm = { base: "geoscene-zoom geoscene-widget", horizontalLayout: "geoscene-zoom--horizontal", zoomInIcon: "geoscene-icon-plus", zoomOutIcon: "geoscene-icon-minus", widgetIcon: "geoscene-icon-zoom-in-magnifying-glass" };
let cl = class extends ti {
  constructor(t, n) {
    super(t, n), this.iconClass = Vm.widgetIcon, this.label = void 0, this.messages = null, this.view = null, this.viewModel = new EU();
  }
  initialize() {
    this._zoomInButton = new NN({ action: this.zoomIn.bind(this), iconClass: Vm.zoomInIcon }), this._zoomOutButton = new NN({ action: this.zoomOut.bind(this), iconClass: Vm.zoomOutIcon });
  }
  destroy() {
    this._zoomInButton.destroy(), this._zoomOutButton.destroy(), this._zoomInButton = null, this._zoomOutButton = null;
  }
  set layout(t) {
    t !== "horizontal" && (t = "vertical"), this._set("layout", t);
  }
  render() {
    const t = this.viewModel, n = { [Vm.horizontalLayout]: this.layout === "horizontal" };
    return this._zoomInButton.enabled = t.state === "ready" && t.canZoomIn, this._zoomOutButton.enabled = t.state === "ready" && t.canZoomOut, this._zoomInButton.title = this.messages.zoomIn, this._zoomOutButton.title = this.messages.zoomOut, B("div", { class: this.classes(Vm.base, n) }, this._zoomInButton.render(), this._zoomOutButton.render());
  }
  zoomIn() {
    return this.viewModel.zoomIn();
  }
  zoomOut() {
    return this.viewModel.zoomOut();
  }
};
u([d()], cl.prototype, "iconClass", void 0), u([d({ aliasOf: { source: "messages.widgetLabel", overridable: !0 } })], cl.prototype, "label", void 0), u([d({ value: "vertical" })], cl.prototype, "layout", null), u([d(), Si("geoscene/widgets/Zoom/t9n/Zoom")], cl.prototype, "messages", void 0), u([Le("viewModel.view")], cl.prototype, "view", void 0), u([d({ type: EU })], cl.prototype, "viewModel", void 0), cl = u([T("geoscene.widgets.Zoom")], cl);
const T0e = cl, IU = "geoscene.views.ui.DefaultUI";
function E0e(e) {
  return e && e.view !== void 0;
}
we.getLogger(IU);
let Rw = class extends y0e {
  constructor(e) {
    super(e), this._defaultPositionLookup = { attribution: "manual", compass: "top-leading", "navigation-toggle": "top-leading", zoom: "top-leading" }, this.components = [];
  }
  initialize() {
    this._handles.add([Nt(() => this.components, this._componentsWatcher.bind(this), va), Nt(() => this.view, this._updateViewAwareWidgets.bind(this), va)]);
  }
  _add(e, t, n, r) {
    if (typeof e == "string" && this._defaultPositionLookup[e]) {
      if (this._find(e))
        return;
      e = this._createComponent(e);
    }
    super._add(e, t, n, r);
  }
  _removeComponents(e) {
    e.forEach((t) => {
      const n = this._find(t);
      n && (this.remove(n), n.destroy());
    });
  }
  _updateViewAwareWidgets(e) {
    this.components.forEach((t) => {
      const n = this._find(t), r = n && n.widget;
      E0e(r) && (r.view = e);
    });
  }
  _componentsWatcher(e, t) {
    this._removeComponents(t), this._addComponents(e), this._adjustPadding(e);
  }
  _adjustPadding(e) {
    if (e.indexOf("attribution") === -1 && !this._isOverridden("padding")) {
      const { top: t } = this.padding;
      this.padding = t;
    }
  }
  _addComponents(e) {
    this.initialized && e.forEach((t) => this.add(this._createComponent(t), this._defaultPositionLookup[t]));
  }
  _createComponent(e) {
    const t = this._createWidget(e);
    if (t)
      return new Pw({ id: e, node: t });
  }
  _createWidget(e) {
    return e === "attribution" ? this._createAttribution() : e === "compass" ? this._createCompass() : e === "navigation-toggle" ? this._createNavigationToggle() : e === "zoom" ? this._createZoom() : void 0;
  }
  _createAttribution() {
    return new b0e({ view: this.view });
  }
  _createCompass() {
    return new _0e({ view: this.view });
  }
  _createNavigationToggle() {
    return new S0e({ view: this.view });
  }
  _createZoom() {
    return new T0e({ view: this.view });
  }
};
u([d()], Rw.prototype, "components", void 0), Rw = u([T(IU)], Rw);
const I0e = Rw;
let Lw = class extends I0e {
  constructor(e) {
    super(e), this.components = ["attribution", "zoom"];
  }
};
u([d()], Lw.prototype, "components", void 0), Lw = u([T("geoscene.views.ui.2d.DefaultUI2D")], Lw);
const MU = Lw;
var zM;
let Fw = zM = class extends se {
  constructor(e) {
    super(e), this.color = new Fe([0, 0, 0, 1]);
  }
  clone() {
    return new zM(q({ color: this.color }));
  }
};
u([d({ type: Fe, json: { write: !0 } })], Fw.prototype, "color", void 0), Fw = zM = u([T("geoscene.webmap.background.ColorBackground")], Fw);
const M0e = Fw, Ba = we.getLogger("geoscene.views.MapView");
let CU, OU, kU, AU, PU, RU;
async function C0e() {
  const [, { GraphicsView2D: e, GraphicContainer: t, LabelManager: n, MapViewNavigation: r, MagnifierView2D: i, Stage: s }] = await Promise.all([import("./webglDeps-w3kmhubo.js"), import("./mapViewDeps-9h4i8lEV.js")]);
  OU = e, kU = t, AU = n, PU = r, RU = i, CU = s;
}
const DN = 160;
function O0e(e) {
  return e && e.declaredClass === "geoscene.Viewpoint";
}
let We = class extends wne(Eme(Ime(eye))) {
  constructor(e) {
    super(e), this._magnifierView = null, this._stage = null, this._resolveWhenReady = [], this.rootLayerViews = new tf({ getCollections: () => {
      var t, n;
      return [(t = this.basemapView) == null ? void 0 : t.baseLayerViews, this.layerViews, (n = this.basemapView) == null ? void 0 : n.referenceLayerViews];
    }, getChildrenFunction: () => null }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.graphicsView = null, this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = { samplingMode: "dynamic", edgeLabelsVisible: !0, labelsAnimationTime: 125, labelCollisionsEnabled: !0 }, this.rendering = !1, this.supersampleScreenshotsEnabled = !1, this.supportsGround = !1, this._stationaryTimer = null, this.frameTask = new kye(this), this._pePromise = null, this.floors = new Ne(), this.highlightOptions = new yU(), this.inputManager = new Lge({ view: this }), this.map = null, this.resizeAlign = "center", this.spatialReferenceLocked = !1, this.timeline = new gU(), this.type = "2d", this.ui = new MU(), this.constraints = new aU(), this.padding = { top: 0, right: 0, bottom: 0, left: 0 }, this.handles.add([Nt(() => this.viewpoint, () => {
      this._lastStationaryEventTimestamp = performance.now(), this._flipStationary(DN);
    }, sT), this.on("resize", (t) => this._resizeHandler(t)), Nt(() => {
      var t;
      return (t = this.animationManager) == null ? void 0 : t.animation;
    }, (t) => {
      this.animation = t;
    })]), wte();
  }
  destroy() {
    this._set("preconditionsReady", !1), this._gotoTask = this.frameTask = null, this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new zge(this.featuresTilingScheme);
  }
  get initialExtentRequired() {
    var e;
    const { scale: t, constraints: n, center: r, viewpoint: i, extent: s } = this;
    let o = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && (e = this.map.initialViewProperties) != null && e.viewpoint) && !s && (n != null && n.effectiveLODs || (o = -1), (!r || t === 0 && o === -1) && (!i || !O(i.targetGeometry) || i.targetGeometry.type !== "extent" && !i.scale));
  }
  get resourceManager() {
    return this._stage.resourceManager;
  }
  get textureManager() {
    return this._stage.painter.textureManager;
  }
  get _defaultsFromMapSettings() {
    return { required: { tileInfo: !0, heightModelInfo: !1, extent: !1 }, requiresExtentInSpatialReference: this.spatialReferenceLocked };
  }
  get _projectionEngineLoaded() {
    return !!wf() || (this._pePromise || (this._pePromise = _f().finally(() => {
      this._pePromise = null;
    })), !1);
  }
  get typeSpecificPreconditionsReady() {
    const e = this._getDefaultViewpoint();
    if (!e)
      return !1;
    const t = this.spatialReference, n = e.targetGeometry;
    return !!cp(n.spatialReference, t) || this._projectionEngineLoaded;
  }
  set animation(e) {
    const t = this._get("animation");
    if (e === t)
      return;
    if (t && t.stop(), !e || e.isFulfilled())
      return void this._set("animation", null);
    this._set("animation", e), this.frameTask.animationInProgress = !0;
    const n = () => {
      e === this._get("animation") && (this._set("animation", null), this.frameTask.requestFrame()), this.frameTask.animationInProgress = !1;
    };
    e.when(n, n);
  }
  get background() {
    return this.get("map.initialViewProperties.background") || null;
  }
  set background(e) {
    e === void 0 ? this._clearOverride("background") : this._override("background", e);
  }
  get center() {
    if (!this.ready)
      return this._get("center");
    const { center: e, spatialReference: t } = this.state.paddedViewState;
    return new Oe({ x: e[0], y: e[1], spatialReference: t });
  }
  set center(e) {
    if (e == null)
      return;
    if (!this.ready)
      return this._set("center", e), void this.notifyChange("initialExtentRequired");
    let t;
    try {
      t = this._project(e, this.spatialReference);
    } catch (r) {
      return void Ba.error(new D("mapview:invalid-center", "could not project the value in the view's spatial reference", { input: e, error: r }));
    }
    const n = this.viewpoint;
    RM(n, n, t), this.viewpoint = n;
  }
  set constraints(e) {
    const t = this._get("constraints");
    t && (this.handles.remove("map-view-constraints"), t.destroy()), this._set("constraints", e), e && (e.view = this, this.ready && (this.state.viewpoint = e.fit(this.state.paddedViewState.viewpoint)), this.handles.add(Nt(() => e.version, () => {
      this.ready && this.state && (this.state.viewpoint = e.fit(this.state.paddedViewState.viewpoint));
    }, sT), "map-view-constraints"));
  }
  get extent() {
    return this.ready ? this.state.paddedViewState.extent.clone() : this._get("extent");
  }
  set extent(e) {
    if (e == null)
      return;
    if (!e.width || !e.height)
      return void Ba.error(new D("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready)
      return this._set("extent", e), this._set("center", null), this._set("viewpoint", null), this._set("scale", 0), this._set("zoom", -1), void this.notifyChange("initialExtentRequired");
    let t;
    try {
      t = this._project(e, this.spatialReference);
    } catch (r) {
      return void Ba.error(new D("mapview:invalid-extent", "could not project the value in the view's spatial reference", { error: r }));
    }
    const n = this.viewpoint;
    mye(n, n, t, this.size, { constraints: this.constraints }), this.viewpoint = n;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(e) {
    this.ready ? (this.state.padding = e, this._set("padding", this.state.padding)) : this._set("padding", e);
  }
  get resolution() {
    return this.state ? this.state.resolution : 0;
  }
  get rotation() {
    return this.ready ? this.state.rotation : this._get("rotation");
  }
  set rotation(e) {
    if (isNaN(e))
      return;
    if (!this.ready)
      return void this._set("rotation", e);
    const t = this.viewpoint;
    Iye(t, t, e), this.viewpoint = t;
  }
  get scale() {
    return this.ready ? this.state.scale : this._get("scale");
  }
  set scale(e) {
    if (!e || isNaN(e))
      return;
    if (!this.ready) {
      this._set("scale", e), this._set("zoom", -1);
      const n = this._get("extent");
      return n && (this._set("extent", null), this._set("center", n.center)), void this.notifyChange("initialExtentRequired");
    }
    const t = this.viewpoint;
    pN(t, t, e), this.viewpoint = t;
  }
  get stationary() {
    return !(this.animation || this.navigating || this.resizing || this._stationaryTimer);
  }
  get updating() {
    return !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || this.layerViewManager.updating === !0 || this.labelManager.updating === !0 || this.graphicsView.updating === !0 || this.allLayerViews.some((e) => !e.destroyed && !("layerViews" in e) && e.updating === !0));
  }
  get viewpoint() {
    if (!this.ready)
      return this._get("viewpoint");
    const e = this.state.paddedViewState;
    return e && e.viewpoint.clone();
  }
  set viewpoint(e) {
    if (e == null)
      return;
    if (!this.ready)
      return this._set("viewpoint", e), this._set("extent", null), this._set("center", null), this._set("zoom", -1), this._set("scale", 0), void this.notifyChange("initialExtentRequired");
    let t, n;
    try {
      t = this._project(e, this.spatialReference), !e.scale || isNaN(e.scale) ? n = new D("mapview:invalid-viewpoint", `invalid scale value of ${e.scale}`) : H(e.targetGeometry) && (n = new D("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (i) {
      n = new D("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", { error: i });
    }
    if (n)
      return void Ba.error(n);
    this._scaleBeforeChangingSpatialReference = null;
    const r = new ba({ targetGeometry: new Oe(), scale: 0, rotation: 0 });
    jo(r, t), this.constraints.constrain(r, this.state.paddedViewState.viewpoint), this.state.viewpoint = r, this.frameTask.requestFrame(), this._set("viewpoint", r);
  }
  get zoom() {
    return this.ready ? this.constraints.scaleToZoom(this.scale) : this._get("zoom");
  }
  set zoom(e) {
    if (e == null)
      return;
    if (!this.ready) {
      this._set("zoom", e), this._set("scale", 0);
      const n = this._get("extent");
      return n && (this._set("extent", null), this._set("center", n.center)), void this.notifyChange("initialExtentRequired");
    }
    if (!this.constraints.effectiveLODs)
      return void this._set("zoom", -1);
    const t = this.viewpoint;
    pN(t, t, this.constraints.zoomToScale(e)), this.viewpoint = t, this._set("zoom", this.constraints.scaleToZoom(this.scale));
  }
  get navigating() {
    return !(!this.mapViewNavigation || !this.mapViewNavigation.interacting);
  }
  goTo(e, t) {
    if (e)
      return this.animation && (this.animation = null), this._createAnimation(), mO(() => this.ready, t).then(() => {
        const n = { animate: !0, ...t }, r = pye(e, this);
        return this.animation.update(r), this._gotoTask = {}, n.animate ? this._gotoAnimated(r, n) : this._gotoImmediate(r, n);
      });
    Ba.error("#goTo()", "target cannot be null or undefined");
  }
  async hitTest(e, t) {
    const n = nN(e) ? tN(this, e) : e;
    if (!this.ready || isNaN(n.x) || isNaN(n.y))
      return { screenPoint: n, results: [] };
    let r = /* @__PURE__ */ new Set(), i = !1, s = null, o = null;
    t != null && t.include ? VN(t.include, jN(this, (p) => r.add(p), (p) => {
      s || (s = /* @__PURE__ */ new Set()), s.add(p);
    }, (p) => r.add(p), () => i = !0)) : (i = !0, r = new Set(this.allLayerViews)), t != null && t.exclude && VN(t.exclude, jN(this, (p) => r.delete(p), (p) => {
      o || (o = /* @__PURE__ */ new Set()), o.add(p);
    }));
    const a = this.allLayerViews.filter((p) => !p.suspended && r.has(p)).reverse(), l = this.toMap(n);
    let c = (await Promise.all([i ? this.graphicsView.hitTest(l) : null, ...a.map((p) => p.hitTest(l, n))])).filter(O).flat();
    return s && (c = c.filter((p) => s.has(BM(p)))), o && (c = c.filter((p) => !o.has(BM(p)))), { screenPoint: n, results: c.map((p) => ({ mapPoint: l, graphic: p })) };
  }
  takeScreenshot(e) {
    e = e || {};
    const t = this.supersampleScreenshotsEnabled ? Math.min(4, Hge(this.size, Math.min(4096, this._stage.context.parameters.maxTextureSize))) : 1;
    let n;
    e.layers ? (n = [], e.layers.forEach((o) => {
      const a = this.allLayerViews.find((l) => l.layer.id === o.id);
      a && "container" in a && a.container && n.push(a.container);
    })) : n = this._stage.children;
    const { format: r, quality: i } = Wge(e.format, e.quality), s = qge(e, t, this.size, this.padding, r, i, n, e.rotation);
    return this._stage.takeScreenshot(s);
  }
  toMap(e) {
    if (!this.ready)
      return null;
    const t = nN(e) ? tN(this, e) : e, n = [0, 0], [r, i] = this.state.toMap(n, [t.x, t.y]), s = this.spatialReference;
    return new Oe({ x: r, y: i, spatialReference: s });
  }
  toScreen(e) {
    if (!this.ready)
      return null;
    const t = this._project(e, this.spatialReference), n = [t.x, t.y];
    return this.state.toScreen(n, n), wi(n[0], n[1]);
  }
  on(e, t, n, r) {
    return this.inputManager && this.viewEvents.on(e, t, n, r) || super.on(e, t);
  }
  hasEventListener(e) {
    return super.hasEventListener(e) || this.viewEvents.hasHandler(e);
  }
  whenLayerView(e) {
    return super.whenLayerView(e);
  }
  graphicChanged(e) {
    this.graphicsView && this.graphicsView.graphicUpdateHandler(e);
  }
  whenReady() {
    return new Promise((e) => {
      this.ready ? e(this) : this._resolveWhenReady.push(e);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    var e, t, n;
    return this.map && "initialViewProperties" in this.map && ((e = this.map) == null || (t = e.initialViewProperties) == null ? void 0 : t.spatialReference) || ((n = this.defaultsFromMap) == null ? void 0 : n.spatialReference) || null;
  }
  hasLayerViewModule(e) {
    return fN.hasLayerViewModule(e);
  }
  importLayerView(e) {
    return fN.importLayerView(e);
  }
  pixelSizeAt() {
    return this.ready ? this.state.resolution : (Ba.error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e) {
    return this.hitTest(e).then((t) => ({ ...t, mapPoint: this.toMap(e) }));
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    let e = c0e(this.type);
    return K("safari") && K("safari") < 9 && (e = new D("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", { type: "safari", requiredVersion: 9, detectedVersion: K("safari") })), O(e) ? (Ba.warn("#validate()", e.message), Promise.reject(e)) : C0e();
  }
  _createAnimation() {
    return this.animation && !this.animation.done || (this.animation = new PM()), this.animation;
  }
  _cancellableGoTo(e, t, n) {
    const r = () => e === this._gotoTask, i = n.then(() => {
      r() && (this.animation = null);
    }).catch((o) => {
      throw r() && (this.animation = null, t.done || (t.stop(), this.frameTask.animationInProgress = !1)), o;
    }), s = new Promise((o) => o(i));
    return t.when().catch(() => {
      r() && s.cancel && s.cancel();
    }), s;
  }
  _gotoImmediate(e, t) {
    const n = this._gotoTask, r = this.animation, i = e.then((s) => {
      if (On(t), n !== this._gotoTask)
        throw new D("view:goto-interrupted", "Goto was interrupted");
      this.viewpoint = r.target = s, r.finish();
    });
    return this._cancellableGoTo(n, r, i);
  }
  _flipStationary(e) {
    return this._stationaryTimer !== null || (this._stationaryTimer = setTimeout(() => {
      this._stationaryTimer = null;
      const t = performance.now() - this._lastStationaryEventTimestamp;
      t < DN && (this._stationaryTimer = this._flipStationary(t));
    }, e)), this._stationaryTimer;
  }
  _getDefaultViewpoint() {
    var e, t, n, r;
    const { constraints: i, initialExtent: s, map: o } = this;
    if (!i)
      return null;
    const a = o && "initialViewProperties" in o && o.initialViewProperties, l = { zoom: this._get("zoom"), scale: this._get("scale"), center: this._get("center"), extent: this._get("extent"), rotation: this._get("rotation"), viewpoint: this._get("viewpoint"), spatialReference: this._userSpatialReference };
    i.effectiveLODs ? l.zoom !== -1 && (l.scale = i.zoomToScale(l.zoom)) : l.zoom = -1;
    let c = null, p = null, f = 0;
    const m = l.viewpoint && l.viewpoint.rotation, y = l.viewpoint && l.viewpoint.targetGeometry;
    O(y) && (y.type === "extent" ? c = y : y.type === "point" && (p = y, f = l.viewpoint.scale));
    const g = l.extent || c || ((e = a == null || (t = a.viewpoint) == null ? void 0 : t.targetGeometry) == null ? void 0 : e.extent) || s, v = l.center || p || (g == null ? void 0 : g.center), w = l.scale || f || (a == null || (n = a.viewpoint) == null ? void 0 : n.scale) || g && fg(g, this.size), b = l.rotation || m || (a == null || (r = a.viewpoint) == null ? void 0 : r.rotation) || 0;
    return v && w ? new ba({ targetGeometry: v, scale: w, rotation: b }) : null;
  }
  _gotoAnimated(e, t) {
    const n = this._gotoTask, r = this.animation, i = e.then((s) => {
      if (On(t), n !== this._gotoTask)
        throw new D("view:goto-interrupted", "Goto was interrupted");
      return r.update(s), this.animationManager.animate(r, this.viewpoint, t), r.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(n, r, i);
  }
  _project(e, t) {
    var n;
    const r = e && e.targetGeometry || e;
    if (!t)
      return e;
    if (!r)
      return null;
    if (t.imageCoordinateSystem || (n = r.spatialReference) != null && n.imageCoordinateSystem || Oi(t, r.spatialReference))
      return e;
    const i = I0(r, t);
    if (!i)
      throw new D("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", { geometry: r, spatialReference: t });
    return O0e(e) ? (e.targetGeometry = i, e) : i;
  }
  _resizeHandler(e) {
    if (!this.ready)
      return;
    const t = this.state;
    let n = this.state.paddedViewState.viewpoint;
    const r = this.state.paddedViewState.size.concat();
    t.size = [e.width, e.height], Eye(n, n, r, this.state.paddedViewState.size, this.resizeAlign), n = this.constraints.constrain(n, null), this.state.viewpoint = n;
  }
  _startup() {
    var e;
    this.timeline.begin("MapView Startup");
    const t = this._getDefaultViewpoint(), n = t.targetGeometry;
    try {
      this._project(t, this.spatialReference);
    } catch (c) {
      var r;
      Ba.warn(new Ds("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", { center: n.toJSON(), spatialReference: this.spatialReference, error: c })), t.targetGeometry = ((r = this.defaultsFromMap.extent) == null ? void 0 : r.center) || new Oe({ x: 0, y: 0, spatialReference: this.spatialReference });
    }
    (e = this.constraints) == null || e.fit(t), this._set("state", new Hye({ padding: this._get("padding"), size: this.size, viewpoint: t })), this.graphics.owner = this;
    const i = new CU(this.surface, { canvas: this.renderCanvas, supersampleScreenshots: this.supersampleScreenshotsEnabled, contextOptions: { disabledExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions }, renderingOptions: this.renderingOptions, timeline: this.timeline });
    this._stage = i, this._magnifierView = new RU(), this._magnifierView.magnifier = this.magnifier;
    const s = new AU({ view: this });
    this._set("labelManager", s);
    const o = new Oye({ view: this });
    this._set("animationManager", o);
    const a = new PU({ view: this, animationManager: o });
    this._set("mapViewNavigation", a), this._setupSpatialReferenceDependentProperties(), this.handles.add([this.rootLayerViews.on("change", () => this._updateStageChildren()), i.on("post-render", () => this._set("rendering", i.renderRequested)), i.on("will-render", () => this._set("rendering", i.renderRequested)), i.on("webgl-error", (c) => this.fatalError = c.error), Nt(() => this.stationary, (c) => i.stationary = c, Rc), Nt(() => this.background, (c) => {
      i.background = c, this._magnifierView.background = c;
    }, Rc), Nt(() => this.magnifier, (c) => this._magnifierView.magnifier = c, Rc), Nt(() => this.renderingOptions, (c) => i.renderingOptions = c, Rc), Nt(() => this.highlightOptions, (c) => i.highlightOptions = c, Rc), Nt(() => this.state.id, () => i.state = this.state, Rc)], "map-view"), this._updateStageChildren();
    const l = this._resolveWhenReady;
    this._resolveWhenReady = [], l.forEach((c) => c(this)), this.timeline.end("MapView Startup"), this.frameTask && this.frameTask.start(), this._set("ready", !0);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.handles.remove("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this._stage.destroy(), this._stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask && this.frameTask.stop(), this._stationaryTimer && (clearTimeout(this._stationaryTimer), this._stationaryTimer = null), this._set("ready", !1);
    const { center: [e, t], spatialReference: n, rotation: r, scale: i } = this.state.paddedViewState, s = new Oe({ x: e, y: t, spatialReference: n });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", s), this._set("zoom", -1), this._set("rotation", r), this._set("scale", i), this._set("spatialReference", n), this._set("state", null), this.animation = null;
  }
  _updateStageChildren() {
    this._stage.removeAllChildren(), this.rootLayerViews.forEach((t) => {
      this._stage.addChild(t.container);
    });
    const e = this.graphicsView;
    this._stage.addChild(e.container), this._stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e = new ege(vne.create({ spatialReference: this.spatialReference, size: 512, numLODs: 36 }));
    this._set("featuresTilingScheme", e);
    const t = new OU({ view: this, graphics: this.graphics, requestUpdateCallback: () => this.requestUpdate(), container: new kU(e) });
    this.frameTask.graphicsView = t, this._set("graphicsView", t);
  }
  _destroySpatialReferenceDependentProperties() {
    const e = this.graphicsView;
    this._set("graphicsView", null), this.frameTask.graphicsView = null, e.destroy(), this._set("featuresTilingScheme", null);
  }
  _spatialReferenceChanged(e) {
    if (!this.ready)
      return;
    this.frameTask.stop();
    for (const a of this.allLayerViews)
      a.processDetach();
    this._destroySpatialReferenceDependentProperties();
    const t = this.state.paddedViewState.clone();
    if (H(this._scaleBeforeChangingSpatialReference))
      this._scaleBeforeChangingSpatialReference = t.scale;
    else {
      const a = t.viewpoint.clone();
      a.scale = this._scaleBeforeChangingSpatialReference, t.viewpoint = a;
    }
    const n = t.clone(), [r, i] = t.center;
    let s = null;
    try {
      s = this._project(new Oe({ x: r, y: i, spatialReference: t.spatialReference }), e);
    } catch (a) {
      wf() || Ba.warn(new Ds("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", { center: s.toJSON(), spatialReference: e, error: a }));
    }
    s || (s = new Oe({ x: 0, y: 0, spatialReference: e }));
    const o = RM(new ba({ targetGeometry: new Oe(), scale: 0, rotation: 0 }), t.viewpoint, s);
    n.viewpoint = o;
    try {
      const l = [t.size[0] / 2, t.size[1] / 2], c = [l[0] + 20, l[1]], p = t.toMap([0, 0], c), { x: f, y: m } = this._project(new Oe({ x: p[0], y: p[1], spatialReference: t.spatialReference }), e);
      p[0] = f, p[1] = m, n.toScreen(p, p);
      const y = $ye(l, p, c), g = Math.hypot(p[0] - l[0], p[1] - l[1]) / 20;
      !Number.isFinite(g) || Math.abs(g) > 4 ? (o.rotation = 0, o.targetGeometry = new Oe({ x: 0, y: 0, spatialReference: e })) : (o.scale *= g, o.scale > K("mapview-srswitch-adjust-rotation-scale-threshold") ? o.rotation = 0 : o.rotation += Number.isFinite(y) ? y : 0);
    } catch {
    }
    this._get("constraints").constrain(o, null), this._get("state").viewpoint = o, this._stage.state = this.state, this._setupSpatialReferenceDependentProperties();
    for (const a of this.allLayerViews)
      a.processAttach();
    this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
  }
};
u([d({ readOnly: !0 })], We.prototype, "animationManager", void 0), u([d({ constructOnly: !0 })], We.prototype, "deactivatedWebGLExtensions", void 0), u([d({ constructOnly: !0 })], We.prototype, "debugWebGLExtensions", void 0), u([d({ readOnly: !0 })], We.prototype, "featuresTilingScheme", void 0), u([d({ readOnly: !0 })], We.prototype, "fullOpacity", void 0), u([d({ readOnly: !0 })], We.prototype, "graphicsTileStore", null), u([d()], We.prototype, "graphicsView", void 0), u([d({ readOnly: !0 })], We.prototype, "state", void 0), u([d()], We.prototype, "initialExtentRequired", null), u([d()], We.prototype, "labelManager", void 0), u([d({ readOnly: !0 })], We.prototype, "resourceManager", null), u([d({ readOnly: !0 })], We.prototype, "textureManager", null), u([d({ readOnly: !0 })], We.prototype, "mapViewNavigation", void 0), u([d({ constructOnly: !0 })], We.prototype, "renderCanvas", void 0), u([d()], We.prototype, "renderingOptions", void 0), u([d({ readOnly: !0 })], We.prototype, "rendering", void 0), u([d({ constructOnly: !0 })], We.prototype, "supersampleScreenshotsEnabled", void 0), u([d({ readOnly: !0 })], We.prototype, "supportsGround", void 0), u([d()], We.prototype, "_stationaryTimer", void 0), u([d()], We.prototype, "_defaultsFromMapSettings", null), u([d()], We.prototype, "_pePromise", void 0), u([d({ readOnly: !0 })], We.prototype, "typeSpecificPreconditionsReady", null), u([d()], We.prototype, "animation", null), u([d({ type: M0e })], We.prototype, "background", null), u([d({ value: null, type: Oe, dependsOn: ["state.id", "ready"] })], We.prototype, "center", null), u([d({ type: aU })], We.prototype, "constraints", null), u([d({ value: null, type: Mt, dependsOn: ["state.id", "ready"] })], We.prototype, "extent", null), u([d()], We.prototype, "floors", void 0), u([d({ type: yU })], We.prototype, "highlightOptions", void 0), u([d({ readOnly: !0 })], We.prototype, "inputManager", void 0), u([d()], We.prototype, "map", void 0), u([d({ value: { top: 0, right: 0, bottom: 0, left: 0 }, cast: (e) => ({ top: 0, right: 0, bottom: 0, left: 0, ...e }) })], We.prototype, "padding", null), u([d()], We.prototype, "resizeAlign", void 0), u([d({ readOnly: !0, dependsOn: ["state.id"] })], We.prototype, "resolution", null), u([d({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], We.prototype, "rotation", null), u([d({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], We.prototype, "scale", null), u([d({ constructOnly: !0 })], We.prototype, "spatialReferenceLocked", void 0), u([d()], We.prototype, "stationary", null), u([d({ type: gU, readOnly: !0 })], We.prototype, "timeline", void 0), u([d({ readOnly: !0 })], We.prototype, "type", void 0), u([d({ readOnly: !0 })], We.prototype, "updating", null), u([d({ value: null, type: ba, dependsOn: ["state.id", "ready"] })], We.prototype, "viewpoint", null), u([d({ value: -1, dependsOn: ["state.id"] })], We.prototype, "zoom", null), u([d({ type: Boolean })], We.prototype, "navigating", null), u([d({ type: MU })], We.prototype, "ui", void 0), We = u([T("geoscene.views.MapView")], We);
const k0e = We;
function BM(e) {
  const t = e.getObjectId();
  var n, r, i, s;
  return t ? `${(n = (r = (i = e.layer) == null ? void 0 : i.uid) != null ? r : (s = e.sourceLayer) == null ? void 0 : s.uid) != null ? n : "MapView"}/${t}` : `"MapView/${e.uid}`;
}
function jN(e, t, n, r, i) {
  return (s) => {
    if (s instanceof Jt) {
      if (s.layer === e)
        i == null || i();
      else {
        const o = e.allLayerViews.find((a) => a.layer === s.layer);
        o && (r == null || r(o));
      }
      n(BM(s));
    } else {
      const o = e.allLayerViews.find((a) => a.layer === s);
      o && t(o);
    }
  };
}
function VN(e, t) {
  if (e)
    if (CP(e))
      for (const n of e)
        if (CP(n))
          for (const r of n)
            t(r);
        else
          t(n);
    else
      t(e);
}
let dl = class extends rB(cB(iS)) {
  constructor(e) {
    super(e), this.elevationInfo = null, this.graphics = new Hd(), this.screenSizePerspectiveEnabled = !0, this.type = "graphics", this.internal = !1;
  }
  destroy() {
    this.removeAll(), this.graphics.destroy();
  }
  add(e) {
    return this.graphics.add(e), this;
  }
  addMany(e) {
    return this.graphics.addMany(e), this;
  }
  removeAll() {
    return this.graphics.removeAll(), this;
  }
  remove(e) {
    this.graphics.remove(e);
  }
  removeMany(e) {
    this.graphics.removeMany(e);
  }
  on(e, t) {
    return super.on(e, t);
  }
  graphicChanged(e) {
    this.emit("graphic-update", e);
  }
};
u([d({ type: iB })], dl.prototype, "elevationInfo", void 0), u([d(CM(Hd, "graphics"))], dl.prototype, "graphics", void 0), u([d({ type: ["show", "hide"] })], dl.prototype, "listMode", void 0), u([d()], dl.prototype, "screenSizePerspectiveEnabled", void 0), u([d({ readOnly: !0 })], dl.prototype, "type", void 0), u([d({ constructOnly: !0 })], dl.prototype, "internal", void 0), dl = u([T("geoscene.layers.GraphicsLayer")], dl);
const NS = dl, LU = (e) => !e.getAttribute("aria-owns"), FU = (e, t, n) => {
  const { parentNode: r } = e;
  if (!r)
    return null;
  const i = r.querySelectorAll(n), s = Array.prototype.indexOf.call(i, e);
  return i[s + t] || null;
}, Nw = (e) => {
  e && (e.focus(), !LU(e) && e.click());
}, fl = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => (i) => {
  const s = e == null ? void 0 : e(i);
  if (n === !1 || !s)
    return t == null ? void 0 : t(i);
};
var zN;
const zt = typeof window < "u", A0e = (e) => typeof e == "string", m_ = () => {
}, NU = zt && ((zN = window == null ? void 0 : window.navigator) == null ? void 0 : zN.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function yp(e) {
  return typeof e == "function" ? e() : _(e);
}
function P0e(e, t) {
  function n(...r) {
    return new Promise((i, s) => {
      Promise.resolve(e(() => t.apply(this, r), { fn: t, thisArg: this, args: r })).then(i).catch(s);
    });
  }
  return n;
}
function R0e(e, t = {}) {
  let n, r, i = m_;
  const s = (a) => {
    clearTimeout(a), i(), i = m_;
  };
  return (a) => {
    const l = yp(e), c = yp(t.maxWait);
    return n && s(n), l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r), r = null), Promise.resolve(a())) : new Promise((p, f) => {
      i = t.rejectOnCancel ? f : p, c && !r && (r = setTimeout(() => {
        n && s(n), r = null, p(a());
      }, c)), n = setTimeout(() => {
        r && s(r), r = null, p(a());
      }, l);
    });
  };
}
function L0e(e) {
  return e;
}
function DS(e) {
  return _W() ? (W5(e), !0) : !1;
}
function F0e(e, t = 200, n = {}) {
  return P0e(R0e(t, n), e);
}
function N0e(e, t = 200, n = {}) {
  const r = J(e.value), i = F0e(() => {
    r.value = e.value;
  }, t, n);
  return Ie(e, () => i()), r;
}
function D0e(e, t = !0) {
  ur() ? Yt(e) : t ? e() : rt(e);
}
function y_(e, t, n = {}) {
  const {
    immediate: r = !0
  } = n, i = J(!1);
  let s = null;
  function o() {
    s && (clearTimeout(s), s = null);
  }
  function a() {
    i.value = !1, o();
  }
  function l(...c) {
    o(), i.value = !0, s = setTimeout(() => {
      i.value = !1, s = null, e(...c);
    }, yp(t));
  }
  return r && (i.value = !0, zt && l()), DS(a), {
    isPending: H5(i),
    start: l,
    stop: a
  };
}
function xl(e) {
  var t;
  const n = yp(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const jS = zt ? window : void 0;
function Il(...e) {
  let t, n, r, i;
  if (A0e(e[0]) || Array.isArray(e[0]) ? ([n, r, i] = e, t = jS) : [t, n, r, i] = e, !t)
    return m_;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], o = () => {
    s.forEach((p) => p()), s.length = 0;
  }, a = (p, f, m, y) => (p.addEventListener(f, m, y), () => p.removeEventListener(f, m, y)), l = Ie(() => [xl(t), yp(i)], ([p, f]) => {
    o(), p && s.push(...n.flatMap((m) => r.map((y) => a(p, m, y, f))));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), o();
  };
  return DS(c), c;
}
let BN = !1;
function j0e(e, t, n = {}) {
  const { window: r = jS, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = n;
  if (!r)
    return;
  NU && !BN && (BN = !0, Array.from(r.document.body.children).forEach((m) => m.addEventListener("click", m_)));
  let a = !0;
  const l = (m) => i.some((y) => {
    if (typeof y == "string")
      return Array.from(r.document.querySelectorAll(y)).some((g) => g === m.target || m.composedPath().includes(g));
    {
      const g = xl(y);
      return g && (m.target === g || m.composedPath().includes(g));
    }
  }), p = [
    Il(r, "click", (m) => {
      const y = xl(e);
      if (!(!y || y === m.target || m.composedPath().includes(y))) {
        if (m.detail === 0 && (a = !l(m)), !a) {
          a = !0;
          return;
        }
        t(m);
      }
    }, { passive: !0, capture: s }),
    Il(r, "pointerdown", (m) => {
      const y = xl(e);
      y && (a = !m.composedPath().includes(y) && !l(m));
    }, { passive: !0 }),
    o && Il(r, "blur", (m) => {
      var y;
      const g = xl(e);
      ((y = r.document.activeElement) == null ? void 0 : y.tagName) === "IFRAME" && !(g != null && g.contains(r.document.activeElement)) && t(m);
    })
  ].filter(Boolean);
  return () => p.forEach((m) => m());
}
function V0e(e, t = !1) {
  const n = J(), r = () => n.value = !!e();
  return r(), D0e(r, t), n;
}
const UN = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, qN = "__vueuse_ssr_handlers__";
UN[qN] = UN[qN] || {};
function z0e(e, t, { window: n = jS, initialValue: r = "" } = {}) {
  const i = J(r), s = P(() => {
    var o;
    return xl(t) || ((o = n == null ? void 0 : n.document) == null ? void 0 : o.documentElement);
  });
  return Ie([s, () => yp(e)], ([o, a]) => {
    var l;
    if (o && n) {
      const c = (l = n.getComputedStyle(o).getPropertyValue(a)) == null ? void 0 : l.trim();
      i.value = c || r;
    }
  }, { immediate: !0 }), Ie(i, (o) => {
    var a;
    (a = s.value) != null && a.style && s.value.style.setProperty(yp(e), o);
  }), i;
}
var GN = Object.getOwnPropertySymbols, B0e = Object.prototype.hasOwnProperty, U0e = Object.prototype.propertyIsEnumerable, q0e = (e, t) => {
  var n = {};
  for (var r in e)
    B0e.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && GN)
    for (var r of GN(e))
      t.indexOf(r) < 0 && U0e.call(e, r) && (n[r] = e[r]);
  return n;
};
function Lp(e, t, n = {}) {
  const r = n, { window: i = jS } = r, s = q0e(r, ["window"]);
  let o;
  const a = V0e(() => i && "ResizeObserver" in i), l = () => {
    o && (o.disconnect(), o = void 0);
  }, c = Ie(() => xl(e), (f) => {
    l(), a.value && i && f && (o = new ResizeObserver(t), o.observe(f, s));
  }, { immediate: !0, flush: "post" }), p = () => {
    l(), c();
  };
  return DS(p), {
    isSupported: a,
    stop: p
  };
}
var WN;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(WN || (WN = {}));
var G0e = Object.defineProperty, HN = Object.getOwnPropertySymbols, W0e = Object.prototype.hasOwnProperty, H0e = Object.prototype.propertyIsEnumerable, JN = (e, t, n) => t in e ? G0e(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, J0e = (e, t) => {
  for (var n in t || (t = {}))
    W0e.call(t, n) && JN(e, n, t[n]);
  if (HN)
    for (var n of HN(t))
      H0e.call(t, n) && JN(e, n, t[n]);
  return e;
};
const Z0e = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
J0e({
  linear: L0e
}, Z0e);
const K0e = () => zt && /firefox/i.test(window.navigator.userAgent);
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const _a = () => {
}, DU = Object.assign, Y0e = Object.prototype.hasOwnProperty, ZN = (e, t) => Y0e.call(e, t), Pl = Array.isArray, an = (e) => typeof e == "function", ln = (e) => typeof e == "string", Q0e = (e) => typeof e == "symbol", Rr = (e) => e !== null && typeof e == "object", UM = (e) => (Rr(e) || an(e)) && an(e.then) && an(e.catch), X0e = Object.prototype.toString, eve = (e) => X0e.call(e), Qx = (e) => eve(e).slice(8, -1), u3 = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, tve = /-(\w)/g, nve = u3((e) => e.replace(tve, (t, n) => n ? n.toUpperCase() : "")), rve = /\B([A-Z])/g, ive = u3(
  (e) => e.replace(rve, "-$1").toLowerCase()
), sve = u3((e) => e.charAt(0).toUpperCase() + e.slice(1));
var ove = typeof global == "object" && global && global.Object === Object && global;
const jU = ove;
var ave = typeof self == "object" && self && self.Object === Object && self, lve = jU || ave || Function("return this")();
const Vo = lve;
var uve = Vo.Symbol;
const zs = uve;
var VU = Object.prototype, cve = VU.hasOwnProperty, dve = VU.toString, zm = zs ? zs.toStringTag : void 0;
function pve(e) {
  var t = cve.call(e, zm), n = e[zm];
  try {
    e[zm] = void 0;
    var r = !0;
  } catch {
  }
  var i = dve.call(e);
  return r && (t ? e[zm] = n : delete e[zm]), i;
}
var hve = Object.prototype, fve = hve.toString;
function mve(e) {
  return fve.call(e);
}
var yve = "[object Null]", gve = "[object Undefined]", KN = zs ? zs.toStringTag : void 0;
function om(e) {
  return e == null ? e === void 0 ? gve : yve : KN && KN in Object(e) ? pve(e) : mve(e);
}
function lc(e) {
  return e != null && typeof e == "object";
}
var vve = "[object Symbol]";
function VS(e) {
  return typeof e == "symbol" || lc(e) && om(e) == vve;
}
function bve(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var wve = Array.isArray;
const Bs = wve;
var _ve = 1 / 0, YN = zs ? zs.prototype : void 0, QN = YN ? YN.toString : void 0;
function zU(e) {
  if (typeof e == "string")
    return e;
  if (Bs(e))
    return bve(e, zU) + "";
  if (VS(e))
    return QN ? QN.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -_ve ? "-0" : t;
}
var Sve = /\s/;
function xve(e) {
  for (var t = e.length; t-- && Sve.test(e.charAt(t)); )
    ;
  return t;
}
var $ve = /^\s+/;
function Tve(e) {
  return e && e.slice(0, xve(e) + 1).replace($ve, "");
}
function No(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var XN = NaN, Eve = /^[-+]0x[0-9a-f]+$/i, Ive = /^0b[01]+$/i, Mve = /^0o[0-7]+$/i, Cve = parseInt;
function qM(e) {
  if (typeof e == "number")
    return e;
  if (VS(e))
    return XN;
  if (No(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = No(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Tve(e);
  var n = Ive.test(e);
  return n || Mve.test(e) ? Cve(e.slice(2), n ? 2 : 8) : Eve.test(e) ? XN : +e;
}
var e4 = 1 / 0, Ove = 17976931348623157e292;
function kve(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = qM(e), e === e4 || e === -e4) {
    var t = e < 0 ? -1 : 1;
    return t * Ove;
  }
  return e === e ? e : 0;
}
function Ave(e) {
  var t = kve(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function BU(e) {
  return e;
}
var Pve = "[object AsyncFunction]", Rve = "[object Function]", Lve = "[object GeneratorFunction]", Fve = "[object Proxy]";
function UU(e) {
  if (!No(e))
    return !1;
  var t = om(e);
  return t == Rve || t == Lve || t == Pve || t == Fve;
}
var Nve = Vo["__core-js_shared__"];
const Xx = Nve;
var t4 = function() {
  var e = /[^.]+$/.exec(Xx && Xx.keys && Xx.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Dve(e) {
  return !!t4 && t4 in e;
}
var jve = Function.prototype, Vve = jve.toString;
function Fp(e) {
  if (e != null) {
    try {
      return Vve.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var zve = /[\\^$.*+?()[\]{}|]/g, Bve = /^\[object .+?Constructor\]$/, Uve = Function.prototype, qve = Object.prototype, Gve = Uve.toString, Wve = qve.hasOwnProperty, Hve = RegExp(
  "^" + Gve.call(Wve).replace(zve, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Jve(e) {
  if (!No(e) || Dve(e))
    return !1;
  var t = UU(e) ? Hve : Bve;
  return t.test(Fp(e));
}
function Zve(e, t) {
  return e == null ? void 0 : e[t];
}
function Np(e, t) {
  var n = Zve(e, t);
  return Jve(n) ? n : void 0;
}
var Kve = Np(Vo, "WeakMap");
const GM = Kve;
var n4 = Object.create, Yve = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!No(t))
      return {};
    if (n4)
      return n4(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
const Qve = Yve;
function Xve(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function ebe(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var tbe = 800, nbe = 16, rbe = Date.now;
function ibe(e) {
  var t = 0, n = 0;
  return function() {
    var r = rbe(), i = nbe - (r - n);
    if (n = r, i > 0) {
      if (++t >= tbe)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function sbe(e) {
  return function() {
    return e;
  };
}
var obe = function() {
  try {
    var e = Np(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
const g_ = obe;
var abe = g_ ? function(e, t) {
  return g_(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: sbe(t),
    writable: !0
  });
} : BU;
const lbe = abe;
var ube = ibe(lbe);
const cbe = ube;
function dbe(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function pbe(e, t, n, r) {
  for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
var hbe = 9007199254740991, fbe = /^(?:0|[1-9]\d*)$/;
function c3(e, t) {
  var n = typeof e;
  return t = t ?? hbe, !!t && (n == "number" || n != "symbol" && fbe.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function qU(e, t, n) {
  t == "__proto__" && g_ ? g_(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function d3(e, t) {
  return e === t || e !== e && t !== t;
}
var mbe = Object.prototype, ybe = mbe.hasOwnProperty;
function p3(e, t, n) {
  var r = e[t];
  (!(ybe.call(e, t) && d3(r, n)) || n === void 0 && !(t in e)) && qU(e, t, n);
}
function zS(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, o = t.length; ++s < o; ) {
    var a = t[s], l = r ? r(n[a], e[a], a, n, e) : void 0;
    l === void 0 && (l = e[a]), i ? qU(n, a, l) : p3(n, a, l);
  }
  return n;
}
var r4 = Math.max;
function gbe(e, t, n) {
  return t = r4(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = r4(r.length - t, 0), o = Array(s); ++i < s; )
      o[i] = r[t + i];
    i = -1;
    for (var a = Array(t + 1); ++i < t; )
      a[i] = r[i];
    return a[t] = n(o), Xve(e, this, a);
  };
}
var vbe = 9007199254740991;
function h3(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= vbe;
}
function GU(e) {
  return e != null && h3(e.length) && !UU(e);
}
var bbe = Object.prototype;
function f3(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || bbe;
  return e === n;
}
function wbe(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var _be = "[object Arguments]";
function i4(e) {
  return lc(e) && om(e) == _be;
}
var WU = Object.prototype, Sbe = WU.hasOwnProperty, xbe = WU.propertyIsEnumerable, $be = i4(/* @__PURE__ */ function() {
  return arguments;
}()) ? i4 : function(e) {
  return lc(e) && Sbe.call(e, "callee") && !xbe.call(e, "callee");
};
const m3 = $be;
function Tbe() {
  return !1;
}
var HU = typeof exports == "object" && exports && !exports.nodeType && exports, s4 = HU && typeof module == "object" && module && !module.nodeType && module, Ebe = s4 && s4.exports === HU, o4 = Ebe ? Vo.Buffer : void 0, Ibe = o4 ? o4.isBuffer : void 0, Mbe = Ibe || Tbe;
const v_ = Mbe;
var Cbe = "[object Arguments]", Obe = "[object Array]", kbe = "[object Boolean]", Abe = "[object Date]", Pbe = "[object Error]", Rbe = "[object Function]", Lbe = "[object Map]", Fbe = "[object Number]", Nbe = "[object Object]", Dbe = "[object RegExp]", jbe = "[object Set]", Vbe = "[object String]", zbe = "[object WeakMap]", Bbe = "[object ArrayBuffer]", Ube = "[object DataView]", qbe = "[object Float32Array]", Gbe = "[object Float64Array]", Wbe = "[object Int8Array]", Hbe = "[object Int16Array]", Jbe = "[object Int32Array]", Zbe = "[object Uint8Array]", Kbe = "[object Uint8ClampedArray]", Ybe = "[object Uint16Array]", Qbe = "[object Uint32Array]", en = {};
en[qbe] = en[Gbe] = en[Wbe] = en[Hbe] = en[Jbe] = en[Zbe] = en[Kbe] = en[Ybe] = en[Qbe] = !0;
en[Cbe] = en[Obe] = en[Bbe] = en[kbe] = en[Ube] = en[Abe] = en[Pbe] = en[Rbe] = en[Lbe] = en[Fbe] = en[Nbe] = en[Dbe] = en[jbe] = en[Vbe] = en[zbe] = !1;
function Xbe(e) {
  return lc(e) && h3(e.length) && !!en[om(e)];
}
function y3(e) {
  return function(t) {
    return e(t);
  };
}
var JU = typeof exports == "object" && exports && !exports.nodeType && exports, mg = JU && typeof module == "object" && module && !module.nodeType && module, ewe = mg && mg.exports === JU, e$ = ewe && jU.process, twe = function() {
  try {
    var e = mg && mg.require && mg.require("util").types;
    return e || e$ && e$.binding && e$.binding("util");
  } catch {
  }
}();
const Mf = twe;
var a4 = Mf && Mf.isTypedArray, nwe = a4 ? y3(a4) : Xbe;
const ZU = nwe;
var rwe = Object.prototype, iwe = rwe.hasOwnProperty;
function KU(e, t) {
  var n = Bs(e), r = !n && m3(e), i = !n && !r && v_(e), s = !n && !r && !i && ZU(e), o = n || r || i || s, a = o ? wbe(e.length, String) : [], l = a.length;
  for (var c in e)
    (t || iwe.call(e, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    c3(c, l))) && a.push(c);
  return a;
}
function YU(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var swe = YU(Object.keys, Object);
const owe = swe;
var awe = Object.prototype, lwe = awe.hasOwnProperty;
function uwe(e) {
  if (!f3(e))
    return owe(e);
  var t = [];
  for (var n in Object(e))
    lwe.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function BS(e) {
  return GU(e) ? KU(e) : uwe(e);
}
function cwe(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var dwe = Object.prototype, pwe = dwe.hasOwnProperty;
function hwe(e) {
  if (!No(e))
    return cwe(e);
  var t = f3(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !pwe.call(e, r)) || n.push(r);
  return n;
}
function g3(e) {
  return GU(e) ? KU(e, !0) : hwe(e);
}
var fwe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, mwe = /^\w*$/;
function v3(e, t) {
  if (Bs(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || VS(e) ? !0 : mwe.test(e) || !fwe.test(e) || t != null && e in Object(t);
}
var ywe = Np(Object, "create");
const e0 = ywe;
function gwe() {
  this.__data__ = e0 ? e0(null) : {}, this.size = 0;
}
function vwe(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var bwe = "__lodash_hash_undefined__", wwe = Object.prototype, _we = wwe.hasOwnProperty;
function Swe(e) {
  var t = this.__data__;
  if (e0) {
    var n = t[e];
    return n === bwe ? void 0 : n;
  }
  return _we.call(t, e) ? t[e] : void 0;
}
var xwe = Object.prototype, $we = xwe.hasOwnProperty;
function Twe(e) {
  var t = this.__data__;
  return e0 ? t[e] !== void 0 : $we.call(t, e);
}
var Ewe = "__lodash_hash_undefined__";
function Iwe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = e0 && t === void 0 ? Ewe : t, this;
}
function gp(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
gp.prototype.clear = gwe;
gp.prototype.delete = vwe;
gp.prototype.get = Swe;
gp.prototype.has = Twe;
gp.prototype.set = Iwe;
function Mwe() {
  this.__data__ = [], this.size = 0;
}
function US(e, t) {
  for (var n = e.length; n--; )
    if (d3(e[n][0], t))
      return n;
  return -1;
}
var Cwe = Array.prototype, Owe = Cwe.splice;
function kwe(e) {
  var t = this.__data__, n = US(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : Owe.call(t, n, 1), --this.size, !0;
}
function Awe(e) {
  var t = this.__data__, n = US(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function Pwe(e) {
  return US(this.__data__, e) > -1;
}
function Rwe(e, t) {
  var n = this.__data__, r = US(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Nl(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Nl.prototype.clear = Mwe;
Nl.prototype.delete = kwe;
Nl.prototype.get = Awe;
Nl.prototype.has = Pwe;
Nl.prototype.set = Rwe;
var Lwe = Np(Vo, "Map");
const t0 = Lwe;
function Fwe() {
  this.size = 0, this.__data__ = {
    hash: new gp(),
    map: new (t0 || Nl)(),
    string: new gp()
  };
}
function Nwe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function qS(e, t) {
  var n = e.__data__;
  return Nwe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function Dwe(e) {
  var t = qS(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function jwe(e) {
  return qS(this, e).get(e);
}
function Vwe(e) {
  return qS(this, e).has(e);
}
function zwe(e, t) {
  var n = qS(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function Dl(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Dl.prototype.clear = Fwe;
Dl.prototype.delete = Dwe;
Dl.prototype.get = jwe;
Dl.prototype.has = Vwe;
Dl.prototype.set = zwe;
var Bwe = "Expected a function";
function b3(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Bwe);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var o = e.apply(this, r);
    return n.cache = s.set(i, o) || s, o;
  };
  return n.cache = new (b3.Cache || Dl)(), n;
}
b3.Cache = Dl;
var Uwe = 500;
function qwe(e) {
  var t = b3(e, function(r) {
    return n.size === Uwe && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Gwe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Wwe = /\\(\\)?/g, Hwe = qwe(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Gwe, function(n, r, i, s) {
    t.push(i ? s.replace(Wwe, "$1") : r || n);
  }), t;
});
const Jwe = Hwe;
function Zwe(e) {
  return e == null ? "" : zU(e);
}
function GS(e, t) {
  return Bs(e) ? e : v3(e, t) ? [e] : Jwe(Zwe(e));
}
var Kwe = 1 / 0;
function U0(e) {
  if (typeof e == "string" || VS(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -Kwe ? "-0" : t;
}
function w3(e, t) {
  t = GS(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[U0(t[n++])];
  return n && n == r ? e : void 0;
}
function vi(e, t, n) {
  var r = e == null ? void 0 : w3(e, t);
  return r === void 0 ? n : r;
}
function _3(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var l4 = zs ? zs.isConcatSpreadable : void 0;
function Ywe(e) {
  return Bs(e) || m3(e) || !!(l4 && e && e[l4]);
}
function S3(e, t, n, r, i) {
  var s = -1, o = e.length;
  for (n || (n = Ywe), i || (i = []); ++s < o; ) {
    var a = e[s];
    t > 0 && n(a) ? t > 1 ? S3(a, t - 1, n, r, i) : _3(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function Qwe(e) {
  var t = e == null ? 0 : e.length;
  return t ? S3(e, 1) : [];
}
function Xwe(e) {
  return cbe(gbe(e, void 0, Qwe), e + "");
}
var e1e = YU(Object.getPrototypeOf, Object);
const QU = e1e;
function WM() {
  if (!arguments.length)
    return [];
  var e = arguments[0];
  return Bs(e) ? e : [e];
}
function t1e() {
  this.__data__ = new Nl(), this.size = 0;
}
function n1e(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function r1e(e) {
  return this.__data__.get(e);
}
function i1e(e) {
  return this.__data__.has(e);
}
var s1e = 200;
function o1e(e, t) {
  var n = this.__data__;
  if (n instanceof Nl) {
    var r = n.__data__;
    if (!t0 || r.length < s1e - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Dl(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Sa(e) {
  var t = this.__data__ = new Nl(e);
  this.size = t.size;
}
Sa.prototype.clear = t1e;
Sa.prototype.delete = n1e;
Sa.prototype.get = r1e;
Sa.prototype.has = i1e;
Sa.prototype.set = o1e;
function a1e(e, t) {
  return e && zS(t, BS(t), e);
}
function l1e(e, t) {
  return e && zS(t, g3(t), e);
}
var XU = typeof exports == "object" && exports && !exports.nodeType && exports, u4 = XU && typeof module == "object" && module && !module.nodeType && module, u1e = u4 && u4.exports === XU, c4 = u1e ? Vo.Buffer : void 0, d4 = c4 ? c4.allocUnsafe : void 0;
function c1e(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = d4 ? d4(n) : new e.constructor(n);
  return e.copy(r), r;
}
function d1e(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var o = e[n];
    t(o, n, e) && (s[i++] = o);
  }
  return s;
}
function eq() {
  return [];
}
var p1e = Object.prototype, h1e = p1e.propertyIsEnumerable, p4 = Object.getOwnPropertySymbols, f1e = p4 ? function(e) {
  return e == null ? [] : (e = Object(e), d1e(p4(e), function(t) {
    return h1e.call(e, t);
  }));
} : eq;
const x3 = f1e;
function m1e(e, t) {
  return zS(e, x3(e), t);
}
var y1e = Object.getOwnPropertySymbols, g1e = y1e ? function(e) {
  for (var t = []; e; )
    _3(t, x3(e)), e = QU(e);
  return t;
} : eq;
const tq = g1e;
function v1e(e, t) {
  return zS(e, tq(e), t);
}
function nq(e, t, n) {
  var r = t(e);
  return Bs(e) ? r : _3(r, n(e));
}
function HM(e) {
  return nq(e, BS, x3);
}
function b1e(e) {
  return nq(e, g3, tq);
}
var w1e = Np(Vo, "DataView");
const JM = w1e;
var _1e = Np(Vo, "Promise");
const ZM = _1e;
var S1e = Np(Vo, "Set");
const KM = S1e;
var h4 = "[object Map]", x1e = "[object Object]", f4 = "[object Promise]", m4 = "[object Set]", y4 = "[object WeakMap]", g4 = "[object DataView]", $1e = Fp(JM), T1e = Fp(t0), E1e = Fp(ZM), I1e = Fp(KM), M1e = Fp(GM), fd = om;
(JM && fd(new JM(new ArrayBuffer(1))) != g4 || t0 && fd(new t0()) != h4 || ZM && fd(ZM.resolve()) != f4 || KM && fd(new KM()) != m4 || GM && fd(new GM()) != y4) && (fd = function(e) {
  var t = om(e), n = t == x1e ? e.constructor : void 0, r = n ? Fp(n) : "";
  if (r)
    switch (r) {
      case $1e:
        return g4;
      case T1e:
        return h4;
      case E1e:
        return f4;
      case I1e:
        return m4;
      case M1e:
        return y4;
    }
  return t;
});
const n0 = fd;
var C1e = Object.prototype, O1e = C1e.hasOwnProperty;
function k1e(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && O1e.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var A1e = Vo.Uint8Array;
const b_ = A1e;
function $3(e) {
  var t = new e.constructor(e.byteLength);
  return new b_(t).set(new b_(e)), t;
}
function P1e(e, t) {
  var n = t ? $3(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var R1e = /\w*$/;
function L1e(e) {
  var t = new e.constructor(e.source, R1e.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var v4 = zs ? zs.prototype : void 0, b4 = v4 ? v4.valueOf : void 0;
function F1e(e) {
  return b4 ? Object(b4.call(e)) : {};
}
function N1e(e, t) {
  var n = t ? $3(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var D1e = "[object Boolean]", j1e = "[object Date]", V1e = "[object Map]", z1e = "[object Number]", B1e = "[object RegExp]", U1e = "[object Set]", q1e = "[object String]", G1e = "[object Symbol]", W1e = "[object ArrayBuffer]", H1e = "[object DataView]", J1e = "[object Float32Array]", Z1e = "[object Float64Array]", K1e = "[object Int8Array]", Y1e = "[object Int16Array]", Q1e = "[object Int32Array]", X1e = "[object Uint8Array]", e_e = "[object Uint8ClampedArray]", t_e = "[object Uint16Array]", n_e = "[object Uint32Array]";
function r_e(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case W1e:
      return $3(e);
    case D1e:
    case j1e:
      return new r(+e);
    case H1e:
      return P1e(e, n);
    case J1e:
    case Z1e:
    case K1e:
    case Y1e:
    case Q1e:
    case X1e:
    case e_e:
    case t_e:
    case n_e:
      return N1e(e, n);
    case V1e:
      return new r();
    case z1e:
    case q1e:
      return new r(e);
    case B1e:
      return L1e(e);
    case U1e:
      return new r();
    case G1e:
      return F1e(e);
  }
}
function i_e(e) {
  return typeof e.constructor == "function" && !f3(e) ? Qve(QU(e)) : {};
}
var s_e = "[object Map]";
function o_e(e) {
  return lc(e) && n0(e) == s_e;
}
var w4 = Mf && Mf.isMap, a_e = w4 ? y3(w4) : o_e;
const l_e = a_e;
var u_e = "[object Set]";
function c_e(e) {
  return lc(e) && n0(e) == u_e;
}
var _4 = Mf && Mf.isSet, d_e = _4 ? y3(_4) : c_e;
const p_e = d_e;
var h_e = 1, f_e = 2, m_e = 4, rq = "[object Arguments]", y_e = "[object Array]", g_e = "[object Boolean]", v_e = "[object Date]", b_e = "[object Error]", iq = "[object Function]", w_e = "[object GeneratorFunction]", __e = "[object Map]", S_e = "[object Number]", sq = "[object Object]", x_e = "[object RegExp]", $_e = "[object Set]", T_e = "[object String]", E_e = "[object Symbol]", I_e = "[object WeakMap]", M_e = "[object ArrayBuffer]", C_e = "[object DataView]", O_e = "[object Float32Array]", k_e = "[object Float64Array]", A_e = "[object Int8Array]", P_e = "[object Int16Array]", R_e = "[object Int32Array]", L_e = "[object Uint8Array]", F_e = "[object Uint8ClampedArray]", N_e = "[object Uint16Array]", D_e = "[object Uint32Array]", Wt = {};
Wt[rq] = Wt[y_e] = Wt[M_e] = Wt[C_e] = Wt[g_e] = Wt[v_e] = Wt[O_e] = Wt[k_e] = Wt[A_e] = Wt[P_e] = Wt[R_e] = Wt[__e] = Wt[S_e] = Wt[sq] = Wt[x_e] = Wt[$_e] = Wt[T_e] = Wt[E_e] = Wt[L_e] = Wt[F_e] = Wt[N_e] = Wt[D_e] = !0;
Wt[b_e] = Wt[iq] = Wt[I_e] = !1;
function yg(e, t, n, r, i, s) {
  var o, a = t & h_e, l = t & f_e, c = t & m_e;
  if (n && (o = i ? n(e, r, i, s) : n(e)), o !== void 0)
    return o;
  if (!No(e))
    return e;
  var p = Bs(e);
  if (p) {
    if (o = k1e(e), !a)
      return ebe(e, o);
  } else {
    var f = n0(e), m = f == iq || f == w_e;
    if (v_(e))
      return c1e(e, a);
    if (f == sq || f == rq || m && !i) {
      if (o = l || m ? {} : i_e(e), !a)
        return l ? v1e(e, l1e(o, e)) : m1e(e, a1e(o, e));
    } else {
      if (!Wt[f])
        return i ? e : {};
      o = r_e(e, f, a);
    }
  }
  s || (s = new Sa());
  var y = s.get(e);
  if (y)
    return y;
  s.set(e, o), p_e(e) ? e.forEach(function(w) {
    o.add(yg(w, t, n, w, e, s));
  }) : l_e(e) && e.forEach(function(w, b) {
    o.set(b, yg(w, t, n, b, e, s));
  });
  var g = c ? l ? b1e : HM : l ? g3 : BS, v = p ? void 0 : g(e);
  return dbe(v || e, function(w, b) {
    v && (b = w, w = e[b]), p3(o, b, yg(w, t, n, b, e, s));
  }), o;
}
var j_e = 4;
function S4(e) {
  return yg(e, j_e);
}
var V_e = 1, z_e = 4;
function oq(e) {
  return yg(e, V_e | z_e);
}
var B_e = "__lodash_hash_undefined__";
function U_e(e) {
  return this.__data__.set(e, B_e), this;
}
function q_e(e) {
  return this.__data__.has(e);
}
function w_(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Dl(); ++t < n; )
    this.add(e[t]);
}
w_.prototype.add = w_.prototype.push = U_e;
w_.prototype.has = q_e;
function G_e(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function W_e(e, t) {
  return e.has(t);
}
var H_e = 1, J_e = 2;
function aq(e, t, n, r, i, s) {
  var o = n & H_e, a = e.length, l = t.length;
  if (a != l && !(o && l > a))
    return !1;
  var c = s.get(e), p = s.get(t);
  if (c && p)
    return c == t && p == e;
  var f = -1, m = !0, y = n & J_e ? new w_() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < a; ) {
    var g = e[f], v = t[f];
    if (r)
      var w = o ? r(v, g, f, t, e, s) : r(g, v, f, e, t, s);
    if (w !== void 0) {
      if (w)
        continue;
      m = !1;
      break;
    }
    if (y) {
      if (!G_e(t, function(b, S) {
        if (!W_e(y, S) && (g === b || i(g, b, n, r, s)))
          return y.push(S);
      })) {
        m = !1;
        break;
      }
    } else if (!(g === v || i(g, v, n, r, s))) {
      m = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), m;
}
function Z_e(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function K_e(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var Y_e = 1, Q_e = 2, X_e = "[object Boolean]", eSe = "[object Date]", tSe = "[object Error]", nSe = "[object Map]", rSe = "[object Number]", iSe = "[object RegExp]", sSe = "[object Set]", oSe = "[object String]", aSe = "[object Symbol]", lSe = "[object ArrayBuffer]", uSe = "[object DataView]", x4 = zs ? zs.prototype : void 0, t$ = x4 ? x4.valueOf : void 0;
function cSe(e, t, n, r, i, s, o) {
  switch (n) {
    case uSe:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case lSe:
      return !(e.byteLength != t.byteLength || !s(new b_(e), new b_(t)));
    case X_e:
    case eSe:
    case rSe:
      return d3(+e, +t);
    case tSe:
      return e.name == t.name && e.message == t.message;
    case iSe:
    case oSe:
      return e == t + "";
    case nSe:
      var a = Z_e;
    case sSe:
      var l = r & Y_e;
      if (a || (a = K_e), e.size != t.size && !l)
        return !1;
      var c = o.get(e);
      if (c)
        return c == t;
      r |= Q_e, o.set(e, t);
      var p = aq(a(e), a(t), r, i, s, o);
      return o.delete(e), p;
    case aSe:
      if (t$)
        return t$.call(e) == t$.call(t);
  }
  return !1;
}
var dSe = 1, pSe = Object.prototype, hSe = pSe.hasOwnProperty;
function fSe(e, t, n, r, i, s) {
  var o = n & dSe, a = HM(e), l = a.length, c = HM(t), p = c.length;
  if (l != p && !o)
    return !1;
  for (var f = l; f--; ) {
    var m = a[f];
    if (!(o ? m in t : hSe.call(t, m)))
      return !1;
  }
  var y = s.get(e), g = s.get(t);
  if (y && g)
    return y == t && g == e;
  var v = !0;
  s.set(e, t), s.set(t, e);
  for (var w = o; ++f < l; ) {
    m = a[f];
    var b = e[m], S = t[m];
    if (r)
      var $ = o ? r(S, b, m, t, e, s) : r(b, S, m, e, t, s);
    if (!($ === void 0 ? b === S || i(b, S, n, r, s) : $)) {
      v = !1;
      break;
    }
    w || (w = m == "constructor");
  }
  if (v && !w) {
    var I = e.constructor, M = t.constructor;
    I != M && "constructor" in e && "constructor" in t && !(typeof I == "function" && I instanceof I && typeof M == "function" && M instanceof M) && (v = !1);
  }
  return s.delete(e), s.delete(t), v;
}
var mSe = 1, $4 = "[object Arguments]", T4 = "[object Array]", nb = "[object Object]", ySe = Object.prototype, E4 = ySe.hasOwnProperty;
function gSe(e, t, n, r, i, s) {
  var o = Bs(e), a = Bs(t), l = o ? T4 : n0(e), c = a ? T4 : n0(t);
  l = l == $4 ? nb : l, c = c == $4 ? nb : c;
  var p = l == nb, f = c == nb, m = l == c;
  if (m && v_(e)) {
    if (!v_(t))
      return !1;
    o = !0, p = !1;
  }
  if (m && !p)
    return s || (s = new Sa()), o || ZU(e) ? aq(e, t, n, r, i, s) : cSe(e, t, l, n, r, i, s);
  if (!(n & mSe)) {
    var y = p && E4.call(e, "__wrapped__"), g = f && E4.call(t, "__wrapped__");
    if (y || g) {
      var v = y ? e.value() : e, w = g ? t.value() : t;
      return s || (s = new Sa()), i(v, w, n, r, s);
    }
  }
  return m ? (s || (s = new Sa()), fSe(e, t, n, r, i, s)) : !1;
}
function WS(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !lc(e) && !lc(t) ? e !== e && t !== t : gSe(e, t, n, r, WS, i);
}
var vSe = 1, bSe = 2;
function wSe(e, t, n, r) {
  var i = n.length, s = i, o = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var a = n[i];
    if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    a = n[i];
    var l = a[0], c = e[l], p = a[1];
    if (o && a[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var f = new Sa();
      if (r)
        var m = r(c, p, l, e, t, f);
      if (!(m === void 0 ? WS(p, c, vSe | bSe, r, f) : m))
        return !1;
    }
  }
  return !0;
}
function lq(e) {
  return e === e && !No(e);
}
function _Se(e) {
  for (var t = BS(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, lq(i)];
  }
  return t;
}
function uq(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function SSe(e) {
  var t = _Se(e);
  return t.length == 1 && t[0][2] ? uq(t[0][0], t[0][1]) : function(n) {
    return n === e || wSe(n, e, t);
  };
}
function xSe(e, t) {
  return e != null && t in Object(e);
}
function $Se(e, t, n) {
  t = GS(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var o = U0(t[r]);
    if (!(s = e != null && n(e, o)))
      break;
    e = e[o];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && h3(i) && c3(o, i) && (Bs(e) || m3(e)));
}
function cq(e, t) {
  return e != null && $Se(e, t, xSe);
}
var TSe = 1, ESe = 2;
function ISe(e, t) {
  return v3(e) && lq(t) ? uq(U0(e), t) : function(n) {
    var r = vi(n, e);
    return r === void 0 && r === t ? cq(n, e) : WS(t, r, TSe | ESe);
  };
}
function MSe(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function CSe(e) {
  return function(t) {
    return w3(t, e);
  };
}
function OSe(e) {
  return v3(e) ? MSe(U0(e)) : CSe(e);
}
function kSe(e) {
  return typeof e == "function" ? e : e == null ? BU : typeof e == "object" ? Bs(e) ? ISe(e[0], e[1]) : SSe(e) : OSe(e);
}
var ASe = function() {
  return Vo.Date.now();
};
const n$ = ASe;
var PSe = "Expected a function", RSe = Math.max, LSe = Math.min;
function YM(e, t, n) {
  var r, i, s, o, a, l, c = 0, p = !1, f = !1, m = !0;
  if (typeof e != "function")
    throw new TypeError(PSe);
  t = qM(t) || 0, No(n) && (p = !!n.leading, f = "maxWait" in n, s = f ? RSe(qM(n.maxWait) || 0, t) : s, m = "trailing" in n ? !!n.trailing : m);
  function y(E) {
    var C = r, A = i;
    return r = i = void 0, c = E, o = e.apply(A, C), o;
  }
  function g(E) {
    return c = E, a = setTimeout(b, t), p ? y(E) : o;
  }
  function v(E) {
    var C = E - l, A = E - c, W = t - C;
    return f ? LSe(W, s - A) : W;
  }
  function w(E) {
    var C = E - l, A = E - c;
    return l === void 0 || C >= t || C < 0 || f && A >= s;
  }
  function b() {
    var E = n$();
    if (w(E))
      return S(E);
    a = setTimeout(b, v(E));
  }
  function S(E) {
    return a = void 0, m && r ? y(E) : (r = i = void 0, o);
  }
  function $() {
    a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
  }
  function I() {
    return a === void 0 ? o : S(n$());
  }
  function M() {
    var E = n$(), C = w(E);
    if (r = arguments, i = this, l = E, C) {
      if (a === void 0)
        return g(l);
      if (f)
        return clearTimeout(a), a = setTimeout(b, t), y(l);
    }
    return a === void 0 && (a = setTimeout(b, t)), o;
  }
  return M.cancel = $, M.flush = I, M;
}
var FSe = Math.max, NSe = Math.min;
function DSe(e, t, n) {
  var r = e == null ? 0 : e.length;
  if (!r)
    return -1;
  var i = r - 1;
  return n !== void 0 && (i = Ave(n), i = n < 0 ? FSe(r + i, 0) : NSe(i, r - 1)), pbe(e, kSe(t), i, !0);
}
var jSe = 1 / 0;
function VSe(e) {
  var t = e == null ? 0 : e.length;
  return t ? S3(e, jSe) : [];
}
function __(e) {
  for (var t = -1, n = e == null ? 0 : e.length, r = {}; ++t < n; ) {
    var i = e[t];
    r[i[0]] = i[1];
  }
  return r;
}
function Qu(e, t) {
  return WS(e, t);
}
function q0(e) {
  return e == null;
}
function dq(e) {
  return e === void 0;
}
function pq(e, t, n, r) {
  if (!No(e))
    return e;
  t = GS(t, e);
  for (var i = -1, s = t.length, o = s - 1, a = e; a != null && ++i < s; ) {
    var l = U0(t[i]), c = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (i != o) {
      var p = a[l];
      c = r ? r(p, l, a) : void 0, c === void 0 && (c = No(p) ? p : c3(t[i + 1]) ? [] : {});
    }
    p3(a, l, c), a = a[l];
  }
  return e;
}
function zSe(e, t, n) {
  for (var r = -1, i = t.length, s = {}; ++r < i; ) {
    var o = t[r], a = w3(e, o);
    n(a, o) && pq(s, GS(o, e), a);
  }
  return s;
}
function BSe(e, t) {
  return zSe(e, t, function(n, r) {
    return cq(e, r);
  });
}
var USe = Xwe(function(e, t) {
  return e == null ? {} : BSe(e, t);
});
const qSe = USe;
function GSe(e, t, n) {
  return e == null ? e : pq(e, t, n);
}
const Cf = (e) => e === void 0, Qr = (e) => typeof e == "boolean", yn = (e) => typeof e == "number", QM = (e) => !e && e !== 0 || Pl(e) && e.length === 0 || Rr(e) && !Object.keys(e).length, uc = (e) => typeof Element > "u" ? !1 : e instanceof Element, WSe = (e) => ln(e) ? !Number.isNaN(Number(e)) : !1, HSe = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), I4 = (e) => sve(e), M4 = (e) => Object.keys(e), r$ = (e, t, n) => ({
  get value() {
    return vi(e, t, n);
  },
  set value(r) {
    GSe(e, t, r);
  }
});
class hq extends Error {
  constructor(t) {
    super(t), this.name = "ElementPlusError";
  }
}
function HS(e, t) {
  throw new hq(`[${e}] ${t}`);
}
function Zt(e, t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ln(e) ? new hq(`[${e}] ${t}`) : e;
    console.warn(n);
  }
}
const JSe = "utils/dom/style", fq = (e = "") => e.split(" ").filter((t) => !!t.trim()), C4 = (e, t) => {
  if (!e || !t)
    return !1;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e.classList.contains(t);
}, XM = (e, t) => {
  !e || !t.trim() || e.classList.add(...fq(t));
}, r0 = (e, t) => {
  !e || !t.trim() || e.classList.remove(...fq(t));
}, Fh = (e, t) => {
  var n;
  if (!zt || !e || !t)
    return "";
  let r = nve(t);
  r === "float" && (r = "cssFloat");
  try {
    const i = e.style[r];
    if (i)
      return i;
    const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
    return s ? s[r] : "";
  } catch {
    return e.style[r];
  }
};
function Rl(e, t = "px") {
  if (!e)
    return "";
  if (yn(e) || WSe(e))
    return `${e}${t}`;
  if (ln(e))
    return e;
  Zt(JSe, "binding value must be a string or number");
}
let rb;
const ZSe = (e) => {
  var t;
  if (!zt)
    return 0;
  if (rb !== void 0)
    return rb;
  const n = document.createElement("div");
  n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
  const r = n.offsetWidth;
  n.style.overflow = "scroll";
  const i = document.createElement("div");
  i.style.width = "100%", n.appendChild(i);
  const s = i.offsetWidth;
  return (t = n.parentNode) == null || t.removeChild(n), rb = r - s, rb;
};
function mq(e, t) {
  if (!zt)
    return;
  if (!t) {
    e.scrollTop = 0;
    return;
  }
  const n = [];
  let r = t.offsetParent;
  for (; r !== null && e !== r && e.contains(r); )
    n.push(r), r = r.offsetParent;
  const i = t.offsetTop + n.reduce((l, c) => l + c.offsetTop, 0), s = i + t.offsetHeight, o = e.scrollTop, a = o + e.clientHeight;
  i < o ? e.scrollTop = i : s > a && (e.scrollTop = s - e.clientHeight);
}
/*! Element Plus Icons Vue v2.3.1 */
var KSe = /* @__PURE__ */ fe({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), yq = KSe, YSe = /* @__PURE__ */ fe({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), QSe = YSe, XSe = /* @__PURE__ */ fe({
  name: "Check",
  __name: "check",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), gq = XSe, e2e = /* @__PURE__ */ fe({
  name: "CircleCheck",
  __name: "circle-check",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      ee("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), t2e = e2e, n2e = /* @__PURE__ */ fe({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), vq = n2e, r2e = /* @__PURE__ */ fe({
  name: "CircleClose",
  __name: "circle-close",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      ee("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), JS = r2e, i2e = /* @__PURE__ */ fe({
  name: "Close",
  __name: "close",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), S_ = i2e, s2e = /* @__PURE__ */ fe({
  name: "Hide",
  __name: "hide",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      ee("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), o2e = s2e, a2e = /* @__PURE__ */ fe({
  name: "InfoFilled",
  __name: "info-filled",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), bq = a2e, l2e = /* @__PURE__ */ fe({
  name: "Loading",
  __name: "loading",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), G0 = l2e, u2e = /* @__PURE__ */ fe({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), wq = u2e, c2e = /* @__PURE__ */ fe({
  name: "View",
  __name: "view",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), d2e = c2e, p2e = /* @__PURE__ */ fe({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(e) {
    return (t, n) => (F(), X("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ee("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), _q = p2e;
const Sq = "__epPropKey", Be = (e) => e, h2e = (e) => Rr(e) && !!e[Sq], ZS = (e, t) => {
  if (!Rr(e) || h2e(e))
    return e;
  const { values: n, required: r, default: i, type: s, validator: o } = e, l = {
    type: s,
    required: !!r,
    validator: n || o ? (c) => {
      let p = !1, f = [];
      if (n && (f = Array.from(n), ZN(e, "default") && f.push(i), p || (p = f.includes(c))), o && (p || (p = o(c))), !p && f.length > 0) {
        const m = [...new Set(f)].map((y) => JSON.stringify(y)).join(", ");
        SW(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${m}], got value ${JSON.stringify(c)}.`);
      }
      return p;
    } : void 0,
    [Sq]: !0
  };
  return ZN(e, "default") && (l.default = i), l;
}, bt = (e) => __(Object.entries(e).map(([t, n]) => [
  t,
  ZS(n, t)
])), Yi = Be([
  String,
  Object,
  Function
]), xq = {
  Close: S_
}, f2e = {
  Close: S_,
  SuccessFilled: wq,
  InfoFilled: bq,
  WarningFilled: _q,
  CircleCloseFilled: vq
}, x_ = {
  success: wq,
  warning: _q,
  error: vq,
  info: bq
}, $q = {
  validating: G0,
  success: t2e,
  error: JS
}, Ai = (e, t) => {
  if (e.install = (n) => {
    for (const r of [e, ...Object.values(t ?? {})])
      n.component(r.name, r);
  }, t)
    for (const [n, r] of Object.entries(t))
      e[n] = r;
  return e;
}, Tq = (e, t) => (e.install = (n) => {
  e._context = n._context, n.config.globalProperties[t] = e;
}, e), bc = (e) => (e.install = _a, e), m2e = (...e) => (t) => {
  e.forEach((n) => {
    an(n) ? n(t) : n.value = t;
  });
}, on = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, jt = "update:modelValue", Oa = "change", eC = "input", W0 = ["", "default", "small", "large"], y2e = {
  large: 40,
  default: 32,
  small: 24
}, g2e = (e) => y2e[e || "default"], Eq = (e) => ["", ...W0].includes(e);
var Dw = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(Dw || {});
const O4 = (e) => [...new Set(e)], k4 = (e) => !e && e !== 0 ? [] : Array.isArray(e) ? e : [e], T3 = (e) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e), v2e = () => Math.floor(Math.random() * 1e4), Iq = (e) => e, b2e = ["class", "style"], w2e = /^on[A-Z]/, _2e = (e = {}) => {
  const { excludeListeners: t = !1, excludeKeys: n } = e, r = P(() => ((n == null ? void 0 : n.value) || []).concat(b2e)), i = ur();
  return i ? P(() => {
    var s;
    return __(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !r.value.includes(o) && !(t && w2e.test(o))));
  }) : (Zt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), P(() => ({})));
}, i0 = ({ from: e, replacement: t, scope: n, version: r, ref: i, type: s = "API" }, o) => {
  Ie(() => _(o), (a) => {
    a && Zt(n, `[${s}] ${e} is about to be deprecated in version ${r}, please use ${t} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
}, S2e = (e, t, n) => {
  let r = {
    offsetX: 0,
    offsetY: 0
  };
  const i = (a) => {
    const l = a.clientX, c = a.clientY, { offsetX: p, offsetY: f } = r, m = e.value.getBoundingClientRect(), y = m.left, g = m.top, v = m.width, w = m.height, b = document.documentElement.clientWidth, S = document.documentElement.clientHeight, $ = -y + p, I = -g + f, M = b - y - v + p, E = S - g - w + f, C = (W) => {
      const j = Math.min(Math.max(p + W.clientX - l, $), M), G = Math.min(Math.max(f + W.clientY - c, I), E);
      r = {
        offsetX: j,
        offsetY: G
      }, e.value && (e.value.style.transform = `translate(${Rl(j)}, ${Rl(G)})`);
    }, A = () => {
      document.removeEventListener("mousemove", C), document.removeEventListener("mouseup", A);
    };
    document.addEventListener("mousemove", C), document.addEventListener("mouseup", A);
  }, s = () => {
    t.value && e.value && t.value.addEventListener("mousedown", i);
  }, o = () => {
    t.value && e.value && t.value.removeEventListener("mousedown", i);
  };
  Yt(() => {
    xW(() => {
      n.value ? s() : o();
    });
  }), us(() => {
    o();
  });
};
var x2e = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const $2e = (e) => (t, n) => T2e(t, n, _(e)), T2e = (e, t, n) => vi(n, e, e).replace(/\{(\w+)\}/g, (r, i) => {
  var s;
  return `${(s = t == null ? void 0 : t[i]) != null ? s : `{${i}}`}`;
}), E2e = (e) => {
  const t = P(() => _(e).name), n = $a(e) ? e : J(e);
  return {
    lang: t,
    locale: n,
    t: $2e(e)
  };
}, Mq = Symbol("localeContextKey"), Dp = (e) => {
  const t = e || pt(Mq, J());
  return E2e(P(() => t.value || x2e));
};
let I2e;
function M2e(e, t = I2e) {
  t && t.active && t.effects.push(e);
}
const A4 = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, Cq = (e) => (e.w & cc) > 0, Oq = (e) => (e.n & cc) > 0, C2e = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= cc;
}, O2e = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let n = 0;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      Cq(i) && !Oq(i) ? i.delete(e) : t[n++] = i, i.w &= ~cc, i.n &= ~cc;
    }
    t.length = n;
  }
};
let Gy = 0, cc = 1;
const tC = 30;
let Zi;
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class k2e {
  constructor(t, n = null, r) {
    this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, M2e(this, r);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = Zi, n = jw;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = Zi, Zi = this, jw = !0, cc = 1 << ++Gy, Gy <= tC ? C2e(this) : P4(this), this.fn();
    } finally {
      Gy <= tC && O2e(this), cc = 1 << --Gy, Zi = this.parent, jw = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Zi === this ? this.deferStop = !0 : this.active && (P4(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function P4(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0;
  }
}
let jw = !0;
function R4(e, t) {
  let n = !1;
  Gy <= tC ? Oq(e) || (e.n |= cc, n = !Cq(e)) : n = !e.has(Zi), n && (e.add(Zi), Zi.deps.push(e), process.env.NODE_ENV !== "production" && Zi.onTrack && Zi.onTrack(
    DU(
      {
        effect: Zi
      },
      t
    )
  ));
}
function L4(e, t) {
  const n = Pl(e) ? e : [...e];
  for (const r of n)
    r.computed && F4(r, t);
  for (const r of n)
    r.computed || F4(r, t);
}
function F4(e, t) {
  (e !== Zi || e.allowRecurse) && (process.env.NODE_ENV !== "production" && e.onTrigger && e.onTrigger(DU({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
}
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Q0e)
);
function KS(e) {
  const t = e && e.__v_raw;
  return t ? KS(t) : e;
}
function A2e(e) {
  jw && Zi && (e = KS(e), process.env.NODE_ENV !== "production" ? R4(e.dep || (e.dep = A4()), {
    target: e,
    type: "get",
    key: "value"
  }) : R4(e.dep || (e.dep = A4())));
}
function P2e(e, t) {
  e = KS(e);
  const n = e.dep;
  n && (process.env.NODE_ENV !== "production" ? L4(n, {
    target: e,
    type: "set",
    key: "value",
    newValue: t
  }) : L4(n));
}
class R2e {
  constructor(t, n, r, i) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new k2e(t, () => {
      this._dirty || (this._dirty = !0, P2e(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r;
  }
  get value() {
    const t = KS(this);
    return A2e(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
function L2e(e, t, n = !1) {
  let r, i;
  const s = an(e);
  s ? (r = e, i = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : _a) : (r = e.get, i = e.set);
  const o = new R2e(r, i, s || !i, n);
  return process.env.NODE_ENV !== "production" && t && !n && (o.effect.onTrack = t.onTrack, o.effect.onTrigger = t.onTrigger), o;
}
const gg = "el", F2e = "is-", Oc = (e, t, n, r, i) => {
  let s = `${e}-${t}`;
  return n && (s += `-${n}`), r && (s += `__${r}`), i && (s += `--${i}`), s;
}, kq = Symbol("namespaceContextKey"), E3 = (e) => {
  const t = e || (ur() ? pt(kq, J(gg)) : J(gg));
  return P(() => _(t) || gg);
}, tt = (e, t) => {
  const n = E3(t);
  return {
    namespace: n,
    b: (v = "") => Oc(n.value, e, v, "", ""),
    e: (v) => v ? Oc(n.value, e, "", v, "") : "",
    m: (v) => v ? Oc(n.value, e, "", "", v) : "",
    be: (v, w) => v && w ? Oc(n.value, e, v, w, "") : "",
    em: (v, w) => v && w ? Oc(n.value, e, "", v, w) : "",
    bm: (v, w) => v && w ? Oc(n.value, e, v, "", w) : "",
    bem: (v, w, b) => v && w && b ? Oc(n.value, e, v, w, b) : "",
    is: (v, ...w) => {
      const b = w.length >= 1 ? w[0] : !0;
      return v && b ? `${F2e}${v}` : "";
    },
    cssVar: (v) => {
      const w = {};
      for (const b in v)
        v[b] && (w[`--${n.value}-${b}`] = v[b]);
      return w;
    },
    cssVarName: (v) => `--${n.value}-${v}`,
    cssVarBlock: (v) => {
      const w = {};
      for (const b in v)
        v[b] && (w[`--${n.value}-${e}-${b}`] = v[b]);
      return w;
    },
    cssVarBlockName: (v) => `--${n.value}-${e}-${v}`
  };
}, N2e = (e, t = {}) => {
  $a(e) || HS("[useLockscreen]", "You need to pass a ref param to this function");
  const n = t.ns || tt("popup"), r = L2e(() => n.bm("parent", "hidden"));
  if (!zt || C4(document.body, r.value))
    return;
  let i = 0, s = !1, o = "0";
  const a = () => {
    setTimeout(() => {
      r0(document == null ? void 0 : document.body, r.value), s && document && (document.body.style.width = o);
    }, 200);
  };
  Ie(e, (l) => {
    if (!l) {
      a();
      return;
    }
    s = !C4(document.body, r.value), s && (o = document.body.style.width), i = ZSe(n.namespace.value);
    const c = document.documentElement.clientHeight < document.body.scrollHeight, p = Fh(document.body, "overflowY");
    i > 0 && (c || p === "scroll") && s && (document.body.style.width = `calc(100% - ${i}px)`), XM(document.body, r.value);
  }), W5(() => a());
}, D2e = ZS({
  type: Be(Boolean),
  default: null
}), j2e = ZS({
  type: Be(Function)
}), Aq = (e) => {
  const t = `update:${e}`, n = `onUpdate:${e}`, r = [t], i = {
    [e]: D2e,
    [n]: j2e
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: c,
      onShow: p,
      onHide: f
    }) => {
      const m = ur(), { emit: y } = m, g = m.props, v = P(() => an(g[n])), w = P(() => g[e] === null), b = (C) => {
        o.value !== !0 && (o.value = !0, a && (a.value = C), an(p) && p(C));
      }, S = (C) => {
        o.value !== !1 && (o.value = !1, a && (a.value = C), an(f) && f(C));
      }, $ = (C) => {
        if (g.disabled === !0 || an(c) && !c())
          return;
        const A = v.value && zt;
        A && y(t, !0), (w.value || !A) && b(C);
      }, I = (C) => {
        if (g.disabled === !0 || !zt)
          return;
        const A = v.value && zt;
        A && y(t, !1), (w.value || !A) && S(C);
      }, M = (C) => {
        Qr(C) && (g.disabled && C ? v.value && y(t, !1) : o.value !== C && (C ? b() : S()));
      }, E = () => {
        o.value ? I() : $();
      };
      return Ie(() => g[e], M), l && m.appContext.config.globalProperties.$route !== void 0 && Ie(() => ({
        ...m.proxy.$route
      }), () => {
        l.value && o.value && I();
      }), Yt(() => {
        M(g[e]);
      }), {
        hide: I,
        show: $,
        toggle: E,
        hasUpdateHandler: v
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: r
  };
};
Aq("modelValue");
const Pq = (e) => {
  const t = ur();
  return P(() => {
    var n, r;
    return (r = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : r[e];
  });
};
var $i = "top", Us = "bottom", qs = "right", Ti = "left", I3 = "auto", H0 = [$i, Us, qs, Ti], Of = "start", s0 = "end", V2e = "clippingParents", Rq = "viewport", Bm = "popper", z2e = "reference", N4 = /* @__PURE__ */ H0.reduce(function(e, t) {
  return e.concat([t + "-" + Of, t + "-" + s0]);
}, []), YS = /* @__PURE__ */ [].concat(H0, [I3]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Of, t + "-" + s0]);
}, []), B2e = "beforeRead", U2e = "read", q2e = "afterRead", G2e = "beforeMain", W2e = "main", H2e = "afterMain", J2e = "beforeWrite", Z2e = "write", K2e = "afterWrite", Y2e = [B2e, U2e, q2e, G2e, W2e, H2e, J2e, Z2e, K2e];
function ka(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function ls(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function vp(e) {
  var t = ls(e).Element;
  return e instanceof t || e instanceof Element;
}
function Ns(e) {
  var t = ls(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function M3(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ls(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function Q2e(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, s = t.elements[n];
    !Ns(s) || !ka(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function X2e(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], s = t.attributes[r] || {}, o = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !Ns(i) || !ka(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const exe = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Q2e,
  effect: X2e,
  requires: ["computeStyles"]
};
function xa(e) {
  return e.split("-")[0];
}
var Zd = Math.max, $_ = Math.min, kf = Math.round;
function nC() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Lq() {
  return !/^((?!chrome|android).)*safari/i.test(nC());
}
function Af(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, s = 1;
  t && Ns(e) && (i = e.offsetWidth > 0 && kf(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && kf(r.height) / e.offsetHeight || 1);
  var o = vp(e) ? ls(e) : window, a = o.visualViewport, l = !Lq() && n, c = (r.left + (l && a ? a.offsetLeft : 0)) / i, p = (r.top + (l && a ? a.offsetTop : 0)) / s, f = r.width / i, m = r.height / s;
  return {
    width: f,
    height: m,
    top: p,
    right: c + f,
    bottom: p + m,
    left: c,
    x: c,
    y: p
  };
}
function C3(e) {
  var t = Af(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function Fq(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && M3(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Ll(e) {
  return ls(e).getComputedStyle(e);
}
function txe(e) {
  return ["table", "td", "th"].indexOf(ka(e)) >= 0;
}
function wc(e) {
  return ((vp(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function QS(e) {
  return ka(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (M3(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    wc(e)
  );
}
function D4(e) {
  return !Ns(e) || // https://github.com/popperjs/popper-core/issues/837
  Ll(e).position === "fixed" ? null : e.offsetParent;
}
function nxe(e) {
  var t = /firefox/i.test(nC()), n = /Trident/i.test(nC());
  if (n && Ns(e)) {
    var r = Ll(e);
    if (r.position === "fixed")
      return null;
  }
  var i = QS(e);
  for (M3(i) && (i = i.host); Ns(i) && ["html", "body"].indexOf(ka(i)) < 0; ) {
    var s = Ll(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function J0(e) {
  for (var t = ls(e), n = D4(e); n && txe(n) && Ll(n).position === "static"; )
    n = D4(n);
  return n && (ka(n) === "html" || ka(n) === "body" && Ll(n).position === "static") ? t : n || nxe(e) || t;
}
function O3(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function vg(e, t, n) {
  return Zd(e, $_(t, n));
}
function rxe(e, t, n) {
  var r = vg(e, t, n);
  return r > n ? n : r;
}
function Nq() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Dq(e) {
  return Object.assign({}, Nq(), e);
}
function jq(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var ixe = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, Dq(typeof t != "number" ? t : jq(t, H0));
};
function sxe(e) {
  var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = xa(n.placement), l = O3(a), c = [Ti, qs].indexOf(a) >= 0, p = c ? "height" : "width";
  if (!(!s || !o)) {
    var f = ixe(i.padding, n), m = C3(s), y = l === "y" ? $i : Ti, g = l === "y" ? Us : qs, v = n.rects.reference[p] + n.rects.reference[l] - o[l] - n.rects.popper[p], w = o[l] - n.rects.reference[l], b = J0(s), S = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, $ = v / 2 - w / 2, I = f[y], M = S - m[p] - f[g], E = S / 2 - m[p] / 2 + $, C = vg(I, E, M), A = l;
    n.modifiersData[r] = (t = {}, t[A] = C, t.centerOffset = C - E, t);
  }
}
function oxe(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || Fq(t.elements.popper, i) && (t.elements.arrow = i));
}
const axe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: sxe,
  effect: oxe,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Pf(e) {
  return e.split("-")[1];
}
var lxe = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function uxe(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: kf(n * i) / i || 0,
    y: kf(r * i) / i || 0
  };
}
function j4(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, p = e.roundOffsets, f = e.isFixed, m = o.x, y = m === void 0 ? 0 : m, g = o.y, v = g === void 0 ? 0 : g, w = typeof p == "function" ? p({
    x: y,
    y: v
  }) : {
    x: y,
    y: v
  };
  y = w.x, v = w.y;
  var b = o.hasOwnProperty("x"), S = o.hasOwnProperty("y"), $ = Ti, I = $i, M = window;
  if (c) {
    var E = J0(n), C = "clientHeight", A = "clientWidth";
    if (E === ls(n) && (E = wc(n), Ll(E).position !== "static" && a === "absolute" && (C = "scrollHeight", A = "scrollWidth")), E = E, i === $i || (i === Ti || i === qs) && s === s0) {
      I = Us;
      var W = f && E === M && M.visualViewport ? M.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        E[C]
      );
      v -= W - r.height, v *= l ? 1 : -1;
    }
    if (i === Ti || (i === $i || i === Us) && s === s0) {
      $ = qs;
      var j = f && E === M && M.visualViewport ? M.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        E[A]
      );
      y -= j - r.width, y *= l ? 1 : -1;
    }
  }
  var G = Object.assign({
    position: a
  }, c && lxe), R = p === !0 ? uxe({
    x: y,
    y: v
  }, ls(n)) : {
    x: y,
    y: v
  };
  if (y = R.x, v = R.y, l) {
    var V;
    return Object.assign({}, G, (V = {}, V[I] = S ? "0" : "", V[$] = b ? "0" : "", V.transform = (M.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + v + "px)" : "translate3d(" + y + "px, " + v + "px, 0)", V));
  }
  return Object.assign({}, G, (t = {}, t[I] = S ? v + "px" : "", t[$] = b ? y + "px" : "", t.transform = "", t));
}
function cxe(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: xa(t.placement),
    variation: Pf(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, j4(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, j4(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const dxe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: cxe,
  data: {}
};
var ib = {
  passive: !0
};
function pxe(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = ls(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && c.forEach(function(p) {
    p.addEventListener("scroll", n.update, ib);
  }), a && l.addEventListener("resize", n.update, ib), function() {
    s && c.forEach(function(p) {
      p.removeEventListener("scroll", n.update, ib);
    }), a && l.removeEventListener("resize", n.update, ib);
  };
}
const hxe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: pxe,
  data: {}
};
var fxe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Vw(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return fxe[t];
  });
}
var mxe = {
  start: "end",
  end: "start"
};
function V4(e) {
  return e.replace(/start|end/g, function(t) {
    return mxe[t];
  });
}
function k3(e) {
  var t = ls(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function A3(e) {
  return Af(wc(e)).left + k3(e).scrollLeft;
}
function yxe(e, t) {
  var n = ls(e), r = wc(e), i = n.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    var c = Lq();
    (c || !c && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + A3(e),
    y: l
  };
}
function gxe(e) {
  var t, n = wc(e), r = k3(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = Zd(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Zd(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + A3(e), l = -r.scrollTop;
  return Ll(i || n).direction === "rtl" && (a += Zd(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function P3(e) {
  var t = Ll(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function Vq(e) {
  return ["html", "body", "#document"].indexOf(ka(e)) >= 0 ? e.ownerDocument.body : Ns(e) && P3(e) ? e : Vq(QS(e));
}
function bg(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = Vq(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = ls(r), o = i ? [s].concat(s.visualViewport || [], P3(r) ? r : []) : r, a = t.concat(o);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(bg(QS(o)))
  );
}
function rC(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function vxe(e, t) {
  var n = Af(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function z4(e, t, n) {
  return t === Rq ? rC(yxe(e, n)) : vp(t) ? vxe(t, n) : rC(gxe(wc(e)));
}
function bxe(e) {
  var t = bg(QS(e)), n = ["absolute", "fixed"].indexOf(Ll(e).position) >= 0, r = n && Ns(e) ? J0(e) : e;
  return vp(r) ? t.filter(function(i) {
    return vp(i) && Fq(i, r) && ka(i) !== "body";
  }) : [];
}
function wxe(e, t, n, r) {
  var i = t === "clippingParents" ? bxe(e) : [].concat(t), s = [].concat(i, [n]), o = s[0], a = s.reduce(function(l, c) {
    var p = z4(e, c, r);
    return l.top = Zd(p.top, l.top), l.right = $_(p.right, l.right), l.bottom = $_(p.bottom, l.bottom), l.left = Zd(p.left, l.left), l;
  }, z4(e, o, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function zq(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? xa(r) : null, s = r ? Pf(r) : null, o = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, l;
  switch (i) {
    case $i:
      l = {
        x: o,
        y: t.y - n.height
      };
      break;
    case Us:
      l = {
        x: o,
        y: t.y + t.height
      };
      break;
    case qs:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case Ti:
      l = {
        x: t.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = i ? O3(i) : null;
  if (c != null) {
    var p = c === "y" ? "height" : "width";
    switch (s) {
      case Of:
        l[c] = l[c] - (t[p] / 2 - n[p] / 2);
        break;
      case s0:
        l[c] = l[c] + (t[p] / 2 - n[p] / 2);
        break;
    }
  }
  return l;
}
function o0(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, s = n.strategy, o = s === void 0 ? e.strategy : s, a = n.boundary, l = a === void 0 ? V2e : a, c = n.rootBoundary, p = c === void 0 ? Rq : c, f = n.elementContext, m = f === void 0 ? Bm : f, y = n.altBoundary, g = y === void 0 ? !1 : y, v = n.padding, w = v === void 0 ? 0 : v, b = Dq(typeof w != "number" ? w : jq(w, H0)), S = m === Bm ? z2e : Bm, $ = e.rects.popper, I = e.elements[g ? S : m], M = wxe(vp(I) ? I : I.contextElement || wc(e.elements.popper), l, p, o), E = Af(e.elements.reference), C = zq({
    reference: E,
    element: $,
    strategy: "absolute",
    placement: i
  }), A = rC(Object.assign({}, $, C)), W = m === Bm ? A : E, j = {
    top: M.top - W.top + b.top,
    bottom: W.bottom - M.bottom + b.bottom,
    left: M.left - W.left + b.left,
    right: W.right - M.right + b.right
  }, G = e.modifiersData.offset;
  if (m === Bm && G) {
    var R = G[i];
    Object.keys(j).forEach(function(V) {
      var Q = [qs, Us].indexOf(V) >= 0 ? 1 : -1, de = [$i, Us].indexOf(V) >= 0 ? "y" : "x";
      j[V] += R[de] * Q;
    });
  }
  return j;
}
function _xe(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? YS : l, p = Pf(r), f = p ? a ? N4 : N4.filter(function(g) {
    return Pf(g) === p;
  }) : H0, m = f.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  m.length === 0 && (m = f);
  var y = m.reduce(function(g, v) {
    return g[v] = o0(e, {
      placement: v,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[xa(v)], g;
  }, {});
  return Object.keys(y).sort(function(g, v) {
    return y[g] - y[v];
  });
}
function Sxe(e) {
  if (xa(e) === I3)
    return [];
  var t = Vw(e);
  return [V4(e), t, V4(t)];
}
function xxe(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, p = n.boundary, f = n.rootBoundary, m = n.altBoundary, y = n.flipVariations, g = y === void 0 ? !0 : y, v = n.allowedAutoPlacements, w = t.options.placement, b = xa(w), S = b === w, $ = l || (S || !g ? [Vw(w)] : Sxe(w)), I = [w].concat($).reduce(function(An, Pn) {
      return An.concat(xa(Pn) === I3 ? _xe(t, {
        placement: Pn,
        boundary: p,
        rootBoundary: f,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: v
      }) : Pn);
    }, []), M = t.rects.reference, E = t.rects.popper, C = /* @__PURE__ */ new Map(), A = !0, W = I[0], j = 0; j < I.length; j++) {
      var G = I[j], R = xa(G), V = Pf(G) === Of, Q = [$i, Us].indexOf(R) >= 0, de = Q ? "width" : "height", _e = o0(t, {
        placement: G,
        boundary: p,
        rootBoundary: f,
        altBoundary: m,
        padding: c
      }), ie = Q ? V ? qs : Ti : V ? Us : $i;
      M[de] > E[de] && (ie = Vw(ie));
      var Ae = Vw(ie), Pe = [];
      if (s && Pe.push(_e[R] <= 0), a && Pe.push(_e[ie] <= 0, _e[Ae] <= 0), Pe.every(function(An) {
        return An;
      })) {
        W = G, A = !1;
        break;
      }
      C.set(G, Pe);
    }
    if (A)
      for (var Bt = g ? 3 : 1, wt = function(Pn) {
        var Un = I.find(function(Me) {
          var Ue = C.get(Me);
          if (Ue)
            return Ue.slice(0, Pn).every(function(Xe) {
              return Xe;
            });
        });
        if (Un)
          return W = Un, "break";
      }, Ut = Bt; Ut > 0; Ut--) {
        var un = wt(Ut);
        if (un === "break")
          break;
      }
    t.placement !== W && (t.modifiersData[r]._skip = !0, t.placement = W, t.reset = !0);
  }
}
const $xe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: xxe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function B4(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function U4(e) {
  return [$i, qs, Us, Ti].some(function(t) {
    return e[t] >= 0;
  });
}
function Txe(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, o = o0(t, {
    elementContext: "reference"
  }), a = o0(t, {
    altBoundary: !0
  }), l = B4(o, r), c = B4(a, i, s), p = U4(l), f = U4(c);
  t.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: p,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": p,
    "data-popper-escaped": f
  });
}
const Exe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Txe
};
function Ixe(e, t, n) {
  var r = xa(e), i = [Ti, $i].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [Ti, qs].indexOf(r) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function Mxe(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = YS.reduce(function(p, f) {
    return p[f] = Ixe(f, t.rects, s), p;
  }, {}), a = o[t.placement], l = a.x, c = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = o;
}
const Cxe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Mxe
};
function Oxe(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = zq({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const kxe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Oxe,
  data: {}
};
function Axe(e) {
  return e === "x" ? "y" : "x";
}
function Pxe(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, c = n.rootBoundary, p = n.altBoundary, f = n.padding, m = n.tether, y = m === void 0 ? !0 : m, g = n.tetherOffset, v = g === void 0 ? 0 : g, w = o0(t, {
    boundary: l,
    rootBoundary: c,
    padding: f,
    altBoundary: p
  }), b = xa(t.placement), S = Pf(t.placement), $ = !S, I = O3(b), M = Axe(I), E = t.modifiersData.popperOffsets, C = t.rects.reference, A = t.rects.popper, W = typeof v == "function" ? v(Object.assign({}, t.rects, {
    placement: t.placement
  })) : v, j = typeof W == "number" ? {
    mainAxis: W,
    altAxis: W
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, W), G = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, R = {
    x: 0,
    y: 0
  };
  if (E) {
    if (s) {
      var V, Q = I === "y" ? $i : Ti, de = I === "y" ? Us : qs, _e = I === "y" ? "height" : "width", ie = E[I], Ae = ie + w[Q], Pe = ie - w[de], Bt = y ? -A[_e] / 2 : 0, wt = S === Of ? C[_e] : A[_e], Ut = S === Of ? -A[_e] : -C[_e], un = t.elements.arrow, An = y && un ? C3(un) : {
        width: 0,
        height: 0
      }, Pn = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Nq(), Un = Pn[Q], Me = Pn[de], Ue = vg(0, C[_e], An[_e]), Xe = $ ? C[_e] / 2 - Bt - Ue - Un - j.mainAxis : wt - Ue - Un - j.mainAxis, lt = $ ? -C[_e] / 2 + Bt + Ue + Me + j.mainAxis : Ut + Ue + Me + j.mainAxis, Tt = t.elements.arrow && J0(t.elements.arrow), bn = Tt ? I === "y" ? Tt.clientTop || 0 : Tt.clientLeft || 0 : 0, tr = (V = G == null ? void 0 : G[I]) != null ? V : 0, Pi = ie + Xe - tr - bn, ni = ie + lt - tr, Lr = vg(y ? $_(Ae, Pi) : Ae, ie, y ? Zd(Pe, ni) : Pe);
      E[I] = Lr, R[I] = Lr - ie;
    }
    if (a) {
      var ri, Fr = I === "x" ? $i : Ti, Ri = I === "x" ? Us : qs, wn = E[M], ii = M === "y" ? "height" : "width", Nr = wn + w[Fr], si = wn - w[Ri], oi = [$i, Ti].indexOf(b) !== -1, pe = (ri = G == null ? void 0 : G[M]) != null ? ri : 0, qe = oi ? Nr : wn - C[ii] - A[ii] - pe + j.altAxis, ht = oi ? wn + C[ii] + A[ii] - pe - j.altAxis : si, _n = y && oi ? rxe(qe, wn, ht) : vg(y ? qe : Nr, wn, y ? ht : si);
      E[M] = _n, R[M] = _n - wn;
    }
    t.modifiersData[r] = R;
  }
}
const Rxe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Pxe,
  requiresIfExists: ["offset"]
};
function Lxe(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function Fxe(e) {
  return e === ls(e) || !Ns(e) ? k3(e) : Lxe(e);
}
function Nxe(e) {
  var t = e.getBoundingClientRect(), n = kf(t.width) / e.offsetWidth || 1, r = kf(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function Dxe(e, t, n) {
  n === void 0 && (n = !1);
  var r = Ns(t), i = Ns(t) && Nxe(t), s = wc(t), o = Af(e, i, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((ka(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  P3(s)) && (a = Fxe(t)), Ns(t) ? (l = Af(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : s && (l.x = A3(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function jxe(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = t.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return e.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function Vxe(e) {
  var t = jxe(e);
  return Y2e.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function zxe(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function Bxe(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var q4 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function G4() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function Uxe(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, s = i === void 0 ? q4 : i;
  return function(a, l, c) {
    c === void 0 && (c = s);
    var p = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, q4, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], m = !1, y = {
      state: p,
      setOptions: function(b) {
        var S = typeof b == "function" ? b(p.options) : b;
        v(), p.options = Object.assign({}, s, p.options, S), p.scrollParents = {
          reference: vp(a) ? bg(a) : a.contextElement ? bg(a.contextElement) : [],
          popper: bg(l)
        };
        var $ = Vxe(Bxe([].concat(r, p.options.modifiers)));
        return p.orderedModifiers = $.filter(function(I) {
          return I.enabled;
        }), g(), y.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!m) {
          var b = p.elements, S = b.reference, $ = b.popper;
          if (G4(S, $)) {
            p.rects = {
              reference: Dxe(S, J0($), p.options.strategy === "fixed"),
              popper: C3($)
            }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(j) {
              return p.modifiersData[j.name] = Object.assign({}, j.data);
            });
            for (var I = 0; I < p.orderedModifiers.length; I++) {
              if (p.reset === !0) {
                p.reset = !1, I = -1;
                continue;
              }
              var M = p.orderedModifiers[I], E = M.fn, C = M.options, A = C === void 0 ? {} : C, W = M.name;
              typeof E == "function" && (p = E({
                state: p,
                options: A,
                name: W,
                instance: y
              }) || p);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: zxe(function() {
        return new Promise(function(w) {
          y.forceUpdate(), w(p);
        });
      }),
      destroy: function() {
        v(), m = !0;
      }
    };
    if (!G4(a, l))
      return y;
    y.setOptions(c).then(function(w) {
      !m && c.onFirstUpdate && c.onFirstUpdate(w);
    });
    function g() {
      p.orderedModifiers.forEach(function(w) {
        var b = w.name, S = w.options, $ = S === void 0 ? {} : S, I = w.effect;
        if (typeof I == "function") {
          var M = I({
            state: p,
            name: b,
            instance: y,
            options: $
          }), E = function() {
          };
          f.push(M || E);
        }
      });
    }
    function v() {
      f.forEach(function(w) {
        return w();
      }), f = [];
    }
    return y;
  };
}
var qxe = [hxe, kxe, dxe, exe, Cxe, $xe, Rxe, axe, Exe], Gxe = /* @__PURE__ */ Uxe({
  defaultModifiers: qxe
});
const Wxe = (e, t, n = {}) => {
  const r = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const c = Hxe(l);
      Object.assign(o.value, c);
    },
    requires: ["computeStyles"]
  }, i = P(() => {
    const { onFirstUpdate: l, placement: c, strategy: p, modifiers: f } = _(n);
    return {
      onFirstUpdate: l,
      placement: c || "bottom",
      strategy: p || "absolute",
      modifiers: [
        ...f || [],
        r,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = Vd(), o = J({
    styles: {
      popper: {
        position: _(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return Ie(i, (l) => {
    const c = _(s);
    c && c.setOptions(l);
  }, {
    deep: !0
  }), Ie([e, t], ([l, c]) => {
    a(), !(!l || !c) && (s.value = Gxe(l, c, _(i)));
  }), us(() => {
    a();
  }), {
    state: P(() => {
      var l;
      return { ...((l = _(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: P(() => _(o).styles),
    attributes: P(() => _(o).attributes),
    update: () => {
      var l;
      return (l = _(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = _(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: P(() => _(s))
  };
};
function Hxe(e) {
  const t = Object.keys(e.elements), n = __(t.map((i) => [i, e.styles[i] || {}])), r = __(t.map((i) => [i, e.attributes[i]]));
  return {
    styles: n,
    attributes: r
  };
}
const Bq = (e) => {
  if (!e)
    return { onClick: _a, onMousedown: _a, onMouseup: _a };
  let t = !1, n = !1;
  return { onClick: (o) => {
    t && n && e(o), t = n = !1;
  }, onMousedown: (o) => {
    t = o.target === o.currentTarget;
  }, onMouseup: (o) => {
    n = o.target === o.currentTarget;
  } };
};
function W4() {
  let e;
  const t = (r, i) => {
    n(), e = window.setTimeout(r, i);
  }, n = () => window.clearTimeout(e);
  return DS(() => n()), {
    registerTimeout: t,
    cancelTimeout: n
  };
}
const iC = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, Jxe = Symbol("elIdInjection"), Uq = () => ur() ? pt(Jxe, iC) : iC, dc = (e) => {
  const t = Uq();
  !zt && t === iC && Zt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = E3();
  return P(() => _(e) || `${n.value}-id-${t.prefix}-${t.current++}`);
};
let Nh = [];
const H4 = (e) => {
  const t = e;
  t.key === on.esc && Nh.forEach((n) => n(t));
}, Zxe = (e) => {
  Yt(() => {
    Nh.length === 0 && document.addEventListener("keydown", H4), zt && Nh.push(e);
  }), us(() => {
    Nh = Nh.filter((t) => t !== e), Nh.length === 0 && zt && document.removeEventListener("keydown", H4);
  });
};
let J4;
const qq = () => {
  const e = E3(), t = Uq(), n = P(() => `${e.value}-popper-container-${t.prefix}`), r = P(() => `#${n.value}`);
  return {
    id: n,
    selector: r
  };
}, Kxe = (e) => {
  const t = document.createElement("div");
  return t.id = e, document.body.appendChild(t), t;
}, Yxe = () => {
  const { id: e, selector: t } = qq();
  return $W(() => {
    zt && (process.env.NODE_ENV === "test" || !J4 && !document.body.querySelector(t.value)) && (J4 = Kxe(e.value));
  }), {
    id: e,
    selector: t
  };
}, Qxe = bt({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Xxe = ({
  showAfter: e,
  hideAfter: t,
  autoClose: n,
  open: r,
  close: i
}) => {
  const { registerTimeout: s } = W4(), {
    registerTimeout: o,
    cancelTimeout: a
  } = W4();
  return {
    onOpen: (p) => {
      s(() => {
        r(p);
        const f = _(n);
        yn(f) && f > 0 && o(() => {
          i(p);
        }, f);
      }, _(e));
    },
    onClose: (p) => {
      a(), s(() => {
        i(p);
      }, _(t));
    }
  };
}, Gq = Symbol("elForwardRef"), e$e = (e) => {
  _r(Gq, {
    setForwardRef: (n) => {
      e.value = n;
    }
  });
}, t$e = (e) => ({
  mounted(t) {
    e(t);
  },
  updated(t) {
    e(t);
  },
  unmounted() {
    e(null);
  }
}), Z4 = J(0), Wq = 2e3, Hq = Symbol("zIndexContextKey"), R3 = (e) => {
  const t = e || (ur() ? pt(Hq, void 0) : void 0), n = P(() => {
    const s = _(t);
    return yn(s) ? s : Wq;
  }), r = P(() => n.value + Z4.value);
  return {
    initialZIndex: n,
    currentZIndex: r,
    nextZIndex: () => (Z4.value++, r.value)
  };
};
function n$e(e) {
  const t = J();
  function n() {
    if (e.value == null)
      return;
    const { selectionStart: i, selectionEnd: s, value: o } = e.value;
    if (i == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, i)), l = o.slice(Math.max(0, s));
    t.value = {
      selectionStart: i,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function r() {
    if (e.value == null || t.value == null)
      return;
    const { value: i } = e.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = t.value;
    if (s == null || o == null || a == null)
      return;
    let l = i.length;
    if (i.endsWith(o))
      l = i.length - o.length;
    else if (i.startsWith(s))
      l = s.length;
    else {
      const c = s[a - 1], p = i.indexOf(c, a - 1);
      p !== -1 && (l = p + 1);
    }
    e.value.setSelectionRange(l, l);
  }
  return [n, r];
}
const _c = ZS({
  type: String,
  values: W0,
  required: !1
}), Jq = Symbol("size"), r$e = () => {
  const e = pt(Jq, {});
  return P(() => _(e.size) || "");
};
function i$e(e, { afterFocus: t, beforeBlur: n, afterBlur: r } = {}) {
  const i = ur(), { emit: s } = i, o = Vd(), a = J(!1), l = (f) => {
    a.value || (a.value = !0, s("focus", f), t == null || t());
  }, c = (f) => {
    var m;
    an(n) && n(f) || f.relatedTarget && ((m = o.value) != null && m.contains(f.relatedTarget)) || (a.value = !1, s("blur", f), r == null || r());
  }, p = () => {
    var f;
    (f = e.value) == null || f.focus();
  };
  return Ie(o, (f) => {
    f && f.setAttribute("tabindex", "-1");
  }), Il(o, "click", p), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: c
  };
}
const Zq = Symbol(), T_ = J();
function XS(e, t = void 0) {
  const n = ur() ? pt(Zq, T_) : T_;
  return e ? P(() => {
    var r, i;
    return (i = (r = n.value) == null ? void 0 : r[e]) != null ? i : t;
  }) : n;
}
function L3(e, t) {
  const n = XS(), r = tt(e, P(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.namespace) || gg;
  })), i = Dp(P(() => {
    var a;
    return (a = n.value) == null ? void 0 : a.locale;
  })), s = R3(P(() => {
    var a;
    return ((a = n.value) == null ? void 0 : a.zIndex) || Wq;
  })), o = P(() => {
    var a;
    return _(t) || ((a = n.value) == null ? void 0 : a.size) || "";
  });
  return Kq(P(() => _(n) || {})), {
    ns: r,
    locale: i,
    zIndex: s,
    size: o
  };
}
const Kq = (e, t, n = !1) => {
  var r;
  const i = !!ur(), s = i ? XS() : void 0, o = (r = t == null ? void 0 : t.provide) != null ? r : i ? _r : void 0;
  if (!o) {
    Zt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = P(() => {
    const l = _(e);
    return s != null && s.value ? s$e(s.value, l) : l;
  });
  return o(Zq, a), o(Mq, P(() => a.value.locale)), o(kq, P(() => a.value.namespace)), o(Hq, P(() => a.value.zIndex)), o(Jq, {
    size: P(() => a.value.size || "")
  }), (n || !T_.value) && (T_.value = a.value), a;
}, s$e = (e, t) => {
  var n;
  const r = [.../* @__PURE__ */ new Set([...M4(e), ...M4(t)])], i = {};
  for (const s of r)
    i[s] = (n = t[s]) != null ? n : e[s];
  return i;
}, o$e = bt({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: Be(Object)
  },
  size: _c,
  button: {
    type: Be(Object)
  },
  experimentalFeatures: {
    type: Be(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: Be(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}), sC = {};
fe({
  name: "ElConfigProvider",
  props: o$e,
  setup(e, { slots: t }) {
    Ie(() => e.message, (r) => {
      Object.assign(sC, r ?? {});
    }, { immediate: !0, deep: !0 });
    const n = Kq(e);
    return () => je(t, "default", { config: n == null ? void 0 : n.value });
  }
});
var at = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
};
const a$e = bt({
  size: {
    type: Be([Number, String])
  },
  color: {
    type: String
  }
}), l$e = fe({
  name: "ElIcon",
  inheritAttrs: !1
}), u$e = /* @__PURE__ */ fe({
  ...l$e,
  props: a$e,
  setup(e) {
    const t = e, n = tt("icon"), r = P(() => {
      const { size: i, color: s } = t;
      return !i && !s ? {} : {
        fontSize: Cf(i) ? void 0 : Rl(i),
        "--color": s
      };
    });
    return (i, s) => (F(), X("i", ga({
      class: _(n).b(),
      style: _(r)
    }, i.$attrs), [
      je(i.$slots, "default")
    ], 16));
  }
});
var c$e = /* @__PURE__ */ at(u$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const Ht = Ai(c$e), am = Symbol("formContextKey"), bp = Symbol("formItemContextKey"), Do = (e, t = {}) => {
  const n = J(void 0), r = t.prop ? n : Pq("size"), i = t.global ? n : r$e(), s = t.form ? { size: void 0 } : pt(am, void 0), o = t.formItem ? { size: void 0 } : pt(bp, void 0);
  return P(() => r.value || _(e) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "");
}, lm = (e) => {
  const t = Pq("disabled"), n = pt(am, void 0);
  return P(() => t.value || _(e) || (n == null ? void 0 : n.disabled) || !1);
}, jl = () => {
  const e = pt(am, void 0), t = pt(bp, void 0);
  return {
    form: e,
    formItem: t
  };
}, Z0 = (e, {
  formItemContext: t,
  disableIdGeneration: n,
  disableIdManagement: r
}) => {
  n || (n = J(!1)), r || (r = J(!1));
  const i = J();
  let s;
  const o = P(() => {
    var a;
    return !!(!e.label && t && t.inputIds && ((a = t.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return Yt(() => {
    s = Ie([$o(e, "id"), n], ([a, l]) => {
      const c = a ?? (l ? void 0 : dc().value);
      c !== i.value && (t != null && t.removeInputId && (i.value && t.removeInputId(i.value), !(r != null && r.value) && !l && c && t.addInputId(c)), i.value = c);
    }, { immediate: !0 });
  }), TW(() => {
    s && s(), t != null && t.removeInputId && i.value && t.removeInputId(i.value);
  }), {
    isLabeledByFormItem: o,
    inputId: i
  };
}, d$e = bt({
  size: {
    type: String,
    values: W0
  },
  disabled: Boolean
}), p$e = bt({
  ...d$e,
  model: Object,
  rules: {
    type: Be(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
}), h$e = {
  validate: (e, t, n) => (Pl(e) || ln(e)) && Qr(t) && ln(n)
}, f$e = "ElForm";
function m$e() {
  const e = J([]), t = P(() => {
    if (!e.value.length)
      return "0";
    const s = Math.max(...e.value);
    return s ? `${s}px` : "";
  });
  function n(s) {
    const o = e.value.indexOf(s);
    return o === -1 && t.value === "0" && Zt(f$e, `unexpected width ${s}`), o;
  }
  function r(s, o) {
    if (s && o) {
      const a = n(o);
      e.value.splice(a, 1, s);
    } else
      s && e.value.push(s);
  }
  function i(s) {
    const o = n(s);
    o > -1 && e.value.splice(o, 1);
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: r,
    deregisterLabelWidth: i
  };
}
const sb = (e, t) => {
  const n = WM(t);
  return n.length > 0 ? e.filter((r) => r.prop && n.includes(r.prop)) : e;
}, zw = "ElForm", y$e = fe({
  name: zw
}), g$e = /* @__PURE__ */ fe({
  ...y$e,
  props: p$e,
  emits: h$e,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = [], s = Do(), o = tt("form"), a = P(() => {
      const { labelPosition: S, inline: $ } = r;
      return [
        o.b(),
        o.m(s.value || "default"),
        {
          [o.m(`label-${S}`)]: S,
          [o.m("inline")]: $
        }
      ];
    }), l = (S) => {
      i.push(S);
    }, c = (S) => {
      S.prop && i.splice(i.indexOf(S), 1);
    }, p = (S = []) => {
      if (!r.model) {
        Zt(zw, "model is required for resetFields to work.");
        return;
      }
      sb(i, S).forEach(($) => $.resetField());
    }, f = (S = []) => {
      sb(i, S).forEach(($) => $.clearValidate());
    }, m = P(() => {
      const S = !!r.model;
      return S || Zt(zw, "model is required for validate to work."), S;
    }), y = (S) => {
      if (i.length === 0)
        return [];
      const $ = sb(i, S);
      return $.length ? $ : (Zt(zw, "please pass correct props!"), []);
    }, g = async (S) => w(void 0, S), v = async (S = []) => {
      if (!m.value)
        return !1;
      const $ = y(S);
      if ($.length === 0)
        return !0;
      let I = {};
      for (const M of $)
        try {
          await M.validate("");
        } catch (E) {
          I = {
            ...I,
            ...E
          };
        }
      return Object.keys(I).length === 0 ? !0 : Promise.reject(I);
    }, w = async (S = [], $) => {
      const I = !an($);
      try {
        const M = await v(S);
        return M === !0 && ($ == null || $(M)), M;
      } catch (M) {
        if (M instanceof Error)
          throw M;
        const E = M;
        return r.scrollToError && b(Object.keys(E)[0]), $ == null || $(!1, E), I && Promise.reject(E);
      }
    }, b = (S) => {
      var $;
      const I = sb(i, S)[0];
      I && (($ = I.$el) == null || $.scrollIntoView(r.scrollIntoViewOptions));
    };
    return Ie(() => r.rules, () => {
      r.validateOnRuleChange && g().catch((S) => Zt(S));
    }, { deep: !0 }), _r(am, is({
      ...hc(r),
      emit: n,
      resetFields: p,
      clearValidate: f,
      validateField: w,
      addField: l,
      removeField: c,
      ...m$e()
    })), t({
      validate: g,
      validateField: w,
      resetFields: p,
      clearValidate: f,
      scrollToField: b
    }), (S, $) => (F(), X("form", {
      class: Z(_(a))
    }, [
      je(S.$slots, "default")
    ], 2));
  }
});
var v$e = /* @__PURE__ */ at(g$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
function Nd() {
  return Nd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nd.apply(this, arguments);
}
function b$e(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, a0(e, t);
}
function oC(e) {
  return oC = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, oC(e);
}
function a0(e, t) {
  return a0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, a0(e, t);
}
function w$e() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Bw(e, t, n) {
  return w$e() ? Bw = Reflect.construct.bind() : Bw = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), c = new l();
    return o && a0(c, o.prototype), c;
  }, Bw.apply(null, arguments);
}
function _$e(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function aC(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return aC = function(r) {
    if (r === null || !_$e(r))
      return r;
    if (typeof r != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(r))
        return t.get(r);
      t.set(r, i);
    }
    function i() {
      return Bw(r, arguments, oC(this).constructor);
    }
    return i.prototype = Object.create(r.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), a0(i, r);
  }, aC(e);
}
var S$e = /%[sdj%]/g, Yq = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (Yq = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(r) {
    return typeof r == "string";
  }) && console.warn(t, n);
});
function lC(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var r = n.field;
    t[r] = t[r] || [], t[r].push(n);
  }), t;
}
function Qi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var i = 0, s = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var o = e.replace(S$e, function(a) {
      if (a === "%%")
        return "%";
      if (i >= s)
        return a;
      switch (a) {
        case "%s":
          return String(n[i++]);
        case "%d":
          return Number(n[i++]);
        case "%j":
          try {
            return JSON.stringify(n[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return o;
  }
  return e;
}
function x$e(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function er(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || x$e(t) && typeof e == "string" && !e);
}
function $$e(e, t, n) {
  var r = [], i = 0, s = e.length;
  function o(a) {
    r.push.apply(r, a || []), i++, i === s && n(r);
  }
  e.forEach(function(a) {
    t(a, o);
  });
}
function K4(e, t, n) {
  var r = 0, i = e.length;
  function s(o) {
    if (o && o.length) {
      n(o);
      return;
    }
    var a = r;
    r = r + 1, a < i ? t(e[a], s) : n([]);
  }
  s([]);
}
function T$e(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var Y4 = /* @__PURE__ */ function(e) {
  b$e(t, e);
  function t(n, r) {
    var i;
    return i = e.call(this, "Async Validation Error") || this, i.errors = n, i.fields = r, i;
  }
  return t;
}(/* @__PURE__ */ aC(Error));
function E$e(e, t, n, r, i) {
  if (t.first) {
    var s = new Promise(function(m, y) {
      var g = function(b) {
        return r(b), b.length ? y(new Y4(b, lC(b))) : m(i);
      }, v = T$e(e);
      K4(v, n, g);
    });
    return s.catch(function(m) {
      return m;
    }), s;
  }
  var o = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], a = Object.keys(e), l = a.length, c = 0, p = [], f = new Promise(function(m, y) {
    var g = function(w) {
      if (p.push.apply(p, w), c++, c === l)
        return r(p), p.length ? y(new Y4(p, lC(p))) : m(i);
    };
    a.length || (r(p), m(i)), a.forEach(function(v) {
      var w = e[v];
      o.indexOf(v) !== -1 ? K4(w, n, g) : $$e(w, n, g);
    });
  });
  return f.catch(function(m) {
    return m;
  }), f;
}
function I$e(e) {
  return !!(e && e.message !== void 0);
}
function M$e(e, t) {
  for (var n = e, r = 0; r < t.length; r++) {
    if (n == null)
      return n;
    n = n[t[r]];
  }
  return n;
}
function Q4(e, t) {
  return function(n) {
    var r;
    return e.fullFields ? r = M$e(t, e.fullFields) : r = t[n.field || e.fullField], I$e(n) ? (n.field = n.field || e.fullField, n.fieldValue = r, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: r,
      field: n.field || e.fullField
    };
  };
}
function X4(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var r = t[n];
        typeof r == "object" && typeof e[n] == "object" ? e[n] = Nd({}, e[n], r) : e[n] = r;
      }
  }
  return e;
}
var Qq = function(t, n, r, i, s, o) {
  t.required && (!r.hasOwnProperty(t.field) || er(n, o || t.type)) && i.push(Qi(s.messages.required, t.fullField));
}, C$e = function(t, n, r, i, s) {
  (/^\s+$/.test(n) || n === "") && i.push(Qi(s.messages.whitespace, t.fullField));
}, ob, O$e = function() {
  if (ob)
    return ob;
  var e = "[a-fA-F\\d:]", t = function(I) {
    return I && I.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", r = "[a-fA-F\\d]{1,4}", i = (`
(?:
(?:` + r + ":){7}(?:" + r + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + r + ":){6}(?:" + n + "|:" + r + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + r + ":){5}(?::" + n + "|(?::" + r + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + r + ":){4}(?:(?::" + r + "){0,1}:" + n + "|(?::" + r + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + r + ":){3}(?:(?::" + r + "){0,2}:" + n + "|(?::" + r + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + r + ":){2}(?:(?::" + r + "){0,3}:" + n + "|(?::" + r + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + r + ":){1}(?:(?::" + r + "){0,4}:" + n + "|(?::" + r + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + r + "){0,5}:" + n + "|(?::" + r + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), s = new RegExp("(?:^" + n + "$)|(?:^" + i + "$)"), o = new RegExp("^" + n + "$"), a = new RegExp("^" + i + "$"), l = function(I) {
    return I && I.exact ? s : new RegExp("(?:" + t(I) + n + t(I) + ")|(?:" + t(I) + i + t(I) + ")", "g");
  };
  l.v4 = function($) {
    return $ && $.exact ? o : new RegExp("" + t($) + n + t($), "g");
  }, l.v6 = function($) {
    return $ && $.exact ? a : new RegExp("" + t($) + i + t($), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", p = "(?:\\S+(?::\\S*)?@)?", f = l.v4().source, m = l.v6().source, y = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", g = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", v = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", w = "(?::\\d{2,5})?", b = '(?:[/?#][^\\s"]*)?', S = "(?:" + c + "|www\\.)" + p + "(?:localhost|" + f + "|" + m + "|" + y + g + v + ")" + w + b;
  return ob = new RegExp("(?:^" + S + "$)", "i"), ob;
}, e5 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Wy = {
  integer: function(t) {
    return Wy.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Wy.number(t) && !Wy.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !Wy.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(e5.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(O$e());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(e5.hex);
  }
}, k$e = function(t, n, r, i, s) {
  if (t.required && n === void 0) {
    Qq(t, n, r, i, s);
    return;
  }
  var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = t.type;
  o.indexOf(a) > -1 ? Wy[a](n) || i.push(Qi(s.messages.types[a], t.fullField, t.type)) : a && typeof n !== t.type && i.push(Qi(s.messages.types[a], t.fullField, t.type));
}, A$e = function(t, n, r, i, s) {
  var o = typeof t.len == "number", a = typeof t.min == "number", l = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, p = n, f = null, m = typeof n == "number", y = typeof n == "string", g = Array.isArray(n);
  if (m ? f = "number" : y ? f = "string" : g && (f = "array"), !f)
    return !1;
  g && (p = n.length), y && (p = n.replace(c, "_").length), o ? p !== t.len && i.push(Qi(s.messages[f].len, t.fullField, t.len)) : a && !l && p < t.min ? i.push(Qi(s.messages[f].min, t.fullField, t.min)) : l && !a && p > t.max ? i.push(Qi(s.messages[f].max, t.fullField, t.max)) : a && l && (p < t.min || p > t.max) && i.push(Qi(s.messages[f].range, t.fullField, t.min, t.max));
}, Zp = "enum", P$e = function(t, n, r, i, s) {
  t[Zp] = Array.isArray(t[Zp]) ? t[Zp] : [], t[Zp].indexOf(n) === -1 && i.push(Qi(s.messages[Zp], t.fullField, t[Zp].join(", ")));
}, R$e = function(t, n, r, i, s) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || i.push(Qi(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var o = new RegExp(t.pattern);
      o.test(n) || i.push(Qi(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, ft = {
  required: Qq,
  whitespace: C$e,
  type: k$e,
  range: A$e,
  enum: P$e,
  pattern: R$e
}, L$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n, "string") && !t.required)
      return r();
    ft.required(t, n, i, o, s, "string"), er(n, "string") || (ft.type(t, n, i, o, s), ft.range(t, n, i, o, s), ft.pattern(t, n, i, o, s), t.whitespace === !0 && ft.whitespace(t, n, i, o, s));
  }
  r(o);
}, F$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && ft.type(t, n, i, o, s);
  }
  r(o);
}, N$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (n === "" && (n = void 0), er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && (ft.type(t, n, i, o, s), ft.range(t, n, i, o, s));
  }
  r(o);
}, D$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && ft.type(t, n, i, o, s);
  }
  r(o);
}, j$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), er(n) || ft.type(t, n, i, o, s);
  }
  r(o);
}, V$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && (ft.type(t, n, i, o, s), ft.range(t, n, i, o, s));
  }
  r(o);
}, z$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && (ft.type(t, n, i, o, s), ft.range(t, n, i, o, s));
  }
  r(o);
}, B$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (n == null && !t.required)
      return r();
    ft.required(t, n, i, o, s, "array"), n != null && (ft.type(t, n, i, o, s), ft.range(t, n, i, o, s));
  }
  r(o);
}, U$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && ft.type(t, n, i, o, s);
  }
  r(o);
}, q$e = "enum", G$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s), n !== void 0 && ft[q$e](t, n, i, o, s);
  }
  r(o);
}, W$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n, "string") && !t.required)
      return r();
    ft.required(t, n, i, o, s), er(n, "string") || ft.pattern(t, n, i, o, s);
  }
  r(o);
}, H$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n, "date") && !t.required)
      return r();
    if (ft.required(t, n, i, o, s), !er(n, "date")) {
      var l;
      n instanceof Date ? l = n : l = new Date(n), ft.type(t, l, i, o, s), l && ft.range(t, l.getTime(), i, o, s);
    }
  }
  r(o);
}, J$e = function(t, n, r, i, s) {
  var o = [], a = Array.isArray(n) ? "array" : typeof n;
  ft.required(t, n, i, o, s, a), r(o);
}, i$ = function(t, n, r, i, s) {
  var o = t.type, a = [], l = t.required || !t.required && i.hasOwnProperty(t.field);
  if (l) {
    if (er(n, o) && !t.required)
      return r();
    ft.required(t, n, i, a, s, o), er(n, o) || ft.type(t, n, i, a, s);
  }
  r(a);
}, Z$e = function(t, n, r, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (er(n) && !t.required)
      return r();
    ft.required(t, n, i, o, s);
  }
  r(o);
}, wg = {
  string: L$e,
  method: F$e,
  number: N$e,
  boolean: D$e,
  regexp: j$e,
  integer: V$e,
  float: z$e,
  array: B$e,
  object: U$e,
  enum: G$e,
  pattern: W$e,
  date: H$e,
  url: i$,
  hex: i$,
  email: i$,
  required: J$e,
  any: Z$e
};
function uC() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var cC = uC(), K0 = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = cC, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(r) {
    var i = this;
    if (!r)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof r != "object" || Array.isArray(r))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(r).forEach(function(s) {
      var o = r[s];
      i.rules[s] = Array.isArray(o) ? o : [o];
    });
  }, t.messages = function(r) {
    return r && (this._messages = X4(uC(), r)), this._messages;
  }, t.validate = function(r, i, s) {
    var o = this;
    i === void 0 && (i = {}), s === void 0 && (s = function() {
    });
    var a = r, l = i, c = s;
    if (typeof l == "function" && (c = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, a), Promise.resolve(a);
    function p(v) {
      var w = [], b = {};
      function S(I) {
        if (Array.isArray(I)) {
          var M;
          w = (M = w).concat.apply(M, I);
        } else
          w.push(I);
      }
      for (var $ = 0; $ < v.length; $++)
        S(v[$]);
      w.length ? (b = lC(w), c(w, b)) : c(null, a);
    }
    if (l.messages) {
      var f = this.messages();
      f === cC && (f = uC()), X4(f, l.messages), l.messages = f;
    } else
      l.messages = this.messages();
    var m = {}, y = l.keys || Object.keys(this.rules);
    y.forEach(function(v) {
      var w = o.rules[v], b = a[v];
      w.forEach(function(S) {
        var $ = S;
        typeof $.transform == "function" && (a === r && (a = Nd({}, a)), b = a[v] = $.transform(b)), typeof $ == "function" ? $ = {
          validator: $
        } : $ = Nd({}, $), $.validator = o.getValidationMethod($), $.validator && ($.field = v, $.fullField = $.fullField || v, $.type = o.getType($), m[v] = m[v] || [], m[v].push({
          rule: $,
          value: b,
          source: a,
          field: v
        }));
      });
    });
    var g = {};
    return E$e(m, l, function(v, w) {
      var b = v.rule, S = (b.type === "object" || b.type === "array") && (typeof b.fields == "object" || typeof b.defaultField == "object");
      S = S && (b.required || !b.required && v.value), b.field = v.field;
      function $(E, C) {
        return Nd({}, C, {
          fullField: b.fullField + "." + E,
          fullFields: b.fullFields ? [].concat(b.fullFields, [E]) : [E]
        });
      }
      function I(E) {
        E === void 0 && (E = []);
        var C = Array.isArray(E) ? E : [E];
        !l.suppressWarning && C.length && e.warning("async-validator:", C), C.length && b.message !== void 0 && (C = [].concat(b.message));
        var A = C.map(Q4(b, a));
        if (l.first && A.length)
          return g[b.field] = 1, w(A);
        if (!S)
          w(A);
        else {
          if (b.required && !v.value)
            return b.message !== void 0 ? A = [].concat(b.message).map(Q4(b, a)) : l.error && (A = [l.error(b, Qi(l.messages.required, b.field))]), w(A);
          var W = {};
          b.defaultField && Object.keys(v.value).map(function(R) {
            W[R] = b.defaultField;
          }), W = Nd({}, W, v.rule.fields);
          var j = {};
          Object.keys(W).forEach(function(R) {
            var V = W[R], Q = Array.isArray(V) ? V : [V];
            j[R] = Q.map($.bind(null, R));
          });
          var G = new e(j);
          G.messages(l.messages), v.rule.options && (v.rule.options.messages = l.messages, v.rule.options.error = l.error), G.validate(v.value, v.rule.options || l, function(R) {
            var V = [];
            A && A.length && V.push.apply(V, A), R && R.length && V.push.apply(V, R), w(V.length ? V : null);
          });
        }
      }
      var M;
      if (b.asyncValidator)
        M = b.asyncValidator(b, v.value, I, v.source, l);
      else if (b.validator) {
        try {
          M = b.validator(b, v.value, I, v.source, l);
        } catch (E) {
          console.error == null || console.error(E), l.suppressValidatorError || setTimeout(function() {
            throw E;
          }, 0), I(E.message);
        }
        M === !0 ? I() : M === !1 ? I(typeof b.message == "function" ? b.message(b.fullField || b.field) : b.message || (b.fullField || b.field) + " fails") : M instanceof Array ? I(M) : M instanceof Error && I(M.message);
      }
      M && M.then && M.then(function() {
        return I();
      }, function(E) {
        return I(E);
      });
    }, function(v) {
      p(v);
    }, a);
  }, t.getType = function(r) {
    if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !wg.hasOwnProperty(r.type))
      throw new Error(Qi("Unknown rule type %s", r.type));
    return r.type || "string";
  }, t.getValidationMethod = function(r) {
    if (typeof r.validator == "function")
      return r.validator;
    var i = Object.keys(r), s = i.indexOf("message");
    return s !== -1 && i.splice(s, 1), i.length === 1 && i[0] === "required" ? wg.required : wg[this.getType(r)] || void 0;
  }, e;
}();
K0.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  wg[t] = n;
};
K0.warning = Yq;
K0.messages = cC;
K0.validators = wg;
const K$e = [
  "",
  "error",
  "validating",
  "success"
], Y$e = bt({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: Be([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: Be([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: K$e
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: W0
  }
}), t5 = "ElLabelWrap";
var Q$e = fe({
  name: t5,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e, {
    slots: t
  }) {
    const n = pt(am, void 0), r = pt(bp);
    r || HS(t5, "usage: <el-form-item><label-wrap /></el-form-item>");
    const i = tt("form"), s = J(), o = J(0), a = () => {
      var p;
      if ((p = s.value) != null && p.firstElementChild) {
        const f = window.getComputedStyle(s.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(f));
      } else
        return 0;
    }, l = (p = "update") => {
      rt(() => {
        t.default && e.isAutoWidth && (p === "update" ? o.value = a() : p === "remove" && (n == null || n.deregisterLabelWidth(o.value)));
      });
    }, c = () => l("update");
    return Yt(() => {
      c();
    }), us(() => {
      l("remove");
    }), J5(() => c()), Ie(o, (p, f) => {
      e.updateAll && (n == null || n.registerLabelWidth(p, f));
    }), Lp(P(() => {
      var p, f;
      return (f = (p = s.value) == null ? void 0 : p.firstElementChild) != null ? f : null;
    }), c), () => {
      var p, f;
      if (!t)
        return null;
      const {
        isAutoWidth: m
      } = e;
      if (m) {
        const y = n == null ? void 0 : n.autoLabelWidth, g = r == null ? void 0 : r.hasLabel, v = {};
        if (g && y && y !== "auto") {
          const w = Math.max(0, Number.parseInt(y, 10) - o.value), b = n.labelPosition === "left" ? "marginRight" : "marginLeft";
          w && (v[b] = `${w}px`);
        }
        return ye("div", {
          ref: s,
          class: [i.be("item", "label-wrap")],
          style: v
        }, [(p = t.default) == null ? void 0 : p.call(t)]);
      } else
        return ye(Ft, {
          ref: s
        }, [(f = t.default) == null ? void 0 : f.call(t)]);
    };
  }
});
const X$e = ["role", "aria-labelledby"], eTe = fe({
  name: "ElFormItem"
}), tTe = /* @__PURE__ */ fe({
  ...eTe,
  props: Y$e,
  setup(e, { expose: t }) {
    const n = e, r = Nf(), i = pt(am, void 0), s = pt(bp, void 0), o = Do(void 0, { formItem: !1 }), a = tt("form-item"), l = dc().value, c = J([]), p = J(""), f = N0e(p, 100), m = J(""), y = J();
    let g, v = !1;
    const w = P(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top")
        return {};
      const Me = Rl(n.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return Me ? { width: Me } : {};
    }), b = P(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top" || i != null && i.inline)
        return {};
      if (!n.label && !n.labelWidth && W)
        return {};
      const Me = Rl(n.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return !n.label && !r.label ? { marginLeft: Me } : {};
    }), S = P(() => [
      a.b(),
      a.m(o.value),
      a.is("error", p.value === "error"),
      a.is("validating", p.value === "validating"),
      a.is("success", p.value === "success"),
      a.is("required", Q.value || n.required),
      a.is("no-asterisk", i == null ? void 0 : i.hideRequiredAsterisk),
      (i == null ? void 0 : i.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [a.m("feedback")]: i == null ? void 0 : i.statusIcon }
    ]), $ = P(() => Qr(n.inlineMessage) ? n.inlineMessage : (i == null ? void 0 : i.inlineMessage) || !1), I = P(() => [
      a.e("error"),
      { [a.em("error", "inline")]: $.value }
    ]), M = P(() => n.prop ? ln(n.prop) ? n.prop : n.prop.join(".") : ""), E = P(() => !!(n.label || r.label)), C = P(() => n.for || (c.value.length === 1 ? c.value[0] : void 0)), A = P(() => !C.value && E.value), W = !!s, j = P(() => {
      const Me = i == null ? void 0 : i.model;
      if (!(!Me || !n.prop))
        return r$(Me, n.prop).value;
    }), G = P(() => {
      const { required: Me } = n, Ue = [];
      n.rules && Ue.push(...WM(n.rules));
      const Xe = i == null ? void 0 : i.rules;
      if (Xe && n.prop) {
        const lt = r$(Xe, n.prop).value;
        lt && Ue.push(...WM(lt));
      }
      if (Me !== void 0) {
        const lt = Ue.map((Tt, bn) => [Tt, bn]).filter(([Tt]) => Object.keys(Tt).includes("required"));
        if (lt.length > 0)
          for (const [Tt, bn] of lt)
            Tt.required !== Me && (Ue[bn] = { ...Tt, required: Me });
        else
          Ue.push({ required: Me });
      }
      return Ue;
    }), R = P(() => G.value.length > 0), V = (Me) => G.value.filter((Xe) => !Xe.trigger || !Me ? !0 : Array.isArray(Xe.trigger) ? Xe.trigger.includes(Me) : Xe.trigger === Me).map(({ trigger: Xe, ...lt }) => lt), Q = P(() => G.value.some((Me) => Me.required)), de = P(() => {
      var Me;
      return f.value === "error" && n.showMessage && ((Me = i == null ? void 0 : i.showMessage) != null ? Me : !0);
    }), _e = P(() => `${n.label || ""}${(i == null ? void 0 : i.labelSuffix) || ""}`), ie = (Me) => {
      p.value = Me;
    }, Ae = (Me) => {
      var Ue, Xe;
      const { errors: lt, fields: Tt } = Me;
      (!lt || !Tt) && console.error(Me), ie("error"), m.value = lt ? (Xe = (Ue = lt == null ? void 0 : lt[0]) == null ? void 0 : Ue.message) != null ? Xe : `${n.prop} is required` : "", i == null || i.emit("validate", n.prop, !1, m.value);
    }, Pe = () => {
      ie("success"), i == null || i.emit("validate", n.prop, !0, "");
    }, Bt = async (Me) => {
      const Ue = M.value;
      return new K0({
        [Ue]: Me
      }).validate({ [Ue]: j.value }, { firstFields: !0 }).then(() => (Pe(), !0)).catch((lt) => (Ae(lt), Promise.reject(lt)));
    }, wt = async (Me, Ue) => {
      if (v || !n.prop)
        return !1;
      const Xe = an(Ue);
      if (!R.value)
        return Ue == null || Ue(!1), !1;
      const lt = V(Me);
      return lt.length === 0 ? (Ue == null || Ue(!0), !0) : (ie("validating"), Bt(lt).then(() => (Ue == null || Ue(!0), !0)).catch((Tt) => {
        const { fields: bn } = Tt;
        return Ue == null || Ue(!1, bn), Xe ? !1 : Promise.reject(bn);
      }));
    }, Ut = () => {
      ie(""), m.value = "", v = !1;
    }, un = async () => {
      const Me = i == null ? void 0 : i.model;
      if (!Me || !n.prop)
        return;
      const Ue = r$(Me, n.prop);
      v = !0, Ue.value = S4(g), await rt(), Ut(), v = !1;
    }, An = (Me) => {
      c.value.includes(Me) || c.value.push(Me);
    }, Pn = (Me) => {
      c.value = c.value.filter((Ue) => Ue !== Me);
    };
    Ie(() => n.error, (Me) => {
      m.value = Me || "", ie(Me ? "error" : "");
    }, { immediate: !0 }), Ie(() => n.validateStatus, (Me) => ie(Me || ""));
    const Un = is({
      ...hc(n),
      $el: y,
      size: o,
      validateState: p,
      labelId: l,
      inputIds: c,
      isGroup: A,
      hasLabel: E,
      addInputId: An,
      removeInputId: Pn,
      resetField: un,
      clearValidate: Ut,
      validate: wt
    });
    return _r(bp, Un), Yt(() => {
      n.prop && (i == null || i.addField(Un), g = S4(j.value));
    }), us(() => {
      i == null || i.removeField(Un);
    }), t({
      size: o,
      validateMessage: m,
      validateState: p,
      validate: wt,
      clearValidate: Ut,
      resetField: un
    }), (Me, Ue) => {
      var Xe;
      return F(), X("div", {
        ref_key: "formItemRef",
        ref: y,
        class: Z(_(S)),
        role: _(A) ? "group" : void 0,
        "aria-labelledby": _(A) ? _(l) : void 0
      }, [
        ye(_(Q$e), {
          "is-auto-width": _(w).width === "auto",
          "update-all": ((Xe = _(i)) == null ? void 0 : Xe.labelWidth) === "auto"
        }, {
          default: te(() => [
            _(E) ? (F(), ce(Mn(_(C) ? "label" : "div"), {
              key: 0,
              id: _(l),
              for: _(C),
              class: Z(_(a).e("label")),
              style: It(_(w))
            }, {
              default: te(() => [
                je(Me.$slots, "label", { label: _(_e) }, () => [
                  Kn(it(_(_e)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : he("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        ee("div", {
          class: Z(_(a).e("content")),
          style: It(_(b))
        }, [
          je(Me.$slots, "default"),
          ye(EW, {
            name: `${_(a).namespace.value}-zoom-in-top`
          }, {
            default: te(() => [
              _(de) ? je(Me.$slots, "error", {
                key: 0,
                error: m.value
              }, () => [
                ee("div", {
                  class: Z(_(I))
                }, it(m.value), 3)
              ]) : he("v-if", !0)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, X$e);
    };
  }
});
var Xq = /* @__PURE__ */ at(tTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
const nTe = Ai(v$e, {
  FormItem: Xq
}), ro = bc(Xq);
let io;
const rTe = `
  height:0 !important;
  visibility:hidden !important;
  ${K0e() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, iTe = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function sTe(e) {
  const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), r = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), i = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
  return { contextStyle: iTe.map((o) => `${o}:${t.getPropertyValue(o)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: n };
}
function n5(e, t = 1, n) {
  var r;
  io || (io = document.createElement("textarea"), document.body.appendChild(io));
  const { paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a } = sTe(e);
  io.setAttribute("style", `${a};${rTe}`), io.value = e.value || e.placeholder || "";
  let l = io.scrollHeight;
  const c = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - i), io.value = "";
  const p = io.scrollHeight - i;
  if (yn(t)) {
    let f = p * t;
    o === "border-box" && (f = f + i + s), l = Math.max(f, l), c.minHeight = `${f}px`;
  }
  if (yn(n)) {
    let f = p * n;
    o === "border-box" && (f = f + i + s), l = Math.min(f, l);
  }
  return c.height = `${l}px`, (r = io.parentNode) == null || r.removeChild(io), io = void 0, c;
}
const oTe = bt({
  id: {
    type: String,
    default: void 0
  },
  size: _c,
  disabled: Boolean,
  modelValue: {
    type: Be([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Be([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: Yi
  },
  prefixIcon: {
    type: Yi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Be([Object, Array, String]),
    default: () => Iq({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), aTe = {
  [jt]: (e) => ln(e),
  input: (e) => ln(e),
  change: (e) => ln(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (e) => e instanceof MouseEvent,
  mouseenter: (e) => e instanceof MouseEvent,
  keydown: (e) => e instanceof Event,
  compositionstart: (e) => e instanceof CompositionEvent,
  compositionupdate: (e) => e instanceof CompositionEvent,
  compositionend: (e) => e instanceof CompositionEvent
}, lTe = ["role"], uTe = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], cTe = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], dTe = fe({
  name: "ElInput",
  inheritAttrs: !1
}), pTe = /* @__PURE__ */ fe({
  ...dTe,
  props: oTe,
  emits: aTe,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = Z5(), s = Nf(), o = P(() => {
      const pe = {};
      return r.containerRole === "combobox" && (pe["aria-haspopup"] = i["aria-haspopup"], pe["aria-owns"] = i["aria-owns"], pe["aria-expanded"] = i["aria-expanded"]), pe;
    }), a = P(() => [
      r.type === "textarea" ? w.b() : v.b(),
      v.m(y.value),
      v.is("disabled", g.value),
      v.is("exceed", An.value),
      {
        [v.b("group")]: s.prepend || s.append,
        [v.bm("group", "append")]: s.append,
        [v.bm("group", "prepend")]: s.prepend,
        [v.m("prefix")]: s.prefix || r.prefixIcon,
        [v.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
        [v.bm("suffix", "password-clear")]: Bt.value && wt.value
      },
      i.class
    ]), l = P(() => [
      v.e("wrapper"),
      v.is("focus", j.value)
    ]), c = _2e({
      excludeKeys: P(() => Object.keys(o.value))
    }), { form: p, formItem: f } = jl(), { inputId: m } = Z0(r, {
      formItemContext: f
    }), y = Do(), g = lm(), v = tt("input"), w = tt("textarea"), b = Vd(), S = Vd(), $ = J(!1), I = J(!1), M = J(!1), E = J(), C = Vd(r.inputStyle), A = P(() => b.value || S.value), { wrapperRef: W, isFocused: j, handleFocus: G, handleBlur: R } = i$e(A, {
      afterBlur() {
        var pe;
        r.validateEvent && ((pe = f == null ? void 0 : f.validate) == null || pe.call(f, "blur").catch((qe) => Zt(qe)));
      }
    }), V = P(() => {
      var pe;
      return (pe = p == null ? void 0 : p.statusIcon) != null ? pe : !1;
    }), Q = P(() => (f == null ? void 0 : f.validateState) || ""), de = P(() => Q.value && $q[Q.value]), _e = P(() => M.value ? d2e : o2e), ie = P(() => [
      i.style,
      r.inputStyle
    ]), Ae = P(() => [
      r.inputStyle,
      C.value,
      { resize: r.resize }
    ]), Pe = P(() => q0(r.modelValue) ? "" : String(r.modelValue)), Bt = P(() => r.clearable && !g.value && !r.readonly && !!Pe.value && (j.value || $.value)), wt = P(() => r.showPassword && !g.value && !r.readonly && !!Pe.value && (!!Pe.value || j.value)), Ut = P(() => r.showWordLimit && !!c.value.maxlength && (r.type === "text" || r.type === "textarea") && !g.value && !r.readonly && !r.showPassword), un = P(() => Pe.value.length), An = P(() => !!Ut.value && un.value > Number(c.value.maxlength)), Pn = P(() => !!s.suffix || !!r.suffixIcon || Bt.value || r.showPassword || Ut.value || !!Q.value && V.value), [Un, Me] = n$e(b);
    Lp(S, (pe) => {
      if (lt(), !Ut.value || r.resize !== "both")
        return;
      const qe = pe[0], { width: ht } = qe.contentRect;
      E.value = {
        right: `calc(100% - ${ht + 15 + 6}px)`
      };
    });
    const Ue = () => {
      const { type: pe, autosize: qe } = r;
      if (!(!zt || pe !== "textarea" || !S.value))
        if (qe) {
          const ht = Rr(qe) ? qe.minRows : void 0, _n = Rr(qe) ? qe.maxRows : void 0, Li = n5(S.value, ht, _n);
          C.value = {
            overflowY: "hidden",
            ...Li
          }, rt(() => {
            S.value.offsetHeight, C.value = Li;
          });
        } else
          C.value = {
            minHeight: n5(S.value).minHeight
          };
    }, lt = ((pe) => {
      let qe = !1;
      return () => {
        var ht;
        if (qe || !r.autosize)
          return;
        ((ht = S.value) == null ? void 0 : ht.offsetParent) === null || (pe(), qe = !0);
      };
    })(Ue), Tt = () => {
      const pe = A.value, qe = r.formatter ? r.formatter(Pe.value) : Pe.value;
      !pe || pe.value === qe || (pe.value = qe);
    }, bn = async (pe) => {
      Un();
      let { value: qe } = pe.target;
      if (r.formatter && (qe = r.parser ? r.parser(qe) : qe), !I.value) {
        if (qe === Pe.value) {
          Tt();
          return;
        }
        n(jt, qe), n("input", qe), await rt(), Tt(), Me();
      }
    }, tr = (pe) => {
      n("change", pe.target.value);
    }, Pi = (pe) => {
      n("compositionstart", pe), I.value = !0;
    }, ni = (pe) => {
      var qe;
      n("compositionupdate", pe);
      const ht = (qe = pe.target) == null ? void 0 : qe.value, _n = ht[ht.length - 1] || "";
      I.value = !T3(_n);
    }, Lr = (pe) => {
      n("compositionend", pe), I.value && (I.value = !1, bn(pe));
    }, ri = () => {
      M.value = !M.value, Fr();
    }, Fr = async () => {
      var pe;
      await rt(), (pe = A.value) == null || pe.focus();
    }, Ri = () => {
      var pe;
      return (pe = A.value) == null ? void 0 : pe.blur();
    }, wn = (pe) => {
      $.value = !1, n("mouseleave", pe);
    }, ii = (pe) => {
      $.value = !0, n("mouseenter", pe);
    }, Nr = (pe) => {
      n("keydown", pe);
    }, si = () => {
      var pe;
      (pe = A.value) == null || pe.select();
    }, oi = () => {
      n(jt, ""), n("change", ""), n("clear"), n("input", "");
    };
    return Ie(() => r.modelValue, () => {
      var pe;
      rt(() => Ue()), r.validateEvent && ((pe = f == null ? void 0 : f.validate) == null || pe.call(f, "change").catch((qe) => Zt(qe)));
    }), Ie(Pe, () => Tt()), Ie(() => r.type, async () => {
      await rt(), Tt(), Ue();
    }), Yt(() => {
      !r.formatter && r.parser && Zt("ElInput", "If you set the parser, you also need to set the formatter."), Tt(), rt(Ue);
    }), t({
      input: b,
      textarea: S,
      ref: A,
      textareaStyle: Ae,
      autosize: $o(r, "autosize"),
      focus: Fr,
      blur: Ri,
      select: si,
      clear: oi,
      resizeTextarea: Ue
    }), (pe, qe) => nn((F(), X("div", ga(_(o), {
      class: _(a),
      style: _(ie),
      role: pe.containerRole,
      onMouseenter: ii,
      onMouseleave: wn
    }), [
      he(" input "),
      pe.type !== "textarea" ? (F(), X(Ft, { key: 0 }, [
        he(" prepend slot "),
        pe.$slots.prepend ? (F(), X("div", {
          key: 0,
          class: Z(_(v).be("group", "prepend"))
        }, [
          je(pe.$slots, "prepend")
        ], 2)) : he("v-if", !0),
        ee("div", {
          ref_key: "wrapperRef",
          ref: W,
          class: Z(_(l))
        }, [
          he(" prefix slot "),
          pe.$slots.prefix || pe.prefixIcon ? (F(), X("span", {
            key: 0,
            class: Z(_(v).e("prefix"))
          }, [
            ee("span", {
              class: Z(_(v).e("prefix-inner"))
            }, [
              je(pe.$slots, "prefix"),
              pe.prefixIcon ? (F(), ce(_(Ht), {
                key: 0,
                class: Z(_(v).e("icon"))
              }, {
                default: te(() => [
                  (F(), ce(Mn(pe.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : he("v-if", !0)
            ], 2)
          ], 2)) : he("v-if", !0),
          ee("input", ga({
            id: _(m),
            ref_key: "input",
            ref: b,
            class: _(v).e("inner")
          }, _(c), {
            type: pe.showPassword ? M.value ? "text" : "password" : pe.type,
            disabled: _(g),
            formatter: pe.formatter,
            parser: pe.parser,
            readonly: pe.readonly,
            autocomplete: pe.autocomplete,
            tabindex: pe.tabindex,
            "aria-label": pe.label,
            placeholder: pe.placeholder,
            style: pe.inputStyle,
            form: r.form,
            autofocus: r.autofocus,
            onCompositionstart: Pi,
            onCompositionupdate: ni,
            onCompositionend: Lr,
            onInput: bn,
            onFocus: qe[0] || (qe[0] = (...ht) => _(G) && _(G)(...ht)),
            onBlur: qe[1] || (qe[1] = (...ht) => _(R) && _(R)(...ht)),
            onChange: tr,
            onKeydown: Nr
          }), null, 16, uTe),
          he(" suffix slot "),
          _(Pn) ? (F(), X("span", {
            key: 1,
            class: Z(_(v).e("suffix"))
          }, [
            ee("span", {
              class: Z(_(v).e("suffix-inner"))
            }, [
              !_(Bt) || !_(wt) || !_(Ut) ? (F(), X(Ft, { key: 0 }, [
                je(pe.$slots, "suffix"),
                pe.suffixIcon ? (F(), ce(_(Ht), {
                  key: 0,
                  class: Z(_(v).e("icon"))
                }, {
                  default: te(() => [
                    (F(), ce(Mn(pe.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : he("v-if", !0)
              ], 64)) : he("v-if", !0),
              _(Bt) ? (F(), ce(_(Ht), {
                key: 1,
                class: Z([_(v).e("icon"), _(v).e("clear")]),
                onMousedown: Dt(_(_a), ["prevent"]),
                onClick: oi
              }, {
                default: te(() => [
                  ye(_(JS))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : he("v-if", !0),
              _(wt) ? (F(), ce(_(Ht), {
                key: 2,
                class: Z([_(v).e("icon"), _(v).e("password")]),
                onClick: ri
              }, {
                default: te(() => [
                  (F(), ce(Mn(_(_e))))
                ]),
                _: 1
              }, 8, ["class"])) : he("v-if", !0),
              _(Ut) ? (F(), X("span", {
                key: 3,
                class: Z(_(v).e("count"))
              }, [
                ee("span", {
                  class: Z(_(v).e("count-inner"))
                }, it(_(un)) + " / " + it(_(c).maxlength), 3)
              ], 2)) : he("v-if", !0),
              _(Q) && _(de) && _(V) ? (F(), ce(_(Ht), {
                key: 4,
                class: Z([
                  _(v).e("icon"),
                  _(v).e("validateIcon"),
                  _(v).is("loading", _(Q) === "validating")
                ])
              }, {
                default: te(() => [
                  (F(), ce(Mn(_(de))))
                ]),
                _: 1
              }, 8, ["class"])) : he("v-if", !0)
            ], 2)
          ], 2)) : he("v-if", !0)
        ], 2),
        he(" append slot "),
        pe.$slots.append ? (F(), X("div", {
          key: 1,
          class: Z(_(v).be("group", "append"))
        }, [
          je(pe.$slots, "append")
        ], 2)) : he("v-if", !0)
      ], 64)) : (F(), X(Ft, { key: 1 }, [
        he(" textarea "),
        ee("textarea", ga({
          id: _(m),
          ref_key: "textarea",
          ref: S,
          class: _(w).e("inner")
        }, _(c), {
          tabindex: pe.tabindex,
          disabled: _(g),
          readonly: pe.readonly,
          autocomplete: pe.autocomplete,
          style: _(Ae),
          "aria-label": pe.label,
          placeholder: pe.placeholder,
          form: r.form,
          autofocus: r.autofocus,
          onCompositionstart: Pi,
          onCompositionupdate: ni,
          onCompositionend: Lr,
          onInput: bn,
          onFocus: qe[2] || (qe[2] = (...ht) => _(G) && _(G)(...ht)),
          onBlur: qe[3] || (qe[3] = (...ht) => _(R) && _(R)(...ht)),
          onChange: tr,
          onKeydown: Nr
        }), null, 16, cTe),
        _(Ut) ? (F(), X("span", {
          key: 0,
          style: It(E.value),
          class: Z(_(v).e("count"))
        }, it(_(un)) + " / " + it(_(c).maxlength), 7)) : he("v-if", !0)
      ], 64))
    ], 16, lTe)), [
      [Ei, pe.type !== "hidden"]
    ]);
  }
});
var hTe = /* @__PURE__ */ at(pTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const eG = Ai(hTe), Zh = 4, fTe = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, mTe = ({
  move: e,
  size: t,
  bar: n
}) => ({
  [n.size]: t,
  transform: `translate${n.axis}(${e}%)`
}), tG = Symbol("scrollbarContextKey"), yTe = bt({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), gTe = "Thumb", vTe = /* @__PURE__ */ fe({
  __name: "thumb",
  props: yTe,
  setup(e) {
    const t = e, n = pt(tG), r = tt("scrollbar");
    n || HS(gTe, "can not inject scrollbar context");
    const i = J(), s = J(), o = J({}), a = J(!1);
    let l = !1, c = !1, p = zt ? document.onselectstart : null;
    const f = P(() => fTe[t.vertical ? "vertical" : "horizontal"]), m = P(() => mTe({
      size: t.size,
      move: t.move,
      bar: f.value
    })), y = P(() => i.value[f.value.offset] ** 2 / n.wrapElement[f.value.scrollSize] / t.ratio / s.value[f.value.offset]), g = (E) => {
      var C;
      if (E.stopPropagation(), E.ctrlKey || [1, 2].includes(E.button))
        return;
      (C = window.getSelection()) == null || C.removeAllRanges(), w(E);
      const A = E.currentTarget;
      A && (o.value[f.value.axis] = A[f.value.offset] - (E[f.value.client] - A.getBoundingClientRect()[f.value.direction]));
    }, v = (E) => {
      if (!s.value || !i.value || !n.wrapElement)
        return;
      const C = Math.abs(E.target.getBoundingClientRect()[f.value.direction] - E[f.value.client]), A = s.value[f.value.offset] / 2, W = (C - A) * 100 * y.value / i.value[f.value.offset];
      n.wrapElement[f.value.scroll] = W * n.wrapElement[f.value.scrollSize] / 100;
    }, w = (E) => {
      E.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", b), document.addEventListener("mouseup", S), p = document.onselectstart, document.onselectstart = () => !1;
    }, b = (E) => {
      if (!i.value || !s.value || l === !1)
        return;
      const C = o.value[f.value.axis];
      if (!C)
        return;
      const A = (i.value.getBoundingClientRect()[f.value.direction] - E[f.value.client]) * -1, W = s.value[f.value.offset] - C, j = (A - W) * 100 * y.value / i.value[f.value.offset];
      n.wrapElement[f.value.scroll] = j * n.wrapElement[f.value.scrollSize] / 100;
    }, S = () => {
      l = !1, o.value[f.value.axis] = 0, document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", S), M(), c && (a.value = !1);
    }, $ = () => {
      c = !1, a.value = !!t.size;
    }, I = () => {
      c = !0, a.value = l;
    };
    us(() => {
      M(), document.removeEventListener("mouseup", S);
    });
    const M = () => {
      document.onselectstart !== p && (document.onselectstart = p);
    };
    return Il($o(n, "scrollbarElement"), "mousemove", $), Il($o(n, "scrollbarElement"), "mouseleave", I), (E, C) => (F(), ce(ko, {
      name: _(r).b("fade"),
      persisted: ""
    }, {
      default: te(() => [
        nn(ee("div", {
          ref_key: "instance",
          ref: i,
          class: Z([_(r).e("bar"), _(r).is(_(f).key)]),
          onMousedown: v
        }, [
          ee("div", {
            ref_key: "thumb",
            ref: s,
            class: Z(_(r).e("thumb")),
            style: It(_(m)),
            onMousedown: g
          }, null, 38)
        ], 34), [
          [Ei, E.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var r5 = /* @__PURE__ */ at(vTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const bTe = bt({
  always: {
    type: Boolean,
    default: !0
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
}), wTe = /* @__PURE__ */ fe({
  __name: "bar",
  props: bTe,
  setup(e, { expose: t }) {
    const n = e, r = J(0), i = J(0);
    return t({
      handleScroll: (o) => {
        if (o) {
          const a = o.offsetHeight - Zh, l = o.offsetWidth - Zh;
          i.value = o.scrollTop * 100 / a * n.ratioY, r.value = o.scrollLeft * 100 / l * n.ratioX;
        }
      }
    }), (o, a) => (F(), X(Ft, null, [
      ye(r5, {
        move: r.value,
        ratio: o.ratioX,
        size: o.width,
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      ye(r5, {
        move: i.value,
        ratio: o.ratioY,
        size: o.height,
        vertical: "",
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var _Te = /* @__PURE__ */ at(wTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const STe = bt({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Be([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), xTe = {
  scroll: ({
    scrollTop: e,
    scrollLeft: t
  }) => [e, t].every(yn)
}, dC = "ElScrollbar", $Te = fe({
  name: dC
}), TTe = /* @__PURE__ */ fe({
  ...$Te,
  props: STe,
  emits: xTe,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = tt("scrollbar");
    let s, o;
    const a = J(), l = J(), c = J(), p = J("0"), f = J("0"), m = J(), y = J(1), g = J(1), v = P(() => {
      const C = {};
      return r.height && (C.height = Rl(r.height)), r.maxHeight && (C.maxHeight = Rl(r.maxHeight)), [r.wrapStyle, C];
    }), w = P(() => [
      r.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !r.native }
    ]), b = P(() => [i.e("view"), r.viewClass]), S = () => {
      var C;
      l.value && ((C = m.value) == null || C.handleScroll(l.value), n("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function $(C, A) {
      Rr(C) ? l.value.scrollTo(C) : yn(C) && yn(A) && l.value.scrollTo(C, A);
    }
    const I = (C) => {
      if (!yn(C)) {
        Zt(dC, "value must be a number");
        return;
      }
      l.value.scrollTop = C;
    }, M = (C) => {
      if (!yn(C)) {
        Zt(dC, "value must be a number");
        return;
      }
      l.value.scrollLeft = C;
    }, E = () => {
      if (!l.value)
        return;
      const C = l.value.offsetHeight - Zh, A = l.value.offsetWidth - Zh, W = C ** 2 / l.value.scrollHeight, j = A ** 2 / l.value.scrollWidth, G = Math.max(W, r.minSize), R = Math.max(j, r.minSize);
      y.value = W / (C - W) / (G / (C - G)), g.value = j / (A - j) / (R / (A - R)), f.value = G + Zh < C ? `${G}px` : "", p.value = R + Zh < A ? `${R}px` : "";
    };
    return Ie(() => r.noresize, (C) => {
      C ? (s == null || s(), o == null || o()) : ({ stop: s } = Lp(c, E), o = Il("resize", E));
    }, { immediate: !0 }), Ie(() => [r.maxHeight, r.height], () => {
      r.native || rt(() => {
        var C;
        E(), l.value && ((C = m.value) == null || C.handleScroll(l.value));
      });
    }), _r(tG, is({
      scrollbarElement: a,
      wrapElement: l
    })), Yt(() => {
      r.native || rt(() => {
        E();
      });
    }), J5(() => E()), t({
      wrapRef: l,
      update: E,
      scrollTo: $,
      setScrollTop: I,
      setScrollLeft: M,
      handleScroll: S
    }), (C, A) => (F(), X("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: Z(_(i).b())
    }, [
      ee("div", {
        ref_key: "wrapRef",
        ref: l,
        class: Z(_(w)),
        style: It(_(v)),
        onScroll: S
      }, [
        (F(), ce(Mn(C.tag), {
          id: C.id,
          ref_key: "resizeRef",
          ref: c,
          class: Z(_(b)),
          style: It(C.viewStyle),
          role: C.role,
          "aria-label": C.ariaLabel,
          "aria-orientation": C.ariaOrientation
        }, {
          default: te(() => [
            je(C.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      C.native ? he("v-if", !0) : (F(), ce(_Te, {
        key: 0,
        ref_key: "barRef",
        ref: m,
        height: f.value,
        width: p.value,
        always: C.always,
        "ratio-x": g.value,
        "ratio-y": y.value
      }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
    ], 2));
  }
});
var ETe = /* @__PURE__ */ at(TTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const F3 = Ai(ETe), N3 = Symbol("popper"), nG = Symbol("popperContent"), ITe = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], rG = bt({
  role: {
    type: String,
    values: ITe,
    default: "tooltip"
  }
}), MTe = fe({
  name: "ElPopper",
  inheritAttrs: !1
}), CTe = /* @__PURE__ */ fe({
  ...MTe,
  props: rG,
  setup(e, { expose: t }) {
    const n = e, r = J(), i = J(), s = J(), o = J(), a = P(() => n.role), l = {
      triggerRef: r,
      popperInstanceRef: i,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return t(l), _r(N3, l), (c, p) => je(c.$slots, "default");
  }
});
var OTe = /* @__PURE__ */ at(CTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const iG = bt({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), kTe = fe({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), ATe = /* @__PURE__ */ fe({
  ...kTe,
  props: iG,
  setup(e, { expose: t }) {
    const n = e, r = tt("popper"), { arrowOffset: i, arrowRef: s, arrowStyle: o } = pt(nG, void 0);
    return Ie(() => n.arrowOffset, (a) => {
      i.value = a;
    }), us(() => {
      s.value = void 0;
    }), t({
      arrowRef: s
    }), (a, l) => (F(), X("span", {
      ref_key: "arrowRef",
      ref: s,
      class: Z(_(r).e("arrow")),
      style: It(_(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var PTe = /* @__PURE__ */ at(ATe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const s$ = "ElOnlyChild", RTe = fe({
  name: s$,
  setup(e, {
    slots: t,
    attrs: n
  }) {
    var r;
    const i = pt(Gq), s = t$e((r = i == null ? void 0 : i.setForwardRef) != null ? r : _a);
    return () => {
      var o;
      const a = (o = t.default) == null ? void 0 : o.call(t, n);
      if (!a)
        return null;
      if (a.length > 1)
        return Zt(s$, "requires exact only one valid child."), null;
      const l = sG(a);
      return l ? nn(IW(l, n), [[s]]) : (Zt(s$, "no valid child node found"), null);
    };
  }
});
function sG(e) {
  if (!e)
    return null;
  const t = e;
  for (const n of t) {
    if (Rr(n))
      switch (n.type) {
        case MW:
          continue;
        case K5:
        case "svg":
          return i5(n);
        case Ft:
          return sG(n.children);
        default:
          return n;
      }
    return i5(n);
  }
  return null;
}
function i5(e) {
  const t = tt("only-child");
  return ye("span", {
    class: t.e("content")
  }, [e]);
}
const oG = bt({
  virtualRef: {
    type: Be(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Be(Function)
  },
  onMouseleave: {
    type: Be(Function)
  },
  onClick: {
    type: Be(Function)
  },
  onKeydown: {
    type: Be(Function)
  },
  onFocus: {
    type: Be(Function)
  },
  onBlur: {
    type: Be(Function)
  },
  onContextmenu: {
    type: Be(Function)
  },
  id: String,
  open: Boolean
}), LTe = fe({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), FTe = /* @__PURE__ */ fe({
  ...LTe,
  props: oG,
  setup(e, { expose: t }) {
    const n = e, { role: r, triggerRef: i } = pt(N3, void 0);
    e$e(i);
    const s = P(() => a.value ? n.id : void 0), o = P(() => {
      if (r && r.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), a = P(() => {
      if (r && r.value !== "tooltip")
        return r.value;
    }), l = P(() => a.value ? `${n.open}` : void 0);
    let c;
    return Yt(() => {
      Ie(() => n.virtualRef, (p) => {
        p && (i.value = xl(p));
      }, {
        immediate: !0
      }), Ie(i, (p, f) => {
        c == null || c(), c = void 0, uc(p) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((m) => {
          var y;
          const g = n[m];
          g && (p.addEventListener(m.slice(2).toLowerCase(), g), (y = f == null ? void 0 : f.removeEventListener) == null || y.call(f, m.slice(2).toLowerCase(), g));
        }), c = Ie([s, o, a, l], (m) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((y, g) => {
            q0(m[g]) ? p.removeAttribute(y) : p.setAttribute(y, m[g]);
          });
        }, { immediate: !0 })), uc(f) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((m) => f.removeAttribute(m));
      }, {
        immediate: !0
      });
    }), us(() => {
      c == null || c(), c = void 0;
    }), t({
      triggerRef: i
    }), (p, f) => p.virtualTriggering ? he("v-if", !0) : (F(), ce(_(RTe), ga({ key: 0 }, p.$attrs, {
      "aria-controls": _(s),
      "aria-describedby": _(o),
      "aria-expanded": _(l),
      "aria-haspopup": _(a)
    }), {
      default: te(() => [
        je(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var NTe = /* @__PURE__ */ at(FTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const o$ = "focus-trap.focus-after-trapped", a$ = "focus-trap.focus-after-released", DTe = "focus-trap.focusout-prevented", s5 = {
  cancelable: !0,
  bubbles: !1
}, jTe = {
  cancelable: !0,
  bubbles: !1
}, o5 = "focusAfterTrapped", a5 = "focusAfterReleased", aG = Symbol("elFocusTrap"), D3 = J(), e2 = J(0), j3 = J(0);
let ab = 0;
const lG = (e) => {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}, l5 = (e, t) => {
  for (const n of e)
    if (!VTe(n, t))
      return n;
}, VTe = (e, t) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}, zTe = (e) => {
  const t = lG(e), n = l5(t, e), r = l5(t.reverse(), e);
  return [n, r];
}, BTe = (e) => e instanceof HTMLInputElement && "select" in e, Cu = (e, t) => {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), j3.value = window.performance.now(), e !== n && BTe(e) && t && e.select();
  }
};
function u5(e, t) {
  const n = [...e], r = e.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
const UTe = () => {
  let e = [];
  return {
    push: (r) => {
      const i = e[0];
      i && r !== i && i.pause(), e = u5(e, r), e.unshift(r);
    },
    remove: (r) => {
      var i, s;
      e = u5(e, r), (s = (i = e[0]) == null ? void 0 : i.resume) == null || s.call(i);
    }
  };
}, qTe = (e, t = !1) => {
  const n = document.activeElement;
  for (const r of e)
    if (Cu(r, t), document.activeElement !== n)
      return;
}, c5 = UTe(), GTe = () => e2.value > j3.value, lb = () => {
  D3.value = "pointer", e2.value = window.performance.now();
}, d5 = () => {
  D3.value = "keyboard", e2.value = window.performance.now();
}, WTe = () => (Yt(() => {
  ab === 0 && (document.addEventListener("mousedown", lb), document.addEventListener("touchstart", lb), document.addEventListener("keydown", d5)), ab++;
}), us(() => {
  ab--, ab <= 0 && (document.removeEventListener("mousedown", lb), document.removeEventListener("touchstart", lb), document.removeEventListener("keydown", d5));
}), {
  focusReason: D3,
  lastUserFocusTimestamp: e2,
  lastAutomatedFocusTimestamp: j3
}), ub = (e) => new CustomEvent(DTe, {
  ...jTe,
  detail: e
}), HTe = fe({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    o5,
    a5,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(e, { emit: t }) {
    const n = J();
    let r, i;
    const { focusReason: s } = WTe();
    Zxe((g) => {
      e.trapped && !o.paused && t("release-requested", g);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (g) => {
      if (!e.loop && !e.trapped || o.paused)
        return;
      const { key: v, altKey: w, ctrlKey: b, metaKey: S, currentTarget: $, shiftKey: I } = g, { loop: M } = e, E = v === on.tab && !w && !b && !S, C = document.activeElement;
      if (E && C) {
        const A = $, [W, j] = zTe(A);
        if (W && j) {
          if (!I && C === j) {
            const R = ub({
              focusReason: s.value
            });
            t("focusout-prevented", R), R.defaultPrevented || (g.preventDefault(), M && Cu(W, !0));
          } else if (I && [W, A].includes(C)) {
            const R = ub({
              focusReason: s.value
            });
            t("focusout-prevented", R), R.defaultPrevented || (g.preventDefault(), M && Cu(j, !0));
          }
        } else if (C === A) {
          const R = ub({
            focusReason: s.value
          });
          t("focusout-prevented", R), R.defaultPrevented || g.preventDefault();
        }
      }
    };
    _r(aG, {
      focusTrapRef: n,
      onKeydown: a
    }), Ie(() => e.focusTrapEl, (g) => {
      g && (n.value = g);
    }, { immediate: !0 }), Ie([n], ([g], [v]) => {
      g && (g.addEventListener("keydown", a), g.addEventListener("focusin", p), g.addEventListener("focusout", f)), v && (v.removeEventListener("keydown", a), v.removeEventListener("focusin", p), v.removeEventListener("focusout", f));
    });
    const l = (g) => {
      t(o5, g);
    }, c = (g) => t(a5, g), p = (g) => {
      const v = _(n);
      if (!v)
        return;
      const w = g.target, b = g.relatedTarget, S = w && v.contains(w);
      e.trapped || b && v.contains(b) || (r = b), S && t("focusin", g), !o.paused && e.trapped && (S ? i = w : Cu(i, !0));
    }, f = (g) => {
      const v = _(n);
      if (!(o.paused || !v))
        if (e.trapped) {
          const w = g.relatedTarget;
          !q0(w) && !v.contains(w) && setTimeout(() => {
            if (!o.paused && e.trapped) {
              const b = ub({
                focusReason: s.value
              });
              t("focusout-prevented", b), b.defaultPrevented || Cu(i, !0);
            }
          }, 0);
        } else {
          const w = g.target;
          w && v.contains(w) || t("focusout", g);
        }
    };
    async function m() {
      await rt();
      const g = _(n);
      if (g) {
        c5.push(o);
        const v = g.contains(document.activeElement) ? r : document.activeElement;
        if (r = v, !g.contains(v)) {
          const b = new Event(o$, s5);
          g.addEventListener(o$, l), g.dispatchEvent(b), b.defaultPrevented || rt(() => {
            let S = e.focusStartEl;
            ln(S) || (Cu(S), document.activeElement !== S && (S = "first")), S === "first" && qTe(lG(g), !0), (document.activeElement === v || S === "container") && Cu(g);
          });
        }
      }
    }
    function y() {
      const g = _(n);
      if (g) {
        g.removeEventListener(o$, l);
        const v = new CustomEvent(a$, {
          ...s5,
          detail: {
            focusReason: s.value
          }
        });
        g.addEventListener(a$, c), g.dispatchEvent(v), !v.defaultPrevented && (s.value == "keyboard" || !GTe() || g.contains(document.activeElement)) && Cu(r ?? document.body), g.removeEventListener(a$, c), c5.remove(o);
      }
    }
    return Yt(() => {
      e.trapped && m(), Ie(() => e.trapped, (g) => {
        g ? m() : y();
      });
    }), us(() => {
      e.trapped && y();
    }), {
      onKeydown: a
    };
  }
});
function JTe(e, t, n, r, i, s) {
  return je(e.$slots, "default", { handleKeydown: e.onKeydown });
}
var uG = /* @__PURE__ */ at(HTe, [["render", JTe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const ZTe = ["fixed", "absolute"], KTe = bt({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Be(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: YS,
    default: "bottom"
  },
  popperOptions: {
    type: Be(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: ZTe,
    default: "absolute"
  }
}), cG = bt({
  ...KTe,
  id: String,
  style: {
    type: Be([String, Array, Object])
  },
  className: {
    type: Be([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Be([String, Array, Object])
  },
  popperStyle: {
    type: Be([String, Array, Object])
  },
  referenceEl: {
    type: Be(Object)
  },
  triggerTargetEl: {
    type: Be(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), YTe = {
  mouseenter: (e) => e instanceof MouseEvent,
  mouseleave: (e) => e instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, QTe = (e, t = []) => {
  const { placement: n, strategy: r, popperOptions: i } = e, s = {
    placement: n,
    strategy: r,
    ...i,
    modifiers: [...eEe(e), ...t]
  };
  return tEe(s, i == null ? void 0 : i.modifiers), s;
}, XTe = (e) => {
  if (zt)
    return xl(e);
};
function eEe(e) {
  const { offset: t, gpuAcceleration: n, fallbackPlacements: r } = e;
  return [
    {
      name: "offset",
      options: {
        offset: [0, t ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: r
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function tEe(e, t) {
  t && (e.modifiers = [...e.modifiers, ...t ?? []]);
}
const nEe = 0, rEe = (e) => {
  const { popperInstanceRef: t, contentRef: n, triggerRef: r, role: i } = pt(N3, void 0), s = J(), o = J(), a = P(() => ({
    name: "eventListeners",
    enabled: !!e.visible
  })), l = P(() => {
    var b;
    const S = _(s), $ = (b = _(o)) != null ? b : nEe;
    return {
      name: "arrow",
      enabled: !dq(S),
      options: {
        element: S,
        padding: $
      }
    };
  }), c = P(() => ({
    onFirstUpdate: () => {
      g();
    },
    ...QTe(e, [
      _(l),
      _(a)
    ])
  })), p = P(() => XTe(e.referenceEl) || _(r)), { attributes: f, state: m, styles: y, update: g, forceUpdate: v, instanceRef: w } = Wxe(p, n, c);
  return Ie(w, (b) => t.value = b), Yt(() => {
    Ie(() => {
      var b;
      return (b = _(p)) == null ? void 0 : b.getBoundingClientRect();
    }, () => {
      g();
    });
  }), {
    attributes: f,
    arrowRef: s,
    contentRef: n,
    instanceRef: w,
    state: m,
    styles: y,
    role: i,
    forceUpdate: v,
    update: g
  };
}, iEe = (e, {
  attributes: t,
  styles: n,
  role: r
}) => {
  const { nextZIndex: i } = R3(), s = tt("popper"), o = P(() => _(t).popper), a = J(yn(e.zIndex) ? e.zIndex : i()), l = P(() => [
    s.b(),
    s.is("pure", e.pure),
    s.is(e.effect),
    e.popperClass
  ]), c = P(() => [
    { zIndex: _(a) },
    _(n).popper,
    e.popperStyle || {}
  ]), p = P(() => r.value === "dialog" ? "false" : void 0), f = P(() => _(n).arrow || {});
  return {
    ariaModal: p,
    arrowStyle: f,
    contentAttrs: o,
    contentClass: l,
    contentStyle: c,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = yn(e.zIndex) ? e.zIndex : i();
    }
  };
}, sEe = (e, t) => {
  const n = J(!1), r = J();
  return {
    focusStartRef: r,
    trapped: n,
    onFocusAfterReleased: (c) => {
      var p;
      ((p = c.detail) == null ? void 0 : p.focusReason) !== "pointer" && (r.value = "first", t("blur"));
    },
    onFocusAfterTrapped: () => {
      t("focus");
    },
    onFocusInTrap: (c) => {
      e.visible && !n.value && (c.target && (r.value = c.target), n.value = !0);
    },
    onFocusoutPrevented: (c) => {
      e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = !1);
    },
    onReleaseRequested: () => {
      n.value = !1, t("close");
    }
  };
}, oEe = fe({
  name: "ElPopperContent"
}), aEe = /* @__PURE__ */ fe({
  ...oEe,
  props: cG,
  emits: YTe,
  setup(e, { expose: t, emit: n }) {
    const r = e, {
      focusStartRef: i,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: c,
      onReleaseRequested: p
    } = sEe(r, n), { attributes: f, arrowRef: m, contentRef: y, styles: g, instanceRef: v, role: w, update: b } = rEe(r), {
      ariaModal: S,
      arrowStyle: $,
      contentAttrs: I,
      contentClass: M,
      contentStyle: E,
      updateZIndex: C
    } = iEe(r, {
      styles: g,
      attributes: f,
      role: w
    }), A = pt(bp, void 0), W = J();
    _r(nG, {
      arrowStyle: $,
      arrowRef: m,
      arrowOffset: W
    }), A && (A.addInputId || A.removeInputId) && _r(bp, {
      ...A,
      addInputId: _a,
      removeInputId: _a
    });
    let j;
    const G = (V = !0) => {
      b(), V && C();
    }, R = () => {
      G(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1);
    };
    return Yt(() => {
      Ie(() => r.triggerTargetEl, (V, Q) => {
        j == null || j(), j = void 0;
        const de = _(V || y.value), _e = _(Q || y.value);
        uc(de) && (j = Ie([w, () => r.ariaLabel, S, () => r.id], (ie) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((Ae, Pe) => {
            q0(ie[Pe]) ? de.removeAttribute(Ae) : de.setAttribute(Ae, ie[Pe]);
          });
        }, { immediate: !0 })), _e !== de && uc(_e) && ["role", "aria-label", "aria-modal", "id"].forEach((ie) => {
          _e.removeAttribute(ie);
        });
      }, { immediate: !0 }), Ie(() => r.visible, R, { immediate: !0 });
    }), us(() => {
      j == null || j(), j = void 0;
    }), t({
      popperContentRef: y,
      popperInstanceRef: v,
      updatePopper: G,
      contentStyle: E
    }), (V, Q) => (F(), X("div", ga({
      ref_key: "contentRef",
      ref: y
    }, _(I), {
      style: _(E),
      class: _(M),
      tabindex: "-1",
      onMouseenter: Q[0] || (Q[0] = (de) => V.$emit("mouseenter", de)),
      onMouseleave: Q[1] || (Q[1] = (de) => V.$emit("mouseleave", de))
    }), [
      ye(_(uG), {
        trapped: _(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": _(y),
        "focus-start-el": _(i),
        onFocusAfterTrapped: _(a),
        onFocusAfterReleased: _(o),
        onFocusin: _(l),
        onFocusoutPrevented: _(c),
        onReleaseRequested: _(p)
      }, {
        default: te(() => [
          je(V.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var lEe = /* @__PURE__ */ at(aEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const uEe = Ai(OTe), V3 = Symbol("elTooltip"), t2 = bt({
  ...Qxe,
  ...cG,
  appendTo: {
    type: Be([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Be(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), dG = bt({
  ...oG,
  disabled: Boolean,
  trigger: {
    type: Be([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Be(Array),
    default: () => [on.enter, on.space]
  }
}), {
  useModelToggleProps: cEe,
  useModelToggleEmits: dEe,
  useModelToggle: pEe
} = Aq("visible"), hEe = bt({
  ...rG,
  ...cEe,
  ...t2,
  ...dG,
  ...iG,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), fEe = [
  ...dEe,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], mEe = (e, t) => Pl(e) ? e.includes(t) : e === t, Kp = (e, t, n) => (r) => {
  mEe(_(e), t) && n(r);
}, yEe = fe({
  name: "ElTooltipTrigger"
}), gEe = /* @__PURE__ */ fe({
  ...yEe,
  props: dG,
  setup(e, { expose: t }) {
    const n = e, r = tt("tooltip"), { controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: c } = pt(V3, void 0), p = J(null), f = () => {
      if (_(i) || n.disabled)
        return !0;
    }, m = $o(n, "trigger"), y = fl(f, Kp(m, "hover", a)), g = fl(f, Kp(m, "hover", l)), v = fl(f, Kp(m, "click", (I) => {
      I.button === 0 && c(I);
    })), w = fl(f, Kp(m, "focus", a)), b = fl(f, Kp(m, "focus", l)), S = fl(f, Kp(m, "contextmenu", (I) => {
      I.preventDefault(), c(I);
    })), $ = fl(f, (I) => {
      const { code: M } = I;
      n.triggerKeys.includes(M) && (I.preventDefault(), c(I));
    });
    return t({
      triggerRef: p
    }), (I, M) => (F(), ce(_(NTe), {
      id: _(s),
      "virtual-ref": I.virtualRef,
      open: _(o),
      "virtual-triggering": I.virtualTriggering,
      class: Z(_(r).e("trigger")),
      onBlur: _(b),
      onClick: _(v),
      onContextmenu: _(S),
      onFocus: _(w),
      onMouseenter: _(y),
      onMouseleave: _(g),
      onKeydown: _($)
    }, {
      default: te(() => [
        je(I.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var vEe = /* @__PURE__ */ at(gEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const bEe = fe({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), wEe = /* @__PURE__ */ fe({
  ...bEe,
  props: t2,
  setup(e, { expose: t }) {
    const n = e, { selector: r } = qq(), i = tt("tooltip"), s = J(null), o = J(!1), {
      controlled: a,
      id: l,
      open: c,
      trigger: p,
      onClose: f,
      onOpen: m,
      onShow: y,
      onHide: g,
      onBeforeShow: v,
      onBeforeHide: w
    } = pt(V3, void 0), b = P(() => n.transition || `${i.namespace.value}-fade-in-linear`), S = P(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
    us(() => {
      o.value = !0;
    });
    const $ = P(() => _(S) ? !0 : _(c)), I = P(() => n.disabled ? !1 : _(c)), M = P(() => n.appendTo || r.value), E = P(() => {
      var ie;
      return (ie = n.style) != null ? ie : {};
    }), C = P(() => !_(c)), A = () => {
      g();
    }, W = () => {
      if (_(a))
        return !0;
    }, j = fl(W, () => {
      n.enterable && _(p) === "hover" && m();
    }), G = fl(W, () => {
      _(p) === "hover" && f();
    }), R = () => {
      var ie, Ae;
      (Ae = (ie = s.value) == null ? void 0 : ie.updatePopper) == null || Ae.call(ie), v == null || v();
    }, V = () => {
      w == null || w();
    }, Q = () => {
      y(), _e = j0e(P(() => {
        var ie;
        return (ie = s.value) == null ? void 0 : ie.popperContentRef;
      }), () => {
        if (_(a))
          return;
        _(p) !== "hover" && f();
      });
    }, de = () => {
      n.virtualTriggering || f();
    };
    let _e;
    return Ie(() => _(c), (ie) => {
      ie || _e == null || _e();
    }, {
      flush: "post"
    }), Ie(() => n.content, () => {
      var ie, Ae;
      (Ae = (ie = s.value) == null ? void 0 : ie.updatePopper) == null || Ae.call(ie);
    }), t({
      contentRef: s
    }), (ie, Ae) => (F(), ce(Y5, {
      disabled: !ie.teleported,
      to: _(M)
    }, [
      ye(ko, {
        name: _(b),
        onAfterLeave: A,
        onBeforeEnter: R,
        onAfterEnter: Q,
        onBeforeLeave: V
      }, {
        default: te(() => [
          _($) ? nn((F(), ce(_(lEe), ga({
            key: 0,
            id: _(l),
            ref_key: "contentRef",
            ref: s
          }, ie.$attrs, {
            "aria-label": ie.ariaLabel,
            "aria-hidden": _(C),
            "boundaries-padding": ie.boundariesPadding,
            "fallback-placements": ie.fallbackPlacements,
            "gpu-acceleration": ie.gpuAcceleration,
            offset: ie.offset,
            placement: ie.placement,
            "popper-options": ie.popperOptions,
            strategy: ie.strategy,
            effect: ie.effect,
            enterable: ie.enterable,
            pure: ie.pure,
            "popper-class": ie.popperClass,
            "popper-style": [ie.popperStyle, _(E)],
            "reference-el": ie.referenceEl,
            "trigger-target-el": ie.triggerTargetEl,
            visible: _(I),
            "z-index": ie.zIndex,
            onMouseenter: _(j),
            onMouseleave: _(G),
            onBlur: de,
            onClose: _(f)
          }), {
            default: te(() => [
              o.value ? he("v-if", !0) : je(ie.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [Ei, _(I)]
          ]) : he("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var _Ee = /* @__PURE__ */ at(wEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const SEe = ["innerHTML"], xEe = { key: 1 }, $Ee = fe({
  name: "ElTooltip"
}), TEe = /* @__PURE__ */ fe({
  ...$Ee,
  props: hEe,
  emits: fEe,
  setup(e, { expose: t, emit: n }) {
    const r = e;
    Yxe();
    const i = dc(), s = J(), o = J(), a = () => {
      var b;
      const S = _(s);
      S && ((b = S.popperInstanceRef) == null || b.update());
    }, l = J(!1), c = J(), { show: p, hide: f, hasUpdateHandler: m } = pEe({
      indicator: l,
      toggleReason: c
    }), { onOpen: y, onClose: g } = Xxe({
      showAfter: $o(r, "showAfter"),
      hideAfter: $o(r, "hideAfter"),
      autoClose: $o(r, "autoClose"),
      open: p,
      close: f
    }), v = P(() => Qr(r.visible) && !m.value);
    _r(V3, {
      controlled: v,
      id: i,
      open: H5(l),
      trigger: $o(r, "trigger"),
      onOpen: (b) => {
        y(b);
      },
      onClose: (b) => {
        g(b);
      },
      onToggle: (b) => {
        _(l) ? g(b) : y(b);
      },
      onShow: () => {
        n("show", c.value);
      },
      onHide: () => {
        n("hide", c.value);
      },
      onBeforeShow: () => {
        n("before-show", c.value);
      },
      onBeforeHide: () => {
        n("before-hide", c.value);
      },
      updatePopper: a
    }), Ie(() => r.disabled, (b) => {
      b && l.value && (l.value = !1);
    });
    const w = (b) => {
      var S, $;
      const I = ($ = (S = o.value) == null ? void 0 : S.contentRef) == null ? void 0 : $.popperContentRef, M = (b == null ? void 0 : b.relatedTarget) || document.activeElement;
      return I && I.contains(M);
    };
    return CW(() => l.value && f()), t({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: w,
      updatePopper: a,
      onOpen: y,
      onClose: g,
      hide: f
    }), (b, S) => (F(), ce(_(uEe), {
      ref_key: "popperRef",
      ref: s,
      role: b.role
    }, {
      default: te(() => [
        ye(vEe, {
          disabled: b.disabled,
          trigger: b.trigger,
          "trigger-keys": b.triggerKeys,
          "virtual-ref": b.virtualRef,
          "virtual-triggering": b.virtualTriggering
        }, {
          default: te(() => [
            b.$slots.default ? je(b.$slots, "default", { key: 0 }) : he("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        ye(_Ee, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": b.ariaLabel,
          "boundaries-padding": b.boundariesPadding,
          content: b.content,
          disabled: b.disabled,
          effect: b.effect,
          enterable: b.enterable,
          "fallback-placements": b.fallbackPlacements,
          "hide-after": b.hideAfter,
          "gpu-acceleration": b.gpuAcceleration,
          offset: b.offset,
          persistent: b.persistent,
          "popper-class": b.popperClass,
          "popper-style": b.popperStyle,
          placement: b.placement,
          "popper-options": b.popperOptions,
          pure: b.pure,
          "raw-content": b.rawContent,
          "reference-el": b.referenceEl,
          "trigger-target-el": b.triggerTargetEl,
          "show-after": b.showAfter,
          strategy: b.strategy,
          teleported: b.teleported,
          transition: b.transition,
          "virtual-triggering": b.virtualTriggering,
          "z-index": b.zIndex,
          "append-to": b.appendTo
        }, {
          default: te(() => [
            je(b.$slots, "content", {}, () => [
              b.rawContent ? (F(), X("span", {
                key: 0,
                innerHTML: b.content
              }, null, 8, SEe)) : (F(), X("span", xEe, it(b.content), 1))
            ]),
            b.showArrow ? (F(), ce(_(PTe), {
              key: 0,
              "arrow-offset": b.arrowOffset
            }, null, 8, ["arrow-offset"])) : he("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var EEe = /* @__PURE__ */ at(TEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const pC = Ai(EEe), IEe = bt({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
}), MEe = ["textContent"], CEe = fe({
  name: "ElBadge"
}), OEe = /* @__PURE__ */ fe({
  ...CEe,
  props: IEe,
  setup(e, { expose: t }) {
    const n = e, r = tt("badge"), i = P(() => n.isDot ? "" : yn(n.value) && yn(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`);
    return t({
      content: i
    }), (s, o) => (F(), X("div", {
      class: Z(_(r).b())
    }, [
      je(s.$slots, "default"),
      ye(ko, {
        name: `${_(r).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: te(() => [
          nn(ee("sup", {
            class: Z([
              _(r).e("content"),
              _(r).em("content", s.type),
              _(r).is("fixed", !!s.$slots.default),
              _(r).is("dot", s.isDot)
            ]),
            textContent: it(_(i))
          }, null, 10, MEe), [
            [Ei, !s.hidden && (_(i) || s.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var kEe = /* @__PURE__ */ at(OEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const AEe = Ai(kEe), pG = Symbol("buttonGroupContextKey"), PEe = (e, t) => {
  i0({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, P(() => e.type === "text"));
  const n = pt(pG, void 0), r = XS("button"), { form: i } = jl(), s = Do(P(() => n == null ? void 0 : n.size)), o = lm(), a = J(), l = Nf(), c = P(() => e.type || (n == null ? void 0 : n.type) || ""), p = P(() => {
    var g, v, w;
    return (w = (v = e.autoInsertSpace) != null ? v : (g = r.value) == null ? void 0 : g.autoInsertSpace) != null ? w : !1;
  }), f = P(() => e.tag === "button" ? {
    ariaDisabled: o.value || e.loading,
    disabled: o.value || e.loading,
    autofocus: e.autofocus,
    type: e.nativeType
  } : {}), m = P(() => {
    var g;
    const v = (g = l.default) == null ? void 0 : g.call(l);
    if (p.value && (v == null ? void 0 : v.length) === 1) {
      const w = v[0];
      if ((w == null ? void 0 : w.type) === K5) {
        const b = w.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(b.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: c,
    _ref: a,
    _props: f,
    shouldAddSpace: m,
    handleClick: (g) => {
      e.nativeType === "reset" && (i == null || i.resetFields()), t("click", g);
    }
  };
}, REe = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], LEe = ["button", "submit", "reset"], hC = bt({
  size: _c,
  disabled: Boolean,
  type: {
    type: String,
    values: REe,
    default: ""
  },
  icon: {
    type: Yi
  },
  nativeType: {
    type: String,
    values: LEe,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Yi,
    default: () => G0
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Be([String, Object]),
    default: "button"
  }
}), FEe = {
  click: (e) => e instanceof MouseEvent
};
function wr(e, t) {
  NEe(e) && (e = "100%");
  var n = DEe(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function cb(e) {
  return Math.min(1, Math.max(0, e));
}
function NEe(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function DEe(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function hG(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function db(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function Dd(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function jEe(e, t, n) {
  return {
    r: wr(e, 255) * 255,
    g: wr(t, 255) * 255,
    b: wr(n, 255) * 255
  };
}
function p5(e, t, n) {
  e = wr(e, 255), t = wr(t, 255), n = wr(n, 255);
  var r = Math.max(e, t, n), i = Math.min(e, t, n), s = 0, o = 0, a = (r + i) / 2;
  if (r === i)
    o = 0, s = 0;
  else {
    var l = r - i;
    switch (o = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case e:
        s = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        s = (n - e) / l + 2;
        break;
      case n:
        s = (e - t) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function l$(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function VEe(e, t, n) {
  var r, i, s;
  if (e = wr(e, 360), t = wr(t, 100), n = wr(n, 100), t === 0)
    i = n, s = n, r = n;
  else {
    var o = n < 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - o;
    r = l$(a, o, e + 1 / 3), i = l$(a, o, e), s = l$(a, o, e - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: s * 255 };
}
function h5(e, t, n) {
  e = wr(e, 255), t = wr(t, 255), n = wr(n, 255);
  var r = Math.max(e, t, n), i = Math.min(e, t, n), s = 0, o = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    s = 0;
  else {
    switch (r) {
      case e:
        s = (t - n) / a + (t < n ? 6 : 0);
        break;
      case t:
        s = (n - e) / a + 2;
        break;
      case n:
        s = (e - t) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function zEe(e, t, n) {
  e = wr(e, 360) * 6, t = wr(t, 100), n = wr(n, 100);
  var r = Math.floor(e), i = e - r, s = n * (1 - t), o = n * (1 - i * t), a = n * (1 - (1 - i) * t), l = r % 6, c = [n, o, s, s, a, n][l], p = [a, n, n, o, s, s][l], f = [s, s, a, n, n, o][l];
  return { r: c * 255, g: p * 255, b: f * 255 };
}
function f5(e, t, n, r) {
  var i = [
    Dd(Math.round(e).toString(16)),
    Dd(Math.round(t).toString(16)),
    Dd(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function BEe(e, t, n, r, i) {
  var s = [
    Dd(Math.round(e).toString(16)),
    Dd(Math.round(t).toString(16)),
    Dd(Math.round(n).toString(16)),
    Dd(UEe(r))
  ];
  return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function UEe(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function m5(e) {
  return Bi(e) / 255;
}
function Bi(e) {
  return parseInt(e, 16);
}
function qEe(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var fC = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function GEe(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, s = null, o = !1, a = !1;
  return typeof e == "string" && (e = JEe(e)), typeof e == "object" && (Ua(e.r) && Ua(e.g) && Ua(e.b) ? (t = jEe(e.r, e.g, e.b), o = !0, a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Ua(e.h) && Ua(e.s) && Ua(e.v) ? (r = db(e.s), i = db(e.v), t = zEe(e.h, r, i), o = !0, a = "hsv") : Ua(e.h) && Ua(e.s) && Ua(e.l) && (r = db(e.s), s = db(e.l), t = VEe(e.h, r, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = hG(n), {
    ok: o,
    format: e.format || a,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var WEe = "[-\\+]?\\d+%?", HEe = "[-\\+]?\\d*\\.\\d+%?", Hu = "(?:".concat(HEe, ")|(?:").concat(WEe, ")"), u$ = "[\\s|\\(]+(".concat(Hu, ")[,|\\s]+(").concat(Hu, ")[,|\\s]+(").concat(Hu, ")\\s*\\)?"), c$ = "[\\s|\\(]+(".concat(Hu, ")[,|\\s]+(").concat(Hu, ")[,|\\s]+(").concat(Hu, ")[,|\\s]+(").concat(Hu, ")\\s*\\)?"), wo = {
  CSS_UNIT: new RegExp(Hu),
  rgb: new RegExp("rgb" + u$),
  rgba: new RegExp("rgba" + c$),
  hsl: new RegExp("hsl" + u$),
  hsla: new RegExp("hsla" + c$),
  hsv: new RegExp("hsv" + u$),
  hsva: new RegExp("hsva" + c$),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function JEe(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (fC[e])
    e = fC[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = wo.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = wo.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = wo.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = wo.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = wo.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = wo.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = wo.hex8.exec(e), n ? {
    r: Bi(n[1]),
    g: Bi(n[2]),
    b: Bi(n[3]),
    a: m5(n[4]),
    format: t ? "name" : "hex8"
  } : (n = wo.hex6.exec(e), n ? {
    r: Bi(n[1]),
    g: Bi(n[2]),
    b: Bi(n[3]),
    format: t ? "name" : "hex"
  } : (n = wo.hex4.exec(e), n ? {
    r: Bi(n[1] + n[1]),
    g: Bi(n[2] + n[2]),
    b: Bi(n[3] + n[3]),
    a: m5(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = wo.hex3.exec(e), n ? {
    r: Bi(n[1] + n[1]),
    g: Bi(n[2] + n[2]),
    b: Bi(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function Ua(e) {
  return !!wo.CSS_UNIT.exec(String(e));
}
var ZEe = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var r;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = qEe(t)), this.originalInput = t;
      var i = GEe(t);
      this.originalInput = t, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, r, i, s = t.r / 255, o = t.g / 255, a = t.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = hG(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = h5(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = h5(this.r, this.g, this.b), n = Math.round(t.h * 360), r = Math.round(t.s * 100), i = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = p5(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = p5(this.r, this.g, this.b), n = Math.round(t.h * 360), r = Math.round(t.s * 100), i = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), f5(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), BEe(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(wr(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(wr(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + f5(this.r, this.g, this.b, !1), n = 0, r = Object.entries(fC); n < r.length; n++) {
        var i = r[n], s = i[0], o = i[1];
        if (t === o)
          return s;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, s = !n && i && (t.startsWith("hex") || t === "name");
      return s ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (r = this.toRgbString()), t === "prgb" && (r = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (r = this.toHexString()), t === "hex3" && (r = this.toHexString(!0)), t === "hex4" && (r = this.toHex8String(!0)), t === "hex8" && (r = this.toHex8String()), t === "name" && (r = this.toName()), t === "hsl" && (r = this.toHslString()), t === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = cb(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = cb(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = cb(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = cb(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), r = (n.h + t) % 360;
      return n.h = r < 0 ? 360 + r : r, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var r = this.toRgb(), i = new e(t).toRgb(), s = n / 100, o = {
        r: (i.r - r.r) * s + r.r,
        g: (i.g - r.g) * s + r.g,
        b: (i.b - r.b) * s + r.b,
        a: (i.a - r.a) * s + r.a
      };
      return new e(o);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var r = this.toHsl(), i = 360 / n, s = [this];
      for (r.h = (r.h - (i * t >> 1) + 720) % 360; --t; )
        r.h = (r.h + i) % 360, s.push(new e(r));
      return s;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / t; t--; )
        o.push(new e({ h: r, s: i, v: s })), s = (s + a) % 1;
      return o;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), r = new e(t).toRgb(), i = n.a + r.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
        a: i
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / t, o = 1; o < t; o++)
        i.push(new e({ h: (r + o * s) % 360, s: n.s, l: n.l }));
      return i;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
);
function tu(e, t = 20) {
  return e.mix("#141414", t).toString();
}
function KEe(e) {
  const t = lm(), n = tt("button");
  return P(() => {
    let r = {};
    const i = e.color;
    if (i) {
      const s = new ZEe(i), o = e.dark ? s.tint(20).toString() : tu(s, 20);
      if (e.plain)
        r = n.cssVarBlock({
          "bg-color": e.dark ? tu(s, 90) : s.tint(90).toString(),
          "text-color": i,
          "border-color": e.dark ? tu(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": o,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": o
        }), t.value && (r[n.cssVarBlockName("disabled-bg-color")] = e.dark ? tu(s, 90) : s.tint(90).toString(), r[n.cssVarBlockName("disabled-text-color")] = e.dark ? tu(s, 50) : s.tint(50).toString(), r[n.cssVarBlockName("disabled-border-color")] = e.dark ? tu(s, 80) : s.tint(80).toString());
      else {
        const a = e.dark ? tu(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (r = n.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), t.value) {
          const c = e.dark ? tu(s, 50) : s.tint(50).toString();
          r[n.cssVarBlockName("disabled-bg-color")] = c, r[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, r[n.cssVarBlockName("disabled-border-color")] = c;
        }
      }
    }
    return r;
  });
}
const YEe = fe({
  name: "ElButton"
}), QEe = /* @__PURE__ */ fe({
  ...YEe,
  props: hC,
  emits: FEe,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = KEe(r), s = tt("button"), { _ref: o, _size: a, _type: l, _disabled: c, _props: p, shouldAddSpace: f, handleClick: m } = PEe(r, n);
    return t({
      ref: o,
      size: a,
      type: l,
      disabled: c,
      shouldAddSpace: f
    }), (y, g) => (F(), ce(Mn(y.tag), ga({
      ref_key: "_ref",
      ref: o
    }, _(p), {
      class: [
        _(s).b(),
        _(s).m(_(l)),
        _(s).m(_(a)),
        _(s).is("disabled", _(c)),
        _(s).is("loading", y.loading),
        _(s).is("plain", y.plain),
        _(s).is("round", y.round),
        _(s).is("circle", y.circle),
        _(s).is("text", y.text),
        _(s).is("link", y.link),
        _(s).is("has-bg", y.bg)
      ],
      style: _(i),
      onClick: _(m)
    }), {
      default: te(() => [
        y.loading ? (F(), X(Ft, { key: 0 }, [
          y.$slots.loading ? je(y.$slots, "loading", { key: 0 }) : (F(), ce(_(Ht), {
            key: 1,
            class: Z(_(s).is("loading"))
          }, {
            default: te(() => [
              (F(), ce(Mn(y.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : y.icon || y.$slots.icon ? (F(), ce(_(Ht), { key: 1 }, {
          default: te(() => [
            y.icon ? (F(), ce(Mn(y.icon), { key: 0 })) : je(y.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : he("v-if", !0),
        y.$slots.default ? (F(), X("span", {
          key: 2,
          class: Z({ [_(s).em("text", "expand")]: _(f) })
        }, [
          je(y.$slots, "default")
        ], 2)) : he("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var XEe = /* @__PURE__ */ at(QEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const eIe = {
  size: hC.size,
  type: hC.type
}, tIe = fe({
  name: "ElButtonGroup"
}), nIe = /* @__PURE__ */ fe({
  ...tIe,
  props: eIe,
  setup(e) {
    const t = e;
    _r(pG, is({
      size: $o(t, "size"),
      type: $o(t, "type")
    }));
    const n = tt("button");
    return (r, i) => (F(), X("div", {
      class: Z(`${_(n).b("group")}`)
    }, [
      je(r.$slots, "default")
    ], 2));
  }
});
var fG = /* @__PURE__ */ at(nIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const d$ = Ai(XEe, {
  ButtonGroup: fG
});
bc(fG);
const Ou = /* @__PURE__ */ new Map();
let y5;
zt && (document.addEventListener("mousedown", (e) => y5 = e), document.addEventListener("mouseup", (e) => {
  for (const t of Ou.values())
    for (const { documentHandler: n } of t)
      n(e, y5);
}));
function g5(e, t) {
  let n = [];
  return Array.isArray(t.arg) ? n = t.arg : uc(t.arg) && n.push(t.arg), function(r, i) {
    const s = t.instance.popperRef, o = r.target, a = i == null ? void 0 : i.target, l = !t || !t.instance, c = !o || !a, p = e.contains(o) || e.contains(a), f = e === o, m = n.length && n.some((g) => g == null ? void 0 : g.contains(o)) || n.length && n.includes(a), y = s && (s.contains(o) || s.contains(a));
    l || c || p || f || m || y || t.value(r, i);
  };
}
const mG = {
  beforeMount(e, t) {
    Ou.has(e) || Ou.set(e, []), Ou.get(e).push({
      documentHandler: g5(e, t),
      bindingFn: t.value
    });
  },
  updated(e, t) {
    Ou.has(e) || Ou.set(e, []);
    const n = Ou.get(e), r = n.findIndex((s) => s.bindingFn === t.oldValue), i = {
      documentHandler: g5(e, t),
      bindingFn: t.value
    };
    r >= 0 ? n.splice(r, 1, i) : n.push(i);
  },
  unmounted(e) {
    Ou.delete(e);
  }
}, yG = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: _c,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, gG = {
  [jt]: (e) => ln(e) || yn(e) || Qr(e),
  change: (e) => ln(e) || yn(e) || Qr(e)
}, um = Symbol("checkboxGroupContextKey"), rIe = ({
  model: e,
  isChecked: t
}) => {
  const n = pt(um, void 0), r = P(() => {
    var s, o;
    const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value, l = (o = n == null ? void 0 : n.min) == null ? void 0 : o.value;
    return !Cf(a) && e.value.length >= a && !t.value || !Cf(l) && e.value.length <= l && t.value;
  });
  return {
    isDisabled: lm(P(() => (n == null ? void 0 : n.disabled.value) || r.value)),
    isLimitDisabled: r
  };
}, iIe = (e, {
  model: t,
  isLimitExceeded: n,
  hasOwnLabel: r,
  isDisabled: i,
  isLabeledByFormItem: s
}) => {
  const o = pt(um, void 0), { formItem: a } = jl(), { emit: l } = ur();
  function c(g) {
    var v, w;
    return g === e.trueLabel || g === !0 ? (v = e.trueLabel) != null ? v : !0 : (w = e.falseLabel) != null ? w : !1;
  }
  function p(g, v) {
    l("change", c(g), v);
  }
  function f(g) {
    if (n.value)
      return;
    const v = g.target;
    l("change", c(v.checked), g);
  }
  async function m(g) {
    n.value || !r.value && !i.value && s.value && (g.composedPath().some((b) => b.tagName === "LABEL") || (t.value = c([!1, e.falseLabel].includes(t.value)), await rt(), p(t.value, g)));
  }
  const y = P(() => (o == null ? void 0 : o.validateEvent) || e.validateEvent);
  return Ie(() => e.modelValue, () => {
    y.value && (a == null || a.validate("change").catch((g) => Zt(g)));
  }), {
    handleChange: f,
    onClickRoot: m
  };
}, sIe = (e) => {
  const t = J(!1), { emit: n } = ur(), r = pt(um, void 0), i = P(() => Cf(r) === !1), s = J(!1);
  return {
    model: P({
      get() {
        var a, l;
        return i.value ? (a = r == null ? void 0 : r.modelValue) == null ? void 0 : a.value : (l = e.modelValue) != null ? l : t.value;
      },
      set(a) {
        var l, c;
        i.value && Pl(a) ? (s.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && a.length > (r == null ? void 0 : r.max.value), s.value === !1 && ((c = r == null ? void 0 : r.changeEvent) == null || c.call(r, a))) : (n(jt, a), t.value = a);
      }
    }),
    isGroup: i,
    isLimitExceeded: s
  };
}, oIe = (e, t, { model: n }) => {
  const r = pt(um, void 0), i = J(!1), s = P(() => {
    const c = n.value;
    return Qr(c) ? c : Pl(c) ? Rr(e.label) ? c.map(uf).some((p) => Qu(p, e.label)) : c.map(uf).includes(e.label) : c != null ? c === e.trueLabel : !!c;
  }), o = Do(P(() => {
    var c;
    return (c = r == null ? void 0 : r.size) == null ? void 0 : c.value;
  }), {
    prop: !0
  }), a = Do(P(() => {
    var c;
    return (c = r == null ? void 0 : r.size) == null ? void 0 : c.value;
  })), l = P(() => !!t.default || !q0(e.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: i,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, aIe = (e, { model: t }) => {
  function n() {
    Pl(t.value) && !t.value.includes(e.label) ? t.value.push(e.label) : t.value = e.trueLabel || !0;
  }
  e.checked && n();
}, vG = (e, t) => {
  const { formItem: n } = jl(), { model: r, isGroup: i, isLimitExceeded: s } = sIe(e), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: p
  } = oIe(e, t, { model: r }), { isDisabled: f } = rIe({ model: r, isChecked: a }), { inputId: m, isLabeledByFormItem: y } = Z0(e, {
    formItemContext: n,
    disableIdGeneration: p,
    disableIdManagement: i
  }), { handleChange: g, onClickRoot: v } = iIe(e, {
    model: r,
    isLimitExceeded: s,
    hasOwnLabel: p,
    isDisabled: f,
    isLabeledByFormItem: y
  });
  return aIe(e, { model: r }), {
    inputId: m,
    isLabeledByFormItem: y,
    isChecked: a,
    isDisabled: f,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: p,
    model: r,
    handleChange: g,
    onClickRoot: v
  };
}, lIe = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], uIe = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], cIe = fe({
  name: "ElCheckbox"
}), dIe = /* @__PURE__ */ fe({
  ...cIe,
  props: yG,
  emits: gG,
  setup(e) {
    const t = e, n = Nf(), {
      inputId: r,
      isLabeledByFormItem: i,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: c,
      model: p,
      handleChange: f,
      onClickRoot: m
    } = vG(t, n), y = tt("checkbox"), g = P(() => [
      y.b(),
      y.m(l.value),
      y.is("disabled", o.value),
      y.is("bordered", t.border),
      y.is("checked", s.value)
    ]), v = P(() => [
      y.e("input"),
      y.is("disabled", o.value),
      y.is("checked", s.value),
      y.is("indeterminate", t.indeterminate),
      y.is("focus", a.value)
    ]);
    return (w, b) => (F(), ce(Mn(!_(c) && _(i) ? "span" : "label"), {
      class: Z(_(g)),
      "aria-controls": w.indeterminate ? w.controls : null,
      onClick: _(m)
    }, {
      default: te(() => [
        ee("span", {
          class: Z(_(v))
        }, [
          w.trueLabel || w.falseLabel ? nn((F(), X("input", {
            key: 0,
            id: _(r),
            "onUpdate:modelValue": b[0] || (b[0] = (S) => $a(p) ? p.value = S : null),
            class: Z(_(y).e("original")),
            type: "checkbox",
            indeterminate: w.indeterminate,
            name: w.name,
            tabindex: w.tabindex,
            disabled: _(o),
            "true-value": w.trueLabel,
            "false-value": w.falseLabel,
            onChange: b[1] || (b[1] = (...S) => _(f) && _(f)(...S)),
            onFocus: b[2] || (b[2] = (S) => a.value = !0),
            onBlur: b[3] || (b[3] = (S) => a.value = !1),
            onClick: b[4] || (b[4] = Dt(() => {
            }, ["stop"]))
          }, null, 42, lIe)), [
            [Yw, _(p)]
          ]) : nn((F(), X("input", {
            key: 1,
            id: _(r),
            "onUpdate:modelValue": b[5] || (b[5] = (S) => $a(p) ? p.value = S : null),
            class: Z(_(y).e("original")),
            type: "checkbox",
            indeterminate: w.indeterminate,
            disabled: _(o),
            value: w.label,
            name: w.name,
            tabindex: w.tabindex,
            onChange: b[6] || (b[6] = (...S) => _(f) && _(f)(...S)),
            onFocus: b[7] || (b[7] = (S) => a.value = !0),
            onBlur: b[8] || (b[8] = (S) => a.value = !1),
            onClick: b[9] || (b[9] = Dt(() => {
            }, ["stop"]))
          }, null, 42, uIe)), [
            [Yw, _(p)]
          ]),
          ee("span", {
            class: Z(_(y).e("inner"))
          }, null, 2)
        ], 2),
        _(c) ? (F(), X("span", {
          key: 0,
          class: Z(_(y).e("label"))
        }, [
          je(w.$slots, "default"),
          w.$slots.default ? he("v-if", !0) : (F(), X(Ft, { key: 0 }, [
            Kn(it(w.label), 1)
          ], 64))
        ], 2)) : he("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var pIe = /* @__PURE__ */ at(dIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const hIe = ["name", "tabindex", "disabled", "true-value", "false-value"], fIe = ["name", "tabindex", "disabled", "value"], mIe = fe({
  name: "ElCheckboxButton"
}), yIe = /* @__PURE__ */ fe({
  ...mIe,
  props: yG,
  emits: gG,
  setup(e) {
    const t = e, n = Nf(), {
      isFocused: r,
      isChecked: i,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = vG(t, n), c = pt(um, void 0), p = tt("checkbox"), f = P(() => {
      var y, g, v, w;
      const b = (g = (y = c == null ? void 0 : c.fill) == null ? void 0 : y.value) != null ? g : "";
      return {
        backgroundColor: b,
        borderColor: b,
        color: (w = (v = c == null ? void 0 : c.textColor) == null ? void 0 : v.value) != null ? w : "",
        boxShadow: b ? `-1px 0 0 0 ${b}` : void 0
      };
    }), m = P(() => [
      p.b("button"),
      p.bm("button", o.value),
      p.is("disabled", s.value),
      p.is("checked", i.value),
      p.is("focus", r.value)
    ]);
    return (y, g) => (F(), X("label", {
      class: Z(_(m))
    }, [
      y.trueLabel || y.falseLabel ? nn((F(), X("input", {
        key: 0,
        "onUpdate:modelValue": g[0] || (g[0] = (v) => $a(a) ? a.value = v : null),
        class: Z(_(p).be("button", "original")),
        type: "checkbox",
        name: y.name,
        tabindex: y.tabindex,
        disabled: _(s),
        "true-value": y.trueLabel,
        "false-value": y.falseLabel,
        onChange: g[1] || (g[1] = (...v) => _(l) && _(l)(...v)),
        onFocus: g[2] || (g[2] = (v) => r.value = !0),
        onBlur: g[3] || (g[3] = (v) => r.value = !1),
        onClick: g[4] || (g[4] = Dt(() => {
        }, ["stop"]))
      }, null, 42, hIe)), [
        [Yw, _(a)]
      ]) : nn((F(), X("input", {
        key: 1,
        "onUpdate:modelValue": g[5] || (g[5] = (v) => $a(a) ? a.value = v : null),
        class: Z(_(p).be("button", "original")),
        type: "checkbox",
        name: y.name,
        tabindex: y.tabindex,
        disabled: _(s),
        value: y.label,
        onChange: g[6] || (g[6] = (...v) => _(l) && _(l)(...v)),
        onFocus: g[7] || (g[7] = (v) => r.value = !0),
        onBlur: g[8] || (g[8] = (v) => r.value = !1),
        onClick: g[9] || (g[9] = Dt(() => {
        }, ["stop"]))
      }, null, 42, fIe)), [
        [Yw, _(a)]
      ]),
      y.$slots.default || y.label ? (F(), X("span", {
        key: 2,
        class: Z(_(p).be("button", "inner")),
        style: It(_(i) ? _(f) : void 0)
      }, [
        je(y.$slots, "default", {}, () => [
          Kn(it(y.label), 1)
        ])
      ], 6)) : he("v-if", !0)
    ], 2));
  }
});
var bG = /* @__PURE__ */ at(yIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const gIe = bt({
  modelValue: {
    type: Be(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: _c,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), vIe = {
  [jt]: (e) => Pl(e),
  change: (e) => Pl(e)
}, bIe = fe({
  name: "ElCheckboxGroup"
}), wIe = /* @__PURE__ */ fe({
  ...bIe,
  props: gIe,
  emits: vIe,
  setup(e, { emit: t }) {
    const n = e, r = tt("checkbox"), { formItem: i } = jl(), { inputId: s, isLabeledByFormItem: o } = Z0(n, {
      formItemContext: i
    }), a = async (c) => {
      t(jt, c), await rt(), t("change", c);
    }, l = P({
      get() {
        return n.modelValue;
      },
      set(c) {
        a(c);
      }
    });
    return _r(um, {
      ...qSe(hc(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), Ie(() => n.modelValue, () => {
      n.validateEvent && (i == null || i.validate("change").catch((c) => Zt(c)));
    }), (c, p) => {
      var f;
      return F(), ce(Mn(c.tag), {
        id: _(s),
        class: Z(_(r).b("group")),
        role: "group",
        "aria-label": _(o) ? void 0 : c.label || "checkbox-group",
        "aria-labelledby": _(o) ? (f = _(i)) == null ? void 0 : f.labelId : void 0
      }, {
        default: te(() => [
          je(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var wG = /* @__PURE__ */ at(wIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const _Ie = Ai(pIe, {
  CheckboxButton: bG,
  CheckboxGroup: wG
});
bc(bG);
bc(wG);
const _G = bt({
  size: _c,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), SIe = bt({
  ..._G,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), SG = {
  [jt]: (e) => ln(e) || yn(e) || Qr(e),
  [Oa]: (e) => ln(e) || yn(e) || Qr(e)
}, xG = Symbol("radioGroupKey"), $G = (e, t) => {
  const n = J(), r = pt(xG, void 0), i = P(() => !!r), s = P({
    get() {
      return i.value ? r.modelValue : e.modelValue;
    },
    set(p) {
      i.value ? r.changeEvent(p) : t && t(jt, p), n.value.checked = e.modelValue === e.label;
    }
  }), o = Do(P(() => r == null ? void 0 : r.size)), a = lm(P(() => r == null ? void 0 : r.disabled)), l = J(!1), c = P(() => a.value || i.value && s.value !== e.label ? -1 : 0);
  return {
    radioRef: n,
    isGroup: i,
    radioGroup: r,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: c,
    modelValue: s
  };
}, xIe = ["value", "name", "disabled"], $Ie = fe({
  name: "ElRadio"
}), TIe = /* @__PURE__ */ fe({
  ...$Ie,
  props: SIe,
  emits: SG,
  setup(e, { emit: t }) {
    const n = e, r = tt("radio"), { radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: c } = $G(n, t);
    function p() {
      rt(() => t("change", c.value));
    }
    return (f, m) => {
      var y;
      return F(), X("label", {
        class: Z([
          _(r).b(),
          _(r).is("disabled", _(l)),
          _(r).is("focus", _(o)),
          _(r).is("bordered", f.border),
          _(r).is("checked", _(c) === f.label),
          _(r).m(_(a))
        ])
      }, [
        ee("span", {
          class: Z([
            _(r).e("input"),
            _(r).is("disabled", _(l)),
            _(r).is("checked", _(c) === f.label)
          ])
        }, [
          nn(ee("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": m[0] || (m[0] = (g) => $a(c) ? c.value = g : null),
            class: Z(_(r).e("original")),
            value: f.label,
            name: f.name || ((y = _(s)) == null ? void 0 : y.name),
            disabled: _(l),
            type: "radio",
            onFocus: m[1] || (m[1] = (g) => o.value = !0),
            onBlur: m[2] || (m[2] = (g) => o.value = !1),
            onChange: p,
            onClick: m[3] || (m[3] = Dt(() => {
            }, ["stop"]))
          }, null, 42, xIe), [
            [Q5, _(c)]
          ]),
          ee("span", {
            class: Z(_(r).e("inner"))
          }, null, 2)
        ], 2),
        ee("span", {
          class: Z(_(r).e("label")),
          onKeydown: m[4] || (m[4] = Dt(() => {
          }, ["stop"]))
        }, [
          je(f.$slots, "default", {}, () => [
            Kn(it(f.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var EIe = /* @__PURE__ */ at(TIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const IIe = bt({
  ..._G,
  name: {
    type: String,
    default: ""
  }
}), MIe = ["value", "name", "disabled"], CIe = fe({
  name: "ElRadioButton"
}), OIe = /* @__PURE__ */ fe({
  ...CIe,
  props: IIe,
  setup(e) {
    const t = e, n = tt("radio"), { radioRef: r, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = $G(t), c = P(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (p, f) => {
      var m;
      return F(), X("label", {
        class: Z([
          _(n).b("button"),
          _(n).is("active", _(a) === p.label),
          _(n).is("disabled", _(o)),
          _(n).is("focus", _(i)),
          _(n).bm("button", _(s))
        ])
      }, [
        nn(ee("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": f[0] || (f[0] = (y) => $a(a) ? a.value = y : null),
          class: Z(_(n).be("button", "original-radio")),
          value: p.label,
          type: "radio",
          name: p.name || ((m = _(l)) == null ? void 0 : m.name),
          disabled: _(o),
          onFocus: f[1] || (f[1] = (y) => i.value = !0),
          onBlur: f[2] || (f[2] = (y) => i.value = !1),
          onClick: f[3] || (f[3] = Dt(() => {
          }, ["stop"]))
        }, null, 42, MIe), [
          [Q5, _(a)]
        ]),
        ee("span", {
          class: Z(_(n).be("button", "inner")),
          style: It(_(a) === p.label ? _(c) : {}),
          onKeydown: f[4] || (f[4] = Dt(() => {
          }, ["stop"]))
        }, [
          je(p.$slots, "default", {}, () => [
            Kn(it(p.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var TG = /* @__PURE__ */ at(OIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const kIe = bt({
  id: {
    type: String,
    default: void 0
  },
  size: _c,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), AIe = SG, PIe = ["id", "aria-label", "aria-labelledby"], RIe = fe({
  name: "ElRadioGroup"
}), LIe = /* @__PURE__ */ fe({
  ...RIe,
  props: kIe,
  emits: AIe,
  setup(e, { emit: t }) {
    const n = e, r = tt("radio"), i = dc(), s = J(), { formItem: o } = jl(), { inputId: a, isLabeledByFormItem: l } = Z0(n, {
      formItemContext: o
    }), c = (f) => {
      t(jt, f), rt(() => t("change", f));
    };
    Yt(() => {
      const f = s.value.querySelectorAll("[type=radio]"), m = f[0];
      !Array.from(f).some((y) => y.checked) && m && (m.tabIndex = 0);
    });
    const p = P(() => n.name || i.value);
    return _r(xG, is({
      ...hc(n),
      changeEvent: c,
      name: p
    })), Ie(() => n.modelValue, () => {
      n.validateEvent && (o == null || o.validate("change").catch((f) => Zt(f)));
    }), (f, m) => (F(), X("div", {
      id: _(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: Z(_(r).b("group")),
      role: "radiogroup",
      "aria-label": _(l) ? void 0 : f.label || "radio-group",
      "aria-labelledby": _(l) ? _(o).labelId : void 0
    }, [
      je(f.$slots, "default")
    ], 10, PIe));
  }
});
var EG = /* @__PURE__ */ at(LIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
const ua = Ai(EIe, {
  RadioButton: TG,
  RadioGroup: EG
}), pb = bc(EG);
bc(TG);
var FIe = fe({
  name: "NodeContent",
  setup() {
    return {
      ns: tt("cascader-node")
    };
  },
  render() {
    const { ns: e } = this, { node: t, panel: n } = this.$parent, { data: r, label: i } = t, { renderLabelFn: s } = n;
    return vl("span", { class: e.e("label") }, s ? s({ node: t, data: r }) : i);
  }
});
const z3 = Symbol(), NIe = fe({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: _Ie,
    ElRadio: ua,
    NodeContent: FIe,
    ElIcon: Ht,
    Check: gq,
    Loading: G0,
    ArrowRight: QSe
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, { emit: t }) {
    const n = pt(z3), r = tt("cascader-node"), i = P(() => n.isHoverMenu), s = P(() => n.config.multiple), o = P(() => n.config.checkStrictly), a = P(() => {
      var E;
      return (E = n.checkedNodes[0]) == null ? void 0 : E.uid;
    }), l = P(() => e.node.isDisabled), c = P(() => e.node.isLeaf), p = P(() => o.value && !c.value || !l.value), f = P(() => y(n.expandingNode)), m = P(() => o.value && n.checkedNodes.some(y)), y = (E) => {
      var C;
      const { level: A, uid: W } = e.node;
      return ((C = E == null ? void 0 : E.pathNodes[A - 1]) == null ? void 0 : C.uid) === W;
    }, g = () => {
      f.value || n.expandNode(e.node);
    }, v = (E) => {
      const { node: C } = e;
      E !== C.checked && n.handleCheckChange(C, E);
    }, w = () => {
      n.lazyLoad(e.node, () => {
        c.value || g();
      });
    }, b = (E) => {
      i.value && (S(), !c.value && t("expand", E));
    }, S = () => {
      const { node: E } = e;
      !p.value || E.loading || (E.loaded ? g() : w());
    }, $ = () => {
      i.value && !c.value || (c.value && !l.value && !o.value && !s.value ? M(!0) : S());
    }, I = (E) => {
      o.value ? (v(E), e.node.loaded && g()) : M(E);
    }, M = (E) => {
      e.node.loaded ? (v(E), !o.value && g()) : w();
    };
    return {
      panel: n,
      isHoverMenu: i,
      multiple: s,
      checkStrictly: o,
      checkedNodeId: a,
      isDisabled: l,
      isLeaf: c,
      expandable: p,
      inExpandingPath: f,
      inCheckedPath: m,
      ns: r,
      handleHoverExpand: b,
      handleExpand: S,
      handleClick: $,
      handleCheck: M,
      handleSelectCheck: I
    };
  }
}), DIe = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], jIe = /* @__PURE__ */ ee("span", null, null, -1);
function VIe(e, t, n, r, i, s) {
  const o = Vn("el-checkbox"), a = Vn("el-radio"), l = Vn("check"), c = Vn("el-icon"), p = Vn("node-content"), f = Vn("loading"), m = Vn("arrow-right");
  return F(), X("li", {
    id: `${e.menuId}-${e.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !e.isLeaf,
    "aria-owns": e.isLeaf ? null : e.menuId,
    "aria-expanded": e.inExpandingPath,
    tabindex: e.expandable ? -1 : void 0,
    class: Z([
      e.ns.b(),
      e.ns.is("selectable", e.checkStrictly),
      e.ns.is("active", e.node.checked),
      e.ns.is("disabled", !e.expandable),
      e.inExpandingPath && "in-active-path",
      e.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: t[2] || (t[2] = (...y) => e.handleHoverExpand && e.handleHoverExpand(...y)),
    onFocus: t[3] || (t[3] = (...y) => e.handleHoverExpand && e.handleHoverExpand(...y)),
    onClick: t[4] || (t[4] = (...y) => e.handleClick && e.handleClick(...y))
  }, [
    he(" prefix "),
    e.multiple ? (F(), ce(o, {
      key: 0,
      "model-value": e.node.checked,
      indeterminate: e.node.indeterminate,
      disabled: e.isDisabled,
      onClick: t[0] || (t[0] = Dt(() => {
      }, ["stop"])),
      "onUpdate:modelValue": e.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (F(), ce(a, {
      key: 1,
      "model-value": e.checkedNodeId,
      label: e.node.uid,
      disabled: e.isDisabled,
      "onUpdate:modelValue": e.handleSelectCheck,
      onClick: t[1] || (t[1] = Dt(() => {
      }, ["stop"]))
    }, {
      default: te(() => [
        he(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        jIe
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (F(), ce(c, {
      key: 2,
      class: Z(e.ns.e("prefix"))
    }, {
      default: te(() => [
        ye(l)
      ]),
      _: 1
    }, 8, ["class"])) : he("v-if", !0),
    he(" content "),
    ye(p),
    he(" postfix "),
    e.isLeaf ? he("v-if", !0) : (F(), X(Ft, { key: 3 }, [
      e.node.loading ? (F(), ce(c, {
        key: 0,
        class: Z([e.ns.is("loading"), e.ns.e("postfix")])
      }, {
        default: te(() => [
          ye(f)
        ]),
        _: 1
      }, 8, ["class"])) : (F(), ce(c, {
        key: 1,
        class: Z(["arrow-right", e.ns.e("postfix")])
      }, {
        default: te(() => [
          ye(m)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, DIe);
}
var zIe = /* @__PURE__ */ at(NIe, [["render", VIe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const BIe = fe({
  name: "ElCascaderMenu",
  components: {
    Loading: G0,
    ElIcon: Ht,
    ElScrollbar: F3,
    ElCascaderNode: zIe
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = ur(), n = tt("cascader-menu"), { t: r } = Dp(), i = v2e();
    let s = null, o = null;
    const a = pt(z3), l = J(null), c = P(() => !e.nodes.length), p = P(() => !a.initialLoaded), f = P(() => `cascader-menu-${i}-${e.index}`), m = (w) => {
      s = w.target;
    }, y = (w) => {
      if (!(!a.isHoverMenu || !s || !l.value))
        if (s.contains(w.target)) {
          g();
          const b = t.vnode.el, { left: S } = b.getBoundingClientRect(), { offsetWidth: $, offsetHeight: I } = b, M = w.clientX - S, E = s.offsetTop, C = E + s.offsetHeight;
          l.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${M} ${E} L${$} 0 V${E} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${M} ${C} L${$} ${I} V${C} Z" />
        `;
        } else
          o || (o = window.setTimeout(v, a.config.hoverThreshold));
    }, g = () => {
      o && (clearTimeout(o), o = null);
    }, v = () => {
      l.value && (l.value.innerHTML = "", g());
    };
    return {
      ns: n,
      panel: a,
      hoverZone: l,
      isEmpty: c,
      isLoading: p,
      menuId: f,
      t: r,
      handleExpand: m,
      handleMouseMove: y,
      clearHoverZone: v
    };
  }
});
function UIe(e, t, n, r, i, s) {
  const o = Vn("el-cascader-node"), a = Vn("loading"), l = Vn("el-icon"), c = Vn("el-scrollbar");
  return F(), ce(c, {
    key: e.menuId,
    tag: "ul",
    role: "menu",
    class: Z(e.ns.b()),
    "wrap-class": e.ns.e("wrap"),
    "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
    onMousemove: e.handleMouseMove,
    onMouseleave: e.clearHoverZone
  }, {
    default: te(() => {
      var p;
      return [
        (F(!0), X(Ft, null, bi(e.nodes, (f) => (F(), ce(o, {
          key: f.uid,
          node: f,
          "menu-id": e.menuId,
          onExpand: e.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        e.isLoading ? (F(), X("div", {
          key: 0,
          class: Z(e.ns.e("empty-text"))
        }, [
          ye(l, {
            size: "14",
            class: Z(e.ns.is("loading"))
          }, {
            default: te(() => [
              ye(a)
            ]),
            _: 1
          }, 8, ["class"]),
          Kn(" " + it(e.t("el.cascader.loading")), 1)
        ], 2)) : e.isEmpty ? (F(), X("div", {
          key: 1,
          class: Z(e.ns.e("empty-text"))
        }, it(e.t("el.cascader.noData")), 3)) : (p = e.panel) != null && p.isHoverMenu ? (F(), X("svg", {
          key: 2,
          ref: "hoverZone",
          class: Z(e.ns.e("hover-zone"))
        }, null, 2)) : he("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var qIe = /* @__PURE__ */ at(BIe, [["render", UIe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let GIe = 0;
const WIe = (e) => {
  const t = [e];
  let { parent: n } = e;
  for (; n; )
    t.unshift(n), n = n.parent;
  return t;
};
let mC = class yC {
  constructor(t, n, r, i = !1) {
    this.data = t, this.config = n, this.parent = r, this.root = i, this.uid = GIe++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: s, label: o, children: a } = n, l = t[a], c = WIe(this);
    this.level = i ? 0 : r ? r.level + 1 : 1, this.value = t[s], this.label = t[o], this.pathNodes = c, this.pathValues = c.map((p) => p.value), this.pathLabels = c.map((p) => p.label), this.childrenData = l, this.children = (l || []).map((p) => new yC(p, n, this)), this.loaded = !n.lazy || this.isLeaf || !QM(l);
  }
  get isDisabled() {
    const { data: t, parent: n, config: r } = this, { disabled: i, checkStrictly: s } = r;
    return (an(i) ? i(t, this) : !!t[i]) || !s && (n == null ? void 0 : n.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: n, childrenData: r, loaded: i } = this, { lazy: s, leaf: o } = n, a = an(o) ? o(t, this) : t[o];
    return Cf(a) ? s && !i ? !1 : !(Array.isArray(r) && r.length) : !!a;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: n, children: r } = this, i = new yC(t, this.config, this);
    return Array.isArray(n) ? n.push(t) : this.childrenData = [t], r.push(i), i;
  }
  calcText(t, n) {
    const r = t ? this.pathLabels.join(n) : this.label;
    return this.text = r, r;
  }
  broadcast(t, ...n) {
    const r = `onParent${I4(t)}`;
    this.children.forEach((i) => {
      i && (i.broadcast(t, ...n), i[r] && i[r](...n));
    });
  }
  emit(t, ...n) {
    const { parent: r } = this, i = `onChild${I4(t)}`;
    r && (r[i] && r[i](...n), r.emit(t, ...n));
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, n = t.filter((i) => !i.isDisabled), r = n.length ? n.every((i) => i.checked) : !1;
    this.setCheckState(r);
  }
  setCheckState(t) {
    const n = this.children.length, r = this.children.reduce((i, s) => {
      const o = s.checked ? 1 : s.indeterminate ? 0.5 : 0;
      return i + o;
    }, 0);
    this.checked = this.loaded && this.children.filter((i) => !i.isDisabled).every((i) => i.loaded && i.checked) && t, this.indeterminate = this.loaded && r !== n && r > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: n, multiple: r } = this.config;
    n || !r ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
  }
};
const gC = (e, t) => e.reduce((n, r) => (r.isLeaf ? n.push(r) : (!t && n.push(r), n = n.concat(gC(r.children, t))), n), []);
class v5 {
  constructor(t, n) {
    this.config = n;
    const r = (t || []).map((i) => new mC(i, this.config));
    this.nodes = r, this.allNodes = gC(r, !1), this.leafNodes = gC(r, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, n) {
    const r = n ? n.appendChild(t) : new mC(t, this.config);
    n || this.nodes.push(r), this.allNodes.push(r), r.isLeaf && this.leafNodes.push(r);
  }
  appendNodes(t, n) {
    t.forEach((r) => this.appendNode(r, n));
  }
  getNodeByValue(t, n = !1) {
    return !t && t !== 0 ? null : this.getFlattedNodes(n).find((i) => Qu(i.value, t) || Qu(i.pathValues, t)) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(!1).find(({ value: r, level: i }) => Qu(t.value, r) && t.level === i) || null;
  }
}
const IG = bt({
  modelValue: {
    type: Be([Number, String, Array])
  },
  options: {
    type: Be(Array),
    default: () => []
  },
  props: {
    type: Be(Object),
    default: () => ({})
  }
}), HIe = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: _a,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, JIe = (e) => P(() => ({
  ...HIe,
  ...e.props
})), b5 = (e) => {
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2]);
}, ZIe = (e) => {
  if (!e)
    return;
  const t = e.querySelector("input");
  t ? t.click() : LU(e) && e.click();
}, KIe = (e, t) => {
  const n = t.slice(0), r = n.map((s) => s.uid), i = e.reduce((s, o) => {
    const a = r.indexOf(o.uid);
    return a > -1 && (s.push(o), n.splice(a, 1), r.splice(a, 1)), s;
  }, []);
  return i.push(...n), i;
}, YIe = fe({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: qIe
  },
  props: {
    ...IG,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [jt, Oa, "close", "expand-change"],
  setup(e, { emit: t, slots: n }) {
    let r = !1;
    const i = tt("cascader"), s = JIe(e);
    let o = null;
    const a = J(!0), l = J([]), c = J(null), p = J([]), f = J(null), m = J([]), y = P(() => s.value.expandTrigger === "hover"), g = P(() => e.renderLabel || n.default), v = () => {
      const { options: R } = e, V = s.value;
      r = !1, o = new v5(R, V), p.value = [o.getNodes()], V.lazy && QM(e.options) ? (a.value = !1, w(void 0, (Q) => {
        Q && (o = new v5(Q, V), p.value = [o.getNodes()]), a.value = !0, A(!1, !0);
      })) : A(!1, !0);
    }, w = (R, V) => {
      const Q = s.value;
      R = R || new mC({}, Q, void 0, !0), R.loading = !0;
      const de = (_e) => {
        const ie = R, Ae = ie.root ? null : ie;
        _e && (o == null || o.appendNodes(_e, Ae)), ie.loading = !1, ie.loaded = !0, ie.childrenData = ie.childrenData || [], V && V(_e);
      };
      Q.lazyLoad(R, de);
    }, b = (R, V) => {
      var Q;
      const { level: de } = R, _e = p.value.slice(0, de);
      let ie;
      R.isLeaf ? ie = R.pathNodes[de - 2] : (ie = R, _e.push(R.children)), ((Q = f.value) == null ? void 0 : Q.uid) !== (ie == null ? void 0 : ie.uid) && (f.value = R, p.value = _e, !V && t("expand-change", (R == null ? void 0 : R.pathValues) || []));
    }, S = (R, V, Q = !0) => {
      const { checkStrictly: de, multiple: _e } = s.value, ie = m.value[0];
      r = !0, !_e && (ie == null || ie.doCheck(!1)), R.doCheck(V), C(), Q && !_e && !de && t("close"), !Q && !_e && !de && $(R);
    }, $ = (R) => {
      R && (R = R.parent, $(R), R && b(R));
    }, I = (R) => o == null ? void 0 : o.getFlattedNodes(R), M = (R) => {
      var V;
      return (V = I(R)) == null ? void 0 : V.filter((Q) => Q.checked !== !1);
    }, E = () => {
      m.value.forEach((R) => R.doCheck(!1)), C(), p.value = p.value.slice(0, 1), f.value = null, t("expand-change", []);
    }, C = () => {
      var R;
      const { checkStrictly: V, multiple: Q } = s.value, de = m.value, _e = M(!V), ie = KIe(de, _e), Ae = ie.map((Pe) => Pe.valueByOption);
      m.value = ie, c.value = Q ? Ae : (R = Ae[0]) != null ? R : null;
    }, A = (R = !1, V = !1) => {
      const { modelValue: Q } = e, { lazy: de, multiple: _e, checkStrictly: ie } = s.value, Ae = !ie;
      if (!(!a.value || r || !V && Qu(Q, c.value)))
        if (de && !R) {
          const Bt = O4(VSe(k4(Q))).map((wt) => o == null ? void 0 : o.getNodeByValue(wt)).filter((wt) => !!wt && !wt.loaded && !wt.loading);
          Bt.length ? Bt.forEach((wt) => {
            w(wt, () => A(!1, V));
          }) : A(!0, V);
        } else {
          const Pe = _e ? k4(Q) : [Q], Bt = O4(Pe.map((wt) => o == null ? void 0 : o.getNodeByValue(wt, Ae)));
          W(Bt, V), c.value = oq(Q);
        }
    }, W = (R, V = !0) => {
      const { checkStrictly: Q } = s.value, de = m.value, _e = R.filter((Pe) => !!Pe && (Q || Pe.isLeaf)), ie = o == null ? void 0 : o.getSameNode(f.value), Ae = V && ie || _e[0];
      Ae ? Ae.pathNodes.forEach((Pe) => b(Pe, !0)) : f.value = null, de.forEach((Pe) => Pe.doCheck(!1)), e.props.multiple ? is(_e).forEach((Pe) => Pe.doCheck(!0)) : _e.forEach((Pe) => Pe.doCheck(!0)), m.value = _e, rt(j);
    }, j = () => {
      zt && l.value.forEach((R) => {
        const V = R == null ? void 0 : R.$el;
        if (V) {
          const Q = V.querySelector(`.${i.namespace.value}-scrollbar__wrap`), de = V.querySelector(`.${i.b("node")}.${i.is("active")}`) || V.querySelector(`.${i.b("node")}.in-active-path`);
          mq(Q, de);
        }
      });
    }, G = (R) => {
      const V = R.target, { code: Q } = R;
      switch (Q) {
        case on.up:
        case on.down: {
          R.preventDefault();
          const de = Q === on.up ? -1 : 1;
          Nw(FU(V, de, `.${i.b("node")}[tabindex="-1"]`));
          break;
        }
        case on.left: {
          R.preventDefault();
          const de = l.value[b5(V) - 1], _e = de == null ? void 0 : de.$el.querySelector(`.${i.b("node")}[aria-expanded="true"]`);
          Nw(_e);
          break;
        }
        case on.right: {
          R.preventDefault();
          const de = l.value[b5(V) + 1], _e = de == null ? void 0 : de.$el.querySelector(`.${i.b("node")}[tabindex="-1"]`);
          Nw(_e);
          break;
        }
        case on.enter:
          ZIe(V);
          break;
      }
    };
    return _r(z3, is({
      config: s,
      expandingNode: f,
      checkedNodes: m,
      isHoverMenu: y,
      initialLoaded: a,
      renderLabelFn: g,
      lazyLoad: w,
      expandNode: b,
      handleCheckChange: S
    })), Ie([s, () => e.options], v, {
      deep: !0,
      immediate: !0
    }), Ie(() => e.modelValue, () => {
      r = !1, A();
    }, {
      deep: !0
    }), Ie(() => c.value, (R) => {
      Qu(R, e.modelValue) || (t(jt, R), t(Oa, R));
    }), OW(() => l.value = []), Yt(() => !QM(e.modelValue) && A()), {
      ns: i,
      menuList: l,
      menus: p,
      checkedNodes: m,
      handleKeyDown: G,
      handleCheckChange: S,
      getFlattedNodes: I,
      getCheckedNodes: M,
      clearCheckedNodes: E,
      calculateCheckedValue: C,
      scrollToExpandingNode: j
    };
  }
});
function QIe(e, t, n, r, i, s) {
  const o = Vn("el-cascader-menu");
  return F(), X("div", {
    class: Z([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
    onKeydown: t[0] || (t[0] = (...a) => e.handleKeyDown && e.handleKeyDown(...a))
  }, [
    (F(!0), X(Ft, null, bi(e.menus, (a, l) => (F(), ce(o, {
      key: l,
      ref_for: !0,
      ref: (c) => e.menuList[l] = c,
      index: l,
      nodes: [...a]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var Uw = /* @__PURE__ */ at(YIe, [["render", QIe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
Uw.install = (e) => {
  e.component(Uw.name, Uw);
};
const XIe = Uw, B3 = bt({
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: W0,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), eMe = {
  close: (e) => e instanceof MouseEvent,
  click: (e) => e instanceof MouseEvent
}, tMe = fe({
  name: "ElTag"
}), nMe = /* @__PURE__ */ fe({
  ...tMe,
  props: B3,
  emits: eMe,
  setup(e, { emit: t }) {
    const n = e, r = Do(), i = tt("tag"), s = P(() => {
      const { type: l, hit: c, effect: p, closable: f, round: m } = n;
      return [
        i.b(),
        i.is("closable", f),
        i.m(l),
        i.m(r.value),
        i.m(p),
        i.is("hit", c),
        i.is("round", m)
      ];
    }), o = (l) => {
      t("close", l);
    }, a = (l) => {
      t("click", l);
    };
    return (l, c) => l.disableTransitions ? (F(), X("span", {
      key: 0,
      class: Z(_(s)),
      style: It({ backgroundColor: l.color }),
      onClick: a
    }, [
      ee("span", {
        class: Z(_(i).e("content"))
      }, [
        je(l.$slots, "default")
      ], 2),
      l.closable ? (F(), ce(_(Ht), {
        key: 0,
        class: Z(_(i).e("close")),
        onClick: Dt(o, ["stop"])
      }, {
        default: te(() => [
          ye(_(S_))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : he("v-if", !0)
    ], 6)) : (F(), ce(ko, {
      key: 1,
      name: `${_(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: te(() => [
        ee("span", {
          class: Z(_(s)),
          style: It({ backgroundColor: l.color }),
          onClick: a
        }, [
          ee("span", {
            class: Z(_(i).e("content"))
          }, [
            je(l.$slots, "default")
          ], 2),
          l.closable ? (F(), ce(_(Ht), {
            key: 0,
            class: Z(_(i).e("close")),
            onClick: Dt(o, ["stop"])
          }, {
            default: te(() => [
              ye(_(S_))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : he("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var rMe = /* @__PURE__ */ at(nMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const vC = Ai(rMe), iMe = bt({
  ...IG,
  size: _c,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: Be(Function),
    default: (e, t) => e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Be(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: t2.teleported,
  tagType: { ...B3.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), sMe = {
  [jt]: (e) => !!e || e === null,
  [Oa]: (e) => !!e || e === null,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  visibleChange: (e) => Qr(e),
  expandChange: (e) => !!e,
  removeTag: (e) => !!e
}, oMe = { key: 0 }, aMe = ["placeholder", "onKeydown"], lMe = ["onClick"], uMe = "ElCascader", cMe = fe({
  name: uMe
}), dMe = /* @__PURE__ */ fe({
  ...cMe,
  props: iMe,
  emits: sMe,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: re }) => {
            const { modifiersData: me, placement: Ee } = re;
            ["right", "left", "bottom", "top"].includes(Ee) || (me.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, s = Z5();
    let o = 0, a = 0;
    const l = tt("cascader"), c = tt("input"), { t: p } = Dp(), { form: f, formItem: m } = jl(), y = J(null), g = J(null), v = J(null), w = J(null), b = J(null), S = J(!1), $ = J(!1), I = J(!1), M = J(!1), E = J(""), C = J(""), A = J([]), W = J([]), j = J([]), G = J(!1), R = P(() => s.style), V = P(() => r.disabled || (f == null ? void 0 : f.disabled)), Q = P(() => r.placeholder || p("el.cascader.placeholder")), de = P(() => C.value || A.value.length > 0 || G.value ? "" : Q.value), _e = Do(), ie = P(() => ["small"].includes(_e.value) ? "small" : "default"), Ae = P(() => !!r.props.multiple), Pe = P(() => !r.filterable || Ae.value), Bt = P(() => Ae.value ? C.value : E.value), wt = P(() => {
      var re;
      return ((re = w.value) == null ? void 0 : re.checkedNodes) || [];
    }), Ut = P(() => !r.clearable || V.value || I.value || !$.value ? !1 : !!wt.value.length), un = P(() => {
      const { showAllLevels: re, separator: me } = r, Ee = wt.value;
      return Ee.length ? Ae.value ? "" : Ee[0].calcText(re, me) : "";
    }), An = P({
      get() {
        return oq(r.modelValue);
      },
      set(re) {
        n(jt, re), n(Oa, re), r.validateEvent && (m == null || m.validate("change").catch((me) => Zt(me)));
      }
    }), Pn = P(() => [
      l.b(),
      l.m(_e.value),
      l.is("disabled", V.value),
      s.class
    ]), Un = P(() => [
      c.e("icon"),
      "icon-arrow-down",
      l.is("reverse", S.value)
    ]), Me = P(() => l.is("focus", S.value || M.value)), Ue = P(() => {
      var re, me;
      return (me = (re = y.value) == null ? void 0 : re.popperRef) == null ? void 0 : me.contentRef;
    }), Xe = (re) => {
      var me, Ee, yt;
      V.value || (re = re ?? !S.value, re !== S.value && (S.value = re, (Ee = (me = g.value) == null ? void 0 : me.input) == null || Ee.setAttribute("aria-expanded", `${re}`), re ? (lt(), rt((yt = w.value) == null ? void 0 : yt.scrollToExpandingNode)) : r.filterable && si(), n("visibleChange", re)));
    }, lt = () => {
      rt(() => {
        var re;
        (re = y.value) == null || re.updatePopper();
      });
    }, Tt = () => {
      I.value = !1;
    }, bn = (re) => {
      const { showAllLevels: me, separator: Ee } = r;
      return {
        node: re,
        key: re.uid,
        text: re.calcText(me, Ee),
        hitState: !1,
        closable: !V.value && !re.isDisabled,
        isCollapseTag: !1
      };
    }, tr = (re) => {
      var me;
      const Ee = re.node;
      Ee.doCheck(!1), (me = w.value) == null || me.calculateCheckedValue(), n("removeTag", Ee.valueByOption);
    }, Pi = () => {
      if (!Ae.value)
        return;
      const re = wt.value, me = [], Ee = [];
      if (re.forEach((yt) => Ee.push(bn(yt))), W.value = Ee, re.length) {
        re.slice(0, r.maxCollapseTags).forEach((nr) => me.push(bn(nr)));
        const yt = re.slice(r.maxCollapseTags), Dr = yt.length;
        Dr && (r.collapseTags ? me.push({
          key: -1,
          text: `+ ${Dr}`,
          closable: !1,
          isCollapseTag: !0
        }) : yt.forEach((nr) => me.push(bn(nr))));
      }
      A.value = me;
    }, ni = () => {
      var re, me;
      const { filterMethod: Ee, showAllLevels: yt, separator: Dr } = r, nr = (me = (re = w.value) == null ? void 0 : re.getFlattedNodes(!r.props.checkStrictly)) == null ? void 0 : me.filter((Tr) => Tr.isDisabled ? !1 : (Tr.calcText(yt, Dr), Ee(Tr, Bt.value)));
      Ae.value && (A.value.forEach((Tr) => {
        Tr.hitState = !1;
      }), W.value.forEach((Tr) => {
        Tr.hitState = !1;
      })), I.value = !0, j.value = nr, lt();
    }, Lr = () => {
      var re;
      let me;
      I.value && b.value ? me = b.value.$el.querySelector(`.${l.e("suggestion-item")}`) : me = (re = w.value) == null ? void 0 : re.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`), me && (me.focus(), !I.value && me.click());
    }, ri = () => {
      var re, me;
      const Ee = (re = g.value) == null ? void 0 : re.input, yt = v.value, Dr = (me = b.value) == null ? void 0 : me.$el;
      if (!(!zt || !Ee)) {
        if (Dr) {
          const nr = Dr.querySelector(`.${l.e("suggestion-list")}`);
          nr.style.minWidth = `${Ee.offsetWidth}px`;
        }
        if (yt) {
          const { offsetHeight: nr } = yt, Tr = A.value.length > 0 ? `${Math.max(nr + 6, o)}px` : `${o}px`;
          Ee.style.height = Tr, lt();
        }
      }
    }, Fr = (re) => {
      var me;
      return (me = w.value) == null ? void 0 : me.getCheckedNodes(re);
    }, Ri = (re) => {
      lt(), n("expandChange", re);
    }, wn = (re) => {
      var me;
      const Ee = (me = re.target) == null ? void 0 : me.value;
      if (re.type === "compositionend")
        G.value = !1, rt(() => Zs(Ee));
      else {
        const yt = Ee[Ee.length - 1] || "";
        G.value = !T3(yt);
      }
    }, ii = (re) => {
      if (!G.value)
        switch (re.code) {
          case on.enter:
            Xe();
            break;
          case on.down:
            Xe(!0), rt(Lr), re.preventDefault();
            break;
          case on.esc:
            S.value === !0 && (re.preventDefault(), re.stopPropagation(), Xe(!1));
            break;
          case on.tab:
            Xe(!1);
            break;
        }
    }, Nr = () => {
      var re;
      (re = w.value) == null || re.clearCheckedNodes(), !S.value && r.filterable && si(), Xe(!1);
    }, si = () => {
      const { value: re } = un;
      E.value = re, C.value = re;
    }, oi = (re) => {
      var me, Ee;
      const { checked: yt } = re;
      Ae.value ? (me = w.value) == null || me.handleCheckChange(re, !yt, !1) : (!yt && ((Ee = w.value) == null || Ee.handleCheckChange(re, !0, !1)), Xe(!1));
    }, pe = (re) => {
      const me = re.target, { code: Ee } = re;
      switch (Ee) {
        case on.up:
        case on.down: {
          const yt = Ee === on.up ? -1 : 1;
          Nw(FU(me, yt, `.${l.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case on.enter:
          me.click();
          break;
      }
    }, qe = () => {
      const re = A.value, me = re[re.length - 1];
      a = C.value ? 0 : a + 1, !(!me || !a || r.collapseTags && re.length > 1) && (me.hitState ? tr(me) : me.hitState = !0);
    }, ht = (re) => {
      const me = re.target, Ee = l.e("search-input");
      me.className === Ee && (M.value = !0), n("focus", re);
    }, _n = (re) => {
      M.value = !1, n("blur", re);
    }, Li = YM(() => {
      const { value: re } = Bt;
      if (!re)
        return;
      const me = r.beforeFilter(re);
      UM(me) ? me.then(ni).catch(() => {
      }) : me !== !1 ? ni() : Tt();
    }, r.debounce), Zs = (re, me) => {
      !S.value && Xe(!0), !(me != null && me.isComposing) && (re ? Li() : Tt());
    }, zo = (re) => Number.parseFloat(z0e(c.cssVarName("input-height"), re).value) - 2;
    return Ie(I, lt), Ie([wt, V], Pi), Ie(A, () => {
      rt(() => ri());
    }), Ie(_e, async () => {
      await rt();
      const re = g.value.input;
      o = zo(re) || o, ri();
    }), Ie(un, si, { immediate: !0 }), Yt(() => {
      const re = g.value.input, me = zo(re);
      o = re.offsetHeight || me, Lp(re, ri);
    }), t({
      getCheckedNodes: Fr,
      cascaderPanelRef: w,
      togglePopperVisible: Xe,
      contentRef: Ue
    }), (re, me) => (F(), ce(_(pC), {
      ref_key: "tooltipRef",
      ref: y,
      visible: S.value,
      teleported: re.teleported,
      "popper-class": [_(l).e("dropdown"), re.popperClass],
      "popper-options": i,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${_(l).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: Tt
    }, {
      default: te(() => [
        nn((F(), X("div", {
          class: Z(_(Pn)),
          style: It(_(R)),
          onClick: me[5] || (me[5] = () => Xe(_(Pe) ? void 0 : !0)),
          onKeydown: ii,
          onMouseenter: me[6] || (me[6] = (Ee) => $.value = !0),
          onMouseleave: me[7] || (me[7] = (Ee) => $.value = !1)
        }, [
          ye(_(eG), {
            ref_key: "input",
            ref: g,
            modelValue: E.value,
            "onUpdate:modelValue": me[1] || (me[1] = (Ee) => E.value = Ee),
            placeholder: _(de),
            readonly: _(Pe),
            disabled: _(V),
            "validate-event": !1,
            size: _(_e),
            class: Z(_(Me)),
            tabindex: _(Ae) && re.filterable && !_(V) ? -1 : void 0,
            onCompositionstart: wn,
            onCompositionupdate: wn,
            onCompositionend: wn,
            onFocus: ht,
            onBlur: _n,
            onInput: Zs
          }, {
            suffix: te(() => [
              _(Ut) ? (F(), ce(_(Ht), {
                key: "clear",
                class: Z([_(c).e("icon"), "icon-circle-close"]),
                onClick: Dt(Nr, ["stop"])
              }, {
                default: te(() => [
                  ye(_(JS))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (F(), ce(_(Ht), {
                key: "arrow-down",
                class: Z(_(Un)),
                onClick: me[0] || (me[0] = Dt((Ee) => Xe(), ["stop"]))
              }, {
                default: te(() => [
                  ye(_(yq))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          _(Ae) ? (F(), X("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: v,
            class: Z(_(l).e("tags"))
          }, [
            (F(!0), X(Ft, null, bi(A.value, (Ee) => (F(), ce(_(vC), {
              key: Ee.key,
              type: re.tagType,
              size: _(ie),
              hit: Ee.hitState,
              closable: Ee.closable,
              "disable-transitions": "",
              onClose: (yt) => tr(Ee)
            }, {
              default: te(() => [
                Ee.isCollapseTag === !1 ? (F(), X("span", oMe, it(Ee.text), 1)) : (F(), ce(_(pC), {
                  key: 1,
                  disabled: S.value || !re.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: te(() => [
                    ee("span", null, it(Ee.text), 1)
                  ]),
                  content: te(() => [
                    ee("div", {
                      class: Z(_(l).e("collapse-tags"))
                    }, [
                      (F(!0), X(Ft, null, bi(W.value.slice(re.maxCollapseTags), (yt, Dr) => (F(), X("div", {
                        key: Dr,
                        class: Z(_(l).e("collapse-tag"))
                      }, [
                        (F(), ce(_(vC), {
                          key: yt.key,
                          class: "in-tooltip",
                          type: re.tagType,
                          size: _(ie),
                          hit: yt.hitState,
                          closable: yt.closable,
                          "disable-transitions": "",
                          onClose: (nr) => tr(yt)
                        }, {
                          default: te(() => [
                            ee("span", null, it(yt.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            re.filterable && !_(V) ? nn((F(), X("input", {
              key: 0,
              "onUpdate:modelValue": me[2] || (me[2] = (Ee) => C.value = Ee),
              type: "text",
              class: Z(_(l).e("search-input")),
              placeholder: _(un) ? "" : _(Q),
              onInput: me[3] || (me[3] = (Ee) => Zs(C.value, Ee)),
              onClick: me[4] || (me[4] = Dt((Ee) => Xe(!0), ["stop"])),
              onKeydown: Ui(qe, ["delete"]),
              onCompositionstart: wn,
              onCompositionupdate: wn,
              onCompositionend: wn,
              onFocus: ht,
              onBlur: _n
            }, null, 42, aMe)), [
              [X5, C.value]
            ]) : he("v-if", !0)
          ], 2)) : he("v-if", !0)
        ], 38)), [
          [_(mG), () => Xe(!1), _(Ue)]
        ])
      ]),
      content: te(() => [
        nn(ye(_(XIe), {
          ref_key: "cascaderPanelRef",
          ref: w,
          modelValue: _(An),
          "onUpdate:modelValue": me[8] || (me[8] = (Ee) => $a(An) ? An.value = Ee : null),
          options: re.options,
          props: r.props,
          border: !1,
          "render-label": re.$slots.default,
          onExpandChange: Ri,
          onClose: me[9] || (me[9] = (Ee) => re.$nextTick(() => Xe(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [Ei, !I.value]
        ]),
        re.filterable ? nn((F(), ce(_(F3), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: b,
          tag: "ul",
          class: Z(_(l).e("suggestion-panel")),
          "view-class": _(l).e("suggestion-list"),
          onKeydown: pe
        }, {
          default: te(() => [
            j.value.length ? (F(!0), X(Ft, { key: 0 }, bi(j.value, (Ee) => (F(), X("li", {
              key: Ee.uid,
              class: Z([
                _(l).e("suggestion-item"),
                _(l).is("checked", Ee.checked)
              ]),
              tabindex: -1,
              onClick: (yt) => oi(Ee)
            }, [
              ee("span", null, it(Ee.text), 1),
              Ee.checked ? (F(), ce(_(Ht), { key: 0 }, {
                default: te(() => [
                  ye(_(gq))
                ]),
                _: 1
              })) : he("v-if", !0)
            ], 10, lMe))), 128)) : je(re.$slots, "empty", { key: 1 }, () => [
              ee("li", {
                class: Z(_(l).e("empty-text"))
              }, it(_(p)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [Ei, I.value]
        ]) : he("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var qw = /* @__PURE__ */ at(dMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
qw.install = (e) => {
  e.component(qw.name, qw);
};
const pMe = qw, hMe = pMe, fMe = fe({
  name: "ElCollapseTransition"
}), mMe = /* @__PURE__ */ fe({
  ...fMe,
  setup(e) {
    const t = tt("collapse-transition"), n = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, r = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        i.dataset.oldOverflow = i.style.overflow, i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        n(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        n(i);
      },
      leaveCancelled(i) {
        n(i);
      }
    };
    return (i, s) => (F(), ce(ko, ga({
      name: _(t).b()
    }, kW(r)), {
      default: te(() => [
        je(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Gw = /* @__PURE__ */ at(mMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
Gw.install = (e) => {
  e.component(Gw.name, Gw);
};
const yMe = Gw, MG = yMe, gMe = bt({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: Be([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: Be([String, Number])
  }
}), vMe = {
  click: (e) => e instanceof MouseEvent
}, bMe = "overlay";
var wMe = fe({
  name: "ElOverlay",
  props: gMe,
  emits: vMe,
  setup(e, { slots: t, emit: n }) {
    const r = tt(bMe), i = (l) => {
      n("click", l);
    }, { onClick: s, onMousedown: o, onMouseup: a } = Bq(e.customMaskEvent ? void 0 : i);
    return () => e.mask ? ye("div", {
      class: [r.b(), e.overlayClass],
      style: {
        zIndex: e.zIndex
      },
      onClick: s,
      onMousedown: o,
      onMouseup: a
    }, [je(t, "default")], Dw.STYLE | Dw.CLASS | Dw.PROPS, ["onClick", "onMouseup", "onMousedown"]) : vl("div", {
      class: e.overlayClass,
      style: {
        zIndex: e.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [je(t, "default")]);
  }
});
const _Me = wMe, CG = Symbol("dialogInjectionKey"), OG = bt({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: Yi
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), SMe = {
  close: () => !0
}, xMe = ["aria-level"], $Me = ["aria-label"], TMe = ["id"], EMe = fe({ name: "ElDialogContent" }), IMe = /* @__PURE__ */ fe({
  ...EMe,
  props: OG,
  emits: SMe,
  setup(e) {
    const t = e, { t: n } = Dp(), { Close: r } = xq, { dialogRef: i, headerRef: s, bodyId: o, ns: a, style: l } = pt(CG), { focusTrapRef: c } = pt(aG), p = P(() => [
      a.b(),
      a.is("fullscreen", t.fullscreen),
      a.is("draggable", t.draggable),
      a.is("align-center", t.alignCenter),
      { [a.m("center")]: t.center },
      t.customClass
    ]), f = m2e(c, i), m = P(() => t.draggable);
    return S2e(i, s, m), (y, g) => (F(), X("div", {
      ref: _(f),
      class: Z(_(p)),
      style: It(_(l)),
      tabindex: "-1"
    }, [
      ee("header", {
        ref_key: "headerRef",
        ref: s,
        class: Z(_(a).e("header"))
      }, [
        je(y.$slots, "header", {}, () => [
          ee("span", {
            role: "heading",
            "aria-level": y.ariaLevel,
            class: Z(_(a).e("title"))
          }, it(y.title), 11, xMe)
        ]),
        y.showClose ? (F(), X("button", {
          key: 0,
          "aria-label": _(n)("el.dialog.close"),
          class: Z(_(a).e("headerbtn")),
          type: "button",
          onClick: g[0] || (g[0] = (v) => y.$emit("close"))
        }, [
          ye(_(Ht), {
            class: Z(_(a).e("close"))
          }, {
            default: te(() => [
              (F(), ce(Mn(y.closeIcon || _(r))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, $Me)) : he("v-if", !0)
      ], 2),
      ee("div", {
        id: _(o),
        class: Z(_(a).e("body"))
      }, [
        je(y.$slots, "default")
      ], 10, TMe),
      y.$slots.footer ? (F(), X("footer", {
        key: 0,
        class: Z(_(a).e("footer"))
      }, [
        je(y.$slots, "footer")
      ], 2)) : he("v-if", !0)
    ], 6));
  }
});
var MMe = /* @__PURE__ */ at(IMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const CMe = bt({
  ...OG,
  appendToBody: Boolean,
  appendTo: {
    type: Be(String),
    default: "body"
  },
  beforeClose: {
    type: Be(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), OMe = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [jt]: (e) => Qr(e),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, kMe = (e, t) => {
  var n;
  const i = ur().emit, { nextZIndex: s } = R3();
  let o = "";
  const a = dc(), l = dc(), c = J(!1), p = J(!1), f = J(!1), m = J((n = e.zIndex) != null ? n : s());
  let y, g;
  const v = XS("namespace", gg), w = P(() => {
    const de = {}, _e = `--${v.value}-dialog`;
    return e.fullscreen || (e.top && (de[`${_e}-margin-top`] = e.top), e.width && (de[`${_e}-width`] = Rl(e.width))), de;
  }), b = P(() => e.alignCenter ? { display: "flex" } : {});
  function S() {
    i("opened");
  }
  function $() {
    i("closed"), i(jt, !1), e.destroyOnClose && (f.value = !1);
  }
  function I() {
    i("close");
  }
  function M() {
    g == null || g(), y == null || y(), e.openDelay && e.openDelay > 0 ? { stop: y } = y_(() => W(), e.openDelay) : W();
  }
  function E() {
    y == null || y(), g == null || g(), e.closeDelay && e.closeDelay > 0 ? { stop: g } = y_(() => j(), e.closeDelay) : j();
  }
  function C() {
    function de(_e) {
      _e || (p.value = !0, c.value = !1);
    }
    e.beforeClose ? e.beforeClose(de) : E();
  }
  function A() {
    e.closeOnClickModal && C();
  }
  function W() {
    zt && (c.value = !0);
  }
  function j() {
    c.value = !1;
  }
  function G() {
    i("openAutoFocus");
  }
  function R() {
    i("closeAutoFocus");
  }
  function V(de) {
    var _e;
    ((_e = de.detail) == null ? void 0 : _e.focusReason) === "pointer" && de.preventDefault();
  }
  e.lockScroll && N2e(c);
  function Q() {
    e.closeOnPressEscape && C();
  }
  return Ie(() => e.modelValue, (de) => {
    de ? (p.value = !1, M(), f.value = !0, m.value = dq(e.zIndex) ? s() : m.value++, rt(() => {
      i("open"), t.value && (t.value.scrollTop = 0);
    })) : c.value && E();
  }), Ie(() => e.fullscreen, (de) => {
    t.value && (de ? (o = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = o);
  }), Yt(() => {
    e.modelValue && (c.value = !0, f.value = !0, M());
  }), {
    afterEnter: S,
    afterLeave: $,
    beforeLeave: I,
    handleClose: C,
    onModalClick: A,
    close: E,
    doClose: j,
    onOpenAutoFocus: G,
    onCloseAutoFocus: R,
    onCloseRequested: Q,
    onFocusoutPrevented: V,
    titleId: a,
    bodyId: l,
    closed: p,
    style: w,
    overlayDialogStyle: b,
    rendered: f,
    visible: c,
    zIndex: m
  };
}, AMe = ["aria-label", "aria-labelledby", "aria-describedby"], PMe = fe({
  name: "ElDialog",
  inheritAttrs: !1
}), RMe = /* @__PURE__ */ fe({
  ...PMe,
  props: CMe,
  emits: OMe,
  setup(e, { expose: t }) {
    const n = e, r = Nf();
    i0({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, P(() => !!r.title)), i0({
      scope: "el-dialog",
      from: "custom-class",
      replacement: "class",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
      type: "Attribute"
    }, P(() => !!n.customClass));
    const i = tt("dialog"), s = J(), o = J(), a = J(), {
      visible: l,
      titleId: c,
      bodyId: p,
      style: f,
      overlayDialogStyle: m,
      rendered: y,
      zIndex: g,
      afterEnter: v,
      afterLeave: w,
      beforeLeave: b,
      handleClose: S,
      onModalClick: $,
      onOpenAutoFocus: I,
      onCloseAutoFocus: M,
      onCloseRequested: E,
      onFocusoutPrevented: C
    } = kMe(n, s);
    _r(CG, {
      dialogRef: s,
      headerRef: o,
      bodyId: p,
      ns: i,
      rendered: y,
      style: f
    });
    const A = Bq($), W = P(() => n.draggable && !n.fullscreen);
    return t({
      visible: l,
      dialogContentRef: a
    }), (j, G) => (F(), ce(Y5, {
      to: j.appendTo,
      disabled: j.appendTo !== "body" ? !1 : !j.appendToBody
    }, [
      ye(ko, {
        name: "dialog-fade",
        onAfterEnter: _(v),
        onAfterLeave: _(w),
        onBeforeLeave: _(b),
        persisted: ""
      }, {
        default: te(() => [
          nn(ye(_(_Me), {
            "custom-mask-event": "",
            mask: j.modal,
            "overlay-class": j.modalClass,
            "z-index": _(g)
          }, {
            default: te(() => [
              ee("div", {
                role: "dialog",
                "aria-modal": "true",
                "aria-label": j.title || void 0,
                "aria-labelledby": j.title ? void 0 : _(c),
                "aria-describedby": _(p),
                class: Z(`${_(i).namespace.value}-overlay-dialog`),
                style: It(_(m)),
                onClick: G[0] || (G[0] = (...R) => _(A).onClick && _(A).onClick(...R)),
                onMousedown: G[1] || (G[1] = (...R) => _(A).onMousedown && _(A).onMousedown(...R)),
                onMouseup: G[2] || (G[2] = (...R) => _(A).onMouseup && _(A).onMouseup(...R))
              }, [
                ye(_(uG), {
                  loop: "",
                  trapped: _(l),
                  "focus-start-el": "container",
                  onFocusAfterTrapped: _(I),
                  onFocusAfterReleased: _(M),
                  onFocusoutPrevented: _(C),
                  onReleaseRequested: _(E)
                }, {
                  default: te(() => [
                    _(y) ? (F(), ce(MMe, ga({
                      key: 0,
                      ref_key: "dialogContentRef",
                      ref: a
                    }, j.$attrs, {
                      "custom-class": j.customClass,
                      center: j.center,
                      "align-center": j.alignCenter,
                      "close-icon": j.closeIcon,
                      draggable: _(W),
                      fullscreen: j.fullscreen,
                      "show-close": j.showClose,
                      title: j.title,
                      "aria-level": j.headerAriaLevel,
                      onClose: _(S)
                    }), b$({
                      header: te(() => [
                        j.$slots.title ? je(j.$slots, "title", { key: 1 }) : je(j.$slots, "header", {
                          key: 0,
                          close: _(S),
                          titleId: _(c),
                          titleClass: _(i).e("title")
                        })
                      ]),
                      default: te(() => [
                        je(j.$slots, "default")
                      ]),
                      _: 2
                    }, [
                      j.$slots.footer ? {
                        name: "footer",
                        fn: te(() => [
                          je(j.$slots, "footer")
                        ])
                      } : void 0
                    ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : he("v-if", !0)
                  ]),
                  _: 3
                }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ], 46, AMe)
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [
            [Ei, _(l)]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["to", "disabled"]));
  }
});
var LMe = /* @__PURE__ */ at(RMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const FMe = Ai(LMe), kG = Symbol("ElSelectGroup"), n2 = Symbol("ElSelect");
function NMe(e, t) {
  const n = pt(n2), r = pt(kG, { disabled: !1 }), i = P(() => Rr(e.value)), s = P(() => n.props.multiple ? f(n.props.modelValue, e.value) : m(e.value, n.props.modelValue)), o = P(() => {
    if (n.props.multiple) {
      const v = n.props.modelValue || [];
      return !s.value && v.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), a = P(() => e.label || (i.value ? "" : e.value)), l = P(() => e.value || e.label || ""), c = P(() => e.disabled || t.groupDisabled || o.value), p = ur(), f = (v = [], w) => {
    if (i.value) {
      const b = n.props.valueKey;
      return v && v.some((S) => uf(vi(S, b)) === vi(w, b));
    } else
      return v && v.includes(w);
  }, m = (v, w) => {
    if (i.value) {
      const { valueKey: b } = n.props;
      return vi(v, b) === vi(w, b);
    } else
      return v === w;
  }, y = () => {
    !e.disabled && !r.disabled && (n.hoverIndex = n.optionsArray.indexOf(p.proxy));
  };
  Ie(() => a.value, () => {
    !e.created && !n.props.remote && n.setSelected();
  }), Ie(() => e.value, (v, w) => {
    const { remote: b, valueKey: S } = n.props;
    if (Object.is(v, w) || (n.onOptionDestroy(w, p.proxy), n.onOptionCreate(p.proxy)), !e.created && !b) {
      if (S && Rr(v) && Rr(w) && v[S] === w[S])
        return;
      n.setSelected();
    }
  }), Ie(() => r.disabled, () => {
    t.groupDisabled = r.disabled;
  }, { immediate: !0 });
  const { queryChange: g } = uf(n);
  return Ie(g, (v) => {
    const { query: w } = _(v), b = new RegExp(HSe(w), "i");
    t.visible = b.test(a.value) || e.created, t.visible || n.filteredOptionsCount--;
  }, { immediate: !0 }), {
    select: n,
    currentLabel: a,
    currentValue: l,
    itemSelected: s,
    isDisabled: c,
    hoverItem: y
  };
}
const DMe = fe({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(e) {
    const t = tt("select"), n = dc(), r = P(() => [
      t.be("dropdown", "item"),
      t.is("disabled", _(a)),
      {
        selected: _(o),
        hover: _(f)
      }
    ]), i = is({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hitState: !1,
      hover: !1
    }), { currentLabel: s, itemSelected: o, isDisabled: a, select: l, hoverItem: c } = NMe(e, i), { visible: p, hover: f } = hc(i), m = ur().proxy;
    l.onOptionCreate(m), us(() => {
      const g = m.value, { selected: v } = l, b = (l.props.multiple ? v : [v]).some((S) => S.value === m.value);
      rt(() => {
        l.cachedOptions.get(g) === m && !b && l.cachedOptions.delete(g);
      }), l.onOptionDestroy(g, m);
    });
    function y() {
      e.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(m);
    }
    return {
      ns: t,
      id: n,
      containerKls: r,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: c,
      visible: p,
      hover: f,
      selectOptionClick: y,
      states: i
    };
  }
}), jMe = ["id", "aria-disabled", "aria-selected"];
function VMe(e, t, n, r, i, s) {
  return nn((F(), X("li", {
    id: e.id,
    class: Z(e.containerKls),
    role: "option",
    "aria-disabled": e.isDisabled || void 0,
    "aria-selected": e.itemSelected,
    onMouseenter: t[0] || (t[0] = (...o) => e.hoverItem && e.hoverItem(...o)),
    onClick: t[1] || (t[1] = Dt((...o) => e.selectOptionClick && e.selectOptionClick(...o), ["stop"]))
  }, [
    je(e.$slots, "default", {}, () => [
      ee("span", null, it(e.currentLabel), 1)
    ])
  ], 42, jMe)), [
    [Ei, e.visible]
  ]);
}
var U3 = /* @__PURE__ */ at(DMe, [["render", VMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const zMe = fe({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e = pt(n2), t = tt("select"), n = P(() => e.props.popperClass), r = P(() => e.props.multiple), i = P(() => e.props.fitInputWidth), s = J("");
    function o() {
      var a;
      s.value = `${(a = e.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
    }
    return Yt(() => {
      o(), Lp(e.selectWrapper, o);
    }), {
      ns: t,
      minWidth: s,
      popperClass: n,
      isMultiple: r,
      isFitInputWidth: i
    };
  }
});
function BMe(e, t, n, r, i, s) {
  return F(), X("div", {
    class: Z([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
    style: It({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
  }, [
    e.$slots.header ? (F(), X("div", {
      key: 0,
      class: Z(e.ns.be("dropdown", "header"))
    }, [
      je(e.$slots, "header")
    ], 2)) : he("v-if", !0),
    je(e.$slots, "default"),
    e.$slots.footer ? (F(), X("div", {
      key: 1,
      class: Z(e.ns.be("dropdown", "footer"))
    }, [
      je(e.$slots, "footer")
    ], 2)) : he("v-if", !0)
  ], 6);
}
var UMe = /* @__PURE__ */ at(zMe, [["render", BMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function qMe(e) {
  const { t } = Dp();
  return is({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: !1,
    selected: e.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: !1,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: !1,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: !1,
    isOnComposition: !1,
    prefixWidth: 11,
    mouseEnter: !1,
    focused: !1
  });
}
const GMe = (e, t, n) => {
  const { t: r } = Dp(), i = tt("select");
  i0({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, P(() => e.suffixTransition === !1));
  const s = J(null), o = J(null), a = J(null), l = J(null), c = J(null), p = J(null), f = J(null), m = J(null), y = J(), g = Vd({ query: "" }), v = Vd(""), w = J([]);
  let b = 0;
  const { form: S, formItem: $ } = jl(), I = P(() => !e.filterable || e.multiple || !t.visible), M = P(() => e.disabled || (S == null ? void 0 : S.disabled)), E = P(() => {
    const z = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : e.modelValue !== void 0 && e.modelValue !== null && e.modelValue !== "";
    return e.clearable && !M.value && t.inputHovering && z;
  }), C = P(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), A = P(() => i.is("reverse", C.value && t.visible && e.suffixTransition)), W = P(() => (S == null ? void 0 : S.statusIcon) && ($ == null ? void 0 : $.validateState) && $q[$ == null ? void 0 : $.validateState]), j = P(() => e.remote ? 300 : 0), G = P(() => e.loading ? e.loadingText || r("el.select.loading") : e.remote && t.query === "" && t.options.size === 0 ? !1 : e.filterable && t.query && t.options.size > 0 && t.filteredOptionsCount === 0 ? e.noMatchText || r("el.select.noMatch") : t.options.size === 0 ? e.noDataText || r("el.select.noData") : null), R = P(() => {
    const z = Array.from(t.options.values()), ae = [];
    return w.value.forEach((Se) => {
      const Je = z.findIndex((pr) => pr.currentLabel === Se);
      Je > -1 && ae.push(z[Je]);
    }), ae.length >= z.length ? ae : z;
  }), V = P(() => Array.from(t.cachedOptions.values())), Q = P(() => {
    const z = R.value.filter((ae) => !ae.created).some((ae) => ae.currentLabel === t.query);
    return e.filterable && e.allowCreate && t.query !== "" && !z;
  }), de = Do(), _e = P(() => ["small"].includes(de.value) ? "small" : "default"), ie = P({
    get() {
      return t.visible && G.value !== !1;
    },
    set(z) {
      t.visible = z;
    }
  });
  Ie([() => M.value, () => de.value, () => S == null ? void 0 : S.size], () => {
    rt(() => {
      Ae();
    });
  }), Ie(() => e.placeholder, (z) => {
    t.cachedPlaceHolder = t.currentPlaceholder = z, e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (t.currentPlaceholder = "");
  }), Ie(() => e.modelValue, (z, ae) => {
    e.multiple && (Ae(), z && z.length > 0 || o.value && t.query !== "" ? t.currentPlaceholder = "" : t.currentPlaceholder = t.cachedPlaceHolder, e.filterable && !e.reserveKeyword && (t.query = "", Pe(t.query))), Ut(), e.filterable && !e.multiple && (t.inputLength = 20), !Qu(z, ae) && e.validateEvent && ($ == null || $.validate("change").catch((Se) => Zt(Se)));
  }, {
    flush: "post",
    deep: !0
  }), Ie(() => t.visible, (z) => {
    var ae, Se, Je, pr, Er;
    z ? ((Se = (ae = l.value) == null ? void 0 : ae.updatePopper) == null || Se.call(ae), e.filterable && (t.filteredOptionsCount = t.optionsCount, t.query = e.remote ? "" : t.selectedLabel, (pr = (Je = a.value) == null ? void 0 : Je.focus) == null || pr.call(Je), e.multiple ? (Er = o.value) == null || Er.focus() : t.selectedLabel && (t.currentPlaceholder = `${t.selectedLabel}`, t.selectedLabel = ""), Pe(t.query), !e.multiple && !e.remote && (g.value.query = "", ym(g), ym(v)))) : (e.filterable && (an(e.filterMethod) && e.filterMethod(""), an(e.remoteMethod) && e.remoteMethod("")), t.query = "", t.previousQuery = null, t.selectedLabel = "", t.inputLength = 20, t.menuVisibleOnFocus = !1, An(), rt(() => {
      o.value && o.value.value === "" && t.selected.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
    }), e.multiple || (t.selected && (e.filterable && e.allowCreate && t.createdSelected && t.createdLabel ? t.selectedLabel = t.createdLabel : t.selectedLabel = t.selected.currentLabel, e.filterable && (t.query = t.selectedLabel)), e.filterable && (t.currentPlaceholder = t.cachedPlaceHolder))), n.emit("visible-change", z);
  }), Ie(() => t.options.entries(), () => {
    var z, ae, Se;
    if (!zt)
      return;
    (ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z), e.multiple && Ae();
    const Je = ((Se = f.value) == null ? void 0 : Se.querySelectorAll("input")) || [];
    (!e.filterable && !e.defaultFirstOption && !Cf(e.modelValue) || !Array.from(Je).includes(document.activeElement)) && Ut(), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && wt();
  }, {
    flush: "post"
  }), Ie(() => t.hoverIndex, (z) => {
    yn(z) && z > -1 ? y.value = R.value[z] || {} : y.value = {}, R.value.forEach((ae) => {
      ae.hover = y.value === ae;
    });
  });
  const Ae = () => {
    rt(() => {
      var z, ae;
      if (!s.value)
        return;
      const Se = s.value.$el.querySelector("input");
      b = b || (Se.clientHeight > 0 ? Se.clientHeight + 2 : 0);
      const Je = p.value, pr = getComputedStyle(Se).getPropertyValue(i.cssVarName("input-height")), Er = Number.parseFloat(pr) || g2e(de.value || (S == null ? void 0 : S.size)), ai = de.value || Er === b || b <= 0 ? Er : b;
      !(Se.offsetParent === null) && (Se.style.height = `${(t.selected.length === 0 ? ai : Math.max(Je ? Je.clientHeight + (Je.clientHeight > ai ? 6 : 0) : 0, ai)) - 2}px`), t.visible && G.value !== !1 && ((ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z));
    });
  }, Pe = async (z) => {
    if (!(t.previousQuery === z || t.isOnComposition)) {
      if (t.previousQuery === null && (an(e.filterMethod) || an(e.remoteMethod))) {
        t.previousQuery = z;
        return;
      }
      t.previousQuery = z, rt(() => {
        var ae, Se;
        t.visible && ((Se = (ae = l.value) == null ? void 0 : ae.updatePopper) == null || Se.call(ae));
      }), t.hoverIndex = -1, e.multiple && e.filterable && rt(() => {
        if (!M.value) {
          const ae = o.value.value.length * 15 + 20;
          t.inputLength = e.collapseTags ? Math.min(50, ae) : ae, Bt();
        }
        Ae();
      }), e.remote && an(e.remoteMethod) ? (t.hoverIndex = -1, e.remoteMethod(z)) : an(e.filterMethod) ? (e.filterMethod(z), ym(v)) : (t.filteredOptionsCount = t.optionsCount, g.value.query = z, ym(g), ym(v)), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && (await rt(), wt());
    }
  }, Bt = () => {
    t.currentPlaceholder !== "" && (t.currentPlaceholder = o.value.value ? "" : t.cachedPlaceHolder);
  }, wt = () => {
    const z = R.value.filter((Je) => Je.visible && !Je.disabled && !Je.states.groupDisabled), ae = z.find((Je) => Je.created), Se = z[0];
    t.hoverIndex = Lr(R.value, ae || Se);
  }, Ut = () => {
    var z;
    if (e.multiple)
      t.selectedLabel = "";
    else {
      const Se = un(e.modelValue);
      (z = Se.props) != null && z.created ? (t.createdLabel = Se.props.value, t.createdSelected = !0) : t.createdSelected = !1, t.selectedLabel = Se.currentLabel, t.selected = Se, e.filterable && (t.query = t.selectedLabel);
      return;
    }
    const ae = [];
    Array.isArray(e.modelValue) && e.modelValue.forEach((Se) => {
      ae.push(un(Se));
    }), t.selected = ae, rt(() => {
      Ae();
    });
  }, un = (z) => {
    let ae;
    const Se = Qx(z).toLowerCase() === "object", Je = Qx(z).toLowerCase() === "null", pr = Qx(z).toLowerCase() === "undefined";
    for (let cs = t.cachedOptions.size - 1; cs >= 0; cs--) {
      const li = V.value[cs];
      if (Se ? vi(li.value, e.valueKey) === vi(z, e.valueKey) : li.value === z) {
        ae = {
          value: z,
          currentLabel: li.currentLabel,
          isDisabled: li.isDisabled
        };
        break;
      }
    }
    if (ae)
      return ae;
    const Er = Se ? z.label : !Je && !pr ? z : "", ai = {
      value: z,
      currentLabel: Er
    };
    return e.multiple && (ai.hitState = !1), ai;
  }, An = () => {
    setTimeout(() => {
      const z = e.valueKey;
      e.multiple ? t.selected.length > 0 ? t.hoverIndex = Math.min.apply(null, t.selected.map((ae) => R.value.findIndex((Se) => vi(Se, z) === vi(ae, z)))) : t.hoverIndex = -1 : t.hoverIndex = R.value.findIndex((ae) => Ee(ae) === Ee(t.selected));
    }, 300);
  }, Pn = () => {
    var z, ae;
    Un(), (ae = (z = l.value) == null ? void 0 : z.updatePopper) == null || ae.call(z), e.multiple && Ae();
  }, Un = () => {
    var z;
    t.inputWidth = (z = s.value) == null ? void 0 : z.$el.offsetWidth;
  }, Me = () => {
    e.filterable && t.query !== t.selectedLabel && (t.query = t.selectedLabel, Pe(t.query));
  }, Ue = YM(() => {
    Me();
  }, j.value), Xe = YM((z) => {
    Pe(z.target.value);
  }, j.value), lt = (z) => {
    Qu(e.modelValue, z) || n.emit(Oa, z);
  }, Tt = (z) => DSe(z, (ae) => !t.disabledOptions.has(ae)), bn = (z) => {
    if (z.code !== on.delete) {
      if (z.target.value.length <= 0 && !Nr()) {
        const ae = e.modelValue.slice(), Se = Tt(ae);
        if (Se < 0)
          return;
        ae.splice(Se, 1), n.emit(jt, ae), lt(ae);
      }
      z.target.value.length === 1 && e.modelValue.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
    }
  }, tr = (z, ae) => {
    const Se = t.selected.indexOf(ae);
    if (Se > -1 && !M.value) {
      const Je = e.modelValue.slice();
      Je.splice(Se, 1), n.emit(jt, Je), lt(Je), n.emit("remove-tag", ae.value);
    }
    z.stopPropagation(), qe();
  }, Pi = (z) => {
    z.stopPropagation();
    const ae = e.multiple ? [] : "";
    if (!ln(ae))
      for (const Se of t.selected)
        Se.isDisabled && ae.push(Se.value);
    n.emit(jt, ae), lt(ae), t.hoverIndex = -1, t.visible = !1, n.emit("clear"), qe();
  }, ni = (z) => {
    var ae;
    if (e.multiple) {
      const Se = (e.modelValue || []).slice(), Je = Lr(Se, z.value);
      Je > -1 ? Se.splice(Je, 1) : (e.multipleLimit <= 0 || Se.length < e.multipleLimit) && Se.push(z.value), n.emit(jt, Se), lt(Se), z.created && (t.query = "", Pe(""), t.inputLength = 20), e.filterable && ((ae = o.value) == null || ae.focus());
    } else
      n.emit(jt, z.value), lt(z.value), t.visible = !1;
    ri(), !t.visible && rt(() => {
      Fr(z);
    });
  }, Lr = (z = [], ae) => {
    if (!Rr(ae))
      return z.indexOf(ae);
    const Se = e.valueKey;
    let Je = -1;
    return z.some((pr, Er) => uf(vi(pr, Se)) === vi(ae, Se) ? (Je = Er, !0) : !1), Je;
  }, ri = () => {
    const z = o.value || s.value;
    z && (z == null || z.focus());
  }, Fr = (z) => {
    var ae, Se, Je, pr, Er;
    const ai = Array.isArray(z) ? z[0] : z;
    let cs = null;
    if (ai != null && ai.value) {
      const li = R.value.filter((Vp) => Vp.value === ai.value);
      li.length > 0 && (cs = li[0].$el);
    }
    if (l.value && cs) {
      const li = (pr = (Je = (Se = (ae = l.value) == null ? void 0 : ae.popperRef) == null ? void 0 : Se.contentRef) == null ? void 0 : Je.querySelector) == null ? void 0 : pr.call(Je, `.${i.be("dropdown", "wrap")}`);
      li && mq(li, cs);
    }
    (Er = m.value) == null || Er.handleScroll();
  }, Ri = (z) => {
    t.optionsCount++, t.filteredOptionsCount++, t.options.set(z.value, z), t.cachedOptions.set(z.value, z), z.disabled && t.disabledOptions.set(z.value, z);
  }, wn = (z, ae) => {
    t.options.get(z) === ae && (t.optionsCount--, t.filteredOptionsCount--, t.options.delete(z));
  }, ii = (z) => {
    z.code !== on.backspace && Nr(!1), t.inputLength = o.value.value.length * 15 + 20, Ae();
  }, Nr = (z) => {
    if (!Array.isArray(t.selected))
      return;
    const ae = Tt(t.selected.map((Je) => Je.value)), Se = t.selected[ae];
    if (Se)
      return z === !0 || z === !1 ? (Se.hitState = z, z) : (Se.hitState = !Se.hitState, Se.hitState);
  }, si = (z) => {
    const ae = z.target.value;
    if (z.type === "compositionend")
      t.isOnComposition = !1, rt(() => Pe(ae));
    else {
      const Se = ae[ae.length - 1] || "";
      t.isOnComposition = !T3(Se);
    }
  }, oi = () => {
    rt(() => Fr(t.selected));
  }, pe = (z) => {
    t.focused || ((e.automaticDropdown || e.filterable) && (e.filterable && !t.visible && (t.menuVisibleOnFocus = !0), t.visible = !0), t.focused = !0, n.emit("focus", z));
  }, qe = () => {
    var z, ae;
    t.visible ? (z = o.value || s.value) == null || z.focus() : (ae = s.value) == null || ae.focus();
  }, ht = () => {
    var z, ae, Se;
    t.visible = !1, (z = s.value) == null || z.blur(), (Se = (ae = a.value) == null ? void 0 : ae.blur) == null || Se.call(ae);
  }, _n = (z) => {
    var ae, Se, Je;
    (ae = l.value) != null && ae.isFocusInsideContent(z) || (Se = c.value) != null && Se.isFocusInsideContent(z) || (Je = f.value) != null && Je.contains(z.relatedTarget) || (t.visible && Zs(), t.focused = !1, n.emit("blur", z));
  }, Li = (z) => {
    Pi(z);
  }, Zs = () => {
    t.visible = !1;
  }, zo = (z) => {
    t.visible && (z.preventDefault(), z.stopPropagation(), t.visible = !1);
  }, re = (z) => {
    z && !t.mouseEnter || M.value || (t.menuVisibleOnFocus ? t.menuVisibleOnFocus = !1 : (!l.value || !l.value.isFocusInsideContent()) && (t.visible = !t.visible), qe());
  }, me = () => {
    t.visible ? R.value[t.hoverIndex] && ni(R.value[t.hoverIndex]) : re();
  }, Ee = (z) => Rr(z.value) ? vi(z.value, e.valueKey) : z.value, yt = P(() => R.value.filter((z) => z.visible).every((z) => z.disabled)), Dr = P(() => e.multiple ? t.selected.slice(0, e.maxCollapseTags) : []), nr = P(() => e.multiple ? t.selected.slice(e.maxCollapseTags) : []), Tr = (z) => {
    if (!t.visible) {
      t.visible = !0;
      return;
    }
    if (!(t.options.size === 0 || t.filteredOptionsCount === 0) && !t.isOnComposition && !yt.value) {
      z === "next" ? (t.hoverIndex++, t.hoverIndex === t.options.size && (t.hoverIndex = 0)) : z === "prev" && (t.hoverIndex--, t.hoverIndex < 0 && (t.hoverIndex = t.options.size - 1));
      const ae = R.value[t.hoverIndex];
      (ae.disabled === !0 || ae.states.groupDisabled === !0 || !ae.visible) && Tr(z), rt(() => Fr(y.value));
    }
  }, pm = () => {
    t.mouseEnter = !0;
  }, jp = () => {
    t.mouseEnter = !1;
  }, hm = (z, ae) => {
    var Se, Je;
    tr(z, ae), (Je = (Se = c.value) == null ? void 0 : Se.updatePopper) == null || Je.call(Se);
  }, fm = P(() => ({
    maxWidth: `${_(t.inputWidth) - 32 - (W.value ? 22 : 0)}px`,
    width: "100%"
  }));
  return {
    optionList: w,
    optionsArray: R,
    hoverOption: y,
    selectSize: de,
    handleResize: Pn,
    debouncedOnInputChange: Ue,
    debouncedQueryChange: Xe,
    deletePrevTag: bn,
    deleteTag: tr,
    deleteSelected: Pi,
    handleOptionSelect: ni,
    scrollToOption: Fr,
    readonly: I,
    resetInputHeight: Ae,
    showClose: E,
    iconComponent: C,
    iconReverse: A,
    showNewOption: Q,
    collapseTagSize: _e,
    setSelected: Ut,
    managePlaceholder: Bt,
    selectDisabled: M,
    emptyText: G,
    toggleLastOptionHitState: Nr,
    resetInputState: ii,
    handleComposition: si,
    onOptionCreate: Ri,
    onOptionDestroy: wn,
    handleMenuEnter: oi,
    handleFocus: pe,
    focus: qe,
    blur: ht,
    handleBlur: _n,
    handleClearClick: Li,
    handleClose: Zs,
    handleKeydownEscape: zo,
    toggleMenu: re,
    selectOption: me,
    getValueKey: Ee,
    navigateOptions: Tr,
    handleDeleteTooltipTag: hm,
    dropMenuVisible: ie,
    queryChange: g,
    groupQueryChange: v,
    showTagList: Dr,
    collapseTagList: nr,
    selectTagsStyle: fm,
    reference: s,
    input: o,
    iOSInput: a,
    tooltipRef: l,
    tagTooltipRef: c,
    tags: p,
    selectWrapper: f,
    scrollbar: m,
    handleMouseEnter: pm,
    handleMouseLeave: jp
  };
};
var WMe = fe({
  name: "ElOptions",
  emits: ["update-options"],
  setup(e, { slots: t, emit: n }) {
    let r = [];
    function i(s, o) {
      if (s.length !== o.length)
        return !1;
      for (const [a] of s.entries())
        if (s[a] != o[a])
          return !1;
      return !0;
    }
    return () => {
      var s, o;
      const a = (s = t.default) == null ? void 0 : s.call(t), l = [];
      function c(p) {
        Array.isArray(p) && p.forEach((f) => {
          var m, y, g, v;
          const w = (m = (f == null ? void 0 : f.type) || {}) == null ? void 0 : m.name;
          w === "ElOptionGroup" ? c(!ln(f.children) && !Array.isArray(f.children) && an((y = f.children) == null ? void 0 : y.default) ? (g = f.children) == null ? void 0 : g.default() : f.children) : w === "ElOption" ? l.push((v = f.props) == null ? void 0 : v.label) : Array.isArray(f.children) && c(f.children);
        });
      }
      return a.length && c((o = a[0]) == null ? void 0 : o.children), i(l, r) || (r = l, n("update-options", l)), a;
    };
  }
});
const w5 = "ElSelect", HMe = fe({
  name: w5,
  componentName: w5,
  components: {
    ElInput: eG,
    ElSelectMenu: UMe,
    ElOption: U3,
    ElOptions: WMe,
    ElTag: vC,
    ElScrollbar: F3,
    ElTooltip: pC,
    ElIcon: Ht
  },
  directives: { ClickOutside: mG },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: Eq
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: t2.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: Yi,
      default: JS
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: Yi,
      default: yq
    },
    tagType: { ...B3.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    suffixTransition: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: String,
      values: YS,
      default: "bottom-start"
    },
    ariaLabel: {
      type: String,
      default: void 0
    }
  },
  emits: [
    jt,
    Oa,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const n = tt("select"), r = tt("input"), { t: i } = Dp(), s = dc(), o = qMe(e), {
      optionList: a,
      optionsArray: l,
      hoverOption: c,
      selectSize: p,
      readonly: f,
      handleResize: m,
      collapseTagSize: y,
      debouncedOnInputChange: g,
      debouncedQueryChange: v,
      deletePrevTag: w,
      deleteTag: b,
      deleteSelected: S,
      handleOptionSelect: $,
      scrollToOption: I,
      setSelected: M,
      resetInputHeight: E,
      managePlaceholder: C,
      showClose: A,
      selectDisabled: W,
      iconComponent: j,
      iconReverse: G,
      showNewOption: R,
      emptyText: V,
      toggleLastOptionHitState: Q,
      resetInputState: de,
      handleComposition: _e,
      onOptionCreate: ie,
      onOptionDestroy: Ae,
      handleMenuEnter: Pe,
      handleFocus: Bt,
      focus: wt,
      blur: Ut,
      handleBlur: un,
      handleClearClick: An,
      handleClose: Pn,
      handleKeydownEscape: Un,
      toggleMenu: Me,
      selectOption: Ue,
      getValueKey: Xe,
      navigateOptions: lt,
      handleDeleteTooltipTag: Tt,
      dropMenuVisible: bn,
      reference: tr,
      input: Pi,
      iOSInput: ni,
      tooltipRef: Lr,
      tagTooltipRef: ri,
      tags: Fr,
      selectWrapper: Ri,
      scrollbar: wn,
      queryChange: ii,
      groupQueryChange: Nr,
      handleMouseEnter: si,
      handleMouseLeave: oi,
      showTagList: pe,
      collapseTagList: qe,
      selectTagsStyle: ht
    } = GMe(e, o, t), {
      inputWidth: _n,
      selected: Li,
      inputLength: Zs,
      filteredOptionsCount: zo,
      visible: re,
      selectedLabel: me,
      hoverIndex: Ee,
      query: yt,
      inputHovering: Dr,
      currentPlaceholder: nr,
      menuVisibleOnFocus: Tr,
      isOnComposition: pm,
      options: jp,
      cachedOptions: hm,
      optionsCount: fm,
      prefixWidth: z
    } = hc(o), ae = P(() => {
      const ut = [n.b()], ds = _(p);
      return ds && ut.push(n.m(ds)), e.disabled && ut.push(n.m("disabled")), ut;
    }), Se = P(() => [
      n.e("tags"),
      n.is("disabled", _(W))
    ]), Je = P(() => [
      n.b("tags-wrapper"),
      { "has-prefix": _(z) && _(Li).length }
    ]), pr = P(() => [
      n.e("input"),
      n.is(_(p)),
      n.is("disabled", _(W))
    ]), Er = P(() => [
      n.e("input"),
      n.is(_(p)),
      n.em("input", "iOS")
    ]), ai = P(() => [
      n.is("empty", !e.allowCreate && !!_(yt) && _(zo) === 0)
    ]), cs = P(() => ({ maxWidth: `${_(_n) > 123 && _(Li).length > e.maxCollapseTags ? _(_n) - 123 : _(_n) - 75}px` })), li = P(() => ({
      marginLeft: `${_(z)}px`,
      flexGrow: 1,
      width: `${_(Zs) / (_(_n) - 32)}%`,
      maxWidth: `${_(_n) - 42}px`
    }));
    _r(n2, is({
      props: e,
      options: jp,
      optionsArray: l,
      cachedOptions: hm,
      optionsCount: fm,
      filteredOptionsCount: zo,
      hoverIndex: Ee,
      handleOptionSelect: $,
      onOptionCreate: ie,
      onOptionDestroy: Ae,
      selectWrapper: Ri,
      selected: Li,
      setSelected: M,
      queryChange: ii,
      groupQueryChange: Nr
    })), Yt(() => {
      o.cachedPlaceHolder = nr.value = e.placeholder || (() => i("el.select.placeholder")), e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (nr.value = ""), Lp(Ri, m), e.remote && e.multiple && E(), rt(() => {
        const ut = tr.value && tr.value.$el;
        if (ut && (_n.value = ut.getBoundingClientRect().width, t.slots.prefix)) {
          const ds = ut.querySelector(`.${r.e("prefix")}`);
          z.value = Math.max(ds.getBoundingClientRect().width + 11, 30);
        }
      }), M();
    }), e.multiple && !Array.isArray(e.modelValue) && t.emit(jt, []), !e.multiple && Array.isArray(e.modelValue) && t.emit(jt, "");
    const Vp = P(() => {
      var ut, ds;
      return (ds = (ut = Lr.value) == null ? void 0 : ut.popperRef) == null ? void 0 : ds.contentRef;
    });
    return {
      isIOS: NU,
      onOptionsRendered: (ut) => {
        a.value = ut;
      },
      prefixWidth: z,
      selectSize: p,
      readonly: f,
      handleResize: m,
      collapseTagSize: y,
      debouncedOnInputChange: g,
      debouncedQueryChange: v,
      deletePrevTag: w,
      deleteTag: b,
      handleDeleteTooltipTag: Tt,
      deleteSelected: S,
      handleOptionSelect: $,
      scrollToOption: I,
      inputWidth: _n,
      selected: Li,
      inputLength: Zs,
      filteredOptionsCount: zo,
      visible: re,
      selectedLabel: me,
      hoverIndex: Ee,
      query: yt,
      inputHovering: Dr,
      currentPlaceholder: nr,
      menuVisibleOnFocus: Tr,
      isOnComposition: pm,
      options: jp,
      resetInputHeight: E,
      managePlaceholder: C,
      showClose: A,
      selectDisabled: W,
      iconComponent: j,
      iconReverse: G,
      showNewOption: R,
      emptyText: V,
      toggleLastOptionHitState: Q,
      resetInputState: de,
      handleComposition: _e,
      handleMenuEnter: Pe,
      handleFocus: Bt,
      focus: wt,
      blur: Ut,
      handleBlur: un,
      handleClearClick: An,
      handleClose: Pn,
      handleKeydownEscape: Un,
      toggleMenu: Me,
      selectOption: Ue,
      getValueKey: Xe,
      navigateOptions: lt,
      dropMenuVisible: bn,
      reference: tr,
      input: Pi,
      iOSInput: ni,
      tooltipRef: Lr,
      popperPaneRef: Vp,
      tags: Fr,
      selectWrapper: Ri,
      scrollbar: wn,
      wrapperKls: ae,
      tagsKls: Se,
      tagWrapperKls: Je,
      inputKls: pr,
      iOSInputKls: Er,
      scrollbarKls: ai,
      selectTagsStyle: ht,
      nsSelect: n,
      tagTextStyle: cs,
      inputStyle: li,
      handleMouseEnter: si,
      handleMouseLeave: oi,
      showTagList: pe,
      collapseTagList: qe,
      tagTooltipRef: ri,
      contentId: s,
      hoverOption: c
    };
  }
}), JMe = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], ZMe = ["disabled"], KMe = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function YMe(e, t, n, r, i, s) {
  const o = Vn("el-tag"), a = Vn("el-tooltip"), l = Vn("el-icon"), c = Vn("el-input"), p = Vn("el-option"), f = Vn("el-options"), m = Vn("el-scrollbar"), y = Vn("el-select-menu"), g = AW("click-outside");
  return nn((F(), X("div", {
    ref: "selectWrapper",
    class: Z(e.wrapperKls),
    onMouseenter: t[22] || (t[22] = (...v) => e.handleMouseEnter && e.handleMouseEnter(...v)),
    onMouseleave: t[23] || (t[23] = (...v) => e.handleMouseLeave && e.handleMouseLeave(...v)),
    onClick: t[24] || (t[24] = Dt((...v) => e.toggleMenu && e.toggleMenu(...v), ["stop"]))
  }, [
    ye(a, {
      ref: "tooltipRef",
      visible: e.dropMenuVisible,
      placement: e.placement,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "popper-options": e.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: e.effect,
      pure: "",
      trigger: "click",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: e.persistent,
      onShow: e.handleMenuEnter
    }, {
      default: te(() => {
        var v, w;
        return [
          ee("div", {
            class: "select-trigger",
            onMouseenter: t[20] || (t[20] = (b) => e.inputHovering = !0),
            onMouseleave: t[21] || (t[21] = (b) => e.inputHovering = !1)
          }, [
            e.multiple ? (F(), X("div", {
              key: 0,
              ref: "tags",
              tabindex: "-1",
              class: Z(e.tagsKls),
              style: It(e.selectTagsStyle),
              onClick: t[15] || (t[15] = (...b) => e.focus && e.focus(...b))
            }, [
              e.collapseTags && e.selected.length ? (F(), ce(ko, {
                key: 0,
                onAfterLeave: e.resetInputHeight
              }, {
                default: te(() => [
                  ee("span", {
                    class: Z(e.tagWrapperKls)
                  }, [
                    (F(!0), X(Ft, null, bi(e.showTagList, (b) => (F(), ce(o, {
                      key: e.getValueKey(b),
                      closable: !e.selectDisabled && !b.isDisabled,
                      size: e.collapseTagSize,
                      hit: b.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (S) => e.deleteTag(S, b)
                    }, {
                      default: te(() => [
                        ee("span", {
                          class: Z(e.nsSelect.e("tags-text")),
                          style: It(e.tagTextStyle)
                        }, it(b.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    e.selected.length > e.maxCollapseTags ? (F(), ce(o, {
                      key: 0,
                      closable: !1,
                      size: e.collapseTagSize,
                      type: e.tagType,
                      "disable-transitions": ""
                    }, {
                      default: te(() => [
                        e.collapseTagsTooltip ? (F(), ce(a, {
                          key: 0,
                          ref: "tagTooltipRef",
                          disabled: e.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: e.effect,
                          placement: "bottom",
                          teleported: e.teleported
                        }, {
                          default: te(() => [
                            ee("span", {
                              class: Z(e.nsSelect.e("tags-text"))
                            }, "+ " + it(e.selected.length - e.maxCollapseTags), 3)
                          ]),
                          content: te(() => [
                            ee("div", {
                              class: Z(e.nsSelect.e("collapse-tags"))
                            }, [
                              (F(!0), X(Ft, null, bi(e.collapseTagList, (b) => (F(), X("div", {
                                key: e.getValueKey(b),
                                class: Z(e.nsSelect.e("collapse-tag"))
                              }, [
                                ye(o, {
                                  class: "in-tooltip",
                                  closable: !e.selectDisabled && !b.isDisabled,
                                  size: e.collapseTagSize,
                                  hit: b.hitState,
                                  type: e.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (S) => e.handleDeleteTooltipTag(S, b)
                                }, {
                                  default: te(() => [
                                    ee("span", {
                                      class: Z(e.nsSelect.e("tags-text")),
                                      style: It({
                                        maxWidth: e.inputWidth - 75 + "px"
                                      })
                                    }, it(b.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (F(), X("span", {
                          key: 1,
                          class: Z(e.nsSelect.e("tags-text"))
                        }, "+ " + it(e.selected.length - e.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : he("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : he("v-if", !0),
              e.collapseTags ? he("v-if", !0) : (F(), ce(ko, {
                key: 1,
                onAfterLeave: e.resetInputHeight
              }, {
                default: te(() => [
                  ee("span", {
                    class: Z(e.tagWrapperKls),
                    style: It(e.prefixWidth && e.selected.length ? { marginLeft: `${e.prefixWidth}px` } : "")
                  }, [
                    (F(!0), X(Ft, null, bi(e.selected, (b) => (F(), ce(o, {
                      key: e.getValueKey(b),
                      closable: !e.selectDisabled && !b.isDisabled,
                      size: e.collapseTagSize,
                      hit: b.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (S) => e.deleteTag(S, b)
                    }, {
                      default: te(() => [
                        ee("span", {
                          class: Z(e.nsSelect.e("tags-text")),
                          style: It({ maxWidth: e.inputWidth - 75 + "px" })
                        }, it(b.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 6)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              e.filterable && !e.selectDisabled ? nn((F(), X("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": t[0] || (t[0] = (b) => e.query = b),
                type: "text",
                class: Z(e.inputKls),
                disabled: e.selectDisabled,
                autocomplete: e.autocomplete,
                style: It(e.inputStyle),
                role: "combobox",
                "aria-activedescendant": ((v = e.hoverOption) == null ? void 0 : v.id) || "",
                "aria-controls": e.contentId,
                "aria-expanded": e.dropMenuVisible,
                "aria-label": e.ariaLabel,
                "aria-autocomplete": "none",
                "aria-haspopup": "listbox",
                onFocus: t[1] || (t[1] = (...b) => e.handleFocus && e.handleFocus(...b)),
                onBlur: t[2] || (t[2] = (...b) => e.handleBlur && e.handleBlur(...b)),
                onKeyup: t[3] || (t[3] = (...b) => e.managePlaceholder && e.managePlaceholder(...b)),
                onKeydown: [
                  t[4] || (t[4] = (...b) => e.resetInputState && e.resetInputState(...b)),
                  t[5] || (t[5] = Ui(Dt((b) => e.navigateOptions("next"), ["prevent"]), ["down"])),
                  t[6] || (t[6] = Ui(Dt((b) => e.navigateOptions("prev"), ["prevent"]), ["up"])),
                  t[7] || (t[7] = Ui((...b) => e.handleKeydownEscape && e.handleKeydownEscape(...b), ["esc"])),
                  t[8] || (t[8] = Ui(Dt((...b) => e.selectOption && e.selectOption(...b), ["stop", "prevent"]), ["enter"])),
                  t[9] || (t[9] = Ui((...b) => e.deletePrevTag && e.deletePrevTag(...b), ["delete"])),
                  t[10] || (t[10] = Ui((b) => e.visible = !1, ["tab"]))
                ],
                onCompositionstart: t[11] || (t[11] = (...b) => e.handleComposition && e.handleComposition(...b)),
                onCompositionupdate: t[12] || (t[12] = (...b) => e.handleComposition && e.handleComposition(...b)),
                onCompositionend: t[13] || (t[13] = (...b) => e.handleComposition && e.handleComposition(...b)),
                onInput: t[14] || (t[14] = (...b) => e.debouncedQueryChange && e.debouncedQueryChange(...b))
              }, null, 46, JMe)), [
                [X5, e.query]
              ]) : he("v-if", !0)
            ], 6)) : he("v-if", !0),
            e.isIOS && !e.multiple && e.filterable && e.readonly ? (F(), X("input", {
              key: 1,
              ref: "iOSInput",
              class: Z(e.iOSInputKls),
              disabled: e.selectDisabled,
              type: "text"
            }, null, 10, ZMe)) : he("v-if", !0),
            ye(c, {
              id: e.id,
              ref: "reference",
              modelValue: e.selectedLabel,
              "onUpdate:modelValue": t[16] || (t[16] = (b) => e.selectedLabel = b),
              type: "text",
              placeholder: typeof e.currentPlaceholder == "function" ? e.currentPlaceholder() : e.currentPlaceholder,
              name: e.name,
              autocomplete: e.autocomplete,
              size: e.selectSize,
              disabled: e.selectDisabled,
              readonly: e.readonly,
              "validate-event": !1,
              class: Z([e.nsSelect.is("focus", e.visible)]),
              tabindex: e.multiple && e.filterable ? -1 : void 0,
              role: "combobox",
              "aria-activedescendant": ((w = e.hoverOption) == null ? void 0 : w.id) || "",
              "aria-controls": e.contentId,
              "aria-expanded": e.dropMenuVisible,
              label: e.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: e.handleFocus,
              onBlur: e.handleBlur,
              onInput: e.debouncedOnInputChange,
              onPaste: e.debouncedOnInputChange,
              onCompositionstart: e.handleComposition,
              onCompositionupdate: e.handleComposition,
              onCompositionend: e.handleComposition,
              onKeydown: [
                t[17] || (t[17] = Ui(Dt((b) => e.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                t[18] || (t[18] = Ui(Dt((b) => e.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                Ui(Dt(e.selectOption, ["stop", "prevent"]), ["enter"]),
                Ui(e.handleKeydownEscape, ["esc"]),
                t[19] || (t[19] = Ui((b) => e.visible = !1, ["tab"]))
              ]
            }, b$({
              suffix: te(() => [
                e.iconComponent && !e.showClose ? (F(), ce(l, {
                  key: 0,
                  class: Z([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
                }, {
                  default: te(() => [
                    (F(), ce(Mn(e.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : he("v-if", !0),
                e.showClose && e.clearIcon ? (F(), ce(l, {
                  key: 1,
                  class: Z([e.nsSelect.e("caret"), e.nsSelect.e("icon")]),
                  onClick: e.handleClearClick
                }, {
                  default: te(() => [
                    (F(), ce(Mn(e.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : he("v-if", !0)
              ]),
              _: 2
            }, [
              e.$slots.prefix ? {
                name: "prefix",
                fn: te(() => [
                  ee("div", KMe, [
                    je(e.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ];
      }),
      content: te(() => [
        ye(y, null, b$({
          default: te(() => [
            nn(ye(m, {
              id: e.contentId,
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": e.nsSelect.be("dropdown", "wrap"),
              "view-class": e.nsSelect.be("dropdown", "list"),
              class: Z(e.scrollbarKls),
              role: "listbox",
              "aria-label": e.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: te(() => [
                e.showNewOption ? (F(), ce(p, {
                  key: 0,
                  value: e.query,
                  created: !0
                }, null, 8, ["value"])) : he("v-if", !0),
                ye(f, { onUpdateOptions: e.onOptionsRendered }, {
                  default: te(() => [
                    je(e.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["onUpdateOptions"])
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [Ei, e.options.size > 0 && !e.loading]
            ]),
            e.emptyText && (!e.allowCreate || e.loading || e.allowCreate && e.options.size === 0) ? (F(), X(Ft, { key: 0 }, [
              e.$slots.empty ? je(e.$slots, "empty", { key: 0 }) : (F(), X("p", {
                key: 1,
                class: Z(e.nsSelect.be("dropdown", "empty"))
              }, it(e.emptyText), 3))
            ], 64)) : he("v-if", !0)
          ]),
          _: 2
        }, [
          e.$slots.header ? {
            name: "header",
            fn: te(() => [
              je(e.$slots, "header")
            ])
          } : void 0,
          e.$slots.footer ? {
            name: "footer",
            fn: te(() => [
              je(e.$slots, "footer")
            ])
          } : void 0
        ]), 1024)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [g, e.handleClose, e.popperPaneRef]
  ]);
}
var QMe = /* @__PURE__ */ at(HMe, [["render", YMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const XMe = fe({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e) {
    const t = tt("select"), n = J(!0), r = ur(), i = J([]);
    _r(kG, is({
      ...hc(e)
    }));
    const s = pt(n2);
    Yt(() => {
      i.value = o(r.subTree);
    });
    const o = (l) => {
      const c = [];
      return Array.isArray(l.children) && l.children.forEach((p) => {
        var f;
        p.type && p.type.name === "ElOption" && p.component && p.component.proxy ? c.push(p.component.proxy) : (f = p.children) != null && f.length && c.push(...o(p));
      }), c;
    }, { groupQueryChange: a } = uf(s);
    return Ie(a, () => {
      n.value = i.value.some((l) => l.visible === !0);
    }, { flush: "post" }), {
      visible: n,
      ns: t
    };
  }
});
function eCe(e, t, n, r, i, s) {
  return nn((F(), X("ul", {
    class: Z(e.ns.be("group", "wrap"))
  }, [
    ee("li", {
      class: Z(e.ns.be("group", "title"))
    }, it(e.label), 3),
    ee("li", null, [
      ee("ul", {
        class: Z(e.ns.b("group"))
      }, [
        je(e.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [Ei, e.visible]
  ]);
}
var AG = /* @__PURE__ */ at(XMe, [["render", eCe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const _5 = Ai(QMe, {
  Option: U3,
  OptionGroup: AG
}), Um = bc(U3);
bc(AG);
const tCe = bt({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: Eq
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: Yi
  },
  activeActionIcon: {
    type: Yi
  },
  activeIcon: {
    type: Yi
  },
  inactiveIcon: {
    type: Yi
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: Be(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  label: {
    type: String,
    default: void 0
  }
}), nCe = {
  [jt]: (e) => Qr(e) || ln(e) || yn(e),
  [Oa]: (e) => Qr(e) || ln(e) || yn(e),
  [eC]: (e) => Qr(e) || ln(e) || yn(e)
}, rCe = ["onClick"], iCe = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], sCe = ["aria-hidden"], oCe = ["aria-hidden"], aCe = ["aria-hidden"], Ww = "ElSwitch", lCe = fe({
  name: Ww
}), uCe = /* @__PURE__ */ fe({
  ...lCe,
  props: tCe,
  emits: nCe,
  setup(e, { expose: t, emit: n }) {
    const r = e, i = ur(), { formItem: s } = jl(), o = Do(), a = tt("switch");
    ((A) => {
      A.forEach((W) => {
        i0({
          from: W[0],
          replacement: W[1],
          scope: Ww,
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/switch.html#attributes",
          type: "Attribute"
        }, P(() => {
          var j;
          return !!((j = i.vnode.props) != null && j[W[2]]);
        }));
      });
    })([
      ['"value"', '"model-value" or "v-model"', "value"],
      ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
      ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
      ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
    ]);
    const { inputId: c } = Z0(r, {
      formItemContext: s
    }), p = lm(P(() => r.loading)), f = J(r.modelValue !== !1), m = J(), y = J(), g = P(() => [
      a.b(),
      a.m(o.value),
      a.is("disabled", p.value),
      a.is("checked", $.value)
    ]), v = P(() => [
      a.e("label"),
      a.em("label", "left"),
      a.is("active", !$.value)
    ]), w = P(() => [
      a.e("label"),
      a.em("label", "right"),
      a.is("active", $.value)
    ]), b = P(() => ({
      width: Rl(r.width)
    }));
    Ie(() => r.modelValue, () => {
      f.value = !0;
    }), Ie(() => r.value, () => {
      f.value = !1;
    });
    const S = P(() => f.value ? r.modelValue : r.value), $ = P(() => S.value === r.activeValue);
    [r.activeValue, r.inactiveValue].includes(S.value) || (n(jt, r.inactiveValue), n(Oa, r.inactiveValue), n(eC, r.inactiveValue)), Ie($, (A) => {
      var W;
      m.value.checked = A, r.validateEvent && ((W = s == null ? void 0 : s.validate) == null || W.call(s, "change").catch((j) => Zt(j)));
    });
    const I = () => {
      const A = $.value ? r.inactiveValue : r.activeValue;
      n(jt, A), n(Oa, A), n(eC, A), rt(() => {
        m.value.checked = $.value;
      });
    }, M = () => {
      if (p.value)
        return;
      const { beforeChange: A } = r;
      if (!A) {
        I();
        return;
      }
      const W = A();
      [
        UM(W),
        Qr(W)
      ].includes(!0) || HS(Ww, "beforeChange must return type `Promise<boolean>` or `boolean`"), UM(W) ? W.then((G) => {
        G && I();
      }).catch((G) => {
        Zt(Ww, `some error occurred: ${G}`);
      }) : W && I();
    }, E = P(() => a.cssVarBlock({
      ...r.activeColor ? { "on-color": r.activeColor } : null,
      ...r.inactiveColor ? { "off-color": r.inactiveColor } : null,
      ...r.borderColor ? { "border-color": r.borderColor } : null
    })), C = () => {
      var A, W;
      (W = (A = m.value) == null ? void 0 : A.focus) == null || W.call(A);
    };
    return Yt(() => {
      m.value.checked = $.value;
    }), t({
      focus: C,
      checked: $
    }), (A, W) => (F(), X("div", {
      class: Z(_(g)),
      style: It(_(E)),
      onClick: Dt(M, ["prevent"])
    }, [
      ee("input", {
        id: _(c),
        ref_key: "input",
        ref: m,
        class: Z(_(a).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": _($),
        "aria-disabled": _(p),
        "aria-label": A.label,
        name: A.name,
        "true-value": A.activeValue,
        "false-value": A.inactiveValue,
        disabled: _(p),
        tabindex: A.tabindex,
        onChange: I,
        onKeydown: Ui(M, ["enter"])
      }, null, 42, iCe),
      !A.inlinePrompt && (A.inactiveIcon || A.inactiveText) ? (F(), X("span", {
        key: 0,
        class: Z(_(v))
      }, [
        A.inactiveIcon ? (F(), ce(_(Ht), { key: 0 }, {
          default: te(() => [
            (F(), ce(Mn(A.inactiveIcon)))
          ]),
          _: 1
        })) : he("v-if", !0),
        !A.inactiveIcon && A.inactiveText ? (F(), X("span", {
          key: 1,
          "aria-hidden": _($)
        }, it(A.inactiveText), 9, sCe)) : he("v-if", !0)
      ], 2)) : he("v-if", !0),
      ee("span", {
        ref_key: "core",
        ref: y,
        class: Z(_(a).e("core")),
        style: It(_(b))
      }, [
        A.inlinePrompt ? (F(), X("div", {
          key: 0,
          class: Z(_(a).e("inner"))
        }, [
          A.activeIcon || A.inactiveIcon ? (F(), ce(_(Ht), {
            key: 0,
            class: Z(_(a).is("icon"))
          }, {
            default: te(() => [
              (F(), ce(Mn(_($) ? A.activeIcon : A.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : A.activeText || A.inactiveText ? (F(), X("span", {
            key: 1,
            class: Z(_(a).is("text")),
            "aria-hidden": !_($)
          }, it(_($) ? A.activeText : A.inactiveText), 11, oCe)) : he("v-if", !0)
        ], 2)) : he("v-if", !0),
        ee("div", {
          class: Z(_(a).e("action"))
        }, [
          A.loading ? (F(), ce(_(Ht), {
            key: 0,
            class: Z(_(a).is("loading"))
          }, {
            default: te(() => [
              ye(_(G0))
            ]),
            _: 1
          }, 8, ["class"])) : A.activeActionIcon && _($) ? (F(), ce(_(Ht), { key: 1 }, {
            default: te(() => [
              (F(), ce(Mn(A.activeActionIcon)))
            ]),
            _: 1
          })) : A.inactiveActionIcon && !_($) ? (F(), ce(_(Ht), { key: 2 }, {
            default: te(() => [
              (F(), ce(Mn(A.inactiveActionIcon)))
            ]),
            _: 1
          })) : he("v-if", !0)
        ], 2)
      ], 6),
      !A.inlinePrompt && (A.activeIcon || A.activeText) ? (F(), X("span", {
        key: 1,
        class: Z(_(w))
      }, [
        A.activeIcon ? (F(), ce(_(Ht), { key: 0 }, {
          default: te(() => [
            (F(), ce(Mn(A.activeIcon)))
          ]),
          _: 1
        })) : he("v-if", !0),
        !A.activeIcon && A.activeText ? (F(), X("span", {
          key: 1,
          "aria-hidden": !_($)
        }, it(A.activeText), 9, aCe)) : he("v-if", !0)
      ], 2)) : he("v-if", !0)
    ], 14, rCe));
  }
});
var cCe = /* @__PURE__ */ at(uCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const md = Ai(cCe);
function dCe(e) {
  let t;
  const n = J(!1), r = is({
    ...e,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function i(m) {
    r.text = m;
  }
  function s() {
    const m = r.parent, y = f.ns;
    if (!m.vLoadingAddClassList) {
      let g = m.getAttribute("loading-number");
      g = Number.parseInt(g) - 1, g ? m.setAttribute("loading-number", g.toString()) : (r0(m, y.bm("parent", "relative")), m.removeAttribute("loading-number")), r0(m, y.bm("parent", "hidden"));
    }
    o(), p.unmount();
  }
  function o() {
    var m, y;
    (y = (m = f.$el) == null ? void 0 : m.parentNode) == null || y.removeChild(f.$el);
  }
  function a() {
    var m;
    e.beforeClose && !e.beforeClose() || (n.value = !0, clearTimeout(t), t = window.setTimeout(l, 400), r.visible = !1, (m = e.closed) == null || m.call(e));
  }
  function l() {
    if (!n.value)
      return;
    const m = r.parent;
    n.value = !1, m.vLoadingAddClassList = void 0, s();
  }
  const c = fe({
    name: "ElLoading",
    setup(m, { expose: y }) {
      const { ns: g, zIndex: v } = L3("loading");
      return y({
        ns: g,
        zIndex: v
      }), () => {
        const w = r.spinner || r.svg, b = vl("svg", {
          class: "circular",
          viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
          ...w ? { innerHTML: w } : {}
        }, [
          vl("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), S = r.text ? vl("p", { class: g.b("text") }, [r.text]) : void 0;
        return vl(ko, {
          name: g.b("fade"),
          onAfterLeave: l
        }, {
          default: te(() => [
            nn(ye("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [
                g.b("mask"),
                r.customClass,
                r.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              vl("div", {
                class: g.b("spinner")
              }, [b, S])
            ]), [[Ei, r.visible]])
          ])
        });
      };
    }
  }), p = PW(c), f = p.mount(document.createElement("div"));
  return {
    ...hc(r),
    setText: i,
    removeElLoadingChild: o,
    close: a,
    handleAfterLeave: l,
    vm: f,
    get $el() {
      return f.$el;
    }
  };
}
let hb;
const bC = function(e = {}) {
  if (!zt)
    return;
  const t = pCe(e);
  if (t.fullscreen && hb)
    return hb;
  const n = dCe({
    ...t,
    closed: () => {
      var i;
      (i = t.closed) == null || i.call(t), t.fullscreen && (hb = void 0);
    }
  });
  hCe(t, t.parent, n), S5(t, t.parent, n), t.parent.vLoadingAddClassList = () => S5(t, t.parent, n);
  let r = t.parent.getAttribute("loading-number");
  return r ? r = `${Number.parseInt(r) + 1}` : r = "1", t.parent.setAttribute("loading-number", r), t.parent.appendChild(n.$el), rt(() => n.visible.value = t.visible), t.fullscreen && (hb = n), n;
}, pCe = (e) => {
  var t, n, r, i;
  let s;
  return ln(e.target) ? s = (t = document.querySelector(e.target)) != null ? t : document.body : s = e.target || document.body, {
    parent: s === document.body || e.body ? document.body : s,
    background: e.background || "",
    svg: e.svg || "",
    svgViewBox: e.svgViewBox || "",
    spinner: e.spinner || !1,
    text: e.text || "",
    fullscreen: s === document.body && ((n = e.fullscreen) != null ? n : !0),
    lock: (r = e.lock) != null ? r : !1,
    customClass: e.customClass || "",
    visible: (i = e.visible) != null ? i : !0,
    target: s
  };
}, hCe = async (e, t, n) => {
  const { nextZIndex: r } = n.vm.zIndex || n.vm._.exposed.zIndex, i = {};
  if (e.fullscreen)
    n.originalPosition.value = Fh(document.body, "position"), n.originalOverflow.value = Fh(document.body, "overflow"), i.zIndex = r();
  else if (e.parent === document.body) {
    n.originalPosition.value = Fh(document.body, "position"), await rt();
    for (const s of ["top", "left"]) {
      const o = s === "top" ? "scrollTop" : "scrollLeft";
      i[s] = `${e.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(Fh(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
      i[s] = `${e.target.getBoundingClientRect()[s]}px`;
  } else
    n.originalPosition.value = Fh(t, "position");
  for (const [s, o] of Object.entries(i))
    n.$el.style[s] = o;
}, S5 = (e, t, n) => {
  const r = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? r0(t, r.bm("parent", "relative")) : XM(t, r.bm("parent", "relative")), e.fullscreen && e.lock ? XM(t, r.bm("parent", "hidden")) : r0(t, r.bm("parent", "hidden"));
}, wC = Symbol("ElLoading"), x5 = (e, t) => {
  var n, r, i, s;
  const o = t.instance, a = (m) => Rr(t.value) ? t.value[m] : void 0, l = (m) => {
    const y = ln(m) && (o == null ? void 0 : o[m]) || m;
    return y && J(y);
  }, c = (m) => l(a(m) || e.getAttribute(`element-loading-${ive(m)}`)), p = (n = a("fullscreen")) != null ? n : t.modifiers.fullscreen, f = {
    text: c("text"),
    svg: c("svg"),
    svgViewBox: c("svgViewBox"),
    spinner: c("spinner"),
    background: c("background"),
    customClass: c("customClass"),
    fullscreen: p,
    target: (r = a("target")) != null ? r : p ? void 0 : e,
    body: (i = a("body")) != null ? i : t.modifiers.body,
    lock: (s = a("lock")) != null ? s : t.modifiers.lock
  };
  e[wC] = {
    options: f,
    instance: bC(f)
  };
}, fCe = (e, t) => {
  for (const n of Object.keys(t))
    $a(t[n]) && (t[n].value = e[n]);
}, $5 = {
  mounted(e, t) {
    t.value && x5(e, t);
  },
  updated(e, t) {
    const n = e[wC];
    t.oldValue !== t.value && (t.value && !t.oldValue ? x5(e, t) : t.value && t.oldValue ? Rr(t.value) && fCe(t.value, n.options) : n == null || n.instance.close());
  },
  unmounted(e) {
    var t;
    (t = e[wC]) == null || t.instance.close();
  }
}, mCe = {
  install(e) {
    e.directive("loading", $5), e.config.globalProperties.$loading = bC;
  },
  directive: $5,
  service: bC
}, PG = ["success", "info", "warning", "error"], yi = Iq({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: zt ? document.body : void 0
}), yCe = bt({
  customClass: {
    type: String,
    default: yi.customClass
  },
  center: {
    type: Boolean,
    default: yi.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: yi.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: yi.duration
  },
  icon: {
    type: Yi,
    default: yi.icon
  },
  id: {
    type: String,
    default: yi.id
  },
  message: {
    type: Be([
      String,
      Object,
      Function
    ]),
    default: yi.message
  },
  onClose: {
    type: Be(Function),
    required: !1
  },
  showClose: {
    type: Boolean,
    default: yi.showClose
  },
  type: {
    type: String,
    values: PG,
    default: yi.type
  },
  offset: {
    type: Number,
    default: yi.offset
  },
  zIndex: {
    type: Number,
    default: yi.zIndex
  },
  grouping: {
    type: Boolean,
    default: yi.grouping
  },
  repeatNum: {
    type: Number,
    default: yi.repeatNum
  }
}), gCe = {
  destroy: () => !0
}, Mo = RW([]), vCe = (e) => {
  const t = Mo.findIndex((i) => i.id === e), n = Mo[t];
  let r;
  return t > 0 && (r = Mo[t - 1]), { current: n, prev: r };
}, bCe = (e) => {
  const { prev: t } = vCe(e);
  return t ? t.vm.exposed.bottom.value : 0;
}, wCe = (e, t) => Mo.findIndex((r) => r.id === e) > 0 ? 20 : t, _Ce = ["id"], SCe = ["innerHTML"], xCe = fe({
  name: "ElMessage"
}), $Ce = /* @__PURE__ */ fe({
  ...xCe,
  props: yCe,
  emits: gCe,
  setup(e, { expose: t }) {
    const n = e, { Close: r } = f2e, { ns: i, zIndex: s } = L3("message"), { currentZIndex: o, nextZIndex: a } = s, l = J(), c = J(!1), p = J(0);
    let f;
    const m = P(() => n.type ? n.type === "error" ? "danger" : n.type : "info"), y = P(() => {
      const C = n.type;
      return { [i.bm("icon", C)]: C && x_[C] };
    }), g = P(() => n.icon || x_[n.type] || ""), v = P(() => bCe(n.id)), w = P(() => wCe(n.id, n.offset) + v.value), b = P(() => p.value + w.value), S = P(() => ({
      top: `${w.value}px`,
      zIndex: o.value
    }));
    function $() {
      n.duration !== 0 && ({ stop: f } = y_(() => {
        M();
      }, n.duration));
    }
    function I() {
      f == null || f();
    }
    function M() {
      c.value = !1;
    }
    function E({ code: C }) {
      C === on.esc && M();
    }
    return Yt(() => {
      $(), a(), c.value = !0;
    }), Ie(() => n.repeatNum, () => {
      I(), $();
    }), Il(document, "keydown", E), Lp(l, () => {
      p.value = l.value.getBoundingClientRect().height;
    }), t({
      visible: c,
      bottom: b,
      close: M
    }), (C, A) => (F(), ce(ko, {
      name: _(i).b("fade"),
      onBeforeLeave: C.onClose,
      onAfterLeave: A[0] || (A[0] = (W) => C.$emit("destroy")),
      persisted: ""
    }, {
      default: te(() => [
        nn(ee("div", {
          id: C.id,
          ref_key: "messageRef",
          ref: l,
          class: Z([
            _(i).b(),
            { [_(i).m(C.type)]: C.type && !C.icon },
            _(i).is("center", C.center),
            _(i).is("closable", C.showClose),
            C.customClass
          ]),
          style: It(_(S)),
          role: "alert",
          onMouseenter: I,
          onMouseleave: $
        }, [
          C.repeatNum > 1 ? (F(), ce(_(AEe), {
            key: 0,
            value: C.repeatNum,
            type: _(m),
            class: Z(_(i).e("badge"))
          }, null, 8, ["value", "type", "class"])) : he("v-if", !0),
          _(g) ? (F(), ce(_(Ht), {
            key: 1,
            class: Z([_(i).e("icon"), _(y)])
          }, {
            default: te(() => [
              (F(), ce(Mn(_(g))))
            ]),
            _: 1
          }, 8, ["class"])) : he("v-if", !0),
          je(C.$slots, "default", {}, () => [
            C.dangerouslyUseHTMLString ? (F(), X(Ft, { key: 1 }, [
              he(" Caution here, message could've been compromised, never use user's input as message "),
              ee("p", {
                class: Z(_(i).e("content")),
                innerHTML: C.message
              }, null, 10, SCe)
            ], 2112)) : (F(), X("p", {
              key: 0,
              class: Z(_(i).e("content"))
            }, it(C.message), 3))
          ]),
          C.showClose ? (F(), ce(_(Ht), {
            key: 2,
            class: Z(_(i).e("closeBtn")),
            onClick: Dt(M, ["stop"])
          }, {
            default: te(() => [
              ye(_(r))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : he("v-if", !0)
        ], 46, _Ce), [
          [Ei, c.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var TCe = /* @__PURE__ */ at($Ce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let ECe = 1;
const RG = (e) => {
  const t = !e || ln(e) || $g(e) || an(e) ? { message: e } : e, n = {
    ...yi,
    ...t
  };
  if (!n.appendTo)
    n.appendTo = document.body;
  else if (ln(n.appendTo)) {
    let r = document.querySelector(n.appendTo);
    uc(r) || (Zt("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), r = document.body), n.appendTo = r;
  }
  return n;
}, ICe = (e) => {
  const t = Mo.indexOf(e);
  if (t === -1)
    return;
  Mo.splice(t, 1);
  const { handler: n } = e;
  n.close();
}, MCe = ({ appendTo: e, ...t }, n) => {
  const r = `message_${ECe++}`, i = t.onClose, s = document.createElement("div"), o = {
    ...t,
    id: r,
    onClose: () => {
      i == null || i(), ICe(p);
    },
    onDestroy: () => {
      Qw(null, s);
    }
  }, a = ye(TCe, o, an(o.message) || $g(o.message) ? {
    default: an(o.message) ? o.message : () => o.message
  } : null);
  a.appContext = n || Rf._context, Qw(a, s), e.appendChild(s.firstElementChild);
  const l = a.component, p = {
    id: r,
    vnode: a,
    vm: l,
    handler: {
      close: () => {
        l.exposed.visible.value = !1;
      }
    },
    props: a.component.props
  };
  return p;
}, Rf = (e = {}, t) => {
  if (!zt)
    return { close: () => {
    } };
  if (yn(sC.max) && Mo.length >= sC.max)
    return { close: () => {
    } };
  const n = RG(e);
  if (n.grouping && Mo.length) {
    const i = Mo.find(({ vnode: s }) => {
      var o;
      return ((o = s.props) == null ? void 0 : o.message) === n.message;
    });
    if (i)
      return i.props.repeatNum += 1, i.props.type = n.type, i.handler;
  }
  const r = MCe(n, t);
  return Mo.push(r), r.handler;
};
PG.forEach((e) => {
  Rf[e] = (t = {}, n) => {
    const r = RG(t);
    return Rf({ ...r, type: e }, n);
  };
});
function CCe(e) {
  for (const t of Mo)
    (!e || e === t.props.type) && t.handler.close();
}
Rf.closeAll = CCe;
Rf._context = null;
const q3 = Tq(Rf, "$message"), LG = [
  "success",
  "info",
  "warning",
  "error"
], OCe = bt({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Yi
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: Be([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Be(Function),
    default: () => {
    }
  },
  onClose: {
    type: Be(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...LG, ""],
    default: ""
  },
  zIndex: Number
}), kCe = {
  destroy: () => !0
}, ACe = ["id"], PCe = ["textContent"], RCe = { key: 0 }, LCe = ["innerHTML"], FCe = fe({
  name: "ElNotification"
}), NCe = /* @__PURE__ */ fe({
  ...FCe,
  props: OCe,
  emits: kCe,
  setup(e, { expose: t }) {
    const n = e, { ns: r, zIndex: i } = L3("notification"), { nextZIndex: s, currentZIndex: o } = i, { Close: a } = xq, l = J(!1);
    let c;
    const p = P(() => {
      const $ = n.type;
      return $ && x_[n.type] ? r.m($) : "";
    }), f = P(() => n.type && x_[n.type] || n.icon), m = P(() => n.position.endsWith("right") ? "right" : "left"), y = P(() => n.position.startsWith("top") ? "top" : "bottom"), g = P(() => {
      var $;
      return {
        [y.value]: `${n.offset}px`,
        zIndex: ($ = n.zIndex) != null ? $ : o.value
      };
    });
    function v() {
      n.duration > 0 && ({ stop: c } = y_(() => {
        l.value && b();
      }, n.duration));
    }
    function w() {
      c == null || c();
    }
    function b() {
      l.value = !1;
    }
    function S({ code: $ }) {
      $ === on.delete || $ === on.backspace ? w() : $ === on.esc ? l.value && b() : v();
    }
    return Yt(() => {
      v(), s(), l.value = !0;
    }), Il(document, "keydown", S), t({
      visible: l,
      close: b
    }), ($, I) => (F(), ce(ko, {
      name: _(r).b("fade"),
      onBeforeLeave: $.onClose,
      onAfterLeave: I[1] || (I[1] = (M) => $.$emit("destroy")),
      persisted: ""
    }, {
      default: te(() => [
        nn(ee("div", {
          id: $.id,
          class: Z([_(r).b(), $.customClass, _(m)]),
          style: It(_(g)),
          role: "alert",
          onMouseenter: w,
          onMouseleave: v,
          onClick: I[0] || (I[0] = (...M) => $.onClick && $.onClick(...M))
        }, [
          _(f) ? (F(), ce(_(Ht), {
            key: 0,
            class: Z([_(r).e("icon"), _(p)])
          }, {
            default: te(() => [
              (F(), ce(Mn(_(f))))
            ]),
            _: 1
          }, 8, ["class"])) : he("v-if", !0),
          ee("div", {
            class: Z(_(r).e("group"))
          }, [
            ee("h2", {
              class: Z(_(r).e("title")),
              textContent: it($.title)
            }, null, 10, PCe),
            nn(ee("div", {
              class: Z(_(r).e("content")),
              style: It($.title ? void 0 : { margin: 0 })
            }, [
              je($.$slots, "default", {}, () => [
                $.dangerouslyUseHTMLString ? (F(), X(Ft, { key: 1 }, [
                  he(" Caution here, message could've been compromised, never use user's input as message "),
                  ee("p", { innerHTML: $.message }, null, 8, LCe)
                ], 2112)) : (F(), X("p", RCe, it($.message), 1))
              ])
            ], 6), [
              [Ei, $.message]
            ]),
            $.showClose ? (F(), ce(_(Ht), {
              key: 0,
              class: Z(_(r).e("closeBtn")),
              onClick: Dt(b, ["stop"])
            }, {
              default: te(() => [
                ye(_(a))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : he("v-if", !0)
          ], 2)
        ], 46, ACe), [
          [Ei, l.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var DCe = /* @__PURE__ */ at(NCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
const E_ = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, _C = 16;
let jCe = 1;
const Lf = function(e = {}, t = null) {
  if (!zt)
    return { close: () => {
    } };
  (typeof e == "string" || $g(e)) && (e = { message: e });
  const n = e.position || "top-right";
  let r = e.offset || 0;
  E_[n].forEach(({ vm: p }) => {
    var f;
    r += (((f = p.el) == null ? void 0 : f.offsetHeight) || 0) + _C;
  }), r += _C;
  const i = `notification_${jCe++}`, s = e.onClose, o = {
    ...e,
    offset: r,
    id: i,
    onClose: () => {
      VCe(i, n, s);
    }
  };
  let a = document.body;
  uc(e.appendTo) ? a = e.appendTo : ln(e.appendTo) && (a = document.querySelector(e.appendTo)), uc(a) || (Zt("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), a = document.body);
  const l = document.createElement("div"), c = ye(DCe, o, $g(o.message) ? {
    default: () => o.message
  } : null);
  return c.appContext = t ?? Lf._context, c.props.onDestroy = () => {
    Qw(null, l);
  }, Qw(c, l), E_[n].push({ vm: c }), a.appendChild(l.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = !1;
    }
  };
};
LG.forEach((e) => {
  Lf[e] = (t = {}) => ((typeof t == "string" || $g(t)) && (t = {
    message: t
  }), Lf({
    ...t,
    type: e
  }));
});
function VCe(e, t, n) {
  const r = E_[t], i = r.findIndex(({ vm: c }) => {
    var p;
    return ((p = c.component) == null ? void 0 : p.props.id) === e;
  });
  if (i === -1)
    return;
  const { vm: s } = r[i];
  if (!s)
    return;
  n == null || n(s);
  const o = s.el.offsetHeight, a = t.split("-")[0];
  r.splice(i, 1);
  const l = r.length;
  if (!(l < 1))
    for (let c = i; c < l; c++) {
      const { el: p, component: f } = r[c].vm, m = Number.parseInt(p.style[a], 10) - o - _C;
      f.props.offset = m;
    }
}
function zCe() {
  for (const e of Object.values(E_))
    e.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = !1;
    });
}
Lf.closeAll = zCe;
Lf._context = null;
const BCe = Tq(Lf, "$notify"), SC = J(!1), lf = {
  name: "",
  level: "",
  color: "#999"
}, xC = [
  {
    lane: [
      {
        arrow: "trun_left",
        vol: 0
      },
      {
        arrow: "straight_right",
        vol: 0
      }
    ],
    angle: 120.08650455410778
  },
  {
    lane: [
      {
        arrow: "trun_left",
        vol: 0
      },
      {
        arrow: "straight_right",
        vol: 0
      }
    ],
    angle: -58.277576574723355
  },
  {
    lane: [
      {
        arrow: "left_straight_right",
        vol: 0
      }
    ],
    angle: 20.68849989345116
  },
  {
    lane: [
      {
        arrow: "left_straight_right",
        vol: 0
      }
    ],
    angle: -160.50816807856677
  }
];
let kc = null, ve = null;
const Rn = 20, Yp = 300, ui = 3, _g = 400, Sg = 400, T5 = 100, p$ = 1, Go = 15, UCe = 3;
function qCe(e) {
  lf.name = e.name, lf.color = e.crossData.color, lf.level = e.crossData.level, xC.length = 0, JSON.parse(JSON.stringify(e.crossData.lanes)).forEach((t) => {
    t.angle = FG(t.startPoint, t.endPoint), delete t.endPoint, delete t.startPoint, xC.push(t);
  }), SC.value = !0;
}
function GCe(e) {
  kc = e.value, kc.width = 800, kc.height = 800, ve = kc.getContext("2d"), ve.clearRect(0, 0, kc.width, kc.height), ve.strokeStyle = "yellow", ve.fillStyle = "#5c83a1", ve.beginPath(), ve.arc(_g, Sg, 100, 0, 2 * Math.PI), ve.stroke(), ve.fill(), ve.beginPath(), ve.arc(_g, Sg, 50, 0, 2 * Math.PI), ve.fillStyle = lf.color, ve.fill(), ve.fillStyle = "black", ve.font = "40px Arial", ve.textAlign = "center", ve.textBaseline = "middle", ve.fillText(lf.level, _g, Sg), ve.fillStyle = "black", ve.font = "20px Arial", ve.textAlign = "left", ve.textBaseline = "bottom", ve.fillText(lf.name, 10, kc.height - 10), xC.forEach((t) => {
    WCe(t);
  });
}
function WCe(e) {
  const { lane: t, angle: n } = e, r = t.length * Rn * 2 + ui, i = -n * Math.PI / 180, s = Math.sqrt(T5 * T5 - r / 2 * (r / 2)), o = _g + s * Math.cos(i), a = Sg + s * Math.sin(i), l = or(s, r / 2, n), c = or(s + Yp, r / 2, n), p = or(s + Yp, -r / 2, n), f = or(s, -r / 2, n);
  ve.beginPath(), ve.moveTo(l.x, l.y), ve.lineTo(c.x, c.y), ve.lineTo(p.x, p.y), ve.lineTo(f.x, f.y), ve.closePath(), ve.fillStyle = "#5c83a1", ve.fill(), ve.beginPath(), ve.moveTo(l.x, l.y), ve.lineTo(c.x, c.y), ve.strokeStyle = "#ffff00", ve.stroke(), ve.beginPath(), ve.moveTo(p.x, p.y), ve.lineTo(f.x, f.y), ve.strokeStyle = "#ffff00", ve.stroke();
  const m = or(s + Go, ui / 2, n), y = or(s + Yp, ui / 2, n), g = or(s + Go, -ui / 2, n), v = or(s + Yp, -ui / 2, n);
  if (ve.beginPath(), ve.moveTo(m.x, m.y), ve.lineTo(y.x, y.y), ve.strokeStyle = "#ffff00", ve.stroke(), ve.beginPath(), ve.moveTo(g.x, g.y), ve.lineTo(v.x, v.y), ve.strokeStyle = "#ffff00", ve.stroke(), ve.setLineDash([10, 10]), ve.lineWidth = 1, ve.strokeStyle = "white", t.length > 1)
    for (let I = 1; I < t.length; I++) {
      const M = or(s, ui / 2 + I * Rn, n), E = or(s + Yp, ui / 2 + I * Rn, n);
      ve.beginPath(), ve.moveTo(M.x, M.y), ve.lineTo(E.x, E.y), ve.stroke();
      const C = or(s, -(ui / 2 + I * Rn), n), A = or(s + Yp, -(ui / 2 + I * Rn), n);
      ve.beginPath(), ve.moveTo(C.x, C.y), ve.lineTo(A.x, A.y), ve.stroke();
    }
  ve.setLineDash([]), ve.save();
  const w = t.length * Rn * 2 + ui, b = p$ / 2, S = o - (w / 2 - b) * Math.cos(i + Math.PI / 2), $ = a - (w / 2 - b) * Math.sin(i + Math.PI / 2);
  for (let I = 0; I < w; I += p$ + UCe) {
    const M = S + I * Math.cos(i + Math.PI / 2), E = $ + I * Math.sin(i + Math.PI / 2), C = M + Go * Math.cos(i), A = E + Go * Math.sin(i);
    ve.beginPath(), ve.moveTo(M, E), ve.lineTo(C, A), ve.strokeStyle = "white", ve.lineWidth = p$, ve.stroke();
  }
  ve.restore(), t.forEach((I, M) => {
    const { x: E, y: C } = or(s + Go + 20, ui / 2 + M * Rn + Rn / 2, n), { x: A, y: W } = or(s + Go + 80, ui / 2 + M * Rn + Rn / 2, n), { x: j, y: G } = or(s + Go + 140, ui / 2 + M * Rn + Rn / 2, n);
    qm(I.arrow, E, C, n), qm(I.arrow, A, W, n), qm(I.arrow, j, G, n);
    const { x: R, y: V } = or(s + Go + 20, -(ui / 2 + M * Rn + Rn / 2), n);
    qm("straight", R, V, n + 180);
    const { x: Q, y: de } = or(s + Go + 80, r / 2 + M * Rn + Rn / 2 + Rn, n), { x: _e, y: ie } = or(s + Go + 100, r / 2 + M * Rn + Rn / 2 + Rn, n);
    qm(I.arrow, Q, de, n), ve.fillStyle = "#fff", ve.font = "12px Arial", ve.textAlign = "center", ve.textBaseline = "middle", ve.save(), ve.translate(_e, ie), ve.rotate(-n * Math.PI / 180), ve.fillText(I.vol, 0, 0), ve.restore();
  });
}
function qm(e, t, n, r) {
  const i = new Image();
  i.src = `/arrow/${e}.svg`, i.onload = () => {
    const o = i.width * 0.07, a = i.height * 0.07;
    ve.save(), ve.translate(t, n), ve.rotate(-r * Math.PI / 180);
    const l = -o / 2, c = -a / 2;
    ve.drawImage(i, l, c, o, a), ve.restore();
  };
}
function FG(e, t) {
  return Math.atan2(t[1] - e[1], t[0] - e[0]) * 180 / Math.PI;
}
function or(e, t, n) {
  const r = n * Math.PI / 180, i = Math.sqrt(e * e + t * t), s = Math.atan2(t, e), o = _g + i * Math.cos(-s - r), a = Sg + i * Math.sin(-s - r);
  return {
    x: o,
    y: a
  };
}
const Ge = is({
  project: [],
  predictionAssessmentType: "current",
  predictionResearchPhase: "morningPeak",
  predictionObject: 1,
  predictionIndex: 1,
  predictionTrans: "out",
  link_name: "",
  heatMap: !1,
  spiderWeb: !1,
  expectedLine: !1,
  community: [],
  flowDiff: !1,
  showPulse: !1,
  // 
  showOd: !1
  // OD
}), pc = {}, I_ = {}, r2 = {}, Ff = [], Y0 = J("link"), NG = {
  current: 0,
  near: 1,
  far: 2
}, HCe = {
  morningPeak: 1,
  nightPeak: 2,
  holiday: 3,
  other: 4
}, Is = J([]);
function JCe(e) {
  const t = [];
  return e.forEach((n) => {
    t.includes(n.predictionResearchPhase) || t.push(n.predictionResearchPhase);
  }), t;
}
function xd(e = "") {
  e && (Y0.value = e), Q0.forEach((t) => {
    t.visible = Ge.predictionObject === 1 && Ge.predictionIndex === 1;
  }), cm.forEach((t) => {
    t.visible = Ge.predictionObject === 1 && Ge.predictionIndex === 1 && Xi.zoom > 16;
  }), l0.forEach((t) => {
    t.visible = Ge.predictionObject === 2;
  }), i2.forEach((t) => {
    t.visible = Ge.predictionObject === 2;
  }), s2.forEach((t) => {
    t.visible = Ge.predictionIndex === 2;
  }), X0.forEach((t) => {
    t.visible = Ge.predictionIndex === 2 && Xi.zoom > 16;
  });
}
function h$() {
  var t;
  mOe();
  const e = (t = I_.list.filter((n) => {
    const r = Ge.predictionAssessmentType === "current" ? void 0 : Ge.predictionAssessmentType;
    return n.predictionAssessmentType === r && n.predictionResearchPhase === Ge.predictionResearchPhase;
  })[0]) == null ? void 0 : t.data;
  e && (Object.assign(r2, e), ZCe(), yOe(), xd());
}
function ZCe() {
  Ff.length = 0, r2.links.forEach((e) => {
    const t = {
      saturation: e.saturation,
      vol: e.vol,
      origin_id: e.origin_id,
      id: e.id
    }, n = pc.links.find((r) => r.id === e.origin_id);
    t.link_name = n.link_name, t.shape = n.shape.split(" ").map((r) => r.split(",")), t.nodes = DG(n.shape, e.direction), console.log(e.observed_vol), Ff.push(t);
  }), YCe();
}
function DG(e, t) {
  const n = e.split(" ").map((a) => a.split(",")), r = n[0], i = n[n.length - 1], s = 4e-5, o = n.map((a) => t === 2 ? [Number.parseFloat(a[0]) + s, Number.parseFloat(a[1])] : t === 1 ? [Number.parseFloat(a[0]) - s, Number.parseFloat(a[1])] : "Invalid direction specified");
  return [
    r,
    ...o,
    i
  ];
}
function G3(e) {
  const t = e.length, n = Math.floor(t / 2) - 1, r = [e[n], e[n + 1]], i = (r[0][0] + r[1][0]) / 2, s = (r[0][1] + r[1][1]) / 2, o = FG(e[0], e[t - 1], e[t - 1]), a = Math.abs(o);
  return { center: [i, s], slope: a };
}
function jG(e) {
  if (e <= 0.4)
    return "#4B7902";
  if (e > 0.4 && e <= 0.6)
    return "#95F204";
  if (e > 0.6 && e <= 0.75)
    return "#FFD400";
  if (e > 0.75 && e <= 0.9)
    return "#F47920";
  if (e > 0.9 && e <= 1)
    return "#D9001B";
  if (e > 1)
    return "#843900";
}
function KCe(e) {
  return e >= Is.value[0].text && e < Is.value[1].text ? Is.value[0].value : e >= Is.value[1].text && e < Is.value[2].text ? Is.value[1].value : e >= Is.value[2].text && e < Is.value[3].text ? Is.value[2].value : Is.value[3].value;
}
function YCe() {
  const e = Array.from(new Set(Ff.map((i) => i.vol))).sort((i, s) => i - s), t = e.length, n = [
    e[0],
    // 0%
    e[Math.ceil((t - 1) * 0.25)],
    e[Math.ceil((t - 1) * 0.5)],
    e[Math.ceil((t - 1) * 0.75)]
  ], r = [
    { value: 1, text: n[0] },
    { value: 4, text: n[1] },
    { value: 7, text: n[2] },
    { value: 10, text: n[3] }
  ];
  return Is.value = r, r;
}
function f$(e, t = null) {
  let n = {};
  const r = Object.values(pc.nodes).filter((i) => i.id === e)[0];
  return t ? t.forEach((i) => {
    n[i] = r[i];
  }) : n = r, n;
}
function QCe(e) {
  var t, n, r, i, s, o, a, l, c;
  if (e.results.length) {
    const p = e.results.filter((f) => f.graphic.geometry.type === "polyline" || f.graphic.geometry.type === "point")[0];
    ((n = (t = p.graphic) == null ? void 0 : t.attributes) == null ? void 0 : n.polylineType) === "line" && Ge.spiderWeb && XCe((r = p.graphic) == null ? void 0 : r.attributes), ((s = (i = p.graphic) == null ? void 0 : i.attributes) == null ? void 0 : s.polylineType) === "line-expected" && (console.log(""), Ge.expectedLine && aOe(p)), ((a = (o = p.graphic) == null ? void 0 : o.attributes) == null ? void 0 : a.polylineType) === "cross" && (console.log(""), (l = p.graphic) != null && l.attributes.crossData && qCe((c = p.graphic) == null ? void 0 : c.attributes));
  } else
    console.log(""), Y0.value === "spider" && (Ge.link_name = "", clearSpider());
}
function XCe(e) {
  zC.get(`/api/v1/prediction/link/spider/${Ge.project[1]}/${NG[Ge.predictionAssessmentType]}/1/${HCe[Ge.predictionResearchPhase]}/${e.id}`).then((t) => {
    if (t.data.code === 0 && t.data.data.length) {
      Ge.link_name = e.link_name;
      const n = t.data.data;
      n.forEach((r) => {
        const i = Ff.find((s) => s.id === r.linkId);
        if (i) {
          const { shape: s, link_name: o } = i;
          Object.assign(r, { shape: s, link_name: o });
        }
      }), n.length && (hiddenGraphicsLayer(), drawSpider(n, e.id)), Y0.value = "spider";
    } else
      q3.error("");
  }).catch((t) => {
    console.error("Error during API call:", t);
  });
}
function fb(e) {
  BCe({
    title: ":",
    message: e,
    type: "info",
    position: "bottom-right",
    duration: 1e4
  });
}
function eOe() {
  try {
    Object.assign(Ge, {
      predictionAssessmentType: "current",
      predictionResearchPhase: "morningPeak",
      predictionObject: 1,
      predictionIndex: 1,
      predictionTrans: "out",
      link_name: "",
      heatMap: !1,
      spiderWeb: !1,
      expectedLine: !1,
      flowDiff: !1
    }), Object.keys(pc).forEach((e) => delete pc[e]), Object.keys(I_).forEach((e) => delete I_[e]), Ff.length = 0, map.removeAll(), Q0.length = 0, cm.length = 0, s2.length = 0, X0.length = 0, l0.length = 0, i2.length = 0, graphicsLayer.removeAll(), expectedLineGraphicsLayer.removeAll(), expectedGraphics.length = 0, nodeToExpectedLineGraphics.length = 0;
  } catch {
  }
}
const W3 = {}, VG = {};
let M_ = null;
function E5() {
  zG();
  const e = [];
  W3.zone.forEach((t) => {
    const n = {
      geometry: {
        type: "point",
        x: t.lng,
        y: t.lat
      },
      attributes: {
        id: t.id,
        od: t[`${Ge.predictionTrans}Sum`],
        name: t.name
      }
    };
    e.push(n);
  }), M_ = new Yk({
    fields: [
      {
        name: "od",
        alias: "Od",
        type: "double"
      }
    ],
    geometryType: "point",
    objectIdField: "ObjectID",
    source: e,
    renderer: new I7({
      colorStops: [
        { ratio: 0, color: "rgba(255, 255, 255, 0)" },
        { ratio: 0.2, color: "rgba(255, 0, 0, 0.8)" },
        { ratio: 0.5, color: "rgba(255, 140, 0, 0.8)" },
        { ratio: 0.8, color: "rgba(255, 140, 0, 0.9)" },
        { ratio: 1, color: "rgba(255, 0, 0, 0.9)" }
      ],
      field: "od",
      minPixelIntensity: 1,
      maxPixelIntensity: 800
    })
  }), Gs.add(M_);
}
function zG() {
  M_ && M_.destroy(), Gs.remove();
}
function tOe() {
  const e = Object.values(VG).find((i) => i.predictionAssessmentType === NG[Ge.predictionAssessmentType] && i.predictionType === 1).details[0].od, { od: t, zone: n } = e;
  for (let i = 0; i < n.length; i++) {
    const s = f$(n[i].id, ["lng", "lat"]);
    n[i].lng = s.lng, n[i].lat = s.lat, n[i].outSum = 0, n[i].outLinks = [], n[i].inSum = 0, n[i].inLinks = [], t[i].map((o, a) => {
      if (n[i].outSum += Number(o), o) {
        const l = f$(n[a].id, ["lng", "lat"]);
        n[i].outLinks.push({
          coord: [l.lng, l.lat],
          vol: Number(o),
          index: a
        });
      }
    });
  }
  const r = t[0].map((i, s) => t.map((o) => o[s]));
  for (let i = 0; i < r.length; i++)
    n[i].inSum = 0, n[i].inLinks = [], r[i].map((s, o) => {
      if (n[i].inSum += Number(s), s) {
        const a = f$(n[o].id, ["lng", "lat"]);
        n[i].inLinks.push({
          coord: [a.lng, a.lat],
          vol: Number(s),
          index: o
        });
      }
    });
  Object.assign(W3, e);
}
const BG = J([]), $C = J(!1), Kr = new NS(), wp = [], Kd = [];
function nOe() {
  W3.zone.forEach((e, t) => {
    const n = new Jt({
      geometry: new Oe({
        longitude: e.lng,
        latitude: e.lat
      }),
      symbol: new Ro({
        text: e.name,
        font: {
          size: 10,
          weight: "bold",
          padding: 0
        },
        color: new Fe([250, 250, 250, 1]),
        backgroundColor: new Fe("#999999"),
        // 
        borderLineColor: new Fe([255, 255, 255, 1]),
        // 
        borderLineSize: 1,
        // 
        verticalAlignment: "middle"
      }),
      attributes: {
        ...e,
        index: t,
        polylineType: "line-expected"
      }
    });
    wp.push(n);
  }), Yd.addMany(wp, 1e3);
}
function I5() {
  Kd.length = 0, Kr.removeAll(), Ge.community.length = 0, wp.forEach((e) => {
    C_(e, "#999999"), e.visible = !1;
  });
}
function rOe() {
  UG();
}
function iOe() {
  Kd.length = 0, Kr.removeAll(), Ge.community.length = 0, wp.forEach((e) => {
    C_(e, "#999999");
  });
}
function sOe() {
  wp.length === 0 && nOe(), wp.forEach((e) => {
    e.visible = !0;
  });
}
const Gm = [];
function oOe(e) {
  const t = Gm.indexOf(e);
  return t > -1 ? (Gm.splice(t, 1), Kr.graphics.filter((r) => r.id === e).forEach((r) => {
    Kr.remove(r);
  }), $C.value = !!Gm.length, !1) : (Gm.push(e), $C.value = !!Gm.length, !0);
}
function aOe(e) {
  cOe(e.graphic.attributes), pOe(), UG();
  const t = e.graphic.attributes.id;
  if (!oOe(t)) {
    C_(e.graphic, "#999999");
    return;
  }
  C_(e.graphic, "#006600");
}
function UG() {
  Kr.removeAll(), Ge.community.length = 0, Kd.forEach((e) => {
    Ge.community.push(e.name), (Ge.predictionTrans === "out" ? e.outLinks : e.inLinks).forEach((n) => {
      lOe([[e.lng, e.lat], n.coord]), uOe([[e.lng, e.lat], n.coord], n.vol), Ge.predictionTrans === "out" ? M5([e.lng, e.lat], n.coord) : M5(n.coord, [e.lng, e.lat]);
    });
  });
}
function lOe(e) {
  const t = new Jt({
    geometry: {
      type: "polyline",
      paths: e
    },
    symbol: {
      type: "simple-line",
      color: [251, 146, 60, 0.8],
      width: 5
    },
    attributes: {
      polylineType: "expected-line"
    }
  }), n = new Hs({
    color: "#fff",
    width: 1,
    style: "dash",
    dashPattern: [10, 5]
    // 10px5px
  }), r = new Jt({
    geometry: {
      type: "polyline",
      paths: e
    },
    symbol: n
  });
  Kr.add(t), Kr.add(r), Gs.add(Kr), Gs.reorder(Kr, 0);
}
function uOe(e, t) {
  const n = G3(e), r = new Jt({
    geometry: new Oe({
      longitude: n.center[0],
      latitude: n.center[1]
    }),
    symbol: new Ro({
      text: t.toFixed(0),
      font: {
        size: 10,
        weight: "bold",
        padding: 0
      },
      color: new Fe([0, 0, 0, 1]),
      backgroundColor: new Fe("#ccc"),
      // 
      borderLineColor: new Fe([255, 255, 255, 1]),
      // 
      borderLineSize: 1,
      // 
      verticalAlignment: "middle"
    }),
    attributes: {
      polylineType: "expected-data"
    }
  });
  r.visible = Ge.showOd, Kr.add(r), Gs.add(Kr), Gs.reorder(Kr, 0);
}
function cOe(e) {
  const t = Kd.findIndex((n) => n.id === e.id);
  t !== -1 ? Kd.splice(t, 1) : Kd.push(e);
}
function C_(e, t) {
  const n = e.symbol.clone();
  n.backgroundColor = new Fe(t), e.symbol = n;
}
function dOe(e, t, n, r) {
  const i = e * Math.PI / 180, s = n * Math.PI / 180, o = (r - t) * Math.PI / 180, a = Math.sin(o) * Math.cos(s), l = Math.cos(i) * Math.sin(s) - Math.sin(i) * Math.cos(s) * Math.cos(o);
  return (Math.atan2(a, l) * 180 / Math.PI + 360) % 360;
}
function M5(e, t) {
  const n = {
    type: "picture-marker",
    url: "/arrow/navigation.svg",
    // 
    width: "24px",
    height: "24px"
  }, r = new Jt({
    symbol: n,
    attributes: {
      polylineType: `expected-arrow-${Ge.predictionTrans}`
    }
  });
  r.visible = Ge.showPulse, Kr.add(r);
  const i = t[0] - e[0], s = t[1] - e[1], o = Math.sqrt(i * i + s * s), a = dOe(e[1], e[0], t[1], t[0]), c = 6e-5 / o;
  let p = 0;
  function f() {
    p += c, p >= 1 && (p = 0);
    const m = e[0] + i * p, y = e[1] + s * p;
    r.geometry = new Oe([m, y]), r.symbol.angle = a, requestAnimationFrame(f);
  }
  f();
}
function pOe() {
  let e = [];
  Kd.forEach((s) => {
    e = Ge.predictionTrans === "out" ? s.outLinks : s.inLinks;
  });
  const t = Array.from(new Set(e.map((s) => s.vol))).sort((s, o) => s - o), n = t.length, r = [
    t[0],
    // 0%
    t[Math.ceil((n - 1) * 0.25)],
    t[Math.ceil((n - 1) * 0.5)],
    t[Math.ceil((n - 1) * 0.75)]
  ], i = [
    { value: 1, text: r[0] },
    { value: 4, text: r[1] },
    { value: 7, text: r[2] },
    { value: 10, text: r[3] }
  ];
  return BG.value = i, i;
}
function hOe() {
  Kr.graphics.forEach((e) => {
    var t;
    ((t = e.attributes) == null ? void 0 : t.polylineType) === "expected-data" && (e.visible = Ge.showOd);
  });
}
function fOe() {
  Kr.graphics.forEach((e) => {
    var t;
    ((t = e.attributes) == null ? void 0 : t.polylineType) === `expected-arrow-${Ge.predictionTrans}` && (e.visible = Ge.showPulse);
  });
}
const Gs = new k6({
  basemap: "geoscene-blue"
  // basemap: 'tianditu-vector',
}), Xi = new k0e({
  map: Gs,
  center: "121.40569010038575, 31.141236748863733".split(","),
  // center: [121.479615, 31.234771],
  // center: [121.480255, 31.234279], // 
  zoom: 16
}), Yd = new NS();
Xi.ui.components = [];
function mOe() {
  Yd.removeAll(), Y0.value = "link";
}
Xi.on("click", (e) => {
  Xi.hitTest(e).then((t) => {
    QCe(t);
  });
});
Xi.watch("zoom", (e) => {
  cm.forEach((t) => {
    t.visible = Ge.predictionObject === 1 && Ge.predictionIndex === 1 && Xi.zoom > 16 && !Ge.flowDiff && !Ge.expectedLine;
  }), X0.forEach((t) => {
    t.visible = Ge.predictionIndex === 2 && Xi.zoom > 16 && !Ge.flowDiff && !Ge.expectedLine;
  }), wp.forEach((t) => {
    t.visible = Ge.expectedLine && Xi.zoom > 14;
  });
});
const Q0 = [], cm = [], l0 = [], i2 = [], s2 = [], X0 = [];
function yOe() {
  gOe(), vOe(r2.nodes), Yd.addMany([...i2, ...Q0, ...cm, ...s2, ...X0]), Yd.addMany(l0), Gs.add(Yd);
}
function gOe() {
  Ff.map((e) => {
    const t = G3(e.nodes), n = new Jt({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Fe(jG(e.saturation)),
        width: 2
      },
      attributes: {
        ...e,
        polylineType: "line"
      }
    });
    Q0.push(n);
    const r = new Jt({
      geometry: new Oe({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new Ro({
        text: e.saturation.toFixed(2),
        font: {
          size: 8
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      })
    });
    r.visible = !1, cm.push(r);
    const i = new Jt({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Fe([252, 124, 124, 0.7]),
        width: KCe(e.vol)
      },
      attributes: {
        ...e,
        polylineType: "flow"
      }
    });
    s2.push(i);
    const s = new Jt({
      geometry: new Oe({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new Ro({
        text: e.vol.toFixed(0),
        font: {
          size: 8
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      })
    });
    s.visible = !1, X0.push(s);
    const o = new Jt({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Fe([252, 124, 124, 0.7]),
        width: 2
      },
      attributes: {
        ...e,
        polylineType: "line"
      }
    });
    i2.push(o);
  });
}
function vOe(e) {
  e.forEach((t) => {
    const n = C5(t), r = n != null && n.delayAvg ? jG(n == null ? void 0 : n.delayAvg) : "#999", i = new Jt({
      geometry: new Oe({
        longitude: t.longitude,
        latitude: t.latitude
      }),
      symbol: {
        type: "picture-marker",
        // autocasts as new PictureMarkerSymbol()
        url: _Oe(r, (n == null ? void 0 : n.level) || t.name),
        width: "30px",
        height: "30px"
      },
      attributes: {
        ...t,
        crossData: {
          ...C5(t),
          color: r
        },
        polylineType: "cross"
      }
    });
    l0.push(i);
  }), Yd.addMany(l0);
}
function C5(e) {
  var n, r, i;
  const t = pc.nodes.find((s) => s.id === e.origin_id);
  return t.entranceLan ? (t.entranceLan.forEach((o) => {
    o.startPoint = [t.lng, t.lat];
    const a = pc.links.find((p) => p.id === o.link_id), l = bOe(a.node_ids.split(","), e.origin_id), c = getNodeInfoById(l, ["lng", "lat"]);
    o.endPoint = [c.lng, c.lat];
  }), {
    lanes: wOe(t.entranceLan),
    level: ((n = e.inter_service_level) == null ? void 0 : n.level) || "-",
    delayAvg: ((r = e.inter_service_level) == null ? void 0 : r.delayAvg) || 0,
    satAvg: ((i = e.inter_service_level) == null ? void 0 : i.satAvg) || 0
  }) : {};
}
function bOe(e, t) {
  return e.length === 0 ? null : e[0] === t ? e[e.length - 1] : e[e.length - 1] === t ? e[0] : null;
}
function wOe(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const { trun_road: r, left_road: i, straight: s, right_road: o, lanes_cnt: a, startPoint: l, endPoint: c } = e[n], p = [];
    for (let f = 1; f <= a; f++) {
      let m = "";
      r.includes(f) && (m += "trun"), i.includes(f) && (m += `${m ? "_" : ""}left`), s.includes(f) && (m += `${m ? "_" : ""}straight`), o.includes(f) && (m += `${m ? "_" : ""}right`), m === "trun_left_straight_right" && (m = "left_straight_right"), p.push({ arrow: m, vol: 0 });
    }
    t.push({
      lane: p,
      startPoint: l,
      endPoint: c
    });
  }
  return t;
}
function _Oe(e = "#999", t = "A") {
  const n = document.createElement("canvas"), r = n.getContext("2d");
  n.width = 60, n.height = 60, r.beginPath(), r.arc(30, 30, 28, 0, 2 * Math.PI, !1), r.fillStyle = e, r.fill(), r.lineWidth = 2, r.strokeStyle = "#fff", r.stroke(), r.fillStyle = "#fff", r.font = "28px sans-serif";
  const i = r.measureText(t).width, s = (n.width - i) / 2, o = (n.height + 28) / 2 - 4;
  return r.fillText(t, s, o), n.toDataURL();
}
function m$() {
  Yd.graphics.forEach((e) => {
    e.visible = !1;
  });
}
const xg = /^[a-z0-9]+(-[a-z0-9]+)*$/, o2 = (e, t, n, r = "") => {
  const i = e.split(":");
  if (e.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3)
      return null;
    r = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length)
    return null;
  if (i.length > 1) {
    const a = i.pop(), l = i.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: i.length > 0 ? i[0] : r,
      prefix: l,
      name: a
    };
    return t && !Hw(c) ? null : c;
  }
  const s = i[0], o = s.split("-");
  if (o.length > 1) {
    const a = {
      provider: r,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !Hw(a) ? null : a;
  }
  if (n && r === "") {
    const a = {
      provider: r,
      prefix: "",
      name: s
    };
    return t && !Hw(a, n) ? null : a;
  }
  return null;
}, Hw = (e, t) => e ? !!((e.provider === "" || e.provider.match(xg)) && (t && e.prefix === "" || e.prefix.match(xg)) && e.name.match(xg)) : !1, qG = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), O_ = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), a2 = Object.freeze({
  ...qG,
  ...O_
}), TC = Object.freeze({
  ...a2,
  body: "",
  hidden: !1
});
function SOe(e, t) {
  const n = {};
  !e.hFlip != !t.hFlip && (n.hFlip = !0), !e.vFlip != !t.vFlip && (n.vFlip = !0);
  const r = ((e.rotate || 0) + (t.rotate || 0)) % 4;
  return r && (n.rotate = r), n;
}
function O5(e, t) {
  const n = SOe(e, t);
  for (const r in TC)
    r in O_ ? r in e && !(r in n) && (n[r] = O_[r]) : r in t ? n[r] = t[r] : r in e && (n[r] = e[r]);
  return n;
}
function xOe(e, t) {
  const n = e.icons, r = e.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(o) {
    if (n[o])
      return i[o] = [];
    if (!(o in i)) {
      i[o] = null;
      const a = r[o] && r[o].parent, l = a && s(a);
      l && (i[o] = [a].concat(l));
    }
    return i[o];
  }
  return (t || Object.keys(n).concat(Object.keys(r))).forEach(s), i;
}
function $Oe(e, t, n) {
  const r = e.icons, i = e.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function o(a) {
    s = O5(
      r[a] || i[a],
      s
    );
  }
  return o(t), n.forEach(o), O5(e, s);
}
function GG(e, t) {
  const n = [];
  if (typeof e != "object" || typeof e.icons != "object")
    return n;
  e.not_found instanceof Array && e.not_found.forEach((i) => {
    t(i, null), n.push(i);
  });
  const r = xOe(e);
  for (const i in r) {
    const s = r[i];
    s && (t(i, $Oe(e, i, s)), n.push(i));
  }
  return n;
}
const TOe = {
  provider: "",
  aliases: {},
  not_found: {},
  ...qG
};
function y$(e, t) {
  for (const n in t)
    if (n in e && typeof e[n] != typeof t[n])
      return !1;
  return !0;
}
function WG(e) {
  if (typeof e != "object" || e === null)
    return null;
  const t = e;
  if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !y$(e, TOe))
    return null;
  const n = t.icons;
  for (const i in n) {
    const s = n[i];
    if (!i.match(xg) || typeof s.body != "string" || !y$(
      s,
      TC
    ))
      return null;
  }
  const r = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const i in r) {
    const s = r[i], o = s.parent;
    if (!i.match(xg) || typeof o != "string" || !n[o] && !r[o] || !y$(
      s,
      TC
    ))
      return null;
  }
  return t;
}
const k5 = /* @__PURE__ */ Object.create(null);
function EOe(e, t) {
  return {
    provider: e,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function _p(e, t) {
  const n = k5[e] || (k5[e] = /* @__PURE__ */ Object.create(null));
  return n[t] || (n[t] = EOe(e, t));
}
function H3(e, t) {
  return WG(t) ? GG(t, (n, r) => {
    r ? e.icons[n] = r : e.missing.add(n);
  }) : [];
}
function IOe(e, t, n) {
  try {
    if (typeof n.body == "string")
      return e.icons[t] = { ...n }, !0;
  } catch {
  }
  return !1;
}
let u0 = !1;
function HG(e) {
  return typeof e == "boolean" && (u0 = e), u0;
}
function MOe(e) {
  const t = typeof e == "string" ? o2(e, !0, u0) : e;
  if (t) {
    const n = _p(t.provider, t.prefix), r = t.name;
    return n.icons[r] || (n.missing.has(r) ? null : void 0);
  }
}
function COe(e, t) {
  const n = o2(e, !0, u0);
  if (!n)
    return !1;
  const r = _p(n.provider, n.prefix);
  return IOe(r, n.name, t);
}
function OOe(e, t) {
  if (typeof e != "object")
    return !1;
  if (typeof t != "string" && (t = e.provider || ""), u0 && !t && !e.prefix) {
    let i = !1;
    return WG(e) && (e.prefix = "", GG(e, (s, o) => {
      o && COe(s, o) && (i = !0);
    })), i;
  }
  const n = e.prefix;
  if (!Hw({
    provider: t,
    prefix: n,
    name: "a"
  }))
    return !1;
  const r = _p(t, n);
  return !!H3(r, e);
}
const JG = Object.freeze({
  width: null,
  height: null
}), ZG = Object.freeze({
  // Dimensions
  ...JG,
  // Transformations
  ...O_
}), kOe = /(-?[0-9.]*[0-9]+[0-9.]*)/g, AOe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function A5(e, t, n) {
  if (t === 1)
    return e;
  if (n = n || 100, typeof e == "number")
    return Math.ceil(e * t * n) / n;
  if (typeof e != "string")
    return e;
  const r = e.split(kOe);
  if (r === null || !r.length)
    return e;
  const i = [];
  let s = r.shift(), o = AOe.test(s);
  for (; ; ) {
    if (o) {
      const a = parseFloat(s);
      isNaN(a) ? i.push(s) : i.push(Math.ceil(a * t * n) / n);
    } else
      i.push(s);
    if (s = r.shift(), s === void 0)
      return i.join("");
    o = !o;
  }
}
const POe = (e) => e === "unset" || e === "undefined" || e === "none";
function ROe(e, t) {
  const n = {
    ...a2,
    ...e
  }, r = {
    ...ZG,
    ...t
  }, i = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let s = n.body;
  [n, r].forEach((g) => {
    const v = [], w = g.hFlip, b = g.vFlip;
    let S = g.rotate;
    w ? b ? S += 2 : (v.push(
      "translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"
    ), v.push("scale(-1 1)"), i.top = i.left = 0) : b && (v.push(
      "translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"
    ), v.push("scale(1 -1)"), i.top = i.left = 0);
    let $;
    switch (S < 0 && (S -= Math.floor(S / 4) * 4), S = S % 4, S) {
      case 1:
        $ = i.height / 2 + i.top, v.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        v.unshift(
          "rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")"
        );
        break;
      case 3:
        $ = i.width / 2 + i.left, v.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    S % 2 === 1 && (i.left !== i.top && ($ = i.left, i.left = i.top, i.top = $), i.width !== i.height && ($ = i.width, i.width = i.height, i.height = $)), v.length && (s = '<g transform="' + v.join(" ") + '">' + s + "</g>");
  });
  const o = r.width, a = r.height, l = i.width, c = i.height;
  let p, f;
  o === null ? (f = a === null ? "1em" : a === "auto" ? c : a, p = A5(f, l / c)) : (p = o === "auto" ? l : o, f = a === null ? A5(p, c / l) : a === "auto" ? c : a);
  const m = {}, y = (g, v) => {
    POe(v) || (m[g] = v.toString());
  };
  return y("width", p), y("height", f), m.viewBox = i.left.toString() + " " + i.top.toString() + " " + l.toString() + " " + c.toString(), {
    attributes: m,
    body: s
  };
}
const LOe = /\sid="(\S+)"/g, FOe = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let NOe = 0;
function DOe(e, t = FOe) {
  const n = [];
  let r;
  for (; r = LOe.exec(e); )
    n.push(r[1]);
  if (!n.length)
    return e;
  const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((s) => {
    const o = typeof t == "function" ? t(s) : t + (NOe++).toString(), a = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    e = e.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + o + i + "$3"
    );
  }), e = e.replace(new RegExp(i, "g"), ""), e;
}
const EC = /* @__PURE__ */ Object.create(null);
function jOe(e, t) {
  EC[e] = t;
}
function IC(e) {
  return EC[e] || EC[""];
}
function J3(e) {
  let t;
  if (typeof e.resources == "string")
    t = [e.resources];
  else if (t = e.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: e.path || "/",
    // URL length limit
    maxURL: e.maxURL || 500,
    // Timeout before next host is used.
    rotate: e.rotate || 750,
    // Timeout before failing query.
    timeout: e.timeout || 5e3,
    // Randomise default API end point.
    random: e.random === !0,
    // Start index
    index: e.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: e.dataAfterTimeout !== !1
  };
}
const Z3 = /* @__PURE__ */ Object.create(null), Wm = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Jw = [];
for (; Wm.length > 0; )
  Wm.length === 1 || Math.random() > 0.5 ? Jw.push(Wm.shift()) : Jw.push(Wm.pop());
Z3[""] = J3({
  resources: ["https://api.iconify.design"].concat(Jw)
});
function VOe(e, t) {
  const n = J3(t);
  return n === null ? !1 : (Z3[e] = n, !0);
}
function K3(e) {
  return Z3[e];
}
const zOe = () => {
  let e;
  try {
    if (e = fetch, typeof e == "function")
      return e;
  } catch {
  }
};
let P5 = zOe();
function BOe(e, t) {
  const n = K3(e);
  if (!n)
    return 0;
  let r;
  if (!n.maxURL)
    r = 0;
  else {
    let i = 0;
    n.resources.forEach((o) => {
      i = Math.max(i, o.length);
    });
    const s = t + ".json?icons=";
    r = n.maxURL - i - n.path.length - s.length;
  }
  return r;
}
function UOe(e) {
  return e === 404;
}
const qOe = (e, t, n) => {
  const r = [], i = BOe(e, t), s = "icons";
  let o = {
    type: s,
    provider: e,
    prefix: t,
    icons: []
  }, a = 0;
  return n.forEach((l, c) => {
    a += l.length + 1, a >= i && c > 0 && (r.push(o), o = {
      type: s,
      provider: e,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), r.push(o), r;
};
function GOe(e) {
  if (typeof e == "string") {
    const t = K3(e);
    if (t)
      return t.path;
  }
  return "/";
}
const WOe = (e, t, n) => {
  if (!P5) {
    n("abort", 424);
    return;
  }
  let r = GOe(t.provider);
  switch (t.type) {
    case "icons": {
      const s = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      r += s + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const s = t.uri;
      r += s.slice(0, 1) === "/" ? s.slice(1) : s;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let i = 503;
  P5(e + r).then((s) => {
    const o = s.status;
    if (o !== 200) {
      setTimeout(() => {
        n(UOe(o) ? "abort" : "next", o);
      });
      return;
    }
    return i = 501, s.json();
  }).then((s) => {
    if (typeof s != "object" || s === null) {
      setTimeout(() => {
        s === 404 ? n("abort", s) : n("next", i);
      });
      return;
    }
    setTimeout(() => {
      n("success", s);
    });
  }).catch(() => {
    n("next", i);
  });
}, HOe = {
  prepare: qOe,
  send: WOe
};
function JOe(e) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  e.sort((i, s) => i.provider !== s.provider ? i.provider.localeCompare(s.provider) : i.prefix !== s.prefix ? i.prefix.localeCompare(s.prefix) : i.name.localeCompare(s.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return e.forEach((i) => {
    if (r.name === i.name && r.prefix === i.prefix && r.provider === i.provider)
      return;
    r = i;
    const s = i.provider, o = i.prefix, a = i.name, l = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = _p(s, o));
    let p;
    a in c.icons ? p = t.loaded : o === "" || c.missing.has(a) ? p = t.missing : p = t.pending;
    const f = {
      provider: s,
      prefix: o,
      name: a
    };
    p.push(f);
  }), t;
}
function KG(e, t) {
  e.forEach((n) => {
    const r = n.loaderCallbacks;
    r && (n.loaderCallbacks = r.filter((i) => i.id !== t));
  });
}
function ZOe(e) {
  e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0, setTimeout(() => {
    e.pendingCallbacksFlag = !1;
    const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let n = !1;
    const r = e.provider, i = e.prefix;
    t.forEach((s) => {
      const o = s.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== i)
          return !0;
        const c = l.name;
        if (e.icons[c])
          o.loaded.push({
            provider: r,
            prefix: i,
            name: c
          });
        else if (e.missing.has(c))
          o.missing.push({
            provider: r,
            prefix: i,
            name: c
          });
        else
          return n = !0, !0;
        return !1;
      }), o.pending.length !== a && (n || KG([e], s.id), s.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        s.abort
      ));
    });
  }));
}
let KOe = 0;
function YOe(e, t, n) {
  const r = KOe++, i = KG.bind(null, n, r);
  if (!t.pending.length)
    return i;
  const s = {
    id: r,
    icons: t,
    callback: e,
    abort: i
  };
  return n.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(s);
  }), i;
}
function QOe(e, t = !0, n = !1) {
  const r = [];
  return e.forEach((i) => {
    const s = typeof i == "string" ? o2(i, t, n) : i;
    s && r.push(s);
  }), r;
}
var XOe = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function eke(e, t, n, r) {
  const i = e.resources.length, s = e.random ? Math.floor(Math.random() * i) : e.index;
  let o;
  if (e.random) {
    let E = e.resources.slice(0);
    for (o = []; E.length > 1; ) {
      const C = Math.floor(Math.random() * E.length);
      o.push(E[C]), E = E.slice(0, C).concat(E.slice(C + 1));
    }
    o = o.concat(E);
  } else
    o = e.resources.slice(s).concat(e.resources.slice(0, s));
  const a = Date.now();
  let l = "pending", c = 0, p, f = null, m = [], y = [];
  typeof r == "function" && y.push(r);
  function g() {
    f && (clearTimeout(f), f = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), g(), m.forEach((E) => {
      E.status === "pending" && (E.status = "aborted");
    }), m = [];
  }
  function w(E, C) {
    C && (y = []), typeof E == "function" && y.push(E);
  }
  function b() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: m.length,
      subscribe: w,
      abort: v
    };
  }
  function S() {
    l = "failed", y.forEach((E) => {
      E(void 0, p);
    });
  }
  function $() {
    m.forEach((E) => {
      E.status === "pending" && (E.status = "aborted");
    }), m = [];
  }
  function I(E, C, A) {
    const W = C !== "success";
    switch (m = m.filter((j) => j !== E), l) {
      case "pending":
        break;
      case "failed":
        if (W || !e.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (C === "abort") {
      p = A, S();
      return;
    }
    if (W) {
      p = A, m.length || (o.length ? M() : S());
      return;
    }
    if (g(), $(), !e.random) {
      const j = e.resources.indexOf(E.resource);
      j !== -1 && j !== e.index && (e.index = j);
    }
    l = "completed", y.forEach((j) => {
      j(A);
    });
  }
  function M() {
    if (l !== "pending")
      return;
    g();
    const E = o.shift();
    if (E === void 0) {
      if (m.length) {
        f = setTimeout(() => {
          g(), l === "pending" && ($(), S());
        }, e.timeout);
        return;
      }
      S();
      return;
    }
    const C = {
      status: "pending",
      resource: E,
      callback: (A, W) => {
        I(C, A, W);
      }
    };
    m.push(C), c++, f = setTimeout(M, e.rotate), n(E, t, C.callback);
  }
  return setTimeout(M), b;
}
function YG(e) {
  const t = {
    ...XOe,
    ...e
  };
  let n = [];
  function r() {
    n = n.filter((a) => a().status === "pending");
  }
  function i(a, l, c) {
    const p = eke(
      t,
      a,
      l,
      (f, m) => {
        r(), c && c(f, m);
      }
    );
    return n.push(p), p;
  }
  function s(a) {
    return n.find((l) => a(l)) || null;
  }
  return {
    query: i,
    find: s,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: r
  };
}
function R5() {
}
const g$ = /* @__PURE__ */ Object.create(null);
function tke(e) {
  if (!g$[e]) {
    const t = K3(e);
    if (!t)
      return;
    const n = YG(t), r = {
      config: t,
      redundancy: n
    };
    g$[e] = r;
  }
  return g$[e];
}
function nke(e, t, n) {
  let r, i;
  if (typeof e == "string") {
    const s = IC(e);
    if (!s)
      return n(void 0, 424), R5;
    i = s.send;
    const o = tke(e);
    o && (r = o.redundancy);
  } else {
    const s = J3(e);
    if (s) {
      r = YG(s);
      const o = e.resources ? e.resources[0] : "", a = IC(o);
      a && (i = a.send);
    }
  }
  return !r || !i ? (n(void 0, 424), R5) : r.query(t, i, n)().abort;
}
const L5 = "iconify2", c0 = "iconify", QG = c0 + "-count", F5 = c0 + "-version", XG = 36e5, rke = 168;
function MC(e, t) {
  try {
    return e.getItem(t);
  } catch {
  }
}
function Y3(e, t, n) {
  try {
    return e.setItem(t, n), !0;
  } catch {
  }
}
function N5(e, t) {
  try {
    e.removeItem(t);
  } catch {
  }
}
function CC(e, t) {
  return Y3(e, QG, t.toString());
}
function OC(e) {
  return parseInt(MC(e, QG)) || 0;
}
const l2 = {
  local: !0,
  session: !0
}, eW = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Q3 = !1;
function ike(e) {
  Q3 = e;
}
let mb = typeof window > "u" ? {} : window;
function tW(e) {
  const t = e + "Storage";
  try {
    if (mb && mb[t] && typeof mb[t].length == "number")
      return mb[t];
  } catch {
  }
  l2[e] = !1;
}
function nW(e, t) {
  const n = tW(e);
  if (!n)
    return;
  const r = MC(n, F5);
  if (r !== L5) {
    if (r) {
      const a = OC(n);
      for (let l = 0; l < a; l++)
        N5(n, c0 + l.toString());
    }
    Y3(n, F5, L5), CC(n, 0);
    return;
  }
  const i = Math.floor(Date.now() / XG) - rke, s = (a) => {
    const l = c0 + a.toString(), c = MC(n, l);
    if (typeof c == "string") {
      try {
        const p = JSON.parse(c);
        if (typeof p == "object" && typeof p.cached == "number" && p.cached > i && typeof p.provider == "string" && typeof p.data == "object" && typeof p.data.prefix == "string" && // Valid item: run callback
        t(p, a))
          return !0;
      } catch {
      }
      N5(n, l);
    }
  };
  let o = OC(n);
  for (let a = o - 1; a >= 0; a--)
    s(a) || (a === o - 1 ? (o--, CC(n, o)) : eW[e].add(a));
}
function rW() {
  if (!Q3) {
    ike(!0);
    for (const e in l2)
      nW(e, (t) => {
        const n = t.data, r = t.provider, i = n.prefix, s = _p(
          r,
          i
        );
        if (!H3(s, n).length)
          return !1;
        const o = n.lastModified || -1;
        return s.lastModifiedCached = s.lastModifiedCached ? Math.min(s.lastModifiedCached, o) : o, !0;
      });
  }
}
function ske(e, t) {
  const n = e.lastModifiedCached;
  if (
    // Matches or newer
    n && n >= t
  )
    return n === t;
  if (e.lastModifiedCached = t, n)
    for (const r in l2)
      nW(r, (i) => {
        const s = i.data;
        return i.provider !== e.provider || s.prefix !== e.prefix || s.lastModified === t;
      });
  return !0;
}
function oke(e, t) {
  Q3 || rW();
  function n(r) {
    let i;
    if (!l2[r] || !(i = tW(r)))
      return;
    const s = eW[r];
    let o;
    if (s.size)
      s.delete(o = Array.from(s).shift());
    else if (o = OC(i), !CC(i, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / XG),
      provider: e.provider,
      data: t
    };
    return Y3(
      i,
      c0 + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !ske(e, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), n("local") || n("session"));
}
function D5() {
}
function ake(e) {
  e.iconsLoaderFlag || (e.iconsLoaderFlag = !0, setTimeout(() => {
    e.iconsLoaderFlag = !1, ZOe(e);
  }));
}
function lke(e, t) {
  e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t, e.iconsQueueFlag || (e.iconsQueueFlag = !0, setTimeout(() => {
    e.iconsQueueFlag = !1;
    const { provider: n, prefix: r } = e, i = e.iconsToLoad;
    delete e.iconsToLoad;
    let s;
    if (!i || !(s = IC(n)))
      return;
    s.prepare(n, r, i).forEach((a) => {
      nke(n, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            e.missing.add(c);
          });
        else
          try {
            const c = H3(
              e,
              l
            );
            if (!c.length)
              return;
            const p = e.pendingIcons;
            p && c.forEach((f) => {
              p.delete(f);
            }), oke(e, l);
          } catch (c) {
            console.error(c);
          }
        ake(e);
      });
    });
  }));
}
const uke = (e, t) => {
  const n = QOe(e, !0, HG()), r = JOe(n);
  if (!r.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        r.loaded,
        r.missing,
        r.pending,
        D5
      );
    }), () => {
      l = !1;
    };
  }
  const i = /* @__PURE__ */ Object.create(null), s = [];
  let o, a;
  return r.pending.forEach((l) => {
    const { provider: c, prefix: p } = l;
    if (p === a && c === o)
      return;
    o = c, a = p, s.push(_p(c, p));
    const f = i[c] || (i[c] = /* @__PURE__ */ Object.create(null));
    f[p] || (f[p] = []);
  }), r.pending.forEach((l) => {
    const { provider: c, prefix: p, name: f } = l, m = _p(c, p), y = m.pendingIcons || (m.pendingIcons = /* @__PURE__ */ new Set());
    y.has(f) || (y.add(f), i[c][p].push(f));
  }), s.forEach((l) => {
    const { provider: c, prefix: p } = l;
    i[c][p].length && lke(l, i[c][p]);
  }), t ? YOe(t, r, s) : D5;
};
function cke(e, t) {
  const n = {
    ...e
  };
  for (const r in t) {
    const i = t[r], s = typeof i;
    r in JG ? (i === null || i && (s === "string" || s === "number")) && (n[r] = i) : s === typeof n[r] && (n[r] = r === "rotate" ? i % 4 : i);
  }
  return n;
}
const dke = /[\s,]+/;
function pke(e, t) {
  t.split(dke).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        e.hFlip = !0;
        break;
      case "vertical":
        e.vFlip = !0;
        break;
    }
  });
}
function hke(e, t = 0) {
  const n = e.replace(/^-?[0-9.]*/, "");
  function r(i) {
    for (; i < 0; )
      i += 4;
    return i % 4;
  }
  if (n === "") {
    const i = parseInt(e);
    return isNaN(i) ? 0 : r(i);
  } else if (n !== e) {
    let i = 0;
    switch (n) {
      case "%":
        i = 25;
        break;
      case "deg":
        i = 90;
    }
    if (i) {
      let s = parseFloat(e.slice(0, e.length - n.length));
      return isNaN(s) ? 0 : (s = s / i, s % 1 === 0 ? r(s) : 0);
    }
  }
  return t;
}
function fke(e, t) {
  let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in t)
    n += " " + r + '="' + t[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>";
}
function mke(e) {
  return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function yke(e) {
  return "data:image/svg+xml," + mke(e);
}
function gke(e) {
  return 'url("' + yke(e) + '")';
}
const j5 = {
  ...ZG,
  inline: !1
}, vke = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, bke = {
  display: "inline-block"
}, kC = {
  backgroundColor: "currentColor"
}, iW = {
  backgroundColor: "transparent"
}, V5 = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, z5 = {
  webkitMask: kC,
  mask: kC,
  background: iW
};
for (const e in z5) {
  const t = z5[e];
  for (const n in V5)
    t[e + n] = V5[n];
}
const Zw = {};
["horizontal", "vertical"].forEach((e) => {
  const t = e.slice(0, 1) + "Flip";
  Zw[e + "-flip"] = t, Zw[e.slice(0, 1) + "-flip"] = t, Zw[e + "Flip"] = t;
});
function B5(e) {
  return e + (e.match(/^[-0-9.]+$/) ? "px" : "");
}
const U5 = (e, t) => {
  const n = cke(j5, t), r = { ...vke }, i = t.mode || "svg", s = {}, o = t.style, a = typeof o == "object" && !(o instanceof Array) ? o : {};
  for (let v in t) {
    const w = t[v];
    if (w !== void 0)
      switch (v) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          n[v] = w === !0 || w === "true" || w === 1;
          break;
        case "flip":
          typeof w == "string" && pke(n, w);
          break;
        case "color":
          s.color = w;
          break;
        case "rotate":
          typeof w == "string" ? n[v] = hke(w) : typeof w == "number" && (n[v] = w);
          break;
        case "ariaHidden":
        case "aria-hidden":
          w !== !0 && w !== "true" && delete r["aria-hidden"];
          break;
        default: {
          const b = Zw[v];
          b ? (w === !0 || w === "true" || w === 1) && (n[b] = !0) : j5[v] === void 0 && (r[v] = w);
        }
      }
  }
  const l = ROe(e, n), c = l.attributes;
  if (n.inline && (s.verticalAlign = "-0.125em"), i === "svg") {
    r.style = {
      ...s,
      ...a
    }, Object.assign(r, c);
    let v = 0, w = t.id;
    return typeof w == "string" && (w = w.replace(/-/g, "_")), r.innerHTML = DOe(l.body, w ? () => w + "ID" + v++ : "iconifyVue"), vl("svg", r);
  }
  const { body: p, width: f, height: m } = e, y = i === "mask" || (i === "bg" ? !1 : p.indexOf("currentColor") !== -1), g = fke(p, {
    ...c,
    width: f + "",
    height: m + ""
  });
  return r.style = {
    ...s,
    "--svg": gke(g),
    width: B5(c.width),
    height: B5(c.height),
    ...bke,
    ...y ? kC : iW,
    ...a
  }, vl("span", r);
};
HG(!0);
jOe("", HOe);
if (typeof document < "u" && typeof window < "u") {
  rW();
  const e = window;
  if (e.IconifyPreload !== void 0) {
    const t = e.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((r) => {
      try {
        // Check if item is an object and not null/array
        (typeof r != "object" || r === null || r instanceof Array || // Check for 'icons' and 'prefix'
        typeof r.icons != "object" || typeof r.prefix != "string" || // Add icon set
        !OOe(r)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (e.IconifyProviders !== void 0) {
    const t = e.IconifyProviders;
    if (typeof t == "object" && t !== null)
      for (let n in t) {
        const r = "IconifyProviders[" + n + "] is invalid.";
        try {
          const i = t[n];
          if (typeof i != "object" || !i || i.resources === void 0)
            continue;
          VOe(n, i) || console.error(r);
        } catch {
          console.error(r);
        }
      }
  }
}
const wke = {
  ...a2,
  body: ""
}, jd = fe({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this._name = "", this._loadingIcon = null, this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(e, t) {
      if (typeof e == "object" && e !== null && typeof e.body == "string")
        return this._name = "", this.abortLoading(), {
          data: e
        };
      let n;
      if (typeof e != "string" || (n = o2(e, !1, !0)) === null)
        return this.abortLoading(), null;
      const r = MOe(n);
      if (!r)
        return (!this._loadingIcon || this._loadingIcon.name !== e) && (this.abortLoading(), this._name = "", r !== null && (this._loadingIcon = {
          name: e,
          abort: uke([n], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== e && (this._name = e, t && t(e));
      const i = ["iconify"];
      return n.prefix !== "" && i.push("iconify--" + n.prefix), n.provider !== "" && i.push("iconify--" + n.provider), { data: r, classes: i };
    }
  },
  // Render icon
  render() {
    this.counter;
    const e = this.$attrs, t = this.iconMounted ? this.getIcon(e.icon, e.onLoad) : null;
    if (!t)
      return U5(wke, e);
    let n = e;
    return t.classes && (n = {
      ...e,
      class: (typeof e.class == "string" ? e.class + " " : "") + t.classes.join(" ")
    }), U5({
      ...a2,
      ...t.data
    }, n);
  }
});
zC.defaults.withCredentials = !0;
const dm = zC.create({
  // baseURL: 'http://49.234.15.230:30192',
  withCredentials: !0,
  timeout: 6e4
});
function _ke(e) {
  const t = (r) => {
    var i;
    q3.error(((i = e == null ? void 0 : e.data) == null ? void 0 : i.message) ?? r);
  };
  if (!e.data) {
    t("");
    return;
  }
  const n = {
    404: () => t(""),
    500: () => t(""),
    403: () => t(""),
    401: () => {
      t(""), router.push(`/login?redirect=${encodeURIComponent(window.location.pathname + window.location.search)}`);
    }
  };
  n[e.status] ? n[e.status]() : t("");
}
dm.interceptors.request.use(
  (e) => e,
  (e) => Promise.reject(e)
);
dm.interceptors.response.use(
  (e) => e,
  (e) => {
    const { response: t } = e;
    if (t)
      return _ke(t), t;
    q3.error("Network error");
  }
);
let ev = "", tv = "";
function Ske(e) {
  e.baseURL && (ev = e.baseURL), e.token && (tv = e.token);
}
function xke() {
  return dm.get(`${ev}/api/v1/project`, {
    headers: {
      Authorization: `Bearer ${tv}`
    }
  });
}
function $ke(e, t) {
  return dm.get(`${ev}/api/v1/prediction/stepData`, {
    params: {
      tag: "step",
      projectId: e,
      predictionId: t
    },
    headers: {
      Authorization: `Bearer ${tv}`
    }
  }).then((n) => n.data).catch((n) => {
    throw n;
  });
}
function sW(e) {
  return dm.get(`${ev}/api/v1/prediction/predictionOutputData/${e}`, {
    headers: {
      Authorization: `Bearer ${tv}`
    }
  }).then((t) => t.data).catch((t) => {
    throw t;
  });
}
function Tke(e, t) {
  return dm.post(`${ev}/api/v1/prediction/od`, {
    projectId: e,
    currentPredictionId: t
  }, {
    headers: {
      Authorization: `Bearer ${tv}`
    }
  }).then((n) => n.data).catch((n) => {
    throw n;
  });
}
let AC = {}, PC = {};
const k_ = [], Ms = J([]);
function Eke(e) {
  e ? Ike(e) : AC = {};
}
function Ike(e) {
  sW(e).then((t) => {
    var n;
    t.code === 0 && (AC = t.data, PC = (n = AC.list.filter((i) => {
      const s = Ge.predictionAssessmentType === "current" ? void 0 : Ge.predictionAssessmentType;
      return i.predictionAssessmentType === s && i.predictionResearchPhase === Ge.predictionResearchPhase;
    })[0]) == null ? void 0 : n.data, Mke());
  }).catch((t) => ({ error: t }));
}
function Mke() {
  k_.length = 0, r2.links.forEach((e, t) => {
    const n = {
      saturation: e.saturation - PC.links[t].saturation,
      vol: e.vol - PC.links[t].vol,
      origin_id: e.origin_id,
      id: e.id
    }, r = pc.links.find((i) => i.id === e.origin_id);
    n.link_name = r.link_name, n.shape = r.shape.split(" ").map((i) => i.split(",")), n.nodes = DG(r.shape, e.direction), k_.push(n);
  }), Cke();
}
const A_ = new NS(), q5 = [], RC = [];
function Cke() {
  Q0.forEach((e) => {
    e.visible = !1;
  }), cm.forEach((e) => {
    e.visible = !1;
  }), k_.forEach((e) => {
    const t = G3(e.nodes), n = e.vol > 0 ? "red" : "green", r = new Jt({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Fe(n),
        width: kke(e.vol)
      },
      attributes: {
        ...e,
        polylineType: "diff-line"
      }
    });
    q5.push(r);
    const i = new Jt({
      geometry: new Oe({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new Ro({
        text: e.vol.toFixed(0),
        font: {
          size: 10
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      }),
      attributes: {
        polylineType: "diff-line-text"
      }
    });
    RC.push(i), Xi.zoom < 16 && (i.visible = !1);
  }), A_.addMany([...q5, ...RC]), Gs.add(A_);
}
function Hm() {
  A_.removeAll(), Gs.remove(A_);
}
function Oke() {
  const e = Array.from(new Set(k_.map((i) => Math.abs(i.vol)))).sort((i, s) => i - s), t = e.length, n = [
    e[0],
    // 0%
    e[Math.ceil((t - 1) * 0.25)],
    e[Math.ceil((t - 1) * 0.5)],
    e[Math.ceil((t - 1) * 0.75)]
  ], r = [
    { value: 1, text: n[0] },
    { value: 4, text: n[1] },
    { value: 7, text: n[2] },
    { value: 10, text: n[3] }
  ];
  return Ms.value = r, r;
}
function kke(e) {
  const t = Math.abs(e);
  return Ms.value.length === 0 && Oke(), t >= Ms.value[0].text && t < Ms.value[1].text ? Ms.value[0].value : t >= Ms.value[1].text && t < Ms.value[2].text ? flowLegend.value[1].value : t >= Ms.value[2].text && t < Ms.value[3].text ? Ms.value[2].value : Ms.value[3].value;
}
Xi.watch("zoom", (e) => {
  RC.forEach((t) => {
    t.visible = Ge.flowDiff && Xi.zoom > 16;
  });
});
const oW = J([]), G5 = new NS();
function Ake() {
  G5.removeAll(), Gs.remove(G5), oW.value.length = 0, xd();
}
const Qp = "material-symbols:minimize", v$ = "material-symbols:chrome-maximize-outline-sharp", aW = {
  __name: "ToggleWindowButton",
  emits: ["change"],
  setup(e, { emit: t }) {
    const n = t, r = J(Qp);
    function i() {
      r.value = r.value === Qp ? v$ : Qp, n("change", r.value === Qp);
    }
    return (s, o) => (F(), X("div", {
      class: "cursor-pointer",
      onClick: i
    }, [
      r.value === Qp ? (F(), ce(_(jd), {
        key: 0,
        icon: Qp,
        class: "text-sm text-stone-600"
      })) : he("", !0),
      r.value === v$ ? (F(), ce(_(jd), {
        key: 1,
        icon: v$,
        class: "text-sm text-stone-600"
      })) : he("", !0)
    ]));
  }
}, Pke = { class: "bg-white shadow text-sm divide-y w-[340px]" }, Rke = { class: "h-10 flex items-center justify-between px-3" }, Lke = /* @__PURE__ */ ee("div", { class: "text-stone-600 text-base" }, "  ", -1), Fke = {
  key: 0,
  class: "divide-y"
}, Nke = { class: "px-3 py-2" }, Dke = { class: "w-full flex items-center justify-between" }, jke = { class: "text-[#606266] leading-normal" }, Vke = { class: "w-full flex items-center justify-between" }, zke = { class: "w-full" }, Bke = { class: "text-[#606266] text-xs pt-2 pb-1 h-6 flex items-center" }, Uke = { class: "py-2 px-3" }, qke = { class: "grid grid-cols-2 grid-rows-1 gap-1" }, Gke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Wke = /* @__PURE__ */ ee("div", null, "", -1), Hke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Jke = /* @__PURE__ */ ee("div", null, "", -1), Zke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Kke = /* @__PURE__ */ ee("div", null, "", -1), Yke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Qke = /* @__PURE__ */ ee("div", null, "", -1), Xke = {
  __name: "ControlPanel",
  setup(e) {
    const t = P(() => Ge), n = J(!0), r = J("");
    function i(G) {
      n.value = G;
    }
    const s = J([]), o = J([]), a = J([]);
    async function l() {
      const G = mCe.service({
        lock: !0,
        text: "",
        background: "rgba(0, 0, 0, 0.7)"
      });
      Promise.all([
        $ke(t.value.project[0], t.value.project[1]),
        sW(t.value.project[1]),
        Tke(t.value.project[0], t.value.project[1])
      ]).then((R) => {
        var V;
        R[0].code === 0 && R[1].code === 0 && (Object.assign(pc, R[0].data), Object.assign(I_, R[1].data), a.value = JCe(R[1].data.list), h$()), ((V = R[2]) == null ? void 0 : V.code) === 0 && (Object.assign(VG, R[2].data), tOe(t, R[2].data)), G.close();
      }).catch((R) => {
        R.response && R.response.status === 404 ? console.error("OD404") : console.error("", R), G.close();
      });
    }
    function c(G) {
      for (const R of s.value)
        if (R.value === G)
          return R.children;
      return [];
    }
    function p(G) {
      o.value = c(G[0]), eOe(), l();
    }
    function f(G) {
      xd(G === 1 ? "link" : "cross"), G === 2 && (t.value.predictionIndex = 1);
    }
    function m(G) {
      xd(G === 1 ? "link" : "flow");
    }
    function y() {
      t.value.link_name = "", Ake();
    }
    function g(G) {
      t.value.heatMap && E5(), t.value.expectedLine && rOe();
    }
    function v() {
      h$();
    }
    function w() {
      h$();
    }
    async function b() {
      const G = [
        // {
        //   projectId: 2355,
        //   projectName: '',
        //   createdAt: '2020-09-21 08:50:08',
        //   updatedAt: '2020-09-21 10:50:08',
        //   updater: '',
        //   redictions: [
        //     {
        //       id: 27446,
        //       name: '',
        //     },
        //     {
        //       id: 27445,
        //       name: '',
        //     },
        //     {
        //       id: 27443,
        //       name: '2',
        //     },
        //   ],
        // },
      ], { data: R } = await xke();
      R.code === 0 && (G = R.data.list);
      const V = G.map((Q) => ({
        label: Q.projectName,
        value: Q.projectId,
        children: Q.redictions.map((de) => ({
          label: de.name,
          value: de.id
        }))
      }));
      s.value = V;
    }
    Yt(async () => {
      b(), t.value.project.length === 0 && fb(""), t.value.project.push(2355), t.value.project.push(27446), l();
    });
    function S(G) {
      Hm(), Eke(G);
    }
    function $() {
      r.value = "", Hm(), m$();
    }
    function I() {
      iOe(), Ge.community.length = 0;
    }
    function M() {
      hOe();
    }
    function E() {
      fOe();
    }
    function C(G) {
      G ? E5() : zG();
    }
    function A(G) {
      G ? (fb(""), m$(), sOe(), t.value.spiderWeb = !1, t.value.flowDiff = !1, r.value = "", Hm()) : (I5(), xd());
    }
    function W(G) {
      G ? (fb(""), t.value.predictionObject = 1, t.value.predictionIndex = 1, t.value.flowDiff = !1, t.value.expectedLine = !1, I5(), r.value = "", Hm(), xd()) : y();
    }
    function j(G) {
      G ? (fb(""), t.value.predictionObject = 1, t.value.predictionIndex = 2, m$(), t.value.expectedLine = !1, t.value.spiderWeb = !1) : (r.value = "", Hm(), xd());
    }
    return (G, R) => (F(), X("div", Pke, [
      ee("div", Rke, [
        Lke,
        ye(aW, { onChange: i })
      ]),
      ye(_(MG), null, {
        default: te(() => [
          n.value ? (F(), X("div", Fke, [
            ee("div", Nke, [
              ye(_(nTe), {
                model: t.value,
                "label-width": "95px"
              }, {
                default: te(() => [
                  ye(_(ro), {
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(hMe), {
                        modelValue: t.value.project,
                        "onUpdate:modelValue": R[0] || (R[0] = (V) => t.value.project = V),
                        options: s.value,
                        props: { expandTrigger: "hover" },
                        filterable: "",
                        placeholder: "",
                        class: "w-full",
                        onChange: p
                      }, null, 8, ["modelValue", "options"])
                    ]),
                    _: 1
                  }),
                  ye(_(ro), {
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(pb), {
                        modelValue: t.value.predictionAssessmentType,
                        "onUpdate:modelValue": R[1] || (R[1] = (V) => t.value.predictionAssessmentType = V),
                        disabled: t.value.project.length === 0,
                        onChange: v
                      }, {
                        default: te(() => [
                          ye(_(ua), {
                            label: "current",
                            class: "!mr-4"
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }),
                          ye(_(ua), {
                            label: "near",
                            class: "!mr-4"
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }),
                          ye(_(ua), { label: "far" }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  }),
                  ye(_(ro), {
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(_5), {
                        modelValue: t.value.predictionResearchPhase,
                        "onUpdate:modelValue": R[2] || (R[2] = (V) => t.value.predictionResearchPhase = V),
                        placeholder: "",
                        class: "w-full",
                        disabled: t.value.project.length === 0,
                        onChange: w
                      }, {
                        default: te(() => [
                          ye(_(Um), {
                            label: "",
                            value: "morningPeak",
                            disabled: !a.value.includes("morningPeak")
                          }, null, 8, ["disabled"]),
                          ye(_(Um), {
                            label: "",
                            value: "nightPeak",
                            disabled: !a.value.includes("nightPeak")
                          }, null, 8, ["disabled"]),
                          ye(_(Um), {
                            label: "",
                            value: "holiday",
                            disabled: !a.value.includes("holiday")
                          }, null, 8, ["disabled"]),
                          ye(_(Um), {
                            label: "",
                            value: "other",
                            disabled: !a.value.includes("other")
                          }, null, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  }),
                  t.value.expectedLine ? he("", !0) : (F(), ce(_(ro), {
                    key: 0,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(pb), {
                        modelValue: t.value.predictionObject,
                        "onUpdate:modelValue": R[3] || (R[3] = (V) => t.value.predictionObject = V),
                        disabled: t.value.project.length === 0,
                        onChange: f
                      }, {
                        default: te(() => [
                          ye(_(ua), {
                            label: 1,
                            class: "!mr-4"
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }),
                          ye(_(ua), {
                            label: 2,
                            disabled: t.value.spiderWeb || t.value.flowDiff
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })),
                  t.value.expectedLine ? he("", !0) : (F(), ce(_(ro), {
                    key: 1,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(pb), {
                        modelValue: t.value.predictionIndex,
                        "onUpdate:modelValue": R[4] || (R[4] = (V) => t.value.predictionIndex = V),
                        disabled: t.value.project.length === 0,
                        onChange: m
                      }, {
                        default: te(() => [
                          ye(_(ua), {
                            label: 1,
                            class: "!mr-4",
                            disabled: t.value.flowDiff
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }, 8, ["disabled"]),
                          ye(_(ua), {
                            label: 2,
                            disabled: t.value.predictionObject === 2
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })),
                  t.value.expectedLine || t.value.heatMap ? (F(), ce(_(ro), {
                    key: 2,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(pb), {
                        modelValue: t.value.predictionTrans,
                        "onUpdate:modelValue": R[5] || (R[5] = (V) => t.value.predictionTrans = V),
                        disabled: t.value.project.length === 0,
                        onChange: g
                      }, {
                        default: te(() => [
                          ye(_(ua), {
                            label: "out",
                            class: "!mr-4"
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          }),
                          ye(_(ua), { label: "in" }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })) : he("", !0),
                  t.value.spiderWeb ? (F(), ce(_(ro), {
                    key: 3,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ee("div", Dke, [
                        ee("div", jke, [
                          ee("span", {
                            class: Z({ "text-red-500": !t.value.link_name })
                          }, it(t.value.link_name || ""), 3)
                        ]),
                        t.value.link_name ? (F(), ce(_(d$), {
                          key: 0,
                          size: "small",
                          type: "primary",
                          text: "",
                          bg: "",
                          class: "ml-2",
                          onClick: y
                        }, {
                          default: te(() => [
                            Kn("  ")
                          ]),
                          _: 1
                        })) : he("", !0)
                      ])
                    ]),
                    _: 1
                  })) : he("", !0),
                  t.value.expectedLine ? (F(), ce(_(ro), {
                    key: 4,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(md), {
                        modelValue: t.value.showPulse,
                        "onUpdate:modelValue": R[6] || (R[6] = (V) => t.value.showPulse = V),
                        onChange: E
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })) : he("", !0),
                  t.value.expectedLine ? (F(), ce(_(ro), {
                    key: 5,
                    label: "OD:",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ye(_(md), {
                        modelValue: t.value.showOd,
                        "onUpdate:modelValue": R[7] || (R[7] = (V) => t.value.showOd = V),
                        onChange: M
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })) : he("", !0),
                  t.value.expectedLine ? (F(), ce(_(ro), {
                    key: 6,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ee("div", Vke, [
                        ee("div", {
                          class: Z(["text-[#606266] leading-normal flex-1 w-[170px] break-words", { "text-red-500": !t.value.community.length }])
                        }, it(t.value.community.join("; ") || ""), 3),
                        t.value.community.length ? (F(), ce(_(d$), {
                          key: 0,
                          size: "small",
                          type: "primary",
                          text: "",
                          bg: "",
                          class: "ml-2",
                          onClick: I
                        }, {
                          default: te(() => [
                            Kn("  ")
                          ]),
                          _: 1
                        })) : he("", !0)
                      ])
                    ]),
                    _: 1
                  })) : he("", !0),
                  t.value.flowDiff ? (F(), ce(_(ro), {
                    key: 7,
                    label: ":",
                    class: "!mb-1"
                  }, {
                    default: te(() => [
                      ee("div", zke, [
                        ee("div", Bke, [
                          Kn("  "),
                          r.value ? (F(), ce(_(d$), {
                            key: 0,
                            size: "small",
                            text: "",
                            type: "primary",
                            class: "!py-0",
                            onClick: $
                          }, {
                            default: te(() => [
                              Kn("  ")
                            ]),
                            _: 1
                          })) : he("", !0)
                        ]),
                        ye(_(_5), {
                          modelValue: r.value,
                          "onUpdate:modelValue": R[8] || (R[8] = (V) => r.value = V),
                          placeholder: "",
                          class: "w-full",
                          onChange: S
                        }, {
                          default: te(() => [
                            (F(!0), X(Ft, null, bi(o.value, (V) => (F(), ce(_(Um), {
                              key: V.value,
                              label: V.label,
                              value: V.value
                            }, null, 8, ["label", "value"]))), 128))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ])
                    ]),
                    _: 1
                  })) : he("", !0)
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            ee("div", Uke, [
              ee("div", qke, [
                ee("div", Gke, [
                  ye(_(jd), {
                    icon: "carbon:heat-map-02",
                    class: "text-base"
                  }),
                  Wke,
                  ye(_(md), {
                    modelValue: t.value.heatMap,
                    "onUpdate:modelValue": R[9] || (R[9] = (V) => t.value.heatMap = V),
                    disabled: t.value.project.length === 0,
                    onChange: C
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                ee("div", Hke, [
                  ye(_(jd), {
                    icon: "carbon:summary-kpi",
                    class: "text-base"
                  }),
                  Jke,
                  ye(_(md), {
                    modelValue: t.value.expectedLine,
                    "onUpdate:modelValue": R[10] || (R[10] = (V) => t.value.expectedLine = V),
                    disabled: t.value.project.length === 0,
                    onChange: A
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                ee("div", Zke, [
                  ye(_(jd), {
                    icon: "carbon:chart-parallel",
                    class: "text-base"
                  }),
                  Kke,
                  ye(_(md), {
                    modelValue: t.value.spiderWeb,
                    "onUpdate:modelValue": R[11] || (R[11] = (V) => t.value.spiderWeb = V),
                    disabled: t.value.project.length === 0,
                    onChange: W
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                ee("div", Yke, [
                  ye(_(jd), {
                    icon: "carbon:traffic-flow",
                    class: "text-base"
                  }),
                  Qke,
                  ye(_(md), {
                    modelValue: t.value.flowDiff,
                    "onUpdate:modelValue": R[12] || (R[12] = (V) => t.value.flowDiff = V),
                    disabled: t.value.project.length === 0,
                    onChange: j
                  }, null, 8, ["modelValue", "disabled"])
                ])
              ])
            ])
          ])) : he("", !0)
        ]),
        _: 1
      })
    ]));
  }
}, e3e = { class: "bg-white shadow text-sm divide-y min-w-[200px]" }, t3e = { class: "h-10 flex items-center justify-between px-3" }, n3e = /* @__PURE__ */ ee("div", { class: "text-stone-600 text-base" }, "  ", -1), r3e = {
  key: 0,
  class: "px-3 py-2"
}, i3e = {
  key: 0,
  class: "space-y-2"
}, s3e = {
  key: 0,
  class: "space-y-2 mb-5"
}, o3e = { class: "flex items-center justify-between" }, a3e = { class: "text-center" }, l3e = /* @__PURE__ */ ee("div", { class: "flex items-center space-x-4" }, [
  /* @__PURE__ */ ee("div", { class: "w-10 h-[2px] bg-green-800" }),
  /* @__PURE__ */ ee("span", null, "  0")
], -1), u3e = /* @__PURE__ */ ee("div", { class: "flex items-center space-x-4" }, [
  /* @__PURE__ */ ee("div", { class: "w-10 h-[2px] bg-red-500" }),
  /* @__PURE__ */ ee("span", null, "  0")
], -1), c3e = {
  key: 0,
  class: "space-y-2 mb-5"
}, d3e = { class: "flex items-center justify-between" }, p3e = { class: "text-center" }, h3e = {
  key: 0,
  class: "space-y-2 mb-5"
}, f3e = { class: "flex items-center justify-between" }, m3e = { class: "text-center" }, y3e = {
  key: 0,
  class: "space-y-2"
}, g3e = {
  key: 1,
  class: "space-y-2"
}, v3e = { class: "flex items-center justify-between" }, b3e = { class: "text-center" }, w3e = {
  __name: "MapLegend",
  setup(e) {
    const t = P(() => Ge), n = [
      {
        text: "A ",
        value: "#4B7902"
      },
      {
        text: "B ",
        value: "#95F204"
      },
      {
        text: "C ",
        value: "#FFD400"
      },
      {
        text: "D ",
        value: "#F47920"
      },
      {
        text: "E ",
        value: "#D9001B"
      },
      {
        text: "F ",
        value: "#843900"
      }
    ];
    P(() => Y0);
    const r = J(!0);
    function i(p) {
      r.value = p;
    }
    const s = P(() => Is), o = P(() => BG), a = P(() => Ms), l = P(() => $C), c = P(() => oW);
    return (p, f) => (F(), X("div", e3e, [
      ee("div", t3e, [
        n3e,
        ye(aW, { onChange: i })
      ]),
      ye(_(MG), null, {
        default: te(() => [
          r.value ? (F(), X("div", r3e, [
            t.value.flowDiff ? (F(), X("div", i3e, [
              a.value.value.length ? (F(), X("div", s3e, [
                ee("div", o3e, [
                  (F(!0), X(Ft, null, bi(a.value.value, (m) => (F(), X("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    ee("div", a3e, it(m.text), 1),
                    ee("div", {
                      style: It({ height: `${m.value}px` }),
                      class: "bg-[#ccc]"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : he("", !0),
              l3e,
              u3e
            ])) : t.value.expectedLine ? (F(), X(Ft, { key: 1 }, [
              l.value.value ? (F(), X("div", c3e, [
                ee("div", d3e, [
                  (F(!0), X(Ft, null, bi(o.value.value, (m) => (F(), X("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    ee("div", p3e, it(m.text), 1),
                    ee("div", {
                      style: It({ height: `${m.value}px` }),
                      class: "bg-orange-400"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : he("", !0)
            ], 64)) : t.value.spiderWeb ? (F(), X(Ft, { key: 2 }, [
              c.value.value.length ? (F(), X("div", h3e, [
                ee("div", f3e, [
                  (F(!0), X(Ft, null, bi(c.value.value, (m) => (F(), X("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    ee("div", m3e, it(m.text), 1),
                    ee("div", {
                      style: It({ height: `${m.value}px` }),
                      class: "bg-[#90EE90]"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : he("", !0)
            ], 64)) : (F(), X(Ft, { key: 3 }, [
              t.value.predictionIndex === 1 ? (F(), X("div", y3e, [
                (F(), X(Ft, null, bi(n, (m) => ee("div", {
                  key: m.value,
                  class: "flex items-center space-x-4"
                }, [
                  ee("div", {
                    class: Z(t.value.predictionObject === 1 ? "w-10 h-[2px]" : "w-5 h-5 rounded-full border-2 border-gray-300"),
                    style: It({ backgroundColor: m.value })
                  }, null, 6),
                  ee("span", null, it(m.text), 1)
                ])), 64))
              ])) : (F(), X("div", g3e, [
                ee("div", v3e, [
                  (F(!0), X(Ft, null, bi(s.value.value, (m) => (F(), X("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    ee("div", b3e, it(m.text), 1),
                    ee("div", {
                      style: It({ height: `${m.value}px` }),
                      class: "bg-red-400"
                    }, null, 4)
                  ]))), 128))
                ])
              ]))
            ], 64))
          ])) : he("", !0)
        ]),
        _: 1
      })
    ]));
  }
}, _3e = { class: "bg-white shadow text-sm" }, S3e = { class: "px-3 py-2 flex items-center space-x-2" }, x3e = /* @__PURE__ */ ee("span", null, "", -1), $3e = {
  __name: "ChangeMap",
  emits: ["changeMap"],
  setup(e, { emit: t }) {
    const n = t, r = J("geoscene-blue");
    function i(s) {
      n("changeMap", s);
    }
    return (s, o) => (F(), X("div", _3e, [
      ee("div", S3e, [
        ye(_(jd), { icon: "ic:round-satellite-alt" }),
        x3e,
        ye(_(md), {
          modelValue: r.value,
          "onUpdate:modelValue": o[0] || (o[0] = (a) => r.value = a),
          "active-value": "tianditu-image",
          "inactive-value": "geoscene-blue",
          onChange: i
        }, null, 8, ["modelValue"])
      ])
    ]));
  }
}, T3e = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, i] of t)
    n[r] = i;
  return n;
}, E3e = (e) => (LW("data-v-f2848984"), e = e(), FW(), e), I3e = /* @__PURE__ */ E3e(() => /* @__PURE__ */ ee("div", { class: "h-0" }, null, -1)), M3e = {
  __name: "ShowCross",
  setup(e) {
    const t = J(null), n = P(() => SC.value);
    function r() {
      SC.value = !1, n.value = !1;
    }
    function i() {
      GCe(t);
    }
    return (s, o) => (F(), X("div", null, [
      ye(_(FMe), {
        modelValue: n.value,
        "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
        title: "",
        width: "500px",
        onClose: r,
        onOpened: i
      }, {
        header: te(() => [
          I3e
        ]),
        default: te(() => [
          ee("canvas", {
            ref_key: "canvasRef",
            ref: t,
            class: "w-[500px] h-[500px] bg-neutral-400"
          }, null, 512)
        ]),
        _: 1
      }, 8, ["modelValue"])
    ]));
  }
}, C3e = /* @__PURE__ */ T3e(M3e, [["__scopeId", "data-v-f2848984"]]), O3e = { class: "relative bg-slate-50 h-screen" }, Kw = {
  __name: "view",
  props: {
    config: {
      type: Object,
      default: () => ({
        baseUrl: "",
        token: ""
      })
    }
  },
  setup(e) {
    const t = e, n = J(null);
    Yt(() => {
      Xi.container = n.value, Ske(t.config);
    });
    function r(i) {
      Gs.basemap = i;
    }
    return (i, s) => (F(), X("div", O3e, [
      ee("div", {
        ref_key: "mapDiv",
        ref: n,
        class: "w-full h-full absolute top-0 left-0 z-10"
      }, null, 512),
      ye(Xke, { class: "z-20 absolute top-4 left-4" }),
      ye(w3e, { class: "z-20 absolute bottom-4 left-4" }),
      ye($3e, {
        class: "z-20 absolute top-4 right-4",
        onChangeMap: r
      }),
      ye(C3e)
    ]));
  }
};
Kw.install = (e) => {
  e.component(Kw.__name, Kw);
};
const k3e = [Kw], A3e = (e) => {
  k3e.forEach((t) => {
    e.component(t.__name, t);
  });
}, Q4e = { install: A3e };
export {
  gS as $,
  R6 as A,
  lS as B,
  rn as C,
  st as D,
  ege as E,
  l4e as F,
  c4e as G,
  mp as H,
  Cg as I,
  Oi as J,
  iT as K,
  z0 as L,
  Mt as M,
  hpe as N,
  FPe as O,
  va as P,
  _f as Q,
  cr as R,
  q as S,
  z8 as T,
  MAe as U,
  hk as V,
  Ol as W,
  QD as X,
  I0 as Y,
  K as Z,
  Aae as _,
  T as a,
  EO as a$,
  ope as a0,
  La as a1,
  yoe as a2,
  ss as a3,
  tc as a4,
  _O as a5,
  SO as a6,
  Bd as a7,
  wO as a8,
  C6 as a9,
  Bhe as aA,
  Uhe as aB,
  qhe as aC,
  se as aD,
  be as aE,
  kae as aF,
  Xu as aG,
  _D as aH,
  OAe as aI,
  zd as aJ,
  U3e as aK,
  TD as aL,
  Fge as aM,
  xD as aN,
  cPe as aO,
  Dn as aP,
  KK as aQ,
  loe as aR,
  aX as aS,
  Xhe as aT,
  XD as aU,
  RLe as aV,
  JV as aW,
  w0 as aX,
  HV as aY,
  PLe as aZ,
  kLe as a_,
  os as aa,
  Oe as ab,
  Po as ac,
  Ki as ad,
  Gf as ae,
  wf as af,
  E0 as ag,
  cp as ah,
  SE as ai,
  tn as aj,
  _E as ak,
  $E as al,
  A1 as am,
  Jte as an,
  En as ao,
  BA as ap,
  Pt as aq,
  PO as ar,
  $P as as,
  $Pe as at,
  uRe as au,
  yRe as av,
  $p as aw,
  VFe as ax,
  ke as ay,
  ot as az,
  Jt as b,
  Ds as b$,
  sc as b0,
  Lo as b1,
  VPe as b2,
  zPe as b3,
  DPe as b4,
  jPe as b5,
  Mi as b6,
  mPe as b7,
  LLe as b8,
  BC as b9,
  oP as bA,
  P8 as bB,
  Xr as bC,
  xe as bD,
  iS as bE,
  xhe as bF,
  y0 as bG,
  Og as bH,
  dhe as bI,
  lhe as bJ,
  ahe as bK,
  ki as bL,
  Hs as bM,
  hS as bN,
  Yf as bO,
  Ip as bP,
  Ehe as bQ,
  vpe as bR,
  cpe as bS,
  Ype as bT,
  Vu as bU,
  afe as bV,
  Vt as bW,
  DRe as bX,
  _S as bY,
  Ro as bZ,
  Yk as b_,
  wV as ba,
  CE as bb,
  On as bc,
  jde as bd,
  Hf as be,
  MFe as bf,
  DK as bg,
  Vde as bh,
  IFe as bi,
  bFe as bj,
  Dg as bk,
  rg as bl,
  oE as bm,
  CFe as bn,
  zfe as bo,
  dRe as bp,
  gRe as bq,
  vRe as br,
  De as bs,
  rB as bt,
  cB as bu,
  fhe as bv,
  bhe as bw,
  YQ as bx,
  JQ as by,
  P7 as bz,
  Hd as c,
  YLe as c$,
  NS as c0,
  w1 as c1,
  vne as c2,
  ZO as c3,
  B7 as c4,
  NFe as c5,
  To as c6,
  mt as c7,
  g0 as c8,
  hf as c9,
  gce as cA,
  vce as cB,
  Wr as cC,
  fn as cD,
  Ci as cE,
  Ku as cF,
  xce as cG,
  r7 as cH,
  Fce as cI,
  aFe as cJ,
  Mce as cK,
  L0 as cL,
  ele as cM,
  Ar as cN,
  bce as cO,
  Oce as cP,
  mce as cQ,
  kce as cR,
  Ace as cS,
  Pce as cT,
  Ice as cU,
  _te as cV,
  Fa as cW,
  pce as cX,
  Fl as cY,
  Rce as cZ,
  Wg as c_,
  js as ca,
  Rde as cb,
  Nu as cc,
  Jk as cd,
  CPe as ce,
  nc as cf,
  op as cg,
  pB as ch,
  B6 as ci,
  GC as cj,
  wce as ck,
  Gr as cl,
  KD as cm,
  uce as cn,
  dce as co,
  cce as cp,
  Ji as cq,
  hce as cr,
  fce as cs,
  Xae as ct,
  OA as cu,
  Dh as cv,
  Ok as cw,
  br as cx,
  Vs as cy,
  fp as cz,
  d,
  Kk as d$,
  Dce as d0,
  MS as d1,
  jce as d2,
  Vce as d3,
  s7 as d4,
  zce as d5,
  o7 as d6,
  sw as d7,
  Bce as d8,
  oFe as d9,
  Wce as dA,
  ice as dB,
  CRe as dC,
  PK as dD,
  y1 as dE,
  iO as dF,
  ORe as dG,
  BQ as dH,
  Jr as dI,
  xPe as dJ,
  FO as dK,
  lp as dL,
  ghe as dM,
  ehe as dN,
  wP as dO,
  P6 as dP,
  dfe as dQ,
  uhe as dR,
  Yhe as dS,
  oB as dT,
  Zk as dU,
  xF as dV,
  _w as dW,
  sB as dX,
  C7 as dY,
  Bde as dZ,
  ohe as d_,
  hZ as da,
  Fe as db,
  YNe as dc,
  c6 as dd,
  Ii as de,
  lfe as df,
  kl as dg,
  ap as dh,
  Oo as di,
  jh as dj,
  Ky as dk,
  KRe as dl,
  tp as dm,
  qP as dn,
  Dye as dp,
  Vye as dq,
  Dx as dr,
  jye as ds,
  mN as dt,
  Xg as du,
  zye as dv,
  ZNe as dw,
  g2 as dx,
  fQ as dy,
  Gce as dz,
  u as e,
  Jy as e$,
  vB as e0,
  tfe as e1,
  mc as e2,
  b0 as e3,
  mO as e4,
  kn as e5,
  K3e as e6,
  tf as e7,
  yP as e8,
  Qh as e9,
  Ipe as eA,
  Mpe as eB,
  HJ as eC,
  lr as eD,
  dPe as eE,
  ma as eF,
  Vf as eG,
  cJ as eH,
  j3e as eI,
  OS as eJ,
  G3e as eK,
  B1 as eL,
  xde as eM,
  Ao as eN,
  cAe as eO,
  Ea as eP,
  Rc as eQ,
  Cn as eR,
  qQ as eS,
  wLe as eT,
  B3e as eU,
  lRe as eV,
  mRe as eW,
  VLe as eX,
  Hj as eY,
  uI as eZ,
  yPe as e_,
  Ma as ea,
  Co as eb,
  Ta as ec,
  xw as ed,
  vF as ee,
  sfe as ef,
  kg as eg,
  O7 as eh,
  jk as ei,
  iB as ej,
  hhe as ek,
  phe as el,
  zf as em,
  Ij as en,
  che as eo,
  Pde as ep,
  oJ as eq,
  rRe as er,
  nS as es,
  nRe as et,
  YD as eu,
  K_ as ev,
  XX as ew,
  T8 as ex,
  Xd as ey,
  tB as ez,
  Nt as f,
  qf as f$,
  Joe as f0,
  Kre as f1,
  fpe as f2,
  zk as f3,
  ype as f4,
  gpe as f5,
  xO as f6,
  HC as f7,
  yh as f8,
  Hi as f9,
  I6 as fA,
  TPe as fB,
  OQ as fC,
  SPe as fD,
  T7 as fE,
  wFe as fF,
  Sp as fG,
  pa as fH,
  iee as fI,
  LB as fJ,
  L3e as fK,
  tRe as fL,
  Pte as fM,
  H8 as fN,
  jLe as fO,
  QR as fP,
  zLe as fQ,
  OLe as fR,
  zV as fS,
  qV as fT,
  DV as fU,
  MY as fV,
  RY as fW,
  WV as fX,
  FAe as fY,
  JAe as fZ,
  p6 as f_,
  JC as fa,
  n1 as fb,
  XL as fc,
  DFe as fd,
  oK as fe,
  fc as ff,
  $t as fg,
  HPe as fh,
  LD as fi,
  OPe as fj,
  p_ as fk,
  dJ as fl,
  yJ as fm,
  vJ as fn,
  q3e as fo,
  D3e as fp,
  yl as fq,
  ZB as fr,
  NNe as fs,
  e4e as ft,
  V3e as fu,
  z3e as fv,
  Jm as fw,
  i0e as fx,
  h7 as fy,
  MM as fz,
  Ws as g,
  iLe as g$,
  qRe as g0,
  URe as g1,
  zRe as g2,
  jRe as g3,
  sPe as g4,
  FRe as g5,
  XRe as g6,
  VRe as g7,
  M0 as g8,
  JRe as g9,
  YRe as gA,
  sT as gB,
  Z_ as gC,
  FLe as gD,
  koe as gE,
  BLe as gF,
  UC as gG,
  $O as gH,
  $r as gI,
  U8 as gJ,
  jf as gK,
  SAe as gL,
  aRe as gM,
  SD as gN,
  OV as gO,
  EV as gP,
  TLe as gQ,
  NLe as gR,
  TV as gS,
  CV as gT,
  lLe as gU,
  uLe as gV,
  sRe as gW,
  Cl as gX,
  ef as gY,
  dB as gZ,
  tLe as g_,
  lPe as ga,
  HRe as gb,
  UAe as gc,
  WNe as gd,
  HNe as ge,
  oPe as gf,
  LAe as gg,
  tPe as gh,
  kAe as gi,
  X_ as gj,
  eS as gk,
  QNe as gl,
  BRe as gm,
  Ate as gn,
  bf as go,
  xs as gp,
  Z3e as gq,
  aPe as gr,
  h8 as gs,
  z_ as gt,
  $0 as gu,
  Ng as gv,
  es as gw,
  wee as gx,
  Q_ as gy,
  bRe as gz,
  Tb as h,
  ID as h$,
  nLe as h0,
  P9 as h1,
  yie as h2,
  sLe as h3,
  oLe as h4,
  rLe as h5,
  sAe as h6,
  x as h7,
  NRe as h8,
  w7 as h9,
  Ag as hA,
  Fs as hB,
  bX as hC,
  Q6 as hD,
  AL as hE,
  Ke as hF,
  Lce as hG,
  XLe as hH,
  QLe as hI,
  eFe as hJ,
  sFe as hK,
  PL as hL,
  tFe as hM,
  rFe as hN,
  lce as hO,
  LL as hP,
  nFe as hQ,
  Sye as hR,
  Lt as hS,
  KNe as hT,
  JNe as hU,
  Si as hV,
  ti as hW,
  B as hX,
  Ya as hY,
  kE as hZ,
  cV as h_,
  Gh as ha,
  ede as hb,
  KAe as hc,
  W3e as hd,
  J3e as he,
  ZAe as hf,
  nPe as hg,
  fPe as hh,
  uPe as hi,
  rPe as hj,
  YAe as hk,
  XAe as hl,
  vr as hm,
  lU as hn,
  m1 as ho,
  k$ as hp,
  O$ as hq,
  If as hr,
  Xpe as hs,
  kPe as ht,
  iJ as hu,
  NPe as hv,
  APe as hw,
  RPe as hx,
  PPe as hy,
  LPe as hz,
  gn as i,
  $Z as i$,
  EAe as i0,
  U_ as i1,
  Y_ as i2,
  AAe as i3,
  Uf as i4,
  $Ae as i5,
  Fye as i6,
  Lk as i7,
  Qce as i8,
  j0 as i9,
  mpe as iA,
  Ud as iB,
  N3e as iC,
  _d as iD,
  F4e as iE,
  yO as iF,
  QRe as iG,
  nO as iH,
  WJ as iI,
  GRe as iJ,
  hQ as iK,
  jFe as iL,
  fK as iM,
  rj as iN,
  zFe as iO,
  foe as iP,
  CS as iQ,
  rc as iR,
  m7 as iS,
  y7 as iT,
  dde as iU,
  wi as iV,
  Y8 as iW,
  Hr as iX,
  iI as iY,
  Tp as iZ,
  A$ as i_,
  Kce as ia,
  d7 as ib,
  Xfe as ic,
  hde as id,
  eme as ie,
  g7 as ig,
  $7 as ih,
  n_ as ii,
  fAe as ij,
  a7 as ik,
  r_ as il,
  iFe as im,
  uFe as io,
  gV as ip,
  lFe as iq,
  CLe as ir,
  Zoe as is,
  Yoe as it,
  hp as iu,
  xp as iv,
  WAe as iw,
  dQ as ix,
  IAe as iy,
  Le as iz,
  Ne as j,
  iRe as j$,
  ks as j0,
  XNe as j1,
  Boe as j2,
  WR as j3,
  IV as j4,
  DLe as j5,
  ete as j6,
  EFe as j7,
  WC as j8,
  X2 as j9,
  UFe as jA,
  ULe as jB,
  t3 as jC,
  Whe as jD,
  Hhe as jE,
  Jhe as jF,
  pPe as jG,
  oae as jH,
  Xn as jI,
  Hg as jJ,
  Ak as jK,
  X1 as jL,
  Tce as jM,
  yce as jN,
  n7 as jO,
  ts as jP,
  Ece as jQ,
  _ce as jR,
  K$ as jS,
  Cce as jT,
  sce as jU,
  $ce as jV,
  Sce as jW,
  fFe as jX,
  rye as jY,
  GNe as jZ,
  u_ as j_,
  ex as ja,
  Kt as jb,
  xLe as jc,
  zge as jd,
  TAe as je,
  WRe as jf,
  s1 as jg,
  DNe as jh,
  GAe as ji,
  HAe as jj,
  hJ as jk,
  qh as jl,
  AY as jm,
  ig as jn,
  Pd as jo,
  _Le as jp,
  ALe as jq,
  UV as jr,
  oRe as js,
  SLe as jt,
  eRe as ju,
  YX as jv,
  QX as jw,
  _Pe as jx,
  qFe as jy,
  GFe as jz,
  tS as k,
  oAe as k0,
  Jd as k1,
  gU as k2,
  df as k3,
  N4e as k4,
  R4e as k5,
  L4e as k6,
  d6 as k7,
  Qn as k8,
  ek as k9,
  QAe as kA,
  Kw as kB,
  Q4e as kC,
  fY as kD,
  ILe as kE,
  MLe as kF,
  TFe as kG,
  YFe as kH,
  Yu as ka,
  ba as kb,
  rS as kc,
  LS as kd,
  JPe as ke,
  tU as kf,
  sye as kg,
  nU as kh,
  hye as ki,
  jNe as kj,
  $ye as kk,
  c_ as kl,
  VNe as km,
  CAe as kn,
  iPe as ko,
  ePe as kp,
  nY as kq,
  hPe as kr,
  pRe as ks,
  hRe as kt,
  ZRe as ku,
  Qg as kv,
  Bk as kw,
  qAe as kx,
  fRe as ky,
  cRe as kz,
  H as l,
  Qe as m,
  D4e as n,
  K8 as o,
  Dk as p,
  Js as q,
  O as r,
  we as s,
  OFe as t,
  ei as u,
  N8 as v,
  F3e as w,
  kp as x,
  D as y,
  Qpe as z
};

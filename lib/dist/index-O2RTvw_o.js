import { getCurrentScope as uG, onScopeDispose as c5, ref as q, watch as Se, unref as _, getCurrentInstance as nn, onMounted as qt, nextTick as Ye, readonly as d5, computed as A, defineComponent as he, openBlock as R, createElementBlock as Z, createElementVNode as K, warn as cG, watchEffect as dG, onBeforeUnmount as Ni, inject as ot, isRef as ra, shallowRef as fd, onBeforeMount as pG, provide as cn, renderSlot as ke, mergeProps as Ko, toRef as io, onUnmounted as hG, reactive as ci, toRefs as zu, normalizeClass as B, onUpdated as p5, createVNode as de, Fragment as Mt, useSlots as ef, withCtx as Y, createBlock as ue, resolveDynamicComponent as gr, normalizeStyle as $t, createTextVNode as jr, toDisplayString as Xe, createCommentVNode as le, TransitionGroup as fG, useAttrs as h5, withDirectives as Yt, withModifiers as kt, vShow as di, Transition as po, cloneVNode as mG, Text as f5, Comment as yG, Teleport as m5, onDeactivated as gG, toRaw as Oh, vModelCheckbox as nb, vModelRadio as y5, h as Ha, resolveComponent as Or, renderList as Mi, onBeforeUpdate as vG, withKeys as $i, vModelText as g5, toHandlers as bG, createSlots as f$, triggerRef as Rf, resolveDirective as wG, createApp as _G, shallowReactive as SG, isVNode as jy, render as ib, pushScopeId as $G, popScopeId as xG } from "vue";
function v5(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: TG } = Object.prototype, { getPrototypeOf: M3 } = Object, Fw = /* @__PURE__ */ ((e) => (t) => {
  const r = TG.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ua = (e) => (e = e.toLowerCase(), (t) => Fw(t) === e), Dw = (e) => (t) => typeof t === e, { isArray: tf } = Array, Vy = Dw("undefined");
function EG(e) {
  return e !== null && !Vy(e) && e.constructor !== null && !Vy(e.constructor) && hs(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const b5 = ua("ArrayBuffer");
function IG(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && b5(e.buffer), t;
}
const MG = Dw("string"), hs = Dw("function"), w5 = Dw("number"), jw = (e) => e !== null && typeof e == "object", OG = (e) => e === !0 || e === !1, Pv = (e) => {
  if (Fw(e) !== "object")
    return !1;
  const t = M3(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, CG = ua("Date"), kG = ua("File"), AG = ua("Blob"), PG = ua("FileList"), RG = (e) => jw(e) && hs(e.pipe), LG = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || hs(e.append) && ((t = Fw(e)) === "formdata" || // detect form-data instance
  t === "object" && hs(e.toString) && e.toString() === "[object FormData]"));
}, NG = ua("URLSearchParams"), FG = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Og(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, i;
  if (typeof e != "object" && (e = [e]), tf(e))
    for (n = 0, i = e.length; n < i; n++)
      t.call(null, e[n], n, e);
  else {
    const s = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], t.call(null, e[a], a, e);
  }
}
function _5(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], t === i.toLowerCase())
      return i;
  return null;
}
const S5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, $5 = (e) => !Vy(e) && e !== S5;
function m$() {
  const { caseless: e } = $5(this) && this || {}, t = {}, r = (n, i) => {
    const s = e && _5(t, i) || i;
    Pv(t[s]) && Pv(n) ? t[s] = m$(t[s], n) : Pv(n) ? t[s] = m$({}, n) : tf(n) ? t[s] = n.slice() : t[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Og(arguments[n], r);
  return t;
}
const DG = (e, t, r, { allOwnKeys: n } = {}) => (Og(t, (i, s) => {
  r && hs(i) ? e[s] = v5(i, r) : e[s] = i;
}, { allOwnKeys: n }), e), jG = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), VG = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, zG = (e, t, r, n) => {
  let i, s, o;
  const a = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && M3(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, UG = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, BG = (e) => {
  if (!e)
    return null;
  if (tf(e))
    return e;
  let t = e.length;
  if (!w5(t))
    return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, qG = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && M3(Uint8Array)), GG = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, HG = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, WG = ua("HTMLFormElement"), JG = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), ek = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), ZG = ua("RegExp"), x5 = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  Og(r, (i, s) => {
    let o;
    (o = t(i, s, e)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(e, n);
}, KG = (e) => {
  x5(e, (t, r) => {
    if (hs(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (hs(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, YG = (e, t) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return tf(e) ? n(e) : n(String(e).split(t)), r;
}, QG = () => {
}, XG = (e, t) => (e = +e, Number.isFinite(e) ? e : t), _2 = "abcdefghijklmnopqrstuvwxyz", tk = "0123456789", T5 = {
  DIGIT: tk,
  ALPHA: _2,
  ALPHA_DIGIT: _2 + _2.toUpperCase() + tk
}, eH = (e = 16, t = T5.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function tH(e) {
  return !!(e && hs(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const rH = (e) => {
  const t = new Array(10), r = (n, i) => {
    if (jw(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[i] = n;
        const s = tf(n) ? [] : {};
        return Og(n, (o, a) => {
          const l = r(o, i + 1);
          !Vy(l) && (s[a] = l);
        }), t[i] = void 0, s;
      }
    }
    return n;
  };
  return r(e, 0);
}, nH = ua("AsyncFunction"), iH = (e) => e && (jw(e) || hs(e)) && hs(e.then) && hs(e.catch), X = {
  isArray: tf,
  isArrayBuffer: b5,
  isBuffer: EG,
  isFormData: LG,
  isArrayBufferView: IG,
  isString: MG,
  isNumber: w5,
  isBoolean: OG,
  isObject: jw,
  isPlainObject: Pv,
  isUndefined: Vy,
  isDate: CG,
  isFile: kG,
  isBlob: AG,
  isRegExp: ZG,
  isFunction: hs,
  isStream: RG,
  isURLSearchParams: NG,
  isTypedArray: qG,
  isFileList: PG,
  forEach: Og,
  merge: m$,
  extend: DG,
  trim: FG,
  stripBOM: jG,
  inherits: VG,
  toFlatObject: zG,
  kindOf: Fw,
  kindOfTest: ua,
  endsWith: UG,
  toArray: BG,
  forEachEntry: GG,
  matchAll: HG,
  isHTMLForm: WG,
  hasOwnProperty: ek,
  hasOwnProp: ek,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: x5,
  freezeMethods: KG,
  toObjectSet: YG,
  toCamelCase: JG,
  noop: QG,
  toFiniteNumber: XG,
  findKey: _5,
  global: S5,
  isContextDefined: $5,
  ALPHABET: T5,
  generateString: eH,
  isSpecCompliantForm: tH,
  toJSONObject: rH,
  isAsyncFn: nH,
  isThenable: iH
};
function pt(e, t, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i);
}
X.inherits(pt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: X.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const E5 = pt.prototype, I5 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  I5[e] = { value: e };
});
Object.defineProperties(pt, I5);
Object.defineProperty(E5, "isAxiosError", { value: !0 });
pt.from = (e, t, r, n, i, s) => {
  const o = Object.create(E5);
  return X.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (a) => a !== "isAxiosError"), pt.call(o, e.message, t, r, n, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o;
};
const sH = null;
function y$(e) {
  return X.isPlainObject(e) || X.isArray(e);
}
function M5(e) {
  return X.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function rk(e, t, r) {
  return e ? e.concat(t).map(function(i, s) {
    return i = M5(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : t;
}
function oH(e) {
  return X.isArray(e) && !e.some(y$);
}
const aH = X.toFlatObject(X, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Vw(e, t, r) {
  if (!X.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = X.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, b) {
    return !X.isUndefined(b[v]);
  });
  const n = r.metaTokens, i = r.visitor || h, s = r.dots, o = r.indexes, l = (r.Blob || typeof Blob < "u" && Blob) && X.isSpecCompliantForm(t);
  if (!X.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(g) {
    if (g === null)
      return "";
    if (X.isDate(g))
      return g.toISOString();
    if (!l && X.isBlob(g))
      throw new pt("Blob is not supported. Use a Buffer instead.");
    return X.isArrayBuffer(g) || X.isTypedArray(g) ? l && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
  function h(g, v, b) {
    let w = g;
    if (g && !b && typeof g == "object") {
      if (X.endsWith(v, "{}"))
        v = n ? v : v.slice(0, -2), g = JSON.stringify(g);
      else if (X.isArray(g) && oH(g) || (X.isFileList(g) || X.endsWith(v, "[]")) && (w = X.toArray(g)))
        return v = M5(v), w.forEach(function($, T) {
          !(X.isUndefined($) || $ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? rk([v], T, s) : o === null ? v : v + "[]",
            c($)
          );
        }), !1;
    }
    return y$(g) ? !0 : (t.append(rk(b, v, s), c(g)), !1);
  }
  const f = [], m = Object.assign(aH, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: y$
  });
  function y(g, v) {
    if (!X.isUndefined(g)) {
      if (f.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      f.push(g), X.forEach(g, function(w, x) {
        (!(X.isUndefined(w) || w === null) && i.call(
          t,
          w,
          X.isString(x) ? x.trim() : x,
          v,
          m
        )) === !0 && y(w, v ? v.concat(x) : [x]);
      }), f.pop();
    }
  }
  if (!X.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function nk(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function O3(e, t) {
  this._pairs = [], e && Vw(e, this, t);
}
const O5 = O3.prototype;
O5.append = function(t, r) {
  this._pairs.push([t, r]);
};
O5.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, nk);
  } : nk;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function lH(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function C5(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || lH, i = r && r.serialize;
  let s;
  if (i ? s = i(t, r) : s = X.isURLSearchParams(t) ? t.toString() : new O3(t, r).toString(n), s) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class uH {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    X.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const ik = uH, k5 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, cH = typeof URLSearchParams < "u" ? URLSearchParams : O3, dH = typeof FormData < "u" ? FormData : null, pH = typeof Blob < "u" ? Blob : null, hH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: cH,
    FormData: dH,
    Blob: pH
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, A5 = typeof window < "u" && typeof document < "u", fH = ((e) => A5 && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), mH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", yH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: A5,
  hasStandardBrowserEnv: fH,
  hasStandardBrowserWebWorkerEnv: mH
}, Symbol.toStringTag, { value: "Module" })), Jo = {
  ...yH,
  ...hH
};
function gH(e, t) {
  return Vw(e, new Jo.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return Jo.isNode && X.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function vH(e) {
  return X.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function bH(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], t[s] = e[s];
  return t;
}
function P5(e) {
  function t(r, n, i, s) {
    let o = r[s++];
    const a = Number.isFinite(+o), l = s >= r.length;
    return o = !o && X.isArray(i) ? i.length : o, l ? (X.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !X.isObject(i[o])) && (i[o] = []), t(r, n, i[o], s) && X.isArray(i[o]) && (i[o] = bH(i[o])), !a);
  }
  if (X.isFormData(e) && X.isFunction(e.entries)) {
    const r = {};
    return X.forEachEntry(e, (n, i) => {
      t(vH(n), i, r, 0);
    }), r;
  }
  return null;
}
function wH(e, t, r) {
  if (X.isString(e))
    try {
      return (t || JSON.parse)(e), X.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
const C3 = {
  transitional: k5,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = X.isObject(t);
    if (s && X.isHTMLForm(t) && (t = new FormData(t)), X.isFormData(t))
      return i && i ? JSON.stringify(P5(t)) : t;
    if (X.isArrayBuffer(t) || X.isBuffer(t) || X.isStream(t) || X.isFile(t) || X.isBlob(t))
      return t;
    if (X.isArrayBufferView(t))
      return t.buffer;
    if (X.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return gH(t, this.formSerializer).toString();
      if ((a = X.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Vw(
          a ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), wH(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || C3.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (t && X.isString(t) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? pt.from(a, pt.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Jo.classes.FormData,
    Blob: Jo.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
X.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  C3.headers[e] = {};
});
const k3 = C3, _H = X.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), SH = (e) => {
  const t = {};
  let r, n, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || t[r] && _H[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, sk = Symbol("internals");
function Lf(e) {
  return e && String(e).trim().toLowerCase();
}
function Rv(e) {
  return e === !1 || e == null ? e : X.isArray(e) ? e.map(Rv) : String(e);
}
function $H(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const xH = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function S2(e, t, r, n, i) {
  if (X.isFunction(n))
    return n.call(this, t, r);
  if (i && (t = r), !!X.isString(t)) {
    if (X.isString(n))
      return t.indexOf(n) !== -1;
    if (X.isRegExp(n))
      return n.test(t);
  }
}
function TH(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function EH(e, t) {
  const r = X.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, t, i, s, o);
      },
      configurable: !0
    });
  });
}
class zw {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const i = this;
    function s(a, l, c) {
      const h = Lf(l);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const f = X.findKey(i, h);
      (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = Rv(a));
    }
    const o = (a, l) => X.forEach(a, (c, h) => s(c, h, l));
    return X.isPlainObject(t) || t instanceof this.constructor ? o(t, r) : X.isString(t) && (t = t.trim()) && !xH(t) ? o(SH(t), r) : t != null && s(r, t, n), this;
  }
  get(t, r) {
    if (t = Lf(t), t) {
      const n = X.findKey(this, t);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return $H(i);
        if (X.isFunction(r))
          return r.call(this, i, n);
        if (X.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = Lf(t), t) {
      const n = X.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || S2(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Lf(o), o) {
        const a = X.findKey(n, o);
        a && (!r || S2(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return X.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!t || S2(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const r = this, n = {};
    return X.forEach(this, (i, s) => {
      const o = X.findKey(n, s);
      if (o) {
        r[o] = Rv(i), delete r[s];
        return;
      }
      const a = t ? TH(s) : String(s).trim();
      a !== s && delete r[s], r[a] = Rv(i), n[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return X.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = t && X.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(t) {
    const n = (this[sk] = this[sk] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Lf(o);
      n[a] || (EH(i, o), n[a] = !0);
    }
    return X.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
zw.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
X.reduceDescriptors(zw.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
X.freezeMethods(zw);
const Ya = zw;
function $2(e, t) {
  const r = this || k3, n = t || r, i = Ya.from(n.headers);
  let s = n.data;
  return X.forEach(e, function(a) {
    s = a.call(r, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function R5(e) {
  return !!(e && e.__CANCEL__);
}
function Cg(e, t, r) {
  pt.call(this, e ?? "canceled", pt.ERR_CANCELED, t, r), this.name = "CanceledError";
}
X.inherits(Cg, pt, {
  __CANCEL__: !0
});
function IH(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new pt(
    "Request failed with status code " + r.status,
    [pt.ERR_BAD_REQUEST, pt.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
const MH = Jo.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, i, s) {
      const o = [e + "=" + encodeURIComponent(t)];
      X.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), X.isString(n) && o.push("path=" + n), X.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function OH(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function CH(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function L5(e, t) {
  return e && !OH(t) ? CH(e, t) : t;
}
const kH = Jo.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let n;
    function i(s) {
      let o = s;
      return t && (r.setAttribute("href", o), o = r.href), r.setAttribute("href", o), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = i(window.location.href), function(o) {
      const a = X.isString(o) ? i(o) : o;
      return a.protocol === n.protocol && a.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function AH(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function PH(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let i = 0, s = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), h = n[s];
    o || (o = c), r[i] = l, n[i] = c;
    let f = s, m = 0;
    for (; f !== i; )
      m += r[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), c - o < t)
      return;
    const y = h && c - h;
    return y ? Math.round(m * 1e3 / y) : void 0;
  };
}
function ok(e, t) {
  let r = 0;
  const n = PH(50, 250);
  return (i) => {
    const s = i.loaded, o = i.lengthComputable ? i.total : void 0, a = s - r, l = n(a), c = s <= o;
    r = s;
    const h = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: l || void 0,
      estimated: l && o && c ? (o - s) / l : void 0,
      event: i
    };
    h[t ? "download" : "upload"] = !0, e(h);
  };
}
const RH = typeof XMLHttpRequest < "u", LH = RH && function(e) {
  return new Promise(function(r, n) {
    let i = e.data;
    const s = Ya.from(e.headers).normalize();
    let { responseType: o, withXSRFToken: a } = e, l;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(l), e.signal && e.signal.removeEventListener("abort", l);
    }
    let h;
    if (X.isFormData(i)) {
      if (Jo.hasStandardBrowserEnv || Jo.hasStandardBrowserWebWorkerEnv)
        s.setContentType(!1);
      else if ((h = s.getContentType()) !== !1) {
        const [v, ...b] = h ? h.split(";").map((w) => w.trim()).filter(Boolean) : [];
        s.setContentType([v || "multipart/form-data", ...b].join("; "));
      }
    }
    let f = new XMLHttpRequest();
    if (e.auth) {
      const v = e.auth.username || "", b = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      s.set("Authorization", "Basic " + btoa(v + ":" + b));
    }
    const m = L5(e.baseURL, e.url);
    f.open(e.method.toUpperCase(), C5(m, e.params, e.paramsSerializer), !0), f.timeout = e.timeout;
    function y() {
      if (!f)
        return;
      const v = Ya.from(
        "getAllResponseHeaders" in f && f.getAllResponseHeaders()
      ), w = {
        data: !o || o === "text" || o === "json" ? f.responseText : f.response,
        status: f.status,
        statusText: f.statusText,
        headers: v,
        config: e,
        request: f
      };
      IH(function($) {
        r($), c();
      }, function($) {
        n($), c();
      }, w), f = null;
    }
    if ("onloadend" in f ? f.onloadend = y : f.onreadystatechange = function() {
      !f || f.readyState !== 4 || f.status === 0 && !(f.responseURL && f.responseURL.indexOf("file:") === 0) || setTimeout(y);
    }, f.onabort = function() {
      f && (n(new pt("Request aborted", pt.ECONNABORTED, e, f)), f = null);
    }, f.onerror = function() {
      n(new pt("Network Error", pt.ERR_NETWORK, e, f)), f = null;
    }, f.ontimeout = function() {
      let b = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const w = e.transitional || k5;
      e.timeoutErrorMessage && (b = e.timeoutErrorMessage), n(new pt(
        b,
        w.clarifyTimeoutError ? pt.ETIMEDOUT : pt.ECONNABORTED,
        e,
        f
      )), f = null;
    }, Jo.hasStandardBrowserEnv && (a && X.isFunction(a) && (a = a(e)), a || a !== !1 && kH(m))) {
      const v = e.xsrfHeaderName && e.xsrfCookieName && MH.read(e.xsrfCookieName);
      v && s.set(e.xsrfHeaderName, v);
    }
    i === void 0 && s.setContentType(null), "setRequestHeader" in f && X.forEach(s.toJSON(), function(b, w) {
      f.setRequestHeader(w, b);
    }), X.isUndefined(e.withCredentials) || (f.withCredentials = !!e.withCredentials), o && o !== "json" && (f.responseType = e.responseType), typeof e.onDownloadProgress == "function" && f.addEventListener("progress", ok(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && f.upload && f.upload.addEventListener("progress", ok(e.onUploadProgress)), (e.cancelToken || e.signal) && (l = (v) => {
      f && (n(!v || v.type ? new Cg(null, e, f) : v), f.abort(), f = null);
    }, e.cancelToken && e.cancelToken.subscribe(l), e.signal && (e.signal.aborted ? l() : e.signal.addEventListener("abort", l)));
    const g = AH(m);
    if (g && Jo.protocols.indexOf(g) === -1) {
      n(new pt("Unsupported protocol " + g + ":", pt.ERR_BAD_REQUEST, e));
      return;
    }
    f.send(i || null);
  });
}, g$ = {
  http: sH,
  xhr: LH
};
X.forEach(g$, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const ak = (e) => `- ${e}`, NH = (e) => X.isFunction(e) || e === null || e === !1, N5 = {
  getAdapter: (e) => {
    e = X.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const i = {};
    for (let s = 0; s < t; s++) {
      r = e[s];
      let o;
      if (n = r, !NH(r) && (n = g$[(o = String(r)).toLowerCase()], n === void 0))
        throw new pt(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? s.length > 1 ? `since :
` + s.map(ak).join(`
`) : " " + ak(s[0]) : "as no adapter specified";
      throw new pt(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: g$
};
function x2(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Cg(null, e);
}
function lk(e) {
  return x2(e), e.headers = Ya.from(e.headers), e.data = $2.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), N5.getAdapter(e.adapter || k3.adapter)(e).then(function(n) {
    return x2(e), n.data = $2.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Ya.from(n.headers), n;
  }, function(n) {
    return R5(n) || (x2(e), n && n.response && (n.response.data = $2.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Ya.from(n.response.headers))), Promise.reject(n);
  });
}
const uk = (e) => e instanceof Ya ? e.toJSON() : e;
function Ch(e, t) {
  t = t || {};
  const r = {};
  function n(c, h, f) {
    return X.isPlainObject(c) && X.isPlainObject(h) ? X.merge.call({ caseless: f }, c, h) : X.isPlainObject(h) ? X.merge({}, h) : X.isArray(h) ? h.slice() : h;
  }
  function i(c, h, f) {
    if (X.isUndefined(h)) {
      if (!X.isUndefined(c))
        return n(void 0, c, f);
    } else
      return n(c, h, f);
  }
  function s(c, h) {
    if (!X.isUndefined(h))
      return n(void 0, h);
  }
  function o(c, h) {
    if (X.isUndefined(h)) {
      if (!X.isUndefined(c))
        return n(void 0, c);
    } else
      return n(void 0, h);
  }
  function a(c, h, f) {
    if (f in t)
      return n(c, h);
    if (f in e)
      return n(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, h) => i(uk(c), uk(h), !0)
  };
  return X.forEach(Object.keys(Object.assign({}, e, t)), function(h) {
    const f = l[h] || i, m = f(e[h], t[h], h);
    X.isUndefined(m) && f !== a || (r[h] = m);
  }), r;
}
const F5 = "1.6.2", A3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  A3[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const ck = {};
A3.transitional = function(t, r, n) {
  function i(s, o) {
    return "[Axios v" + F5 + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (t === !1)
      throw new pt(
        i(o, " has been removed" + (r ? " in " + r : "")),
        pt.ERR_DEPRECATED
      );
    return r && !ck[o] && (ck[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(s, o, a) : !0;
  };
};
function FH(e, t, r) {
  if (typeof e != "object")
    throw new pt("options must be an object", pt.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = t[s];
    if (o) {
      const a = e[s], l = a === void 0 || o(a, s, e);
      if (l !== !0)
        throw new pt("option " + s + " must be " + l, pt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new pt("Unknown option " + s, pt.ERR_BAD_OPTION);
  }
}
const v$ = {
  assertOptions: FH,
  validators: A3
}, vl = v$.validators;
class sb {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new ik(),
      response: new ik()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = Ch(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && v$.assertOptions(n, {
      silentJSONParsing: vl.transitional(vl.boolean),
      forcedJSONParsing: vl.transitional(vl.boolean),
      clarifyTimeoutError: vl.transitional(vl.boolean)
    }, !1), i != null && (X.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : v$.assertOptions(i, {
      encode: vl.function,
      serialize: vl.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && X.merge(
      s.common,
      s[r.method]
    );
    s && X.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete s[g];
      }
    ), r.headers = Ya.concat(o, s);
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(r) === !1 || (l = l && v.synchronous, a.unshift(v.fulfilled, v.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(v) {
      c.push(v.fulfilled, v.rejected);
    });
    let h, f = 0, m;
    if (!l) {
      const g = [lk.bind(this), void 0];
      for (g.unshift.apply(g, a), g.push.apply(g, c), m = g.length, h = Promise.resolve(r); f < m; )
        h = h.then(g[f++], g[f++]);
      return h;
    }
    m = a.length;
    let y = r;
    for (f = 0; f < m; ) {
      const g = a[f++], v = a[f++];
      try {
        y = g(y);
      } catch (b) {
        v.call(this, b);
        break;
      }
    }
    try {
      h = lk.call(this, y);
    } catch (g) {
      return Promise.reject(g);
    }
    for (f = 0, m = c.length; f < m; )
      h = h.then(c[f++], c[f++]);
    return h;
  }
  getUri(t) {
    t = Ch(this.defaults, t);
    const r = L5(t.baseURL, t.url);
    return C5(r, t.params, t.paramsSerializer);
  }
}
X.forEach(["delete", "get", "head", "options"], function(t) {
  sb.prototype[t] = function(r, n) {
    return this.request(Ch(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
X.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(s, o, a) {
      return this.request(Ch(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  sb.prototype[t] = r(), sb.prototype[t + "Form"] = r(!0);
});
const Lv = sb;
class P3 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners)
        return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, t(function(s, o, a) {
      n.reason || (n.reason = new Cg(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new P3(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
const DH = P3;
function jH(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function VH(e) {
  return X.isObject(e) && e.isAxiosError === !0;
}
const b$ = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(b$).forEach(([e, t]) => {
  b$[t] = e;
});
const zH = b$;
function D5(e) {
  const t = new Lv(e), r = v5(Lv.prototype.request, t);
  return X.extend(r, Lv.prototype, t, { allOwnKeys: !0 }), X.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(i) {
    return D5(Ch(e, i));
  }, r;
}
const Ar = D5(k3);
Ar.Axios = Lv;
Ar.CanceledError = Cg;
Ar.CancelToken = DH;
Ar.isCancel = R5;
Ar.VERSION = F5;
Ar.toFormData = Vw;
Ar.AxiosError = pt;
Ar.Cancel = Ar.CanceledError;
Ar.all = function(t) {
  return Promise.all(t);
};
Ar.spread = jH;
Ar.isAxiosError = VH;
Ar.mergeConfig = Ch;
Ar.AxiosHeaders = Ya;
Ar.formToJSON = (e) => P5(X.isHTMLForm(e) ? new FormData(e) : e);
Ar.getAdapter = N5.getAdapter;
Ar.HttpStatusCode = zH;
Ar.default = Ar;
const R3 = Ar;
function u(e, t, r, n) {
  var i, s = arguments.length, o = s < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(e, t, r, n);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
  return s > 3 && o && Object.defineProperty(t, r, o), o;
}
function pAe(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(h) {
      try {
        c(n.next(h));
      } catch (f) {
        o(f);
      }
    }
    function l(h) {
      try {
        c(n.throw(h));
      } catch (f) {
        o(f);
      }
    }
    function c(h) {
      h.done ? s(h.value) : i(h.value).then(a, l);
    }
    c((n = n.apply(e, t || [])).next());
  });
}
function UH(e) {
  return e && e.release && typeof e.release == "function";
}
function BH(e) {
  return e && e.acquire && typeof e.acquire == "function";
}
let Jd = class w$ {
  constructor(t, r, n, i = 1, s = 0) {
    if (this._ctor = t, this._acquireFunction = r, this._releaseFunction = n, this.allocationSize = i, this._pool = new Array(s), this._initialSize = s, this._ctor)
      for (let o = 0; o < s; o++)
        this._pool[o] = new this._ctor();
    this.allocationSize = Math.max(i, 1);
  }
  destroy() {
    this.prune(0);
  }
  acquire(...t) {
    let r;
    if (w$.test.disabled)
      r = new this._ctor();
    else {
      if (this._pool.length === 0) {
        const n = this.allocationSize;
        for (let i = 0; i < n; i++)
          this._pool[i] = new this._ctor();
      }
      r = this._pool.pop();
    }
    return this._acquireFunction ? this._acquireFunction(r, ...t) : BH(r) && r.acquire(...t), r;
  }
  release(t) {
    t && !w$.test.disabled && (this._releaseFunction ? this._releaseFunction(t) : UH(t) && t.release(), this._pool.push(t));
  }
  prune(t = this._initialSize) {
    if (!(t >= this._pool.length)) {
      for (let r = t; r < this._pool.length; ++r) {
        const n = this._pool[r];
        this._dispose(n);
      }
      this._pool.length = t;
    }
  }
  _dispose(t) {
    t.dispose && typeof t.dispose == "function" && t.dispose();
  }
};
Jd.test = { disabled: !1 };
function qH(e) {
  e.length = 0;
}
let jn = class {
  constructor(t = 50, r = 50) {
    this._pool = new Jd(Array, void 0, qH, r, t);
  }
  acquire() {
    return this._pool.acquire();
  }
  release(t) {
    this._pool.release(t);
  }
  prune() {
    this._pool.prune(0);
  }
  static acquire() {
    return T2.acquire();
  }
  static release(t) {
    return T2.release(t);
  }
  static prune() {
    T2.prune();
  }
};
const T2 = new jn(100);
function fAe(e) {
  const t = [];
  return function* () {
    yield* t;
    for (const r of e)
      t.push(r), yield r;
  };
}
function GH(e, t) {
  for (const r of e)
    if (r != null && t(r))
      return r;
}
function ob(e) {
  return e != null && typeof e[Symbol.iterator] == "function";
}
function td(e, t) {
  return e != null ? t(e) : null;
}
function as(e, t) {
  return j5(e, t), e;
}
function j5(e, t) {
  if (e == null)
    throw new Error(t ?? "value is None");
}
function Vt(e) {
  return e == null || e.destroy(), null;
}
function mAe(e) {
  return e == null || e.dispose(), null;
}
function tr(e) {
  return e == null || e.remove(), null;
}
function zy(e) {
  return e == null || e.abort(), null;
}
function yAe(e) {
  return e == null || e.release(), null;
}
function HH(e, t, r) {
  return e != null && t != null ? r != null ? r(e, t) : e.equals(t) : e === t;
}
function WH(e) {
  return null;
}
function gAe(e, t) {
  const r = new Array();
  for (const n of e)
    r.push(n != null ? t(n) : null);
  return r;
}
function vAe(e, t) {
  for (const r of e)
    td(r, t);
}
function bAe(e) {
  return e;
}
let ca = class _$ {
  constructor() {
    this._groups = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.removeAll();
  }
  get size() {
    let t = 0;
    return this._groups.forEach((r) => {
      t += r.length;
    }), t;
  }
  add(t, r) {
    if (ob(t)) {
      const n = this._getOrCreateGroup(r);
      for (const i of t)
        this._isHandle(i) && n.push(i);
    } else
      this._isHandle(t) && this._getOrCreateGroup(r).push(t);
    return this;
  }
  forEach(t, r) {
    if (typeof t == "function")
      this._groups.forEach((n) => n.forEach(t));
    else {
      const n = this._getGroup(t);
      n && r && n.forEach(r);
    }
  }
  has(t) {
    return this._groups.has(this._ensureGroupKey(t));
  }
  remove(t) {
    if (typeof t != "string" && ob(t)) {
      for (const r of t)
        this.remove(r);
      return this;
    }
    return this.has(t) ? (this._removeAllFromGroup(this._getGroup(t)), this._groups.delete(this._ensureGroupKey(t)), this) : this;
  }
  removeAll() {
    return this._groups.forEach((t) => this._removeAllFromGroup(t)), this._groups.clear(), this;
  }
  _isHandle(t) {
    return t && (!!t.remove || t instanceof _$);
  }
  _getOrCreateGroup(t) {
    if (this.has(t))
      return this._getGroup(t);
    const r = [];
    return this._groups.set(this._ensureGroupKey(t), r), r;
  }
  _getGroup(t) {
    return this._groups.get(this._ensureGroupKey(t));
  }
  _ensureGroupKey(t) {
    return t || "_default_";
  }
  _removeAllFromGroup(t) {
    for (const r of t)
      r instanceof _$ ? r.removeAll() : r.remove();
  }
};
const V5 = Symbol("Accessor-beforeDestroy");
function Uw(e) {
  return nl(() => e.forEach((t) => t != null && t.remove()));
}
function nl(e) {
  return { remove: () => {
    e && (e(), e = void 0);
  } };
}
let E2 = class uc {
  constructor(t = 1) {
    this._seed = t;
  }
  set seed(t) {
    this._seed = t ?? Math.random() * uc._m;
  }
  getInt() {
    return this._seed = (uc._a * this._seed + uc._c) % uc._m, this._seed;
  }
  getFloat() {
    return this.getInt() / (uc._m - 1);
  }
  getIntRange(t, r) {
    return Math.round(this.getFloatRange(t, r));
  }
  getFloatRange(t, r) {
    const n = r - t;
    return t + this.getInt() / uc._m * n;
  }
};
E2._m = 2147483647, E2._a = 48271, E2._c = 0;
const wAe = 1.5;
function _Ae(e, t) {
  return t ? e.filter((r, n, i) => i.findIndex(t.bind(null, r)) === n) : e.filter((r, n, i) => i.indexOf(r) === n);
}
function Bw(e, t, r) {
  if (e == null && t == null)
    return !0;
  if (e == null || t == null || e.length !== t.length)
    return !1;
  if (r) {
    for (let n = 0; n < e.length; n++)
      if (!r(e[n], t[n]))
        return !1;
  } else
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n])
        return !1;
  return !0;
}
function SAe(e, t) {
  let r = e.length !== t.length;
  r && (e.length = t.length);
  for (let n = 0; n < t.length; ++n)
    e[n] !== t[n] && (e[n] = t[n], r = !0);
  return r;
}
function $Ae(e, t, r) {
  let n, i;
  return r ? (n = t.filter((s) => !e.some((o) => r(o, s))), i = e.filter((s) => !t.some((o) => r(o, s)))) : (n = t.filter((s) => !e.includes(s)), i = e.filter((s) => !t.includes(s))), { added: n, removed: i };
}
function xAe(e) {
  return e && typeof e.length == "number";
}
const JH = !!Array.prototype.fill;
function TAe(e, t) {
  if (JH)
    return new Array(e).fill(t);
  const r = new Array(e);
  for (let n = 0; n < e; n++)
    r[n] = t;
  return r;
}
function EAe(e, t) {
  t === void 0 && (t = e, e = 0);
  const r = new Array(t - e);
  for (let n = e; n < t; n++)
    r[n - e] = n;
  return r;
}
let z5 = class {
  constructor() {
    this.last = 0;
  }
};
const U5 = new z5();
function S$(e, t, r, n) {
  n = n || U5;
  const i = Math.max(0, n.last - 10);
  for (let o = i; o < r; ++o)
    if (e[o] === t)
      return n.last = o, o;
  const s = Math.min(i, r);
  for (let o = 0; o < s; ++o)
    if (e[o] === t)
      return n.last = o, o;
  return -1;
}
function ZH(e, t, r, n) {
  const i = r ?? e.length, s = S$(e, t, i, n);
  if (s !== -1)
    return e[s] = e[i - 1], r == null && e.pop(), t;
}
const Ms = /* @__PURE__ */ new Set();
function KH(e, t, r = e.length, n = t.length, i, s) {
  if (n === 0 || r === 0)
    return r;
  Ms.clear();
  for (let a = 0; a < n; ++a)
    Ms.add(t[a]);
  i = i || U5;
  const o = Math.max(0, i.last - 10);
  for (let a = o; a < r; ++a)
    if (Ms.has(e[a]) && (s && s.push(e[a]), Ms.delete(e[a]), e[a] = e[r - 1], --r, --a, Ms.size === 0 || r === 0))
      return Ms.clear(), r;
  for (let a = 0; a < o; ++a)
    if (Ms.has(e[a]) && (s && s.push(e[a]), Ms.delete(e[a]), e[a] = e[r - 1], --r, --a, Ms.size === 0 || r === 0))
      return Ms.clear(), r;
  return Ms.clear(), r;
}
function YH(e, t) {
  const r = e.indexOf(t);
  return r !== -1 ? (e.splice(r, 1), t) : null;
}
function kh(e, t) {
  return e != null;
}
let vu;
function U(e) {
  return typeof vu[e] == "function" ? vu[e] = vu[e](globalThis) : vu[e];
}
var r5, n5, i5, s5;
vu = (r5 = globalThis.dojoConfig) != null && r5.has || (n5 = globalThis.geosceneConfig) != null && n5.has ? { ...(i5 = globalThis.dojoConfig) == null ? void 0 : i5.has, ...(s5 = globalThis.geosceneConfig) == null ? void 0 : s5.has } : {}, U.add = (e, t, r, n) => ((n || vu[e] === void 0) && (vu[e] = t), r && U(e)), U.cache = vu, U.add("geoscene-deprecation-warnings", !0), U.add("geoscene-force-fullscreen-debug", !1), (() => {
  var t;
  U.add("host-webworker", globalThis.WorkerGlobalScope !== void 0 && self instanceof globalThis.WorkerGlobalScope);
  const e = typeof window < "u" && typeof location < "u" && typeof document < "u" && window.location === location && window.document === document;
  if (U.add("host-browser", e), U.add("host-node", typeof globalThis.process == "object" && ((t = globalThis.process.versions) == null ? void 0 : t.node) && globalThis.process.versions.v8), U.add("dom", e), U("host-browser")) {
    const r = navigator, n = r.userAgent, i = r.appVersion, s = parseFloat(i);
    if (U.add("wp", parseFloat(n.split("Windows Phone")[1]) || void 0), U.add("msapp", parseFloat(n.split("MSAppHost/")[1]) || void 0), U.add("khtml", i.includes("Konqueror") ? s : void 0), U.add("edge", parseFloat(n.split("Edge/")[1]) || void 0), U.add("opr", parseFloat(n.split("OPR/")[1]) || void 0), U.add("webkit", !U("wp") && !U("edge") && parseFloat(n.split("WebKit/")[1]) || void 0), U.add("chrome", !U("edge") && !U("opr") && parseFloat(n.split("Chrome/")[1]) || void 0), U.add("android", !U("wp") && parseFloat(n.split("Android ")[1]) || void 0), U.add("safari", !i.includes("Safari") || U("wp") || U("chrome") || U("android") || U("edge") || U("opr") ? void 0 : parseFloat(i.split("Version/")[1])), U.add("mac", i.includes("Macintosh")), !U("wp") && /(iPhone|iPod|iPad)/.test(n)) {
      const o = RegExp.$1.replace(/P/, "p"), a = /OS ([\d_]+)/.test(n) ? RegExp.$1 : "1", l = parseFloat(a.replace(/_/, ".").replaceAll("_", ""));
      U.add(o, l), U.add("ios", l);
    }
    U("webkit") || (!n.includes("Gecko") || U("wp") || U("khtml") || U("edge") || U.add("mozilla", s), U("mozilla") && U.add("ff", parseFloat(n.split("Firefox/")[1] || n.split("Minefield/")[1]) || void 0));
  }
})(), (() => {
  if (globalThis.navigator) {
    const e = navigator.userAgent, t = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i.test(e), r = /iPhone/i.test(e);
    t && U.add("geoscene-mobile", t), r && U.add("geoscene-iPhone", r), U.add("geoscene-geolocation", !!navigator.geolocation);
  }
  U.add("geoscene-wasm", "WebAssembly" in globalThis), U.add("geoscene-shared-array-buffer", () => {
    const e = "SharedArrayBuffer" in globalThis, t = globalThis.crossOriginIsolated === !1;
    return e && !t;
  }), U.add("wasm-simd", () => {
    const e = [0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11];
    return WebAssembly.validate(new Uint8Array(e));
  }), U.add("geoscene-atomics", "Atomics" in globalThis), U.add("geoscene-workers", "Worker" in globalThis), U.add("web-feat:cache", "caches" in globalThis), U.add("geoscene-workers-arraybuffer-transfer", !U("safari") || Number(U("safari")) >= 12), U.add("workers-pool-size", 8), U.add("featurelayer-simplify-thresholds", [0.5, 0.5, 0.5, 0.5]), U.add("featurelayer-simplify-payload-size-factors", [1, 1, 4]), U.add("featurelayer-animation-enabled", !0), U.add("featurelayer-snapshot-enabled", !0), U.add("featurelayer-snapshot-point-min-threshold", 8e4), U.add("featurelayer-snapshot-point-max-threshold", 4e5), U.add("featurelayer-snapshot-point-coverage", 0.1), U.add("featurelayer-advanced-symbols", !1), U.add("featurelayer-pbf", !0), U.add("featurelayer-pbf-statistics", !1), U.add("feature-layers-workers", !0), U.add("feature-polyline-generalization-factor", 1), U.add("mapview-transitions-duration", 200), U.add("mapview-srswitch-adjust-rotation-scale-threshold", 24e6), U.add("mapserver-pbf-version-support", 10.81), U.add("mapservice-popup-identify-max-tolerance", 20), U.add("heatmap-allow-raster-fallback", !1), U.add("heatmap-force-raster", !1), U("host-webworker") || U("host-browser") && (U.add("geoscene-csp-restrictions", () => {
    try {
      new Function();
    } catch {
      return !0;
    }
    return !1;
  }), U.add("geoscene-image-decode", () => {
    if ("decode" in new Image()) {
      const e = new Image();
      return e.src = 'data:image/svg+xml;charset=UTF-8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>', void e.decode().then(() => {
        U.add("geoscene-image-decode", !0, !0, !0);
      }).catch(() => {
        U.add("geoscene-image-decode", !1, !0, !0);
      });
    }
    return !1;
  }), U.add("geoscene-url-encodes-apostrophe", () => {
    const e = window.document.createElement("a");
    return e.href = "?'", e.href.includes("?%27");
  }));
})();
function MAe(e) {
  return e instanceof ArrayBuffer;
}
function L3(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Int8Array";
}
function B5(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Uint8Array";
}
function q5(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Uint8ClampedArray";
}
function N3(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Int16Array";
}
function G5(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Uint16Array";
}
function F3(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Int32Array";
}
function H5(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Uint32Array";
}
function qw(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Float32Array";
}
function Gw(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "Float64Array";
}
function QH(e) {
  return !("buffer" in e);
}
function OAe(e) {
  return e != null ? QH(e) ? 8 * e.length + 12 : e.byteLength + XH : 0;
}
const XH = 145, CAe = 1024;
function kAe(e) {
  return Gw(e) || qw(e) || F3(e) || N3(e) || L3(e);
}
function AAe(e) {
  return Gw(e) || qw(e);
}
function PAe(e) {
  return Gw(e) ? 179769e303 : qw(e) ? 3402823e32 : H5(e) ? 4294967295 : G5(e) ? 65535 : B5(e) || q5(e) ? 255 : F3(e) ? 2147483647 : N3(e) ? 32767 : L3(e) ? 127 : 256;
}
function W5(e, t) {
  let r;
  if (t)
    for (r in e)
      e.hasOwnProperty(r) && (e[r] === void 0 ? delete e[r] : e[r] instanceof Object && W5(e[r], !0));
  else
    for (r in e)
      e.hasOwnProperty(r) && e[r] === void 0 && delete e[r];
  return e;
}
function j(e) {
  if (!e || typeof e != "object" || typeof e == "function")
    return e;
  const t = K5(e);
  if (t != null)
    return t;
  if (ab(e))
    return e.clone();
  if (J5(e))
    return e.map(j);
  if (Z5(e))
    return e.clone();
  const r = {};
  for (const n of Object.getOwnPropertyNames(e))
    r[n] = j(e[n]);
  return r;
}
function $$(e) {
  if (!e || typeof e != "object" || typeof e == "function" || "HTMLElement" in globalThis && e instanceof HTMLElement)
    return e;
  const t = K5(e);
  if (t != null)
    return t;
  if (J5(e)) {
    let r = !0;
    const n = e.map((i) => {
      const s = $$(i);
      return i != null && s == null && (r = !1), s;
    });
    return r ? n : null;
  }
  if (ab(e))
    return e.clone();
  if (e instanceof File || e instanceof Blob)
    return e;
  if (!Z5(e)) {
    const r = new (Object.getPrototypeOf(e)).constructor();
    for (const n of Object.getOwnPropertyNames(e)) {
      const i = e[n], s = $$(i);
      if (i != null && s == null)
        return null;
      r[n] = s;
    }
    return r;
  }
  return null;
}
function ab(e) {
  return typeof e.clone == "function";
}
function J5(e) {
  return typeof e.map == "function" && typeof e.forEach == "function";
}
function Z5(e) {
  return typeof e.notifyChange == "function" && typeof e.watch == "function";
}
function dk(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function K5(e) {
  if (L3(e) || B5(e) || q5(e) || N3(e) || G5(e) || F3(e) || H5(e) || qw(e) || Gw(e))
    return e.slice();
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof ArrayBuffer)
    return e.slice(0, e.byteLength);
  if (e instanceof Map) {
    const t = /* @__PURE__ */ new Map();
    for (const [r, n] of e)
      t.set(r, j(n));
    return t;
  }
  if (e instanceof Set) {
    const t = /* @__PURE__ */ new Set();
    for (const r of e)
      t.add(j(r));
    return t;
  }
  return null;
}
function D3(e, t) {
  return e === t || typeof e == "number" && isNaN(e) && typeof t == "number" && isNaN(t) || typeof (e || {}).getTime == "function" && typeof (t || {}).getTime == "function" && e.getTime() === t.getTime() || !1;
}
function Y5(e, t) {
  return e === t || (e == null || typeof e == "string" ? e === t : typeof e == "number" ? e === t || typeof t == "number" && isNaN(e) && isNaN(t) : e instanceof Date ? t instanceof Date && e.getTime() === t.getTime() : Array.isArray(e) ? Array.isArray(t) && Bw(e, t) : e instanceof Set ? t instanceof Set && tW(e, t) : e instanceof Map ? t instanceof Map && rW(e, t) : !!dk(e) && dk(t) && eW(e, t));
}
function eW(e, t) {
  if (e === null || t === null)
    return !1;
  const r = Object.keys(e);
  if (t === null || Object.keys(t).length !== r.length)
    return !1;
  for (const n of r)
    if (e[n] !== t[n] || !Object.prototype.hasOwnProperty.call(t, n))
      return !1;
  return !0;
}
function tW(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const r of e)
    if (!t.has(r))
      return !1;
  return !0;
}
function rW(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const [r, n] of e) {
    const i = t.get(r);
    if (i !== n || i === void 0 && !t.has(r))
      return !1;
  }
  return !0;
}
function Bn(e) {
  return e.__accessor__ ?? null;
}
function nW(e, t) {
  return e != null && e.metadatas && e.metadatas[t] != null;
}
function Nv(e, t, r) {
  return r ? lb(e, t, { policy: r, path: "" }) : lb(e, t, null);
}
function lb(e, t, r) {
  return t ? Object.keys(t).reduce((n, i) => {
    const s = i;
    let o = null, a = "merge";
    if (r && (o = r.path ? `${r.path}.${i}` : i, a = r.policy(o)), a === "replace" || a === "replace-arrays" && Array.isArray(n[s]))
      return n[s] = t[s], n;
    if (n[s] === void 0)
      return n[s] = j(t[s]), n;
    let l = n[s], c = t[s];
    if (l === c)
      return n;
    if (Array.isArray(c) || Array.isArray(n))
      l = l ? Array.isArray(l) ? n[s] = l.concat() : n[s] = [l] : n[s] = [], c && (Array.isArray(c) || (c = [c]), c.forEach((h) => {
        l.includes(h) || l.push(h);
      }));
    else if (c && typeof c == "object")
      if (r) {
        const h = r.path;
        r.path = o, n[s] = lb(l, c, r), r.path = h;
      } else
        n[s] = lb(l, c, null);
    else
      n.hasOwnProperty(i) && !t.hasOwnProperty(i) || (n[s] = c);
    return n;
  }, e || {}) : e;
}
function Q5(e) {
  return Array.isArray(e) ? e : e.split(".");
}
function pk(e) {
  return e.includes(",") ? e.split(",").map((t) => t.trim()) : [e.trim()];
}
function iW(e) {
  if (Array.isArray(e)) {
    const t = [];
    for (const r of e)
      t.push(...pk(r));
    return t;
  }
  return pk(e);
}
function X5(e, t, r, n) {
  const i = iW(t);
  if (i.length !== 1) {
    const s = i.map((o) => n(e, o, r));
    return Uw(s);
  }
  return n(e, i[0], r);
}
function eF(e) {
  let t = !1;
  return () => {
    t || (t = !0, e());
  };
}
function tF(e, t) {
  const r = e[e.length - 1] === "?" ? e.slice(0, -1) : e;
  if (t.getItemAt != null || Array.isArray(t)) {
    const i = parseInt(r, 10);
    if (!isNaN(i))
      return Array.isArray(t) ? t[i] : t.at(i);
  }
  const n = Bn(t);
  return nW(n, r) ? n.get(r) : t[r];
}
function rF(e, t, r) {
  if (e == null)
    return e;
  const n = tF(t[r], e);
  return !n && r < t.length - 1 ? void 0 : r === t.length - 1 ? n : rF(n, t, r + 1);
}
function kg(e, t, r = 0) {
  return typeof t != "string" || t.includes(".") ? rF(e, Q5(t), r) : tF(t, e);
}
function ub(e, t) {
  return kg(e, t);
}
function hk(e, t) {
  return kg(t, e) !== void 0;
}
function Ag(e) {
  let t = e.constructor.__accessorMetadata__;
  const r = Object.prototype.hasOwnProperty.call(e.constructor, "__accessorMetadata__");
  if (t) {
    if (!r) {
      t = Object.create(t);
      for (const n in t)
        t[n] = j(t[n]);
      Object.defineProperty(e.constructor, "__accessorMetadata__", { value: t, enumerable: !1, configurable: !0, writable: !0 });
    }
  } else
    t = {}, Object.defineProperty(e.constructor, "__accessorMetadata__", { value: t, enumerable: !1, configurable: !0, writable: !0 });
  return e.constructor.__accessorMetadata__;
}
function Hw(e, t) {
  const r = Ag(e);
  let n = r[t];
  return n || (n = r[t] = {}), n;
}
function sW(e, t) {
  return Nv(e, t, aW);
}
const oW = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/;
function aW(e) {
  return oW.test(e) ? "replace" : "merge";
}
function nF(e, t, r = !1) {
  return sF(e, t, r);
}
function Pg(e, t) {
  if (t != null)
    return t[e] || iF(e.split("."), !1, t);
}
function In(e, t, r) {
  const n = e.split("."), i = n.pop(), s = iF(n, !0, r);
  s && i && (s[i] = t);
}
function iF(e, t, r) {
  let n = r;
  for (const i of e) {
    if (n == null)
      return;
    if (!(i in n)) {
      if (!t)
        return;
      n[i] = {};
    }
    n = n[i];
  }
  return n;
}
function sF(e, t, r) {
  return t ? Object.keys(t).reduce((n, i) => {
    let s = n[i], o = t[i];
    return s === o ? n : s === void 0 ? (n[i] = j(o), n) : (Array.isArray(o) || Array.isArray(n) ? (s = s ? Array.isArray(s) ? n[i] = s.concat() : n[i] = [s] : n[i] = [], o && (Array.isArray(o) || (o = [o]), r ? o.forEach((a) => {
      s.includes(a) || s.push(a);
    }) : n[i] = o.concat())) : o && typeof o == "object" ? n[i] = sF(s, o, r) : n.hasOwnProperty(i) && !t.hasOwnProperty(i) || (n[i] = o), n);
  }, e || {}) : e;
}
var o5;
const bt = { analysisTheme: { accentColor: [255, 127, 0], textColor: "white" }, apiKey: void 0, applicationName: "", applicationUrl: (o5 = globalThis.location) == null ? void 0 : o5.href, assetsPath: "", fontsUrl: "https://doc.geoscene.cn/resources/fonts", geometryServiceUrl: "https://www.geosceneonline.cn/server/rest/services/Utilities/Geometry/GeometryServer", geoRSSServiceUrl: "https://www.geosceneonline.cn/geoscene/sharing/rss", kmlServiceUrl: "https://www.geosceneonline.cn/geoscene/sharing/kml", userPrivilegesApplied: !1, portalUrl: "https://www.geosceneonline.cn/geoscene", routeServiceUrl: "undefined", workers: { loaderConfig: { has: {}, paths: {}, map: {}, packages: [] } }, request: { crossOriginNoCorsDomains: null, httpsDomains: ["arcgis.com", "geosceneonline.cn", "arcgisonline.com", "esrikr.com", "premiumservices.blackbridge.com", "esripremium.accuweather.com", "gbm.digitalglobe.com", "firstlook.digitalglobe.com", "msi.digitalglobe.com"], interceptors: [], maxUrlLength: 2e3, priority: "high", proxyRules: [], proxyUrl: null, timeout: 6e4, trustedServers: [], useIdentity: !0 }, log: { interceptors: [], level: null } };
if (globalThis.geosceneConfig && (nF(bt, globalThis.geosceneConfig, !0), delete bt.has), !bt.assetsPath) {
  {
    const e = "4.27";
    bt.assetsPath = `https://js.geoscene.cn/${e}/@geoscene/core/assets`;
  }
  bt.defaultAssetsPath = bt.assetsPath;
}
const lW = /\{([^\}]+)\}/g;
function fk(e) {
  return e ?? "";
}
function Ww(e, t) {
  return e.replaceAll(lW, typeof t == "object" ? (r, n) => fk(Pg(n, t)) : (r, n) => fk(t(n)));
}
function RAe(e, t) {
  return e.replaceAll(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, (r) => t && t.includes(r) ? r : `\\${r}`);
}
function j3(e) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t = (t << 5) - t + e.charCodeAt(r), t |= 0;
  return t;
}
function LAe(e) {
  return new DOMParser().parseFromString(e || "", "text/html").body.innerText || "";
}
function NAe(e, t) {
  return new RegExp(`{${t}}`, "ig").test(e);
}
const mk = { info: 0, warn: 1, error: 2, none: 3 };
let se = class gn {
  constructor(t) {
    this.level = null, this._module = "", this._parent = null, this.writer = null, this._loggedMessages = { error: /* @__PURE__ */ new Map(), warn: /* @__PURE__ */ new Map(), info: /* @__PURE__ */ new Map() }, t.level != null && (this.level = t.level), t.writer != null && (this.writer = t.writer), this._module = t.module, gn._loggers.set(this.module, this);
    const r = this.module.lastIndexOf(".");
    r !== -1 && (this._parent = gn.getLogger(this.module.slice(0, r)));
  }
  get module() {
    return this._module;
  }
  get parent() {
    return this._parent;
  }
  error(...t) {
    this._log("error", "always", ...t);
  }
  warn(...t) {
    this._log("warn", "always", ...t);
  }
  info(...t) {
    this._log("info", "always", ...t);
  }
  errorOnce(...t) {
    this._log("error", "once", ...t);
  }
  warnOnce(...t) {
    this._log("warn", "once", ...t);
  }
  infoOnce(...t) {
    this._log("info", "once", ...t);
  }
  errorOncePerTick(...t) {
    this._log("error", "oncePerTick", ...t);
  }
  warnOncePerTick(...t) {
    this._log("warn", "oncePerTick", ...t);
  }
  infoOncePerTick(...t) {
    this._log("info", "oncePerTick", ...t);
  }
  get test() {
    const t = this;
    return { loggedMessages: t._loggedMessages, clearLoggedWarnings: () => t._loggedMessages.warn.clear() };
  }
  static get test() {
    return { resetLoggers(t = /* @__PURE__ */ new Map()) {
      const r = gn._loggers;
      return gn._loggers = t, r;
    }, set throttlingDisabled(t) {
      gn._throttlingDisabled = t;
    } };
  }
  static getLogger(t) {
    return t = typeof t != "string" ? t.declaredClass : t, gn._loggers.get(t) || new gn({ module: t });
  }
  _log(t, r, ...n) {
    if (this._matchLevel(t)) {
      if (r !== "always" && !gn._throttlingDisabled) {
        const i = this._argsToKey(n), s = this._loggedMessages[t].get(i);
        if (r === "once" && s != null || r === "oncePerTick" && s && s >= gn._tickCounter)
          return;
        this._loggedMessages[t].set(i, gn._tickCounter), gn._scheduleTickCounterIncrement();
      }
      for (const i of bt.log.interceptors)
        if (i(t, this.module, ...n))
          return;
      this._inheritedWriter()(t, this.module, ...n);
    }
  }
  _parentWithMember(t, r) {
    let n = this;
    for (; n != null; ) {
      const i = n[t];
      if (i != null)
        return i;
      n = n.parent;
    }
    return r;
  }
  _inheritedWriter() {
    return this._parentWithMember("writer", this._consoleWriter);
  }
  _consoleWriter(t, r, ...n) {
    console[t](`[${r}]`, ...n);
  }
  _matchLevel(t) {
    const r = bt.log.level || "warn";
    return mk[this._parentWithMember("level", r)] <= mk[t];
  }
  _argsToKey(...t) {
    return j3(JSON.stringify(t, (n, i) => typeof i != "object" || Array.isArray(i) ? i : "[Object]"));
  }
  static _scheduleTickCounterIncrement() {
    gn._tickCounterScheduled || (gn._tickCounterScheduled = !0, Promise.resolve().then(() => {
      gn._tickCounter++, gn._tickCounterScheduled = !1;
    }));
  }
};
se._loggers = /* @__PURE__ */ new Map(), se._tickCounter = 0, se._tickCounterScheduled = !1, se._throttlingDisabled = !1;
var Wa;
(function(e) {
  e[e.INITIALIZING = 0] = "INITIALIZING", e[e.CONSTRUCTING = 1] = "CONSTRUCTING", e[e.CONSTRUCTED = 2] = "CONSTRUCTED";
})(Wa || (Wa = {}));
let uW = class {
  constructor(t, r) {
    this._observers = t, this._observer = r;
  }
  remove() {
    YH(this._observers, this._observer);
  }
}, oF = class {
  constructor() {
    this._observers = null, this.destroyed = !1;
  }
  observe(t) {
    if (this.destroyed || t.destroyed)
      return cW;
    this._observers == null && (this._observers = []);
    const r = this._observers;
    let n = !1, i = !1;
    const s = r.length;
    for (let o = 0; o < s; ++o) {
      const a = r[o];
      if (a.destroyed)
        i = !0;
      else if (a === t) {
        n = !0;
        break;
      }
    }
    return n || (r.push(t), i && this._removeDestroyedObservers()), new uW(r, t);
  }
  _removeDestroyedObservers() {
    const t = this._observers;
    if (!t || t.length === 0)
      return;
    const r = t.length;
    let n = 0;
    for (let i = 0; i < r; ++i) {
      for (; i + n < r && t[i + n].destroyed; )
        ++n;
      if (n > 0) {
        if (!(i + n < r))
          break;
        t[i] = t[i + n];
      }
    }
    t.length = r - n;
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const t = this._observers;
    if (t != null) {
      for (const r of t)
        r.onCommitted();
      this._observers = null;
    }
  }
};
const cW = nl();
var Qe;
(function(e) {
  e[e.DEFAULTS = 0] = "DEFAULTS", e[e.COMPUTED = 1] = "COMPUTED", e[e.SERVICE = 2] = "SERVICE", e[e.PORTAL_ITEM = 3] = "PORTAL_ITEM", e[e.WEB_SCENE = 4] = "WEB_SCENE", e[e.WEB_MAP = 5] = "WEB_MAP", e[e.LINK_CHART = 6] = "LINK_CHART", e[e.USER = 7] = "USER";
})(Qe || (Qe = {}));
const x$ = Qe.USER + 1;
function bu(e) {
  switch (e) {
    case "defaults":
      return Qe.DEFAULTS;
    case "service":
      return Qe.SERVICE;
    case "portal-item":
      return Qe.PORTAL_ITEM;
    case "web-scene":
      return Qe.WEB_SCENE;
    case "web-map":
      return Qe.WEB_MAP;
    case "link-chart":
      return Qe.LINK_CHART;
    case "user":
      return Qe.USER;
    default:
      return null;
  }
}
function cb(e) {
  switch (e) {
    case Qe.DEFAULTS:
      return "defaults";
    case Qe.SERVICE:
      return "service";
    case Qe.PORTAL_ITEM:
      return "portal-item";
    case Qe.WEB_SCENE:
      return "web-scene";
    case Qe.WEB_MAP:
      return "web-map";
    case Qe.LINK_CHART:
      return "link-chart";
    case Qe.USER:
      return "user";
  }
  return void 0;
}
function dW(e) {
  return cb(e);
}
var St;
(function(e) {
  e[e.Dirty = 1] = "Dirty", e[e.Overriden = 2] = "Overriden", e[e.Computing = 4] = "Computing", e[e.NonNullable = 8] = "NonNullable", e[e.HasDefaultValue = 16] = "HasDefaultValue", e[e.DepTrackingInitialized = 32] = "DepTrackingInitialized", e[e.AutoTracked = 64] = "AutoTracked", e[e.ExplicitlyTracking = 128] = "ExplicitlyTracking";
})(St || (St = {}));
const db = { onObservableAccessed: () => {
}, onTrackingEnd: () => {
} }, um = [];
let uy = db;
function Ve(e) {
  uy.onObservableAccessed(e);
}
let Fv = !1, Dv = !1;
function il(e, t, r) {
  if (Fv)
    return V3(e, t, r);
  aF(e);
  const n = t.call(r);
  return lF(), n;
}
function pW(e, t) {
  return il(db, e, t);
}
function V3(e, t, r) {
  const n = Fv;
  Fv = !0, aF(e);
  let i = null;
  try {
    i = t.call(r);
  } catch (s) {
    Dv && se.getLogger("geoscene.core.accessorSupport.tracking").error(s);
  }
  return lF(), Fv = n, i;
}
function aF(e) {
  uy = e, um.push(e);
}
function lF() {
  const e = um.length;
  if (e > 1) {
    const t = um.pop();
    uy = um[e - 2], t.onTrackingEnd();
  } else if (e === 1) {
    const t = um.pop();
    uy = db, t.onTrackingEnd();
  } else
    uy = db;
}
function uF(e, t) {
  const r = t.observerObject;
  if (r.flags & St.DepTrackingInitialized)
    return;
  const n = Dv;
  Dv = !1, r.flags & St.AutoTracked ? V3(t, t.metadata.get, e) : cF(e, t), Dv = n;
}
const hW = [];
function cF(e, t) {
  const r = t.observerObject;
  r.flags & St.ExplicitlyTracking || (r.flags |= St.ExplicitlyTracking, V3(t, () => {
    const n = t.metadata.dependsOn || hW;
    for (const i of n)
      if (typeof i != "string" || i.includes(".")) {
        const s = Q5(i);
        for (let o = 0, a = e; o < s.length && a != null && typeof a == "object"; ++o)
          a = yk(a, s[o], o !== s.length - 1);
      } else
        yk(e, i, !1);
  }), r.flags &= ~St.ExplicitlyTracking);
}
function yk(e, t, r) {
  const n = t[t.length - 1] === "?" ? t.slice(0, -1) : t;
  if (e.getItemAt != null || Array.isArray(e)) {
    const s = parseInt(n, 10);
    if (!isNaN(s))
      return Array.isArray(e) ? e[s] : e.at(s);
  }
  const i = Bn(e);
  if (i) {
    const s = i.propertiesByName.get(n);
    s && (Ve(s.observerObject), uF(e, s));
  }
  return r ? e[n] : void 0;
}
let gk = class {
  constructor(t, r) {
    this.propertyName = t, this.metadata = r, this.observerObject = new fW(), this._accessed = null, this._handles = null, this.observerObject.flags = St.Dirty | (r.nonNullable ? St.NonNullable : 0) | (r.hasOwnProperty("value") ? St.HasDefaultValue : 0) | (r.get === void 0 ? St.DepTrackingInitialized : 0) | (r.dependsOn === void 0 ? St.AutoTracked : 0);
  }
  destroy() {
    this.observerObject.destroy(), this._accessed = null, this._clearObservationHandles();
  }
  getComputed(t) {
    const r = this.observerObject;
    Ve(r);
    const n = t.store, i = this.propertyName, s = r.flags, o = n.get(i);
    if (s & St.Computing || ~s & St.Dirty && n.has(i))
      return o;
    r.flags |= St.Computing;
    const a = t.host;
    let l;
    s & St.AutoTracked ? l = il(this, this.metadata.get, a) : (cF(a, this), l = this.metadata.get.call(a)), n.set(i, l, Qe.COMPUTED);
    const c = n.get(i);
    return c === o ? r.flags &= ~St.Dirty : pW(this.commit, this), r.flags &= ~St.Computing, c;
  }
  onObservableAccessed(t) {
    if (t === this.observerObject)
      return;
    let r = this._accessed;
    if (r == null)
      r = [], this._accessed = r;
    else if (r.includes(t))
      return;
    r.push(t);
  }
  onTrackingEnd() {
    this._clearObservationHandles();
    const t = this.observerObject;
    t.flags |= St.DepTrackingInitialized;
    const r = this._accessed;
    if (r == null || r.length === 0)
      return;
    let n = this._handles;
    n == null && (n = [], this._handles = n);
    for (let i = 0; i < r.length; ++i)
      n.push(r[i].observe(t));
    r.length = 0;
  }
  notifyChange() {
    const t = this.observerObject;
    t.onInvalidated(), t.onCommitted();
  }
  invalidate() {
    this.observerObject.onInvalidated();
  }
  commit() {
    const t = this.observerObject;
    t.flags &= ~St.Dirty, t.onCommitted();
  }
  _clearObservationHandles() {
    const t = this._handles;
    if (t !== null) {
      for (let r = 0; r < t.length; ++r)
        t[r].remove();
      t.length = 0;
    }
  }
}, fW = class extends oF {
  constructor() {
    super(...arguments), this.flags = 0;
  }
  onInvalidated() {
    ~this.flags & St.Overriden && (this.flags |= St.Dirty);
    const t = this._observers;
    if (t && t.length > 0)
      for (const r of t)
        r.onInvalidated();
  }
  onCommitted() {
    const t = this._observers;
    if (t && t.length > 0) {
      const r = t.slice();
      for (const n of r)
        n.onCommitted();
    }
  }
  destroy() {
    this.flags & St.Dirty && this.onCommitted(), super.destroy();
  }
}, mW = class dF {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(t) {
    const r = new dF();
    return this._values.forEach((n, i) => {
      t && t.has(i) || r.set(i, j(n));
    }), r;
  }
  get(t) {
    return this._values.get(t);
  }
  originOf() {
    return Qe.USER;
  }
  keys() {
    return [...this._values.keys()];
  }
  set(t, r) {
    this._values.set(t, r);
  }
  delete(t) {
    this._values.delete(t);
  }
  has(t) {
    return this._values.has(t);
  }
  forEach(t) {
    this._values.forEach(t);
  }
};
function b0(e, t, r) {
  return e !== void 0;
}
function vk(e, t, r, n) {
  return e !== void 0 && (!(r == null && e.observerObject.flags & St.NonNullable) || (n.lifecycle, Wa.INITIALIZING, !1));
}
function yW(e) {
  return e && typeof e.destroy == "function";
}
se.getLogger("geoscene.core.accessorSupport.Properties");
let gW = class {
  constructor(t) {
    this.host = t, this.propertiesByName = /* @__PURE__ */ new Map(), this.ctorArgs = null, this.destroyed = !1, this.lifecycle = Wa.INITIALIZING, this.store = new mW(), this._origin = Qe.USER;
    const r = this.host.constructor.__accessorMetadata__;
    for (const n in r) {
      const i = new gk(n, r[n]);
      this.propertiesByName.set(n, i);
    }
    this.metadatas = r;
  }
  initialize() {
    this.lifecycle = Wa.CONSTRUCTING;
  }
  constructed() {
    this.lifecycle = Wa.CONSTRUCTED;
  }
  destroy() {
    this.destroyed = !0;
    for (const [t, r] of this.propertiesByName) {
      if (r.metadata.autoDestroy) {
        const n = this.internalGet(t);
        n && yW(n) && (n.destroy(), ~r.observerObject.flags & St.NonNullable && this._internalSet(r, null));
      }
      r.destroy();
    }
  }
  get initialized() {
    return this.lifecycle !== Wa.INITIALIZING;
  }
  get(t) {
    const r = this.propertiesByName.get(t);
    if (r.metadata.get)
      return r.getComputed(this);
    Ve(r.observerObject);
    const n = this.store;
    return n.has(t) ? n.get(t) : r.metadata.value;
  }
  originOf(t) {
    const r = this.store.originOf(t);
    if (r === void 0) {
      const n = this.propertiesByName.get(t);
      if (n !== void 0 && n.observerObject.flags & St.HasDefaultValue)
        return "defaults";
    }
    return cb(r);
  }
  has(t) {
    return !!this.propertiesByName.has(t) && this.store.has(t);
  }
  keys() {
    return [...this.propertiesByName.keys()];
  }
  internalGet(t) {
    const r = this.propertiesByName.get(t);
    if (b0(r))
      return this.store.has(t) ? this.store.get(t) : r.metadata.value;
  }
  internalSet(t, r) {
    const n = this.propertiesByName.get(t);
    b0(n) && this._internalSet(n, r);
  }
  getDependsInfo(t, r, n) {
    const i = this.propertiesByName.get(r);
    if (!b0(i))
      return "";
    const s = /* @__PURE__ */ new Set(), o = il({ onObservableAccessed: (l) => s.add(l), onTrackingEnd: () => {
    } }, () => {
      var l;
      return (l = i.metadata.get) == null ? void 0 : l.call(t);
    });
    let a = `${n}${t.declaredClass.split(".").pop()}.${r}: ${o}
`;
    if (s.size === 0)
      return a;
    n += "  ";
    for (const l of s)
      l instanceof gk && (a += `${n}${l.propertyName}: undefined
`);
    return a;
  }
  setAtOrigin(t, r, n) {
    const i = this.propertiesByName.get(t);
    if (b0(i))
      return this._setAtOrigin(i, r, n);
  }
  isOverridden(t) {
    const r = this.propertiesByName.get(t);
    return r !== void 0 && !!(r.observerObject.flags & St.Overriden);
  }
  clearOverride(t) {
    const r = this.propertiesByName.get(t), n = r == null ? void 0 : r.observerObject;
    n && n.flags & St.Overriden && (n.flags &= ~St.Overriden, r.notifyChange());
  }
  override(t, r) {
    const n = this.propertiesByName.get(t);
    if (!vk(n, t, r, this))
      return;
    const i = n.metadata.cast;
    if (i) {
      const s = this._cast(i, r), { valid: o, value: a } = s;
      if (I2.release(s), !o)
        return;
      r = a;
    }
    n.observerObject.flags |= St.Overriden, this._internalSet(n, r);
  }
  set(t, r) {
    const n = this.propertiesByName.get(t);
    if (!vk(n, t, r, this))
      return;
    const i = n.metadata.cast;
    if (i) {
      const o = this._cast(i, r), { valid: a, value: l } = o;
      if (I2.release(o), !a)
        return;
      r = l;
    }
    const s = n.metadata.set;
    s ? s.call(this.host, r) : this._internalSet(n, r);
  }
  setDefaultOrigin(t) {
    this._origin = bu(t);
  }
  getDefaultOrigin() {
    return cb(this._origin);
  }
  notifyChange(t) {
    const r = this.propertiesByName.get(t);
    r !== void 0 && r.notifyChange();
  }
  invalidate(t) {
    const r = this.propertiesByName.get(t);
    r !== void 0 && r.invalidate();
  }
  commit(t) {
    const r = this.propertiesByName.get(t);
    r !== void 0 && r.commit();
  }
  _internalSet(t, r) {
    const n = this.lifecycle !== Wa.INITIALIZING ? this._origin : Qe.DEFAULTS;
    this._setAtOrigin(t, r, n);
  }
  _setAtOrigin(t, r, n) {
    const i = this.store, s = t.propertyName;
    i.has(s, n) && D3(r, i.get(s)) && ~t.observerObject.flags & St.Overriden && n === i.originOf(s) || (t.invalidate(), i.set(s, r, n), t.commit(), uF(this.host, t));
  }
  _cast(t, r) {
    const n = I2.acquire();
    return n.valid = !0, n.value = r, t && (n.value = t.call(this.host, r, n)), n;
  }
}, vW = class {
  constructor() {
    this.value = null, this.valid = !0;
  }
  acquire() {
    this.valid = !0;
  }
  release() {
    this.value = null;
  }
};
const I2 = new Jd(vW);
function bW(e, t) {
  return e.replaceAll(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g, (r, n) => n === "" ? "$" : (Pg(n, t) ?? "").toString());
}
let pF = class {
  constructor(t, r, n) {
    this.name = t, this.details = n, this.message = (r && bW(r, n)) ?? "";
  }
  toString() {
    return "[" + this.name + "]: " + this.message;
  }
}, G = class hF extends pF {
  constructor(t, r, n) {
    super(t, r, n);
  }
  toJSON() {
    if (this.details != null)
      try {
        return { name: this.name, message: this.message, details: JSON.parse(JSON.stringify(this.details, (t, r) => {
          if (r && typeof r == "object" && typeof r.toJSON == "function")
            return r;
          try {
            return j(r);
          } catch {
            return "[object]";
          }
        })) };
      } catch (t) {
        throw se.getLogger("geoscene.core.Error").error(t), t;
      }
    return { name: this.name, message: this.message, details: this.details };
  }
  static fromJSON(t) {
    return new hF(t.name, t.message, t.details);
  }
};
G.prototype.type = "error";
function pb(e, t, r) {
  if (e && t)
    if (typeof t == "object")
      for (const n of Object.getOwnPropertyNames(t))
        pb(e, n, t[n]);
    else {
      if (t.includes(".")) {
        const i = t.split("."), s = i.splice(i.length - 1, 1)[0];
        return void pb(ub(e, i), s, r);
      }
      const n = e.__accessor__;
      n != null && wW(t, n), e[t] = r;
    }
}
function wW(e, t) {
  if (U("geoscene-unknown-property-errors") && !_W(e, t))
    throw new G("set:unknown-property", SW(e, t));
}
function _W(e, t) {
  return t.metadatas[e] != null;
}
function SW(e, t) {
  return "setting unknown property '" + e + "' on instance of " + t.host.declaredClass;
}
let $W;
function xW() {
  return $W;
}
let fF = class extends Jd {
  constructor() {
    super(...arguments), this._set = /* @__PURE__ */ new Set();
  }
  destroy() {
    super.destroy(), this._set = WH(this._set);
  }
  acquire(...t) {
    const r = super.acquire(...t);
    return this._set.delete(r), r;
  }
  release(t) {
    t && !this._set.has(t) && (super.release(t), this._set.add(t));
  }
  _dispose(t) {
    this._set.delete(t), super._dispose(t);
  }
};
const w0 = [];
function hb(e) {
  w0.push(e), w0.length === 1 && queueMicrotask(() => {
    const t = w0.slice();
    w0.length = 0;
    for (const r of t)
      r();
  });
}
let cy = class {
  constructor(t, r = 30) {
    this.name = t, this._counter = 0, this._samples = new Array(r);
  }
  record(t) {
    t != null && (this._samples[++this._counter % this._samples.length] = t);
  }
  get median() {
    return this._samples.slice().sort((t, r) => t - r)[Math.floor(this._samples.length / 2)];
  }
  get average() {
    return this._samples.reduce((t, r) => t + r, 0) / this._samples.length;
  }
  get last() {
    return this._samples[this._counter % this._samples.length];
  }
};
var T$;
(function(e) {
  const t = (s, o, a, l) => {
    let c = o, h = o;
    const f = a >>> 1, m = s[c - 1];
    for (; h <= f; ) {
      h = c << 1, h < a && l(s[h - 1], s[h]) < 0 && ++h;
      const y = s[h - 1];
      if (l(y, m) <= 0)
        break;
      s[c - 1] = y, c = h;
    }
    s[c - 1] = m;
  }, r = (s, o) => s < o ? -1 : s > o ? 1 : 0;
  function n(s, o, a, l) {
    o === void 0 && (o = 0), a === void 0 && (a = s.length), l === void 0 && (l = r);
    for (let h = a >>> 1; h > o; h--)
      t(s, h, a, l);
    const c = o + 1;
    for (let h = a - 1; h > o; h--) {
      const f = s[o];
      s[o] = s[h], s[h] = f, t(s, c, h, l);
    }
  }
  function* i(s, o, a, l) {
    o === void 0 && (o = 0), a === void 0 && (a = s.length), l === void 0 && (l = r);
    for (let h = a >>> 1; h > o; h--)
      t(s, h, a, l), yield;
    const c = o + 1;
    for (let h = a - 1; h > o; h--) {
      const f = s[o];
      s[o] = s[h], s[h] = f, t(s, c, h, l), yield;
    }
  }
  e.sort = n, e.iterableSort = i;
})(T$ || (T$ = {}));
const bk = T$, TW = 1.5, EW = 1.1;
let md = class {
  constructor(t) {
    this.data = [], this._length = 0, this._allocator = void 0, this._deallocator = () => null, this._shrink = () => {
    }, this._hint = new z5(), t && (t.initialSize && (this.data = new Array(t.initialSize)), t.allocator && (this._allocator = t.allocator), t.deallocator !== void 0 && (this._deallocator = t.deallocator), t.shrink && (this._shrink = () => wk(this)));
  }
  toArray() {
    return this.data.slice(0, this.length);
  }
  filter(t) {
    const r = new Array();
    for (let n = 0; n < this._length; n++) {
      const i = this.data[n];
      t(i) && r.push(i);
    }
    return r;
  }
  at(t) {
    if ((t = Math.trunc(t) || 0) < 0 && (t += this._length), !(t < 0 || t >= this._length))
      return this.data[t];
  }
  includes(t, r) {
    const n = this.data.indexOf(t, r);
    return n !== -1 && n < this.length;
  }
  get length() {
    return this._length;
  }
  set length(t) {
    if (t > this._length) {
      if (this._allocator) {
        for (; this._length < t; )
          this.data[this._length++] = this._allocator(this.data[this._length]);
        return;
      }
      this._length = t;
    } else {
      if (this._deallocator)
        for (let r = t; r < this._length; ++r)
          this.data[r] = this._deallocator(this.data[r]);
      this._length = t, this._shrink();
    }
  }
  clear() {
    this.length = 0;
  }
  prune() {
    this.clear(), this.data = [];
  }
  push(t) {
    this.data[this._length++] = t;
  }
  pushArray(t, r = t.length) {
    for (let n = 0; n < r; n++)
      this.data[this._length++] = t[n];
  }
  fill(t, r) {
    for (let n = 0; n < r; n++)
      this.data[this._length++] = t;
  }
  pushNew() {
    this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
    const t = this.data[this._length];
    return ++this._length, t;
  }
  unshift(t) {
    this.data.unshift(t), this._length++, wk(this);
  }
  pop() {
    if (this.length === 0)
      return;
    const t = this.data[this.length - 1];
    return this.length = this.length - 1, this._shrink(), t;
  }
  remove(t) {
    const r = S$(this.data, t, this.length, this._hint);
    if (r !== -1)
      return this.data.splice(r, 1), this.length = this.length - 1, t;
  }
  removeUnordered(t) {
    return this.removeUnorderedIndex(S$(this.data, t, this.length, this._hint));
  }
  removeUnorderedIndex(t) {
    if (!(t >= this.length || t < 0))
      return this.swapElements(t, this.length - 1), this.pop();
  }
  removeUnorderedMany(t, r = t.length, n) {
    this.length = KH(this.data, t, this.length, r, this._hint, n), this._shrink();
  }
  front() {
    if (this.length !== 0)
      return this.data[0];
  }
  back() {
    if (this.length !== 0)
      return this.data[this.length - 1];
  }
  swapElements(t, r) {
    if (t >= this.length || r >= this.length || t === r)
      return;
    const n = this.data[t];
    this.data[t] = this.data[r], this.data[r] = n;
  }
  sort(t) {
    bk.sort(this.data, 0, this.length, t);
  }
  iterableSort(t) {
    return bk.iterableSort(this.data, 0, this.length, t);
  }
  some(t, r) {
    for (let n = 0; n < this.length; ++n)
      if (t.call(r, this.data[n], n, this.data))
        return !0;
    return !1;
  }
  find(t, r) {
    for (let n = 0; n < this.length; ++n) {
      const i = this.data[n];
      if (t.call(r, i, n))
        return i;
    }
  }
  filterInPlace(t, r) {
    let n = 0;
    for (let i = 0; i < this._length; ++i) {
      const s = this.data[i];
      t.call(r, s, i, this.data) && (this.data[i] = this.data[n], this.data[n] = s, n++);
    }
    if (this._deallocator)
      for (let i = n; i < this._length; i++)
        this.data[i] = this._deallocator(this.data[i]);
    return this._length = n, this._shrink(), this;
  }
  forAll(t, r) {
    const n = this.length, i = this.data;
    for (let s = 0; s < n; ++s)
      t.call(r, i[s], s, i);
  }
  forEach(t, r) {
    for (let n = 0; n < this.length; ++n)
      t.call(r, this.data[n], n, this.data);
  }
  map(t, r) {
    const n = new Array(this.length);
    for (let i = 0; i < this.length; ++i)
      n[i] = t.call(r, this.data[i], i, this.data);
    return n;
  }
  reduce(t, r) {
    let n = r;
    for (let i = 0; i < this.length; ++i)
      n = t(n, this.data[i], i, this.data);
    return n;
  }
  has(t) {
    const r = this.length, n = this.data;
    for (let i = 0; i < r; ++i)
      if (n[i] === t)
        return !0;
    return !1;
  }
};
function wk(e) {
  e.data.length > TW * e.length && (e.data.length = Math.floor(e.length * EW));
}
function IW(e) {
  return { setTimeout: (t, r) => {
    const n = e.setTimeout(t, r);
    return { remove: () => e.clearTimeout(n) };
  } };
}
const rf = IW(globalThis);
function Jw(e) {
  return e && (typeof e.on == "function" || typeof e.addEventListener == "function");
}
function Zw(e, t, r) {
  if (!Jw(e))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("on" in e)
    return e.on(t, r);
  if (Array.isArray(t)) {
    const n = t.slice();
    for (const i of n)
      e.addEventListener(i, r);
    return { remove() {
      for (const i of n)
        e.removeEventListener(i, r);
    } };
  }
  return e.addEventListener(t, r), { remove() {
    e.removeEventListener(t, r);
  } };
}
function mF(e, t, r) {
  if (!Jw(e))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("once" in e)
    return e.once(t, r);
  const n = Zw(e, t, (i) => {
    n.remove(), r.call(e, i);
  });
  return { remove() {
    n.remove();
  } };
}
const MW = { Win: "Meta", Scroll: "ScrollLock", Spacebar: " ", Down: "ArrowDown", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Del: "Delete", Apps: "ContextMenu", Esc: "Escape", Multiply: "*", Add: "+", Subtract: "-", Decimal: ".", Divide: "/" };
function OW({ key: e }) {
  return MW[e] || e;
}
function rr(e = "Aborted") {
  return new G("AbortError", e);
}
function lr(e, t = "Aborted") {
  if (ho(e))
    throw rr(t);
}
function Kw(e) {
  return e != null ? "aborted" in e ? e : e.signal : e;
}
function ho(e) {
  const t = Kw(e);
  return t != null && t.aborted;
}
function Go(e) {
  if (Fi(e))
    throw e;
}
function _k(e) {
  if (!Fi(e))
    throw e;
}
function fs(e, t) {
  const r = Kw(e);
  if (r != null) {
    if (!r.aborted)
      return mF(r, "abort", () => t());
    t();
  }
}
function z3(e, t) {
  const r = Kw(e);
  if (r != null)
    return lr(r), mF(r, "abort", () => t(rr()));
}
function CW(e, t) {
  return Kw(t) == null ? e : new Promise((r, n) => {
    let i = fs(t, () => n(rr()));
    const s = () => i = tr(i);
    e.then(s, s), e.then(r, n);
  });
}
function Fi(e) {
  return (e == null ? void 0 : e.name) === "AbortError";
}
async function E$(e) {
  try {
    return await e;
  } catch (t) {
    if (!Fi(t))
      throw t;
    return;
  }
}
async function Zd(e) {
  if (!e)
    return;
  if (typeof e.forEach != "function") {
    const r = Object.keys(e), n = r.map((o) => e[o]), i = await Zd(n), s = {};
    return r.map((o, a) => s[o] = i[a]), s;
  }
  const t = e;
  return Promise.allSettled(t).then((r) => Array.from(t, (n, i) => {
    const s = r[i];
    return s.status === "fulfilled" ? { promise: n, value: s.value } : { promise: n, error: s.reason };
  }));
}
async function kW(e) {
  return (await Zd(e)).filter((t) => !!t.value).map((t) => t.value);
}
function yF(e, t = void 0, r) {
  const n = new AbortController();
  return fs(r, () => n.abort()), new Promise((i, s) => {
    let o = setTimeout(() => {
      o = 0, i(t);
    }, e);
    fs(n, () => {
      o && (clearTimeout(o), s(rr()));
    });
  });
}
function pl(e) {
  return e && typeof e.then == "function";
}
function I$(e) {
  return pl(e) ? e : Promise.resolve(e);
}
function gF(e, t = -1) {
  let r, n, i, s, o = null;
  const a = (...l) => {
    if (r) {
      n = l, s && s.reject(rr()), s = vs();
      const m = s.promise;
      if (o) {
        const y = o;
        o = null, y.abort();
      }
      return m;
    }
    if (i = s || vs(), s = null, t > 0) {
      const m = new AbortController();
      r = I$(e(...l, m.signal));
      const y = r;
      yF(t).then(() => {
        r === y && (s ? m.abort() : o = m);
      });
    } else
      r = 1, r = I$(e(...l));
    const c = () => {
      const m = n;
      n = i = r = o = null, m != null && a(...m);
    }, h = r, f = i;
    return h.then(c, c), h.then(f.resolve, f.reject), f.promise;
  };
  return a;
}
function vs() {
  let e, t;
  const r = new Promise((i, s) => {
    e = i, t = s;
  }), n = (i) => {
    e(i);
  };
  return n.resolve = (i) => e(i), n.reject = (i) => t(i), n.timeout = (i, s) => rf.setTimeout(() => n.reject(s), i), n.promise = r, n;
}
async function Sk(e) {
  await Promise.resolve(), lr(e);
}
function WAe(e) {
  return e;
}
let AW = class {
  constructor(t) {
    this.phases = t, this.paused = !1, this.ticks = -1, this.removed = !1;
  }
}, PW = class {
  constructor(t) {
    this.callback = t, this.isActive = !0;
  }
  remove() {
    this.isActive = !1;
  }
}, M$ = 0;
const Nf = { time: 0, deltaTime: 0, elapsedFrameTime: 0, frameDuration: 0 }, O$ = ["prepare", "preRender", "render", "postRender", "update", "finish"], C$ = [], Td = new md();
let RW = class {
  constructor(t) {
    this._task = t;
  }
  remove() {
    this._task.removed = !0;
  }
  pause() {
    this._task.paused = !0;
  }
  resume() {
    this._task.paused = !1;
  }
};
const fb = { frameTasks: Td, willDispatch: !1, clearFrameTasks: LW, dispatch: wF, executeFrameTasks: NW };
function nf(e) {
  const t = new PW(e);
  return C$.push(t), fb.willDispatch || (fb.willDispatch = !0, hb(wF)), t;
}
function Ah(e) {
  const t = new AW(e);
  return Td.push(t), mb == null && (M$ = performance.now(), mb = requestAnimationFrame(vF)), new RW(t);
}
let mb = null;
function LW(e = !1) {
  Td.forAll((t) => {
    t.removed = !0;
  }), e && bF();
}
function vF() {
  const e = performance.now();
  mb = null, mb = Td.length > 0 ? requestAnimationFrame(vF) : null, fb.executeFrameTasks(e);
}
function NW(e) {
  const t = e - M$;
  M$ = e;
  const r = 1e3 / 60, n = Math.max(0, t - r);
  Nf.time = e, Nf.frameDuration = r - n;
  for (let i = 0; i < O$.length; i++) {
    const s = performance.now(), o = O$[i];
    Td.forAll((a) => {
      var l;
      a.paused || a.removed || (i === 0 && a.ticks++, a.phases[o] && (Nf.elapsedFrameTime = performance.now() - e, Nf.deltaTime = a.ticks === 0 ? 0 : t, (l = a.phases[o]) == null || l.call(a, Nf)));
    }), FW[i].record(performance.now() - s);
  }
  bF(), DW.record(performance.now() - e);
}
const _0 = new md();
function bF() {
  Td.forAll((e) => {
    e.removed && _0.push(e);
  }), Td.removeUnorderedMany(_0.data, _0.length), _0.clear();
}
function wF() {
  for (; C$.length; ) {
    const e = C$.shift();
    e.isActive && e.callback();
  }
  fb.willDispatch = !1;
}
function YAe(e = 1, t) {
  const r = vs(), n = () => {
    ho(t) ? r.reject(rr()) : e === 0 ? r() : (--e, hb(() => n()));
  };
  return n(), r.promise;
}
const FW = O$.map((e) => new cy(e)), DW = new cy("total");
function jW(e, t) {
  for (const r of e.entries())
    if (t(r[0]))
      return !0;
  return !1;
}
let VW = 0;
function dy() {
  return ++VW;
}
let Yw = class {
  constructor(t) {
    this._accessed = [], this._handles = [], this._observerObject = new zW(t), $k.register(this, new WeakRef(this._observerObject), this);
  }
  destroy() {
    var t;
    $k.unregister(this._observerObject), this._accessed.length = 0, (t = this._observerObject) == null || t.destroy(), this.clear();
  }
  onObservableAccessed(t) {
    const r = this._accessed;
    r.includes(t) || r.push(t);
  }
  onTrackingEnd() {
    const t = this._handles, r = this._accessed, n = this._observerObject;
    for (let i = 0; i < r.length; ++i)
      t.push(r[i].observe(n));
    r.length = 0;
  }
  clear() {
    const t = this._handles;
    for (let r = 0; r < t.length; ++r)
      t[r].remove();
    t.length = 0;
  }
}, zW = class {
  constructor(t) {
    this._notify = t, this._invalidCount = 0, this.destroyed = !1;
  }
  onInvalidated() {
    this._invalidCount++;
  }
  onCommitted() {
    if (this.destroyed)
      return;
    const t = this._invalidCount;
    if (t === 1)
      return this._invalidCount = 0, void this._notify();
    this._invalidCount = t > 0 ? t - 1 : 0;
  }
  destroy() {
    this.destroyed = !0, this._notify = UW;
  }
};
const $k = new FinalizationRegistry((e) => {
  var t;
  (t = e.deref()) == null || t.destroy();
});
function UW() {
}
let mh = !1;
const yb = [];
function _F(e, t) {
  let r = new Yw(s), n = null, i = !1;
  function s() {
    if (!r || i)
      return;
    if (mh)
      return void xF(s);
    const a = n;
    r.clear(), mh = !0, i = !0, n = il(r, e), i = !1, mh = !1, t(n, a), TF();
  }
  function o() {
    r && (r.destroy(), r = null, n = null);
  }
  return i = !0, n = il(r, e), i = !1, { remove: o };
}
function SF(e, t) {
  let r = new Yw(i), n = null;
  function i() {
    t(n, o);
  }
  function s() {
    r && (r.destroy(), r = null), n = null;
  }
  function o() {
    return r ? (r.clear(), n = il(r, e), n) : null;
  }
  return o(), { remove: s };
}
function $F(e) {
  let t = new Yw(n), r = !1;
  function n() {
    t && !r && (mh ? xF(n) : (t.clear(), mh = !0, r = !0, il(t, e), r = !1, mh = !1, TF()));
  }
  function i() {
    t && (t.destroy(), t = null);
  }
  return r = !0, il(t, e), r = !1, { remove: i };
}
function xF(e) {
  yb.includes(e) || yb.unshift(e);
}
function TF() {
  for (; yb.length; )
    yb.pop()();
}
var py;
(function(e) {
  e[e.Untracked = 0] = "Untracked", e[e.Tracked = 1] = "Tracked";
})(py || (py = {}));
let Uy = class {
  constructor() {
    this.uid = dy(), this.removed = !1, this.type = null, this.oldValue = null, this.callback = null, this.getValue = null, this.target = null, this.path = null, this.equals = null;
  }
  static acquireUntracked(t, r, n, i, s) {
    return this.pool.acquire(py.Untracked, t, r, n, i, s, D3);
  }
  static acquireTracked(t, r, n, i) {
    return this.pool.acquire(py.Tracked, t, r, n, null, null, i);
  }
  notify(t, r) {
    this.type === py.Untracked ? this.callback.call(this.target, t, r, this.path, this.target) : this.callback.call(null, t, r, void 0, void 0);
  }
  acquire(t, r, n, i, s, o, a) {
    this.uid = dy(), this.removed = !1, this.type = t, this.oldValue = r, this.callback = n, this.getValue = i, this.target = s, this.path = o, this.equals = a;
  }
  release() {
    this.target = this.path = this.oldValue = this.callback = this.getValue = null, this.uid = dy(), this.removed = !0;
  }
};
Uy.pool = new fF(Uy);
const jv = new jn(), Qa = /* @__PURE__ */ new Set();
let gb;
function vb(e) {
  Qa.delete(e), Qa.add(e), gb || (gb = nf(GW));
}
function BW(e) {
  if (e.removed)
    return;
  const t = e.oldValue, r = e.getValue();
  e.equals(t, r) || (e.oldValue = r, e.notify(r, t));
}
function qW(e) {
  for (const t of Qa.values())
    t.target === e && (t.removed = !0);
}
function GW() {
  let e = 10;
  for (; gb && e--; ) {
    gb = null;
    const t = HW(), r = jv.acquire();
    for (const n of t) {
      const i = n.uid;
      BW(n), i === n.uid && n.removed && r.push(n);
    }
    for (const n of Qa)
      n.removed && (r.push(n), Qa.delete(n));
    for (const n of r)
      Uy.pool.release(n);
    jv.release(r), jv.release(t), k$.forEach((n) => n());
  }
}
function HW() {
  const e = jv.acquire();
  e.length = Qa.size;
  let t = 0;
  for (const r of Qa)
    e[t] = r, ++t;
  return Qa.clear(), e;
}
const k$ = /* @__PURE__ */ new Set();
function WW(e) {
  return k$.add(e), { remove() {
    k$.delete(e);
  } };
}
function JW(e, t, r) {
  let n = X5(e, t, r, (i, s, o) => {
    let a, l, c = SF(() => kg(i, s), (h, f) => {
      i.__accessor__.destroyed || a && a.uid !== l ? n.remove() : (a || (a = Uy.acquireUntracked(h, o, f, i, s), l = a.uid), vb(a));
    });
    return { remove: eF(() => {
      c.remove(), a && (a.uid !== l || a.removed || (a.removed = !0, vb(a)), a = null), n = c = null;
    }) };
  });
  return n;
}
function ZW(e, t, r) {
  const n = X5(e, t, r, (i, s, o) => {
    let a = !1;
    return _F(() => kg(i, s), (l, c) => {
      i.__accessor__.destroyed ? n.remove() : a || (a = !0, D3(c, l) || o.call(i, l, c, s, i), a = !1);
    });
  });
  return n;
}
function KW(e, t, r, n = !1) {
  return !e.__accessor__ || e.__accessor__.destroyed ? { remove() {
  } } : n ? ZW(e, t, r) : JW(e, t, r);
}
function YW(e, t, r) {
  let n, i, s = SF(e, (o, a) => {
    n && n.uid !== i ? s.remove() : (n || (n = Uy.acquireTracked(o, t, a, r), i = n.uid), vb(n));
  });
  return { remove: eF(() => {
    s.remove(), n && (n.uid !== i || n.removed || (n.removed = !0, vb(n)), n = null), s = null;
  }) };
}
function QW(e, t, r) {
  let n = !1;
  return _F(e, (i, s) => {
    n || (n = !0, r(s, i) || t(i, s), n = !1);
  });
}
function XW(e, t, r = !1, n = Y5) {
  return r ? QW(e, t, n) : YW(e, t, n);
}
function xk(e) {
  return jW(Qa, (t) => t.oldValue === e);
}
function Qw(e, t) {
  for (const [r, n] of e)
    if (t(n, r))
      return !0;
  return !1;
}
function eJ(e, t, r) {
  const n = e.get(t);
  if (n !== void 0)
    return n;
  const i = r();
  return e.set(t, i), i;
}
const yh = se.getLogger("geoscene.core.accessorSupport.ensureTypes");
function tJ(e) {
  return e == null ? e : new Date(e);
}
function rJ(e) {
  return e == null ? e : !!e;
}
function Rg(e) {
  return e == null ? e : e.toString();
}
function ls(e) {
  return e == null ? e : (e = parseFloat(e), isNaN(e) ? 0 : e);
}
function U3(e) {
  return e == null ? e : Math.round(parseFloat(e));
}
function EF(e) {
  return e && e.constructor && e.constructor.__accessorMetadata__ !== void 0;
}
function bb(e, t) {
  return t != null && e && !(t instanceof e);
}
function IF(e) {
  return e && "isCollection" in e;
}
function Tk(e) {
  return e && e.Type ? typeof e.Type == "function" ? e.Type : e.Type.base : null;
}
function nJ(e, t) {
  if (!t || !t.constructor || !IF(t.constructor))
    return A$(e, t) ? t : new e(t);
  const r = Tk(e.prototype.itemType), n = Tk(t.constructor.prototype.itemType);
  return r ? n ? r === n ? t : r.prototype.isPrototypeOf(n.prototype) ? new e(t) : (A$(e, t), t) : new e(t) : t;
}
function A$(e, t) {
  return !!EF(t) && (yh.error("Accessor#set", "Assigning an instance of '" + (t.declaredClass || "unknown") + "' which is not a subclass of '" + e_(e) + "'"), !0);
}
function Xw(e, t) {
  return t == null ? t : IF(e) ? nJ(e, t) : bb(e, t) ? A$(e, t) ? t : new e(t) : t;
}
function e_(e) {
  return e && e.prototype && e.prototype.declaredClass || "unknown";
}
const iJ = /* @__PURE__ */ new WeakMap();
function sJ(e) {
  switch (e) {
    case Number:
      return ls;
    case Ot:
      return U3;
    case Boolean:
      return rJ;
    case String:
      return Rg;
    case Date:
      return tJ;
    default:
      return eJ(iJ, e, () => Xw.bind(null, e));
  }
}
function br(e, t) {
  const r = sJ(e);
  return arguments.length === 1 ? r : r(t);
}
function By(e, t, r) {
  return arguments.length === 1 ? By.bind(null, e) : t && (Array.isArray(t) ? t.map((n) => e(n, r)) : [e(t, r)]);
}
function oJ(e, t) {
  return arguments.length === 1 ? By((r) => br(e, r)) : By((r) => br(e, r), t);
}
function MF(e, t, r) {
  return t !== 0 && Array.isArray(r) ? r.map((n) => MF(e, t - 1, n)) : e(r);
}
function wb(e, t, r) {
  if (arguments.length === 2)
    return (s) => wb(e, t, s);
  if (!r)
    return r;
  r = MF(e, t, r);
  let n = t, i = r;
  for (; n > 0 && Array.isArray(i); )
    n--, i = i[0];
  if (i !== void 0)
    for (let s = 0; s < n; s++)
      r = [r];
  return r;
}
function aJ(e, t, r) {
  return arguments.length === 2 ? wb((n) => br(e, n), t) : wb((n) => br(e, n), t, r);
}
function OF(e) {
  return !!Array.isArray(e) && !e.some((t) => {
    const r = typeof t;
    return !(r === "string" || r === "number" || r === "function" && e.length > 1);
  });
}
function P$(e, t) {
  if (arguments.length === 2)
    return P$(e).call(null, t);
  const r = /* @__PURE__ */ new Set(), n = e.filter((a) => typeof a != "function"), i = e.filter((a) => typeof a == "function");
  for (const a of e)
    typeof a != "string" && typeof a != "number" || r.add(a);
  let s = null, o = null;
  return (a, l) => {
    if (a == null)
      return a;
    const c = typeof a, h = c === "string" || c === "number";
    return h && (r.has(a) || i.some((f) => c === "string" && f === String || c === "number" && f === Number)) || c === "object" && i.some((f) => !bb(a, f)) ? a : (h && n.length ? (s || (s = n.map((f) => typeof f == "string" ? `'${f}'` : `${f}`).join(", ")), yh.error("Accessor#set", `'${a}' is not a valid value for this property, only the following values are valid: ${s}`)) : typeof a == "object" && i.length ? (o || (o = i.map((f) => e_(f)).join(", ")), yh.error("Accessor#set", `'${a}' is not a valid value for this property, value must be one of ${o}`)) : yh.error("Accessor#set", `'${a}' is not a valid value for this property`), l && (l.valid = !1), null);
  };
}
function na(e, t) {
  if (arguments.length === 2)
    return na(e).call(null, t);
  const r = {}, n = [], i = [];
  for (const l in e.typeMap) {
    const c = e.typeMap[l];
    r[l] = br(c), n.push(e_(c)), i.push(l);
  }
  const s = () => `'${n.join("', '")}'`, o = () => `'${i.join("', '")}'`, a = typeof e.key == "string" ? (l) => l[e.key] : e.key;
  return (l) => {
    if (e.base && !bb(e.base, l) || l == null)
      return l;
    const c = a(l) || e.defaultKeyValue, h = r[c];
    if (!h)
      return yh.error("Accessor#set", `Invalid property value, value needs to be one of ${s()}, or a plain object that can autocast (having .type = ${o()})`), null;
    if (!bb(e.typeMap[c], l))
      return l;
    if (typeof e.key == "string" && !EF(l)) {
      const f = {};
      for (const m in l)
        m !== e.key && (f[m] = l[m]);
      return h(f);
    }
    return h(l);
  };
}
let Ot = class {
};
const rPe = { native: (e) => ({ type: "native", value: e }), array: (e) => ({ type: "array", value: e }), oneOf: (e) => ({ type: "one-of", values: e }) };
function lJ(e) {
  if (!e || !("type" in e))
    return !1;
  switch (e.type) {
    case "native":
    case "array":
    case "one-of":
      return !0;
  }
  return !1;
}
function CF(e) {
  switch (e.type) {
    case "native":
      return br(e.value);
    case "array":
      return By(CF(e.value));
    case "one-of":
      return uJ(e);
    default:
      return null;
  }
}
function uJ(e) {
  let t = null;
  return (r, n) => L$(r, e) ? r : (t == null && (t = R$(e)), yh.error("Accessor#set", `Invalid property value, value needs to be of type ${t}`), n && (n.valid = !1), null);
}
function R$(e) {
  switch (e.type) {
    case "native":
      switch (e.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case Ot:
          return "integer";
        case Date:
          return "date";
        default:
          return e_(e.value);
      }
    case "array":
      return `array of ${R$(e.value)}`;
    case "one-of": {
      const t = e.values.map((r) => R$(r));
      return `one of ${t.slice(0, t.length - 1)} or ${t[t.length - 1]}`;
    }
  }
  return "unknown";
}
function L$(e, t) {
  if (e == null)
    return !0;
  switch (t.type) {
    case "native":
      switch (t.value) {
        case Number:
        case Ot:
          return typeof e == "number";
        case Boolean:
          return typeof e == "boolean";
        case String:
          return typeof e == "string";
      }
      return e instanceof t.value;
    case "array":
      return !!Array.isArray(e) && !e.some((r) => !L$(r, t.value));
    case "one-of":
      return t.values.some((r) => L$(e, r));
  }
}
function d(e = {}) {
  return (t, r) => {
    if (t === Function.prototype)
      throw new Error(`Inappropriate use of @property() on a static field: ${t.name}.${r}. Accessor does not support static properties.`);
    const n = Object.getOwnPropertyDescriptor(t, r), i = Hw(t, r);
    n && (n.get || n.set ? (i.get = n.get || i.get, i.set = n.set || i.set) : "value" in n && ("value" in e && se.getLogger("geoscene.core.accessorSupport.decorators.property").warn(`@property() will redefine the value of "${r}" on "${t.constructor.name}" already defined in the metadata`, e), i.value = e.value = n.value)), e.readOnly != null && (i.readOnly = e.readOnly);
    const s = e.aliasOf;
    if (s) {
      const l = typeof s == "string" ? s : s.source, c = typeof s == "string" ? null : s.overridable === !0;
      let h;
      i.dependsOn = [l], i.get = function() {
        let f = ub(this, l);
        if (typeof f == "function") {
          h || (h = l.split(".").slice(0, -1).join("."));
          const m = ub(this, h);
          m && (f = f.bind(m));
        }
        return f;
      }, i.readOnly || (i.set = c ? function(f) {
        this._override(r, f);
      } : function(f) {
        pb(this, l, f);
      });
    }
    const o = e.type, a = e.types;
    i.cast || (o ? i.cast = cJ(o) : a && (Array.isArray(a) ? i.cast = By(na(a[0])) : i.cast = na(a))), sW(i, e), e.range && (i.cast = dJ(i.cast, e.range));
  };
}
function kF(e, t, r) {
  const n = Hw(e, r);
  n.json || (n.json = {});
  let i = n.json;
  return t !== void 0 && (i.origins || (i.origins = {}), i.origins[t] || (i.origins[t] = {}), i = i.origins[t]), i;
}
function cJ(e) {
  let t = 0, r = e;
  if (lJ(e))
    return CF(e);
  for (; Array.isArray(r) && r.length === 1 && typeof r[0] != "string" && typeof r[0] != "number"; )
    r = r[0], t++;
  const n = r;
  if (OF(n))
    return t === 0 ? P$(n) : wb(P$(n), t);
  if (t === 1)
    return oJ(n);
  if (t > 1)
    return aJ(n, t);
  const i = e;
  return i.from ? i.from : br(i);
}
function dJ(e, t) {
  return (r) => {
    let n = +e(r);
    return t.step != null && (n = Math.round(n / t.step) * t.step), t.min != null && (n = Math.max(t.min, n)), t.max != null && (n = Math.min(t.max, n)), n;
  };
}
function pJ(e) {
  if (e.json && e.json.origins) {
    const t = e.json.origins, r = { "web-document": ["web-scene", "web-map"] };
    for (const n in r)
      if (t[n]) {
        const i = t[n];
        r[n].forEach((s) => {
          t[s] = i;
        }), delete t[n];
      }
  }
}
let bs = class extends pF {
  constructor(t, r, n) {
    super(t, r, n);
  }
};
bs.prototype.type = "warning";
function AF(e) {
  return !!e && e.prototype && e.prototype.declaredClass && e.prototype.declaredClass.indexOf("geoscene.core.Collection") === 0;
}
const N$ = se.getLogger("geoscene.core.accessorSupport.extensions.serializableProperty.reader");
function Ek(e, t, r) {
  var n, i;
  e && (!r && !t.read || (n = t.read) != null && n.reader || ((i = t.read) == null ? void 0 : i.enabled) === !1 || mJ(e) && In("read.reader", sf(e), t));
}
function sf(e) {
  var r, n;
  const t = e.ndimArray ?? 0;
  if (t > 1)
    return fJ(e);
  if (t === 1)
    return Ik(e);
  if ("type" in e && RF(e.type)) {
    const i = (n = (r = e.type.prototype) == null ? void 0 : r.itemType) == null ? void 0 : n.Type, s = Ik(typeof i == "function" ? { type: i } : { types: i });
    return (o, a, l) => {
      const c = s(o, a, l);
      return c && new e.type(c);
    };
  }
  return B3(e);
}
function B3(e) {
  return "type" in e ? hJ(e.type) : yJ(e.types);
}
function hJ(e) {
  return e.prototype.read ? (t, r, n) => {
    if (t == null)
      return t;
    const i = typeof t;
    if (i !== "object")
      return void N$.error(`Expected JSON value of type 'object' to deserialize type '${e.prototype.declaredClass}', but got '${i}'`);
    const s = new e();
    return s.read(t, n), s;
  } : e.fromJSON;
}
function PF(e, t, r, n) {
  return n !== 0 && Array.isArray(t) ? t.map((i) => PF(e, i, r, n - 1)) : e(t, void 0, r);
}
function fJ(e) {
  const t = B3(e), r = PF.bind(null, t), n = e.ndimArray ?? 0;
  return (i, s, o) => {
    if (i == null)
      return i;
    i = r(i, o, n);
    let a = n, l = i;
    for (; a > 0 && Array.isArray(l); )
      a--, l = l[0];
    if (l !== void 0)
      for (let c = 0; c < a; c++)
        i = [i];
    return i;
  };
}
function Ik(e) {
  const t = B3(e);
  return (r, n, i) => {
    if (r == null)
      return r;
    if (Array.isArray(r)) {
      const o = [];
      for (const a of r) {
        const l = t(a, void 0, i);
        l !== void 0 && o.push(l);
      }
      return o;
    }
    const s = t(r, void 0, i);
    return s !== void 0 ? [s] : void 0;
  };
}
function RF(e) {
  if (!AF(e))
    return !1;
  const t = e.prototype.itemType;
  return !(!t || !t.Type) && (typeof t.Type == "function" ? q3(t.Type) : LF(t.Type));
}
function mJ(e) {
  return "types" in e ? LF(e.types) : q3(e.type);
}
function q3(e) {
  return !Array.isArray(e) && !!e && e.prototype && ("read" in e.prototype || "fromJSON" in e || RF(e));
}
function LF(e) {
  for (const t in e.typeMap)
    if (!q3(e.typeMap[t]))
      return !1;
  return !0;
}
function yJ(e) {
  let t = null;
  const r = e.errorContext ?? "type";
  return (n, i, s) => {
    if (n == null)
      return n;
    const o = typeof n;
    if (o !== "object")
      return void N$.error(`Expected JSON value of type 'object' to deserialize, but got '${o}'`);
    t || (t = gJ(e));
    const a = e.key;
    if (typeof a != "string")
      return;
    const l = n[a], c = l ? t[l] : e.defaultKeyValue ? e.typeMap[e.defaultKeyValue] : void 0;
    if (!c) {
      const f = `Type '${l || "unknown"}' is not supported`;
      return s && s.messages && n && s.messages.push(new bs(`${r}:unsupported`, f, { definition: n, context: s })), void N$.error(f);
    }
    const h = new c();
    return h.read(n, s), h;
  };
}
function gJ(e) {
  var r, n;
  const t = {};
  for (const i in e.typeMap) {
    const s = e.typeMap[i], o = Ag(s.prototype);
    if (typeof e.key == "function")
      continue;
    const a = o[e.key];
    if (!a)
      continue;
    (r = a.json) != null && r.type && Array.isArray(a.json.type) && a.json.type.length === 1 && typeof a.json.type[0] == "string" && (t[a.json.type[0]] = s);
    const l = (n = a.json) == null ? void 0 : n.write;
    if (!l || !l.writer) {
      t[i] = s;
      continue;
    }
    const c = l.target, h = typeof c == "string" ? c : e.key, f = {};
    l.writer(i, f, h), f[h] && (t[f[h]] = s);
  }
  return t;
}
function vJ(e) {
  if (e.json || (e.json = {}), Ok(e.json), Ck(e.json), Mk(e.json), e.json.origins)
    for (const t in e.json.origins)
      Ok(e.json.origins[t]), Ck(e.json.origins[t]), Mk(e.json.origins[t]);
  return !0;
}
function Mk(e) {
  e.name && (e.read && typeof e.read == "object" ? e.read.source === void 0 && (e.read.source = e.name) : e.read = { source: e.name }, e.write && typeof e.write == "object" ? e.write.target === void 0 && (e.write.target = e.name) : e.write = { target: e.name });
}
function Ok(e) {
  typeof e.read == "boolean" ? e.read = { enabled: e.read } : typeof e.read == "function" ? e.read = { enabled: !0, reader: e.read } : e.read && typeof e.read == "object" && e.read.enabled === void 0 && (e.read.enabled = !0);
}
function Ck(e) {
  typeof e.write == "boolean" ? e.write = { enabled: e.write } : typeof e.write == "function" ? e.write = { enabled: !0, writer: e.write } : e.write && typeof e.write == "object" && e.write.enabled === void 0 && (e.write.enabled = !0);
}
function kk(e, t) {
  if (!t.write || t.write.writer || t.write.enabled === !1 && !t.write.overridePolicy)
    return;
  const r = (e == null ? void 0 : e.ndimArray) ?? 0;
  e && (r === 1 || "type" in e && AF(e.type)) ? t.write.writer = _J : r > 1 ? t.write.writer = SJ(r) : t.types ? Array.isArray(t.types) ? t.write.writer = wJ(t.types[0]) : t.write.writer = bJ(t.types) : t.write.writer = qy;
}
function bJ(e) {
  return (t, r, n, i) => t ? NF(t, e, i) ? qy(t, r, n, i) : void 0 : qy(t, r, n, i);
}
function NF(e, t, r) {
  for (const n in t.typeMap)
    if (e instanceof t.typeMap[n])
      return !0;
  if (r != null && r.messages) {
    const n = t.errorContext ?? "type", i = `Values of type '${(typeof t.key != "function" ? e[t.key] : e.declaredClass) ?? "Unknown"}' cannot be written`;
    r && r.messages && e && r.messages.push(new G(`${n}:unsupported`, i, { definition: e, context: r })), se.getLogger("geoscene.core.accessorSupport.extensions.serializableProperty.writer").error(i);
  }
  return !1;
}
function wJ(e) {
  return (t, r, n, i) => !t || !Array.isArray(t) ? qy(t, r, n, i) : qy(t.filter((s) => NF(s, e, i)), r, n, i);
}
function qy(e, t, r, n) {
  In(r, _b(e, n), t);
}
function _b(e, t) {
  return e && typeof e.write == "function" ? e.write({}, t) : e && typeof e.toJSON == "function" ? e.toJSON() : typeof e == "number" ? Sb(e) : e;
}
function Sb(e) {
  return e === -1 / 0 ? -Number.MAX_VALUE : e === 1 / 0 ? Number.MAX_VALUE : isNaN(e) ? null : e;
}
function _J(e, t, r, n) {
  let i;
  e === null ? i = null : e && typeof e.map == "function" ? (i = e.map((s) => _b(s, n)), typeof i.toArray == "function" && (i = i.toArray())) : i = [_b(e, n)], In(r, i, t);
}
function FF(e, t, r) {
  return r !== 0 && Array.isArray(e) ? e.map((n) => FF(n, t, r - 1)) : _b(e, t);
}
function SJ(e) {
  return (t, r, n, i) => {
    let s;
    if (t === null)
      s = null;
    else {
      s = FF(t, i, e);
      let o = e, a = s;
      for (; o > 0 && Array.isArray(a); )
        o--, a = a[0];
      if (a !== void 0)
        for (let l = 0; l < o; l++)
          s = [s];
    }
    In(n, s, r);
  };
}
function $J(e, t) {
  return G3(e, "any", t == null ? void 0 : t.origin);
}
function F$(e, t) {
  return G3(e, "read", t == null ? void 0 : t.origin);
}
function DF(e, t) {
  return G3(e, "write", t == null ? void 0 : t.origin);
}
function G3(e, t, r) {
  let n = e == null ? void 0 : e.json;
  if (n != null && n.origins && r) {
    let i;
    i = r === "link-chart" ? n.origins[r] && (t === "any" || t in n.origins[r]) ? n.origins[r] : n.origins["web-map"] : n.origins[r], i && (t === "any" || t in i) && (n = i);
  }
  return n;
}
function xJ(e) {
  const t = TJ(e);
  if (e.json.origins)
    for (const r in e.json.origins) {
      const n = e.json.origins[r], i = n.types ? EJ(n) : t;
      Ek(i, n, !1), n.types && !n.write && e.json.write && e.json.write.enabled && (n.write = { ...e.json.write }), kk(i, n);
    }
  Ek(t, e.json, !0), kk(t, e.json);
}
function TJ(e) {
  return e.json.types ? D$(e.json) : e.type ? jF(e) : D$(e);
}
function EJ(e) {
  return e.type ? jF(e) : D$(e);
}
function jF(e) {
  if (!e.type)
    return;
  let t = 0, r = e.type;
  for (; Array.isArray(r) && !OF(r); )
    r = r[0], t++;
  return { type: r, ndimArray: t };
}
function D$(e) {
  if (!e.types)
    return;
  let t = 0, r = e.types;
  for (; Array.isArray(r); )
    r = r[0], t++;
  return { types: r, ndimArray: t };
}
function IJ(e) {
  vJ(e) && (pJ(e), xJ(e));
}
const M2 = /* @__PURE__ */ new Set(), O2 = /* @__PURE__ */ new Set();
function E(e) {
  return (t) => {
    t.prototype.declaredClass = e, OJ(t);
    const r = [], n = [];
    let i = t.prototype;
    for (; i; )
      i.hasOwnProperty("initialize") && !M2.has(i.initialize) && (M2.add(i.initialize), r.push(i.initialize)), i.hasOwnProperty("destroy") && !O2.has(i.destroy) && (O2.add(i.destroy), n.push(i.destroy)), i = Object.getPrototypeOf(i);
    M2.clear(), O2.clear();
    class s extends t {
      constructor(...a) {
        if (super(...a), this.constructor === s && typeof this.postscript == "function") {
          if (r.length && Object.defineProperty(this, "initialize", { enumerable: !1, configurable: !0, value() {
            for (let l = r.length - 1; l >= 0; l--)
              r[l].call(this);
          } }), n.length) {
            let l = !1;
            const c = this[V5];
            Object.defineProperty(this, "destroy", { enumerable: !1, configurable: !0, value() {
              if (!l) {
                l = !0, c.call(this);
                for (let h = 0; h < n.length; h++)
                  n[h].call(this);
              }
            } });
          }
          this.postscript(...a);
        }
      }
    }
    return s.__accessorMetadata__ = Ag(t.prototype), s.prototype.declaredClass = e, s;
  };
}
function MJ(e, t) {
  return t.get == null ? function() {
    const r = this.__accessor__, n = r.propertiesByName.get(e);
    if (n === void 0)
      return;
    Ve(n.observerObject);
    const i = r.store;
    return i.has(e) ? i.get(e) : n.metadata.value;
  } : function() {
    const r = this.__accessor__, n = r.propertiesByName.get(e);
    if (n !== void 0)
      return n.getComputed(r);
  };
}
function OJ(e) {
  const t = e.prototype, r = Ag(t), n = {};
  for (const i of Object.getOwnPropertyNames(r)) {
    const s = r[i];
    IJ(s), n[i] = { enumerable: !0, configurable: !0, get: MJ(i, s), set(o) {
      const a = this.__accessor__;
      if (a !== void 0) {
        if (!Object.isFrozen(this)) {
          if (a.initialized && s.readOnly)
            throw new TypeError(`[accessor] cannot assign to read-only property '${i}' of ${this.declaredClass}`);
          if (a.lifecycle === Wa.CONSTRUCTED && s.constructOnly)
            throw new TypeError(`[accessor] cannot assign to construct-only property '${i}' of ${this.declaredClass}`);
          a.set(i, o);
        }
      } else
        Object.defineProperty(this, i, { enumerable: !0, configurable: !0, writable: !0, value: o });
    } };
  }
  Object.defineProperties(e.prototype, n);
}
var VF, zF;
function CJ(e) {
  var t;
  if (e == null)
    return { value: e };
  if (Array.isArray(e))
    return { type: [e[0]], value: null };
  switch (typeof e) {
    case "object":
      return (t = e.constructor) != null && t.__accessorMetadata__ || e instanceof Date ? { type: e.constructor, value: e } : e;
    case "boolean":
      return { type: Boolean, value: e };
    case "string":
      return { type: String, value: e };
    case "number":
      return { type: Number, value: e };
    case "function":
      return { type: e, value: null };
    default:
      return;
  }
}
const Nl = Symbol("Accessor-Handles"), j$ = Symbol("Accessor-Initialized");
let Ae = class UF {
  static createSubclass(t = {}) {
    if (Array.isArray(t))
      throw new Error("Multi-inheritance unsupported since 4.16");
    const { properties: r, declaredClass: n, constructor: i } = t;
    delete t.declaredClass, delete t.properties, delete t.constructor;
    const s = this;
    class o extends s {
      constructor(...l) {
        super(...l), this.inherited = null, i && i.apply(this, l);
      }
    }
    Ag(o.prototype);
    for (const a in t) {
      const l = t[a];
      o.prototype[a] = typeof l == "function" ? function(...c) {
        const h = this.inherited;
        let f;
        this.inherited = function(...m) {
          if (s.prototype[a])
            return s.prototype[a].apply(this, m);
        };
        try {
          f = l.apply(this, c);
        } catch (m) {
          throw this.inherited = h, m;
        }
        return this.inherited = h, f;
      } : t[a];
    }
    for (const a in r) {
      const l = CJ(r[a]);
      d(l)(o.prototype, a);
    }
    return E(n)(o);
  }
  constructor(...t) {
    if (this[VF] = null, this[zF] = !1, this.constructor === UF)
      throw new Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
    const r = new gW(this);
    Object.defineProperty(this, "__accessor__", { enumerable: !1, value: r }), t.length > 0 && this.normalizeCtorArgs && (r.ctorArgs = this.normalizeCtorArgs.apply(this, t)), Ak.register(this, r.propertiesByName, this);
  }
  postscript(t) {
    const r = this.__accessor__, n = r.ctorArgs || t;
    r.initialize(), n && (this.set(n), r.ctorArgs = null), r.constructed(), this.initialize(), this[j$] = !0;
  }
  initialize() {
  }
  [V5]() {
    this[Nl] = Vt(this[Nl]);
  }
  destroy() {
    var t;
    this.destroyed || (Ak.unregister(this), qW(this), this.__accessor__.destroy(), (t = xW()) == null || t.onInstanceDestroy(this));
  }
  get constructed() {
    return this.__accessor__ && this.__accessor__.initialized || !1;
  }
  get initialized() {
    return this[j$];
  }
  get destroyed() {
    return this.__accessor__ && this.__accessor__.destroyed || !1;
  }
  commitProperty(t) {
    this.get(t);
  }
  get(t) {
    return ub(this, t);
  }
  hasOwnProperty(t) {
    return this.__accessor__ ? this.__accessor__.has(t) : Object.prototype.hasOwnProperty.call(this, t);
  }
  keys() {
    return this.__accessor__ ? this.__accessor__.keys() : [];
  }
  set(t, r) {
    return pb(this, t, r), this;
  }
  watch(t, r, n) {
    return KW(this, t, r, n);
  }
  own(t) {
    this.addHandles(t);
  }
  addHandles(t, r) {
    if (this.destroyed) {
      const i = Array.isArray(t) ? t : [t];
      for (const s of i)
        s.remove();
      return;
    }
    let n = this[Nl];
    n == null && (n = this[Nl] = new ca()), n.add(t, r);
  }
  removeHandles(t) {
    const r = this[Nl];
    r != null && r.remove(t);
  }
  removeAllHandles() {
    const t = this[Nl];
    t != null && t.removeAll();
  }
  hasHandles(t) {
    const r = this[Nl];
    return r != null && r.has(t);
  }
  _override(t, r) {
    r === void 0 ? this.__accessor__.clearOverride(t) : this.__accessor__.override(t, r);
  }
  _clearOverride(t) {
    return this.__accessor__.clearOverride(t);
  }
  _overrideIfSome(t, r) {
    r == null ? this.__accessor__.clearOverride(t) : this.__accessor__.override(t, r);
  }
  _isOverridden(t) {
    return this.__accessor__.isOverridden(t);
  }
  notifyChange(t) {
    this.__accessor__.notifyChange(t);
  }
  _get(t) {
    return this.__accessor__.internalGet(t);
  }
  _set(t, r) {
    return this.__accessor__.internalSet(t, r), this;
  }
};
VF = Nl, zF = j$;
const Ak = new FinalizationRegistry((e) => {
  for (const t of e.values())
    t.destroy();
});
let Vv = class BF {
  constructor() {
    this._emitter = new BF.EventEmitter(this);
  }
  emit(t, r) {
    return this._emitter.emit(t, r);
  }
  on(t, r) {
    return this._emitter.on(t, r);
  }
  once(t, r) {
    return this._emitter.once(t, r);
  }
  hasEventListener(t) {
    return this._emitter.hasEventListener(t);
  }
};
(function(e) {
  class t {
    constructor(i = null) {
      this._target = i, this._listenersMap = null;
    }
    clear() {
      var i;
      (i = this._listenersMap) == null || i.clear(), this._listenersMap = null;
    }
    destroy() {
      this.clear();
    }
    emit(i, s) {
      const o = this._listenersMap && this._listenersMap.get(i);
      if (!o)
        return !1;
      const a = this._target || this;
      return [...o].forEach((l) => {
        l.call(a, s);
      }), o.length > 0;
    }
    on(i, s) {
      if (Array.isArray(i)) {
        const a = i.map((l) => this.on(l, s));
        return Uw(a);
      }
      if (i.includes(","))
        throw new TypeError("Evented.on() with a comma delimited string of event types is not supported");
      this._listenersMap || (this._listenersMap = /* @__PURE__ */ new Map());
      const o = this._listenersMap.get(i) || [];
      return o.push(s), this._listenersMap.set(i, o), { remove: () => {
        const a = this._listenersMap && this._listenersMap.get(i) || [], l = a.indexOf(s);
        l >= 0 && a.splice(l, 1);
      } };
    }
    once(i, s) {
      const o = this.on(i, (a) => {
        o.remove(), s.call(null, a);
      });
      return o;
    }
    hasEventListener(i) {
      const s = this._listenersMap && this._listenersMap.get(i);
      return s != null && s.length > 0;
    }
  }
  e.EventEmitter = t, e.EventedMixin = (n) => {
    let i = class extends n {
      constructor() {
        super(...arguments), this._emitter = new t();
      }
      destroy() {
        this._emitter.clear();
      }
      emit(s, o) {
        return this._emitter.emit(s, o);
      }
      on(s, o) {
        return this._emitter.on(s, o);
      }
      once(s, o) {
        return this._emitter.once(s, o);
      }
      hasEventListener(s) {
        return this._emitter.hasEventListener(s);
      }
    };
    return i = u([E("geoscene.core.Evented")], i), i;
  };
  let r = class extends Ae {
    constructor() {
      super(...arguments), this._emitter = new Vv.EventEmitter(this);
    }
    destroy() {
      this._emitter.clear();
    }
    emit(n, i) {
      return this._emitter.emit(n, i);
    }
    on(n, i) {
      return this._emitter.on(n, i);
    }
    once(n, i) {
      return this._emitter.once(n, i);
    }
    hasEventListener(n) {
      return this._emitter.hasEventListener(n);
    }
  };
  r = u([E("geoscene.core.Evented")], r), e.EventedAccessor = r;
})(Vv || (Vv = {}));
const Uu = Vv;
var vt;
(function(e) {
  e[e.ADD = 1] = "ADD", e[e.REMOVE = 2] = "REMOVE", e[e.MOVE = 4] = "MOVE";
})(vt || (vt = {}));
function H3(e) {
  return (t, r) => {
    t[r] = e;
  };
}
let t_ = class extends oF {
  notify() {
    const t = this._observers;
    if (t && t.length > 0) {
      const r = t.slice();
      for (const n of r)
        n.onInvalidated(), n.onCommitted();
    }
  }
};
var qa;
let kJ = class {
  constructor() {
    this.target = null, this.cancellable = !1, this.defaultPrevented = !1, this.item = void 0, this.type = void 0;
  }
  preventDefault() {
    this.cancellable && (this.defaultPrevented = !0);
  }
  reset(t) {
    this.defaultPrevented = !1, this.item = t;
  }
};
const qi = new Jd(kJ, void 0, (e) => {
  e.item = null, e.target = null, e.defaultPrevented = !1, e.cancellable = !1;
}), AJ = () => {
};
function C2(e) {
  return e ? e instanceof Wc ? e.toArray() : e.length ? Array.prototype.slice.apply(e) : [] : [];
}
function k2(e) {
  if (e && e.length)
    return e[0];
}
function PJ(e, t, r, n) {
  const i = Math.min(e.length - r, t.length - n);
  let s = 0;
  for (; s < i && e[r + s] === t[n + s]; )
    s++;
  return s;
}
function qF(e, t, r, n) {
  t && t.forEach((i, s, o) => {
    e.push(i), qF(e, r.call(n, i, s, o), r, n);
  });
}
const bl = /* @__PURE__ */ new Set(), wl = /* @__PURE__ */ new Set(), _l = /* @__PURE__ */ new Set(), A2 = /* @__PURE__ */ new Map();
let RJ = 0, Wc = qa = class extends Uu.EventedAccessor {
  static isCollection(e) {
    return e != null && e instanceof qa;
  }
  constructor(e) {
    super(e), this._chgListeners = [], this._notifications = null, this._timer = null, this._observable = new t_(), this.length = 0, this._items = [], Object.defineProperty(this, "uid", { value: RJ++ });
  }
  normalizeCtorArgs(e) {
    return e ? Array.isArray(e) || e instanceof qa ? { items: e } : e : {};
  }
  destroy() {
    this._removeAllRaw();
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  get items() {
    return Ve(this._observable), this._items;
  }
  set items(e) {
    this._emitBeforeChanges(vt.ADD) || (this._splice(0, this.length, C2(e)), this._emitAfterChanges(vt.ADD));
  }
  hasEventListener(e) {
    return e === "change" ? this._chgListeners.length > 0 : this._emitter.hasEventListener(e);
  }
  on(e, t) {
    if (e === "change") {
      const r = this._chgListeners, n = { removed: !1, callback: t };
      return r.push(n), this._notifications && this._notifications.push({ listeners: r.slice(), items: this._items.slice(), changes: [] }), { remove() {
        this.remove = AJ, n.removed = !0, r.splice(r.indexOf(n), 1);
      } };
    }
    return this._emitter.on(e, t);
  }
  once(e, t) {
    const r = this.on(e, t);
    return { remove() {
      r.remove();
    } };
  }
  add(e, t) {
    if (Ve(this._observable), this._emitBeforeChanges(vt.ADD))
      return this;
    const r = this.getNextIndex(t ?? null);
    return this._splice(r, 0, [e]), this._emitAfterChanges(vt.ADD), this;
  }
  addMany(e, t = this._items.length) {
    if (Ve(this._observable), !e || !e.length)
      return this;
    if (this._emitBeforeChanges(vt.ADD))
      return this;
    const r = this.getNextIndex(t);
    return this._splice(r, 0, C2(e)), this._emitAfterChanges(vt.ADD), this;
  }
  at(e) {
    if (Ve(this._observable), (e = Math.trunc(e) || 0) < 0 && (e += this.length), !(e < 0 || e >= this.length))
      return this._items[e];
  }
  removeAll() {
    if (Ve(this._observable), !this.length || this._emitBeforeChanges(vt.REMOVE))
      return [];
    const e = this._removeAllRaw();
    return this._emitAfterChanges(vt.REMOVE), e;
  }
  _removeAllRaw() {
    return this.length === 0 ? [] : this._splice(0, this.length) || [];
  }
  clone() {
    return Ve(this._observable), this._createNewInstance({ items: this._items.map(j) });
  }
  concat(...e) {
    Ve(this._observable);
    const t = e.map(C2);
    return this._createNewInstance({ items: this._items.concat(...t) });
  }
  drain(e, t) {
    if (Ve(this._observable), !this.length || this._emitBeforeChanges(vt.REMOVE))
      return;
    const r = this._splice(0, this.length), n = r.length;
    for (let i = 0; i < n; i++)
      e.call(t, r[i], i, r);
    this._emitAfterChanges(vt.REMOVE);
  }
  every(e, t) {
    return Ve(this._observable), this._items.every(e, t);
  }
  filter(e, t) {
    let r;
    return Ve(this._observable), r = arguments.length === 2 ? this._items.filter(e, t) : this._items.filter(e), this._createNewInstance({ items: r });
  }
  find(e, t) {
    return Ve(this._observable), this._items.find(e, t);
  }
  findIndex(e, t) {
    return Ve(this._observable), this._items.findIndex(e, t);
  }
  flatten(e, t) {
    Ve(this._observable);
    const r = [];
    return qF(r, this, e, t), new qa(r);
  }
  forEach(e, t) {
    return Ve(this._observable), this._items.forEach(e, t);
  }
  getItemAt(e) {
    return Ve(this._observable), this._items[e];
  }
  getNextIndex(e) {
    Ve(this._observable);
    const t = this.length;
    return (e = e ?? t) < 0 ? e = 0 : e > t && (e = t), e;
  }
  includes(e, t = 0) {
    return Ve(this._observable), this._items.includes(e, t);
  }
  indexOf(e, t = 0) {
    return Ve(this._observable), this._items.indexOf(e, t);
  }
  join(e = ",") {
    return Ve(this._observable), this._items.join(e);
  }
  lastIndexOf(e, t = this.length - 1) {
    return Ve(this._observable), this._items.lastIndexOf(e, t);
  }
  map(e, t) {
    Ve(this._observable);
    const r = this._items.map(e, t);
    return new qa({ items: r });
  }
  reorder(e, t = this.length - 1) {
    Ve(this._observable);
    const r = this.indexOf(e);
    if (r !== -1) {
      if (t < 0 ? t = 0 : t >= this.length && (t = this.length - 1), r !== t) {
        if (this._emitBeforeChanges(vt.MOVE))
          return e;
        this._splice(r, 1), this._splice(t, 0, [e]), this._emitAfterChanges(vt.MOVE);
      }
      return e;
    }
  }
  pop() {
    if (Ve(this._observable), !this.length || this._emitBeforeChanges(vt.REMOVE))
      return;
    const e = k2(this._splice(this.length - 1, 1));
    return this._emitAfterChanges(vt.REMOVE), e;
  }
  push(...e) {
    return Ve(this._observable), this._emitBeforeChanges(vt.ADD) || (this._splice(this.length, 0, e), this._emitAfterChanges(vt.ADD)), this.length;
  }
  reduce(e, t) {
    Ve(this._observable);
    const r = this._items;
    return arguments.length === 2 ? r.reduce(e, t) : r.reduce(e);
  }
  reduceRight(e, t) {
    Ve(this._observable);
    const r = this._items;
    return arguments.length === 2 ? r.reduceRight(e, t) : r.reduceRight(e);
  }
  remove(e) {
    return Ve(this._observable), this.removeAt(this.indexOf(e));
  }
  removeAt(e) {
    if (Ve(this._observable), e < 0 || e >= this.length || this._emitBeforeChanges(vt.REMOVE))
      return;
    const t = k2(this._splice(e, 1));
    return this._emitAfterChanges(vt.REMOVE), t;
  }
  removeMany(e) {
    if (Ve(this._observable), !e || !e.length || this._emitBeforeChanges(vt.REMOVE))
      return [];
    const t = e instanceof qa ? e.toArray() : e, r = this._items, n = [], i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s], a = r.indexOf(o);
      if (a > -1) {
        const l = 1 + PJ(t, r, s + 1, a + 1), c = this._splice(a, l);
        c && c.length > 0 && n.push.apply(n, c), s += l - 1;
      }
    }
    return this._emitAfterChanges(vt.REMOVE), n;
  }
  reverse() {
    if (Ve(this._observable), this._emitBeforeChanges(vt.MOVE))
      return this;
    const e = this._splice(0, this.length);
    return e && (e.reverse(), this._splice(0, 0, e)), this._emitAfterChanges(vt.MOVE), this;
  }
  shift() {
    if (Ve(this._observable), !this.length || this._emitBeforeChanges(vt.REMOVE))
      return;
    const e = k2(this._splice(0, 1));
    return this._emitAfterChanges(vt.REMOVE), e;
  }
  slice(e = 0, t = this.length) {
    return Ve(this._observable), this._createNewInstance({ items: this._items.slice(e, t) });
  }
  some(e, t) {
    return Ve(this._observable), this._items.some(e, t);
  }
  sort(e) {
    if (Ve(this._observable), !this.length || this._emitBeforeChanges(vt.MOVE))
      return this;
    const t = this._splice(0, this.length);
    return arguments.length ? t.sort(e) : t.sort(), this._splice(0, 0, t), this._emitAfterChanges(vt.MOVE), this;
  }
  splice(e, t, ...r) {
    Ve(this._observable);
    const n = (t ? vt.REMOVE : 0) | (r.length ? vt.ADD : 0);
    if (this._emitBeforeChanges(n))
      return [];
    const i = this._splice(e, t, r) || [];
    return this._emitAfterChanges(n), i;
  }
  toArray() {
    return Ve(this._observable), this._items.slice();
  }
  toJSON() {
    return Ve(this._observable), this.toArray();
  }
  toLocaleString() {
    return Ve(this._observable), this._items.toLocaleString();
  }
  toString() {
    return Ve(this._observable), this._items.toString();
  }
  unshift(...e) {
    return Ve(this._observable), !e.length || this._emitBeforeChanges(vt.ADD) || (this._splice(0, 0, e), this._emitAfterChanges(vt.ADD)), this.length;
  }
  _createNewInstance(e) {
    return new this.constructor(e);
  }
  _splice(e, t, r) {
    const n = this._items, i = this.itemType;
    let s, o;
    if (!this._notifications && this.hasEventListener("change") && (this._notifications = [{ listeners: this._chgListeners.slice(), items: this._items.slice(), changes: [] }], this._timer && this._timer.remove(), this._timer = nf(() => this._dispatchChange())), t) {
      if (o = n.splice(e, t), this.hasEventListener("before-remove")) {
        const a = qi.acquire();
        a.target = this, a.cancellable = !0;
        for (let l = 0, c = o.length; l < c; l++)
          s = o[l], a.reset(s), this.emit("before-remove", a), a.defaultPrevented && (o.splice(l, 1), n.splice(e, 0, s), e += 1, l -= 1, c -= 1);
        qi.release(a);
      }
      if (this.length = this._items.length, this.hasEventListener("after-remove")) {
        const a = qi.acquire();
        a.target = this, a.cancellable = !1;
        const l = o.length;
        for (let c = 0; c < l; c++)
          a.reset(o[c]), this.emit("after-remove", a);
        qi.release(a);
      }
    }
    if (r && r.length) {
      if (i) {
        const h = [];
        for (const f of r) {
          const m = i.ensureType(f);
          m == null && f != null || h.push(m);
        }
        r = h;
      }
      const a = this.hasEventListener("before-add"), l = this.hasEventListener("after-add"), c = e === this.length;
      if (a || l) {
        const h = qi.acquire();
        h.target = this, h.cancellable = !0;
        const f = qi.acquire();
        f.target = this, f.cancellable = !1;
        for (const m of r)
          a ? (h.reset(m), this.emit("before-add", h), h.defaultPrevented || (c ? n.push(m) : n.splice(e++, 0, m), this._set("length", n.length), l && (f.reset(m), this.emit("after-add", f)))) : (c ? n.push(m) : n.splice(e++, 0, m), this._set("length", n.length), f.reset(m), this.emit("after-add", f));
        qi.release(f), qi.release(h);
      } else {
        if (c)
          for (const h of r)
            n.push(h);
        else
          n.splice(e, 0, ...r);
        this._set("length", n.length);
      }
    }
    return (r && r.length || o && o.length) && this._notifyChangeEvent(r, o), o;
  }
  _emitBeforeChanges(e) {
    let t = !1;
    if (this.hasEventListener("before-changes")) {
      const r = qi.acquire();
      r.target = this, r.cancellable = !0, r.type = e, this.emit("before-changes", r), t = r.defaultPrevented, qi.release(r);
    }
    return t;
  }
  _emitAfterChanges(e) {
    if (this.hasEventListener("after-changes")) {
      const t = qi.acquire();
      t.target = this, t.cancellable = !1, t.type = e, this.emit("after-changes", t), qi.release(t);
    }
    this._observable.notify();
  }
  _notifyChangeEvent(e, t) {
    this.hasEventListener("change") && this._notifications && this._notifications[this._notifications.length - 1].changes.push({ added: e, removed: t });
  }
  _dispatchChange() {
    if (this._timer && (this._timer.remove(), this._timer = null), !this._notifications)
      return;
    const e = this._notifications;
    this._notifications = null;
    for (const t of e) {
      const r = t.changes;
      bl.clear(), wl.clear(), _l.clear();
      for (const { added: l, removed: c } of r) {
        if (l)
          if (_l.size === 0 && wl.size === 0)
            for (const h of l)
              bl.add(h);
          else
            for (const h of l)
              wl.has(h) ? (_l.add(h), wl.delete(h)) : _l.has(h) || bl.add(h);
        if (c)
          if (_l.size === 0 && bl.size === 0)
            for (const h of c)
              wl.add(h);
          else
            for (const h of c)
              bl.has(h) ? bl.delete(h) : (_l.delete(h), wl.add(h));
      }
      const n = jn.acquire();
      bl.forEach((l) => {
        n.push(l);
      });
      const i = jn.acquire();
      wl.forEach((l) => {
        i.push(l);
      });
      const s = this._items, o = t.items, a = jn.acquire();
      if (_l.forEach((l) => {
        o.indexOf(l) !== s.indexOf(l) && a.push(l);
      }), t.listeners && (n.length || i.length || a.length)) {
        const l = { target: this, added: n, removed: i, moved: a }, c = t.listeners.length;
        for (let h = 0; h < c; h++) {
          const f = t.listeners[h];
          f.removed || f.callback.call(this, l);
        }
      }
      jn.release(n), jn.release(i), jn.release(a);
    }
    bl.clear(), wl.clear(), _l.clear();
  }
};
Wc.ofType = (e) => {
  if (!e)
    return qa;
  if (A2.has(e))
    return A2.get(e);
  let t = null;
  if (typeof e == "function")
    t = e.prototype.declaredClass;
  else if (e.base)
    t = e.base.prototype.declaredClass;
  else
    for (const n in e.typeMap) {
      const i = e.typeMap[n].prototype.declaredClass;
      t ? t += ` | ${i}` : t = i;
    }
  let r = class extends qa {
  };
  return u([H3({ Type: e, ensureType: typeof e == "function" ? br(e) : na(e) })], r.prototype, "itemType", void 0), r = u([E(`geoscene.core.Collection<${t}>`)], r), A2.set(e, r), r;
}, u([d()], Wc.prototype, "length", void 0), u([d()], Wc.prototype, "items", null), Wc = qa = u([E("geoscene.core.Collection")], Wc);
const je = Wc;
function Ed(e, t, r = je) {
  return t || (t = new r()), t === e || (t.removeAll(), LJ(e) ? t.addMany(e) : e && t.add(e)), t;
}
function GF(e) {
  return e;
}
function LJ(e) {
  return e && (Array.isArray(e) || "items" in e && Array.isArray(e.items));
}
const Pk = /* @__PURE__ */ new Set();
function NJ(e, t, r = !1) {
  r && Pk.has(t) || (r && Pk.add(t), e.warn(`🛑 DEPRECATED - ${t}`));
}
function V$(e, t, r = {}) {
  if (U("geoscene-deprecation-warnings")) {
    const { moduleName: n } = r;
    $b(e, `Property: ${(n ? n + "::" : "") + t}`, r);
  }
}
function $b(e, t, r = {}) {
  if (U("geoscene-deprecation-warnings")) {
    const { replacement: n, version: i, see: s, warnOnce: o } = r;
    let a = t;
    n && (a += `
	🛠️ Replacement: ${n}`), i && (a += `
	⚙️ Version: ${i}`), s && (a += `
	🔗 See ${s} for more details.`), NJ(e, a, o);
  }
}
let FJ = class HF {
  constructor() {
    this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !1;
  }
  clone(t) {
    const r = new HF();
    return this._values.forEach((n, i) => {
      t && t.has(i) || r.set(i, j(n.value), n.origin);
    }), r;
  }
  get(t, r) {
    r = this._normalizeOrigin(r);
    const n = this._values.get(t);
    return r == null || (n == null ? void 0 : n.origin) === r ? n == null ? void 0 : n.value : void 0;
  }
  originOf(t) {
    var r;
    return ((r = this._values.get(t)) == null ? void 0 : r.origin) ?? Qe.USER;
  }
  keys(t) {
    t = this._normalizeOrigin(t);
    const r = [...this._values.keys()];
    return t == null ? r : r.filter((n) => {
      var i;
      return ((i = this._values.get(n)) == null ? void 0 : i.origin) === t;
    });
  }
  set(t, r, n) {
    if ((n = this._normalizeOrigin(n)) === Qe.DEFAULTS) {
      const i = this._values.get(t);
      if (i && i.origin != null && i.origin > n)
        return;
    }
    this._values.set(t, new DJ(r, n));
  }
  delete(t, r) {
    var n;
    (r = this._normalizeOrigin(r)) != null && ((n = this._values.get(t)) == null ? void 0 : n.origin) !== r || this._values.delete(t);
  }
  has(t, r) {
    var n;
    return (r = this._normalizeOrigin(r)) != null ? ((n = this._values.get(t)) == null ? void 0 : n.origin) === r : this._values.has(t);
  }
  forEach(t) {
    this._values.forEach(({ value: r }, n) => t(r, n));
  }
  _normalizeOrigin(t) {
    if (t != null)
      return t === Qe.DEFAULTS ? t : Qe.USER;
  }
}, DJ = class {
  constructor(t, r) {
    this.value = t, this.origin = r;
  }
};
function WF(e, t, r) {
  t.keys().forEach((i) => {
    r.set(i, t.get(i), Qe.DEFAULTS);
  });
  const n = e.metadatas;
  Object.keys(n).forEach((i) => {
    e.internalGet(i) && r.set(i, e.internalGet(i), Qe.DEFAULTS);
  });
}
function jJ(e, t, r) {
  if (!e || !e.read || e.read.enabled === !1 || !e.read.source)
    return !1;
  const n = e.read.source;
  if (typeof n == "string") {
    if (n === t || n.includes(".") && n.indexOf(t) === 0 && hk(n, r))
      return !0;
  } else
    for (const i of n)
      if (i === t || i.includes(".") && i.indexOf(t) === 0 && hk(i, r))
        return !0;
  return !1;
}
function VJ(e) {
  return e && (!e.read || e.read.enabled !== !1 && !e.read.source);
}
function zJ(e, t, r, n, i) {
  let s = F$(t[r], i);
  VJ(s) && (e[r] = !0);
  for (const o of Object.getOwnPropertyNames(t))
    s = F$(t[o], i), jJ(s, r, n) && (e[o] = !0);
}
function UJ(e, t, r, n) {
  const i = r.metadatas, s = $J(i[t], n), o = s == null ? void 0 : s.default;
  if (o === void 0)
    return;
  const a = typeof o == "function" ? o.call(e, t, n) : o;
  a !== void 0 && r.set(t, a);
}
const JF = { origin: "service" };
function ZF(e, t, r = JF) {
  if (!t || typeof t != "object")
    return;
  const n = Bn(e), i = n.metadatas, s = {};
  for (const o of Object.getOwnPropertyNames(t))
    zJ(s, i, o, t, r);
  n.setDefaultOrigin(r.origin);
  for (const o of Object.getOwnPropertyNames(s)) {
    const a = F$(i[o], r).read, l = a && a.source;
    let c;
    c = l && typeof l == "string" ? kg(t, l) : t[o], a && a.reader && (c = a.reader.call(e, c, t, r)), c !== void 0 && n.set(o, c);
  }
  if (!r || !r.ignoreDefaults) {
    n.setDefaultOrigin("defaults");
    for (const o of Object.getOwnPropertyNames(i))
      s[o] || UJ(e, o, n, r);
  }
  n.setDefaultOrigin("user");
}
function BJ(e, t, r, n = JF) {
  var s;
  const i = { ...n, messages: [] };
  r(i), (s = i.messages) == null || s.forEach((o) => {
    o.type !== "warning" || e.loaded ? n && n.messages && n.messages.push(o) : e.loadWarnings.push(o);
  });
}
function qJ(e, t, r, n, i) {
  var o, a;
  const s = {};
  return (a = (o = t.write) == null ? void 0 : o.writer) == null || a.call(e, n, s, r, i), s;
}
function KF(e, t, r, n, i, s) {
  if (!n || !n.write)
    return !1;
  const o = e.get(r);
  if (!i && n.write.overridePolicy) {
    const a = n.write.overridePolicy.call(e, o, r, s ?? void 0);
    a !== void 0 && (i = a);
  }
  if (i || (i = n.write), !i || i.enabled === !1)
    return !1;
  if ((o === null && !i.allowNull && !i.writerEnsuresNonNull || o === void 0) && i.isRequired) {
    const a = new G("web-document-write:property-required", `Missing value for required property '${r}' on '${e.declaredClass}'`, { propertyName: r, target: e });
    return a && s && s.messages ? s.messages.push(a) : a && !s && se.getLogger("geoscene.core.accessorSupport.write").error(a.name, a.message), !1;
  }
  return !(o === void 0 || o === null && !i.allowNull && !i.writerEnsuresNonNull || !i.alwaysWriteDefaults && (!t.store.multipleOriginsSupported || t.store.originOf(r) === Qe.DEFAULTS) && GJ(e, r, s, n, o) || !i.ignoreOrigin && s && s.origin && t.store.multipleOriginsSupported && t.store.originOf(r) < bu(s.origin));
}
function GJ(e, t, r, n, i) {
  const s = n.default;
  if (s === void 0)
    return !1;
  if (n.defaultEquals != null)
    return n.defaultEquals(i);
  if (typeof s == "function") {
    if (Array.isArray(i)) {
      const o = s.call(e, t, r ?? void 0);
      return Bw(o, i);
    }
    return !1;
  }
  return s === i;
}
function HJ(e, t, r, n) {
  const i = Bn(e), s = i.metadatas, o = DF(s[t], n);
  return !!o && KF(e, i, t, o, r, n);
}
function YF(e, t, r) {
  var s, o;
  if (e && typeof e.toJSON == "function" && (!e.toJSON.isDefaultToJSON || !e.write))
    return Nv(t, e.toJSON(r));
  const n = Bn(e), i = n.metadatas;
  for (const a in i) {
    const l = DF(i[a], r);
    if (!KF(e, n, a, l, void 0, r))
      continue;
    const c = e.get(a), h = qJ(e, l, l.write && typeof l.write.target == "string" ? l.write.target : a, c, r);
    Object.keys(h).length > 0 && (t = Nv(t, h), (o = (s = r == null ? void 0 : r.resources) == null ? void 0 : s.pendingOperations) != null && o.length && r.resources.pendingOperations.push(Promise.all(r.resources.pendingOperations).then(() => Nv(t, h, () => "replace-arrays"))), r && r.writtenProperties && r.writtenProperties.push({ target: e, propName: a, oldOrigin: dW(n.store.originOf(a)), newOrigin: r.origin }));
  }
  return t;
}
const Lg = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r);
      const n = Bn(this), i = n.store, s = new FJ();
      n.store = s, WF(n, i, s);
    }
    read(r, n) {
      ZF(this, r, n);
    }
    write(r, n) {
      return YF(this, r ?? {}, n);
    }
    toJSON(r) {
      return this.write({}, r);
    }
    static fromJSON(r, n) {
      return WJ.call(this, r, n);
    }
  };
  return t = u([E("geoscene.core.JSONSupport")], t), t.prototype.toJSON.isDefaultToJSON = !0, t;
};
function WJ(e, t) {
  if (!e)
    return null;
  if (e.declaredClass)
    throw new Error("JSON object is already hydrated");
  const r = new this();
  return r.read(e, t), r;
}
let re = class extends Lg(Ae) {
};
re = u([E("geoscene.core.JSONSupport")], re);
var lu;
(function(e) {
  e[e.PENDING = 0] = "PENDING", e[e.RESOLVED = 1] = "RESOLVED", e[e.REJECTED = 2] = "REJECTED";
})(lu || (lu = {}));
let JJ = class {
  constructor() {
    this._resolver = vs(), this._status = lu.PENDING, this._resolvingPromises = [], this._resolver.promise.then(() => {
      this._status = lu.RESOLVED, this._cleanUp();
    }, () => {
      this._status = lu.REJECTED, this._cleanUp();
    }), this.promise = this._resolver.promise;
  }
  destroy() {
    this._cleanUp();
  }
  addResolvingPromise(t) {
    this._resolvingPromises.push(t), this._tryResolve();
  }
  isResolved() {
    return this._status === lu.RESOLVED;
  }
  isRejected() {
    return this._status === lu.REJECTED;
  }
  isFulfilled() {
    return this._status !== lu.PENDING;
  }
  abort() {
    this._resolver.reject(rr());
  }
  _cleanUp() {
    this._allPromise = null, this._resolvingPromises = null;
  }
  _tryResolve() {
    if (this.isFulfilled())
      return;
    const t = vs(), r = [...this._resolvingPromises, t.promise], n = this._allPromise = Promise.all(r);
    n.then(() => {
      this.isFulfilled() || this._allPromise !== n || this._resolver.resolve();
    }, (i) => {
      this.isFulfilled() || this._allPromise !== n || Fi(i) || this._resolver.reject(i);
    }), t.resolve();
  }
};
const r_ = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this._promiseProps = new JJ(), this.addResolvingPromise(Promise.resolve());
    }
    destroy() {
      var r;
      (r = this._promiseProps) == null || r.destroy();
    }
    isResolved() {
      return this._promiseProps.isResolved();
    }
    isRejected() {
      return this._promiseProps.isRejected();
    }
    isFulfilled() {
      return this._promiseProps.isFulfilled();
    }
    when(r, n) {
      return this._promiseProps.promise.then(() => this).then(r, n);
    }
    catch(r) {
      return this.when(null, r);
    }
    addResolvingPromise(r) {
      r && !this._promiseProps.isFulfilled() && this._promiseProps.addResolvingPromise("_promiseProps" in r ? r.when() : r);
    }
  };
  return t = u([E("geoscene.core.Promise")], t), t;
};
let xb = class extends r_(Ae) {
};
xb = u([E("geoscene.core.Promise")], xb);
const ZJ = "not-loaded", KJ = "loading", YJ = "failed", Rk = "loaded", QF = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this._loadController = null, this.loadError = null, this.loadStatus = "not-loaded", this._set("loadWarnings", []), this.addResolvingPromise(new Promise((n) => {
        const i = this.load.bind(this);
        this.load = (s) => {
          const o = new Promise((a, l) => {
            const c = z3(s, l);
            this.destroyed && l(new G("load:instance-destroyed", `Instance of '${this.declaredClass || this.constructor.name}' is already destroyed`, { instance: this })), this.when(a, l).finally(() => {
              c && c.remove();
            });
          });
          if (this.loadStatus === ZJ) {
            this._set("loadStatus", KJ);
            const a = this._loadController = new AbortController();
            i({ signal: a.signal }), fs(a.signal, () => {
              this._promiseProps.abort();
            });
          }
          return n(), o;
        };
      })), this.when(() => {
        this._set("loadStatus", Rk), this._loadController = null;
      }, (n) => {
        this._set("loadStatus", YJ), this._set("loadError", n), this._loadController = null;
      });
    }
    destroy() {
      this._loadController = zy(this._loadController), this._set("loadError", null), this._set("loadWarnings", []);
    }
    get loaded() {
      return this.loadStatus === Rk;
    }
    get loadWarnings() {
      return this._get("loadWarnings");
    }
    load() {
      return null;
    }
    cancelLoad() {
      var r;
      return this.isFulfilled() || (this._set("loadError", new G("load:cancelled", "Cancelled")), (r = this._loadController) == null || r.abort()), this;
    }
  };
  return u([d({ readOnly: !0 })], t.prototype, "loaded", null), u([d({ readOnly: !0 })], t.prototype, "loadError", void 0), u([d({ clonable: !1 })], t.prototype, "loadStatus", void 0), u([d({ type: [bs], readOnly: !0 })], t.prototype, "loadWarnings", null), t = u([E("geoscene.core.Loadable")], t), t;
};
let cm = class extends QF(xb) {
};
cm = u([E("geoscene.core.Loadable")], cm), function(e) {
  function t(r) {
    return !(!r || !r.load);
  }
  e.LoadableMixin = QF, e.isLoadable = t;
}(cm || (cm = {}));
const sl = cm;
function dPe(e, t, r) {
  return Zd(e.map((n, i) => t.apply(r, [n, i])));
}
async function QJ(e, t, r) {
  return (await Zd(e.map((n, i) => t.apply(r, [n, i])))).map((n) => n.value);
}
function W3(e) {
  return { ok: !0, value: e };
}
function J3(e) {
  return { ok: !1, error: e };
}
function XJ(e) {
  return e != null && e.ok === !0 ? e.value : null;
}
function eZ(e) {
  return e != null && e.ok === !1 ? e.error : null;
}
async function n_(e) {
  if (e == null)
    return { ok: !1, error: new Error("no promise provided") };
  try {
    return W3(await e);
  } catch (t) {
    return J3(t);
  }
}
async function pPe(e) {
  try {
    return W3(await e);
  } catch (t) {
    return Go(t), J3(t);
  }
}
function Z3(e, t) {
  return new Fl(e, t);
}
let Fl = class extends Ae {
  get value() {
    return XJ(this._result);
  }
  get error() {
    return eZ(this._result);
  }
  get finished() {
    return this._result != null;
  }
  constructor(t, r) {
    super({}), this._result = null, this._abortHandle = null, this.abort = () => {
      this._abortController = zy(this._abortController);
    }, this.remove = this.abort, this._abortController = new AbortController();
    const { signal: n } = this._abortController;
    this.promise = t(n), this.promise.then((i) => {
      this._result = W3(i), this._cleanup();
    }, (i) => {
      this._result = J3(i), this._cleanup();
    }), this._abortHandle = fs(r, this.abort);
  }
  normalizeCtorArgs() {
    return {};
  }
  destroy() {
    this.abort();
  }
  _cleanup() {
    this._abortHandle = tr(this._abortHandle), this._abortController = null;
  }
};
u([d()], Fl.prototype, "value", null), u([d()], Fl.prototype, "error", null), u([d()], Fl.prototype, "finished", null), u([d()], Fl.prototype, "promise", void 0), u([d()], Fl.prototype, "_result", void 0), Fl = u([E("geoscene.core.asyncUtils.ReactiveTask")], Fl);
async function XF(e, t) {
  return await e.load(), tZ(e, t);
}
async function tZ(e, t) {
  const r = [], n = (...s) => {
    for (const o of s)
      o != null && (Array.isArray(o) ? n(...o) : je.isCollection(o) ? o.forEach((a) => n(a)) : sl.isLoadable(o) && r.push(o));
  };
  t(n);
  let i = null;
  if (await QJ(r, async (s) => {
    const o = await n_(rZ(s) ? s.loadAll() : s.load());
    o.ok !== !1 || i || (i = o);
  }), i)
    throw i.error;
  return e;
}
function rZ(e) {
  return "loadAll" in e && typeof e.loadAll == "function";
}
const nZ = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i, iZ = { devext: { customBaseUrl: "mapsdevext.geoscene.cn", portalHostname: "devext.geoscene.cn" }, qaext: { customBaseUrl: "mapsqa.geoscene.cn", portalHostname: "qaext.geoscene.cn" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function Lk(e) {
  const t = e == null ? void 0 : e.match(nZ);
  if (!t)
    return null;
  const [, r, n, i] = t;
  if (!r)
    return null;
  let s = null, o = null, a = null;
  const { devext: l, qaext: c, www: h } = iZ;
  if (n)
    if (s = r, i)
      switch (i.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: o, portalHostname: a } = l);
          break;
        case "qa":
          ({ customBaseUrl: o, portalHostname: a } = c);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: o, portalHostname: a } = h);
  else
    switch (r.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: o, portalHostname: a } = l);
        break;
      case "qaext":
        ({ customBaseUrl: o, portalHostname: a } = c);
        break;
      case "www":
        ({ customBaseUrl: o, portalHostname: a } = h);
        break;
      default:
        return null;
    }
  return { customBaseUrl: o, isPortal: !1, portalHostname: a, urlKey: s };
}
function sZ(e) {
  return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e);
}
function oZ(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r.buffer;
}
const aZ = se.getLogger("geoscene.core.urlUtils"), of = bt.request, Nk = "geoscene/config: geosceneConfig.request.proxyUrl is not set.", e6 = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i, t6 = /^\s*http:/i, lZ = /^\s*https:/i, uZ = /^\s*file:/i, cZ = /:\d+$/, dZ = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i, pZ = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"), hZ = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
let gh = class {
  constructor(t = "") {
    this.uri = t, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let r = this.uri.match(pZ);
    this.scheme = r[2] || (r[1] ? "" : null), this.authority = r[4] || (r[3] ? "" : null), this.path = r[5], this.query = r[7] || (r[6] ? "" : null), this.fragment = r[9] || (r[8] ? "" : null), this.authority != null && (r = this.authority.match(hZ), this.user = r[3] || null, this.password = r[4] || null, this.host = r[6] || r[7], this.port = r[9] || null);
  }
  toString() {
    return this.uri;
  }
};
const S0 = {}, fZ = new gh(bt.applicationUrl);
let Sn = fZ;
const mZ = yZ();
let K3 = mZ;
const Y3 = () => Sn, mPe = () => K3;
function yZ() {
  const e = Sn.path, t = e.substring(0, e.lastIndexOf(e.split("/")[e.split("/").length - 1]));
  return `${`${Sn.scheme}://${Sn.host}${Sn.port != null ? `:${Sn.port}` : ""}`}${t}`;
}
function Di(e) {
  if (!e)
    return null;
  const t = { path: null, query: null }, r = new gh(e), n = e.indexOf("?");
  return r.query === null ? t.path = e : (t.path = e.substring(0, n), t.query = Q3(r.query)), r.fragment && (t.hash = r.fragment, r.query === null && (t.path = t.path.substring(0, t.path.length - (r.fragment.length + 1)))), t;
}
function Q3(e) {
  const t = e.split("&"), r = {};
  for (const n of t) {
    if (!n)
      continue;
    const i = n.indexOf("=");
    let s, o;
    i < 0 ? (s = decodeURIComponent(n), o = "") : (s = decodeURIComponent(n.slice(0, i)), o = decodeURIComponent(n.slice(i + 1)));
    let a = r[s];
    typeof a == "string" && (a = r[s] = [a]), Array.isArray(a) ? a.push(o) : r[s] = o;
  }
  return r;
}
function Fk(e) {
  return e && typeof e == "object" && "toJSON" in e && typeof e.toJSON == "function";
}
function Gy(e, t) {
  return e ? t && typeof t == "function" ? Object.keys(e).map((r) => encodeURIComponent(r) + "=" + encodeURIComponent(t(r, e[r]))).join("&") : Object.keys(e).map((r) => {
    const n = e[r];
    if (n == null)
      return "";
    const i = encodeURIComponent(r) + "=", s = t && t[r];
    return s ? i + encodeURIComponent(s(n)) : Array.isArray(n) ? n.map((o) => Fk(o) ? i + encodeURIComponent(JSON.stringify(o)) : i + encodeURIComponent(o)).join("&") : Fk(n) ? i + encodeURIComponent(JSON.stringify(n)) : i + encodeURIComponent(n);
  }).filter((r) => r).join("&") : "";
}
function gZ(e = !1) {
  let t, r = of.proxyUrl;
  if (typeof e == "string") {
    t = xZ(e);
    const n = i_(e);
    n && (r = n.proxyUrl);
  } else
    t = !!e;
  if (!r)
    throw aZ.warn(Nk), new G("urlutils:proxy-not-set", Nk);
  return t && z$() && (r = nM(r)), Di(r);
}
function yPe(e) {
  const t = i_(e);
  let r, n;
  if (t) {
    const i = X3(t.proxyUrl);
    r = i.path, n = i.query ? Q3(i.query) : null;
  }
  if (r) {
    const i = Di(e);
    e = r + "?" + i.path;
    const s = Gy({ ...n, ...i.query });
    s && (e = `${e}?${s}`);
  }
  return e;
}
const Ff = { path: "", query: "" };
function X3(e) {
  const t = e.indexOf("?");
  return t !== -1 ? (Ff.path = e.slice(0, t), Ff.query = e.slice(t + 1)) : (Ff.path = e, Ff.query = null), Ff;
}
function r6(e) {
  return e = (e = Eb(e = CZ(e = X3(e).path), !0)).toLowerCase();
}
function vZ(e) {
  const t = { proxyUrl: e.proxyUrl, urlPrefix: r6(e.urlPrefix) }, r = of.proxyRules, n = t.urlPrefix;
  let i = r.length;
  for (let s = 0; s < r.length; s++) {
    const o = r[s].urlPrefix;
    if (n.indexOf(o) === 0) {
      if (n.length === o.length)
        return -1;
      i = s;
      break;
    }
    o.indexOf(n) === 0 && (i = s + 1);
  }
  return r.splice(i, 0, t), i;
}
function i_(e) {
  const t = of.proxyRules, r = r6(e);
  for (let n = 0; n < t.length; n++)
    if (r.indexOf(t[n].urlPrefix) === 0)
      return t[n];
}
function bZ(e, t) {
  if (!e || !t)
    return !1;
  e = Tb(e), t = Tb(t);
  const r = Lk(e), n = Lk(t);
  return r != null && n != null ? r.portalHostname === n.portalHostname : r == null && n == null && Ph(e, t, !0);
}
function n6(e, t) {
  return e = Tb(e), t = Tb(t), Eb(e) === Eb(t);
}
function Tb(e) {
  const t = (e = ao(e)).indexOf("/sharing");
  return t > 0 ? e.substring(0, t) : e.replace(/\/+$/, "");
}
function i6(e) {
  const t = (n) => n == null || n instanceof RegExp && n.test(e) || typeof n == "string" && e.startsWith(n), r = of.interceptors;
  if (r) {
    for (const n of r)
      if (Array.isArray(n.urls)) {
        if (n.urls.some(t))
          return n;
      } else if (t(n.urls))
        return n;
  }
  return null;
}
function Ph(e, t, r = !1) {
  if (!e || !t)
    return !1;
  const n = B$(e), i = B$(t);
  return !(!r && n.scheme !== i.scheme) && n.host != null && i.host != null && n.host.toLowerCase() === i.host.toLowerCase() && n.port === i.port;
}
function eM(e) {
  if (typeof e == "string") {
    if (!Ai(e))
      return !0;
    e = B$(e);
  }
  if (Ph(e, Sn))
    return !0;
  const t = of.trustedServers || [];
  for (let r = 0; r < t.length; r++) {
    const n = wZ(t[r]);
    for (let i = 0; i < n.length; i++)
      if (Ph(e, n[i]))
        return !0;
  }
  return !1;
}
function wZ(e) {
  return S0[e] || (rM(e) || ia(e) ? S0[e] = [new gh(cs(e))] : S0[e] = [new gh(`http://${e}`), new gh(`https://${e}`)]), S0[e];
}
function cs(e, t = K3, r) {
  return ia(e) ? r && r.preserveProtocolRelative ? e : Sn.scheme === "http" && Sn.authority === lo(e).slice(2) ? `http:${e}` : `https:${e}` : rM(e) ? e : Rh(e[0] === "/" ? MZ(t) : t, e);
}
function tM(e, t = K3, r) {
  if (e == null || !Ai(e))
    return e;
  const n = ao(e), i = n.toLowerCase(), s = ao(t).toLowerCase().replace(/\/+$/, ""), o = r ? ao(r).toLowerCase().replace(/\/+$/, "") : null;
  if (o && s.indexOf(o) !== 0)
    return e;
  const a = (f, m, y) => (y = f.indexOf(m, y)) === -1 ? f.length : y;
  let l = a(i, "/", i.indexOf("//") + 2), c = -1;
  for (; i.slice(0, l + 1) === s.slice(0, l) + "/" && (c = l + 1, l !== i.length); )
    l = a(i, "/", l + 1);
  if (c === -1 || o && c < o.length)
    return e;
  e = n.slice(c);
  const h = s.slice(c - 1).replaceAll(/[^/]+/g, "").length;
  if (h > 0)
    for (let f = 0; f < h; f++)
      e = `../${e}`;
  else
    e = `./${e}`;
  return e;
}
function ao(e) {
  return e = PZ(e = AZ(e = kZ(e = cs(e = e.trim()))));
}
function Rh(...e) {
  const t = e.filter(kh);
  if (!t || !t.length)
    return;
  const r = [];
  if (Ai(t[0])) {
    const i = t[0], s = i.indexOf("//");
    s !== -1 && (r.push(i.slice(0, s + 1)), EZ(t[0]) && (r[0] += "/"), t[0] = i.slice(s + 2));
  } else
    t[0][0] === "/" && r.push("");
  const n = t.reduce((i, s) => s ? i.concat(s.split("/")) : i, []);
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    s === ".." && r.length > 0 && r[r.length - 1] !== ".." ? r.pop() : (!s && i === n.length - 1 || s && (s !== "." || r.length === 0)) && r.push(s);
  }
  return r.join("/");
}
function lo(e, t = !1) {
  if (e == null || s_(e) || Kd(e))
    return null;
  let r = e.indexOf("://");
  if (r === -1 && ia(e))
    r = 2;
  else {
    if (r === -1)
      return null;
    r += 3;
  }
  const n = e.indexOf("/", r);
  return n !== -1 && (e = e.slice(0, n)), t && (e = Eb(e, !0)), e;
}
function Ai(e) {
  return ia(e) || rM(e);
}
function s_(e) {
  return e != null && e.slice(0, 5) === "blob:";
}
function Kd(e) {
  return e != null && e.slice(0, 5) === "data:";
}
function _Z(e) {
  const t = Hy(e);
  return t && t.isBase64 ? oZ(t.data) : null;
}
function gPe(e) {
  return btoa(String.fromCharCode.apply(null, e)).replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
const SZ = /^data:(.*?)(;base64)?,(.*)$/;
function Hy(e) {
  const t = e.match(SZ);
  if (!t)
    return null;
  const [, r, n, i] = t;
  return { mediaType: r, isBase64: !!n, data: i };
}
function s6(e) {
  return e.isBase64 ? `data:${e.mediaType};base64,${e.data}` : `data:${e.mediaType},${e.data}`;
}
function vPe(e) {
  const t = _Z(e);
  if (!t)
    return null;
  const r = Hy(e);
  return new Blob([t], { type: r.mediaType });
}
function bPe(e, t) {
  $Z(e, t);
}
function $Z(e, t) {
  if (!e)
    return !1;
  const r = document.createElement("a");
  if (!("download" in r))
    return !1;
  const n = URL.createObjectURL(e);
  return r.download = t, r.href = n, r.style.display = "none", document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(n), !0;
}
function ia(e) {
  return e != null && e[0] === "/" && e[1] === "/";
}
function rM(e) {
  return e != null && e6.test(e);
}
function xZ(e) {
  return e != null && lZ.test(e) || Sn.scheme === "https" && ia(e);
}
function TZ(e) {
  return e != null && t6.test(e) || Sn.scheme === "http" && ia(e);
}
function EZ(e) {
  return e != null && uZ.test(e);
}
function nM(e) {
  return ia(e) ? `https:${e}` : e.replace(t6, "https:");
}
function IZ() {
  return Sn.scheme === "http";
}
function z$() {
  return Sn.scheme === "https";
}
function Eb(e, t = !1) {
  return ia(e) ? e.slice(2) : (e = e.replace(e6, ""), t && e.length > 1 && e[0] === "/" && e[1] === "/" && (e = e.slice(2)), e);
}
function MZ(e) {
  const t = e.indexOf("//"), r = e.indexOf("/", t + 2);
  return r === -1 ? e : e.slice(0, r);
}
function OZ(e) {
  let t = 0;
  if (Ai(e)) {
    const n = e.indexOf("//");
    n !== -1 && (t = n + 2);
  }
  const r = e.lastIndexOf("/");
  return r < t ? e : e.slice(0, r + 1);
}
function wPe(e, t) {
  if (!e)
    return "";
  const r = Di(e).path.replace(/\/+$/, ""), n = r.substring(r.lastIndexOf("/") + 1);
  if (!(t != null && t.length))
    return n;
  const i = new RegExp(`.(${t.join("|")})$`, "ig");
  return n.replace(i, "");
}
function CZ(e) {
  return e && e[e.length - 1] === "/" ? e : `${e}/`;
}
function o6(e) {
  return e.replace(/\/+$/, "");
}
function kZ(e) {
  if (/^https?:\/\//i.test(e)) {
    const t = X3(e);
    e = (e = t.path.replaceAll(/\/{2,}/g, "/")).replace("/", "//"), t.query && (e += `?${t.query}`);
  }
  return e;
}
function AZ(e) {
  return e.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function PZ(e) {
  const t = of.httpsDomains;
  if (!TZ(e))
    return e;
  const r = e.indexOf("/", 7);
  let n;
  if (n = r === -1 ? e : e.slice(0, r), n = n.toLowerCase().slice(7), cZ.test(n)) {
    if (!n.endsWith(":80"))
      return e;
    n = n.slice(0, -3), e = e.replace(":80", "");
  }
  return IZ() && n === Sn.authority && !dZ.test(e) || (z$() && n === Sn.authority || t && t.some((i) => n === i || n.endsWith(`.${i}`)) || z$() && !i_(e)) && (e = nM(e)), e;
}
function U$(e, t, r) {
  if (!(t && r && e && Ai(e)))
    return e;
  const n = e.indexOf("//"), i = e.indexOf("/", n + 2), s = e.indexOf(":", n + 2), o = Math.min(i < 0 ? e.length : i, s < 0 ? e.length : s);
  return e.slice(n + 2, o).toLowerCase() !== t.toLowerCase() ? e : `${e.slice(0, n + 2)}${r}${e.slice(o)}`;
}
function B$(e) {
  return typeof e == "string" ? new gh(cs(e)) : (e.scheme || (e.scheme = Sn.scheme), e);
}
function _Pe(e) {
  return RZ.test(e);
}
function a6(e, t) {
  const r = Di(e), n = Object.keys(r.query || {});
  return n.length > 0 && t && t.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${n.join(", ")}.`), r.path;
}
function l6(e, t, r) {
  const n = Di(e), i = n.query || {};
  return i[t] = String(r), `${n.path}?${Gy(i)}`;
}
function P2(e, t) {
  const r = Di(e), n = r.query || {};
  for (const s in t)
    n[s] = t[s];
  const i = Gy(n);
  return i ? `${r.path}?${i}` : r.path;
}
function SPe(e) {
  if (e == null)
    return null;
  const t = e.match(u6);
  return t ? t[2] : null;
}
function Dk(e) {
  if (e == null)
    return null;
  const t = e.match(u6);
  return t ? { path: t[1], extension: t[2] } : { path: e, extension: null };
}
async function $Pe(e) {
  return typeof e == "string" ? Hy(e) ?? { data: e } : new Promise((t, r) => {
    const n = new FileReader();
    n.readAsDataURL(e), n.onload = () => t(Hy(n.result)), n.onerror = (i) => r(i);
  });
}
const u6 = /([^.]*)\.([^\/]*)$/, RZ = /(^data:image\/svg|\.svg$)/i;
function ge(e, t, r) {
  let n, i;
  return t === void 0 ? (i = e, n = [void 0]) : typeof t != "string" ? (i = e, n = [void 0], r = t) : (i = t, n = Array.isArray(e) ? e : [e]), (s, o) => {
    const a = s.constructor.prototype;
    for (const l of n) {
      const c = kF(s, l, i);
      c.write && typeof c.write == "object" || (c.write = {}), r && (c.write.target = r), c.write.writer = a[o];
    }
  };
}
let et = class {
  constructor(t, r = { ignoreUnknown: !1, useNumericKeys: !1 }) {
    this._jsonToAPI = t, this._options = r, this.apiValues = [], this.jsonValues = [], this._apiToJSON = this._invertMap(t), this.apiValues = this._getKeysSorted(this._apiToJSON), this.jsonValues = this._getKeysSorted(this._jsonToAPI), this.read = (n) => this.fromJSON(n), this.write = (n, i, s) => {
      const o = this.toJSON(n);
      o !== void 0 && In(s, o, i);
    }, this.write.isJSONMapWriter = !0;
  }
  toJSON(t) {
    if (t == null)
      return null;
    if (this._apiToJSON.hasOwnProperty(t)) {
      const r = this._apiToJSON[t];
      return this._options.useNumericKeys ? +r : r;
    }
    return this._options.ignoreUnknown ? void 0 : t;
  }
  fromJSON(t) {
    return t != null && this._jsonToAPI.hasOwnProperty(t) ? this._jsonToAPI[t] : this._options.ignoreUnknown ? void 0 : t;
  }
  _invertMap(t) {
    const r = {};
    for (const n in t)
      r[t[n]] = n;
    return r;
  }
  _getKeysSorted(t) {
    const r = [];
    for (const n in t)
      r.push(n);
    return r.sort(), r;
  }
};
function Mn() {
  return function(e, t) {
    return new et(e, { ignoreUnknown: !0, ...t });
  };
}
let iM = class {
  constructor(t, r, n, i) {
    this.semiMajorAxis = t, this.flattening = r, this.outerAtmosphereRimWidth = n;
    const s = 1 - this.flattening;
    this.semiMinorAxis = this.semiMajorAxis * s, this.halfSemiMajorAxis = this.semiMajorAxis / 2, this.halfCircumference = Math.PI * this.semiMajorAxis, this.metersPerDegree = this.halfCircumference / 180, this.inverseFlattening = 1 / (1 - this.flattening) - 1, this.eccentricitySquared = i || 2 * this.flattening - this.flattening * this.flattening, this.meanRadiusSemiAxes = (2 * this.semiMajorAxis + this.semiMinorAxis) / 3;
  }
  get radius() {
    return this.semiMajorAxis;
  }
};
const Bt = new iM(6378137, 1 / 298.257223563, 3e5, 0.006694379990137799), Xa = new iM(3396190, 1 / 169.8944472236118, 23e4), ku = new iM(1737400, 0, 0);
var Id;
(function(e) {
  e[e.CGCS2000 = 4490] = "CGCS2000", e[e.GCSMARS2000 = 104971] = "GCSMARS2000", e[e.GCSMARS2000_SPHERE = 104905] = "GCSMARS2000_SPHERE", e[e.GCSMOON2000 = 104903] = "GCSMOON2000";
})(Id || (Id = {}));
let p;
const S = { values: [1, 0.3048, 0.3048006096012192, 0.3047972654, 0.9143917962, 0.201166195164, 0.9143984146160287, 0.3047994715386762, 20.11676512155263, 20.11678249437587, 0.9143985307444408, 0.91439523, 0.3047997101815088, 20.1168, 20.116756, 5e4, 15e4], units: ["Meter", "Foot", "Foot_US", "Foot_Clarke", "Yard_Clarke", "Link_Clarke", "Yard_Sears", "Foot_Sears", "Chain_Sears", "Chain_Benoit_1895_B", "Yard_Indian", "Yard_Indian_1937", "Foot_Gold_Coast", "Chain", "Chain_Sears_1922_Truncated", "50_Kilometers", "150_Kilometers"], 2066: 5, 2136: 12, 2155: 2, 2157: 0, 2158: 0, 2159: 12, 2160: 12, 2204: 2, 2219: 0, 2220: 0, 2254: 2, 2255: 2, 2256: 1, 2265: 1, 2266: 1, 2267: 2, 2268: 2, 2269: 1, 2270: 1, 2271: 2, 2272: 2, 2273: 1, 2294: 0, 2295: 0, 2314: 3, 2899: 2, 2900: 2, 2901: 1, 2909: 1, 2910: 1, 2911: 2, 2912: 2, 2913: 1, 2914: 1, 2992: 1, 2993: 0, 2994: 1, 3080: 1, 3089: 2, 3090: 0, 3091: 2, 3102: 2, 3141: 0, 3142: 0, 3167: 14, 3359: 2, 3360: 0, 3361: 1, 3362: 0, 3363: 2, 3364: 0, 3365: 2, 3366: 3, 3404: 2, 3405: 0, 3406: 0, 3407: 3, 3439: 0, 3440: 0, 3479: 1, 3480: 0, 3481: 1, 3482: 0, 3483: 1, 3484: 0, 3485: 2, 3486: 0, 3487: 2, 3488: 0, 3489: 0, 3490: 2, 3491: 0, 3492: 2, 3493: 0, 3494: 2, 3495: 0, 3496: 2, 3497: 0, 3498: 2, 3499: 0, 3500: 2, 3501: 0, 3502: 2, 3503: 0, 3504: 2, 3505: 0, 3506: 2, 3507: 0, 3508: 2, 3509: 0, 3510: 2, 3511: 0, 3512: 2, 3513: 0, 3514: 0, 3515: 2, 3516: 0, 3517: 2, 3518: 0, 3519: 2, 3520: 0, 3521: 2, 3522: 0, 3523: 2, 3524: 0, 3525: 2, 3526: 0, 3527: 2, 3528: 0, 3529: 2, 3530: 0, 3531: 2, 3532: 0, 3533: 2, 3534: 0, 3535: 2, 3536: 0, 3537: 2, 3538: 0, 3539: 2, 3540: 0, 3541: 2, 3542: 0, 3543: 2, 3544: 0, 3545: 2, 3546: 0, 3547: 2, 3548: 0, 3549: 2, 3550: 0, 3551: 2, 3552: 0, 3553: 2, 3582: 2, 3583: 0, 3584: 2, 3585: 0, 3586: 2, 3587: 0, 3588: 1, 3589: 0, 3590: 1, 3591: 0, 3592: 0, 3593: 1, 3598: 2, 3599: 0, 3600: 2, 3605: 1, 3606: 0, 3607: 0, 3608: 2, 3609: 0, 3610: 2, 3611: 0, 3612: 2, 3613: 0, 3614: 2, 3615: 0, 3616: 2, 3617: 0, 3618: 2, 3619: 0, 3620: 2, 3621: 0, 3622: 2, 3623: 0, 3624: 2, 3625: 0, 3626: 2, 3627: 0, 3628: 2, 3629: 0, 3630: 2, 3631: 0, 3632: 2, 3633: 0, 3634: 1, 3635: 0, 3636: 1, 3640: 2, 3641: 0, 3642: 2, 3643: 0, 3644: 1, 3645: 0, 3646: 1, 3647: 0, 3648: 1, 3649: 0, 3650: 2, 3651: 0, 3652: 2, 3653: 0, 3654: 2, 3655: 0, 3656: 1, 3657: 0, 3658: 2, 3659: 0, 3660: 2, 3661: 0, 3662: 2, 3663: 0, 3664: 2, 3668: 2, 3669: 0, 3670: 2, 3671: 0, 3672: 2, 3673: 0, 3674: 2, 3675: 0, 3676: 1, 3677: 2, 3678: 0, 3679: 1, 3680: 2, 3681: 0, 3682: 1, 3683: 2, 3684: 0, 3685: 0, 3686: 2, 3687: 0, 3688: 2, 3689: 0, 3690: 2, 3691: 0, 3692: 2, 3696: 2, 3697: 0, 3698: 2, 3699: 0, 3700: 2, 3793: 0, 3794: 0, 3812: 0, 3854: 0, 3857: 0, 3920: 0, 3978: 0, 3979: 0, 3991: 2, 3992: 2, 4026: 0, 4037: 0, 4038: 0, 4071: 0, 4082: 0, 4083: 0, 4087: 0, 4088: 0, 4217: 2, 4414: 0, 4415: 0, 4417: 0, 4434: 0, 4437: 0, 4438: 2, 4439: 2, 4462: 0, 4467: 0, 4471: 0, 4474: 0, 4559: 0, 4647: 0, 4822: 0, 4826: 0, 4839: 0, 5018: 0, 5041: 0, 5042: 0, 5048: 0, 5167: 0, 5168: 0, 5221: 0, 5223: 0, 5234: 0, 5235: 0, 5243: 0, 5247: 0, 5266: 0, 5316: 0, 5320: 0, 5321: 0, 5325: 0, 5337: 0, 5361: 0, 5362: 0, 5367: 0, 5382: 0, 5383: 0, 5396: 0, 5456: 0, 5457: 0, 5469: 0, 5472: 4, 5490: 0, 5513: 0, 5514: 0, 5523: 0, 5559: 0, 5588: 1, 5589: 3, 5596: 0, 5627: 0, 5629: 0, 5641: 0, 5643: 0, 5644: 0, 5646: 2, 5654: 2, 5655: 2, 5659: 0, 5700: 0, 5825: 0, 5836: 0, 5837: 0, 5839: 0, 5842: 0, 5844: 0, 5858: 0, 5879: 0, 5880: 0, 5887: 0, 5890: 0, 6128: 1, 6129: 1, 6141: 1, 6204: 0, 6210: 0, 6211: 0, 6307: 0, 6312: 0, 6316: 0, 6362: 0, 6391: 1, 6405: 1, 6406: 0, 6407: 1, 6408: 0, 6409: 1, 6410: 0, 6411: 2, 6412: 0, 6413: 2, 6414: 0, 6415: 0, 6416: 2, 6417: 0, 6418: 2, 6419: 0, 6420: 2, 6421: 0, 6422: 2, 6423: 0, 6424: 2, 6425: 0, 6426: 2, 6427: 0, 6428: 2, 6429: 0, 6430: 2, 6431: 0, 6432: 2, 6433: 0, 6434: 2, 6435: 0, 6436: 2, 6437: 0, 6438: 2, 6439: 0, 6440: 0, 6441: 2, 6442: 0, 6443: 2, 6444: 0, 6445: 2, 6446: 0, 6447: 2, 6448: 0, 6449: 2, 6450: 0, 6451: 2, 6452: 0, 6453: 2, 6454: 0, 6455: 2, 6456: 0, 6457: 2, 6458: 0, 6459: 2, 6460: 0, 6461: 2, 6462: 0, 6463: 2, 6464: 0, 6465: 2, 6466: 0, 6467: 2, 6468: 0, 6469: 2, 6470: 0, 6471: 2, 6472: 0, 6473: 2, 6474: 0, 6475: 2, 6476: 0, 6477: 2, 6478: 0, 6479: 2, 6484: 2, 6485: 0, 6486: 2, 6487: 0, 6488: 2, 6489: 0, 6490: 2, 6491: 0, 6492: 2, 6493: 0, 6494: 1, 6495: 0, 6496: 1, 6497: 0, 6498: 0, 6499: 1, 6500: 0, 6501: 2, 6502: 0, 6503: 2, 6504: 0, 6505: 2, 6506: 0, 6507: 2, 6508: 0, 6509: 0, 6510: 2, 6515: 1, 6516: 0, 6518: 0, 6519: 2, 6520: 0, 6521: 2, 6522: 0, 6523: 2, 6524: 0, 6525: 2, 6526: 0, 6527: 2, 6528: 0, 6529: 2, 6530: 0, 6531: 2, 6532: 0, 6533: 2, 6534: 0, 6535: 2, 6536: 0, 6537: 2, 6538: 0, 6539: 2, 6540: 0, 6541: 2, 6542: 0, 6543: 2, 6544: 0, 6545: 1, 6546: 0, 6547: 1, 6548: 0, 6549: 2, 6550: 0, 6551: 2, 6552: 0, 6553: 2, 6554: 0, 6555: 2, 6556: 0, 6557: 1, 6558: 0, 6559: 1, 6560: 0, 6561: 1, 6562: 0, 6563: 2, 6564: 0, 6565: 2, 6566: 0, 6567: 0, 6568: 2, 6569: 0, 6570: 1, 6571: 0, 6572: 2, 6573: 0, 6574: 2, 6575: 0, 6576: 2, 6577: 0, 6578: 2, 6582: 2, 6583: 0, 6584: 2, 6585: 0, 6586: 2, 6587: 0, 6588: 2, 6589: 0, 6590: 2, 6591: 0, 6592: 0, 6593: 2, 6594: 0, 6595: 2, 6596: 0, 6597: 2, 6598: 0, 6599: 2, 6600: 0, 6601: 2, 6602: 0, 6603: 2, 6605: 2, 6606: 0, 6607: 2, 6608: 0, 6609: 2, 6610: 0, 6611: 0, 6612: 2, 6613: 0, 6614: 2, 6615: 0, 6616: 2, 6617: 0, 6618: 2, 6633: 2, 6646: 0, 6703: 0, 6784: 0, 6785: 1, 6786: 0, 6787: 1, 6788: 0, 6789: 1, 6790: 0, 6791: 1, 6792: 0, 6793: 1, 6794: 0, 6795: 1, 6796: 0, 6797: 1, 6798: 0, 6799: 1, 6800: 0, 6801: 1, 6802: 0, 6803: 1, 6804: 0, 6805: 1, 6806: 0, 6807: 1, 6808: 0, 6809: 1, 6810: 0, 6811: 1, 6812: 0, 6813: 1, 6814: 0, 6815: 1, 6816: 0, 6817: 1, 6818: 0, 6819: 1, 6820: 0, 6821: 1, 6822: 0, 6823: 1, 6824: 0, 6825: 1, 6826: 0, 6827: 1, 6828: 0, 6829: 1, 6830: 0, 6831: 1, 6832: 0, 6833: 1, 6834: 0, 6835: 1, 6836: 0, 6837: 1, 6838: 0, 6839: 1, 6840: 0, 6841: 1, 6842: 0, 6843: 1, 6844: 0, 6845: 1, 6846: 0, 6847: 1, 6848: 0, 6849: 1, 6850: 0, 6851: 1, 6852: 0, 6853: 1, 6854: 0, 6855: 1, 6856: 0, 6857: 1, 6858: 0, 6859: 1, 6860: 0, 6861: 1, 6862: 0, 6863: 1, 6867: 0, 6868: 1, 6870: 0, 6875: 0, 6876: 0, 6879: 0, 6880: 2, 6884: 0, 6885: 1, 6886: 0, 6887: 1, 6915: 0, 6922: 0, 6923: 2, 6924: 0, 6925: 2, 6962: 0, 6984: 0, 6991: 0, 7128: 2, 7131: 0, 7132: 2, 7142: 0, 7257: 0, 7258: 2, 7259: 0, 7260: 2, 7261: 0, 7262: 2, 7263: 0, 7264: 2, 7265: 0, 7266: 2, 7267: 0, 7268: 2, 7269: 0, 7270: 2, 7271: 0, 7272: 2, 7273: 0, 7274: 2, 7275: 0, 7276: 2, 7277: 0, 7278: 2, 7279: 0, 7280: 2, 7281: 0, 7282: 2, 7283: 0, 7284: 2, 7285: 0, 7286: 2, 7287: 0, 7288: 2, 7289: 0, 7290: 2, 7291: 0, 7292: 2, 7293: 0, 7294: 2, 7295: 0, 7296: 2, 7297: 0, 7298: 2, 7299: 0, 7300: 2, 7301: 0, 7302: 2, 7303: 0, 7304: 2, 7305: 0, 7306: 2, 7307: 0, 7308: 2, 7309: 0, 7310: 2, 7311: 0, 7312: 2, 7313: 0, 7314: 2, 7315: 0, 7316: 2, 7317: 0, 7318: 2, 7319: 0, 7320: 2, 7321: 0, 7322: 2, 7323: 0, 7324: 2, 7325: 0, 7326: 2, 7327: 0, 7328: 2, 7329: 0, 7330: 2, 7331: 0, 7332: 2, 7333: 0, 7334: 2, 7335: 0, 7336: 2, 7337: 0, 7338: 2, 7339: 0, 7340: 2, 7341: 0, 7342: 2, 7343: 0, 7344: 2, 7345: 0, 7346: 2, 7347: 0, 7348: 2, 7349: 0, 7350: 2, 7351: 0, 7352: 2, 7353: 0, 7354: 2, 7355: 0, 7356: 2, 7357: 0, 7358: 2, 7359: 0, 7360: 2, 7361: 0, 7362: 2, 7363: 0, 7364: 2, 7365: 0, 7366: 2, 7367: 0, 7368: 2, 7369: 0, 7370: 2, 7877: 0, 7878: 0, 7882: 0, 7883: 0, 7887: 0, 7899: 0, 7991: 0, 7992: 0, 8035: 2, 8036: 2, 8058: 0, 8059: 0, 8082: 0, 8083: 0, 8088: 0, 8090: 0, 8091: 2, 8092: 0, 8093: 2, 8095: 0, 8096: 2, 8097: 0, 8098: 2, 8099: 0, 8100: 2, 8101: 0, 8102: 2, 8103: 0, 8104: 2, 8105: 0, 8106: 2, 8107: 0, 8108: 2, 8109: 0, 8110: 2, 8111: 0, 8112: 2, 8113: 0, 8114: 2, 8115: 0, 8116: 2, 8117: 0, 8118: 2, 8119: 0, 8120: 2, 8121: 0, 8122: 2, 8123: 0, 8124: 2, 8125: 0, 8126: 2, 8127: 0, 8128: 2, 8129: 0, 8130: 2, 8131: 0, 8132: 2, 8133: 0, 8134: 2, 8135: 0, 8136: 2, 8137: 0, 8138: 2, 8139: 0, 8140: 2, 8141: 0, 8142: 2, 8143: 0, 8144: 2, 8145: 0, 8146: 2, 8147: 0, 8148: 2, 8149: 0, 8150: 2, 8151: 0, 8152: 2, 8153: 0, 8154: 2, 8155: 0, 8156: 2, 8157: 0, 8158: 2, 8159: 0, 8160: 2, 8161: 0, 8162: 2, 8163: 0, 8164: 2, 8165: 0, 8166: 2, 8167: 0, 8168: 2, 8169: 0, 8170: 2, 8171: 0, 8172: 2, 8173: 0, 8177: 2, 8179: 0, 8180: 2, 8181: 0, 8182: 2, 8184: 0, 8185: 2, 8187: 0, 8189: 2, 8191: 0, 8193: 2, 8196: 0, 8197: 2, 8198: 0, 8200: 2, 8201: 0, 8202: 2, 8203: 0, 8204: 2, 8205: 0, 8206: 2, 8207: 0, 8208: 2, 8209: 0, 8210: 2, 8212: 0, 8213: 2, 8214: 0, 8216: 2, 8218: 0, 8220: 2, 8222: 0, 8224: 2, 8225: 0, 8226: 2, 8311: 0, 8312: 1, 8313: 0, 8314: 1, 8315: 0, 8316: 1, 8317: 0, 8318: 1, 8319: 0, 8320: 1, 8321: 0, 8322: 1, 8323: 0, 8324: 1, 8325: 0, 8326: 1, 8327: 0, 8328: 1, 8329: 0, 8330: 1, 8331: 0, 8332: 1, 8333: 0, 8334: 1, 8335: 0, 8336: 1, 8337: 0, 8338: 1, 8339: 0, 8340: 1, 8341: 0, 8342: 1, 8343: 0, 8344: 1, 8345: 0, 8346: 1, 8347: 0, 8348: 1, 8352: 0, 8353: 0, 8379: 0, 8380: 2, 8381: 0, 8382: 2, 8383: 0, 8384: 2, 8385: 0, 8387: 2, 8391: 0, 8395: 0, 8433: 0, 8441: 0, 8455: 0, 8456: 0, 8531: 2, 8682: 0, 8686: 0, 8687: 0, 8692: 0, 8693: 0, 8826: 0, 8903: 0, 8950: 0, 8951: 0, 9039: 0, 9040: 0, 9141: 0, 9149: 0, 9150: 0, 9191: 0, 9221: 0, 9222: 0, 9249: 0, 9250: 0, 9252: 0, 9254: 0, 9265: 0, 9284: 0, 9285: 0, 9300: 0, 9354: 0, 9367: 0, 9373: 0, 9377: 0, 9387: 0, 9391: 0, 9456: 0, 9473: 0, 9498: 0, 9674: 0, 9678: 0, 9680: 0, 9709: 0, 9712: 0, 9713: 0, 9716: 0, 9741: 0, 9748: 2, 9749: 2, 9761: 0, 9766: 0, 9793: 0, 9794: 0, 9869: 0, 9874: 0, 9875: 0, 9880: 0, 9943: 0, 9945: 0, 9947: 0, 9967: 0, 9972: 0, 9977: 0, 20042: 0, 20050: 1, 20499: 0, 20538: 0, 20539: 0, 20790: 0, 20791: 0, 21291: 0, 21292: 0, 21500: 0, 21817: 0, 21818: 0, 22032: 0, 22033: 0, 22091: 0, 22092: 0, 22239: 0, 22240: 0, 22332: 0, 22337: 0, 22338: 0, 22391: 0, 22392: 0, 22639: 0, 22700: 0, 22739: 0, 22770: 0, 22780: 0, 22832: 0, 23090: 0, 23095: 0, 23239: 0, 23240: 0, 23433: 0, 23700: 0, 24047: 0, 24048: 0, 24100: 3, 24200: 0, 24305: 0, 24306: 0, 24382: 10, 24383: 0, 24500: 0, 24547: 0, 24548: 0, 24571: 9, 24600: 0, 25e3: 0, 25231: 0, 25884: 0, 25932: 0, 26237: 0, 26331: 0, 26332: 0, 26432: 0, 26591: 0, 26592: 0, 26632: 0, 26692: 0, 27120: 0, 27200: 0, 27291: 6, 27292: 6, 27429: 0, 27492: 0, 27493: 0, 27500: 0, 27700: 0, 28232: 0, 28600: 0, 28991: 0, 28992: 0, 29100: 0, 29101: 0, 29220: 0, 29221: 0, 29333: 0, 29635: 0, 29636: 0, 29701: 0, 29738: 0, 29739: 0, 29849: 0, 29850: 0, 29871: 8, 29872: 7, 29873: 0, 29874: 0, 30200: 5, 30339: 0, 30340: 0, 30591: 0, 30592: 0, 30791: 0, 30792: 0, 30800: 0, 31028: 0, 31121: 0, 31154: 0, 31170: 0, 31171: 0, 31370: 0, 31528: 0, 31529: 0, 31600: 0, 31700: 0, 31838: 0, 31839: 0, 31900: 0, 31901: 0, 32061: 0, 32062: 0, 32098: 0, 32099: 2, 32100: 0, 32104: 0, 32161: 0, 32766: 0, 53048: 0, 53049: 0, 54090: 0, 54091: 0, 65061: 2, 65062: 2, 65161: 0, 65163: 0, 102041: 2, 102064: 11, 102068: 15, 102069: 16, 102118: 2, 102119: 1, 102120: 2, 102121: 2, 102217: 2, 102218: 0, 102219: 2, 102220: 2, 102378: 1, 102379: 1, 102380: 0, 102381: 1, 102589: 2, 102599: 2, 102600: 2, 102604: 2, 102647: 0, 102704: 2, 102705: 2, 102706: 0, 102731: 0, 102732: 0, 102759: 1, 102760: 1, 102761: 2, 102762: 0, 102763: 2, 102764: 0, 102765: 0, 102766: 2, 102970: 1, 102974: 2, 102993: 0, 102994: 0, 102995: 2, 102996: 2, 103015: 0, 103016: 2, 103017: 0, 103018: 2, 103025: 0, 103026: 0, 103027: 2, 103028: 2, 103035: 0, 103036: 0, 103037: 2, 103038: 2, 103039: 0, 103040: 0, 103041: 2, 103042: 2, 103043: 0, 103044: 0, 103045: 2, 103046: 2, 103047: 0, 103048: 0, 103049: 2, 103050: 2, 103051: 0, 103052: 2, 103053: 0, 103054: 2, 103055: 0, 103056: 2, 103057: 0, 103058: 0, 103059: 2, 103060: 2, 103061: 0, 103062: 0, 103063: 2, 103064: 2, 103069: 2, 103070: 0, 103071: 0, 103072: 2, 103073: 2, 103086: 0, 103087: 0, 103088: 2, 103089: 2, 103094: 1, 103095: 0, 103096: 2, 103103: 0, 103104: 2, 103105: 0, 103106: 2, 103121: 0, 103122: 2, 103123: 0, 103124: 0, 103125: 1, 103126: 1, 103127: 0, 103128: 0, 103129: 2, 103130: 2, 103131: 0, 103132: 0, 103133: 2, 103134: 2, 103135: 0, 103136: 0, 103137: 1, 103138: 1, 103139: 0, 103140: 2, 103141: 0, 103142: 2, 103143: 0, 103144: 2, 103145: 0, 103146: 1, 103147: 0, 103148: 0, 103149: 2, 103150: 2, 103151: 0, 103152: 2, 103172: 0, 103173: 2, 103174: 0, 103175: 0, 103176: 2, 103177: 2, 103178: 0, 103179: 0, 103180: 2, 103181: 2, 103182: 0, 103183: 0, 103184: 2, 103185: 2, 103228: 0, 103229: 0, 103230: 2, 103231: 2, 103250: 0, 103251: 2, 103252: 0, 103253: 2, 103260: 0, 103261: 0, 103262: 2, 103263: 2, 103270: 0, 103271: 0, 103272: 2, 103273: 2, 103274: 0, 103275: 0, 103276: 2, 103277: 2, 103278: 0, 103279: 0, 103280: 2, 103281: 2, 103282: 0, 103283: 0, 103284: 2, 103285: 2, 103286: 0, 103287: 2, 103288: 0, 103289: 2, 103290: 0, 103291: 2, 103292: 0, 103293: 0, 103294: 2, 103295: 2, 103296: 0, 103297: 0, 103298: 2, 103299: 2, 103376: 2, 103377: 0, 103378: 0, 103379: 2, 103380: 2, 103393: 0, 103394: 0, 103395: 2, 103396: 2, 103472: 0, 103473: 1, 103474: 0, 103475: 2, 103482: 0, 103483: 2, 103484: 0, 103485: 2, 103500: 0, 103501: 2, 103502: 0, 103503: 0, 103504: 1, 103505: 1, 103506: 0, 103507: 0, 103508: 2, 103509: 2, 103510: 0, 103511: 0, 103512: 2, 103513: 2, 103514: 0, 103515: 2, 103516: 0, 103517: 2, 103518: 0, 103519: 2, 103520: 0, 103521: 1, 103522: 0, 103523: 0, 103524: 2, 103525: 2, 103526: 0, 103527: 2, 103561: 2, 103562: 2, 103563: 0, 103564: 0, 103565: 2, 103566: 2, 103567: 0, 103568: 0, 103569: 2, 103570: 2, 103584: 0, 103585: 2, 103586: 0, 103587: 2, 103588: 1, 103589: 0, 103590: 2, 103591: 1, 103592: 0, 103593: 2, 103594: 1, 103695: 2 };
for (p = 2e3; p <= 2045; p++)
  S[p] = 0;
for (p = 2056; p <= 2065; p++)
  S[p] = 0;
for (p = 2067; p <= 2135; p++)
  S[p] = 0;
for (p = 2137; p <= 2154; p++)
  S[p] = 0;
for (p = 2161; p <= 2170; p++)
  S[p] = 0;
for (p = 2172; p <= 2193; p++)
  S[p] = 0;
for (p = 2195; p <= 2198; p++)
  S[p] = 0;
for (p = 2200; p <= 2203; p++)
  S[p] = 0;
for (p = 2205; p <= 2217; p++)
  S[p] = 0;
for (p = 2222; p <= 2224; p++)
  S[p] = 1;
for (p = 2225; p <= 2250; p++)
  S[p] = 2;
for (p = 2251; p <= 2253; p++)
  S[p] = 1;
for (p = 2257; p <= 2264; p++)
  S[p] = 2;
for (p = 2274; p <= 2279; p++)
  S[p] = 2;
for (p = 2280; p <= 2282; p++)
  S[p] = 1;
for (p = 2283; p <= 2289; p++)
  S[p] = 2;
for (p = 2290; p <= 2292; p++)
  S[p] = 0;
for (p = 2308; p <= 2313; p++)
  S[p] = 0;
for (p = 2315; p <= 2491; p++)
  S[p] = 0;
for (p = 2494; p <= 2866; p++)
  S[p] = 0;
for (p = 2867; p <= 2869; p++)
  S[p] = 1;
for (p = 2870; p <= 2888; p++)
  S[p] = 2;
for (p = 2891; p <= 2895; p++)
  S[p] = 2;
for (p = 2896; p <= 2898; p++)
  S[p] = 1;
for (p = 2902; p <= 2908; p++)
  S[p] = 2;
for (p = 2915; p <= 2920; p++)
  S[p] = 2;
for (p = 2921; p <= 2923; p++)
  S[p] = 1;
for (p = 2924; p <= 2930; p++)
  S[p] = 2;
for (p = 2931; p <= 2962; p++)
  S[p] = 0;
for (p = 2964; p <= 2968; p++)
  S[p] = 2;
for (p = 2969; p <= 2973; p++)
  S[p] = 0;
for (p = 2975; p <= 2991; p++)
  S[p] = 0;
for (p = 2995; p <= 3051; p++)
  S[p] = 0;
for (p = 3054; p <= 3079; p++)
  S[p] = 0;
for (p = 3081; p <= 3088; p++)
  S[p] = 0;
for (p = 3092; p <= 3101; p++)
  S[p] = 0;
for (p = 3106; p <= 3138; p++)
  S[p] = 0;
for (p = 3146; p <= 3151; p++)
  S[p] = 0;
for (p = 3153; p <= 3166; p++)
  S[p] = 0;
for (p = 3168; p <= 3172; p++)
  S[p] = 0;
for (p = 3174; p <= 3203; p++)
  S[p] = 0;
for (p = 3294; p <= 3358; p++)
  S[p] = 0;
for (p = 3367; p <= 3403; p++)
  S[p] = 0;
for (p = 3408; p <= 3416; p++)
  S[p] = 0;
for (p = 3417; p <= 3438; p++)
  S[p] = 2;
for (p = 3441; p <= 3446; p++)
  S[p] = 2;
for (p = 3447; p <= 3450; p++)
  S[p] = 0;
for (p = 3451; p <= 3459; p++)
  S[p] = 2;
for (p = 3460; p <= 3478; p++)
  S[p] = 0;
for (p = 3554; p <= 3559; p++)
  S[p] = 0;
for (p = 3560; p <= 3570; p++)
  S[p] = 2;
for (p = 3571; p <= 3581; p++)
  S[p] = 0;
for (p = 3594; p <= 3597; p++)
  S[p] = 0;
for (p = 3601; p <= 3604; p++)
  S[p] = 0;
for (p = 3637; p <= 3639; p++)
  S[p] = 0;
for (p = 3665; p <= 3667; p++)
  S[p] = 0;
for (p = 3693; p <= 3695; p++)
  S[p] = 0;
for (p = 3701; p <= 3727; p++)
  S[p] = 0;
for (p = 3728; p <= 3739; p++)
  S[p] = 2;
for (p = 3740; p <= 3751; p++)
  S[p] = 0;
for (p = 3753; p <= 3760; p++)
  S[p] = 2;
for (p = 3761; p <= 3773; p++)
  S[p] = 0;
for (p = 3775; p <= 3777; p++)
  S[p] = 0;
for (p = 3779; p <= 3781; p++)
  S[p] = 0;
for (p = 3783; p <= 3785; p++)
  S[p] = 0;
for (p = 3788; p <= 3791; p++)
  S[p] = 0;
for (p = 3797; p <= 3802; p++)
  S[p] = 0;
for (p = 3814; p <= 3816; p++)
  S[p] = 0;
for (p = 3825; p <= 3829; p++)
  S[p] = 0;
for (p = 3832; p <= 3841; p++)
  S[p] = 0;
for (p = 3844; p <= 3852; p++)
  S[p] = 0;
for (p = 3873; p <= 3885; p++)
  S[p] = 0;
for (p = 3890; p <= 3893; p++)
  S[p] = 0;
for (p = 3907; p <= 3912; p++)
  S[p] = 0;
for (p = 3942; p <= 3950; p++)
  S[p] = 0;
for (p = 3968; p <= 3970; p++)
  S[p] = 0;
for (p = 3973; p <= 3976; p++)
  S[p] = 0;
for (p = 3986; p <= 3989; p++)
  S[p] = 0;
for (p = 3994; p <= 3997; p++)
  S[p] = 0;
for (p = 4048; p <= 4051; p++)
  S[p] = 0;
for (p = 4056; p <= 4063; p++)
  S[p] = 0;
for (p = 4093; p <= 4096; p++)
  S[p] = 0;
for (p = 4390; p <= 4398; p++)
  S[p] = 0;
for (p = 4399; p <= 4413; p++)
  S[p] = 2;
for (p = 4418; p <= 4433; p++)
  S[p] = 2;
for (p = 4455; p <= 4457; p++)
  S[p] = 2;
for (p = 4484; p <= 4489; p++)
  S[p] = 0;
for (p = 4491; p <= 4554; p++)
  S[p] = 0;
for (p = 4568; p <= 4589; p++)
  S[p] = 0;
for (p = 4652; p <= 4656; p++)
  S[p] = 0;
for (p = 4766; p <= 4800; p++)
  S[p] = 0;
for (p = 5014; p <= 5016; p++)
  S[p] = 0;
for (p = 5069; p <= 5072; p++)
  S[p] = 0;
for (p = 5105; p <= 5130; p++)
  S[p] = 0;
for (p = 5173; p <= 5188; p++)
  S[p] = 0;
for (p = 5253; p <= 5259; p++)
  S[p] = 0;
for (p = 5269; p <= 5275; p++)
  S[p] = 0;
for (p = 5292; p <= 5311; p++)
  S[p] = 0;
for (p = 5329; p <= 5331; p++)
  S[p] = 0;
for (p = 5343; p <= 5349; p++)
  S[p] = 0;
for (p = 5355; p <= 5357; p++)
  S[p] = 0;
for (p = 5387; p <= 5389; p++)
  S[p] = 0;
for (p = 5459; p <= 5463; p++)
  S[p] = 0;
for (p = 5479; p <= 5482; p++)
  S[p] = 0;
for (p = 5518; p <= 5520; p++)
  S[p] = 0;
for (p = 5530; p <= 5539; p++)
  S[p] = 0;
for (p = 5550; p <= 5552; p++)
  S[p] = 0;
for (p = 5562; p <= 5583; p++)
  S[p] = 0;
for (p = 5623; p <= 5625; p++)
  S[p] = 2;
for (p = 5631; p <= 5639; p++)
  S[p] = 0;
for (p = 5649; p <= 5653; p++)
  S[p] = 0;
for (p = 5663; p <= 5680; p++)
  S[p] = 0;
for (p = 5682; p <= 5685; p++)
  S[p] = 0;
for (p = 5875; p <= 5877; p++)
  S[p] = 0;
for (p = 5896; p <= 5899; p++)
  S[p] = 0;
for (p = 5921; p <= 5940; p++)
  S[p] = 0;
for (p = 6050; p <= 6125; p++)
  S[p] = 0;
for (p = 6244; p <= 6275; p++)
  S[p] = 0;
for (p = 6328; p <= 6348; p++)
  S[p] = 0;
for (p = 6350; p <= 6356; p++)
  S[p] = 0;
for (p = 6366; p <= 6372; p++)
  S[p] = 0;
for (p = 6381; p <= 6387; p++)
  S[p] = 0;
for (p = 6393; p <= 6404; p++)
  S[p] = 0;
for (p = 6480; p <= 6483; p++)
  S[p] = 0;
for (p = 6511; p <= 6514; p++)
  S[p] = 0;
for (p = 6579; p <= 6581; p++)
  S[p] = 0;
for (p = 6619; p <= 6624; p++)
  S[p] = 0;
for (p = 6625; p <= 6627; p++)
  S[p] = 2;
for (p = 6628; p <= 6632; p++)
  S[p] = 0;
for (p = 6634; p <= 6637; p++)
  S[p] = 0;
for (p = 6669; p <= 6692; p++)
  S[p] = 0;
for (p = 6707; p <= 6709; p++)
  S[p] = 0;
for (p = 6720; p <= 6723; p++)
  S[p] = 0;
for (p = 6732; p <= 6738; p++)
  S[p] = 0;
for (p = 6931; p <= 6933; p++)
  S[p] = 0;
for (p = 6956; p <= 6959; p++)
  S[p] = 0;
for (p = 7005; p <= 7007; p++)
  S[p] = 0;
for (p = 7057; p <= 7070; p++)
  S[p] = 2;
for (p = 7074; p <= 7082; p++)
  S[p] = 0;
for (p = 7109; p <= 7118; p++)
  S[p] = 0;
for (p = 7119; p <= 7127; p++)
  S[p] = 1;
for (p = 7374; p <= 7376; p++)
  S[p] = 0;
for (p = 7528; p <= 7586; p++)
  S[p] = 0;
for (p = 7587; p <= 7645; p++)
  S[p] = 2;
for (p = 7692; p <= 7696; p++)
  S[p] = 0;
for (p = 7755; p <= 7787; p++)
  S[p] = 0;
for (p = 7791; p <= 7795; p++)
  S[p] = 0;
for (p = 7799; p <= 7801; p++)
  S[p] = 0;
for (p = 7803; p <= 7805; p++)
  S[p] = 0;
for (p = 7825; p <= 7831; p++)
  S[p] = 0;
for (p = 7845; p <= 7859; p++)
  S[p] = 0;
for (p = 8013; p <= 8032; p++)
  S[p] = 0;
for (p = 8065; p <= 8068; p++)
  S[p] = 1;
for (p = 8518; p <= 8529; p++)
  S[p] = 2;
for (p = 8533; p <= 8536; p++)
  S[p] = 2;
for (p = 8538; p <= 8540; p++)
  S[p] = 2;
for (p = 8677; p <= 8679; p++)
  S[p] = 0;
for (p = 8836; p <= 8840; p++)
  S[p] = 0;
for (p = 8857; p <= 8859; p++)
  S[p] = 0;
for (p = 8908; p <= 8910; p++)
  S[p] = 0;
for (p = 9154; p <= 9159; p++)
  S[p] = 0;
for (p = 9205; p <= 9218; p++)
  S[p] = 0;
for (p = 9271; p <= 9273; p++)
  S[p] = 0;
for (p = 9295; p <= 9297; p++)
  S[p] = 0;
for (p = 9356; p <= 9360; p++)
  S[p] = 0;
for (p = 9404; p <= 9407; p++)
  S[p] = 0;
for (p = 9476; p <= 9482; p++)
  S[p] = 0;
for (p = 9487; p <= 9494; p++)
  S[p] = 0;
for (p = 9697; p <= 9699; p++)
  S[p] = 0;
for (p = 9821; p <= 9865; p++)
  S[p] = 0;
for (p = 20002; p <= 20032; p++)
  S[p] = 0;
for (p = 20047; p <= 20049; p++)
  S[p] = 0;
for (p = 20062; p <= 20092; p++)
  S[p] = 0;
for (p = 20135; p <= 20138; p++)
  S[p] = 0;
for (p = 20248; p <= 20258; p++)
  S[p] = 0;
for (p = 20348; p <= 20358; p++)
  S[p] = 0;
for (p = 20436; p <= 20440; p++)
  S[p] = 0;
for (p = 20822; p <= 20824; p++)
  S[p] = 0;
for (p = 20904; p <= 20932; p++)
  S[p] = 0;
for (p = 20934; p <= 20936; p++)
  S[p] = 0;
for (p = 21004; p <= 21032; p++)
  S[p] = 0;
for (p = 21035; p <= 21037; p++)
  S[p] = 0;
for (p = 21095; p <= 21097; p++)
  S[p] = 0;
for (p = 21148; p <= 21150; p++)
  S[p] = 0;
for (p = 21207; p <= 21264; p++)
  S[p] = 0;
for (p = 21307; p <= 21364; p++)
  S[p] = 0;
for (p = 21413; p <= 21423; p++)
  S[p] = 0;
for (p = 21453; p <= 21463; p++)
  S[p] = 0;
for (p = 21473; p <= 21483; p++)
  S[p] = 0;
for (p = 21780; p <= 21782; p++)
  S[p] = 0;
for (p = 21891; p <= 21894; p++)
  S[p] = 0;
for (p = 21896; p <= 21899; p++)
  S[p] = 0;
for (p = 22171; p <= 22177; p++)
  S[p] = 0;
for (p = 22181; p <= 22187; p++)
  S[p] = 0;
for (p = 22191; p <= 22197; p++)
  S[p] = 0;
for (p = 22207; p <= 22222; p++)
  S[p] = 0;
for (p = 22234; p <= 22236; p++)
  S[p] = 0;
for (p = 22243; p <= 22250; p++)
  S[p] = 0;
for (p = 22262; p <= 22265; p++)
  S[p] = 0;
for (p = 22307; p <= 22322; p++)
  S[p] = 0;
for (p = 22348; p <= 22357; p++)
  S[p] = 0;
for (p = 22407; p <= 22422; p++)
  S[p] = 0;
for (p = 22462; p <= 22465; p++)
  S[p] = 0;
for (p = 22521; p <= 22525; p++)
  S[p] = 0;
for (p = 22607; p <= 22622; p++)
  S[p] = 0;
for (p = 22641; p <= 22646; p++)
  S[p] = 0;
for (p = 22648; p <= 22657; p++)
  S[p] = 0;
for (p = 22707; p <= 22722; p++)
  S[p] = 0;
for (p = 22762; p <= 22765; p++)
  S[p] = 0;
for (p = 22991; p <= 22994; p++)
  S[p] = 0;
for (p = 23028; p <= 23038; p++)
  S[p] = 0;
for (p = 23830; p <= 23853; p++)
  S[p] = 0;
for (p = 23866; p <= 23872; p++)
  S[p] = 0;
for (p = 23877; p <= 23884; p++)
  S[p] = 0;
for (p = 23886; p <= 23894; p++)
  S[p] = 0;
for (p = 23946; p <= 23948; p++)
  S[p] = 0;
for (p = 24311; p <= 24313; p++)
  S[p] = 0;
for (p = 24342; p <= 24347; p++)
  S[p] = 0;
for (p = 24370; p <= 24374; p++)
  S[p] = 10;
for (p = 24375; p <= 24381; p++)
  S[p] = 0;
for (p = 24718; p <= 24721; p++)
  S[p] = 0;
for (p = 24817; p <= 24821; p++)
  S[p] = 0;
for (p = 24877; p <= 24882; p++)
  S[p] = 0;
for (p = 24891; p <= 24893; p++)
  S[p] = 0;
for (p = 25391; p <= 25395; p++)
  S[p] = 0;
for (p = 25828; p <= 25838; p++)
  S[p] = 0;
for (p = 26191; p <= 26195; p++)
  S[p] = 0;
for (p = 26391; p <= 26393; p++)
  S[p] = 0;
for (p = 26701; p <= 26722; p++)
  S[p] = 0;
for (p = 26729; p <= 26799; p++)
  S[p] = 2;
for (p = 26801; p <= 26803; p++)
  S[p] = 2;
for (p = 26811; p <= 26813; p++)
  S[p] = 2;
for (p = 26847; p <= 26870; p++)
  S[p] = 2;
for (p = 26891; p <= 26899; p++)
  S[p] = 0;
for (p = 26901; p <= 26923; p++)
  S[p] = 0;
for (p = 26929; p <= 26946; p++)
  S[p] = 0;
for (p = 26948; p <= 26998; p++)
  S[p] = 0;
for (p = 27037; p <= 27040; p++)
  S[p] = 0;
for (p = 27205; p <= 27232; p++)
  S[p] = 0;
for (p = 27258; p <= 27260; p++)
  S[p] = 0;
for (p = 27391; p <= 27398; p++)
  S[p] = 0;
for (p = 27561; p <= 27564; p++)
  S[p] = 0;
for (p = 27571; p <= 27574; p++)
  S[p] = 0;
for (p = 27581; p <= 27584; p++)
  S[p] = 0;
for (p = 27591; p <= 27594; p++)
  S[p] = 0;
for (p = 28191; p <= 28193; p++)
  S[p] = 0;
for (p = 28348; p <= 28358; p++)
  S[p] = 0;
for (p = 28402; p <= 28432; p++)
  S[p] = 0;
for (p = 28462; p <= 28492; p++)
  S[p] = 0;
for (p = 29118; p <= 29122; p++)
  S[p] = 0;
for (p = 29168; p <= 29172; p++)
  S[p] = 0;
for (p = 29177; p <= 29185; p++)
  S[p] = 0;
for (p = 29187; p <= 29195; p++)
  S[p] = 0;
for (p = 29900; p <= 29903; p++)
  S[p] = 0;
for (p = 30161; p <= 30179; p++)
  S[p] = 0;
for (p = 30491; p <= 30494; p++)
  S[p] = 0;
for (p = 30729; p <= 30732; p++)
  S[p] = 0;
for (p = 31251; p <= 31259; p++)
  S[p] = 0;
for (p = 31265; p <= 31268; p++)
  S[p] = 0;
for (p = 31275; p <= 31279; p++)
  S[p] = 0;
for (p = 31281; p <= 31297; p++)
  S[p] = 0;
for (p = 31461; p <= 31469; p++)
  S[p] = 0;
for (p = 31491; p <= 31495; p++)
  S[p] = 0;
for (p = 31917; p <= 31922; p++)
  S[p] = 0;
for (p = 31965; p <= 32e3; p++)
  S[p] = 0;
for (p = 32001; p <= 32003; p++)
  S[p] = 2;
for (p = 32005; p <= 32031; p++)
  S[p] = 2;
for (p = 32033; p <= 32060; p++)
  S[p] = 2;
for (p = 32064; p <= 32067; p++)
  S[p] = 2;
for (p = 32074; p <= 32077; p++)
  S[p] = 2;
for (p = 32081; p <= 32086; p++)
  S[p] = 0;
for (p = 32107; p <= 32130; p++)
  S[p] = 0;
for (p = 32133; p <= 32159; p++)
  S[p] = 0;
for (p = 32164; p <= 32167; p++)
  S[p] = 2;
for (p = 32180; p <= 32199; p++)
  S[p] = 0;
for (p = 32201; p <= 32260; p++)
  S[p] = 0;
for (p = 32301; p <= 32360; p++)
  S[p] = 0;
for (p = 32601; p <= 32662; p++)
  S[p] = 0;
for (p = 32664; p <= 32667; p++)
  S[p] = 2;
for (p = 32701; p <= 32761; p++)
  S[p] = 0;
for (p = 53001; p <= 53004; p++)
  S[p] = 0;
for (p = 53008; p <= 53019; p++)
  S[p] = 0;
for (p = 53021; p <= 53032; p++)
  S[p] = 0;
for (p = 53034; p <= 53037; p++)
  S[p] = 0;
for (p = 53042; p <= 53046; p++)
  S[p] = 0;
for (p = 53074; p <= 53080; p++)
  S[p] = 0;
for (p = 54001; p <= 54004; p++)
  S[p] = 0;
for (p = 54008; p <= 54019; p++)
  S[p] = 0;
for (p = 54021; p <= 54032; p++)
  S[p] = 0;
for (p = 54034; p <= 54037; p++)
  S[p] = 0;
for (p = 54042; p <= 54046; p++)
  S[p] = 0;
for (p = 54048; p <= 54053; p++)
  S[p] = 0;
for (p = 54074; p <= 54080; p++)
  S[p] = 0;
for (p = 54098; p <= 54101; p++)
  S[p] = 0;
for (p = 102001; p <= 102040; p++)
  S[p] = 0;
for (p = 102042; p <= 102063; p++)
  S[p] = 0;
for (p = 102065; p <= 102067; p++)
  S[p] = 0;
for (p = 102070; p <= 102117; p++)
  S[p] = 0;
for (p = 102122; p <= 102216; p++)
  S[p] = 0;
for (p = 102221; p <= 102377; p++)
  S[p] = 0;
for (p = 102382; p <= 102388; p++)
  S[p] = 0;
for (p = 102389; p <= 102398; p++)
  S[p] = 2;
for (p = 102399; p <= 102444; p++)
  S[p] = 0;
for (p = 102445; p <= 102447; p++)
  S[p] = 2;
for (p = 102448; p <= 102458; p++)
  S[p] = 0;
for (p = 102459; p <= 102468; p++)
  S[p] = 2;
for (p = 102469; p <= 102499; p++)
  S[p] = 0;
for (p = 102500; p <= 102519; p++)
  S[p] = 1;
for (p = 102520; p <= 102524; p++)
  S[p] = 0;
for (p = 102525; p <= 102529; p++)
  S[p] = 2;
for (p = 102530; p <= 102588; p++)
  S[p] = 0;
for (p = 102590; p <= 102598; p++)
  S[p] = 0;
for (p = 102601; p <= 102603; p++)
  S[p] = 0;
for (p = 102605; p <= 102628; p++)
  S[p] = 0;
for (p = 102629; p <= 102646; p++)
  S[p] = 2;
for (p = 102648; p <= 102700; p++)
  S[p] = 2;
for (p = 102701; p <= 102703; p++)
  S[p] = 0;
for (p = 102707; p <= 102730; p++)
  S[p] = 2;
for (p = 102733; p <= 102758; p++)
  S[p] = 2;
for (p = 102767; p <= 102900; p++)
  S[p] = 0;
for (p = 102901; p <= 102933; p++)
  S[p] = 2;
for (p = 102934; p <= 102950; p++)
  S[p] = 13;
for (p = 102951; p <= 102955; p++)
  S[p] = 0;
for (p = 102961; p <= 102963; p++)
  S[p] = 0;
for (p = 102965; p <= 102969; p++)
  S[p] = 0;
for (p = 102971; p <= 102973; p++)
  S[p] = 0;
for (p = 102975; p <= 102989; p++)
  S[p] = 0;
for (p = 102990; p <= 102992; p++)
  S[p] = 1;
for (p = 102997; p <= 103002; p++)
  S[p] = 0;
for (p = 103003; p <= 103008; p++)
  S[p] = 2;
for (p = 103009; p <= 103011; p++)
  S[p] = 0;
for (p = 103012; p <= 103014; p++)
  S[p] = 2;
for (p = 103019; p <= 103021; p++)
  S[p] = 0;
for (p = 103022; p <= 103024; p++)
  S[p] = 2;
for (p = 103029; p <= 103031; p++)
  S[p] = 0;
for (p = 103032; p <= 103034; p++)
  S[p] = 2;
for (p = 103065; p <= 103068; p++)
  S[p] = 0;
for (p = 103074; p <= 103076; p++)
  S[p] = 0;
for (p = 103077; p <= 103079; p++)
  S[p] = 1;
for (p = 103080; p <= 103082; p++)
  S[p] = 0;
for (p = 103083; p <= 103085; p++)
  S[p] = 2;
for (p = 103090; p <= 103093; p++)
  S[p] = 0;
for (p = 103097; p <= 103099; p++)
  S[p] = 0;
for (p = 103100; p <= 103102; p++)
  S[p] = 2;
for (p = 103107; p <= 103109; p++)
  S[p] = 0;
for (p = 103110; p <= 103112; p++)
  S[p] = 2;
for (p = 103113; p <= 103116; p++)
  S[p] = 0;
for (p = 103117; p <= 103120; p++)
  S[p] = 2;
for (p = 103153; p <= 103157; p++)
  S[p] = 0;
for (p = 103158; p <= 103162; p++)
  S[p] = 2;
for (p = 103163; p <= 103165; p++)
  S[p] = 0;
for (p = 103166; p <= 103168; p++)
  S[p] = 1;
for (p = 103169; p <= 103171; p++)
  S[p] = 2;
for (p = 103186; p <= 103188; p++)
  S[p] = 0;
for (p = 103189; p <= 103191; p++)
  S[p] = 2;
for (p = 103192; p <= 103195; p++)
  S[p] = 0;
for (p = 103196; p <= 103199; p++)
  S[p] = 2;
for (p = 103200; p <= 103224; p++)
  S[p] = 0;
for (p = 103225; p <= 103227; p++)
  S[p] = 1;
for (p = 103232; p <= 103237; p++)
  S[p] = 0;
for (p = 103238; p <= 103243; p++)
  S[p] = 2;
for (p = 103244; p <= 103246; p++)
  S[p] = 0;
for (p = 103247; p <= 103249; p++)
  S[p] = 2;
for (p = 103254; p <= 103256; p++)
  S[p] = 0;
for (p = 103257; p <= 103259; p++)
  S[p] = 2;
for (p = 103264; p <= 103266; p++)
  S[p] = 0;
for (p = 103267; p <= 103269; p++)
  S[p] = 2;
for (p = 103300; p <= 103375; p++)
  S[p] = 0;
for (p = 103381; p <= 103383; p++)
  S[p] = 0;
for (p = 103384; p <= 103386; p++)
  S[p] = 1;
for (p = 103387; p <= 103389; p++)
  S[p] = 0;
for (p = 103390; p <= 103392; p++)
  S[p] = 2;
for (p = 103397; p <= 103399; p++)
  S[p] = 0;
for (p = 103400; p <= 103471; p++)
  S[p] = 2;
for (p = 103476; p <= 103478; p++)
  S[p] = 0;
for (p = 103479; p <= 103481; p++)
  S[p] = 2;
for (p = 103486; p <= 103488; p++)
  S[p] = 0;
for (p = 103489; p <= 103491; p++)
  S[p] = 2;
for (p = 103492; p <= 103495; p++)
  S[p] = 0;
for (p = 103496; p <= 103499; p++)
  S[p] = 2;
for (p = 103528; p <= 103543; p++)
  S[p] = 0;
for (p = 103544; p <= 103548; p++)
  S[p] = 2;
for (p = 103549; p <= 103551; p++)
  S[p] = 0;
for (p = 103552; p <= 103554; p++)
  S[p] = 1;
for (p = 103555; p <= 103557; p++)
  S[p] = 2;
for (p = 103558; p <= 103560; p++)
  S[p] = 0;
for (p = 103571; p <= 103573; p++)
  S[p] = 0;
for (p = 103574; p <= 103576; p++)
  S[p] = 2;
for (p = 103577; p <= 103580; p++)
  S[p] = 0;
for (p = 103581; p <= 103583; p++)
  S[p] = 2;
for (p = 103595; p <= 103694; p++)
  S[p] = 0;
for (p = 103696; p <= 103699; p++)
  S[p] = 0;
for (p = 103700; p <= 103793; p++)
  S[p] = 2;
for (p = 103794; p <= 103890; p++)
  S[p] = 0;
for (p = 103891; p <= 103896; p++)
  S[p] = 2;
for (p = 103900; p <= 103971; p++)
  S[p] = 2;
for (p = 103972; p <= 103977; p++)
  S[p] = 0;
for (p = 112e3; p <= 112101; p++)
  S[p] = 0;
const LZ = { 102113: !0, 102100: !0, 3857: !0, 3785: !0 }, NZ = { 4326: !0, 3785: !0, 3857: !0, 102113: !0, 102100: !0, 104905: !0, 104971: !0 }, jk = 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]', $0 = [-20037508342788905e-9, 20037508342788905e-9], x0 = [-20037508342787e-6, 20037508342787e-6], c6 = { 102113: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: $0, origin: x0, dx: 1e-5 }, 102100: { wkTemplate: jk, valid: $0, origin: x0, dx: 1e-5 }, 3785: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: $0, origin: x0, dx: 1e-5 }, 3857: { wkTemplate: jk, valid: $0, origin: x0, dx: 1e-5 }, 4326: { wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]', altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104971: { wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104905: { wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 } };
function tn(e, t) {
  return e === t || e != null && t != null && (e.wkid != null || t.wkid != null ? e.wkid === t.wkid || Md(e) && Md(t) || t.latestWkid != null && e.wkid === t.latestWkid || e.latestWkid != null && t.wkid === e.latestWkid : !(!e.wkt || !t.wkt) && e.wkt.toUpperCase() === t.wkt.toUpperCase());
}
function el(e) {
  return en(e) && e.wkid && c6[e.wkid] || null;
}
function d6(e) {
  return !!en(e) && (e.wkid ? S[e.wkid] == null : !!e.wkt && !!/^\s*GEOGCS/i.test(e.wkt));
}
function FZ(e) {
  return !(oM(e) || lM(e));
}
function Wy(e) {
  return en(e) && e.wkid === 4326;
}
function EPe(e) {
  return en(e) && e.wkid === Id.CGCS2000;
}
function Md(e) {
  return en(e) && e.wkid != null && LZ[e.wkid] === !0;
}
function DZ(e) {
  return en(e) && e.wkid === 32662;
}
function sM(e) {
  return e === Id.GCSMARS2000 || e === Id.GCSMARS2000_SPHERE;
}
function oM(e) {
  return en(e) && e.wkid != null && sM(e.wkid);
}
function aM(e) {
  return e === Id.GCSMOON2000;
}
function lM(e) {
  return en(e) && e.wkid != null && aM(e.wkid);
}
function jZ(e) {
  return en(e) && e.wkid != null && NZ[e.wkid] === !0;
}
function en(e) {
  return e != null && (e.wkid != null && e.wkid >= 2e3 || e.wkt != null);
}
const VZ = { wkid: 4326, wkt: Ww(c6[4326].wkTemplate, { Central_Meridian: "0.0" }) }, zZ = { wkid: 102100, latestWkid: 3857 }, UZ = { wkid: 32662 };
function uM(e) {
  return { wkt: `GEOCCS["Spherical geocentric",
    DATUM["Not specified",
      SPHEROID["Sphere",${e.radius},0]],
    PRIMEM["Greenwich",0.0,
      AUTHORITY["EPSG","8901"]],
    UNIT["m",1.0],
    AXIS["Geocentric X",OTHER],
    AXIS["Geocentric Y",EAST],
    AXIS["Geocentric Z",NORTH]
  ]` };
}
const BZ = uM(Bt), p6 = uM(Xa), h6 = uM(ku), qZ = { wkt: `GEOCCS["WGS 84",
  DATUM["WGS_1984",
    SPHEROID["WGS 84",${Bt.radius},298.257223563,
      AUTHORITY["EPSG","7030"]],
    AUTHORITY["EPSG","6326"]],
  PRIMEM["Greenwich",0,
    AUTHORITY["EPSG","8901"]],
  UNIT["m",1.0,
    AUTHORITY["EPSG","9001"]],
  AXIS["Geocentric X",OTHER],
  AXIS["Geocentric Y",OTHER],
  AXIS["Geocentric Z",NORTH],
  AUTHORITY["EPSG","4978"]
]` };
function GZ(e) {
  return e != null && (oM(e) || tn(e, p6)) ? Xa : e != null && (lM(e) || tn(e, h6)) ? ku : Bt;
}
function IPe(e) {
  return sM(e) ? Xa : aM(e) ? ku : Bt;
}
const MPe = 39.37, HZ = Bt.radius * Math.PI / 200, f6 = /UNIT\[([^\]]+)\]\]$/i, yd = S, m6 = /UNIT\[([^\]]+)\]/i, WZ = /* @__PURE__ */ new Set([4261, 4305, 4807, 4810, 4811, 4812, 4816, 4819, 4821, 4901, 4902, 37225, 104139, 104140]), JZ = Mn()({ meter: "meters", foot: "feet", foot_us: "us-feet", foot_clarke: "clarke-feet", yard_clarke: "clarke-yards", link_clarke: "clarke-links", yard_sears: "sears-yards", foot_sears: "sears-feet", chain_sears: "sears-chains", chain_benoit_1895_b: "benoit-1895-b-chains", yard_indian: "indian-yards", yard_indian_1937: "indian-1937-yards", foot_gold_coast: "gold-coast-feet", chain_sears_1922_truncated: "sears-1922-truncated-chains", "50_kilometers": "50-kilometers", "150_kilometers": "150-kilometers" }), So = (e) => e * e, Sl = (e) => e * e * e, Jy = { length: { baseUnit: "meters", units: { millimeters: { inBaseUnits: 1e-3 }, centimeters: { inBaseUnits: 0.01 }, decimeters: { inBaseUnits: 0.1 }, meters: { inBaseUnits: 1 }, kilometers: { inBaseUnits: 1e3 }, inches: { inBaseUnits: 0.0254 }, feet: { inBaseUnits: 0.3048 }, yards: { inBaseUnits: 0.9144 }, miles: { inBaseUnits: 1609.344 }, "nautical-miles": { inBaseUnits: 1852 }, "us-feet": { inBaseUnits: 1200 / 3937 } } }, area: { baseUnit: "square-meters", units: { "square-millimeters": { inBaseUnits: So(1e-3) }, "square-centimeters": { inBaseUnits: So(0.01) }, "square-decimeters": { inBaseUnits: So(0.1) }, "square-meters": { inBaseUnits: 1 }, "square-kilometers": { inBaseUnits: So(1e3) }, "square-inches": { inBaseUnits: So(0.0254) }, "square-feet": { inBaseUnits: So(0.3048) }, "square-yards": { inBaseUnits: So(0.9144) }, "square-miles": { inBaseUnits: So(1609.344) }, "square-us-feet": { inBaseUnits: So(1200 / 3937) }, acres: { inBaseUnits: 15625e-7 * So(1609.344) }, ares: { inBaseUnits: 100 }, hectares: { inBaseUnits: 1e4 } } }, volume: { baseUnit: "liters", units: { liters: { inBaseUnits: 1 }, "cubic-millimeters": { inBaseUnits: 1e3 * Sl(1e-3) }, "cubic-centimeters": { inBaseUnits: 1e3 * Sl(0.01) }, "cubic-decimeters": { inBaseUnits: 1e3 * Sl(0.1) }, "cubic-meters": { inBaseUnits: 1e3 }, "cubic-kilometers": { inBaseUnits: 1e3 * Sl(1e3) }, "cubic-inches": { inBaseUnits: 1e3 * Sl(0.0254) }, "cubic-feet": { inBaseUnits: 1e3 * Sl(0.3048) }, "cubic-yards": { inBaseUnits: 1e3 * Sl(0.9144) }, "cubic-miles": { inBaseUnits: 1e3 * Sl(1609.344) } } }, angle: { baseUnit: "radians", units: { radians: { inBaseUnits: 1 }, degrees: { inBaseUnits: Math.PI / 180 } } } }, ZZ = (() => {
  const e = {};
  for (const t in Jy)
    for (const r in Jy[t].units)
      e[r] = t;
  return e;
})();
function KZ(e, t, r) {
  return e * Jy[r].units[t].inBaseUnits;
}
function YZ(e, t, r) {
  return e / Jy[r].units[t].inBaseUnits;
}
function q$(e) {
  const t = ZZ[e];
  if (!t)
    throw new Error("unknown type");
  return t;
}
function Vk(e, t = null) {
  return t = t || q$(e), Jy[t].baseUnit === e;
}
function Wi(e, t, r) {
  if (t === r)
    return e;
  const n = q$(t);
  if (n !== q$(r))
    throw new Error("incompatible units");
  const i = Vk(t, n) ? e : KZ(e, t, n);
  return Vk(r, n) ? i : YZ(i, r, n);
}
function QZ(e, t, r) {
  return Wi(e, t, "meters") / (r * Math.PI / 180);
}
function y6(e) {
  return JZ.fromJSON(e.toLowerCase()) || null;
}
function Ib(e) {
  if (e != null && !FZ(e))
    return 1;
  const t = Yd(e);
  return t > 1e5 ? 1 : t;
}
function XZ(e) {
  return Yd(e) >= GZ(e).metersPerDegree ? "meters" : v6(e);
}
function Yd(e, t = Bt.metersPerDegree) {
  return eK(e, !0) ?? t;
}
function eK(e, t = !1) {
  const r = e != null ? e.wkid : null, n = e != null ? e.wkt : null;
  let i = null;
  if (r) {
    if (sM(r))
      return Xa.metersPerDegree;
    if (aM(r))
      return ku.metersPerDegree;
    i = yd.values[yd[r]], !i && t && WZ.has(r) && (i = HZ);
  } else
    n && (w6(n) ? i = zk(f6.exec(n), i) : b6(n) && (i = zk(m6.exec(n), i)));
  return i;
}
function OPe(e) {
  return e.isGeographic ? 1 : Yd(e);
}
function zk(e, t) {
  return e && e[1] ? g6(e[1]) : t;
}
function g6(e) {
  return parseFloat(e.split(",")[1]);
}
function v6(e) {
  const t = e != null ? e.wkid : null, r = e != null ? e.wkt : null;
  let n = null;
  if (t)
    n = yd.units[yd[t]];
  else if (r) {
    const i = w6(r) ? f6 : b6(r) ? m6 : null;
    if (i) {
      const s = i.exec(r);
      s && s[1] && (n = rK(s[1]));
    }
  }
  return n != null ? y6(n) : null;
}
function b6(e) {
  return /^GEOCCS/i.test(e);
}
function w6(e) {
  return /^PROJCS/i.test(e);
}
const tK = 1e-7;
function rK(e) {
  const t = /[\\"\\']{1}([^\\"\\']+)/.exec(e);
  let r = t && t[1];
  if (!r || !yd.units.includes(r)) {
    const n = g6(e);
    r = null;
    const i = yd.values;
    for (let s = 0; s < i.length; ++s)
      if (Math.abs(n - i[s]) < tK) {
        r = yd.units[s];
        break;
      }
  }
  return r;
}
const nK = { esriAcres: "acres", esriAres: "ares", esriHectares: "hectares", esriSquareCentimeters: "square-centimeters", esriSquareDecimeters: "square-decimeters", esriSquareFeet: "square-feet", esriSquareInches: "square-inches", esriSquareKilometers: "square-kilometers", esriSquareMeters: "square-meters", esriSquareMiles: "square-miles", esriSquareMillimeters: "square-millimeters", esriSquareUsFeet: "square-us-feet", esriSquareYards: "square-yards" }, iK = { esriCentimeters: "centimeters", esriDecimeters: "decimeters", esriFeet: "feet", esriInches: "inches", esriKilometers: "kilometers", esriMeters: "meters", esriMiles: "miles", esriMillimeters: "millimeters", esriNauticalMiles: "nautical-miles", esriYards: "yards" }, sK = { esriDUDecimalDegrees: "degrees", esriDURadians: "radians" }, oK = Mn()(nK), aK = Mn()(iK), CPe = Mn()(sK);
var Eo;
let gt = Eo = class extends re {
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.wkid) {
      if (e.wkid === 102100)
        return Eo.WebMercator;
      if (e.wkid === 4326)
        return Eo.WGS84;
    }
    const t = new Eo();
    return t.read(e), t;
  }
  constructor(e) {
    super(e), this.latestWkid = null, this.wkid = null, this.wkt = null, this.vcsWkid = null, this.latestVcsWkid = null, this.imageCoordinateSystem = null;
  }
  normalizeCtorArgs(e) {
    return e && typeof e == "object" ? e : { [typeof e == "string" ? "wkt" : "wkid"]: e };
  }
  get isWGS84() {
    return Wy(this);
  }
  get isWebMercator() {
    return Md(this);
  }
  get isGeographic() {
    return d6(this);
  }
  get isWrappable() {
    return jZ(this);
  }
  get metersPerUnit() {
    return Yd(this);
  }
  get unit() {
    return v6(this) || (this.isGeographic ? "degrees" : null);
  }
  writeWkt(e, t) {
    this.wkid || (t.wkt = e);
  }
  clone() {
    if (this === Eo.WGS84)
      return Eo.WGS84;
    if (this === Eo.WebMercator)
      return Eo.WebMercator;
    const e = new Eo();
    return this.wkid != null ? (e.wkid = this.wkid, this.latestWkid != null && (e.latestWkid = this.latestWkid), this.vcsWkid != null && (e.vcsWkid = this.vcsWkid), this.latestVcsWkid != null && (e.latestVcsWkid = this.latestVcsWkid)) : this.wkt != null && (e.wkt = this.wkt), this.imageCoordinateSystem && (e.imageCoordinateSystem = j(this.imageCoordinateSystem)), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    if (this.imageCoordinateSystem || e.imageCoordinateSystem) {
      if (this.imageCoordinateSystem == null || e.imageCoordinateSystem == null)
        return !1;
      const { id: t, referenceServiceName: r } = e.imageCoordinateSystem, { geodataXform: n } = e.imageCoordinateSystem, i = this.imageCoordinateSystem;
      return t == null || n ? JSON.stringify(i) === JSON.stringify(e.imageCoordinateSystem) : r ? i.id === t && i.referenceServiceName === r : i.id === t;
    }
    return tn(this, e);
  }
  toJSON(e) {
    return this.write(void 0, e);
  }
};
gt.GCS_NAD_1927 = null, gt.WGS84 = null, gt.WebMercator = null, gt.PlateCarree = null, u([d({ readOnly: !0 })], gt.prototype, "isWGS84", null), u([d({ readOnly: !0 })], gt.prototype, "isWebMercator", null), u([d({ readOnly: !0 })], gt.prototype, "isGeographic", null), u([d({ readOnly: !0 })], gt.prototype, "isWrappable", null), u([d({ type: Ot, json: { write: !0 } })], gt.prototype, "latestWkid", void 0), u([d({ readOnly: !0 })], gt.prototype, "metersPerUnit", null), u([d({ readOnly: !0 })], gt.prototype, "unit", null), u([d({ type: Ot, json: { write: !0, origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkt == null };
} } } } } })], gt.prototype, "wkid", void 0), u([d({ type: String, json: { origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkid == null };
} } } } } })], gt.prototype, "wkt", void 0), u([ge("wkt"), ge("web-scene", "wkt")], gt.prototype, "writeWkt", null), u([d({ type: Ot, json: { write: !0 } })], gt.prototype, "vcsWkid", void 0), u([d({ type: Ot, json: { write: !0 } })], gt.prototype, "latestVcsWkid", void 0), u([d()], gt.prototype, "imageCoordinateSystem", void 0), gt = Eo = u([E("geoscene.geometry.SpatialReference")], gt), gt.prototype.toJSON.isDefaultToJSON = !0, gt.GCS_NAD_1927 = new gt({ wkid: 4267, wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]' }), gt.WGS84 = new gt(VZ), gt.WebMercator = new gt(zZ), gt.PlateCarree = new gt(UZ), Object.freeze && (Object.freeze(gt.GCS_NAD_1927), Object.freeze(gt.WGS84), Object.freeze(gt.WebMercator));
const tt = gt, _6 = "20230615", S6 = "1f5db620f7f53ad9484d45c023aeb6d5fbf0f873", lK = "4.27";
let cM = lK;
cM = "4.27.1";
const uK = { async request(e, t) {
  var a, l;
  const { default: r } = await Promise.resolve().then(() => MK), n = e.options, i = n.responseType;
  n.signal = t == null ? void 0 : t.signal, n.responseType = i === "native" || i === "native-request-init" ? "native-request-init" : i && ["blob", "json", "text"].includes(i) && ((a = i6(e.url)) != null && a.after) ? i : "array-buffer";
  const s = await r(e.url, n), o = { data: s.data, httpStatus: s.httpStatus, ssl: s.ssl };
  switch ((l = s.requestOptions) == null ? void 0 : l.responseType) {
    case "native-request-init":
      return delete o.data.signal, o;
    case "blob":
      o.data = await o.data.arrayBuffer();
      break;
    case "json":
      o.data = new TextEncoder().encode(JSON.stringify(o.data)).buffer;
      break;
    case "text":
      o.data = new TextEncoder().encode(o.data).buffer;
  }
  return { result: o, transferList: [o.data] };
} };
let st;
function kPe(e) {
  st = e;
}
function APe(e) {
  const t = st == null ? void 0 : st.findCredential(e);
  return t != null && t.token ? l6(e, "token", t.token) : e;
}
U("host-webworker");
const cK = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function $6(e) {
  const t = lo(e, !0);
  return !!t && t.endsWith(".arcgis.com") && !cK.includes(t) && !e.endsWith("/sharing/rest/generateToken");
}
function dK(e, t, r = !1, n) {
  return new Promise((i, s) => {
    if (ho(n))
      return void s(Uk());
    let o = () => {
      c(), s(new Error(`Unable to load ${t}`));
    }, a = () => {
      const h = e;
      c(), i(h);
    }, l = () => {
      if (!e)
        return;
      const h = e;
      c(), h.src = "", s(Uk());
    };
    const c = () => {
      U("geoscene-image-decode") || (e.removeEventListener("error", o), e.removeEventListener("load", a)), o = null, a = null, e = null, n != null && n.removeEventListener("abort", l), l = null, r && URL.revokeObjectURL(t);
    };
    n != null && n.addEventListener("abort", l), U("geoscene-image-decode") ? e.decode().then(a, o) : (e.addEventListener("error", o), e.addEventListener("load", a));
  });
}
function Uk() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const e = new Error();
    return e.name = "AbortError", e;
  }
}
const pK = "Timeout exceeded";
function hK() {
  return new Error(pK);
}
function fK(e) {
  bt.request.crossOriginNoCorsDomains || (bt.request.crossOriginNoCorsDomains = {});
  const t = bt.request.crossOriginNoCorsDomains;
  for (let r of e)
    r = r.toLowerCase(), /^https?:\/\//.test(r) ? t[lo(r) ?? ""] = 0 : (t[lo("http://" + r) ?? ""] = 0, t[lo("https://" + r) ?? ""] = 0);
}
function mK(e) {
  const t = bt.request.crossOriginNoCorsDomains;
  if (t) {
    let r = lo(e);
    if (r)
      return r = r.toLowerCase(), !Ph(r, Y3()) && t[r] < Date.now() - 36e5;
  }
  return !1;
}
async function yK(e) {
  var i;
  const t = bt.request.crossOriginNoCorsDomains, r = lo(e);
  t && r && (t[r.toLowerCase()] = Date.now());
  const n = Di(e);
  e = n.path, ((i = n.query) == null ? void 0 : i.f) === "json" && (e += "?f=json");
  try {
    await fetch(e, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}
async function zr(e, t) {
  var c;
  e instanceof URL && (e = e.toString()), (t == null ? void 0 : t.query) instanceof URLSearchParams && (t.query = Q3(t.query.toString().replaceAll("+", " ")));
  const r = Kd(e), n = s_(e);
  n || r || (e = ao(e));
  const i = { url: e, requestOptions: { ...t } };
  let s = i6(e);
  if (s) {
    const h = await xK(s, i);
    if (h != null)
      return { data: h, getHeader: dM, httpStatus: 200, requestOptions: i.requestOptions, url: i.url };
    s.after || s.error || (s = null);
  }
  if (e = i.url, (t = i.requestOptions).responseType === "image" && (U("host-webworker") || U("host-node")))
    throw Yo("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), i);
  if (t.method === "head") {
    if (t.body)
      throw Yo("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), i);
    if (r || n)
      throw Yo("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), i);
  }
  if (await _K(), Mb)
    return Mb.execute(e, t);
  const o = new AbortController();
  fs(t, () => o.abort());
  const a = { controller: o, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: !1, interceptor: s, params: i, redoRequest: !1, useIdentity: eo.useIdentity, useProxy: !1, useSSL: !1, withCredentials: !1 }, l = await EK(a);
  return (c = s == null ? void 0 : s.after) == null || c.call(s, l), l;
}
let Mb;
const eo = bt.request, x6 = "FormData" in globalThis, gK = [499, 498, 403, 401], vK = ["COM_0056", "COM_0057", "SB_0008"], bK = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i], dM = () => null, Ob = Symbol();
function wK(e) {
  const t = lo(e);
  t && !zr._corsServers.includes(t) && zr._corsServers.push(t);
}
function Bk(e) {
  const t = lo(e);
  return !t || t.endsWith(".arcgis.com") || zr._corsServers.includes(t) || eM(t);
}
function Yo(e, t, r, n) {
  let i = "Error";
  const s = { url: r.url, requestOptions: r.requestOptions, getHeader: dM, ssl: !1 };
  if (t instanceof G)
    return t.details ? (t.details = j(t.details), t.details.url = r.url, t.details.requestOptions = r.requestOptions) : t.details = s, t;
  if (t) {
    const o = n && ((c) => n.headers.get(c)), a = n == null ? void 0 : n.status, l = t.message;
    l && (i = l), o && (s.getHeader = o), s.httpStatus = (t.httpCode != null ? t.httpCode : t.code) || a || 0, s.subCode = t.subcode, s.messageCode = t.messageCode, typeof t.details == "string" ? s.messages = [t.details] : s.messages = t.details, s.raw = Ob in t ? t[Ob] : t;
  }
  return Fi(t) ? rr() : new G(e, i, s);
}
async function _K() {
  U("host-webworker") ? Mb || (Mb = await import("./request-helIhU5A.js")) : zr._abortableFetch || (zr._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function G$() {
  st || await import("./IdentityManager-qXWUx7Bf.js");
}
async function SK(e) {
  var a;
  const t = e.params.url, r = e.params.requestOptions, n = e.controller.signal, i = r.body;
  let s = null, o = null;
  if (x6 && "HTMLFormElement" in globalThis && (i instanceof FormData ? s = i : i instanceof HTMLFormElement && (s = new FormData(i))), typeof i == "string" && (o = i), e.fetchOptions = { cache: r.cacheBust && !("polyfill" in zr._abortableFetch) ? "no-cache" : "default", credentials: "same-origin", headers: r.headers || {}, method: r.method === "head" ? "HEAD" : "GET", mode: "cors", priority: eo.priority, redirect: "follow", signal: n }, (s || o) && (e.fetchOptions.body = s || o), r.authMode === "anonymous" && (e.useIdentity = !1), e.hasToken = !!(/token=/i.test(t) || (a = r.query) != null && a.token || s != null && s.get("token")), !e.hasToken && bt.apiKey && $6(t) && (r.query || (r.query = {}), r.query.token = bt.apiKey, e.hasToken = !0), e.useIdentity && !e.hasToken && !e.credentialToken && !T6(t) && !ho(n)) {
    let l;
    r.authMode === "immediate" ? (await G$(), l = await st.getCredential(t, { signal: n }), e.credential = l) : r.authMode === "no-prompt" ? (await G$(), l = await st.getCredential(t, { prompt: !1, signal: n }).catch(() => {
    }), e.credential = l) : st && (l = st.findCredential(t)), l && (e.credentialToken = l.token, e.useSSL = !!l.ssl);
  }
}
function T6(e) {
  return bK.some((t) => t.test(e));
}
async function $K(e) {
  let t = e.params.url;
  const r = e.params.requestOptions, n = e.fetchOptions ?? {}, i = s_(t) || Kd(t), s = r.responseType || "json", o = i ? 0 : r.timeout != null ? r.timeout : eo.timeout;
  let a = !1;
  if (!i) {
    e.useSSL && (t = nM(t)), r.cacheBust && n.cache === "default" && (t = l6(t, "request.preventCache", Date.now()));
    let m = { ...r.query };
    e.credentialToken && (m.token = e.credentialToken);
    let y = Gy(m);
    U("geoscene-url-encodes-apostrophe") && (y = y.replaceAll("'", "%27"));
    const g = t.length + 1 + y.length;
    let v;
    a = r.method === "delete" || r.method === "post" || r.method === "put" || !!r.body || g > eo.maxUrlLength;
    const b = r.useProxy || !!i_(t);
    if (b) {
      const w = gZ(t);
      v = w.path, !a && v.length + 1 + g > eo.maxUrlLength && (a = !0), w.query && (m = { ...w.query, ...m });
    }
    if (n.method === "HEAD" && (a || b)) {
      if (a)
        throw g > eo.maxUrlLength ? Yo("request:invalid-parameters", new Error("URL exceeds maximum length"), e.params) : Yo("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e.params);
      if (b)
        throw Yo("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e.params);
    }
    if (a ? (n.method = r.method === "delete" ? "DELETE" : r.method === "put" ? "PUT" : "POST", r.body ? t = P2(t, m) : (n.body = Gy(m), n.headers || (n.headers = {}), n.headers["Content-Type"] = "application/x-www-form-urlencoded")) : t = P2(t, m), b && (e.useProxy = !0, t = `${v}?${t}`), m.token && x6 && n.body instanceof FormData && !sZ(t) && n.body.set("token", m.token), r.hasOwnProperty("withCredentials"))
      e.withCredentials = r.withCredentials;
    else if (!Ph(t, Y3())) {
      if (eM(t))
        e.withCredentials = !0;
      else if (st) {
        const w = st.findServerInfo(t);
        w != null && w.webTierAuth && (e.withCredentials = !0);
      }
    }
    e.withCredentials && (n.credentials = "include", mK(t) && await yK(a ? P2(t, m) : t));
  }
  let l, c, h = 0, f = !1;
  o > 0 && (h = setTimeout(() => {
    f = !0, e.controller.abort();
  }, o));
  try {
    if (r.responseType === "native-request-init")
      c = n, c.url = t;
    else if (r.responseType !== "image" || n.cache !== "default" || n.method !== "GET" || a || TK(r.headers) || !i && !e.useProxy && eo.proxyUrl && !Bk(t)) {
      if (l = await zr._abortableFetch(t, n), e.useProxy || wK(t), r.responseType === "native")
        c = l;
      else if (n.method !== "HEAD")
        if (l.ok) {
          switch (s) {
            case "array-buffer":
              c = await l.arrayBuffer();
              break;
            case "blob":
            case "image":
              c = await l.blob();
              break;
            default:
              c = await l.text();
          }
          if (h && (clearTimeout(h), h = 0), s === "json" || s === "xml" || s === "document")
            if (c)
              switch (s) {
                case "json":
                  c = JSON.parse(c);
                  break;
                case "xml":
                  c = qk(c, "application/xml");
                  break;
                case "document":
                  c = qk(c, "text/html");
              }
            else
              c = null;
          if (c) {
            if (s === "array-buffer" || s === "blob") {
              const m = l.headers.get("Content-Type");
              if (m && /application\/json|text\/plain/i.test(m) && c[s === "blob" ? "size" : "byteLength"] <= 750)
                try {
                  const y = await new Response(c).json();
                  y.error && (c = y);
                } catch {
                }
            }
            s === "image" && c instanceof Blob && (c = await Gk(URL.createObjectURL(c), e, !0));
          }
        } else {
          c = await l.text();
          try {
            c = JSON.parse(c);
          } catch {
          }
        }
    } else
      c = await Gk(t, e);
  } catch (m) {
    if (m.name === "AbortError")
      throw f ? hK() : rr("Request canceled");
    if (!(!l && m instanceof TypeError && eo.proxyUrl) || r.body || r.method === "delete" || r.method === "head" || r.method === "post" || r.method === "put" || e.useProxy || Bk(t))
      throw m;
    e.redoRequest = !0, vZ({ proxyUrl: eo.proxyUrl, urlPrefix: lo(t) ?? "" });
  } finally {
    h && clearTimeout(h);
  }
  return [l, c];
}
async function xK(e, t) {
  if (e.responseData != null)
    return e.responseData;
  if (e.headers && (t.requestOptions.headers = { ...t.requestOptions.headers, ...e.headers }), e.query && (t.requestOptions.query = { ...t.requestOptions.query, ...e.query }), e.before) {
    let r, n;
    try {
      n = await e.before(t);
    } catch (i) {
      r = Yo("request:interceptor", i, t);
    }
    if ((n instanceof Error || n instanceof G) && (r = Yo("request:interceptor", n, t)), r)
      throw e.error && e.error(r), r;
    return n;
  }
}
function TK(e) {
  if (e) {
    for (const t of Object.getOwnPropertyNames(e))
      if (e[t])
        return !0;
  }
  return !1;
}
function qk(e, t) {
  let r;
  try {
    r = new DOMParser().parseFromString(e, t);
  } catch {
  }
  if (!r || r.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return r;
}
async function EK(e) {
  var s, o;
  let t, r;
  await SK(e);
  try {
    do
      [t, r] = await $K(e);
    while (!await IK(e, t, r));
  } catch (a) {
    const l = Yo("request:server", a, e.params, t);
    throw l.details.ssl = e.useSSL, (s = e.interceptor) != null && s.error && e.interceptor.error(l), l;
  }
  const n = e.params.url;
  if (r && /\/sharing\/rest\/(accounts|portals)\/self/i.test(n)) {
    if (!e.hasToken && !e.credentialToken && ((o = r.user) != null && o.username) && !eM(n)) {
      const a = lo(n, !0);
      a && eo.trustedServers.push(a);
    }
    Array.isArray(r.authorizedCrossOriginNoCorsDomains) && fK(r.authorizedCrossOriginNoCorsDomains);
  }
  const i = e.credential;
  if (i && st) {
    const a = st.findServerInfo(i.server);
    let l = a == null ? void 0 : a.owningSystemUrl;
    if (l) {
      l = l.replace(/\/?$/, "/sharing");
      const c = st.findCredential(l, i.userId);
      c && st._getIdenticalSvcIdx(l, c) === -1 && c.resources.unshift(l);
    }
  }
  return { data: r, getHeader: t ? (a) => t == null ? void 0 : t.headers.get(a) : dM, httpStatus: (t == null ? void 0 : t.status) ?? 200, requestOptions: e.params.requestOptions, ssl: e.useSSL, url: e.params.url };
}
async function IK(e, t, r) {
  var c;
  if (e.redoRequest)
    return e.redoRequest = !1, !1;
  const n = e.params.requestOptions;
  if (!t || n.responseType === "native" || n.responseType === "native-request-init")
    return !0;
  let i, s;
  if (r && (r.error ? i = r.error : r.status === "error" && Array.isArray(r.messages) && (i = { ...r }, i[Ob] = r, i.details = r.messages)), !i && !t.ok)
    throw i = new Error(`Unable to load ${t.url} status: ${t.status}`), i[Ob] = r, i;
  let o, a = null;
  i && (s = Number(i.code), a = i.hasOwnProperty("subcode") ? Number(i.subcode) : null, o = i.messageCode, o = o == null ? void 0 : o.toUpperCase());
  const l = n.authMode;
  if (s === 403 && (a === 4 || (c = i.message) != null && c.toLowerCase().includes("ssl") && !i.message.toLowerCase().includes("permission"))) {
    if (!e.useSSL)
      return e.useSSL = !0, !1;
  } else if (!e.hasToken && e.useIdentity && (l !== "no-prompt" || s === 498) && s !== void 0 && gK.includes(s) && !T6(e.params.url) && (s !== 403 || o && !vK.includes(o) && (a == null || a === 2 && e.credentialToken))) {
    await G$();
    try {
      const h = await st.getCredential(e.params.url, { error: Yo("request:server", i, e.params), prompt: l !== "no-prompt", signal: e.controller.signal, token: e.credentialToken });
      return e.credential = h, e.credentialToken = h.token, e.useSSL = e.useSSL || h.ssl, !1;
    } catch (h) {
      if (l === "no-prompt")
        return e.credential = void 0, e.credentialToken = void 0, !1;
      i = h;
    }
  }
  if (i)
    throw i;
  return !0;
}
function Gk(e, t, r = !1) {
  const n = t.controller.signal, i = new Image();
  return t.withCredentials ? i.crossOrigin = "use-credentials" : i.crossOrigin = "anonymous", i.alt = "", i.fetchPriority = eo.priority, i.src = e, dK(i, e, r, n);
}
zr._abortableFetch = null, zr._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];
const MK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: zr
}, Symbol.toStringTag, { value: "Module" }));
function ce(e, t, r) {
  let n, i;
  return t === void 0 || Array.isArray(t) ? (i = e, r = t, n = [void 0]) : (i = t, n = Array.isArray(e) ? e : [e]), (s, o) => {
    const a = s.constructor.prototype;
    n.forEach((l) => {
      const c = kF(s, l, i);
      c.read && typeof c.read == "object" || (c.read = {}), c.read.reader = a[o], r && (c.read.source = (c.read.source || []).concat(r));
    });
  };
}
let Io = class extends re {
  constructor(...t) {
    super(...t), this.type = null, this.hasM = !1, this.hasZ = !1, this.spatialReference = tt.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(t, r) {
    if (t instanceof tt)
      return t;
    if (t != null) {
      const n = new tt();
      return n.read(t, r), n;
    }
    return t;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(t) {
    return this.cache[t];
  }
  setCacheValue(t, r) {
    this.cache[t] = r;
  }
};
u([d()], Io.prototype, "type", void 0), u([d({ readOnly: !0 })], Io.prototype, "cache", null), u([d({ readOnly: !0 })], Io.prototype, "extent", null), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Io.prototype, "hasM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Io.prototype, "hasZ", void 0), u([d({ type: tt, json: { write: !0 }, value: tt.WGS84 })], Io.prototype, "spatialReference", void 0), u([ce("spatialReference")], Io.prototype, "readSpatialReference", null), Io = u([E("geoscene.geometry.Geometry")], Io);
const Bu = Io, OK = Object.prototype.toString;
function CK(e) {
  const t = "__accessorMetadata__" in e ? br(e) : e;
  return function(...r) {
    if (r.push(t), typeof r[2] == "number")
      throw new Error("Using @cast has parameter decorator is not supported since 4.16");
    return kK.apply(this, r);
  };
}
function kK(e, t, r, n) {
  Hw(e, t).cast = n;
}
function AK(e) {
  return (t, r) => {
    Hw(t, e).cast = t[r];
  };
}
function xt(...e) {
  if (e.length !== 3 || typeof e[1] != "string")
    return e.length === 1 && OK.call(e[0]) === "[object Function]" ? CK(e[0]) : e.length === 1 && typeof e[0] == "string" ? AK(e[0]) : void 0;
}
function PK(e, t) {
  const r = e.x - t.x, n = e.y - t.y, i = e.hasZ && t.hasZ ? e.z - t.z : 0;
  return Math.sqrt(r * r + n * n + i * i);
}
const RK = 57.29577951308232, LK = 0.017453292519943;
function Hk(e) {
  return e * RK;
}
function Wk(e) {
  return e * LK;
}
function RPe(e) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-e / Bt.radius));
}
function H$(e) {
  return e.wkid != null || e.wkt != null;
}
const R2 = [0, 0];
function Cb(e, t, r, n, i) {
  const s = e, o = i;
  if (o.spatialReference = r, "x" in s && "x" in o)
    [o.x, o.y] = t(s.x, s.y, R2, n);
  else if ("xmin" in s && "xmin" in o)
    [o.xmin, o.ymin] = t(s.xmin, s.ymin, R2, n), [o.xmax, o.ymax] = t(s.xmax, s.ymax, R2, n);
  else if ("paths" in s && "paths" in o || "rings" in s && "rings" in o) {
    const a = "paths" in s ? s.paths : s.rings, l = [];
    let c;
    for (let h = 0; h < a.length; h++) {
      const f = a[h];
      c = [], l.push(c);
      for (let m = 0; m < f.length; m++)
        c.push(t(f[m][0], f[m][1], [0, 0], n)), f[m].length > 2 && c[m].push(f[m][2]), f[m].length > 3 && c[m].push(f[m][3]);
    }
    "paths" in o ? o.paths = l : o.rings = l;
  } else if ("points" in s && "points" in o) {
    const a = s.points, l = [];
    for (let c = 0; c < a.length; c++)
      l[c] = t(a[c][0], a[c][1], [0, 0], n), a[c].length > 2 && l[c].push(a[c][2]), a[c].length > 3 && l[c].push(a[c][3]);
    o.points = l;
  }
  return i;
}
function zv(e, t) {
  const r = e && (H$(e) ? e : e.spatialReference), n = t && (H$(t) ? t : t.spatialReference);
  return !(e && "type" in e && e.type === "mesh" || t && "type" in t && t.type === "mesh" || !r || !n) && (!!tn(n, r) || Md(n) && Wy(r) || Md(r) && Wy(n));
}
function o_(e, t) {
  if (e == null)
    return null;
  const r = e.spatialReference, n = t && (H$(t) ? t : t.spatialReference);
  return zv(r, n) ? tn(r, n) ? j(e) : Md(n) ? Cb(e, uh, tt.WebMercator, !1, j(e)) : Wy(n) ? Cb(e, hy, tt.WGS84, !1, j(e)) : null : null;
}
function uh(e, t, r = [0, 0]) {
  t > 89.99999 ? t = 89.99999 : t < -89.99999 && (t = -89.99999);
  const n = Wk(t);
  return r[0] = Wk(e) * Bt.radius, r[1] = Bt.halfSemiMajorAxis * Math.log((1 + Math.sin(n)) / (1 - Math.sin(n))), r;
}
function hy(e, t, r = [0, 0], n = !1) {
  const i = Hk(e / Bt.radius);
  return r[0] = n ? i : i - 360 * Math.floor((i + 180) / 360), r[1] = Hk(Math.PI / 2 - 2 * Math.atan(Math.exp(-t / Bt.radius))), r;
}
function Uv(e, t = !1, r = j(e)) {
  return Cb(e, uh, tt.WebMercator, t, r);
}
function dm(e, t = !1, r = j(e)) {
  return Cb(e, hy, tt.WGS84, t, r);
}
var Bv;
const Df = [0, 0];
function Jk(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
let Rn = Bv = class extends Bu {
  static copy(e, t) {
    t._set("x", e._get("x")), t._set("y", e._get("y")), t._set("z", e._get("z")), t._set("m", e._get("m"));
    const r = e._get("spatialReference");
    t._set("spatialReference", Object.isFrozen(r) ? r : r.clone());
  }
  constructor(...e) {
    super(...e), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  normalizeCtorArgs(e, t, r, n, i) {
    let s;
    if (Array.isArray(e))
      s = e, i = t, e = s[0], t = s[1], r = s[2], n = s[3];
    else if (e && typeof e == "object") {
      if (s = e, e = s.x != null ? s.x : s.longitude, t = s.y != null ? s.y : s.latitude, r = s.z, n = s.m, (i = s.spatialReference) && i.declaredClass !== "geoscene.geometry.SpatialReference" && (i = new tt(i)), s.longitude != null || s.latitude != null) {
        if (s.longitude == null)
          se.getLogger(this).warn(".longitude=", "Latitude was defined without longitude");
        else if (s.latitude == null)
          se.getLogger(this).warn(".latitude=", "Longitude was defined without latitude");
        else if (!s.declaredClass && i && i.isWebMercator) {
          const a = uh(s.longitude, s.latitude, Df);
          e = a[0], t = a[1];
        }
      }
    } else
      Jk(r) ? (i = r, r = null) : Jk(n) && (i = n, n = null);
    const o = { x: e, y: t };
    return o.x == null && o.y != null ? se.getLogger(this).warn(".y=", "Y coordinate was defined without an X coordinate") : o.y == null && o.x != null && se.getLogger(this).warn(".x=", "X coordinate was defined without a Y coordinate"), i != null && (o.spatialReference = i), r != null && (o.z = r), n != null && (o.m = n), o;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return this.m !== void 0;
  }
  set hasM(e) {
    e !== (this._get("m") !== void 0) && (this._set("m", e ? 0 : void 0), this._set("hasM", e));
  }
  get hasZ() {
    return this.z !== void 0;
  }
  set hasZ(e) {
    e !== (this._get("z") !== void 0) && (this._set("z", e ? 0 : void 0), this._set("hasZ", e));
  }
  get latitude() {
    const { spatialReference: e, x: t, y: r } = this;
    if (e) {
      if (e.isWebMercator)
        return hy(t, r, Df)[1];
      if (e.isGeographic)
        return r;
    }
    return null;
  }
  set latitude(e) {
    const { spatialReference: t, x: r } = this;
    e != null && t && (t.isWebMercator ? this._set("y", uh(r, e, Df)[1]) : t.isGeographic && this._set("y", e), this._set("latitude", e));
  }
  get longitude() {
    const { x: e, y: t, spatialReference: r } = this;
    if (r) {
      if (r.isWebMercator)
        return hy(e, t, Df)[0];
      if (r.isGeographic)
        return e;
    }
    return null;
  }
  set longitude(e) {
    const { y: t, spatialReference: r } = this;
    e != null && r && (r.isWebMercator ? this._set("x", uh(e, t, Df)[0]) : r.isGeographic && this._set("x", e), this._set("longitude", e));
  }
  writeX(e, t, r) {
    t[r] = isNaN(e) ? "NaN" : e;
  }
  readX(e) {
    return typeof e == "string" ? NaN : e;
  }
  clone() {
    const e = new Bv();
    return e.x = this.x, e.y = this.y, e.z = this.z, e.m = this.m, e.spatialReference = this.spatialReference, e;
  }
  copy(e) {
    return Bv.copy(e, this), this;
  }
  equals(e) {
    if (e == null)
      return !1;
    const { x: t, y: r, z: n, m: i, spatialReference: s } = this, { z: o, m: a } = e;
    let { x: l, y: c, spatialReference: h } = e;
    if (!s.equals(h))
      if (s.isWebMercator && h.isWGS84)
        [l, c] = uh(l, c), h = s;
      else {
        if (!s.isWGS84 || !h.isWebMercator)
          return !1;
        [l, c] = hy(l, c), h = s;
      }
    return t === l && r === c && n === o && i === a && s.wkid === h.wkid;
  }
  offset(e, t, r) {
    return this.x += e, this.y += t, r != null && (this.z = (this.z ?? 0) + r), this;
  }
  normalize() {
    if (!this.spatialReference)
      return this;
    const e = el(this.spatialReference);
    if (!e)
      return this;
    let t = this.x;
    const [r, n] = e.valid, i = 2 * n;
    let s;
    return t > n ? (s = Math.ceil(Math.abs(t - n) / i), t -= s * i) : t < r && (s = Math.ceil(Math.abs(t - r) / i), t += s * i), this._set("x", t), this;
  }
  distance(e) {
    return PK(this, e);
  }
  toArray() {
    const e = this.hasZ, t = this.hasM;
    return e && t ? [this.x, this.y, this.z, this.m] : e ? [this.x, this.y, this.z] : t ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], Rn.prototype, "cache", null), u([d({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Rn.prototype, "hasM", null), u([d({ type: Boolean, json: { read: !1, write: { enabled: !1, overridePolicy: null } } })], Rn.prototype, "hasZ", null), u([d({ type: Number })], Rn.prototype, "latitude", null), u([d({ type: Number })], Rn.prototype, "longitude", null), u([d({ type: Number, json: { type: [Number, String], write: { isRequired: !0, allowNull: !0 } } }), xt((e) => isNaN(e) ? e : ls(e))], Rn.prototype, "x", void 0), u([ge("x")], Rn.prototype, "writeX", null), u([ce("x")], Rn.prototype, "readX", null), u([d({ type: Number, json: { write: !0 } })], Rn.prototype, "y", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Rn.prototype, "z", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Rn.prototype, "m", void 0), Rn = Bv = u([E("geoscene.geometry.Point")], Rn), Rn.prototype.toJSON.isDefaultToJSON = !0;
const Re = Rn, L2 = [0, 0];
function a_(e, t) {
  return t != null && Dn(e, t.x, t.y, t.z);
}
function LPe(e, t) {
  if (!t.points || t.points.length)
    return !1;
  for (const r of t.points)
    if (!Lh(e, r))
      return !1;
  return !0;
}
function NK(e, t) {
  const { xmin: r, ymin: n, zmin: i, xmax: s, ymax: o, zmax: a } = t;
  return e.hasZ && t.hasZ ? Dn(e, r, n, i) && Dn(e, r, o, i) && Dn(e, s, o, i) && Dn(e, s, n, i) && Dn(e, r, n, a) && Dn(e, r, o, a) && Dn(e, s, o, a) && Dn(e, s, n, a) : Dn(e, r, n) && Dn(e, r, o) && Dn(e, s, o) && Dn(e, s, n);
}
function Lh(e, t) {
  return Dn(e, t[0], t[1]);
}
function FK(e, t) {
  return Dn(e, t[0], t[1], t[2]);
}
function Dn(e, t, r, n) {
  return t >= e.xmin && t <= e.xmax && r >= e.ymin && r <= e.ymax && (n == null || !e.hasZ || n >= e.zmin && n <= e.zmax);
}
function E6(e, t) {
  return L2[1] = t.y, L2[0] = t.x, DK(e, L2);
}
function DK(e, t) {
  return I6(e.rings, t);
}
function I6(e, t) {
  if (!e)
    return !1;
  if (jK(e))
    return Zk(!1, e, t);
  let r = !1;
  for (let n = 0, i = e.length; n < i; n++)
    r = Zk(r, e[n], t);
  return r;
}
function jK(e) {
  return !Array.isArray(e[0][0]);
}
function Zk(e, t, r) {
  const [n, i] = r;
  let s = e, o = 0;
  for (let a = 0, l = t.length; a < l; a++) {
    o++, o === l && (o = 0);
    const [c, h] = t[a], [f, m] = t[o];
    (h < i && m >= i || m < i && h >= i) && c + (i - h) / (m - h) * (f - c) < n && (s = !s);
  }
  return s;
}
function VK(e, t) {
  return a_(e, t);
}
function zK(e, t) {
  const r = e.hasZ && t.hasZ;
  let n, i, s;
  if (e.xmin <= t.xmin) {
    if (n = t.xmin, e.xmax < n)
      return !1;
  } else if (n = e.xmin, t.xmax < n)
    return !1;
  if (e.ymin <= t.ymin) {
    if (i = t.ymin, e.ymax < i)
      return !1;
  } else if (i = e.ymin, t.ymax < i)
    return !1;
  if (r && t.hasZ) {
    if (e.zmin <= t.zmin) {
      if (s = t.zmin, e.zmax < s)
        return !1;
    } else if (s = e.zmin, t.zmax < s)
      return !1;
  }
  return !0;
}
function UK(e, t) {
  const { points: r, hasZ: n } = t, i = n ? FK : Lh;
  for (const s of r)
    if (i(e, s))
      return !0;
  return !1;
}
const Od = [0, 0], Cd = [0, 0], kd = [0, 0], Ad = [0, 0], BK = [Od, Cd, kd, Ad], M6 = [[kd, Od], [Od, Cd], [Cd, Ad], [Ad, kd]];
function qK(e, t) {
  return GK(e, t.rings);
}
function GK(e, t) {
  Od[0] = e.xmin, Od[1] = e.ymax, Cd[0] = e.xmax, Cd[1] = e.ymax, kd[0] = e.xmin, kd[1] = e.ymin, Ad[0] = e.xmax, Ad[1] = e.ymin;
  for (const r of BK)
    if (I6(t, r))
      return !0;
  for (const r of t) {
    if (!r.length)
      continue;
    let n = r[0];
    if (Lh(e, n))
      return !0;
    for (let i = 1; i < r.length; i++) {
      const s = r[i];
      if (Lh(e, s) || O6(n, s, M6))
        return !0;
      n = s;
    }
  }
  return !1;
}
function HK(e, t) {
  Od[0] = e.xmin, Od[1] = e.ymax, Cd[0] = e.xmax, Cd[1] = e.ymax, kd[0] = e.xmin, kd[1] = e.ymin, Ad[0] = e.xmax, Ad[1] = e.ymin;
  const r = t.paths;
  for (const n of r) {
    if (!r.length)
      continue;
    let i = n[0];
    if (Lh(e, i))
      return !0;
    for (let s = 1; s < n.length; s++) {
      const o = n[s];
      if (Lh(e, o) || O6(i, o, M6))
        return !0;
      i = o;
    }
  }
  return !1;
}
const Jr = [0, 0];
function WK(e) {
  for (let t = 0; t < e.length; t++) {
    const r = e[t];
    for (let i = 0; i < r.length - 1; i++) {
      const s = r[i], o = r[i + 1];
      for (let a = t + 1; a < e.length; a++)
        for (let l = 0; l < e[a].length - 1; l++) {
          const c = e[a][l], h = e[a][l + 1];
          if (W$(s, o, c, h, Jr) && !(Jr[0] === s[0] && Jr[1] === s[1] || Jr[0] === c[0] && Jr[1] === c[1] || Jr[0] === o[0] && Jr[1] === o[1] || Jr[0] === h[0] && Jr[1] === h[1]))
            return !0;
        }
    }
    const n = r.length;
    if (!(n <= 4))
      for (let i = 0; i < n - 3; i++) {
        let s = n - 1;
        i === 0 && (s = n - 2);
        const o = r[i], a = r[i + 1];
        for (let l = i + 2; l < s; l++) {
          const c = r[l], h = r[l + 1];
          if (W$(o, a, c, h, Jr) && !(Jr[0] === o[0] && Jr[1] === o[1] || Jr[0] === c[0] && Jr[1] === c[1] || Jr[0] === a[0] && Jr[1] === a[1] || Jr[0] === h[0] && Jr[1] === h[1]))
            return !0;
        }
      }
  }
  return !1;
}
function O6(e, t, r) {
  for (let n = 0; n < r.length; n++)
    if (W$(e, t, r[n][0], r[n][1]))
      return !0;
  return !1;
}
function W$(e, t, r, n, i) {
  const [s, o] = e, [a, l] = t, [c, h] = r, [f, m] = n, y = f - c, g = s - c, v = a - s, b = m - h, w = o - h, x = l - o, $ = b * v - y * x;
  if ($ === 0)
    return !1;
  const T = (y * w - b * g) / $, C = (v * w - x * g) / $;
  return T >= 0 && T <= 1 && C >= 0 && C <= 1 && (i && (i[0] = s + T * (a - s), i[1] = o + T * (l - o)), !0);
}
function JK(e) {
  switch (e) {
    case "esriGeometryEnvelope":
    case "extent":
      return zK;
    case "esriGeometryMultipoint":
    case "multipoint":
      return UK;
    case "esriGeometryPoint":
    case "point":
      return VK;
    case "esriGeometryPolygon":
    case "polygon":
      return qK;
    case "esriGeometryPolyline":
    case "polyline":
      return HK;
  }
}
var Ji;
function ZK(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
function $l(e, t, r) {
  return t == null ? r : r == null ? t : e(t, r);
}
let Rr = Ji = class extends Bu {
  constructor(...e) {
    super(...e), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(e, t, r, n, i) {
    return ZK(e) ? { spatialReference: e, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : typeof e == "object" ? (e.spatialReference = e.spatialReference == null ? tt.WGS84 : e.spatialReference, e) : { xmin: e, ymin: t, xmax: r, ymax: n, spatialReference: i ?? tt.WGS84 };
  }
  static fromBounds(e, t) {
    return new Ji({ xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: t });
  }
  static fromPoint(e) {
    return new Ji({ xmin: e.x, ymin: e.y, zmin: e.z, xmax: e.x, ymax: e.y, zmax: e.z, spatialReference: e.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const e = new Re({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (e.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (e.m = 0.5 * (this.mmin + this.mmax)), e;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return this.mmin != null && this.mmax != null;
  }
  get hasZ() {
    return this.zmin != null && this.zmax != null;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(e) {
    const t = this.center;
    return e.z != null && this.hasZ ? this.offset(e.x - t.x, e.y - t.y, e.z - t.z) : this.offset(e.x - t.x, e.y - t.y);
  }
  clone() {
    const e = new Ji();
    return e.xmin = this.xmin, e.ymin = this.ymin, e.xmax = this.xmax, e.ymax = this.ymax, e.spatialReference = this.spatialReference, this.zmin != null && (e.zmin = this.zmin, e.zmax = this.zmax), this.mmin != null && (e.mmin = this.mmin, e.mmax = this.mmax), e;
  }
  contains(e) {
    if (!e)
      return !1;
    const t = this.spatialReference, r = e.spatialReference;
    return t && r && !t.equals(r) && zv(t, r) && (e = t.isWebMercator ? Uv(e) : dm(e, !0)), e.type === "point" ? a_(this, e) : e.type === "extent" && NK(this, e);
  }
  equals(e) {
    if (this === e)
      return !0;
    if (e == null)
      return !1;
    const t = this.spatialReference, r = e.spatialReference;
    return t && r && !t.equals(r) && zv(t, r) && (e = t.isWebMercator ? Uv(e) : dm(e, !0)), this.xmin === e.xmin && this.ymin === e.ymin && this.zmin === e.zmin && this.mmin === e.mmin && this.xmax === e.xmax && this.ymax === e.ymax && this.zmax === e.zmax && this.mmax === e.mmax;
  }
  expand(e) {
    const t = 0.5 * (1 - e), r = this.width * t, n = this.height * t;
    if (this.xmin += r, this.ymin += n, this.xmax -= r, this.ymax -= n, this.hasZ) {
      const i = (this.zmax - this.zmin) * t;
      this.zmin += i, this.zmax -= i;
    }
    if (this.hasM) {
      const i = (this.mmax - this.mmin) * t;
      this.mmin += i, this.mmax -= i;
    }
    return this;
  }
  intersects(e) {
    if (e == null)
      return !1;
    e.type === "mesh" && (e = e.extent);
    const t = this.spatialReference, r = e.spatialReference;
    return t && r && !tn(t, r) && zv(t, r) && (e = t.isWebMercator ? Uv(e) : dm(e, !0)), JK(e.type)(this, e);
  }
  normalize() {
    const e = this._normalize(!1, !0);
    return Array.isArray(e) ? e : [e];
  }
  offset(e, t, r) {
    return this.xmin += e, this.ymin += t, this.xmax += e, this.ymax += t, r != null && (this.zmin += r, this.zmax += r), this;
  }
  shiftCentralMeridian() {
    return this._normalize(!0);
  }
  union(e) {
    return this === e || (this.xmin = Math.min(this.xmin, e.xmin), this.ymin = Math.min(this.ymin, e.ymin), this.xmax = Math.max(this.xmax, e.xmax), this.ymax = Math.max(this.ymax, e.ymax), (this.hasZ || e.hasZ) && (this.zmin = $l(Math.min, this.zmin, e.zmin), this.zmax = $l(Math.max, this.zmax, e.zmax)), (this.hasM || e.hasM) && (this.mmin = $l(Math.min, this.mmin, e.mmin), this.mmax = $l(Math.max, this.mmax, e.mmax))), this;
  }
  intersection(e) {
    return this === e ? this : e != null && this.intersects(e) ? (this.xmin = Math.max(this.xmin, e.xmin), this.ymin = Math.max(this.ymin, e.ymin), this.xmax = Math.min(this.xmax, e.xmax), this.ymax = Math.min(this.ymax, e.ymax), (this.hasZ || e.hasZ) && (this.zmin = $l(Math.max, this.zmin, e.zmin), this.zmax = $l(Math.min, this.zmax, e.zmax)), (this.hasM || e.hasM) && (this.mmin = $l(Math.max, this.mmin, e.mmin), this.mmax = $l(Math.min, this.mmax, e.mmax)), this) : null;
  }
  toJSON(e) {
    return this.write({}, e);
  }
  _shiftCM(e = el(this.spatialReference)) {
    if (!e || !this.spatialReference)
      return this;
    const t = this.spatialReference, r = this._getCM(e);
    if (r) {
      const n = t.isWebMercator ? dm(r) : r;
      this.xmin -= r.x, this.xmax -= r.x, t.isWebMercator || (n.x = this._normalizeX(n.x, e).x), this.spatialReference = new tt(Ww((t.isWGS84 ? e.altTemplate : null) ?? e.wkTemplate, { Central_Meridian: n.x }));
    }
    return this;
  }
  _getCM(e) {
    let t = null;
    const [r, n] = e.valid, i = this.xmin, s = this.xmax;
    return i >= r && i <= n && s >= r && s <= n || (t = this.center), t;
  }
  _normalize(e, t, r) {
    const n = this.spatialReference;
    if (!n)
      return this;
    const i = r ?? el(n);
    if (i == null)
      return this;
    const s = this._getParts(i).map((l) => l.extent);
    if (s.length < 2)
      return s[0] || this;
    if (s.length > 2)
      return e ? this._shiftCM(i) : this.set({ xmin: i.valid[0], xmax: i.valid[1] });
    if (e)
      return this._shiftCM(i);
    if (t)
      return s;
    let o = !0, a = !0;
    return s.forEach((l) => {
      l.hasZ || (o = !1), l.hasM || (a = !1);
    }), { rings: s.map((l) => {
      const c = [[l.xmin, l.ymin], [l.xmin, l.ymax], [l.xmax, l.ymax], [l.xmax, l.ymin], [l.xmin, l.ymin]];
      if (o) {
        const h = (l.zmax - l.zmin) / 2;
        for (let f = 0; f < c.length; f++)
          c[f].push(h);
      }
      if (a) {
        const h = (l.mmax - l.mmin) / 2;
        for (let f = 0; f < c.length; f++)
          c[f].push(h);
      }
      return c;
    }), hasZ: o, hasM: a, spatialReference: n };
  }
  _getParts(e) {
    let t = this.cache._parts;
    if (!t) {
      t = [];
      const { ymin: i, ymax: s, spatialReference: o } = this, a = this.width, l = this.xmin, c = this.xmax;
      let h;
      e = e || el(o);
      const [f, m] = e.valid;
      h = this._normalizeX(this.xmin, e);
      const y = h.x, g = h.frameId;
      h = this._normalizeX(this.xmax, e);
      const v = h.x, b = h.frameId, w = y === v && a > 0;
      if (a > 2 * m) {
        const x = new Ji(l < c ? y : v, i, m, s, o), $ = new Ji(f, i, l < c ? v : y, s, o), T = new Ji(0, i, m, s, o), C = new Ji(f, i, 0, s, o), I = [], O = [];
        x.contains(T) && I.push(g), x.contains(C) && O.push(g), $.contains(T) && I.push(b), $.contains(C) && O.push(b);
        for (let M = g + 1; M < b; M++)
          I.push(M), O.push(M);
        t.push({ extent: x, frameIds: [g] }, { extent: $, frameIds: [b] }, { extent: T, frameIds: I }, { extent: C, frameIds: O });
      } else
        y > v || w ? t.push({ extent: new Ji(y, i, m, s, o), frameIds: [g] }, { extent: new Ji(f, i, v, s, o), frameIds: [b] }) : t.push({ extent: new Ji(y, i, v, s, o), frameIds: [g] });
      this.cache._parts = t;
    }
    const r = this.hasZ, n = this.hasM;
    if (r || n) {
      const i = {};
      r && (i.zmin = this.zmin, i.zmax = this.zmax), n && (i.mmin = this.mmin, i.mmax = this.mmax);
      for (let s = 0; s < t.length; s++)
        t[s].extent.set(i);
    }
    return t;
  }
  _normalizeX(e, t) {
    const [r, n] = t.valid, i = 2 * n;
    let s, o = 0;
    return e > n ? (s = Math.ceil(Math.abs(e - n) / i), e -= s * i, o = s) : e < r && (s = Math.ceil(Math.abs(e - r) / i), e += s * i, o = -s), { x: e, frameId: o };
  }
};
u([d({ readOnly: !0 })], Rr.prototype, "cache", null), u([d({ readOnly: !0 })], Rr.prototype, "center", null), u([d({ readOnly: !0 })], Rr.prototype, "extent", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], Rr.prototype, "hasM", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: null } } })], Rr.prototype, "hasZ", null), u([d({ readOnly: !0 })], Rr.prototype, "height", null), u([d({ readOnly: !0 })], Rr.prototype, "width", null), u([d({ type: Number, json: { type: [Number, String], write: { enabled: !0, allowNull: !0 } } })], Rr.prototype, "xmin", void 0), u([d({ type: Number, json: { write: !0 } })], Rr.prototype, "ymin", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Rr.prototype, "mmin", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Rr.prototype, "zmin", void 0), u([d({ type: Number, json: { write: !0 } })], Rr.prototype, "xmax", void 0), u([d({ type: Number, json: { write: !0 } })], Rr.prototype, "ymax", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], Rr.prototype, "mmax", void 0), u([d({ type: Number, json: { origins: { "web-scene": { write: !1 } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], Rr.prototype, "zmax", void 0), Rr = Ji = u([E("geoscene.geometry.Extent")], Rr), Rr.prototype.toJSON.isDefaultToJSON = !0;
const Ct = Rr;
let fy;
var a5, l5;
const KK = ((a5 = globalThis.geosceneConfig) == null ? void 0 : a5.locale) ?? ((l5 = globalThis.dojoConfig) == null ? void 0 : l5.locale);
function C6() {
  var e;
  return KK ?? ((e = globalThis.navigator) == null ? void 0 : e.language) ?? "en";
}
function uo() {
  return fy === void 0 && (fy = C6()), fy;
}
const my = [];
function k6(e) {
  return my.push(e), { remove() {
    my.splice(my.indexOf(e), 1);
  } };
}
const J$ = [];
function pM(e) {
  return J$.push(e), { remove() {
    my.splice(J$.indexOf(e), 1);
  } };
}
function YK() {
  const e = C6();
  fy !== e && (fy = e, [...J$].forEach((t) => {
    t.call(null, e);
  }), [...my].forEach((t) => {
    t.call(null, e);
  }));
}
var u5;
(u5 = globalThis.addEventListener) == null || u5.call(globalThis, "languagechange", YK);
let T0;
function QK(e) {
  return T0 && !T0.destroyed || (T0 = e()), T0;
}
var Z$;
const XK = new et({ avgRating: "avg-rating", numRatings: "num-ratings", numComments: "num-comments", numViews: "num-views" });
let Zi = Z$ = class extends Ae {
  constructor(e) {
    super(e), this.categories = null, this.disableExtraQuery = !1, this.extent = null, this.filter = null, this.num = 10, this.query = null, this.sortField = null, this.start = 1;
  }
  get sortOrder() {
    return this._get("sortOrder") || "asc";
  }
  set sortOrder(e) {
    e !== "asc" && e !== "desc" || this._set("sortOrder", e);
  }
  clone() {
    return new Z$({ categories: this.categories ? j(this.categories) : null, disableExtraQuery: this.disableExtraQuery, extent: this.extent ? this.extent.clone() : null, filter: this.filter, num: this.num, query: this.query, sortField: this.sortField, sortOrder: this.sortOrder, start: this.start });
  }
  toRequestOptions(e, t) {
    let r = [];
    this.categories && (r = this.categories.map((o) => Array.isArray(o) ? JSON.stringify(o) : o));
    let n = "";
    if (this.extent) {
      const o = o_(this.extent, tt.WGS84);
      o != null && (n = `${o.xmin},${o.ymin},${o.xmax},${o.ymax}`);
    }
    let i = this.query;
    !this.disableExtraQuery && e.extraQuery && (i = "(" + i + ")" + e.extraQuery);
    const s = { categories: r, bbox: n, q: i, filter: this.filter, num: this.num, sortField: null, sortOrder: null, start: this.start };
    return this.sortField && (s.sortField = this.sortField.split(",").map((o) => XK.toJSON(o.trim())).join(","), s.sortOrder = this.sortOrder), { query: { ...t, ...s } };
  }
};
u([d()], Zi.prototype, "categories", void 0), u([d()], Zi.prototype, "disableExtraQuery", void 0), u([d({ type: Ct })], Zi.prototype, "extent", void 0), u([d()], Zi.prototype, "filter", void 0), u([d()], Zi.prototype, "num", void 0), u([d()], Zi.prototype, "query", void 0), u([d()], Zi.prototype, "sortField", void 0), u([d()], Zi.prototype, "sortOrder", null), u([d()], Zi.prototype, "start", void 0), Zi = Z$ = u([E("geoscene.portal.PortalQueryParams")], Zi);
const Wo = Zi;
let cc = class extends Ae {
  constructor(t) {
    super(t), this.nextQueryParams = null, this.queryParams = null, this.results = null, this.total = null;
  }
};
u([d()], cc.prototype, "nextQueryParams", void 0), u([d()], cc.prototype, "queryParams", void 0), u([d()], cc.prototype, "results", void 0), u([d()], cc.prototype, "total", void 0), cc = u([E("geoscene.portal.PortalQueryResult")], cc);
const eY = cc;
let _a = class extends re {
  constructor(t) {
    super(t), this.created = null, this.id = null, this.portal = null, this.title = null, this.username = null;
  }
  get url() {
    const t = this.get("portal.restUrl");
    return t ? `${t}/content/users/${this.username}/${this.id}` : null;
  }
  toJSON() {
    throw new G("internal:not-yet-implemented", "PortalFolder.toJSON is not yet implemented");
  }
};
u([d({ type: Date })], _a.prototype, "created", void 0), u([d()], _a.prototype, "id", void 0), u([d()], _a.prototype, "portal", void 0), u([d()], _a.prototype, "title", void 0), u([d({ readOnly: !0 })], _a.prototype, "url", null), u([d()], _a.prototype, "username", void 0), _a = u([E("geoscene.portal.PortalFolder")], _a);
const tY = _a;
let Lr = class extends re {
  constructor(t) {
    super(t), this.access = null, this.created = null, this.description = null, this.id = null, this.isInvitationOnly = !1, this.modified = null, this.owner = null, this.portal = null, this.snippet = null, this.sortField = null, this.sortOrder = null, this.tags = null, this.title = null;
  }
  get thumbnailUrl() {
    var n;
    const t = this.url, r = this.thumbnail;
    return t && r && this.portal ? (n = this.portal) == null ? void 0 : n.normalizeUrl(`${t}/info/${r}?f=json`) : null;
  }
  get url() {
    const t = this.get("portal.restUrl");
    return t ? t + "/community/groups/" + this.id : null;
  }
  fetchCategorySchema(t) {
    return as(this.portal).request(this.url + "/categorySchema", t).then((r) => {
      const n = r.categorySchema || [];
      return n.some((i) => i.source === "contentCategorySetsGroupQuery.LivingAtlas") ? this._fetchCategorySchemaSet("LivingAtlas", t) : n;
    });
  }
  fetchMembers(t) {
    return as(this.portal).request(this.url + "/users", t);
  }
  getThumbnailUrl(t) {
    let r = this.thumbnailUrl;
    return r && t && (r += `&w=${t}`), r;
  }
  toJSON() {
    throw new G("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  queryItems(t, r) {
    let n = br(Wo, t);
    const i = as(this.portal);
    return parseFloat(i.currentVersion) > 5 ? (n = n || new Wo(), i.queryPortal(`/content/groups/${this.id}/search`, n, "PortalItem", r)) : (n = n ? n.clone() : new Wo(), n.query = "group:" + this.id + (n.query ? " " + n.query : ""), i.queryItems(n, r));
  }
  _fetchCategorySchemaSet(t, r) {
    const n = as(this.portal);
    return n.fetchSelf(n.authMode, !0, r).then((i) => {
      const s = i.contentCategorySetsGroupQuery;
      if (s) {
        const o = new Wo();
        return o.disableExtraQuery = !0, o.num = 1, o.query = s, n.queryGroups(o, r);
      }
      throw new G("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery value not found");
    }).then((i) => {
      if (i.total) {
        const s = i.results[0], o = new Wo();
        return o.num = 1, o.query = `typekeywords:"${t}"`, s.queryItems(o, r);
      }
      throw new G("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery group not found");
    }).then((i) => i.total ? i.results[0].fetchData("json", r).then((s) => {
      const o = s && s.categorySchema;
      return o && o.length ? o : [];
    }) : []);
  }
};
u([d()], Lr.prototype, "access", void 0), u([d({ type: Date })], Lr.prototype, "created", void 0), u([d()], Lr.prototype, "description", void 0), u([d()], Lr.prototype, "id", void 0), u([d()], Lr.prototype, "isInvitationOnly", void 0), u([d({ type: Date })], Lr.prototype, "modified", void 0), u([d()], Lr.prototype, "owner", void 0), u([d()], Lr.prototype, "portal", void 0), u([d()], Lr.prototype, "snippet", void 0), u([d()], Lr.prototype, "sortField", void 0), u([d()], Lr.prototype, "sortOrder", void 0), u([d()], Lr.prototype, "tags", void 0), u([d()], Lr.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], Lr.prototype, "thumbnailUrl", null), u([d()], Lr.prototype, "title", void 0), u([d({ readOnly: !0 })], Lr.prototype, "url", null), Lr = u([E("geoscene.portal.PortalGroup")], Lr);
const K$ = Lr, rY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: K$
}, Symbol.toStringTag, { value: "Module" }));
var Y$;
let Ft = Y$ = class extends re {
  constructor(...e) {
    super(...e), this.access = null, this.created = null, this.culture = null, this.description = null, this.email = null, this.fullName = null, this.modified = null, this.orgId = null, this.portal = null, this.preferredView = null, this.privileges = null, this.region = null, this.role = null, this.roleId = null, this.sourceJSON = null, this.units = null, this.username = null, this.userType = null;
  }
  get thumbnailUrl() {
    const e = this.url, t = this.thumbnail;
    return e && t ? this.portal.normalizeUrl(`${e}/info/${t}?f=json`) : null;
  }
  get userContentUrl() {
    const e = this.get("portal.restUrl");
    return e ? `${e}/content/users/${this.username}` : null;
  }
  get url() {
    const e = this.get("portal.restUrl");
    return e ? `${e}/community/users/${this.username}` : null;
  }
  addItem(e) {
    const t = e && e.item, r = e && e.data, n = e && e.folder, i = { method: "post" };
    t && (i.query = t.createPostQuery(), r != null && (typeof r == "string" ? i.query.text = r : typeof r == "object" && (i.query.text = JSON.stringify(r))));
    let s = this.userContentUrl;
    return n && (s += "/" + (typeof n == "string" ? n : n.id)), this.portal.request(s + "/addItem", i).then((o) => (t.id = o.id, t.portal = this.portal, t.loaded ? t.reload() : t.load()));
  }
  deleteItem(e) {
    let t = this.userContentUrl;
    return e.ownerFolder && (t += "/" + e.ownerFolder), this.portal.request(t + `/items/${e.id}/delete`, { method: "post" }).then(() => {
      e.id = null, e.portal = null;
    });
  }
  deleteItems(e) {
    const t = this.userContentUrl + "/deleteItems", r = e.map((n) => n.id);
    if (r.length) {
      const n = { method: "post", query: { items: r.join(",") } };
      return this.portal.request(t, n).then(() => {
        e.forEach((i) => {
          i.id = null, i.portal = null;
        });
      });
    }
    return Promise.resolve(void 0);
  }
  fetchFolders() {
    const e = { query: { num: 1 } };
    return this.portal.request(this.userContentUrl ?? "", e).then((t) => {
      let r;
      return r = t && t.folders ? t.folders.map((n) => {
        const i = tY.fromJSON(n);
        return i.portal = this.portal, i;
      }) : [], r;
    });
  }
  fetchGroups() {
    return this.portal.request(this.url ?? "").then((e) => {
      let t;
      return t = e && e.groups ? e.groups.map((r) => {
        const n = K$.fromJSON(r);
        return n.portal = this.portal, n;
      }) : [], t;
    });
  }
  fetchItems(e) {
    const t = e ?? {};
    let r, n = this.userContentUrl ?? "";
    return t.folder && (n += "/" + t.folder.id), Promise.resolve().then(() => A6).then(({ default: i }) => {
      r = i;
      const s = { folders: !1, num: t.num || 10, start: t.start || 1, sortField: t.sortField || "created", sortOrder: t.sortOrder || "asc" };
      return this.portal.request(n, { query: s });
    }).then((i) => {
      let s;
      return i && i.items ? (s = i.items.map((o) => {
        const a = r.fromJSON(o);
        return a.portal = this.portal, a;
      }), Promise.all(s.map((o) => o.load())).catch((o) => o).then(() => ({ items: s, nextStart: i.nextStart, total: i.total }))) : { items: [], nextStart: -1, total: 0 };
    });
  }
  fetchTags() {
    return this.portal.request(this.url + "/tags").then((e) => e.tags);
  }
  getThumbnailUrl(e) {
    let t = this.thumbnailUrl;
    return t && e && (t += `&w=${e}`), t;
  }
  queryFavorites(e) {
    return this.favGroupId ? (this._favGroup || (this._favGroup = new K$({ id: this.favGroupId, portal: this.portal })), this._favGroup.queryItems(e)) : Promise.reject(new G("internal:unknown", "Unknown internal error", { internalError: "Unknown favGroupId" }));
  }
  toJSON() {
    throw new G("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    const t = new Y$();
    return t.sourceJSON = e, t.read(e), t;
  }
};
u([d()], Ft.prototype, "access", void 0), u([d({ type: Date })], Ft.prototype, "created", void 0), u([d()], Ft.prototype, "culture", void 0), u([d()], Ft.prototype, "description", void 0), u([d()], Ft.prototype, "email", void 0), u([d()], Ft.prototype, "favGroupId", void 0), u([d()], Ft.prototype, "fullName", void 0), u([d({ type: Date })], Ft.prototype, "modified", void 0), u([d()], Ft.prototype, "orgId", void 0), u([d()], Ft.prototype, "portal", void 0), u([d()], Ft.prototype, "preferredView", void 0), u([d()], Ft.prototype, "privileges", void 0), u([d()], Ft.prototype, "region", void 0), u([d()], Ft.prototype, "role", void 0), u([d()], Ft.prototype, "roleId", void 0), u([d()], Ft.prototype, "sourceJSON", void 0), u([d()], Ft.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], Ft.prototype, "thumbnailUrl", null), u([d()], Ft.prototype, "units", void 0), u([d({ readOnly: !0 })], Ft.prototype, "userContentUrl", null), u([d({ readOnly: !0 })], Ft.prototype, "url", null), u([d()], Ft.prototype, "username", void 0), u([d()], Ft.prototype, "userType", void 0), Ft = Y$ = u([E("geoscene.portal.PortalUser")], Ft);
const hM = Ft, nY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: hM
}, Symbol.toStringTag, { value: "Module" }));
var Sa;
let E0;
const Kk = { PortalGroup: () => Promise.resolve().then(() => rY), PortalItem: () => Promise.resolve().then(() => A6), PortalUser: () => Promise.resolve().then(() => nY) };
let pe = Sa = class extends Lg(sl) {
  constructor(e) {
    super(e), this._esriIdCredentialCreateHandle = null, this.access = null, this.allSSL = !1, this.authMode = "auto", this.authorizedCrossOriginDomains = null, this.basemapGalleryGroupQuery = null, this.basemapGalleryGroupQuery3D = null, this.bingKey = null, this.canListApps = !1, this.canListData = !1, this.canListPreProvisionedItems = !1, this.canProvisionDirectPurchase = !1, this.canSearchPublic = !0, this.canShareBingPublic = !1, this.canSharePublic = !1, this.canSignInArcGIS = !1, this.canSignInIDP = !1, this.colorSetsGroupQuery = null, this.commentsEnabled = !1, this.created = null, this.culture = null, this.customBaseUrl = null, this.defaultBasemap = null, this.defaultDevBasemap = null, this.defaultExtent = null, this.defaultVectorBasemap = null, this.description = null, this.devBasemapGalleryGroupQuery = null, this.eueiEnabled = null, this.featuredGroups = null, this.featuredItemsGroupQuery = null, this.galleryTemplatesGroupQuery = null, this.livingAtlasGroupQuery = null, this.hasCategorySchema = !1, this.helperServices = null, this.homePageFeaturedContent = null, this.homePageFeaturedContentCount = null, this.httpPort = null, this.httpsPort = null, this.id = null, this.ipCntryCode = null, this.isPortal = !1, this.isReadOnly = !1, this.layerTemplatesGroupQuery = null, this.maxTokenExpirationMinutes = null, this.modified = null, this.name = null, this.portalHostname = null, this.portalMode = null, this.portalProperties = null, this.region = null, this.rotatorPanels = null, this.showHomePageDescription = !1, this.sourceJSON = null, this.supportsHostedServices = !1, this.symbolSetsGroupQuery = null, this.templatesGroupQuery = null, this.units = null, this.url = bt.portalUrl, this.urlKey = null, this.user = null, this.use3dBasemaps = !0, this.useStandardizedQuery = !1, this.useVectorBasemaps = !1, this.vectorBasemapGalleryGroupQuery = null;
  }
  normalizeCtorArgs(e) {
    return typeof e == "string" ? { url: e } : e;
  }
  destroy() {
    Yk.unregister(this), this.defaultBasemap = Vt(this.defaultBasemap), this.defaultDevBasemap = Vt(this.defaultDevBasemap), this.defaultVectorBasemap = Vt(this.defaultVectorBasemap), this._esriIdCredentialCreateHandle = tr(this._esriIdCredentialCreateHandle);
  }
  readAuthorizedCrossOriginDomains(e) {
    if (e)
      for (const t of e)
        bt.request.trustedServers.includes(t) || bt.request.trustedServers.push(t);
    return e;
  }
  readDefaultBasemap(e) {
    return this._readBasemap(e);
  }
  readDefaultDevBasemap(e) {
    return this._readBasemap(e);
  }
  readDefaultVectorBasemap(e) {
    return this._readBasemap(e);
  }
  get extraQuery() {
    const e = !(this.user && this.user.orgId) || this.canSearchPublic;
    return this.id && !e ? ` AND orgid:${this.id}` : null;
  }
  get isOrganization() {
    return !!this.access;
  }
  get itemPageUrl() {
    return this.url ? `${this.url}/home/item.html` : null;
  }
  get restUrl() {
    let e = this.url;
    if (e) {
      const t = e.indexOf("/sharing");
      e = t > 0 ? e.substring(0, t) : this.url.replace(/\/+$/, ""), e += "/sharing/rest";
    }
    return e;
  }
  get thumbnailUrl() {
    const e = this.restUrl, t = this.thumbnail;
    return e && t ? this._normalizeSSL(e + "/portals/self/resources/" + t) : null;
  }
  readUrlKey(e) {
    return e && e.toLowerCase();
  }
  readUser(e) {
    let t = null;
    return e && (t = hM.fromJSON(e), t.portal = this), t;
  }
  load(e) {
    const t = Promise.resolve().then(() => MY).then(({ default: r }) => {
      lr(e), E0 = r;
    }).then(() => this.sourceJSON ? this.sourceJSON : this.fetchSelf(this.authMode, !1, e)).then((r) => {
      var n;
      if (st) {
        const i = st;
        this.credential = i.findCredential(this.restUrl), this.credential || this.authMode !== Sa.AUTH_MODE_AUTO || ((n = this._esriIdCredentialCreateHandle) == null || n.remove(), this._esriIdCredentialCreateHandle = i.on("credential-create", iY(new WeakRef(this))), Yk.register(this, this._esriIdCredentialCreateHandle, this));
      }
      this.sourceJSON = r, this.read(r);
    });
    return this.addResolvingPromise(t), Promise.resolve(this);
  }
  async createElevationLayers() {
    await this.load();
    const e = this._getHelperService("defaultElevationLayers"), t = (await import("./ElevationLayer-xSkPc64b.js")).default;
    return e ? e.map((r) => new t({ id: r.id, url: r.url })) : [];
  }
  async fetchBasemaps(e, t) {
    const r = await this._fetchBasemaps(e, t);
    if ((t == null ? void 0 : t.include3d) === !0 && this.use3dBasemaps !== !1) {
      const n = await this._fetchBasemaps3D(e, t);
      r.unshift(...n);
    }
    return r;
  }
  fetchCategorySchema(e) {
    return this.hasCategorySchema ? this.request(this.restUrl + "/portals/self/categorySchema", e).then((t) => t.categorySchema) : ho(e) ? Promise.reject(rr()) : Promise.resolve([]);
  }
  fetchFeaturedGroups(e) {
    const t = this.featuredGroups, r = new Wo();
    if (r.num = 100, r.sortField = "title", t && t.length) {
      const n = [];
      for (const i of t)
        n.push(`(title:"${i.title}" AND owner:${i.owner})`);
      return r.query = n.join(" OR "), this.queryGroups(r, e).then((i) => i.results);
    }
    return ho(e) ? Promise.reject(rr()) : Promise.resolve([]);
  }
  fetchRegions(e) {
    var r;
    const t = ((r = this.user) == null ? void 0 : r.culture) || this.culture || uo();
    return this.request(this.restUrl + "/portals/regions", { ...e, query: { culture: t } });
  }
  fetchSettings(e) {
    var r;
    const t = ((r = this.user) == null ? void 0 : r.culture) || this.culture || uo();
    return this.request(this.restUrl + "/portals/self/settings", { ...e, query: { culture: t } });
  }
  static getDefault() {
    return QK(() => new Sa());
  }
  queryGroups(e, t) {
    return this.queryPortal("/community/groups", e, "PortalGroup", t);
  }
  queryItems(e, t) {
    return this.queryPortal("/search", e, "PortalItem", t);
  }
  queryUsers(e, t) {
    return e.sortField || (e.sortField = "username"), this.queryPortal("/community/users", e, "PortalUser", t);
  }
  fetchSelf(e = this.authMode, t = !1, r) {
    const n = this.restUrl + "/portals/self", i = { authMode: e, query: { culture: uo().toLowerCase() }, ...r };
    return i.authMode === "auto" && (i.authMode = "no-prompt"), t && (i.query.default = !0), this.request(n, i);
  }
  queryPortal(e, t, r, n) {
    const i = br(Wo, t), s = (o) => this.request(this.restUrl + e, { ...i.toRequestOptions(this), ...n }).then((a) => {
      const l = i.clone();
      return l.start = a.nextStart, new eY({ nextQueryParams: l, queryParams: i, total: a.total, results: Sa._resultsToTypedArray(o, { portal: this }, a, n) });
    }).then((a) => Promise.all(a.results.map((l) => typeof l.when == "function" ? l.when() : a)).then(() => a, (l) => (Go(l), a)));
    return r && Kk[r] ? Kk[r]().then(({ default: o }) => (lr(n), s(o))) : s();
  }
  signIn() {
    if (this.authMode === Sa.AUTH_MODE_ANONYMOUS)
      return Promise.reject(new G("portal:invalid-auth-mode", `Current "authMode"' is "${this.authMode}"`));
    if (this.loadStatus === "failed")
      return Promise.reject(this.loadError);
    const e = (t) => Promise.resolve().then(() => this.loadStatus === "not-loaded" ? (t || (this.authMode = "immediate"), this.load().then(() => null)) : this.loadStatus === "loading" ? this.load().then(() => this.credential ? null : (this.credential = t, this.fetchSelf("immediate"))) : this.user && this.credential === t ? null : (this.credential = t, this.fetchSelf("immediate"))).then((r) => {
      r && (this.sourceJSON = r, this.read(r));
    });
    return st ? st.getCredential(this.restUrl).then((t) => e(t)) : e(this.credential);
  }
  normalizeUrl(e) {
    const t = this.credential && this.credential.token;
    return this._normalizeSSL(t ? e + (e.includes("?") ? "&" : "?") + "token=" + t : e);
  }
  requestToTypedArray(e, t, r) {
    return this.request(e, t).then((n) => {
      const i = Sa._resultsToTypedArray(r, { portal: this }, n);
      return Promise.all(i.map((s) => typeof s.when == "function" ? s.when() : n)).then(() => i, () => i);
    });
  }
  request(e, t = {}) {
    const r = { f: "json", ...t.query }, { authMode: n = this.authMode === Sa.AUTH_MODE_ANONYMOUS ? "anonymous" : "auto", body: i = null, cacheBust: s = !1, method: o = "auto", responseType: a = "json", signal: l } = t, c = { authMode: n, body: i, cacheBust: s, method: o, query: r, responseType: a, timeout: 0, signal: l };
    return zr(this._normalizeSSL(e), c).then((h) => h.data);
  }
  toJSON() {
    throw new G("internal:not-yet-implemented", "Portal.toJSON is not yet implemented");
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new Sa({ sourceJSON: e });
  }
  _getHelperService(e) {
    const t = this.helperServices && this.helperServices[e];
    if (!t)
      throw new G("portal:service-not-found", `The \`helperServices\` do not include an entry named "${e}"`);
    return t;
  }
  async _fetchBasemaps(e, t) {
    const r = new Wo();
    r.query = e || (bt.apiKey && $6(this.url) ? this.devBasemapGalleryGroupQuery : this.useVectorBasemaps ? this.vectorBasemapGalleryGroupQuery : this.basemapGalleryGroupQuery), r.disableExtraQuery = !0;
    const n = await this.queryGroups(r, t);
    if (!n.total)
      return [];
    const i = n.results[0];
    r.num = 100, r.query = 'type:"Web Map" -type:"Web Application"', r.sortField = i.sortField || "name", r.sortOrder = i.sortOrder || "desc";
    const s = await i.queryItems(r, t);
    return s.total ? s.results.filter((o) => o.type === "Web Map").map((o) => new E0({ portalItem: o })) : [];
  }
  async _fetchBasemaps3D(e, t) {
    const r = e || this.basemapGalleryGroupQuery3D;
    if (!r)
      return [];
    const n = new Wo({ query: r, disableExtraQuery: !0 }), i = await this.queryGroups(n, t);
    if (!i.total)
      return [];
    const s = i.results[0];
    n.num = 100, n.query = 'type:"Web Scene"', n.sortField = s.sortField || "name", n.sortOrder = s.sortOrder || "desc";
    const o = await s.queryItems(n, t);
    return o.total ? o.results.filter((a) => a.type === "Web Scene").map((a) => new E0({ portalItem: a })) : [];
  }
  _normalizeSSL(e) {
    return e.replace(/^http:/i, "https:").replace(":7080", ":7443");
  }
  _readBasemap(e) {
    if (e) {
      const t = E0.fromJSON(e);
      return t.portalItem = { portal: this }, t;
    }
    return null;
  }
  static _resultsToTypedArray(e, t, r, n) {
    let i = [];
    if (r) {
      const s = n != null ? n.signal : null;
      i = r.listings || r.notifications || r.userInvitations || r.tags || r.items || r.groups || r.comments || r.provisions || r.results || r.relatedItems || r, (e || t) && (i = i.map((o) => {
        const a = Object.assign(e ? e.fromJSON(o) : o, t);
        return typeof a.load == "function" && a.load(s), a;
      }));
    } else
      i = [];
    return i;
  }
};
pe.AUTH_MODE_ANONYMOUS = "anonymous", pe.AUTH_MODE_AUTO = "auto", pe.AUTH_MODE_IMMEDIATE = "immediate", u([d()], pe.prototype, "access", void 0), u([d()], pe.prototype, "allSSL", void 0), u([d()], pe.prototype, "authMode", void 0), u([d()], pe.prototype, "authorizedCrossOriginDomains", void 0), u([ce("authorizedCrossOriginDomains")], pe.prototype, "readAuthorizedCrossOriginDomains", null), u([d()], pe.prototype, "basemapGalleryGroupQuery", void 0), u([d({ json: { name: "3DBasemapGalleryGroupQuery" } })], pe.prototype, "basemapGalleryGroupQuery3D", void 0), u([d()], pe.prototype, "bingKey", void 0), u([d()], pe.prototype, "canListApps", void 0), u([d()], pe.prototype, "canListData", void 0), u([d()], pe.prototype, "canListPreProvisionedItems", void 0), u([d()], pe.prototype, "canProvisionDirectPurchase", void 0), u([d()], pe.prototype, "canSearchPublic", void 0), u([d()], pe.prototype, "canShareBingPublic", void 0), u([d()], pe.prototype, "canSharePublic", void 0), u([d()], pe.prototype, "canSignInArcGIS", void 0), u([d()], pe.prototype, "canSignInIDP", void 0), u([d()], pe.prototype, "colorSetsGroupQuery", void 0), u([d()], pe.prototype, "commentsEnabled", void 0), u([d({ type: Date })], pe.prototype, "created", void 0), u([d()], pe.prototype, "credential", void 0), u([d()], pe.prototype, "culture", void 0), u([d()], pe.prototype, "currentVersion", void 0), u([d()], pe.prototype, "customBaseUrl", void 0), u([d()], pe.prototype, "defaultBasemap", void 0), u([ce("defaultBasemap")], pe.prototype, "readDefaultBasemap", null), u([d()], pe.prototype, "defaultDevBasemap", void 0), u([ce("defaultDevBasemap")], pe.prototype, "readDefaultDevBasemap", null), u([d({ type: Ct })], pe.prototype, "defaultExtent", void 0), u([d()], pe.prototype, "defaultVectorBasemap", void 0), u([ce("defaultVectorBasemap")], pe.prototype, "readDefaultVectorBasemap", null), u([d()], pe.prototype, "description", void 0), u([d()], pe.prototype, "devBasemapGalleryGroupQuery", void 0), u([d()], pe.prototype, "eueiEnabled", void 0), u([d({ readOnly: !0 })], pe.prototype, "extraQuery", null), u([d()], pe.prototype, "featuredGroups", void 0), u([d()], pe.prototype, "featuredItemsGroupQuery", void 0), u([d()], pe.prototype, "galleryTemplatesGroupQuery", void 0), u([d()], pe.prototype, "livingAtlasGroupQuery", void 0), u([d()], pe.prototype, "hasCategorySchema", void 0), u([d()], pe.prototype, "helpBase", void 0), u([d()], pe.prototype, "helperServices", void 0), u([d()], pe.prototype, "helpMap", void 0), u([d()], pe.prototype, "homePageFeaturedContent", void 0), u([d()], pe.prototype, "homePageFeaturedContentCount", void 0), u([d()], pe.prototype, "httpPort", void 0), u([d()], pe.prototype, "httpsPort", void 0), u([d()], pe.prototype, "id", void 0), u([d()], pe.prototype, "ipCntryCode", void 0), u([d({ readOnly: !0 })], pe.prototype, "isOrganization", null), u([d()], pe.prototype, "isPortal", void 0), u([d()], pe.prototype, "isReadOnly", void 0), u([d({ readOnly: !0 })], pe.prototype, "itemPageUrl", null), u([d()], pe.prototype, "layerTemplatesGroupQuery", void 0), u([d()], pe.prototype, "maxTokenExpirationMinutes", void 0), u([d({ type: Date })], pe.prototype, "modified", void 0), u([d()], pe.prototype, "name", void 0), u([d()], pe.prototype, "portalHostname", void 0), u([d()], pe.prototype, "portalMode", void 0), u([d()], pe.prototype, "portalProperties", void 0), u([d()], pe.prototype, "region", void 0), u([d({ readOnly: !0 })], pe.prototype, "restUrl", null), u([d()], pe.prototype, "rotatorPanels", void 0), u([d()], pe.prototype, "showHomePageDescription", void 0), u([d()], pe.prototype, "sourceJSON", void 0), u([d()], pe.prototype, "staticImagesUrl", void 0), u([d({ json: { name: "2DStylesGroupQuery" } })], pe.prototype, "stylesGroupQuery2d", void 0), u([d({ json: { name: "stylesGroupQuery" } })], pe.prototype, "stylesGroupQuery3d", void 0), u([d()], pe.prototype, "supportsHostedServices", void 0), u([d()], pe.prototype, "symbolSetsGroupQuery", void 0), u([d()], pe.prototype, "templatesGroupQuery", void 0), u([d()], pe.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], pe.prototype, "thumbnailUrl", null), u([d()], pe.prototype, "units", void 0), u([d()], pe.prototype, "url", void 0), u([d()], pe.prototype, "urlKey", void 0), u([ce("urlKey")], pe.prototype, "readUrlKey", null), u([d()], pe.prototype, "user", void 0), u([ce("user")], pe.prototype, "readUser", null), u([d()], pe.prototype, "use3dBasemaps", void 0), u([d()], pe.prototype, "useStandardizedQuery", void 0), u([d()], pe.prototype, "useVectorBasemaps", void 0), u([d()], pe.prototype, "vectorBasemapGalleryGroupQuery", void 0), pe = Sa = u([E("geoscene.portal.Portal")], pe);
const pi = pe, Yk = new FinalizationRegistry((e) => {
  e.remove();
});
function iY(e) {
  const t = st;
  return () => {
    const r = e.deref();
    r && t.findCredential(r.restUrl) && r.signIn().catch(() => {
    });
  };
}
const sY = se.getLogger("geoscene.assets");
function Ja(e) {
  if (!bt.assetsPath)
    throw sY.errorOnce("The API assets location needs to be set using config.assetsPath. More information: https://doc.geoscene.cn/javascript/4.27/api-reference/geoscene-config.html"), new G("assets:path-not-set", "config.assetsPath is not set");
  return Rh(bt.assetsPath, e);
}
let $a = class extends Ae {
  constructor(t) {
    super(t), this.portalItem = null;
  }
  normalizeCtorArgs(t) {
    return t && t.portalItem && t.path ? { ...t, path: this._normalizePath(t.path, t.portalItem) } : t;
  }
  set path(t) {
    t != null && Ai(t) ? se.getLogger(this).error("portalitemresource:invalid-path", "A portal item resource path must be relative") : this._set("path", t);
  }
  _castPath(t) {
    return this._normalizePath(t, this.portalItem);
  }
  get url() {
    return this.portalItem && this.path ? `${this.portalItem.itemUrl}/resources/${this.path}` : null;
  }
  get cdnUrl() {
    return this.portalItem && this.path ? `${this.portalItem.itemCdnUrl}/resources/${this.path}` : null;
  }
  get itemRelativeUrl() {
    return this.portalItem && this.path ? `./resources/${this.path}` : null;
  }
  fetch(t = "json", r) {
    const n = this.cdnUrl;
    if (n == null)
      throw new G("portal-item-resource:fetch", "Portal item resource does not refer to a valid item or path");
    return this.portalItem.portal.request(n, { responseType: t, query: { token: this.portalItem.apiKey }, signal: r == null ? void 0 : r.signal });
  }
  async update(t, r) {
    const { addOrUpdateResource: n } = await import("./resourceUtils-zoan8Otp.js");
    return n(this, "update", t, r);
  }
  hasPath() {
    return this.path != null;
  }
  _normalizePath(t, r) {
    return t == null ? t : (t = t.replace(/^\/+/, ""), r != null && Ai(t) && (t = tM(t, r.itemUrl)), t == null ? void 0 : t.replace(/^\/+/, "").replace(/^(\.\/)?resources\//, ""));
  }
};
u([d()], $a.prototype, "portalItem", void 0), u([d({ type: String, value: null })], $a.prototype, "path", null), u([xt("path")], $a.prototype, "_castPath", null), u([d({ type: String, readOnly: !0 })], $a.prototype, "url", null), u([d({ type: String, readOnly: !0 })], $a.prototype, "cdnUrl", null), u([d({ type: String, readOnly: !0 })], $a.prototype, "itemRelativeUrl", null), $a = u([E("geoscene.portal.PortalItemResource")], $a);
const oY = $a;
let pm = class extends Ae {
  constructor(t) {
    super(t), this.created = null, this.rating = null;
  }
};
u([d()], pm.prototype, "created", void 0), u([d()], pm.prototype, "rating", void 0), pm = u([E("geoscene.portal.PortalRating")], pm);
const N2 = pm;
var dc;
const aY = /* @__PURE__ */ new Set(["Map Service", "Feature Service", "Feature Collection", "Scene Service", "Image Service", "Stream Service", "Vector Tile Service", "GeoJson", "CSV", "KML", "WFS", "WMTS", "WMS", "Feed"]), lY = /* @__PURE__ */ new Set(["KML", "GeoJson", "CSV"]);
let qe = dc = class extends Lg(sl) {
  static from(e) {
    return Xw(dc, e);
  }
  constructor(e) {
    super(e), this.access = null, this.accessInformation = null, this.apiKey = null, this.applicationProxies = null, this.avgRating = null, this.categories = null, this.created = null, this.culture = null, this.description = null, this.extent = null, this.groupCategories = null, this.id = null, this.isOrgItem = !1, this.itemControl = null, this.licenseInfo = null, this.modified = null, this.name = null, this.numComments = null, this.numRatings = null, this.numViews = null, this.owner = null, this.ownerFolder = null, this.portal = null, this.screenshots = null, this.size = null, this.snippet = null, this.sourceJSON = null, this.sourceUrl = null, this.spatialReference = null, this.tags = null, this.title = null, this.type = null, this.typeKeywords = null, this.url = null;
  }
  destroy() {
    this.portal = null;
  }
  get displayName() {
    const e = this.type, t = this.typeKeywords || [];
    let r = e;
    return e === "Feature Service" || e === "Feature Collection" ? r = t.includes("Table") ? "Table" : t.includes("Route Layer") ? "Route Layer" : t.includes("Markup") ? "Markup" : "Feature Layer" : e === "Image Service" ? r = t.includes("Elevation 3D Layer") ? "Elevation Layer" : t.includes("Tiled Imagery") ? "Tiled Imagery Layer" : "Imagery Layer" : e === "Scene Service" ? r = "Scene Layer" : e === "Video Service" ? r = "Video Layer" : e === "Scene Package" ? r = "Scene Layer Package" : e === "Stream Service" ? r = "Feature Layer" : e === "Geoprocessing Service" ? r = t.includes("Web Tool") ? "Tool" : "Geoprocessing Service" : e === "Geocoding Service" ? r = "Locator" : e === "Geoenrichment Service" ? r = "GeoEnrichment Service" : e === "Microsoft Powerpoint" ? r = "Microsoft PowerPoint" : e === "GeoJson" ? r = "GeoJSON" : e === "Globe Service" ? r = "Globe Layer" : e === "Vector Tile Service" ? r = "Tile Layer" : e === "netCDF" ? r = "NetCDF" : e === "Map Service" ? r = t.includes("Spatiotemporal") || !t.includes("Hosted Service") && !t.includes("Tiled") || t.includes("Relational") ? "Map Image Layer" : "Tile Layer" : e && e.toLowerCase().includes("add in") ? r = e.replaceAll(/(add in)/gi, "Add-In") : e === "datastore catalog service" ? r = "Big Data File Share" : e === "Compact Tile Package" ? r = "Tile Package (tpkx)" : e === "OGCFeatureServer" ? r = "OGC Feature Layer" : e === "web mapping application" && t.includes("configurableApp") ? r = "Instant App" : e === "Insights Page" ? r = "Insights Report" : e === "Excalibur Imagery Project" && (r = "Excalibur Project"), r;
  }
  readExtent(e) {
    return e && e.length ? new Ct(e[0][0], e[0][1], e[1][0], e[1][1]) : null;
  }
  get iconUrl() {
    const e = this.type && this.type.toLowerCase() || "", t = this.typeKeywords || [], r = "geoscene/images/portal/", n = "16";
    let i, s = !1, o = !1, a = !1, l = !1, c = !1, h = !1;
    return e.indexOf("service") > 0 || e === "feature collection" || e === "kml" || e === "wms" || e === "wmts" || e === "wfs" ? (s = t.includes("Hosted Service"), e === "feature service" || e === "feature collection" || e === "kml" || e === "wfs" ? (o = t.includes("Table"), a = t.includes("Route Layer"), l = t.includes("Markup"), c = t.includes("Spatiotemporal"), h = t.includes("UtilityNetwork"), i = c && o ? "spatiotemporaltable" : o ? "table" : a ? "routelayer" : l ? "markup" : c ? "spatiotemporal" : s ? "featureshosted" : h ? "utilitynetwork" : "features") : i = e === "map service" || e === "wms" || e === "wmts" ? s || t.includes("Tiled") || e === "wmts" ? "maptiles" : "mapimages" : e === "scene service" ? t.includes("Line") ? "sceneweblayerline" : t.includes("3DObject") ? "sceneweblayermultipatch" : t.includes("Point") ? "sceneweblayerpoint" : t.includes("IntegratedMesh") ? "sceneweblayermesh" : t.includes("PointCloud") ? "sceneweblayerpointcloud" : t.includes("Polygon") ? "sceneweblayerpolygon" : t.includes("Building") ? "sceneweblayerbuilding" : t.includes("Voxel") ? "sceneweblayervoxel" : "sceneweblayer" : e === "image service" ? t.includes("Elevation 3D Layer") ? "elevationlayer" : t.includes("Tiled Imagery") ? "tiledimagerylayer" : "imagery" : e === "stream service" ? "streamlayer" : e === "video service" ? t.includes("Live Stream") ? "livestreamvideolayer" : "videolayer" : e === "vector tile service" ? "vectortile" : e === "datastore catalog service" ? "datastorecollection" : e === "geocoding service" ? "geocodeservice" : e === "geoprocessing service" ? t.includes("Web Tool") ? "tool" : "layers" : e === "geodata service" ? "geodataservice" : "layers") : i = e === "web map" || e === "cityengine web scene" ? "maps" : e === "web scene" ? t.includes("ViewingMode-Local") ? "webscenelocal" : "websceneglobal" : e === "web mapping application" && t.includes("configurableApp") ? "instantapps" : e === "web mapping application" || e === "mobile application" || e === "application" || e === "operation view" || e === "desktop application" ? "apps" : e === "map document" || e === "map package" || e === "published map" || e === "scene document" || e === "globe document" || e === "basemap package" || e === "mobile basemap package" || e === "mobile map package" || e === "project package" || e === "project template" || e === "pro map" || e === "layout" || e === "layer" && t.includes("ArcGIS Pro") || e === "explorer map" && t.indexOf("Explorer Document") ? "mapsgray" : e === "service definition" || e === "csv" || e === "shapefile" || e === "cad drawing" || e === "geojson" || e === "netcdf" || e === "administrative report" ? "datafiles" : e === "explorer add in" || e === "desktop add in" || e === "windows viewer add in" || e === "windows viewer configuration" ? "appsgray" : e === "360 vr experience" ? "360vr" : e === "arcgis pro add in" || e === "arcgis pro configuration" ? "addindesktop" : e === "rule package" || e === "file geodatabase" || e === "sqlite geodatabase" || e === "csv collection" || e === "kml collection" || e === "windows mobile package" || e === "map template" || e === "desktop application template" || e === "gml" || e === "arcpad package" || e === "code sample" || e === "form" || e === "document link" || e === "earth configuration" || e === "operations dashboard add in" || e === "rules package" || e === "image" || e === "workflow manager package" || e === "explorer map" && t.includes("Explorer Mapping Application") || t.includes("Document") ? "datafilesgray" : e === "network analysis service" || e === "geoprocessing service" || e === "geodata service" || e === "geometry service" || e === "geoprocessing package" || e === "locator package" || e === "geoprocessing sample" || e === "workflow manager service" ? "toolsgray" : e === "layer" || e === "layer package" || e === "explorer layer" ? "layersgray" : e === "scene package" ? "scenepackage" : e === "mobile scene package" ? "mobilescenepackage" : e === "tile package" || e === "compact tile package" ? "tilepackage" : e === "task file" ? "taskfile" : e === "report template" ? "report-template" : e === "statistical data collection" ? "statisticaldatacollection" : e === "insights workbook" ? "workbook" : e === "insights model" ? "insightsmodel" : e === "insights page" ? "insightspage" : e === "insights theme" ? "insightstheme" : e === "hub initiative" ? "hubinitiative" : e === "hubpage" ? "hubpage" : e === "hub event" ? "hubevent" : e === "hub site application" ? "hubsite" : e === "hub project" ? "hubproject" : e === "relational database connection" ? "relationaldatabaseconnection" : e === "big data file share" ? "datastorecollection" : e === "image collection" ? "imagecollection" : e === "style" ? "style" : e === "desktop style" ? "desktopstyle" : e === "dashboard" ? "dashboard" : e === "raster function template" ? "rasterprocessingtemplate" : e === "vector tile package" ? "vectortilepackage" : e === "ortho mapping project" ? "orthomappingproject" : e === "ortho mapping template" ? "orthomappingtemplate" : e === "solution" ? "solutions" : e === "geopackage" ? "geopackage" : e === "deep learning package" ? "deeplearningpackage" : e === "real time analytic" ? "realtimeanalytics" : e === "big data analytic" ? "bigdataanalytics" : e === "feed" ? "feed" : e === "excalibur imagery project" ? "excaliburimageryproject" : e === "notebook" ? "notebook" : e === "storymap" ? "storymap" : e === "survey123 add in" ? "survey123addin" : e === "mission" ? "mission" : e === "mission report" ? "missionreport" : e === "quickcapture project" ? "quickcaptureproject" : e === "pro report" ? "proreport" : e === "pro report template" ? "proreporttemplate" : e === "urban model" ? "urbanmodel" : e === "web experience" ? "experiencebuilder" : e === "web experience template" ? "webexperiencetemplate" : e === "experience builder widget" ? "experiencebuilderwidget" : e === "experience builder widget package" ? "experiencebuilderwidgetpackage" : e === "workflow" ? "workflow" : e === "insights script" ? "insightsscript" : e === "kernel gateway connection" ? "kernelgatewayconnection" : e === "hub initiative template" ? "hubinitiativetemplate" : e === "storymap theme" ? "storymaptheme" : e === "knowledge graph" ? "knowledgegraph" : e === "native application" ? "nativeapp" : e === "native application installer" ? "nativeappinstaller" : e === "link chart" ? "linkchart" : e === "investigation" ? "investigation" : e === "ogcfeatureserver" ? "features" : e === "pro project" ? "proproject" : e === "insights workbook package" ? "insightsworkbookpackage" : e === "apache parquet" ? "apacheparquet" : e === "notebook code snippets" || e === "notebook code snippet library" ? "notebookcodesnippets" : e === "suitability model" ? "suitabilitymodel" : e === "esri classifier definition" ? "classifierdefinition" : e === "esri classification schema" ? "classificationschema" : e === "insights data engineering workbook" ? "dataengineeringworkbook" : e === "insights data engineering model" ? "dataengineeringmodel" : e === "deep learning studio project" ? "deeplearningproject" : e === "discussion" ? "discussion" : e === "allsource project" ? "allsourceproject" : e === "api key" ? "apikey" : e === "data pipeline" ? "datapipelines" : "maps", i ? Ja(r + i + n + ".png") : null;
  }
  get isLayer() {
    return this.type != null && aY.has(this.type);
  }
  get itemCdnUrl() {
    let e = this.itemUrl;
    return e && st && !st.findCredential(e) && (e = st._normalizeAGOLorgDomain(e), e = e.replace(/^https?:\/\/www\.arcgis\.com/, "https://cdn.arcgis.com"), e = e.replace(/^https?:\/\/devext\.arcgis\.com/, "https://cdndev.arcgis.com"), e = e.replace(/^https?:\/\/qaext\.arcgis\.com/, "https://cdnqa.arcgis.com")), e;
  }
  get itemPageUrl() {
    var t;
    const e = (t = this.portal) == null ? void 0 : t.itemPageUrl;
    return e && this.id ? `${e}?id=${this.id}` : null;
  }
  get itemUrl() {
    var t;
    const e = (t = this.portal) == null ? void 0 : t.restUrl;
    return e && this.id ? `${e}/content/items/${this.id}` : null;
  }
  get thumbnailUrl() {
    var r;
    const e = this.itemUrl, t = this.thumbnail;
    return e && t ? ((r = this.portal) == null ? void 0 : r.normalizeUrl(`${e}/info/${t}?f=json`)) ?? null : null;
  }
  get userItemUrl() {
    const e = this.get("portal.restUrl");
    if (!e)
      return null;
    const t = this.owner || this.get("portal.user.username");
    return t ? `${e}/content/users/${this.ownerFolder ? `${t}/${this.ownerFolder}` : t}/items/${this.id}` : null;
  }
  load(e) {
    const t = this.portal ?? (this.portal = pi.getDefault()), r = t.load(e).then(() => this.sourceJSON ? this.sourceJSON : this.id && this.itemUrl ? t.request(this.itemUrl, { signal: e != null ? e.signal : null, query: { token: this.apiKey } }) : {}).then((n) => {
      this.sourceJSON = n, this.read(n);
    });
    return this.addResolvingPromise(r), Promise.resolve(this);
  }
  async addRating(e) {
    const t = { method: "post", query: {} };
    return e instanceof N2 && (e = e.rating), e == null || isNaN(e) || typeof e != "number" || (t.query.rating = e), this.portal ? (await this.portal.request(this.itemUrl + "/addRating", t), new N2({ rating: e, created: /* @__PURE__ */ new Date() })) : null;
  }
  clone() {
    const e = { access: this.access, accessInformation: this.accessInformation, applicationProxies: j(this.applicationProxies), avgRating: this.avgRating, categories: j(this.categories), created: j(this.created), culture: this.culture, description: this.description, extent: j(this.extent), groupCategories: j(this.groupCategories), id: this.id, itemControl: this.itemControl, licenseInfo: this.licenseInfo, modified: j(this.modified), name: this.name, numComments: this.numComments, numRatings: this.numRatings, numViews: this.numViews, owner: this.owner, ownerFolder: this.ownerFolder, portal: this.portal, screenshots: j(this.screenshots), size: this.size, snippet: this.snippet, sourceUrl: this.sourceUrl, spatialReference: this.spatialReference, tags: j(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: j(this.typeKeywords), url: this.url };
    this.loaded && (e.loadStatus = "loaded");
    const t = new dc({ sourceJSON: this.sourceJSON }).set(e);
    return t._set("isOrgItem", this.isOrgItem), t;
  }
  createPostQuery() {
    var r;
    const e = this.toJSON();
    for (const n of ["tags", "typeKeywords", "categories"])
      e[n] = (r = e[n]) == null ? void 0 : r.join(", ");
    const { extent: t } = e;
    return t && (e.extent = JSON.stringify(t)), e;
  }
  async deleteRating() {
    await as(this.portal).request(this.itemUrl + "/deleteRating", { method: "post" });
  }
  fetchData(e = "json", t) {
    return as(this.portal).request(this.itemUrl + "/data", { responseType: e, ...t, query: { token: this.apiKey } });
  }
  async fetchRating(e) {
    const t = await as(this.portal).request(this.itemUrl + "/rating", { query: { token: this.apiKey }, ...e });
    return t.rating != null ? (t.created = new Date(t.created), new N2(t)) : null;
  }
  fetchRelatedItems(e, t) {
    return as(this.portal).requestToTypedArray(this.itemUrl + "/relatedItems", { query: { ...e, token: this.apiKey }, ...t }, dc);
  }
  getThumbnailUrl(e) {
    let t = this.thumbnailUrl;
    return t && e && (t += `&w=${e}`), t;
  }
  reload() {
    return as(this.portal).request(this.itemUrl ?? "", { cacheBust: !0, query: { token: this.apiKey } }).then((e) => (this.sourceJSON = e, this.read(e), this));
  }
  update(e) {
    return this.id ? this.load().then(() => as(this.portal).signIn()).then(() => {
      const t = e && e.data, r = { method: "post" };
      r.query = this.createPostQuery();
      for (const n in r.query)
        r.query[n] === null && (r.query[n] = "");
      return r.query.clearEmptyFields = !0, t != null && (typeof t == "string" ? r.query.text = t : typeof t == "object" && (r.query.text = JSON.stringify(t))), this.portal.request(`${this.userItemUrl}/update`, r).then(() => this.reload());
    }) : Promise.reject(new G("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async copy(e) {
    if (!this.id)
      throw new G("portal:item-does-not-exist", "The item does not exist yet");
    await this.load();
    const { portal: t, itemUrl: r } = this;
    await as(t).signIn();
    const { copyResources: n, folder: i, tags: s, title: o } = e || {}, a = { method: "post", query: { copyPrivateResources: n === "all", folder: typeof i == "string" ? i : i == null ? void 0 : i.id, includeResources: !!n, tags: s == null ? void 0 : s.join(","), title: o } }, { itemId: l } = await t.request(`${r}/copy`, a);
    return new dc({ id: l, portal: t });
  }
  updateThumbnail(e) {
    return this.id ? this.load().then(() => this.portal.signIn()).then(() => {
      const t = e.thumbnail, r = e.filename, n = { method: "post" };
      if (typeof t == "string")
        Kd(t) ? n.query = { data: t } : n.query = { url: cs(t) }, r != null && (n.query.filename = r);
      else {
        const i = new FormData();
        r != null ? i.append("file", t, r) : i.append("file", t), n.body = i;
      }
      return this.portal.request(`${this.userItemUrl}/updateThumbnail`, n).then(() => this.reload());
    }) : Promise.reject(new G("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async fetchResources(e = {}, t) {
    const { fetchResources: r } = await import("./resourceUtils-zoan8Otp.js");
    return r(this, e, t);
  }
  async addResource(e, t, r) {
    const { addOrUpdateResource: n } = await import("./resourceUtils-zoan8Otp.js");
    return e.portalItem = this, n(e, "add", t, r);
  }
  async removeResource(e, t) {
    const { removeResource: r } = await import("./resourceUtils-zoan8Otp.js");
    if (e.portalItem && e.portalItem.itemUrl !== this.itemUrl)
      throw new G("removeresource:portal-item-mismatch", "The portal item associated with the provided resource does not match the item");
    return r(this, e, t);
  }
  async removeAllResources(e) {
    const { removeAllResources: t } = await import("./resourceUtils-zoan8Otp.js");
    return t(this, e);
  }
  resourceFromPath(e) {
    return new oY({ portalItem: this, path: e });
  }
  toJSON() {
    const e = this.extent, t = { accessInformation: this.accessInformation, categories: j(this.categories), created: this.created && this.created.getTime(), description: this.description, extent: e && [[e.xmin, e.ymin], [e.xmax, e.ymax]], id: this.id, isOrgItem: this.isOrgItem, licenseInfo: this.licenseInfo, modified: this.modified && this.modified.getTime(), name: this.name, owner: this.owner, ownerFolder: this.ownerFolder, snippet: this.snippet, sourceUrl: this.sourceUrl, spatialReference: this.spatialReference, tags: j(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: j(this.typeKeywords), url: this.url };
    return W5(t);
  }
  static fromJSON(e) {
    if (!e)
      return null;
    if (e.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new dc({ sourceJSON: e });
  }
  _getPostQuery() {
    const e = this.toJSON();
    for (const t in e)
      t === "tags" && e[t] !== null && (e[t] = e[t].join(", ")), t === "typeKeywords" && e[t] !== null && (e[t] = e[t].join(", ")), t === "extent" && e[t] && (e[t] = JSON.stringify(e[t]));
    return e;
  }
};
u([d({ type: ["private", "shared", "org", "public"] })], qe.prototype, "access", void 0), u([d()], qe.prototype, "accessInformation", void 0), u([d({ type: String })], qe.prototype, "apiKey", void 0), u([d({ json: { read: { source: "appProxies" } } })], qe.prototype, "applicationProxies", void 0), u([d()], qe.prototype, "avgRating", void 0), u([d()], qe.prototype, "categories", void 0), u([d({ type: Date })], qe.prototype, "created", void 0), u([d()], qe.prototype, "culture", void 0), u([d()], qe.prototype, "description", void 0), u([d({ readOnly: !0 })], qe.prototype, "displayName", null), u([d({ type: Ct })], qe.prototype, "extent", void 0), u([ce("extent")], qe.prototype, "readExtent", null), u([d()], qe.prototype, "groupCategories", void 0), u([d({ readOnly: !0 })], qe.prototype, "iconUrl", null), u([d()], qe.prototype, "id", void 0), u([d({ readOnly: !0 })], qe.prototype, "isLayer", null), u([d({ type: Boolean, readOnly: !0 })], qe.prototype, "isOrgItem", void 0), u([d()], qe.prototype, "itemControl", void 0), u([d({ readOnly: !0 })], qe.prototype, "itemPageUrl", null), u([d({ readOnly: !0 })], qe.prototype, "itemUrl", null), u([d()], qe.prototype, "licenseInfo", void 0), u([d({ type: Date })], qe.prototype, "modified", void 0), u([d()], qe.prototype, "name", void 0), u([d()], qe.prototype, "numComments", void 0), u([d()], qe.prototype, "numRatings", void 0), u([d()], qe.prototype, "numViews", void 0), u([d()], qe.prototype, "owner", void 0), u([d()], qe.prototype, "ownerFolder", void 0), u([d({ type: pi })], qe.prototype, "portal", void 0), u([d()], qe.prototype, "screenshots", void 0), u([d()], qe.prototype, "size", void 0), u([d()], qe.prototype, "snippet", void 0), u([d()], qe.prototype, "sourceJSON", void 0), u([d({ type: String })], qe.prototype, "sourceUrl", void 0), u([d({ type: String })], qe.prototype, "spatialReference", void 0), u([d()], qe.prototype, "tags", void 0), u([d()], qe.prototype, "thumbnail", void 0), u([d({ readOnly: !0 })], qe.prototype, "thumbnailUrl", null), u([d()], qe.prototype, "title", void 0), u([d()], qe.prototype, "type", void 0), u([d()], qe.prototype, "typeKeywords", void 0), u([d({ type: String, json: { read(e, t) {
  var r;
  if (lY.has(t.type)) {
    const n = (r = this.portal) == null ? void 0 : r.restUrl;
    e || (e = n && this.id ? `${n}/content/items/${this.id}/data` : null);
  }
  return e;
} } })], qe.prototype, "url", void 0), u([d({ readOnly: !0 })], qe.prototype, "userItemUrl", null), qe = dc = u([E("geoscene.portal.PortalItem")], qe);
const yy = qe, A6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yy
}, Symbol.toStringTag, { value: "Module" })), Qk = /^([a-z]{2})(?:[-_]([A-Za-z]{2}))?$/, uY = { ar: !0, bg: !0, bs: !0, ca: !0, cs: !0, da: !0, de: !0, el: !0, en: !0, es: !0, et: !0, fi: !0, fr: !0, he: !0, hr: !0, hu: !0, id: !0, it: !0, ja: !0, ko: !0, lt: !0, lv: !0, nb: !0, nl: !0, pl: !0, "pt-BR": !0, "pt-PT": !0, ro: !0, ru: !0, sk: !0, sl: !0, sr: !0, sv: !0, th: !0, tr: !0, uk: !0, vi: !0, "zh-CN": !0, "zh-HK": !0, "zh-TW": !0 };
function Xk(e) {
  return e in uY;
}
const hm = [], vh = /* @__PURE__ */ new Map();
function eA(e) {
  for (const t of vh.keys())
    R6(e.pattern, t) && vh.delete(t);
}
function cY(e) {
  return hm.includes(e) || (eA(e), hm.unshift(e)), { remove() {
    const t = hm.indexOf(e);
    t > -1 && (hm.splice(t, 1), eA(e));
  } };
}
async function P6(e) {
  const t = uo();
  vh.has(e) || vh.set(e, pY(e, t));
  const r = vh.get(e);
  return r && await hY.add(r), r;
}
function dY(e) {
  if (!Qk.test(e))
    return null;
  const t = Qk.exec(e);
  if (t === null)
    return null;
  const [, r, n] = t, i = r + (n ? "-" + n.toUpperCase() : "");
  return Xk(i) ? i : Xk(r) ? r : null;
}
async function pY(e, t) {
  const r = [];
  for (const n of hm)
    if (R6(n.pattern, e))
      try {
        return await n.fetchMessageBundle(e, t);
      } catch (i) {
        r.push(i);
      }
  throw r.length ? new G("intl:message-bundle-error", `Errors occurred while loading "${e}"`, { errors: r }) : new G("intl:no-message-bundle-loader", `No loader found for message bundle "${e}"`);
}
function R6(e, t) {
  return typeof e == "string" ? t.startsWith(e) : e.test(t);
}
pM(() => {
  vh.clear();
});
const hY = new class {
  constructor() {
    this._numLoading = 0, this._dfd = null;
  }
  async waitForAll() {
    this._dfd && await this._dfd.promise;
  }
  add(e) {
    return this._increase(), e.then(() => this._decrease(), () => this._decrease()), this.waitForAll();
  }
  _increase() {
    this._numLoading++, this._dfd || (this._dfd = vs());
  }
  _decrease() {
    this._numLoading = Math.max(this._numLoading - 1, 0), this._dfd && this._numLoading === 0 && (this._dfd.resolve(), this._dfd = null);
  }
}();
async function fY(e) {
  if (!e)
    return;
  const t = e.includes("-vector") ? e.slice(0, e.indexOf("-vector")) : e, r = await P6("geoscene/t9n/basemaps");
  return r[e] || r[t];
}
const Q$ = { "geoscene-community": { get thumbnailUrl() {
  return Ja("geoscene/images/basemap/community.jpg");
}, id: "geoscene-community", classic: !0, title: "彩色版基础底图", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "彩色版基础底图", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer" }] }, "geoscene-gray": { get thumbnailUrl() {
  return Ja("geoscene/images/basemap/gray.jpg");
}, id: "geoscene-gray", classic: !0, title: "灰色不含兴趣点版中国基础地图", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "灰色不含兴趣点版中国基础地图", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetGray/MapServer" }] }, "geoscene-blue": { get thumbnailUrl() {
  return Ja("geoscene/images/basemap/blue.jpg");
}, id: "geoscene-blue", classic: !0, title: "蓝黑色不含兴趣点版中国基础地图", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "蓝黑色不含兴趣点版中国基础地图", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer" }] }, "geoscene-warm": { get thumbnailUrl() {
  return Ja("geoscene/images/basemap/warm.jpg");
}, id: "geoscene-warm", classic: !0, title: "暖色不含兴趣点版中国基础地图", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: !1, title: "暖色不含兴趣点版中国基础地图", url: "//map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetWarm/MapServer" }] }, "tianditu-topography": { classic: !0, title: "天地图-地形地图（球面墨卡托投影）", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/ter_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=ter&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_6884", title: "天地图-地形地图（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cta_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cta&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_4525", title: "天地图-地形注记（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }] }, "tianditu-image": { classic: !0, title: "天地图-影像地图（球面墨卡托投影）", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=img&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_3572", title: "天地图-影像地图（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cia&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_5882", title: "天地图-影像注记（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }] }, "tianditu-vector": { classic: !0, title: "天地图-矢量（含注记）（球面墨卡托投影）", baseMapLayers: [{ templateUrl: "https://{subDomain}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=vec&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_8803", title: "天地图-矢量地图（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }, { templateUrl: "https://{subDomain}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&LAYER=cva&STYLE=default&FORMAT=tiles&TILEMATRIXSET=w&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}&tk=4267820f43926eaf808d61dc07269beb", copyright: "天地图", fullExtent: { xmin: -20037508342787e-6, ymin: -2003750834278e-5, xmax: 2003750834278e-5, ymax: 20037508342787e-6, spatialReference: { wkid: 102100 } }, subDomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"], opacity: 1, visibility: !0, id: "WebTiled_2198", title: "天地图-矢量注记（球面墨卡托投影）", type: "WebTiledLayer", layerType: "WebTiledLayer" }] } };
function zPe(e) {
  return e != null && typeof e == "object" && "type" in e && e.type === "feature";
}
const UPe = { Point: "SceneLayer", "3DObject": "SceneLayer", IntegratedMesh: "IntegratedMeshLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" };
function L6(e) {
  const t = e == null ? void 0 : e.type;
  return t === "building-scene" || t === "integrated-mesh" || t === "point-cloud" || t === "scene";
}
function fM(e) {
  var t;
  return (e == null ? void 0 : e.type) === "feature" && !e.url && ((t = e.source) == null ? void 0 : t.type) === "memory";
}
async function N6(e, t) {
  const r = st == null ? void 0 : st.findServerInfo(e);
  if ((r == null ? void 0 : r.currentVersion) != null)
    return r.owningSystemUrl || null;
  const n = e.toLowerCase().indexOf("/rest/services");
  if (n === -1)
    return null;
  const i = `${e.substring(0, n)}/rest/info`, s = t != null ? t.signal : null, { data: o } = await zr(i, { query: { f: "json" }, responseType: "json", signal: s });
  return (o == null ? void 0 : o.owningSystemUrl) || null;
}
function mY(e) {
  if (!("capabilities" in e))
    return !1;
  switch (e.type) {
    case "csv":
    case "feature":
    case "geojson":
    case "imagery":
    case "knowledge-graph-sublayer":
    case "ogc-feature":
    case "oriented-imagery":
    case "scene":
    case "subtype-group":
    case "subtype-sublayer":
    case "wfs":
      return !0;
    default:
      return !1;
  }
}
function yY(e) {
  return mY(e) ? "effectiveCapabilities" in e ? e.effectiveCapabilities : e.capabilities : null;
}
function gY(e) {
  if (!("editingEnabled" in e))
    return !1;
  switch (e.type) {
    case "csv":
    case "feature":
    case "geojson":
    case "oriented-imagery":
    case "scene":
    case "subtype-group":
    case "subtype-sublayer":
      return !0;
    default:
      return !1;
  }
}
function vY(e) {
  return !!gY(e) && ("effectiveEditingEnabled" in e ? e.effectiveEditingEnabled : e.editingEnabled);
}
const bY = /* @__PURE__ */ new Set(["bing-maps", "imagery", "imagery-tile", "map-image", "open-street-map", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wms", "wmts"]), wY = /* @__PURE__ */ new Set(["csv", "feature", "geo-rss", "geojson", "group", "imagery", "imagery-tile", "kml", "map-image", "map-notes", "media", "ogc-feature", "route", "stream", "subtype-group", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wfs", "wms", "wmts"]);
function _Y(e) {
  return e.layerContainerType === "basemap" ? bY : e.layerContainerType === "operational-layers" ? wY : null;
}
function SY(e, t) {
  if (t.restrictedWebMapWriting) {
    const r = _Y(t);
    return r == null || r.has(e.type) && !fM(e);
  }
  return !0;
}
function $Y(e, t) {
  if (t)
    if (fM(e)) {
      const r = Pg("featureCollection.layers", t), n = r && r[0] && r[0].layerDefinition;
      n && tA(e, n);
    } else
      e.type !== "group" && tA(e, t);
}
function tA(e, t) {
  "maxScale" in e && (t.maxScale = Sb(e.maxScale) ?? void 0), "minScale" in e && (t.minScale = Sb(e.minScale) ?? void 0);
}
function xY(e, t) {
  if ($Y(e, t), t && ("blendMode" in e && (t.blendMode = e.blendMode, t.blendMode === "normal" && delete t.blendMode), t.opacity = Sb(e.opacity) ?? void 0, t.title = e.title || "Layer", t.visibility = e.visible, "legendEnabled" in e && e.type !== "wmts"))
    if (fM(e)) {
      const r = t.featureCollection;
      r && (r.showLegend = e.legendEnabled);
    } else
      t.showLegend = e.legendEnabled;
}
function rA(e, t, r) {
  if (!("write" in e) || !e.write)
    return r && r.messages && r.messages.push(new G("layer:unsupported", `Layers (${e.title}, ${e.id}) of type '${e.declaredClass}' cannot be persisted`, { layer: e })), null;
  if (SY(e, r)) {
    const n = {};
    return e.write(n, r) ? n : null;
  }
  return t != null && xY(e, t = j(t)), t;
}
var qv;
let TY = 0;
const F6 = "geoscene.Basemap";
let Ki = qv = class extends Lg(sl) {
  constructor(e) {
    super(e), this.id = null, this.portalItem = null, this.spatialReference = null, this.thumbnailUrl = null, this.title = "Basemap", this.id = Date.now().toString(16) + "-basemap-" + TY++, this.baseLayers = new je(), this.referenceLayers = new je();
    const t = (n) => {
      n.parent && n.parent !== this && "remove" in n.parent && n.parent.remove(n), n.parent = this, n.type === "elevation" && se.getLogger(this).error(`Layer '${n.title}, id:${n.id}' of type '${n.type}' is not supported as a basemap layer and will therefore be ignored.`);
    }, r = (n) => {
      n.parent = null;
    };
    this.addHandles([this.baseLayers.on("after-add", (n) => t(n.item)), this.referenceLayers.on("after-add", (n) => t(n.item)), this.baseLayers.on("after-remove", (n) => r(n.item)), this.referenceLayers.on("after-remove", (n) => r(n.item))]);
  }
  initialize() {
    this.when().catch((e) => {
      se.getLogger(this).error("#load()", `Failed to load basemap (title: '${this.title}', id: '${this.id}')`, e);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    var r;
    const e = this.baseLayers.removeAll();
    for (const n of e)
      n.destroy();
    const t = this.referenceLayers.removeAll();
    for (const n of t)
      n.destroy();
    this.baseLayers.destroy(), this.referenceLayers.destroy(), (r = this.portalItem) == null || r.destroy(), this.portalItem = null;
  }
  normalizeCtorArgs(e) {
    return e && "resourceInfo" in e && (this._set("resourceInfo", e.resourceInfo), delete (e = { ...e }).resourceInfo), e;
  }
  set baseLayers(e) {
    this._set("baseLayers", Ed(e, this._get("baseLayers")));
  }
  _writeBaseLayers(e, t, r) {
    const n = [];
    e && (r = { ...r, layerContainerType: "basemap" }, this.baseLayers.forEach((i) => {
      const s = rA(i, r.webmap ? r.webmap.getLayerJSONFromResourceInfo(i) : null, r);
      s != null && n.push(s);
    }), this.referenceLayers.forEach((i) => {
      const s = rA(i, r.webmap ? r.webmap.getLayerJSONFromResourceInfo(i) : null, r);
      s != null && (i.type !== "scene" && (s.isReference = !0), n.push(s));
    })), t.baseMapLayers = n;
  }
  set referenceLayers(e) {
    this._set("referenceLayers", Ed(e, this._get("referenceLayers")));
  }
  writeTitle(e, t) {
    t.title = e || "Basemap";
  }
  load(e) {
    return this.addResolvingPromise(this._loadFromSource(e)), Promise.resolve(this);
  }
  loadAll() {
    return XF(this, (e) => {
      e(this.baseLayers, this.referenceLayers);
    });
  }
  clone() {
    const e = { id: this.id, title: this.title, portalItem: this.portalItem, baseLayers: this.baseLayers.map((t) => ab(t) ? t.clone() : t), referenceLayers: this.referenceLayers.map((t) => ab(t) ? t.clone() : t) };
    return this.loaded && (e.loadStatus = "loaded"), new qv({ resourceInfo: this.resourceInfo }).set(e);
  }
  read(e, t) {
    this.resourceInfo || this._set("resourceInfo", { data: e, context: t }), super.read(e, t);
  }
  write(e, t) {
    return e = e || {}, t && t.origin || (t = { origin: "web-map", ...t }), super.write(e, t), !this.loaded && this.resourceInfo && this.resourceInfo.data.baseMapLayers && (e.baseMapLayers = this.resourceInfo.data.baseMapLayers.map((r) => {
      const n = j(r);
      return n.url && ia(n.url) && (n.url = `https:${n.url}`), n.templateUrl && ia(n.templateUrl) && (n.templateUrl = `https:${n.templateUrl}`), n;
    })), e;
  }
  async _loadFromSource(e) {
    const { resourceInfo: t, portalItem: r } = this;
    lr(e);
    const n = [];
    if (t) {
      const i = t.context ? t.context.url : null;
      if (n.push(this._loadLayersFromJSON(t.data, i, e)), t.data.id && !t.data.title) {
        const s = t.data.id;
        n.push(fY(s).then((o) => {
          o && this.read({ title: o }, t.context);
        }));
      }
    } else
      r && n.push(this._loadFromItem(r, e));
    await Promise.all(n);
  }
  async _loadLayersFromJSON(e, t, r) {
    const n = this.resourceInfo && this.resourceInfo.context, i = this.portalItem && this.portalItem.portal || n && n.portal || null, s = IY[(n == null ? void 0 : n.origin) || ""] ?? "web-map", { populateOperationalLayers: o } = await import("./layersCreator-2nqeJ20g.js"), a = [];
    if (lr(r), e.baseMapLayers && Array.isArray(e.baseMapLayers)) {
      const l = { context: { origin: s, url: t, portal: i, layerContainerType: "basemap" }, defaultLayerType: "DefaultTileLayer" }, c = (m) => s === "web-scene" && m.layerType === "ArcGISSceneServiceLayer" || m.isReference, h = o(this.baseLayers, e.baseMapLayers.filter((m) => !c(m)), l);
      a.push(h);
      const f = o(this.referenceLayers, e.baseMapLayers.filter(c), l);
      a.push(f);
    }
    await Zd(a);
  }
  async _loadFromItem(e, t) {
    const r = await e.load(t), n = await r.fetchData("json", t), i = Di(e.itemUrl ?? "");
    return this._set("resourceInfo", { data: n.baseMap ?? {}, context: { origin: EY[e.type || ""] ?? "web-map", portal: e.portal || pi.getDefault(), url: i } }), this.read(this.resourceInfo.data, this.resourceInfo.context), this.read({ spatialReference: n.spatialReference }, this.resourceInfo.context), this.read({ title: e.title, thumbnailUrl: e.thumbnailUrl }, { origin: "portal-item", portal: e.portal || pi.getDefault(), url: i }), this._loadLayersFromJSON(this.resourceInfo.data, i, t);
  }
  static fromId(e) {
    const t = Q$[e];
    if (!t)
      return null;
    if (t.deprecated) {
      let r = null;
      e === "dark-gray" ? r = "dark-gray-vector" : e === "gray" ? r = "gray-vector" : e === "streets" ? r = "streets-vector" : e === "topo" && (r = "topo-vector"), $b(se.getLogger(F6), `The ${e} basemap has entered mature support and is no longer being updated.`, { replacement: r, see: "https://doc.geoscene.cn/blog/1iq8aD", warnOnce: !0 });
    }
    return qv.fromJSON(t);
  }
};
u([d({ json: { write: { ignoreOrigin: !0, target: "baseMapLayers", writer(e, t, r, n) {
  this._writeBaseLayers(e, t, n);
} }, origins: { "web-scene": { write: { ignoreOrigin: !0, target: { baseMapLayers: { type: je } }, writer(e, t, r, n) {
  this._writeBaseLayers(e, t, n);
} } } } } })], Ki.prototype, "baseLayers", null), u([d({ type: String, json: { origins: { "web-scene": { write: !0 } } } })], Ki.prototype, "id", void 0), u([d({ type: yy })], Ki.prototype, "portalItem", void 0), u([d()], Ki.prototype, "referenceLayers", null), u([d({ readOnly: !0 })], Ki.prototype, "resourceInfo", void 0), u([d({ type: tt })], Ki.prototype, "spatialReference", void 0), u([d()], Ki.prototype, "thumbnailUrl", void 0), u([d({ type: String, json: { origins: { "web-scene": { write: { isRequired: !0 } } } } })], Ki.prototype, "title", void 0), u([ge("title")], Ki.prototype, "writeTitle", null), Ki = qv = u([E(F6)], Ki);
const EY = { "Web Scene": "web-scene", "Web Map": "web-map", "Link Chart": "link-chart" }, IY = { "web-scene": "web-scene", "web-map": "web-map", "link-chart": "link-chart" }, kb = Ki, MY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kb
}, Symbol.toStringTag, { value: "Module" })), Ab = { transparent: [0, 0, 0, 0], black: [0, 0, 0, 1], silver: [192, 192, 192, 1], gray: [128, 128, 128, 1], white: [255, 255, 255, 1], maroon: [128, 0, 0, 1], red: [255, 0, 0, 1], purple: [128, 0, 128, 1], fuchsia: [255, 0, 255, 1], green: [0, 128, 0, 1], lime: [0, 255, 0, 1], olive: [128, 128, 0, 1], yellow: [255, 255, 0, 1], navy: [0, 0, 128, 1], blue: [0, 0, 255, 1], teal: [0, 128, 128, 1], aqua: [0, 255, 255, 1], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], blanchedalmond: [255, 235, 205, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], oldlace: [253, 245, 230, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], rebeccapurple: [102, 51, 153, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], whitesmoke: [245, 245, 245, 1], yellowgreen: [154, 205, 50, 1] };
function D6(e) {
  return !!Ab[e] || !!Ab[e.toLowerCase()];
}
function mM(e) {
  return Ab[e] ?? Ab[e.toLowerCase()];
}
function OY(e) {
  return [...mM(e)];
}
function F2(e, t, r) {
  r < 0 && ++r, r > 1 && --r;
  const n = 6 * r;
  return n < 1 ? e + (t - e) * n : 2 * r < 1 ? t : 3 * r < 2 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function j6(e, t, r, n = 1) {
  const i = (e % 360 + 360) % 360 / 360, s = r <= 0.5 ? r * (t + 1) : r + t - r * t, o = 2 * r - s;
  return [Math.round(255 * F2(o, s, i + 1 / 3)), Math.round(255 * F2(o, s, i)), Math.round(255 * F2(o, s, i - 1 / 3)), n];
}
function CY(e) {
  const t = e.length > 5, r = t ? 8 : 4, n = (1 << r) - 1, i = t ? 1 : 17, s = t ? e.length === 9 : e.length === 5;
  let o = +("0x" + e.substr(1));
  if (isNaN(o))
    return null;
  const a = [0, 0, 0, 1];
  let l;
  return s && (l = o & n, o >>= r, a[3] = i * l / 255), l = o & n, o >>= r, a[2] = i * l, l = o & n, o >>= r, a[1] = i * l, l = o & n, o >>= r, a[0] = i * l, a;
}
function da() {
  return [0, 0, 0];
}
function kY(e) {
  return [e[0], e[1], e[2]];
}
function Ng(e, t, r) {
  return [e, t, r];
}
function AY(e) {
  const t = da(), r = Math.min(3, e.length);
  for (let n = 0; n < r; ++n)
    t[n] = e[n];
  return t;
}
function PY(e, t) {
  return new Float64Array(e, t, 3);
}
function V6() {
  return da();
}
function z6() {
  return Ng(1, 1, 1);
}
function U6() {
  return Ng(1, 0, 0);
}
function B6() {
  return Ng(0, 1, 0);
}
function q6() {
  return Ng(0, 0, 1);
}
const RY = V6(), LY = z6(), NY = U6(), FY = B6(), DY = q6();
Object.freeze(Object.defineProperty({ __proto__: null, ONES: LY, UNIT_X: NY, UNIT_Y: FY, UNIT_Z: DY, ZEROS: RY, clone: kY, create: da, createView: PY, fromArray: AY, fromValues: Ng, ones: z6, unitX: U6, unitY: B6, unitZ: q6, zeros: V6 }, Symbol.toStringTag, { value: "Module" }));
let yM = 1e-6;
function Es() {
  return yM;
}
function jY(e) {
  yM = e;
}
const l_ = Math.random, VY = Math.PI / 180, zY = 180 / Math.PI;
function gM(e) {
  return e * VY;
}
function UY(e) {
  return e * zY;
}
function BY(e, t) {
  return Math.abs(e - t) <= yM * Math.max(1, Math.abs(e), Math.abs(t));
}
Object.freeze(Object.defineProperty({ __proto__: null, RANDOM: l_, equals: BY, getEpsilon: Es, setEpsilon: jY, toDegree: UY, toRadian: gM }, Symbol.toStringTag, { value: "Module" }));
function vM(e) {
  const t = e[0], r = e[1], n = e[2];
  return Math.sqrt(t * t + r * r + n * n);
}
function X$(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
}
function G6(e, t, r, n) {
  return e[0] = t, e[1] = r, e[2] = n, e;
}
function qY(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;
}
function H6(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;
}
function W6(e, t, r) {
  return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;
}
function J6(e, t, r) {
  return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;
}
function GY(e, t) {
  return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;
}
function HY(e, t) {
  return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;
}
function WY(e, t) {
  return e[0] = Math.abs(t[0]), e[1] = Math.abs(t[1]), e[2] = Math.abs(t[2]), e;
}
function JY(e, t) {
  return e[0] = Math.sign(t[0]), e[1] = Math.sign(t[1]), e[2] = Math.sign(t[2]), e;
}
function ZY(e, t, r) {
  return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;
}
function KY(e, t, r) {
  return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;
}
function YY(e, t) {
  return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;
}
function Z6(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;
}
function QY(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;
}
function K6(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1], i = t[2] - e[2];
  return Math.sqrt(r * r + n * n + i * i);
}
function Y6(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1], i = t[2] - e[2];
  return r * r + n * n + i * i;
}
function Q6(e) {
  const t = e[0], r = e[1], n = e[2];
  return t * t + r * r + n * n;
}
function XY(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;
}
function eQ(e, t) {
  return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;
}
function ex(e, t) {
  const r = t[0], n = t[1], i = t[2];
  let s = r * r + n * n + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s), e;
}
function X6(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function tQ(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = r[0], a = r[1], l = r[2];
  return e[0] = i * l - s * a, e[1] = s * o - n * l, e[2] = n * a - i * o, e;
}
function rQ(e, t, r, n) {
  const i = t[0], s = t[1], o = t[2];
  return e[0] = i + n * (r[0] - i), e[1] = s + n * (r[1] - s), e[2] = o + n * (r[2] - o), e;
}
function nQ(e, t, r, n, i, s) {
  const o = s * s, a = o * (2 * s - 3) + 1, l = o * (s - 2) + s, c = o * (s - 1), h = o * (3 - 2 * s);
  return e[0] = t[0] * a + r[0] * l + n[0] * c + i[0] * h, e[1] = t[1] * a + r[1] * l + n[1] * c + i[1] * h, e[2] = t[2] * a + r[2] * l + n[2] * c + i[2] * h, e;
}
function iQ(e, t, r, n, i, s) {
  const o = 1 - s, a = o * o, l = s * s, c = a * o, h = 3 * s * a, f = 3 * l * o, m = l * s;
  return e[0] = t[0] * c + r[0] * h + n[0] * f + i[0] * m, e[1] = t[1] * c + r[1] * h + n[1] * f + i[1] * m, e[2] = t[2] * c + r[2] * h + n[2] * f + i[2] * m, e;
}
function sQ(e, t) {
  t = t || 1;
  const r = l_, n = 2 * r() * Math.PI, i = 2 * r() - 1, s = Math.sqrt(1 - i * i) * t;
  return e[0] = Math.cos(n) * s, e[1] = Math.sin(n) * s, e[2] = i * t, e;
}
function oQ(e, t, r) {
  const n = t[0], i = t[1], s = t[2];
  return e[0] = r[0] * n + r[4] * i + r[8] * s + r[12], e[1] = r[1] * n + r[5] * i + r[9] * s + r[13], e[2] = r[2] * n + r[6] * i + r[10] * s + r[14], e;
}
function aQ(e, t, r) {
  const n = t[0], i = t[1], s = t[2];
  return e[0] = n * r[0] + i * r[3] + s * r[6], e[1] = n * r[1] + i * r[4] + s * r[7], e[2] = n * r[2] + i * r[5] + s * r[8], e;
}
function lQ(e, t, r) {
  const n = r[0], i = r[1], s = r[2], o = r[3], a = t[0], l = t[1], c = t[2];
  let h = i * c - s * l, f = s * a - n * c, m = n * l - i * a, y = i * m - s * f, g = s * h - n * m, v = n * f - i * h;
  const b = 2 * o;
  return h *= b, f *= b, m *= b, y *= 2, g *= 2, v *= 2, e[0] = a + h + y, e[1] = l + f + g, e[2] = c + m + v, e;
}
function uQ(e, t, r, n) {
  const i = [], s = [];
  return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e;
}
function cQ(e, t, r, n) {
  const i = [], s = [];
  return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e;
}
function dQ(e, t, r, n) {
  const i = [], s = [];
  return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e;
}
function pQ(e, t) {
  X$(I0, e), X$(M0, t), ex(I0, I0), ex(M0, M0);
  const r = X6(I0, M0);
  return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r);
}
const I0 = da(), M0 = da();
function hQ(e) {
  return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")";
}
function fQ(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
}
function mQ(e, t) {
  if (e === t)
    return !0;
  const r = e[0], n = e[1], i = e[2], s = t[0], o = t[1], a = t[2], l = Es();
  return Math.abs(r - s) <= l * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - o) <= l * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - a) <= l * Math.max(1, Math.abs(i), Math.abs(a));
}
function yQ(e, t, r) {
  const n = r[0] - t[0], i = r[1] - t[1], s = r[2] - t[2];
  let o = n * n + i * i + s * s;
  return o > 0 ? (o = 1 / Math.sqrt(o), e[0] = n * o, e[1] = i * o, e[2] = s * o, e) : (e[0] = 0, e[1] = 0, e[2] = 0, e);
}
const gQ = H6, vQ = W6, bQ = J6, wQ = K6, _Q = Y6, SQ = vM, $Q = Q6;
Object.freeze(Object.defineProperty({ __proto__: null, abs: WY, add: qY, angle: pQ, bezier: iQ, ceil: GY, copy: X$, cross: tQ, direction: yQ, dist: wQ, distance: K6, div: bQ, divide: J6, dot: X6, equals: mQ, exactEquals: fQ, floor: HY, hermite: nQ, inverse: eQ, len: SQ, length: vM, lerp: rQ, max: KY, min: ZY, mul: vQ, multiply: W6, negate: XY, normalize: ex, random: sQ, rotateX: uQ, rotateY: cQ, rotateZ: dQ, round: YY, scale: Z6, scaleAndAdd: QY, set: G6, sign: JY, sqrDist: _Q, sqrLen: $Q, squaredDistance: Y6, squaredLength: Q6, str: hQ, sub: gQ, subtract: H6, transformMat3: aQ, transformMat4: oQ, transformQuat: lQ }, Symbol.toStringTag, { value: "Module" }));
function xQ(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
function TQ(e, t, r, n, i) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e;
}
function EQ(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;
}
function e8(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;
}
function t8(e, t, r) {
  return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;
}
function r8(e, t, r) {
  return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;
}
function IQ(e, t) {
  return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;
}
function MQ(e, t) {
  return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;
}
function OQ(e, t, r) {
  return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;
}
function CQ(e, t, r) {
  return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;
}
function kQ(e, t) {
  return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;
}
function AQ(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;
}
function PQ(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;
}
function n8(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1], i = t[2] - e[2], s = t[3] - e[3];
  return Math.sqrt(r * r + n * n + i * i + s * s);
}
function i8(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1], i = t[2] - e[2], s = t[3] - e[3];
  return r * r + n * n + i * i + s * s;
}
function s8(e) {
  const t = e[0], r = e[1], n = e[2], i = e[3];
  return Math.sqrt(t * t + r * r + n * n + i * i);
}
function o8(e) {
  const t = e[0], r = e[1], n = e[2], i = e[3];
  return t * t + r * r + n * n + i * i;
}
function RQ(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;
}
function LQ(e, t) {
  return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;
}
function NQ(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3];
  let o = r * r + n * n + i * i + s * s;
  return o > 0 && (o = 1 / Math.sqrt(o), e[0] = r * o, e[1] = n * o, e[2] = i * o, e[3] = s * o), e;
}
function FQ(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
}
function a8(e, t, r, n) {
  const i = t[0], s = t[1], o = t[2], a = t[3];
  return e[0] = i + n * (r[0] - i), e[1] = s + n * (r[1] - s), e[2] = o + n * (r[2] - o), e[3] = a + n * (r[3] - a), e;
}
function DQ(e, t) {
  const r = l_;
  let n, i, s, o, a, l;
  t = t || 1;
  do
    n = 2 * r() - 1, i = 2 * r() - 1, a = n * n + i * i;
  while (a >= 1);
  do
    s = 2 * r() - 1, o = 2 * r() - 1, l = s * s + o * o;
  while (l >= 1);
  const c = Math.sqrt((1 - a) / l);
  return e[0] = t * n, e[1] = t * i, e[2] = t * s * c, e[3] = t * o * c, e;
}
function jQ(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3];
  return e[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * o, e[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * o, e[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * o, e[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * o, e;
}
function VQ(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = r[0], a = r[1], l = r[2], c = r[3], h = c * n + a * s - l * i, f = c * i + l * n - o * s, m = c * s + o * i - a * n, y = -o * n - a * i - l * s;
  return e[0] = h * c + y * -o + f * -l - m * -a, e[1] = f * c + y * -a + m * -o - h * -l, e[2] = m * c + y * -l + h * -a - f * -o, e[3] = t[3], e;
}
function zQ(e) {
  return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")";
}
function UQ(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];
}
function BQ(e, t) {
  const r = e[0], n = e[1], i = e[2], s = e[3], o = t[0], a = t[1], l = t[2], c = t[3], h = Es();
  return Math.abs(r - o) <= h * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - a) <= h * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - l) <= h * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - c) <= h * Math.max(1, Math.abs(s), Math.abs(c));
}
const qQ = e8, GQ = t8, HQ = r8, WQ = n8, JQ = i8, ZQ = s8, KQ = o8;
Object.freeze(Object.defineProperty({ __proto__: null, add: EQ, ceil: IQ, copy: xQ, dist: WQ, distance: n8, div: HQ, divide: r8, dot: FQ, equals: BQ, exactEquals: UQ, floor: MQ, inverse: LQ, len: ZQ, length: s8, lerp: a8, max: CQ, min: OQ, mul: GQ, multiply: t8, negate: RQ, normalize: NQ, random: DQ, round: kQ, scale: AQ, scaleAndAdd: PQ, set: TQ, sqrDist: JQ, sqrLen: KQ, squaredDistance: i8, squaredLength: o8, str: zQ, sub: qQ, subtract: e8, transformMat4: jQ, transformQuat: VQ }, Symbol.toStringTag, { value: "Module" }));
const nA = new Float32Array(1);
function BPe(e) {
  --e;
  for (let t = 1; t < 32; t <<= 1)
    e |= e >> t;
  return e + 1;
}
function ws(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function qPe(e) {
  return (e & e - 1) == 0;
}
function GPe(e) {
  return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e;
}
function HPe(e, t, r) {
  return e + (t - e) * r;
}
function YQ(e) {
  return e * Math.PI / 180;
}
function l8(e) {
  return 180 * e / Math.PI;
}
function WPe(e) {
  return Math.acos(ws(e, -1, 1));
}
function u8(e) {
  return Math.asin(ws(e, -1, 1));
}
function D2(e, t, r = 1e-6) {
  return e === t ? !0 : !Number.isFinite(e) || !Number.isFinite(t) ? !1 : (e > t ? e - t : t - e) <= r;
}
const Pb = new DataView(new ArrayBuffer(Float64Array.BYTES_PER_ELEMENT));
function QQ(e) {
  return Pb.setFloat64(0, e), Pb.getBigInt64(0);
}
function XQ(e) {
  return Pb.setBigInt64(0, e), Pb.getFloat64(0);
}
const j2 = BigInt("1000000");
eX(1);
function eX(e) {
  const t = QQ(e = Math.abs(e)), r = XQ(t <= j2 ? j2 : t - j2);
  return Math.abs(e - r);
}
function JPe(e) {
  return c8(Math.max(-iA, Math.min(e, iA)));
}
function c8(e) {
  return nA[0] = e, nA[0];
}
function ZPe(e, t) {
  const r = vM(e), n = u8(e[2] / r), i = Math.atan2(e[1] / r, e[0] / r);
  return G6(t, r, n, i), t;
}
function KPe(e) {
  const t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[3] * e[3] + e[4] * e[4] + e[5] * e[5], n = e[6] * e[6] + e[7] * e[7] + e[8] * e[8];
  return !(D2(t, 1) && D2(r, 1) && D2(n, 1));
}
const iA = c8(34028234663852886e22);
function O0(e) {
  return ws(U3(e), 0, 255);
}
function C0(e, t, r) {
  return e = Number(e), isNaN(e) ? r : e < t ? t : e > r ? r : e;
}
let Gv = class on {
  static blendColors(t, r, n, i = new on()) {
    return i.r = Math.round(t.r + (r.r - t.r) * n), i.g = Math.round(t.g + (r.g - t.g) * n), i.b = Math.round(t.b + (r.b - t.b) * n), i.a = t.a + (r.a - t.a) * n, i._sanitize();
  }
  static fromRgb(t, r) {
    const n = t.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
    if (n) {
      const i = n[2].split(/\s*,\s*/), s = n[1];
      if (s === "rgb" && i.length === 3 || s === "rgba" && i.length === 4) {
        const o = i[0];
        if (o.charAt(o.length - 1) === "%") {
          const a = i.map((l) => 2.56 * parseFloat(l));
          return i.length === 4 && (a[3] = parseFloat(i[3])), on.fromArray(a, r);
        }
        return on.fromArray(i.map((a) => parseFloat(a)), r);
      }
      if (s === "hsl" && i.length === 3 || s === "hsla" && i.length === 4)
        return on.fromArray(j6(parseFloat(i[0]), parseFloat(i[1]) / 100, parseFloat(i[2]) / 100, parseFloat(i[3])), r);
    }
    return null;
  }
  static fromHex(t, r = new on()) {
    if (t.length !== 4 && t.length !== 7 || t[0] !== "#")
      return null;
    const n = t.length === 4 ? 4 : 8, i = (1 << n) - 1;
    let s = +("0x" + t.substr(1));
    return isNaN(s) ? null : (["b", "g", "r"].forEach((o) => {
      const a = s & i;
      s >>= n, r[o] = n === 4 ? 17 * a : a;
    }), r.a = 1, r);
  }
  static fromArray(t, r = new on()) {
    return r._set(Number(t[0]), Number(t[1]), Number(t[2]), Number(t[3])), isNaN(r.a) && (r.a = 1), r._sanitize();
  }
  static fromString(t, r) {
    const n = D6(t) ? mM(t) : null;
    return n && on.fromArray(n, r) || on.fromRgb(t, r) || on.fromHex(t, r);
  }
  static fromJSON(t) {
    return t && new on([t[0], t[1], t[2], t[3] / 255]);
  }
  static toUnitRGB(t) {
    return t != null ? [t.r / 255, t.g / 255, t.b / 255] : null;
  }
  static toUnitRGBA(t) {
    return t != null ? [t.r / 255, t.g / 255, t.b / 255, t.a != null ? t.a : 1] : null;
  }
  constructor(t) {
    this.r = 255, this.g = 255, this.b = 255, this.a = 1, t && this.setColor(t);
  }
  get isBright() {
    return 0.299 * this.r + 0.587 * this.g + 0.114 * this.b >= 127;
  }
  setColor(t) {
    return typeof t == "string" ? on.fromString(t, this) : Array.isArray(t) ? on.fromArray(t, this) : (this._set(t.r ?? 0, t.g ?? 0, t.b ?? 0, t.a ?? 1), t instanceof on || this._sanitize()), this;
  }
  toRgb() {
    return [this.r, this.g, this.b];
  }
  toRgba() {
    return [this.r, this.g, this.b, this.a];
  }
  toHex() {
    const t = this.r.toString(16), r = this.g.toString(16), n = this.b.toString(16);
    return `#${t.length < 2 ? "0" + t : t}${r.length < 2 ? "0" + r : r}${n.length < 2 ? "0" + n : n}`;
  }
  toCss(t = !1) {
    const r = this.r + ", " + this.g + ", " + this.b;
    return t ? `rgba(${r}, ${this.a})` : `rgb(${r})`;
  }
  toString() {
    return this.toCss(!0);
  }
  toJSON() {
    return this.toArray();
  }
  toArray(t = on.AlphaMode.ALWAYS) {
    const r = O0(this.r), n = O0(this.g), i = O0(this.b);
    return t === on.AlphaMode.ALWAYS || this.a !== 1 ? [r, n, i, O0(255 * this.a)] : [r, n, i];
  }
  clone() {
    return new on(this.toRgba());
  }
  hash() {
    return this.r << 24 | this.g << 16 | this.b << 8 | 255 * this.a;
  }
  equals(t) {
    return t != null && t.r === this.r && t.g === this.g && t.b === this.b && t.a === this.a;
  }
  _sanitize() {
    return this.r = Math.round(C0(this.r, 0, 255)), this.g = Math.round(C0(this.g, 0, 255)), this.b = Math.round(C0(this.b, 0, 255)), this.a = C0(this.a, 0, 1), this;
  }
  _set(t, r, n, i) {
    this.r = t, this.g = r, this.b = n, this.a = i;
  }
};
Gv.prototype.declaredClass = "geoscene.Color", function(e) {
  var t;
  (t = e.AlphaMode || (e.AlphaMode = {}))[t.ALWAYS = 0] = "ALWAYS", t[t.UNLESS_OPAQUE = 1] = "UNLESS_OPAQUE";
}(Gv || (Gv = {}));
const Me = Gv;
function YPe(e) {
}
function tX(e) {
  return () => e;
}
function Ie(e, t = {}) {
  const r = e instanceof et ? e : new et(e, t), n = { type: (t == null ? void 0 : t.ignoreUnknown) ?? 1 ? r.apiValues : String, json: { type: r.jsonValues, read: !(t != null && t.readOnly) && { reader: r.read }, write: { writer: r.write } } };
  return (t == null ? void 0 : t.readOnly) !== void 0 && (n.readOnly = !!t.readOnly), (t == null ? void 0 : t.default) !== void 0 && (n.json.default = t.default), (t == null ? void 0 : t.name) !== void 0 && (n.json.name = t.name), (t == null ? void 0 : t.nonNullable) !== void 0 && (n.nonNullable = t.nonNullable), d(n);
}
var tx;
let Hv = tx = class extends re {
  constructor(e) {
    super(e), this.type = "none";
  }
  clone() {
    return new tx({ type: this.type });
  }
};
u([Ie({ none: "none", stayAbove: "stay-above" })], Hv.prototype, "type", void 0), Hv = tx = u([E("geoscene.ground.NavigationConstraint")], Hv);
function u_(e) {
  const t = U3(100 * (1 - e));
  return Math.max(0, Math.min(t, 100));
}
function Zy(e) {
  const t = 1 - e / 100;
  return Math.max(0, Math.min(t, 1));
}
var rx;
let xa = rx = class extends Lg(sl) {
  constructor(e) {
    super(e), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new je();
    const t = (n) => {
      n.parent && n.parent !== this && "remove" in n.parent && n.parent.remove(n), n.parent = this, n.type !== "elevation" && n.type !== "base-elevation" && se.getLogger(this).error(`Layer '${n.title}, id:${n.id}' of type '${n.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, r = (n) => {
      n.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (n) => t(n.item)), this.layers.on("after-remove", (n) => r(n.item))]);
  }
  initialize() {
    this.when().catch((e) => {
      Fi(e) || se.getLogger(this).error("#load()", "Failed to load ground", e);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const e = this.layers.removeAll();
    for (const t of e)
      t.destroy();
    this.layers.destroy();
  }
  normalizeCtorArgs(e) {
    return e && "resourceInfo" in e && (this._set("resourceInfo", e.resourceInfo), delete (e = { ...e }).resourceInfo), e;
  }
  set layers(e) {
    this._set("layers", Ed(e, this._get("layers")));
  }
  writeLayers(e, t, r, n) {
    const i = [];
    e && (n = { ...n, layerContainerType: "ground" }, e.forEach((s) => {
      if ("write" in s) {
        const o = {};
        tX(s)().write(o, n) && i.push(o);
      } else
        n && n.messages && n.messages.push(new G("layer:unsupported", `Layers (${s.title}, ${s.id}) of type '${s.declaredClass}' cannot be persisted in the ground`, { layer: s }));
    })), t.layers = i;
  }
  load(e) {
    return this.addResolvingPromise(this._loadFromSource(e)), Promise.resolve(this);
  }
  loadAll() {
    return XF(this, (e) => {
      e(this.layers);
    });
  }
  async queryElevation(e, t) {
    await this.load({ signal: t == null ? void 0 : t.signal });
    const { ElevationQuery: r } = await import("./ElevationQuery-RCmCwB2G.js");
    lr(t);
    const n = new r(), i = this.layers.filter(sA).toArray();
    return n.queryAll(i, e, t);
  }
  async createElevationSampler(e, t) {
    await this.load({ signal: t == null ? void 0 : t.signal });
    const { ElevationQuery: r } = await import("./ElevationQuery-RCmCwB2G.js");
    lr(t);
    const n = new r(), i = this.layers.filter(sA).toArray();
    return n.createSamplerAll(i, e, t);
  }
  clone() {
    const e = { opacity: this.opacity, surfaceColor: j(this.surfaceColor), navigationConstraint: j(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (e.loadStatus = "loaded"), new rx({ resourceInfo: this.resourceInfo }).set(e);
  }
  read(e, t) {
    this.resourceInfo || this._set("resourceInfo", { data: e, context: t }), super.read(e, t);
  }
  _loadFromSource(e) {
    const t = this.resourceInfo;
    return t ? this._loadLayersFromJSON(t.data, t.context, e) : Promise.resolve();
  }
  _loadLayersFromJSON(e, t, r) {
    const n = t && t.origin || "web-scene", i = t && t.portal || null, s = t && t.url || null;
    return import("./layersCreator-2nqeJ20g.js").then(({ populateOperationalLayers: o }) => {
      lr(r);
      const a = [];
      if (e.layers && Array.isArray(e.layers)) {
        const l = { context: { origin: n, url: s, portal: i, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
        a.push(o(this.layers, e.layers, l));
      }
      return Zd(a);
    }).then(() => {
    });
  }
};
function rX(e) {
  return e && "createElevationSampler" in e;
}
function sA(e) {
  return e.type === "elevation" || rX(e);
}
u([d({ json: { read: !1 } })], xa.prototype, "layers", null), u([ge("layers")], xa.prototype, "writeLayers", null), u([d({ readOnly: !0 })], xa.prototype, "resourceInfo", void 0), u([d({ type: Number, nonNullable: !0, range: { min: 0, max: 1 }, json: { type: Ot, read: { reader: Zy, source: "transparency" }, write: { writer: (e, t) => {
  t.transparency = u_(e);
}, target: "transparency" } } })], xa.prototype, "opacity", void 0), u([d({ type: Me, json: { type: [Ot], write: (e, t) => {
  t.surfaceColor = e.toJSON().slice(0, 3);
} } })], xa.prototype, "surfaceColor", void 0), u([d({ type: Hv, json: { write: !0 } })], xa.prototype, "navigationConstraint", void 0), xa = rx = u([E("geoscene.Ground")], xa);
const Rb = xa;
let Tp = class extends je {
  constructor(t) {
    super(t), this.getCollections = null;
  }
  initialize() {
    this.own($F(() => this._refresh()));
  }
  destroy() {
    this.getCollections = null;
  }
  _refresh() {
    const t = this.getCollections != null ? this.getCollections() : null;
    if (t == null)
      return void this.removeAll();
    let r = 0;
    for (const n of t)
      n != null && (r = this._processCollection(r, n));
    this.splice(r, this.length);
  }
  _createNewInstance(t) {
    return new je(t);
  }
  _processCollection(t, r) {
    if (!r)
      return t;
    const n = this.itemFilterFunction ?? ((i) => !!i);
    for (const i of r)
      if (i) {
        if (n(i)) {
          const s = this.indexOf(i, t);
          s >= 0 ? s !== t && this.reorder(i, t) : this.add(i, t), ++t;
        }
        if (this.getChildrenFunction) {
          const s = this.getChildrenFunction(i);
          if (Array.isArray(s))
            for (const o of s)
              t = this._processCollection(t, o);
          else
            t = this._processCollection(t, s);
        }
      }
    return t;
  }
};
u([d()], Tp.prototype, "getCollections", void 0), u([d()], Tp.prototype, "getChildrenFunction", void 0), u([d()], Tp.prototype, "itemFilterFunction", void 0), Tp = u([E("geoscene.core.CollectionFlattener")], Tp);
const Ky = Tp, nX = [["binary", "application/octet-stream", "bin", ""]];
function iX(e, t) {
  return wM(aX(e, t));
}
function sX(e, t) {
  return wM(lX(e, t));
}
function XPe(e, t) {
  return d8(oX(e, t));
}
function bM(e) {
  return [...nX, ...e];
}
function oX(e, t) {
  return bM(t).find((r) => wM(r) === e);
}
function aX(e, t) {
  return bM(t).find((r) => d8(r) === e);
}
function lX(e, t) {
  const r = e.toLowerCase();
  return bM(t).find((n) => uX(n).some((i) => r.endsWith(i)));
}
function wM(e) {
  return e == null ? void 0 : e[0];
}
function d8(e) {
  return e == null ? void 0 : e[1];
}
function uX(e) {
  return (e == null ? void 0 : e[2].split(",")) ?? [];
}
function eRe(e) {
  var t;
  return (t = e.tables) == null ? void 0 : t.find((r) => r.role === "assetMaps");
}
function cX(e) {
  var t, r;
  return !(!(e && typeof e == "object" && "loaded" in e && e.loaded && ((r = (t = yY(e)) == null ? void 0 : t.operations) != null && r.supportsEditing) && "type" in e) || "editingEnabled" in e && !vY(e) || e.type === "scene" && !dX(e));
}
function dX(e) {
  const t = e.infoFor3D;
  if (!t)
    return !0;
  const { supportedFormats: r, queryFormats: n } = t, i = iX("model/gltf-binary", r) ?? sX("glb", r);
  return i != null && n.includes(i);
}
const oA = se.getLogger("geoscene.support.basemapUtils");
function pX() {
  return {};
}
function hX(e) {
  for (const t in e) {
    const r = e[t];
    (r == null ? void 0 : r.destroyed) === !1 && r.destroy(), delete e[t];
  }
}
function fX(e, t) {
  let r;
  if (typeof e == "string") {
    if (!(e in Q$)) {
      const n = Object.entries(Q$).filter(([i, s]) => bt.apiKey && !s.classic || !bt.apiKey && s.classic && !s.deprecated).map(([i]) => `"${i}"`).join(", ");
      return oA.warn(`Unable to find basemap definition for: ${e}. Try one of these: ${n}`), null;
    }
    t && (r = t[e]), r || (r = kb.fromId(e), t && (t[e] = r));
  } else
    r = br(kb, e);
  return r != null && r.destroyed && (oA.warn("The provided basemap is already destroyed", { basemap: r }), r = null), r;
}
function mX(e) {
  return new Ky({ getCollections: () => [e.tables, e.layers], getChildrenFunction: (t) => {
    const r = [];
    return "tables" in t && r.push(t.tables), "layers" in t && r.push(t.layers), r;
  }, itemFilterFunction: (t) => {
    const r = t.parent;
    return !!r && "tables" in r && r.tables.includes(t);
  } });
}
function V2(e) {
  for (const t of e.values())
    t == null || t.destroy();
  e.clear();
}
const aA = { "world-elevation": { id: "worldElevation", url: "//links.geoscene.cn/geoscene/rest/services/elevation3d/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//links.geoscene.cn/geoscene/rest/services/elevation3d/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function yX(e) {
  let t = null;
  if (typeof e == "string")
    if (e in aA) {
      const r = aA[e];
      t = new Rb({ resourceInfo: { data: { layers: [r] } } });
    } else
      se.getLogger("geoscene.support.groundUtils").warn(`Unable to find ground definition for: ${e}. Try "world-elevation"`);
  else
    t = br(Rb, e);
  return t;
}
function Nh(e, t, r = !1) {
  let { hasM: n, hasZ: i } = e;
  Array.isArray(t) ? t.length !== 4 || n || i ? t.length === 3 && r && !n ? (i = !0, n = !1) : t.length === 3 && n && i && (n = !1, i = !1) : (n = !0, i = !0) : (i = !i && t.hasZ && (!n || t.hasM), n = !n && t.hasM && (!i || t.hasZ)), e.hasZ = i, e.hasM = n;
}
var nx;
function lA(e) {
  return (t, r) => t == null ? r : r == null ? t : e(t, r);
}
function gX(e) {
  return e && (e.declaredClass === "geoscene.geometry.SpatialReference" || e.wkid != null);
}
let Dl = nx = class extends Bu {
  constructor(...e) {
    super(...e), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(e, t) {
    if (!e && !t)
      return {};
    const r = {};
    Array.isArray(e) ? (r.points = e, r.spatialReference = t) : gX(e) ? r.spatialReference = e : (e.points && (r.points = e.points), e.spatialReference && (r.spatialReference = e.spatialReference), e.hasZ && (r.hasZ = e.hasZ), e.hasM && (r.hasM = e.hasM));
    const n = r.points && r.points[0];
    return n && (r.hasZ === void 0 && r.hasM === void 0 ? (r.hasZ = n.length > 2, r.hasM = !1) : r.hasZ === void 0 ? r.hasZ = n.length > 3 : r.hasM === void 0 && (r.hasM = n.length > 3)), r;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const e = this.points;
    if (!e.length)
      return null;
    const t = new Ct(), r = this.hasZ, n = this.hasM, i = r ? 3 : 2, s = e[0], o = lA(Math.min), a = lA(Math.max);
    let l, c, h, f, [m, y] = s, [g, v] = s;
    for (let b = 0, w = e.length; b < w; b++) {
      const x = e[b], [$, T] = x;
      if (m = o(m, $), y = o(y, T), g = a(g, $), v = a(v, T), r && x.length > 2) {
        const C = x[2];
        l = o(l, C), h = a(h, C);
      }
      if (n && x.length > i) {
        const C = x[i];
        c = o(c, C), f = a(f, C);
      }
    }
    return t.xmin = m, t.ymin = y, t.xmax = g, t.ymax = v, t.spatialReference = this.spatialReference, r ? (t.zmin = l, t.zmax = h) : (t.zmin = void 0, t.zmax = void 0), n ? (t.mmin = c, t.mmax = f) : (t.mmin = void 0, t.mmax = void 0), t;
  }
  writePoints(e, t) {
    t.points = j(this.points);
  }
  addPoint(e) {
    return Nh(this, e), Array.isArray(e) ? this.points.push(e) : this.points.push(e.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const e = { points: j(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (e.hasZ = !0), this.hasM && (e.hasM = !0), new nx(e);
  }
  getPoint(e) {
    if (!this._validateInputs(e))
      return null;
    const t = this.points[e], r = { x: t[0], y: t[1], spatialReference: this.spatialReference };
    let n = 2;
    return this.hasZ && (r.z = t[2], n = 3), this.hasM && (r.m = t[n]), new Re(r);
  }
  removePoint(e) {
    if (!this._validateInputs(e))
      return null;
    const t = new Re(this.points.splice(e, 1)[0], this.spatialReference);
    return this.notifyChange("points"), t;
  }
  setPoint(e, t) {
    return this._validateInputs(e) ? (Nh(this, t), Array.isArray(t) || (t = t.toArray()), this.points[e] = t, this.notifyChange("points"), this) : this;
  }
  toJSON(e) {
    return this.write({}, e);
  }
  _validateInputs(e) {
    return e != null && e >= 0 && e < this.points.length;
  }
};
u([d({ readOnly: !0 })], Dl.prototype, "cache", null), u([d()], Dl.prototype, "extent", null), u([d({ type: [[Number]], json: { write: { isRequired: !0 } } })], Dl.prototype, "points", void 0), u([ge("points")], Dl.prototype, "writePoints", null), Dl = nx = u([E("geoscene.geometry.Multipoint")], Dl), Dl.prototype.toJSON.isDefaultToJSON = !0;
const c_ = Dl;
function tRe(e) {
  const t = [];
  for (e.reset(); e.nextPath(); ) {
    const r = [];
    for (; e.nextPoint(); )
      r.push([e.x, e.y]);
    t.push(r);
  }
  return e.reset(), t;
}
function vX(e) {
  const t = [];
  for (; e.nextPoint(); )
    t.push([e.x, e.y]);
  return e.seekPathStart(), t;
}
function p8(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1];
  if (e.length > 2 && t.length > 2) {
    const i = e[2] - t[2];
    return Math.sqrt(r * r + n * n + i * i);
  }
  return Math.sqrt(r * r + n * n);
}
function bX(e, t, r) {
  const n = e[0] + r * (t[0] - e[0]), i = e[1] + r * (t[1] - e[1]);
  return e.length > 2 && t.length > 2 ? [n, i, e[2] + r * (t[2] - e[2])] : [n, i];
}
function wX(e, t, r, n) {
  const [i, s] = t, [o, a] = r[n], [l, c] = r[n + 1], h = l - o, f = c - a, m = h * h + f * f, y = (i - o) * h + (s - a) * f, g = Math.min(1, Math.max(0, y / m));
  return e[0] = o + h * g, e[1] = a + f * g, e;
}
function rRe(e, t, r) {
  let n, i, s, o, a = !1, l = 1 / 0;
  for (r.reset(); r.nextPath(); )
    if (r.nextPoint())
      for (n = r.x, i = r.y; r.nextPoint(); )
        s = r.x, o = r.y, i > t != o > t && e < (s - n) * (t - i) / (o - i) + n && (a = !a), l = Math.min(l, _X(e, t, n, i, s, o)), n = s, i = o;
  return l === 0 ? 0 : (a ? 1 : -1) * Math.sqrt(l);
}
function _X(e, t, r, n, i, s) {
  let o = r, a = n, l = i - o, c = s - a;
  if (l !== 0 || c !== 0) {
    const h = ((e - o) * l + (t - a) * c) / (l * l + c * c);
    h > 1 ? (o = i, a = s) : h > 0 && (o += l * h, a += c * h);
  }
  return l = e - o, c = t - a, l * l + c * c;
}
function h8(e, t) {
  return bX(e, t, 0.5);
}
function f8(e, t, r) {
  const n = e.length;
  let i = 0, s = 0, o = 0;
  for (let a = 0; a < n; a++) {
    const l = e[a], c = e[(a + 1) % n];
    let h = 2;
    i += l[0] * c[1] - c[0] * l[1], l.length > 2 && c.length > 2 && r && (s += l[0] * c[2] - c[0] * l[2], h = 3), l.length > h && c.length > h && t && (o += l[0] * c[h] - c[0] * l[h]);
  }
  return i <= 0 && s <= 0 && o <= 0;
}
function SX(e) {
  const t = e.length;
  return t > 2 && Bw(e[0], e[t - 1]);
}
function nRe(e) {
  if ("rings" in e && ($X(e), e.rings.length > 0 && !f8(e.rings[0], e.hasM ?? !1, e.hasZ ?? !1)))
    for (const t of e.rings)
      t.reverse();
}
function $X(e) {
  if ("rings" in e)
    for (const t of e.rings)
      SX(t) || t.push(t[0].slice());
}
function iRe(e) {
  if (!e || e.length < 3)
    return 0;
  let t = 0;
  const r = e.length - 1;
  for (let n = 0; n < r; n++)
    t += (e[n][0] - e[n + 1][0]) * (e[n][1] + e[n + 1][1]);
  return t += (e[r][0] - e[0][0]) * (e[r][1] + e[0][1]), -0.5 * t;
}
function m8(e) {
  if (!e || e.numPoints < 3)
    return 0;
  let t, r, n = 0;
  if (e.seekPathStart(), !e.nextPoint())
    return 0;
  t = e.x, r = e.y;
  const i = t, s = r;
  for (; e.nextPoint(); )
    n += (t - e.x) * (r + e.y), t = e.x, r = e.y;
  return n += (t - i) * (r + s), -0.5 * n;
}
function sRe(e) {
  return e ? e.hasZ ? [e.xmax - e.xmin / 2, e.ymax - e.ymin / 2, e.zmax - e.zmin / 2] : [e.xmax - e.xmin / 2, e.ymax - e.ymin / 2] : null;
}
function xX(e) {
  return e ? TX(e.rings, e.hasZ ?? !1) : null;
}
function TX(e, t) {
  if (!e || !e.length)
    return null;
  const r = [], n = [], i = t ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let s = 0, o = e.length; s < o; s++) {
    const a = y8(e[s], t, i);
    a && n.push(a);
  }
  if (n.sort((s, o) => {
    let a = s[2] - o[2];
    return a === 0 && t && (a = s[4] - o[4]), a;
  }), n.length && (r[0] = n[0][0], r[1] = n[0][1], t && (r[2] = n[0][3]), (r[0] < i[0] || r[0] > i[1] || r[1] < i[2] || r[1] > i[3] || t && (r[2] < i[4] || r[2] > i[5])) && (r.length = 0)), !r.length) {
    const s = e[0] && e[0].length ? EX(e[0], t) : null;
    if (!s)
      return null;
    r[0] = s[0], r[1] = s[1], t && s.length > 2 && (r[2] = s[2]);
  }
  return r;
}
function y8(e, t, r) {
  let n = 0, i = 0, s = 0, o = 0, a = 0;
  const l = e.length ? e[0][0] : 0, c = e.length ? e[0][1] : 0, h = e.length && t ? e[0][2] : 0;
  for (let m = 0; m < e.length; m++) {
    const y = e[m], g = e[(m + 1) % e.length], [v, b, w] = y, x = v - l, $ = b - c, [T, C, I] = g, O = T - l, M = C - c, L = x * M - O * $;
    if (o += L, n += (x + O) * L, i += ($ + M) * L, t && y.length > 2 && g.length > 2) {
      const N = w - h, ee = I - h, D = x * ee - O * N;
      s += (N + ee) * D, a += D;
    }
    v < r[0] && (r[0] = v), v > r[1] && (r[1] = v), b < r[2] && (r[2] = b), b > r[3] && (r[3] = b), t && (w < r[4] && (r[4] = w), w > r[5] && (r[5] = w));
  }
  if (o > 0 && (o *= -1), a > 0 && (a *= -1), !o)
    return null;
  o *= 0.5, a *= 0.5;
  const f = [n / (6 * o) + l, i / (6 * o) + c, o];
  return t && (r[4] === r[5] || a === 0 ? (f[3] = (r[4] + r[5]) / 2, f[4] = 0) : (f[3] = s / (6 * a) + h, f[4] = a)), f;
}
function EX(e, t) {
  const r = t ? [0, 0, 0] : [0, 0], n = t ? [0, 0, 0] : [0, 0];
  let i = 0, s = 0, o = 0, a = 0;
  for (let l = 0, c = e.length; l < c - 1; l++) {
    const h = e[l], f = e[l + 1];
    if (h && f) {
      r[0] = h[0], r[1] = h[1], n[0] = f[0], n[1] = f[1], t && h.length > 2 && f.length > 2 && (r[2] = h[2], n[2] = f[2]);
      const m = p8(r, n);
      if (m) {
        i += m;
        const y = h8(h, f);
        s += m * y[0], o += m * y[1], t && y.length > 2 && (a += m * y[2]);
      }
    }
  }
  return i > 0 ? t ? [s / i, o / i, a / i] : [s / i, o / i] : e.length ? e[0] : null;
}
function IX(e) {
  const { hasZ: t, numPaths: r } = e;
  if (r === 0)
    return null;
  const n = [], i = [], s = t ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (e.reset(); e.nextPath(); ) {
    const o = y8(vX(e), e.hasZ, s);
    o && i.push(o);
  }
  if (i.sort((o, a) => {
    let l = o[2] - a[2];
    return l === 0 && t && (l = o[4] - a[4]), l;
  }), i.length && (n[0] = i[0][0], n[1] = i[0][1], t && (n[2] = i[0][3]), (n[0] < s[0] || n[0] > s[1] || n[1] < s[2] || n[1] > s[3] || t && (n[2] < s[4] || n[2] > s[5])) && (n.length = 0)), !n.length) {
    e.reset(), e.nextPath();
    const o = e.numPoints ? MX(e) : null;
    if (!o)
      return null;
    n[0] = o[0], n[1] = o[1], t && o.length > 2 && (n[2] = o[2]);
  }
  return n;
}
function MX(e) {
  const { hasZ: t } = e, r = t ? [0, 0, 0] : [0, 0], n = t ? [0, 0, 0] : [0, 0];
  let i = 0, s = 0, o = 0, a = 0;
  if (e.nextPoint()) {
    let l = e.x, c = e.y, h = e.z;
    for (; e.nextPoint(); ) {
      const f = e.x, m = e.y, y = e.z;
      r[0] = l, r[1] = c, n[0] = f, n[1] = m, t && (r[2] = h, n[2] = y);
      const g = p8(r, n);
      if (g) {
        i += g;
        const v = h8(r, n);
        s += g * v[0], o += g * v[1], t && v.length > 2 && (a += g * v[2]);
      }
      l = f, c = m, h = y;
    }
  }
  return i > 0 ? t ? [s / i, o / i, a / i] : [s / i, o / i] : e.numPoints ? (e.seekPathStart(), e.nextPoint(), [e.x, e.y]) : null;
}
const OX = 1e-6;
function oRe(e) {
  let t = 0;
  for (e.reset(); e.nextPath(); )
    t += m8(e);
  if (t < OX) {
    const i = IX(e);
    return i ? [i[0], i[1]] : null;
  }
  const r = [0, 0];
  if (e.reset(), !e.nextPath() || !e.nextPoint())
    return null;
  const n = [e.x, e.y];
  for (e.reset(); e.nextPath(); )
    kX(r, n, e);
  return r[0] *= 1 / t, r[1] *= 1 / t, r[0] += n[0], r[1] += n[1], r;
}
const CX = 1 / 3;
function kX(e, t, r) {
  if (!e || !r || r.numPoints < 3)
    return null;
  r.nextPoint();
  const n = r.x, i = r.y;
  r.nextPoint();
  let s, o = r.x - n, a = r.y - i, l = 0, c = 0;
  for (; r.nextPoint(); )
    l = r.x - n, c = r.y - i, s = 0.5 * CX * (l * a - c * o), e[0] += s * (o + l), e[1] += s * (a + c), o = l, a = c;
  const h = m8(r), f = [n, i];
  return f[0] -= t[0], f[1] -= t[1], f[0] *= h, f[1] *= h, e[0] += f[0], e[1] += f[1], e;
}
function sa(e = LX) {
  return [e[0], e[1], e[2], e[3]];
}
function aRe(e) {
  return [e[0], e[1], e[2], e[3]];
}
function g8(e, t) {
  return e !== t && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]), e;
}
function lRe(e, t, r, n, i = sa()) {
  return i[0] = e, i[1] = t, i[2] = r, i[3] = n, i;
}
function uRe(e, t = sa()) {
  return t[0] = e.xmin, t[1] = e.ymin, t[2] = e.xmax, t[3] = e.ymax, t;
}
function cRe(e, t) {
  return new Ct({ xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: t });
}
function dRe(e, t) {
  t[0] < e[0] && (e[0] = t[0]), t[0] > e[2] && (e[2] = t[0]), t[1] < e[1] && (e[1] = t[1]), t[1] > e[3] && (e[3] = t[1]);
}
function pRe(e, t, r) {
  if (t != null)
    if ("length" in t)
      ix(t) ? (r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r[2] = Math.max(e[2], t[2]), r[3] = Math.max(e[3], t[3])) : t.length !== 2 && t.length !== 3 || (r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r[2] = Math.max(e[2], t[0]), r[3] = Math.max(e[3], t[1]));
    else
      switch (t.type) {
        case "extent":
          r[0] = Math.min(e[0], t.xmin), r[1] = Math.min(e[1], t.ymin), r[2] = Math.max(e[2], t.xmax), r[3] = Math.max(e[3], t.ymax);
          break;
        case "point":
          r[0] = Math.min(e[0], t.x), r[1] = Math.min(e[1], t.y), r[2] = Math.max(e[2], t.x), r[3] = Math.max(e[3], t.y);
      }
  else
    g8(r, e);
}
function AX(e) {
  return e == null || e[0] >= e[2] ? 0 : e[2] - e[0];
}
function PX(e) {
  return e[1] >= e[3] ? 0 : e[3] - e[1];
}
function hRe(e) {
  return AX(e) * PX(e);
}
function fRe(e, t, r) {
  return t >= e[0] && r >= e[1] && t <= e[2] && r <= e[3];
}
function mRe(e, t, r) {
  return t[0] >= e[0] - r && t[1] >= e[1] - r && t[0] <= e[2] + r && t[1] <= e[3] + r;
}
function yRe(e, t) {
  return Math.max(t[0], e[0]) <= Math.min(t[2], e[2]) && Math.max(t[1], e[1]) <= Math.min(t[3], e[3]);
}
function RX(e, t) {
  return t[0] >= e[0] && t[2] <= e[2] && t[1] >= e[1] && t[3] <= e[3];
}
function gRe(e) {
  return e ? g8(e, uA) : sa(uA);
}
function ix(e) {
  return e != null && e.length === 4;
}
function vRe(e, t) {
  return ix(e) && ix(t) ? e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] : e === t;
}
const uA = [1 / 0, 1 / 0, -1 / 0, -1 / 0], LX = [0, 0, 0, 0];
function v8(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function b8(e) {
  return e.points !== void 0;
}
function w8(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function _8(e) {
  return e.paths !== void 0;
}
function S8(e) {
  return e.rings !== void 0;
}
function $8(e) {
  function t(r, n) {
    return r == null ? n : n == null ? r : e(r, n);
  }
  return t;
}
const wu = $8(Math.min), _u = $8(Math.max);
function bRe(e, t) {
  return _8(t) ? Fh(e, t.paths, !1, !1) : S8(t) ? Fh(e, t.rings, !1, !1) : b8(t) ? _M(e, t.points, !1, !1, !1, !1) : v8(t) ? x8(e, t) : (w8(t) && (e[0] = t.x, e[1] = t.y, e[2] = t.x, e[3] = t.y), e);
}
function wRe(e) {
  let t, r, n, i;
  for (e.reset(), t = n = 1 / 0, r = i = -1 / 0; e.nextPath(); ) {
    const s = NX(e);
    t = Math.min(s[0], t), n = Math.min(s[1], n), r = Math.max(s[2], r), i = Math.max(s[3], i);
  }
  return sa([t, n, r, i]);
}
function NX(e) {
  let t, r, n, i;
  for (t = n = 1 / 0, r = i = -1 / 0; e.nextPoint(); )
    t = Math.min(e.x, t), n = Math.min(e.y, n), r = Math.max(e.x, r), i = Math.max(e.y, i);
  return sa([t, n, r, i]);
}
function _Re(e, t) {
  return _8(t) ? Fh(e, t.paths, !0, !1) : S8(t) ? Fh(e, t.rings, !0, !1) : b8(t) ? _M(e, t.points, !0, !1, !0, !1) : v8(t) ? x8(e, t, !0, !1, !0, !1) : (w8(t) && (e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.x, e[4] = t.y, e[5] = t.z), e);
}
function Fh(e, t, r, n) {
  const i = r ? 3 : 2;
  if (!t.length || !t[0].length)
    return null;
  let s, o, a, l, [c, h] = t[0][0], [f, m] = t[0][0];
  for (let y = 0; y < t.length; y++) {
    const g = t[y];
    for (let v = 0; v < g.length; v++) {
      const b = g[v], [w, x] = b;
      if (c = wu(c, w), h = wu(h, x), f = _u(f, w), m = _u(m, x), r && b.length > 2) {
        const $ = b[2];
        s = wu(s, $), o = _u(o, $);
      }
      if (n && b.length > i) {
        const $ = b[i];
        a = wu(s, $), l = _u(o, $);
      }
    }
  }
  return r ? n ? (e[0] = c, e[1] = h, e[2] = s, e[3] = a, e[4] = f, e[5] = m, e[6] = o, e[7] = l, e.length = 8, e) : (e[0] = c, e[1] = h, e[2] = s, e[3] = f, e[4] = m, e[5] = o, e.length = 6, e) : n ? (e[0] = c, e[1] = h, e[2] = a, e[3] = f, e[4] = m, e[5] = l, e.length = 6, e) : (e[0] = c, e[1] = h, e[2] = f, e[3] = m, e.length = 4, e);
}
function x8(e, t, r, n, i, s) {
  const o = t.xmin, a = t.xmax, l = t.ymin, c = t.ymax;
  let h = t.zmin, f = t.zmax, m = t.mmin, y = t.mmax;
  return i ? (h = h || 0, f = f || 0, s ? (m = m || 0, y = y || 0, e[0] = o, e[1] = l, e[2] = h, e[3] = m, e[4] = a, e[5] = c, e[6] = f, e[7] = y, e) : (e[0] = o, e[1] = l, e[2] = h, e[3] = a, e[4] = c, e[5] = f, e)) : s ? (m = m || 0, y = y || 0, e[0] = o, e[1] = l, e[2] = m, e[3] = a, e[4] = c, e[5] = y, e) : (e[0] = o, e[1] = l, e[2] = a, e[3] = c, e);
}
function _M(e, t, r, n, i, s) {
  const o = r ? 3 : 2, a = n && s, l = r && i;
  if (!t.length || !t[0].length)
    return null;
  let c, h, f, m, [y, g] = t[0], [v, b] = t[0];
  for (let w = 0; w < t.length; w++) {
    const x = t[w], [$, T] = x;
    if (y = wu(y, $), g = wu(g, T), v = _u(v, $), b = _u(b, T), l && x.length > 2) {
      const C = x[2];
      c = wu(c, C), h = _u(h, C);
    }
    if (a && x.length > o) {
      const C = x[o];
      f = wu(c, C), m = _u(h, C);
    }
  }
  return i ? (c = c || 0, h = h || 0, s ? (f = f || 0, m = m || 0, e[0] = y, e[1] = g, e[2] = c, e[3] = f, e[4] = v, e[5] = b, e[6] = h, e[7] = m, e) : (e[0] = y, e[1] = g, e[2] = c, e[3] = v, e[4] = b, e[5] = h, e)) : s ? (f = f || 0, m = m || 0, e[0] = y, e[1] = g, e[2] = f, e[3] = v, e[4] = b, e[5] = m, e) : (e[0] = y, e[1] = g, e[2] = v, e[3] = b, e);
}
function FX(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function DX(e) {
  return e.points !== void 0;
}
function jX(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function VX(e) {
  return e.paths !== void 0;
}
function zX(e) {
  return e.rings !== void 0;
}
const SM = [];
function T8(e, t, r, n) {
  return { xmin: e, ymin: t, xmax: r, ymax: n };
}
function E8(e, t, r, n, i, s) {
  return { xmin: e, ymin: t, zmin: r, xmax: n, ymax: i, zmax: s };
}
function I8(e, t, r, n, i, s) {
  return { xmin: e, ymin: t, mmin: r, xmax: n, ymax: i, mmax: s };
}
function M8(e, t, r, n, i, s, o, a) {
  return { xmin: e, ymin: t, zmin: r, mmin: n, xmax: i, ymax: s, zmax: o, mmax: a };
}
function $M(e, t = !1, r = !1) {
  return t ? r ? M8(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7]) : E8(e[0], e[1], e[2], e[3], e[4], e[5]) : r ? I8(e[0], e[1], e[2], e[3], e[4], e[5]) : T8(e[0], e[1], e[2], e[3]);
}
function SRe(e) {
  return e ? FX(e) ? e : jX(e) ? BX(e) : zX(e) ? O8(e) : VX(e) ? C8(e) : DX(e) ? UX(e) : null : null;
}
function UX(e) {
  const { hasZ: t, hasM: r, points: n } = e;
  return $M(_M(SM, n, t ?? !1, r ?? !1), t, r);
}
function BX(e) {
  const { x: t, y: r, z: n, m: i } = e, s = i != null;
  return n != null ? s ? M8(t, r, n, i, t, r, n, i) : E8(t, r, n, t, r, n) : s ? I8(t, r, i, t, r, i) : T8(t, r, t, r);
}
function O8(e) {
  const { hasZ: t, hasM: r, rings: n } = e, i = Fh(SM, n, t ?? !1, r ?? !1);
  return i ? $M(i, t, r) : null;
}
function C8(e) {
  const { hasZ: t, hasM: r, paths: n } = e, i = Fh(SM, n, t ?? !1, r ?? !1);
  return i ? $M(i, t, r) : null;
}
var Wv;
function cA(e) {
  return !Array.isArray(e[0]);
}
let Mo = Wv = class extends Bu {
  static fromExtent(e) {
    const t = e.clone().normalize(), r = e.spatialReference;
    let n = !1, i = !1;
    for (const o of t)
      o.hasZ && (n = !0), o.hasM && (i = !0);
    const s = { rings: t.map((o) => {
      const a = [[o.xmin, o.ymin], [o.xmin, o.ymax], [o.xmax, o.ymax], [o.xmax, o.ymin], [o.xmin, o.ymin]];
      if (n && o.hasZ) {
        const l = o.zmin + 0.5 * (o.zmax - o.zmin);
        for (let c = 0; c < a.length; c++)
          a[c].push(l);
      }
      if (i && o.hasM) {
        const l = o.mmin + 0.5 * (o.mmax - o.mmin);
        for (let c = 0; c < a.length; c++)
          a[c].push(l);
      }
      return a;
    }), spatialReference: r };
    return n && (s.hasZ = !0), i && (s.hasM = !0), new Wv(s);
  }
  constructor(...e) {
    super(...e), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(e, t) {
    let r, n, i = null, s = null;
    return e && !Array.isArray(e) ? (i = e.rings ?? null, t || (e.spatialReference ? t = e.spatialReference : e.rings || (t = e)), r = e.hasZ, n = e.hasM) : i = e, i = i || [], t = t || tt.WGS84, i.length && i[0] && i[0][0] != null && typeof i[0][0] == "number" && (i = [i]), s = i[0] && i[0][0], s && (r === void 0 && n === void 0 ? (r = s.length > 2, n = s.length > 3) : r === void 0 ? r = n ? s.length > 3 : s.length > 2 : n === void 0 && (n = r ? s.length > 3 : s.length > 2)), { rings: i, spatialReference: t, hasZ: r, hasM: n };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const e = xX(this);
    if (!e || isNaN(e[0]) || isNaN(e[1]) || this.hasZ && isNaN(e[2]))
      return null;
    const t = new Re();
    return t.x = e[0], t.y = e[1], t.spatialReference = this.spatialReference, this.hasZ && (t.z = e[2]), t;
  }
  get extent() {
    const { spatialReference: e } = this, t = O8(this);
    if (!t)
      return null;
    const r = new Ct(t);
    return r.spatialReference = e, r;
  }
  get isSelfIntersecting() {
    return WK(this.rings);
  }
  writeRings(e, t) {
    t.rings = j(this.rings);
  }
  addRing(e) {
    if (!e)
      return;
    const t = this.rings, r = t.length;
    if (cA(e)) {
      const n = [];
      for (let i = 0, s = e.length; i < s; i++)
        n[i] = e[i].toArray();
      t[r] = n;
    } else
      t[r] = e.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const e = new Wv();
    return e.spatialReference = this.spatialReference, e.rings = j(this.rings), e.hasZ = this.hasZ, e.hasM = this.hasM, e;
  }
  equals(e) {
    if (this === e)
      return !0;
    if (e == null)
      return !1;
    const t = this.spatialReference, r = e.spatialReference;
    if (t != null != (r != null) || t != null && r != null && !t.equals(r) || this.rings.length !== e.rings.length)
      return !1;
    const n = ([i, s, o, a], [l, c, h, f]) => i === l && s === c && (o == null && h == null || o === h) && (a == null && f == null || a === f);
    for (let i = 0; i < this.rings.length; i++) {
      const s = this.rings[i], o = e.rings[i];
      if (!Bw(s, o, n))
        return !1;
    }
    return !0;
  }
  contains(e) {
    if (!e)
      return !1;
    const t = o_(e, this.spatialReference);
    return E6(this, t ?? e);
  }
  isClockwise(e) {
    let t;
    return t = cA(e) ? e.map((r) => this.hasZ ? this.hasM ? [r.x, r.y, r.z, r.m] : [r.x, r.y, r.z] : [r.x, r.y]) : e, f8(t, this.hasM, this.hasZ);
  }
  getPoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const r = this.rings[e][t], n = this.hasZ, i = this.hasM;
    return n && !i ? new Re(r[0], r[1], r[2], void 0, this.spatialReference) : i && !n ? new Re(r[0], r[1], void 0, r[2], this.spatialReference) : n && i ? new Re(r[0], r[1], r[2], r[3], this.spatialReference) : new Re(r[0], r[1], this.spatialReference);
  }
  insertPoint(e, t, r) {
    return this._validateInputs(e, t, !0) ? (Nh(this, r), Array.isArray(r) || (r = r.toArray()), this.rings[e].splice(t, 0, r), this.notifyChange("rings"), this) : this;
  }
  removePoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const r = new Re(this.rings[e].splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r;
  }
  removeRing(e) {
    if (!this._validateInputs(e, null))
      return null;
    const t = this.rings.splice(e, 1)[0], r = this.spatialReference, n = t.map((i) => new Re(i, r));
    return this.notifyChange("rings"), n;
  }
  setPoint(e, t, r) {
    return this._validateInputs(e, t) ? (Nh(this, r), Array.isArray(r) || (r = r.toArray()), this.rings[e][t] = r, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(e, t, r = !1) {
    if (e == null || e < 0 || e >= this.rings.length)
      return !1;
    if (t != null) {
      const n = this.rings[e];
      if (r && (t < 0 || t > n.length) || !r && (t < 0 || t >= n.length))
        return !1;
    }
    return !0;
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], Mo.prototype, "cache", null), u([d({ readOnly: !0 })], Mo.prototype, "centroid", null), u([d({ readOnly: !0 })], Mo.prototype, "extent", null), u([d({ readOnly: !0 })], Mo.prototype, "isSelfIntersecting", null), u([d({ type: [[[Number]]], json: { write: { isRequired: !0 } } })], Mo.prototype, "rings", void 0), u([ge("rings")], Mo.prototype, "writeRings", null), Mo = Wv = u([E("geoscene.geometry.Polygon")], Mo), Mo.prototype.toJSON.isDefaultToJSON = !0;
const af = Mo;
var sx;
function qX(e) {
  return !Array.isArray(e[0]);
}
let jl = sx = class extends Bu {
  constructor(...e) {
    super(...e), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(e, t) {
    let r, n, i = null, s = null;
    return e && !Array.isArray(e) ? (i = e.paths ?? null, t || (e.spatialReference ? t = e.spatialReference : e.paths || (t = e)), r = e.hasZ, n = e.hasM) : i = e, i = i || [], t = t || tt.WGS84, i.length && i[0] && i[0][0] != null && typeof i[0][0] == "number" && (i = [i]), s = i[0] && i[0][0], s && (r === void 0 && n === void 0 ? (r = s.length > 2, n = !1) : r === void 0 ? r = !n && s.length > 3 : n === void 0 && (n = !r && s.length > 3)), { paths: i, spatialReference: t, hasZ: r, hasM: n };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: e } = this, t = C8(this);
    if (!t)
      return null;
    const r = new Ct(t);
    return r.spatialReference = e, r;
  }
  writePaths(e, t) {
    t.paths = j(this.paths);
  }
  addPath(e) {
    if (!e)
      return;
    const t = this.paths, r = t.length;
    if (qX(e)) {
      const n = [];
      for (let i = 0, s = e.length; i < s; i++)
        n[i] = e[i].toArray();
      t[r] = n;
    } else
      t[r] = e.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const e = new sx();
    return e.spatialReference = this.spatialReference, e.paths = j(this.paths), e.hasZ = this.hasZ, e.hasM = this.hasM, e;
  }
  getPoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const r = this.paths[e][t], n = this.hasZ, i = this.hasM;
    return n && !i ? new Re(r[0], r[1], r[2], void 0, this.spatialReference) : i && !n ? new Re(r[0], r[1], void 0, r[2], this.spatialReference) : n && i ? new Re(r[0], r[1], r[2], r[3], this.spatialReference) : new Re(r[0], r[1], this.spatialReference);
  }
  insertPoint(e, t, r) {
    return this._validateInputs(e, t, !0) ? (Nh(this, r), Array.isArray(r) || (r = r.toArray()), this.paths[e].splice(t, 0, r), this.notifyChange("paths"), this) : this;
  }
  removePath(e) {
    if (!this._validateInputs(e, null))
      return null;
    const t = this.paths.splice(e, 1)[0], r = this.spatialReference, n = t.map((i) => new Re(i, r));
    return this.notifyChange("paths"), n;
  }
  removePoint(e, t) {
    if (!this._validateInputs(e, t))
      return null;
    const r = new Re(this.paths[e].splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), r;
  }
  setPoint(e, t, r) {
    return this._validateInputs(e, t) ? (Nh(this, r), Array.isArray(r) || (r = r.toArray()), this.paths[e][t] = r, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(e, t, r = !1) {
    if (e == null || e < 0 || e >= this.paths.length)
      return !1;
    if (t != null) {
      const n = this.paths[e];
      if (r && (t < 0 || t > n.length) || !r && (t < 0 || t >= n.length))
        return !1;
    }
    return !0;
  }
  toJSON(e) {
    return this.write({}, e);
  }
};
u([d({ readOnly: !0 })], jl.prototype, "cache", null), u([d({ readOnly: !0 })], jl.prototype, "extent", null), u([d({ type: [[[Number]]], json: { write: { isRequired: !0 } } })], jl.prototype, "paths", void 0), u([ge("paths")], jl.prototype, "writePaths", null), jl = sx = u([E("geoscene.geometry.Polyline")], jl), jl.prototype.toJSON.isDefaultToJSON = !0;
const d_ = jl, GX = Mn()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon" }), dA = Mn()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh" });
function k8(e) {
  return e.xmin !== void 0 && e.ymin !== void 0 && e.xmax !== void 0 && e.ymax !== void 0;
}
function A8(e) {
  return e.points !== void 0;
}
function P8(e) {
  return e.x !== void 0 && e.y !== void 0;
}
function R8(e) {
  return e.paths !== void 0;
}
function gy(e) {
  return e.rings !== void 0;
}
function Pd(e) {
  return e == null ? null : e instanceof Bu ? e : P8(e) ? Re.fromJSON(e) : R8(e) ? d_.fromJSON(e) : gy(e) ? af.fromJSON(e) : A8(e) ? c_.fromJSON(e) : k8(e) ? Ct.fromJSON(e) : null;
}
function $Re(e) {
  return e ? P8(e) ? "esriGeometryPoint" : R8(e) ? "esriGeometryPolyline" : gy(e) ? "esriGeometryPolygon" : k8(e) ? "esriGeometryEnvelope" : A8(e) ? "esriGeometryMultipoint" : null : null;
}
const HX = { esriGeometryPoint: Re, esriGeometryPolyline: d_, esriGeometryPolygon: af, esriGeometryEnvelope: Ct, esriGeometryMultipoint: c_ };
function xRe(e) {
  return e && HX[e] || null;
}
const Qd = { base: Bu, key: "type", typeMap: { extent: Ct, multipoint: c_, point: Re, polyline: d_, polygon: af } };
na(Qd);
let L8 = 0;
const xM = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), Object.defineProperty(this, "uid", { writable: !1, configurable: !1, value: Date.now().toString(16) + "-object-" + L8++ });
    }
  };
  return t = u([E("geoscene.core.Identifiable")], t), t;
}, TM = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), Object.defineProperty(this, "uid", { writable: !1, configurable: !1, value: L8++ });
    }
  };
  return t = u([E("geoscene.core.NumericIdentifiable")], t), t;
};
let pA = class extends xM(class {
}) {
};
pA = u([E("geoscene.core.Identifiable")], pA);
async function WX(e) {
  const t = "portalItem" in e ? e : { portalItem: e }, { fromItem: r } = await import("./portalLayers-AP57473J.js");
  try {
    return await r(t);
  } catch (n) {
    const i = t && t.portalItem, s = i && i.id || "unset", o = i && i.portal && i.portal.url || bt.portalUrl;
    throw se.getLogger("geoscene.layers.support.fromPortalItem").error("#fromPortalItem()", "Failed to create layer from portal item (portal: '" + o + "', id: '" + s + "')", n), n;
  }
}
let JX = 0, Nr = class extends Uu.EventedMixin(xM(sl)) {
  constructor() {
    super(...arguments), this.attributionDataUrl = null, this.fullExtent = new Ct(-180, -90, 180, 90, tt.WGS84), this.id = Date.now().toString(16) + "-layer-" + JX++, this.legendEnabled = !0, this.listMode = "show", this.opacity = 1, this.parent = null, this.popupEnabled = !0, this.attributionVisible = !0, this.spatialReference = tt.WGS84, this.title = null, this.type = null, this.url = null, this.visible = !0;
  }
  static async fromGeoSceneServerUrl(t) {
    const r = typeof t == "string" ? { url: t } : t;
    return (await import("./arcgisLayers-I47B2UCO.js")).fromUrl(r);
  }
  static fromPortalItem(t) {
    return WX(t);
  }
  initialize() {
    this.when().catch((t) => {
      Fi(t) || se.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: t });
    });
  }
  destroy() {
    if (this.parent) {
      const t = this, r = this.parent;
      "layers" in r && r.layers.includes(t) ? r.layers.remove(t) : "tables" in r && r.tables.includes(t) ? r.tables.remove(t) : "baseLayers" in r && r.baseLayers.includes(t) ? r.baseLayers.remove(t) : "baseLayers" in r && r.referenceLayers.includes(t) && r.referenceLayers.remove(t);
    }
  }
  get hasAttributionData() {
    return this.attributionDataUrl != null;
  }
  get parsedUrl() {
    return Di(this.url);
  }
  async fetchAttributionData() {
    const t = this.attributionDataUrl;
    if (this.hasAttributionData && t)
      return (await zr(t, { query: { f: "json" }, responseType: "json" })).data;
    throw new G("layer:no-attribution-data", "Layer does not have attribution data");
  }
};
u([d({ type: String })], Nr.prototype, "attributionDataUrl", void 0), u([d({ type: Ct })], Nr.prototype, "fullExtent", void 0), u([d({ readOnly: !0 })], Nr.prototype, "hasAttributionData", null), u([d({ type: String, clonable: !1 })], Nr.prototype, "id", void 0), u([d({ type: Boolean, nonNullable: !0 })], Nr.prototype, "legendEnabled", void 0), u([d({ type: ["show", "hide", "hide-children"] })], Nr.prototype, "listMode", void 0), u([d({ type: Number, range: { min: 0, max: 1 }, nonNullable: !0 })], Nr.prototype, "opacity", void 0), u([d({ clonable: !1 })], Nr.prototype, "parent", void 0), u([d({ readOnly: !0 })], Nr.prototype, "parsedUrl", null), u([d({ type: Boolean })], Nr.prototype, "popupEnabled", void 0), u([d({ type: Boolean })], Nr.prototype, "attributionVisible", void 0), u([d({ type: tt })], Nr.prototype, "spatialReference", void 0), u([d({ type: String })], Nr.prototype, "title", void 0), u([d({ readOnly: !0, json: { read: !1 } })], Nr.prototype, "type", void 0), u([d()], Nr.prototype, "url", void 0), u([d({ type: Boolean, nonNullable: !0 })], Nr.prototype, "visible", void 0), Nr = u([E("geoscene.layers.Layer")], Nr);
const EM = Nr;
function ox(e, t, r) {
  let n, i;
  if (e)
    for (let s = 0, o = e.length; s < o; s++) {
      if (n = e.at(s), (n == null ? void 0 : n[t]) === r)
        return n;
      if ((n == null ? void 0 : n.type) === "group" && (i = ox(n.layers, t, r), i))
        return i;
    }
}
const ZX = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this.layers = new je();
      const n = (o) => {
        o.parent && "remove" in o.parent && o.parent.remove(o);
      }, i = (o) => {
        o.parent = this, this.layerAdded(o), o.type !== "elevation" && o.type !== "base-elevation" || se.getLogger(this).error(`Layer 'title:${o.title}, id:${o.id}' of type '${o.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, s = (o) => {
        o.parent = null, this.layerRemoved(o);
      };
      this.addHandles([this.layers.on("before-add", (o) => n(o.item)), this.layers.on("after-add", (o) => i(o.item)), this.layers.on("after-remove", (o) => s(o.item))]);
    }
    destroy() {
      const r = this.layers.toArray();
      for (const n of r)
        n.destroy();
      this.layers.destroy();
    }
    set layers(r) {
      this._set("layers", Ed(r, this._get("layers")));
    }
    add(r, n) {
      const i = this.layers;
      if (n = i.getNextIndex(n), r instanceof EM) {
        const s = r;
        s.parent === this ? this.reorder(s, n) : i.add(s, n);
      } else
        pl(r) ? r.then((s) => {
          this.destroyed || this.add(s, n);
        }) : se.getLogger(this).error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(r, n) {
      const i = this.layers;
      let s = i.getNextIndex(n);
      r.slice().forEach((o) => {
        o.parent !== this ? (i.add(o, s), s += 1) : this.reorder(o, s);
      });
    }
    findLayerById(r) {
      return ox(this.layers, "id", r);
    }
    findLayerByUid(r) {
      return ox(this.layers, "uid", r);
    }
    remove(r) {
      return this.layers.remove(r);
    }
    removeMany(r) {
      return this.layers.removeMany(r);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(r, n) {
      return this.layers.reorder(r, n);
    }
    layerAdded(r) {
    }
    layerRemoved(r) {
    }
  };
  return u([d()], t.prototype, "layers", null), t = u([E("geoscene.support.LayersMixin")], t), t;
};
function ax(e, t, r) {
  if (e)
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e.at(n);
      if (s[t] === r)
        return s;
      if ((s == null ? void 0 : s.type) === "group") {
        const o = ax(s.tables, t, r);
        if (o)
          return o;
      }
    }
}
const KX = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this.tables = new je(), this.addHandles([this.tables.on("after-add", (n) => {
        const i = n.item;
        i.parent && i.parent !== this && "tables" in i.parent && i.parent.tables.remove(i), i.parent = this, i.type !== "feature" && se.getLogger(this).error(`Layer 'title:${i.title}, id:${i.id}' of type '${i.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (n) => {
        n.item.parent = null;
      })]);
    }
    destroy() {
      const r = this.tables.removeAll();
      for (const n of r)
        n.destroy();
      this.tables.destroy();
    }
    set tables(r) {
      this._set("tables", Ed(r, this._get("tables")));
    }
    findTableById(r) {
      return ax(this.tables, "id", r);
    }
    findTableByUid(r) {
      return ax(this.tables, "uid", r);
    }
  };
  return u([d()], t.prototype, "tables", null), t = u([E("geoscene.support.TablesMixin")], t), t;
};
let Oo = class extends KX(ZX(Uu.EventedMixin(Ae))) {
  constructor(t) {
    super(t), this.allLayers = new Ky({ getCollections: () => {
      var r, n, i;
      return [(r = this.basemap) == null ? void 0 : r.baseLayers, (n = this.ground) == null ? void 0 : n.layers, this.layers, (i = this.basemap) == null ? void 0 : i.referenceLayers];
    }, getChildrenFunction: (r) => "layers" in r ? r.layers : null }), this.allTables = mX(this), this.basemap = null, this.editableLayers = new Ky({ getCollections: () => [this.allLayers], itemFilterFunction: cX }), this.ground = new Rb(), this._basemapCache = pX();
  }
  destroy() {
    var t, r;
    this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), (t = this.ground) == null || t.destroy(), (r = this.basemap) == null || r.destroy(), hX(this._basemapCache), this._basemapCache = null;
  }
  castBasemap(t) {
    return fX(t, this._basemapCache);
  }
  castGround(t) {
    return yX(t) ?? this._get("ground");
  }
  findLayerById(t) {
    return this.allLayers.find((r) => r.id === t);
  }
  findTableById(t) {
    return this.allTables.find((r) => r.id === t);
  }
};
u([d({ readOnly: !0, dependsOn: [] })], Oo.prototype, "allLayers", void 0), u([d({ readOnly: !0 })], Oo.prototype, "allTables", void 0), u([d({ type: kb })], Oo.prototype, "basemap", void 0), u([xt("basemap")], Oo.prototype, "castBasemap", null), u([d({ readOnly: !0 })], Oo.prototype, "editableLayers", void 0), u([d({ type: Rb, nonNullable: !0 })], Oo.prototype, "ground", void 0), u([xt("ground")], Oo.prototype, "castGround", null), Oo = u([E("geoscene.Map")], Oo);
const N8 = Oo, Rt = (e) => {
  let t = class extends e {
    clone() {
      var l;
      const r = as(Bn(this), "unable to clone instance of non-accessor class"), n = r.metadatas, i = r.store, s = {}, o = /* @__PURE__ */ new Map();
      for (const c in n) {
        const h = n[c], f = i == null ? void 0 : i.originOf(c), m = h.clonable;
        if (h.readOnly || m === !1 || f !== Qe.USER && f !== Qe.DEFAULTS && f !== Qe.WEB_MAP && f !== Qe.WEB_SCENE)
          continue;
        const y = this[c];
        let g = null;
        g = typeof m == "function" ? m(y) : m === "reference" ? y : $$(y), y != null && g == null || (f === Qe.DEFAULTS ? o.set(c, g) : s[c] = g);
      }
      const a = new (Object.getPrototypeOf(this)).constructor(s);
      if (o.size) {
        const c = (l = Bn(a)) == null ? void 0 : l.store;
        if (c)
          for (const [h, f] of o)
            c.set(h, f, Qe.DEFAULTS);
      }
      return a;
    }
  };
  return t = u([E("geoscene.core.Clonable")], t), t;
};
let hA = class extends Rt(Ae) {
};
hA = u([E("geoscene.core.Clonable")], hA);
var Dh;
function YX(e, t) {
  switch (e.type) {
    case "range": {
      const r = "range" in e ? e.range[0] : e.minValue, n = "range" in e ? e.range[1] : e.maxValue;
      if (r != null && +t < r || n != null && +t > n)
        return Dh.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (e.codedValues == null || e.codedValues.every((r) => r == null || r.code !== t))
        return Dh.INVALID_CODED_VALUE;
  }
  return null;
}
(function(e) {
  e.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
})(Dh || (Dh = {}));
const QX = se.getLogger("geoscene.support.arcadeOnDemand");
let z2;
function Rd() {
  return z2 || (z2 = (async () => {
    const e = await import("./arcadeUtils-6_knHA4j.js").then((t) => t.az);
    return { arcade: e.arcade, arcadeUtils: e, Dictionary: e.Dictionary, Feature: e.arcadeFeature };
  })()), z2;
}
const ORe = (e, t, r) => IM.create(e, t, r, null, ["$feature"], []), CRe = (e, t, r) => IM.create(e, t, r, null, ["$feature", "$view"], []), XX = (e, t, r, n) => IM.create(e, t, r, n, ["$feature", "$view"], []);
let IM = class F8 {
  constructor(t, r, n, i, s, o, a) {
    this.services = null, this.script = t, this.evaluate = i;
    const l = Array.isArray(o) ? o : o.fields;
    this.fields = l, this._syntaxTree = n, this._arcade = r, this._arcadeFeature = s, this._spatialReference = a, this._referencesGeometry = r.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(t, r, n, i, s, o) {
    const { arcade: a, Feature: l, Dictionary: c } = await Rd(), h = tt.fromJSON(r);
    let f;
    try {
      f = a.parseScript(t, o);
    } catch (M) {
      return QX.error(new G("arcade-bad-expression", "Failed to parse arcade script", { script: t, error: M })), null;
    }
    const m = s.reduce((M, L) => ({ ...M, [L]: null }), {});
    let y = null;
    i != null && (y = new c(i), y.immutable = !0, m.$config = null);
    const g = a.scriptUsesGeometryEngine(f), v = g && a.enableGeometrySupport(), b = a.scriptUsesFeatureSet(f) && a.enableFeatureSetSupport(), w = a.scriptIsAsync(f), x = w && a.enableAsyncSupport(), $ = { vars: m, spatialReference: h, useAsync: !!x };
    await Promise.all([v, b, x]);
    const T = /* @__PURE__ */ new Set();
    await a.loadDependentModules(T, f, null, w, g);
    const C = new c();
    C.immutable = !1, C.setField("scale", 0);
    const I = a.compileScript(f, $), O = (M, L) => ("$view" in M && M.$view && (C.setField("scale", typeof M.$view == "object" && "scale" in M.$view ? M.$view.scale : void 0), M.$view = C), y && (M.$config = y), I({ vars: M, spatialReference: h, services: L }));
    return new F8(t, a, f, O, new l(), n, h);
  }
  repurposeFeature(t) {
    return t.geometry && !t.geometry.spatialReference && (t.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(t.geometry, t.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
};
const eee = /^([0-9_])/, tee = /[^a-z0-9_\u0080-\uffff]+/gi;
function ree(e) {
  return e == null ? null : e.trim().replaceAll(tee, "_").replace(eee, "F$1") || null;
}
const nee = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"], iee = ["field", "normalizationField"];
function fA(e, t) {
  if (e != null && t != null) {
    for (const r of Array.isArray(e) ? e : [e])
      if (mA(nee, r, t), "visualVariables" in r && r.visualVariables)
        for (const n of r.visualVariables)
          mA(iee, n, t);
  }
}
function mA(e, t, r) {
  if (e)
    for (const n of e) {
      const i = Pg(n, t), s = i && typeof i != "function" && r.get(i);
      s && In(n, s.name, t);
    }
}
function D8(e, t) {
  var r;
  if (e != null && ((r = t == null ? void 0 : t.fields) != null && r.length))
    if ("startField" in e) {
      const n = t.get(e.startField), i = t.get(e.endField);
      e.startField = (n == null ? void 0 : n.name) ?? null, e.endField = (i == null ? void 0 : i.name) ?? null;
    } else {
      const n = t.get(e.startTimeField), i = t.get(e.endTimeField);
      e.startTimeField = (n == null ? void 0 : n.name) ?? null, e.endTimeField = (i == null ? void 0 : i.name) ?? null;
    }
}
const U2 = /* @__PURE__ */ new Set();
function MM(e, t) {
  return e && t ? (U2.clear(), Yy(U2, e, t), Array.from(U2).sort()) : [];
}
function Yy(e, t, r) {
  var n;
  if (r)
    if ((n = t == null ? void 0 : t.fields) != null && n.length)
      if (r.includes("*"))
        for (const { name: i } of t.fields)
          e.add(i);
      else
        for (const i of r)
          Pi(e, t, i);
    else {
      if (r.includes("*"))
        return e.clear(), void e.add("*");
      for (const i of r)
        i != null && e.add(i);
    }
}
function Pi(e, t, r) {
  if (typeof r == "string")
    if (t) {
      const n = t.get(r);
      n && e.add(n.name);
    } else
      e.add(r);
}
function kRe(e, t) {
  return t == null || e == null ? [] : t.includes("*") ? (e.fields ?? []).map((r) => r.name) : t;
}
async function qn(e, t, r) {
  var s;
  if (!r)
    return;
  const { arcadeUtils: n } = await Rd(), i = n.extractFieldNames(r, (s = t == null ? void 0 : t.fields) == null ? void 0 : s.map((o) => o.name));
  for (const o of i)
    Pi(e, t, o);
}
async function j8(e, t, r) {
  if (r && r !== "1=1") {
    const { WhereClause: n } = await import("./WhereClause-ULyNcODK.js").then((s) => s.W), i = n.create(r, t);
    if (!i.isStandardized)
      throw new G("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: r });
    Yy(e, t, i.fieldNames);
  }
}
function see({ displayField: e, fields: t }) {
  return e || (t && t.length ? B2(t, "name-or-title") || B2(t, "unique-identifier") || B2(t, "type-or-category") || oee(t) : null);
}
function oee(e) {
  for (const t of e) {
    if (!t || !t.name)
      continue;
    const r = t.name.toLowerCase();
    if (r.includes("name") || r.includes("title"))
      return t.name;
  }
  return null;
}
function B2(e, t) {
  for (const r of e)
    if (r && r.valueType && r.valueType === t)
      return r.name;
  return null;
}
async function ARe(e, t) {
  var n;
  if (!t)
    return;
  const r = (n = t.elevationInfo) == null ? void 0 : n.featureExpressionInfo;
  return r ? r.collectRequiredFields(e, t.fieldsIndex) : void 0;
}
function aee(e, t, r) {
  r.onStatisticExpression ? qn(e, t, r.onStatisticExpression.expression) : e.add(r.onStatisticField);
}
async function PRe(e, t, r) {
  if (!t || !r || !("fields" in r))
    return;
  const n = [], i = r.popupTemplate;
  n.push(lee(e, t, i)), r.fields && n.push(...r.fields.map(async (s) => aee(e, t.fieldsIndex, s))), await Promise.all(n);
}
async function lee(e, t, r) {
  const n = [];
  r != null && r.expressionInfos && n.push(...r.expressionInfos.map((s) => qn(e, t.fieldsIndex, s.expression)));
  const i = r == null ? void 0 : r.content;
  if (Array.isArray(i))
    for (const s of i)
      s.type === "expression" && s.expressionInfo && n.push(qn(e, t.fieldsIndex, s.expressionInfo.expression));
  await Promise.all(n);
}
async function RRe(e, t, r) {
  t && (t.timeInfo && r != null && r.timeExtent && Yy(e, t.fieldsIndex, [t.timeInfo.startField, t.timeInfo.endField]), t.floorInfo && Yy(e, t.fieldsIndex, [t.floorInfo.floorField]), r != null && r.where != null && await j8(e, t.fieldsIndex, r.where));
}
async function LRe(e, t, r) {
  t && r && await Promise.all(r.map((n) => uee(e, t, n)));
}
async function uee(e, t, r) {
  t && r && (r.valueExpression ? await qn(e, t.fieldsIndex, r.valueExpression) : r.field && Pi(e, t.fieldsIndex, r.field));
}
function NRe(e) {
  return e ? MM(e.fieldsIndex, V8(e)) : [];
}
function cee(e) {
  if (!e)
    return [];
  const t = e.geometryFieldsInfo;
  return t ? MM(e.fieldsIndex, [t.shapeAreaField, t.shapeLengthField]) : [];
}
const dee = ["oid", "global-id", "guid"], pee = ["oid", "global-id"], hee = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i];
function fee(e) {
  const t = /* @__PURE__ */ new Set();
  z8(e).forEach((n) => t.add(n)), cee(e).forEach((n) => t.add(n.toLowerCase()));
  const r = e && "infoFor3D" in e ? e.infoFor3D : void 0;
  return r && (Object.values(r.assetMapFieldRoles).forEach((n) => t.add(n.toLowerCase())), Object.values(r.transformFieldRoles).forEach((n) => t.add(n.toLowerCase()))), Array.from(t);
}
function V8(e) {
  if (!e)
    return [];
  const t = "editFieldsInfo" in e && e.editFieldsInfo;
  if (!t)
    return [];
  const { creationDateField: r, creatorField: n, editDateField: i, editorField: s } = t;
  return [r, n, i, s].filter(Boolean);
}
function z8(e) {
  return V8(e).map((t) => t.toLowerCase());
}
function mee(e, t) {
  var r;
  return e.editable && !dee.includes(e.type) && !z8(t).includes(((r = e.name) == null ? void 0 : r.toLowerCase()) ?? "");
}
function yee(e, t) {
  var n;
  const r = ((n = e.name) == null ? void 0 : n.toLowerCase()) ?? "";
  return !((t == null ? void 0 : t.objectIdField) != null && r === t.objectIdField.toLowerCase() || (t == null ? void 0 : t.globalIdField) != null && r === t.globalIdField.toLowerCase() || fee(t).includes(r) || pee.includes(e.type) || hee.some((i) => i.test(r)));
}
async function FRe(e, t) {
  const { labelingInfo: r, fieldsIndex: n } = t;
  r && r.length && await Promise.all(r.map((i) => gee(e, n, i)));
}
async function gee(e, t, r) {
  if (!r)
    return;
  const n = r.getLabelExpression(), i = r.where;
  if (n.type === "arcade")
    await qn(e, t, n.expression);
  else {
    const s = n.expression.match(/{[^}]*}/g);
    s && s.forEach((o) => {
      Pi(e, t, o.slice(1, -1));
    });
  }
  await j8(e, t, i);
}
function vee(e) {
  const t = e.defaultValue;
  return t !== void 0 && q8(e, t) ? t : e.nullable ? null : void 0;
}
function U8(e) {
  return typeof e == "number" && !isNaN(e) && isFinite(e);
}
function bee(e) {
  return e === null || U8(e);
}
const OM = "isInteger" in Number ? Number.isInteger : (e) => typeof e == "number" && isFinite(e) && Math.floor(e) === e;
function wee(e) {
  return e === null || OM(e);
}
function B8(e) {
  return e != null && typeof e == "string";
}
function _ee(e) {
  return e === null || B8(e);
}
function See() {
  return !0;
}
function q8(e, t) {
  let r;
  switch (e.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
      r = e.nullable ? wee : OM;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      r = e.nullable ? bee : U8;
      break;
    case "string":
    case "esriFieldTypeString":
      r = e.nullable ? _ee : B8;
      break;
    default:
      r = See;
  }
  return arguments.length === 1 ? r : r(t);
}
const $ee = ["integer", "small-integer", "single", "double"], xee = /* @__PURE__ */ new Set([...$ee, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]), Tee = ["date", "date-only", "time-only", "timestamp-offset"], Eee = /* @__PURE__ */ new Set([...Tee, "esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
function G8(e) {
  return e != null && xee.has(e.type);
}
function DRe(e) {
  return e != null && (e.type === "string" || e.type === "esriFieldTypeString");
}
function jRe(e) {
  return e != null && Eee.has(e.type);
}
var Lb, Nb;
function VRe(e) {
  return e == null || typeof e == "number" && isNaN(e) ? null : e;
}
function zRe(e, t) {
  return e == null || e.nullable && t === null ? null : G8(e) && !Iee(e.type, Number(t)) ? Lb.OUT_OF_RANGE : q8(e, t) ? e.domain ? YX(e.domain, t) : null : Nb.INVALID_TYPE;
}
function Iee(e, t) {
  const r = typeof e == "string" ? H8(e) : e;
  if (!r)
    return !1;
  const n = r.min, i = r.max;
  return r.isInteger ? OM(t) && t >= n && t <= i : t >= n && t <= i;
}
function H8(e) {
  switch (e) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return Mee;
    case "esriFieldTypeInteger":
    case "integer":
      return Oee;
    case "esriFieldTypeBigInteger":
    case "big-integer":
      return Cee;
    case "esriFieldTypeSingle":
    case "single":
      return kee;
    case "esriFieldTypeDouble":
    case "double":
      return Aee;
  }
}
(function(e) {
  e.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
})(Lb || (Lb = {})), function(e) {
  e.INVALID_TYPE = "type-validation-error::invalid-type";
}(Nb || (Nb = {}));
const Mee = { min: -32768, max: 32767, isInteger: !0 }, Oee = { min: -2147483648, max: 2147483647, isInteger: !0 }, Cee = { min: -Number.MAX_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, isInteger: !0 }, kee = { min: -34e37, max: 12e37, isInteger: !1 }, Aee = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: !1 };
function URe(e, t, r) {
  switch (e) {
    case Dh.INVALID_CODED_VALUE:
      return `Value ${r} is not in the coded domain - field: ${t.name}, domain: ${JSON.stringify(t.domain)}`;
    case Dh.VALUE_OUT_OF_RANGE:
      return `Value ${r} is out of the range of valid values - field: ${t.name}, domain: ${JSON.stringify(t.domain)}`;
    case Nb.INVALID_TYPE:
      return `Value ${r} is not a valid value for the field type - field: ${t.name}, type: ${t.type}, nullable: ${t.nullable}`;
    case Lb.OUT_OF_RANGE: {
      const { min: n, max: i } = H8(t.type);
      return `Value ${r} is out of range for the number type - field: ${t.name}, type: ${t.type}, value range is ${n} to ${i}`;
    }
  }
}
function BRe(e, t) {
  return !Pee(e, t, null);
}
function Pee(e, t, r) {
  if (!t || !t.attributes || !e) {
    if (r != null)
      for (const s of e ?? [])
        r.add(s);
    return !0;
  }
  const n = t.attributes;
  let i = !1;
  for (const s of e)
    if (!(s in n)) {
      if (i = !0, r == null)
        break;
      r.add(s);
    }
  return i;
}
function Ree(e) {
  return !!e && ["raster.itempixelvalue", "raster.servicepixelvalue"].some((t) => e.toLowerCase().startsWith(t));
}
let Jv = class extends re {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d({ type: ["attachments", "custom", "fields", "media", "text", "expression", "relationship"], readOnly: !0, json: { read: !1, write: !0 } })], Jv.prototype, "type", void 0), Jv = u([E("geoscene.popup.content.Content")], Jv);
const qu = Jv;
var lx;
let pc = lx = class extends qu {
  constructor(e) {
    super(e), this.description = null, this.displayType = "auto", this.title = null, this.type = "attachments";
  }
  clone() {
    return new lx({ description: this.description, displayType: this.displayType, title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], pc.prototype, "description", void 0), u([d({ type: ["auto", "preview", "list"], json: { write: !0 } })], pc.prototype, "displayType", void 0), u([d({ type: String, json: { write: !0 } })], pc.prototype, "title", void 0), u([d({ type: ["attachments"], readOnly: !0, json: { read: !1, write: !0 } })], pc.prototype, "type", void 0), pc = lx = u([E("geoscene.popup.content.AttachmentsContent")], pc);
const Qy = pc;
var ux;
let hc = ux = class extends qu {
  constructor(e) {
    super(e), this.creator = null, this.destroyer = null, this.outFields = null, this.type = "custom";
  }
  clone() {
    return new ux({ creator: this.creator, destroyer: this.destroyer, outFields: Array.isArray(this.outFields) ? j(this.outFields) : null });
  }
};
u([d()], hc.prototype, "creator", void 0), u([d()], hc.prototype, "destroyer", void 0), u([d()], hc.prototype, "outFields", void 0), u([d({ type: ["custom"], readOnly: !0 })], hc.prototype, "type", void 0), hc = ux = u([E("geoscene.popup.content.CustomContent")], hc);
const Lee = hc;
var cx;
let Ep = cx = class extends re {
  constructor(e) {
    super(e), this.title = null, this.expression = null, this.returnType = "dictionary";
  }
  clone() {
    return new cx({ title: this.title, expression: this.expression });
  }
};
u([d({ type: String, json: { write: !0 } })], Ep.prototype, "title", void 0), u([d({ type: String, json: { write: !0 } })], Ep.prototype, "expression", void 0), u([d({ type: ["dictionary"], readOnly: !0, json: { read: !1, write: !0 } })], Ep.prototype, "returnType", void 0), Ep = cx = u([E("geoscene.popup.ElementExpressionInfo")], Ep);
const Nee = Ep;
var dx;
let fm = dx = class extends qu {
  constructor(e) {
    super(e), this.expressionInfo = null, this.type = "expression";
  }
  clone() {
    var e;
    return new dx({ expressionInfo: (e = this.expressionInfo) == null ? void 0 : e.clone() });
  }
};
u([d({ type: Nee, json: { write: !0 } })], fm.prototype, "expressionInfo", void 0), u([d({ type: ["expression"], readOnly: !0, json: { read: !1, write: !0 } })], fm.prototype, "type", void 0), fm = dx = u([E("geoscene.popup.content.ExpressionContent")], fm);
const CM = fm;
class Xd extends Error {
}
class Fee extends Xd {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}
class Dee extends Xd {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}
class jee extends Xd {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}
class mm extends Xd {
}
class W8 extends Xd {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}
class us extends Xd {
}
class xl extends Xd {
  constructor() {
    super("Zone is an abstract class");
  }
}
const we = "numeric", fo = "short", Ri = "long", Fb = {
  year: we,
  month: we,
  day: we
}, J8 = {
  year: we,
  month: fo,
  day: we
}, Vee = {
  year: we,
  month: fo,
  day: we,
  weekday: fo
}, Z8 = {
  year: we,
  month: Ri,
  day: we
}, K8 = {
  year: we,
  month: Ri,
  day: we,
  weekday: Ri
}, Y8 = {
  hour: we,
  minute: we
}, Q8 = {
  hour: we,
  minute: we,
  second: we
}, X8 = {
  hour: we,
  minute: we,
  second: we,
  timeZoneName: fo
}, eD = {
  hour: we,
  minute: we,
  second: we,
  timeZoneName: Ri
}, tD = {
  hour: we,
  minute: we,
  hourCycle: "h23"
}, rD = {
  hour: we,
  minute: we,
  second: we,
  hourCycle: "h23"
}, nD = {
  hour: we,
  minute: we,
  second: we,
  hourCycle: "h23",
  timeZoneName: fo
}, iD = {
  hour: we,
  minute: we,
  second: we,
  hourCycle: "h23",
  timeZoneName: Ri
}, sD = {
  year: we,
  month: we,
  day: we,
  hour: we,
  minute: we
}, oD = {
  year: we,
  month: we,
  day: we,
  hour: we,
  minute: we,
  second: we
}, aD = {
  year: we,
  month: fo,
  day: we,
  hour: we,
  minute: we
}, lD = {
  year: we,
  month: fo,
  day: we,
  hour: we,
  minute: we,
  second: we
}, zee = {
  year: we,
  month: fo,
  day: we,
  weekday: fo,
  hour: we,
  minute: we
}, uD = {
  year: we,
  month: Ri,
  day: we,
  hour: we,
  minute: we,
  timeZoneName: fo
}, cD = {
  year: we,
  month: Ri,
  day: we,
  hour: we,
  minute: we,
  second: we,
  timeZoneName: fo
}, dD = {
  year: we,
  month: Ri,
  day: we,
  weekday: Ri,
  hour: we,
  minute: we,
  timeZoneName: Ri
}, pD = {
  year: we,
  month: Ri,
  day: we,
  weekday: Ri,
  hour: we,
  minute: we,
  second: we,
  timeZoneName: Ri
};
class Fg {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new xl();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new xl();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new xl();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, r) {
    throw new xl();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, r) {
    throw new xl();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    throw new xl();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    throw new xl();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new xl();
  }
}
let q2 = null;
class p_ extends Fg {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return q2 === null && (q2 = new p_()), q2;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: r, locale: n }) {
    return fD(t, r, n);
  }
  /** @override **/
  formatOffset(t, r) {
    return by(this.offset(t), r);
  }
  /** @override **/
  offset(t) {
    return -new Date(t).getTimezoneOffset();
  }
  /** @override **/
  equals(t) {
    return t.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let Zv = {};
function Uee(e) {
  return Zv[e] || (Zv[e] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), Zv[e];
}
const Bee = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function qee(e, t) {
  const r = e.format(t).replace(/\u200E/g, ""), n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r), [, i, s, o, a, l, c, h] = n;
  return [o, i, s, a, l, c, h];
}
function Gee(e, t) {
  const r = e.formatToParts(t), n = [];
  for (let i = 0; i < r.length; i++) {
    const { type: s, value: o } = r[i], a = Bee[s];
    s === "era" ? n[a] = o : dt(a) || (n[a] = parseInt(o, 10));
  }
  return n;
}
let k0 = {};
class ol extends Fg {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    return k0[t] || (k0[t] = new ol(t)), k0[t];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    k0 = {}, Zv = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = ol.isValidZone(t);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: r, locale: n }) {
    return fD(t, r, n, this.name);
  }
  /** @override **/
  formatOffset(t, r) {
    return by(this.offset(t), r);
  }
  /** @override **/
  offset(t) {
    const r = new Date(t);
    if (isNaN(r))
      return NaN;
    const n = Uee(this.name);
    let [i, s, o, a, l, c, h] = n.formatToParts ? Gee(n, r) : qee(n, r);
    a === "BC" && (i = -Math.abs(i) + 1);
    const m = PM({
      year: i,
      month: s,
      day: o,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: h,
      millisecond: 0
    });
    let y = +r;
    const g = y % 1e3;
    return y -= g >= 0 ? g : 1e3 + g, (m - y) / (60 * 1e3);
  }
  /** @override **/
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let yA = {};
function Hee(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = yA[r];
  return n || (n = new Intl.ListFormat(e, t), yA[r] = n), n;
}
let px = {};
function hx(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = px[r];
  return n || (n = new Intl.DateTimeFormat(e, t), px[r] = n), n;
}
let fx = {};
function Wee(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = fx[r];
  return n || (n = new Intl.NumberFormat(e, t), fx[r] = n), n;
}
let mx = {};
function Jee(e, t = {}) {
  const { base: r, ...n } = t, i = JSON.stringify([e, n]);
  let s = mx[i];
  return s || (s = new Intl.RelativeTimeFormat(e, t), mx[i] = s), s;
}
let ym = null;
function Zee() {
  return ym || (ym = new Intl.DateTimeFormat().resolvedOptions().locale, ym);
}
function Kee(e) {
  const t = e.indexOf("-x-");
  t !== -1 && (e = e.substring(0, t));
  const r = e.indexOf("-u-");
  if (r === -1)
    return [e];
  {
    let n, i;
    try {
      n = hx(e).resolvedOptions(), i = e;
    } catch {
      const l = e.substring(0, r);
      n = hx(l).resolvedOptions(), i = l;
    }
    const { numberingSystem: s, calendar: o } = n;
    return [i, s, o];
  }
}
function Yee(e, t, r) {
  return (r || t) && (e.includes("-u-") || (e += "-u"), r && (e += `-ca-${r}`), t && (e += `-nu-${t}`)), e;
}
function Qee(e) {
  const t = [];
  for (let r = 1; r <= 12; r++) {
    const n = We.utc(2016, r, 1);
    t.push(e(n));
  }
  return t;
}
function Xee(e) {
  const t = [];
  for (let r = 1; r <= 7; r++) {
    const n = We.utc(2016, 11, 13 + r);
    t.push(e(n));
  }
  return t;
}
function A0(e, t, r, n, i) {
  const s = e.listingMode(r);
  return s === "error" ? null : s === "en" ? n(t) : i(t);
}
function ete(e) {
  return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn";
}
class tte {
  constructor(t, r, n) {
    this.padTo = n.padTo || 0, this.floor = n.floor || !1;
    const { padTo: i, floor: s, ...o } = n;
    if (!r || Object.keys(o).length > 0) {
      const a = { useGrouping: !1, ...n };
      n.padTo > 0 && (a.minimumIntegerDigits = n.padTo), this.inf = Wee(t, a);
    }
  }
  format(t) {
    if (this.inf) {
      const r = this.floor ? Math.floor(t) : t;
      return this.inf.format(r);
    } else {
      const r = this.floor ? Math.floor(t) : AM(t, 3);
      return Mr(r, this.padTo);
    }
  }
}
class rte {
  constructor(t, r, n) {
    this.opts = n, this.originalZone = void 0;
    let i;
    if (this.opts.timeZone)
      this.dt = t;
    else if (t.zone.type === "fixed") {
      const o = -1 * (t.offset / 60), a = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      t.offset !== 0 && ol.create(a).valid ? (i = a, this.dt = t) : (i = "UTC", this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    } else
      t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t, i = t.zone.name) : (i = "UTC", this.dt = t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    const s = { ...this.opts };
    s.timeZone = s.timeZone || i, this.dtf = hx(r, s);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: t }) => t).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const t = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? t.map((r) => {
      if (r.type === "timeZoneName") {
        const n = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...r,
          value: n
        };
      } else
        return r;
    }) : t;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class nte {
  constructor(t, r, n) {
    this.opts = { style: "long", ...n }, !r && hD() && (this.rtf = Jee(t, n));
  }
  format(t, r) {
    return this.rtf ? this.rtf.format(t, r) : wte(r, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, r) {
    return this.rtf ? this.rtf.formatToParts(t, r) : [];
  }
}
class Kt {
  static fromOpts(t) {
    return Kt.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN);
  }
  static create(t, r, n, i = !1) {
    const s = t || Ir.defaultLocale, o = s || (i ? "en-US" : Zee()), a = r || Ir.defaultNumberingSystem, l = n || Ir.defaultOutputCalendar;
    return new Kt(o, a, l, s);
  }
  static resetCache() {
    ym = null, px = {}, fx = {}, mx = {};
  }
  static fromObject({ locale: t, numberingSystem: r, outputCalendar: n } = {}) {
    return Kt.create(t, r, n);
  }
  constructor(t, r, n, i) {
    const [s, o, a] = Kee(t);
    this.locale = s, this.numberingSystem = r || o || null, this.outputCalendar = n || a || null, this.intl = Yee(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = ete(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), r = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && r ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : Kt.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, r = !1, n = !0) {
    return A0(this, t, n, gD, () => {
      const i = r ? { month: t, day: "numeric" } : { month: t }, s = r ? "format" : "standalone";
      return this.monthsCache[s][t] || (this.monthsCache[s][t] = Qee((o) => this.extract(o, i, "month"))), this.monthsCache[s][t];
    });
  }
  weekdays(t, r = !1, n = !0) {
    return A0(this, t, n, wD, () => {
      const i = r ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, s = r ? "format" : "standalone";
      return this.weekdaysCache[s][t] || (this.weekdaysCache[s][t] = Xee(
        (o) => this.extract(o, i, "weekday")
      )), this.weekdaysCache[s][t];
    });
  }
  meridiems(t = !0) {
    return A0(
      this,
      void 0,
      t,
      () => _D,
      () => {
        if (!this.meridiemCache) {
          const r = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [We.utc(2016, 11, 13, 9), We.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, r, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t, r = !0) {
    return A0(this, t, r, SD, () => {
      const n = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [We.utc(-40, 1, 1), We.utc(2017, 1, 1)].map(
        (i) => this.extract(i, n, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, r, n) {
    const i = this.dtFormatter(t, r), s = i.formatToParts(), o = s.find((a) => a.type.toLowerCase() === n);
    return o ? o.value : null;
  }
  numberFormatter(t = {}) {
    return new tte(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, r = {}) {
    return new rte(t, this.intl, r);
  }
  relFormatter(t = {}) {
    return new nte(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return Hee(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
}
let G2 = null;
class Tn extends Fg {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return G2 === null && (G2 = new Tn(0)), G2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(t) {
    return t === 0 ? Tn.utcInstance : new Tn(t);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(t) {
    if (t) {
      const r = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r)
        return new Tn(f_(r[1], r[2]));
    }
    return null;
  }
  constructor(t) {
    super(), this.fixed = t;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${by(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${by(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(t, r) {
    return by(this.fixed, r);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(t) {
    return t.type === "fixed" && t.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class ite extends Fg {
  constructor(t) {
    super(), this.zoneName = t;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function yu(e, t) {
  if (dt(e) || e === null)
    return t;
  if (e instanceof Fg)
    return e;
  if (ste(e)) {
    const r = e.toLowerCase();
    return r === "default" ? t : r === "local" || r === "system" ? p_.instance : r === "utc" || r === "gmt" ? Tn.utcInstance : Tn.parseSpecifier(r) || ol.create(e);
  } else
    return gd(e) ? Tn.instance(e) : typeof e == "object" && e.offset && typeof e.offset == "number" ? e : new ite(e);
}
let gA = () => Date.now(), vA = "system", bA = null, wA = null, _A = null, SA = 60, $A;
class Ir {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return gA;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(t) {
    gA = t;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(t) {
    vA = t;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return yu(vA, p_.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return bA;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(t) {
    bA = t;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return wA;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(t) {
    wA = t;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return _A;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(t) {
    _A = t;
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return SA;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
   */
  static set twoDigitCutoffYear(t) {
    SA = t % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return $A;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    $A = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Kt.resetCache(), ol.resetCache();
  }
}
function dt(e) {
  return typeof e > "u";
}
function gd(e) {
  return typeof e == "number";
}
function h_(e) {
  return typeof e == "number" && e % 1 === 0;
}
function ste(e) {
  return typeof e == "string";
}
function ote(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function hD() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function ate(e) {
  return Array.isArray(e) ? e : [e];
}
function xA(e, t, r) {
  if (e.length !== 0)
    return e.reduce((n, i) => {
      const s = [t(i), i];
      return n && r(n[0], s[0]) === n[0] ? n : s;
    }, null)[1];
}
function lte(e, t) {
  return t.reduce((r, n) => (r[n] = e[n], r), {});
}
function jh(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Za(e, t, r) {
  return h_(e) && e >= t && e <= r;
}
function ute(e, t) {
  return e - t * Math.floor(e / t);
}
function Mr(e, t = 2) {
  const r = e < 0;
  let n;
  return r ? n = "-" + ("" + -e).padStart(t, "0") : n = ("" + e).padStart(t, "0"), n;
}
function uu(e) {
  if (!(dt(e) || e === null || e === ""))
    return parseInt(e, 10);
}
function Xu(e) {
  if (!(dt(e) || e === null || e === ""))
    return parseFloat(e);
}
function kM(e) {
  if (!(dt(e) || e === null || e === "")) {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function AM(e, t, r = !1) {
  const n = 10 ** t;
  return (r ? Math.trunc : Math.round)(e * n) / n;
}
function Dg(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function vy(e) {
  return Dg(e) ? 366 : 365;
}
function Db(e, t) {
  const r = ute(t - 1, 12) + 1, n = e + (t - r) / 12;
  return r === 2 ? Dg(n) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1];
}
function PM(e) {
  let t = Date.UTC(
    e.year,
    e.month - 1,
    e.day,
    e.hour,
    e.minute,
    e.second,
    e.millisecond
  );
  return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(e.year, e.month - 1, e.day)), +t;
}
function jb(e) {
  const t = (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7, r = e - 1, n = (r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400)) % 7;
  return t === 4 || n === 3 ? 53 : 52;
}
function yx(e) {
  return e > 99 ? e : e > Ir.twoDigitCutoffYear ? 1900 + e : 2e3 + e;
}
function fD(e, t, r, n = null) {
  const i = new Date(e), s = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  n && (s.timeZone = n);
  const o = { timeZoneName: t, ...s }, a = new Intl.DateTimeFormat(r, o).formatToParts(i).find((l) => l.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function f_(e, t) {
  let r = parseInt(e, 10);
  Number.isNaN(r) && (r = 0);
  const n = parseInt(t, 10) || 0, i = r < 0 || Object.is(r, -0) ? -n : n;
  return r * 60 + i;
}
function mD(e) {
  const t = Number(e);
  if (typeof e == "boolean" || e === "" || Number.isNaN(t))
    throw new us(`Invalid unit value ${e}`);
  return t;
}
function Vb(e, t) {
  const r = {};
  for (const n in e)
    if (jh(e, n)) {
      const i = e[n];
      if (i == null)
        continue;
      r[t(n)] = mD(i);
    }
  return r;
}
function by(e, t) {
  const r = Math.trunc(Math.abs(e / 60)), n = Math.trunc(Math.abs(e % 60)), i = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${i}${Mr(r, 2)}:${Mr(n, 2)}`;
    case "narrow":
      return `${i}${r}${n > 0 ? `:${n}` : ""}`;
    case "techie":
      return `${i}${Mr(r, 2)}${Mr(n, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function m_(e) {
  return lte(e, ["hour", "minute", "second", "millisecond"]);
}
const cte = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], yD = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], dte = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function gD(e) {
  switch (e) {
    case "narrow":
      return [...dte];
    case "short":
      return [...yD];
    case "long":
      return [...cte];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const vD = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], bD = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], pte = ["M", "T", "W", "T", "F", "S", "S"];
function wD(e) {
  switch (e) {
    case "narrow":
      return [...pte];
    case "short":
      return [...bD];
    case "long":
      return [...vD];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const _D = ["AM", "PM"], hte = ["Before Christ", "Anno Domini"], fte = ["BC", "AD"], mte = ["B", "A"];
function SD(e) {
  switch (e) {
    case "narrow":
      return [...mte];
    case "short":
      return [...fte];
    case "long":
      return [...hte];
    default:
      return null;
  }
}
function yte(e) {
  return _D[e.hour < 12 ? 0 : 1];
}
function gte(e, t) {
  return wD(t)[e.weekday - 1];
}
function vte(e, t) {
  return gD(t)[e.month - 1];
}
function bte(e, t) {
  return SD(t)[e.year < 0 ? 0 : 1];
}
function wte(e, t, r = "always", n = !1) {
  const i = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, s = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (r === "auto" && s) {
    const f = e === "days";
    switch (t) {
      case 1:
        return f ? "tomorrow" : `next ${i[e][0]}`;
      case -1:
        return f ? "yesterday" : `last ${i[e][0]}`;
      case 0:
        return f ? "today" : `this ${i[e][0]}`;
    }
  }
  const o = Object.is(t, -0) || t < 0, a = Math.abs(t), l = a === 1, c = i[e], h = n ? l ? c[1] : c[2] || c[1] : l ? i[e][0] : e;
  return o ? `${a} ${h} ago` : `in ${a} ${h}`;
}
function TA(e, t) {
  let r = "";
  for (const n of e)
    n.literal ? r += n.val : r += t(n.val);
  return r;
}
const _te = {
  D: Fb,
  DD: J8,
  DDD: Z8,
  DDDD: K8,
  t: Y8,
  tt: Q8,
  ttt: X8,
  tttt: eD,
  T: tD,
  TT: rD,
  TTT: nD,
  TTTT: iD,
  f: sD,
  ff: aD,
  fff: uD,
  ffff: dD,
  F: oD,
  FF: lD,
  FFF: cD,
  FFFF: pD
};
class $n {
  static create(t, r = {}) {
    return new $n(t, r);
  }
  static parseFormat(t) {
    let r = null, n = "", i = !1;
    const s = [];
    for (let o = 0; o < t.length; o++) {
      const a = t.charAt(o);
      a === "'" ? (n.length > 0 && s.push({ literal: i || /^\s+$/.test(n), val: n }), r = null, n = "", i = !i) : i || a === r ? n += a : (n.length > 0 && s.push({ literal: /^\s+$/.test(n), val: n }), n = a, r = a);
    }
    return n.length > 0 && s.push({ literal: i || /^\s+$/.test(n), val: n }), s;
  }
  static macroTokenToFormatOpts(t) {
    return _te[t];
  }
  constructor(t, r) {
    this.opts = r, this.loc = t, this.systemLoc = null;
  }
  formatWithSystemDefault(t, r) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, { ...this.opts, ...r }).format();
  }
  formatDateTime(t, r = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...r }).format();
  }
  formatDateTimeParts(t, r = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...r }).formatToParts();
  }
  formatInterval(t, r = {}) {
    return this.loc.dtFormatter(t.start, { ...this.opts, ...r }).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate());
  }
  resolvedOptions(t, r = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...r }).resolvedOptions();
  }
  num(t, r = 0) {
    if (this.opts.forceSimple)
      return Mr(t, r);
    const n = { ...this.opts };
    return r > 0 && (n.padTo = r), this.loc.numberFormatter(n).format(t);
  }
  formatDateTimeFromString(t, r) {
    const n = this.loc.listingMode() === "en", i = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (y, g) => this.loc.extract(t, y, g), o = (y) => t.isOffsetFixed && t.offset === 0 && y.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, y.format) : "", a = () => n ? yte(t) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (y, g) => n ? vte(t, y) : s(g ? { month: y } : { month: y, day: "numeric" }, "month"), c = (y, g) => n ? gte(t, y) : s(
      g ? { weekday: y } : { weekday: y, month: "long", day: "numeric" },
      "weekday"
    ), h = (y) => {
      const g = $n.macroTokenToFormatOpts(y);
      return g ? this.formatWithSystemDefault(t, g) : y;
    }, f = (y) => n ? bte(t, y) : s({ era: y }, "era"), m = (y) => {
      switch (y) {
        case "S":
          return this.num(t.millisecond);
        case "u":
        case "SSS":
          return this.num(t.millisecond, 3);
        case "s":
          return this.num(t.second);
        case "ss":
          return this.num(t.second, 2);
        case "uu":
          return this.num(Math.floor(t.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t.millisecond / 100));
        case "m":
          return this.num(t.minute);
        case "mm":
          return this.num(t.minute, 2);
        case "h":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
        case "hh":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
        case "H":
          return this.num(t.hour);
        case "HH":
          return this.num(t.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return t.zoneName;
        case "a":
          return a();
        case "d":
          return i ? s({ day: "numeric" }, "day") : this.num(t.day);
        case "dd":
          return i ? s({ day: "2-digit" }, "day") : this.num(t.day, 2);
        case "c":
          return this.num(t.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        case "E":
          return this.num(t.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        case "L":
          return i ? s({ month: "numeric", day: "numeric" }, "month") : this.num(t.month);
        case "LL":
          return i ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return i ? s({ month: "numeric" }, "month") : this.num(t.month);
        case "MM":
          return i ? s({ month: "2-digit" }, "month") : this.num(t.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year);
        case "yy":
          return i ? s({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2);
        case "yyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year, 4);
        case "yyyyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(t.year, 6);
        case "G":
          return f("short");
        case "GG":
          return f("long");
        case "GGGGG":
          return f("narrow");
        case "kk":
          return this.num(t.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t.weekYear, 4);
        case "W":
          return this.num(t.weekNumber);
        case "WW":
          return this.num(t.weekNumber, 2);
        case "o":
          return this.num(t.ordinal);
        case "ooo":
          return this.num(t.ordinal, 3);
        case "q":
          return this.num(t.quarter);
        case "qq":
          return this.num(t.quarter, 2);
        case "X":
          return this.num(Math.floor(t.ts / 1e3));
        case "x":
          return this.num(t.ts);
        default:
          return h(y);
      }
    };
    return TA($n.parseFormat(r), m);
  }
  formatDurationFromString(t, r) {
    const n = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, i = (l) => (c) => {
      const h = n(c);
      return h ? this.num(l.get(h), c.length) : c;
    }, s = $n.parseFormat(r), o = s.reduce(
      (l, { literal: c, val: h }) => c ? l : l.concat(h),
      []
    ), a = t.shiftTo(...o.map(n).filter((l) => l));
    return TA(s, i(a));
  }
}
class so {
  constructor(t, r) {
    this.reason = t, this.explanation = r;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const $D = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function lf(...e) {
  const t = e.reduce((r, n) => r + n.source, "");
  return RegExp(`^${t}$`);
}
function uf(...e) {
  return (t) => e.reduce(
    ([r, n, i], s) => {
      const [o, a, l] = s(t, i);
      return [{ ...r, ...o }, a || n, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function cf(e, ...t) {
  if (e == null)
    return [null, null];
  for (const [r, n] of t) {
    const i = r.exec(e);
    if (i)
      return n(i);
  }
  return [null, null];
}
function xD(...e) {
  return (t, r) => {
    const n = {};
    let i;
    for (i = 0; i < e.length; i++)
      n[e[i]] = uu(t[r + i]);
    return [n, null, r + i];
  };
}
const TD = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, Ste = `(?:${TD.source}?(?:\\[(${$D.source})\\])?)?`, RM = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, ED = RegExp(`${RM.source}${Ste}`), LM = RegExp(`(?:T${ED.source})?`), $te = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, xte = /(\d{4})-?W(\d\d)(?:-?(\d))?/, Tte = /(\d{4})-?(\d{3})/, Ete = xD("weekYear", "weekNumber", "weekDay"), Ite = xD("year", "ordinal"), Mte = /(\d{4})-(\d\d)-(\d\d)/, ID = RegExp(
  `${RM.source} ?(?:${TD.source}|(${$D.source}))?`
), Ote = RegExp(`(?: ${ID.source})?`);
function bh(e, t, r) {
  const n = e[t];
  return dt(n) ? r : uu(n);
}
function Cte(e, t) {
  return [{
    year: bh(e, t),
    month: bh(e, t + 1, 1),
    day: bh(e, t + 2, 1)
  }, null, t + 3];
}
function df(e, t) {
  return [{
    hours: bh(e, t, 0),
    minutes: bh(e, t + 1, 0),
    seconds: bh(e, t + 2, 0),
    milliseconds: kM(e[t + 3])
  }, null, t + 4];
}
function jg(e, t) {
  const r = !e[t] && !e[t + 1], n = f_(e[t + 1], e[t + 2]), i = r ? null : Tn.instance(n);
  return [{}, i, t + 3];
}
function Vg(e, t) {
  const r = e[t] ? ol.create(e[t]) : null;
  return [{}, r, t + 1];
}
const kte = RegExp(`^T?${RM.source}$`), Ate = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Pte(e) {
  const [t, r, n, i, s, o, a, l, c] = e, h = t[0] === "-", f = l && l[0] === "-", m = (y, g = !1) => y !== void 0 && (g || y && h) ? -y : y;
  return [
    {
      years: m(Xu(r)),
      months: m(Xu(n)),
      weeks: m(Xu(i)),
      days: m(Xu(s)),
      hours: m(Xu(o)),
      minutes: m(Xu(a)),
      seconds: m(Xu(l), l === "-0"),
      milliseconds: m(kM(c), f)
    }
  ];
}
const Rte = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function NM(e, t, r, n, i, s, o) {
  const a = {
    year: t.length === 2 ? yx(uu(t)) : uu(t),
    month: yD.indexOf(r) + 1,
    day: uu(n),
    hour: uu(i),
    minute: uu(s)
  };
  return o && (a.second = uu(o)), e && (a.weekday = e.length > 3 ? vD.indexOf(e) + 1 : bD.indexOf(e) + 1), a;
}
const Lte = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function Nte(e) {
  const [
    ,
    t,
    r,
    n,
    i,
    s,
    o,
    a,
    l,
    c,
    h,
    f
  ] = e, m = NM(t, i, n, r, s, o, a);
  let y;
  return l ? y = Rte[l] : c ? y = 0 : y = f_(h, f), [m, new Tn(y)];
}
function Fte(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const Dte = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, jte = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Vte = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function EA(e) {
  const [, t, r, n, i, s, o, a] = e;
  return [NM(t, i, n, r, s, o, a), Tn.utcInstance];
}
function zte(e) {
  const [, t, r, n, i, s, o, a] = e;
  return [NM(t, a, r, n, i, s, o), Tn.utcInstance];
}
const Ute = lf($te, LM), Bte = lf(xte, LM), qte = lf(Tte, LM), Gte = lf(ED), MD = uf(
  Cte,
  df,
  jg,
  Vg
), Hte = uf(
  Ete,
  df,
  jg,
  Vg
), Wte = uf(
  Ite,
  df,
  jg,
  Vg
), Jte = uf(
  df,
  jg,
  Vg
);
function Zte(e) {
  return cf(
    e,
    [Ute, MD],
    [Bte, Hte],
    [qte, Wte],
    [Gte, Jte]
  );
}
function Kte(e) {
  return cf(Fte(e), [Lte, Nte]);
}
function Yte(e) {
  return cf(
    e,
    [Dte, EA],
    [jte, EA],
    [Vte, zte]
  );
}
function Qte(e) {
  return cf(e, [Ate, Pte]);
}
const Xte = uf(df);
function ere(e) {
  return cf(e, [kte, Xte]);
}
const tre = lf(Mte, Ote), rre = lf(ID), nre = uf(
  df,
  jg,
  Vg
);
function ire(e) {
  return cf(
    e,
    [tre, MD],
    [rre, nre]
  );
}
const sre = "Invalid Duration", OD = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, ore = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...OD
}, Gi = 146097 / 400, cp = 146097 / 4800, are = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Gi / 7,
    days: Gi,
    hours: Gi * 24,
    minutes: Gi * 24 * 60,
    seconds: Gi * 24 * 60 * 60,
    milliseconds: Gi * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Gi / 28,
    days: Gi / 4,
    hours: Gi * 24 / 4,
    minutes: Gi * 24 * 60 / 4,
    seconds: Gi * 24 * 60 * 60 / 4,
    milliseconds: Gi * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: cp / 7,
    days: cp,
    hours: cp * 24,
    minutes: cp * 24 * 60,
    seconds: cp * 24 * 60 * 60,
    milliseconds: cp * 24 * 60 * 60 * 1e3
  },
  ...OD
}, fc = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], lre = fc.slice(0).reverse();
function Tl(e, t, r = !1) {
  const n = {
    values: r ? t.values : { ...e.values, ...t.values || {} },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
    matrix: t.matrix || e.matrix
  };
  return new yt(n);
}
function ure(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function CD(e, t, r, n, i) {
  const s = e[i][r], o = t[r] / s, a = Math.sign(o) === Math.sign(n[i]), l = !a && n[i] !== 0 && Math.abs(o) <= 1 ? ure(o) : Math.trunc(o);
  n[i] += l, t[r] -= l * s;
}
function cre(e, t) {
  lre.reduce((r, n) => dt(t[n]) ? r : (r && CD(e, t, r, t, n), n), null);
}
function dre(e) {
  const t = {};
  for (const [r, n] of Object.entries(e))
    n !== 0 && (t[r] = n);
  return t;
}
class yt {
  /**
   * @private
   */
  constructor(t) {
    const r = t.conversionAccuracy === "longterm" || !1;
    let n = r ? are : ore;
    t.matrix && (n = t.matrix), this.values = t.values, this.loc = t.loc || Kt.create(), this.conversionAccuracy = r ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = n, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(t, r) {
    return yt.fromObject({ milliseconds: t }, r);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(t, r = {}) {
    if (t == null || typeof t != "object")
      throw new us(
        `Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`
      );
    return new yt({
      values: Vb(t, yt.normalizeUnit),
      loc: Kt.fromObject(r),
      conversionAccuracy: r.conversionAccuracy,
      matrix: r.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(t) {
    if (gd(t))
      return yt.fromMillis(t);
    if (yt.isDuration(t))
      return t;
    if (typeof t == "object")
      return yt.fromObject(t);
    throw new us(
      `Unknown duration argument ${t} of type ${typeof t}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(t, r) {
    const [n] = Qte(t);
    return n ? yt.fromObject(n, r) : yt.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(t, r) {
    const [n] = ere(t);
    return n ? yt.fromObject(n, r) : yt.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(t, r = null) {
    if (!t)
      throw new us("need to specify a reason the Duration is invalid");
    const n = t instanceof so ? t : new so(t, r);
    if (Ir.throwOnInvalid)
      throw new jee(n);
    return new yt({ invalid: n });
  }
  /**
   * @private
   */
  static normalizeUnit(t) {
    const r = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[t && t.toLowerCase()];
    if (!r)
      throw new W8(t);
    return r;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(t) {
    return t && t.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(t, r = {}) {
    const n = {
      ...r,
      floor: r.round !== !1 && r.floor !== !1
    };
    return this.isValid ? $n.create(this.loc, n).formatDurationFromString(this, t) : sre;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(t = {}) {
    const r = fc.map((n) => {
      const i = this.values[n];
      return dt(i) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...t, unit: n.slice(0, -1) }).format(i);
    }).filter((n) => n);
    return this.loc.listFormatter({ type: "conjunction", style: t.listStyle || "narrow", ...t }).format(r);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let t = "P";
    return this.years !== 0 && (t += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (t += this.weeks + "W"), this.days !== 0 && (t += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"), this.hours !== 0 && (t += this.hours + "H"), this.minutes !== 0 && (t += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (t += AM(this.seconds + this.milliseconds / 1e3, 3) + "S"), t === "P" && (t += "T0S"), t;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(t = {}) {
    if (!this.isValid)
      return null;
    const r = this.toMillis();
    if (r < 0 || r >= 864e5)
      return null;
    t = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...t
    };
    const n = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let i = t.format === "basic" ? "hhmm" : "hh:mm";
    (!t.suppressSeconds || n.seconds !== 0 || n.milliseconds !== 0) && (i += t.format === "basic" ? "ss" : ":ss", (!t.suppressMilliseconds || n.milliseconds !== 0) && (i += ".SSS"));
    let s = n.toFormat(i);
    return t.includePrefix && (s = "T" + s), s;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const r = yt.fromDurationLike(t), n = {};
    for (const i of fc)
      (jh(r.values, i) || jh(this.values, i)) && (n[i] = r.get(i) + this.get(i));
    return Tl(this, { values: n }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const r = yt.fromDurationLike(t);
    return this.plus(r.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(t) {
    if (!this.isValid)
      return this;
    const r = {};
    for (const n of Object.keys(this.values))
      r[n] = mD(t(this.values[n], n));
    return Tl(this, { values: r }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(t) {
    return this[yt.normalizeUnit(t)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const r = { ...this.values, ...Vb(t, yt.normalizeUnit) };
    return Tl(this, { values: r });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: t, numberingSystem: r, conversionAccuracy: n, matrix: i } = {}) {
    const o = { loc: this.loc.clone({ locale: t, numberingSystem: r }), matrix: i, conversionAccuracy: n };
    return Tl(this, o);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(t) {
    return this.isValid ? this.shiftTo(t).get(t) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const t = this.toObject();
    return cre(this.matrix, t), Tl(this, { values: t }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const t = dre(this.normalize().shiftToAll().toObject());
    return Tl(this, { values: t }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...t) {
    if (!this.isValid)
      return this;
    if (t.length === 0)
      return this;
    t = t.map((o) => yt.normalizeUnit(o));
    const r = {}, n = {}, i = this.toObject();
    let s;
    for (const o of fc)
      if (t.indexOf(o) >= 0) {
        s = o;
        let a = 0;
        for (const c in n)
          a += this.matrix[c][o] * n[c], n[c] = 0;
        gd(i[o]) && (a += i[o]);
        const l = Math.trunc(a);
        r[o] = l, n[o] = (a * 1e3 - l * 1e3) / 1e3;
        for (const c in i)
          fc.indexOf(c) > fc.indexOf(o) && CD(this.matrix, i, c, r, o);
      } else
        gd(i[o]) && (n[o] = i[o]);
    for (const o in n)
      n[o] !== 0 && (r[s] += o === s ? n[o] : n[o] / this.matrix[s][o]);
    return Tl(this, { values: r }, !0).normalize();
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const t = {};
    for (const r of Object.keys(this.values))
      t[r] = this.values[r] === 0 ? 0 : -this.values[r];
    return Tl(this, { values: t }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(t) {
    if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
      return !1;
    function r(n, i) {
      return n === void 0 || n === 0 ? i === void 0 || i === 0 : n === i;
    }
    for (const n of fc)
      if (!r(this.values[n], t.values[n]))
        return !1;
    return !0;
  }
}
const dp = "Invalid Interval";
function pre(e, t) {
  return !e || !e.isValid ? mr.invalid("missing or invalid start") : !t || !t.isValid ? mr.invalid("missing or invalid end") : t < e ? mr.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`
  ) : null;
}
class mr {
  /**
   * @private
   */
  constructor(t) {
    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(t, r = null) {
    if (!t)
      throw new us("need to specify a reason the Interval is invalid");
    const n = t instanceof so ? t : new so(t, r);
    if (Ir.throwOnInvalid)
      throw new Dee(n);
    return new mr({ invalid: n });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(t, r) {
    const n = zf(t), i = zf(r), s = pre(n, i);
    return s ?? new mr({
      start: n,
      end: i
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(t, r) {
    const n = yt.fromDurationLike(r), i = zf(t);
    return mr.fromDateTimes(i, i.plus(n));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(t, r) {
    const n = yt.fromDurationLike(r), i = zf(t);
    return mr.fromDateTimes(i.minus(n), i);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(t, r) {
    const [n, i] = (t || "").split("/", 2);
    if (n && i) {
      let s, o;
      try {
        s = We.fromISO(n, r), o = s.isValid;
      } catch {
        o = !1;
      }
      let a, l;
      try {
        a = We.fromISO(i, r), l = a.isValid;
      } catch {
        l = !1;
      }
      if (o && l)
        return mr.fromDateTimes(s, a);
      if (o) {
        const c = yt.fromISO(i, r);
        if (c.isValid)
          return mr.after(s, c);
      } else if (l) {
        const c = yt.fromISO(n, r);
        if (c.isValid)
          return mr.before(a, c);
      }
    }
    return mr.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(t) {
    return t && t.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(t = "milliseconds") {
    return this.isValid ? this.toDuration(t).get(t) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(t = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const r = this.start.startOf(t), n = this.end.startOf(t);
    return Math.floor(n.diff(r, t).get(t)) + (n.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(t) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(t) {
    return this.isValid ? this.s > t : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(t) {
    return this.isValid ? this.e <= t : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(t) {
    return this.isValid ? this.s <= t && this.e > t : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: t, end: r } = {}) {
    return this.isValid ? mr.fromDateTimes(t || this.s, r || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...t) {
    if (!this.isValid)
      return [];
    const r = t.map(zf).filter((o) => this.contains(o)).sort(), n = [];
    let { s: i } = this, s = 0;
    for (; i < this.e; ) {
      const o = r[s] || this.e, a = +o > +this.e ? this.e : o;
      n.push(mr.fromDateTimes(i, a)), i = a, s += 1;
    }
    return n;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(t) {
    const r = yt.fromDurationLike(t);
    if (!this.isValid || !r.isValid || r.as("milliseconds") === 0)
      return [];
    let { s: n } = this, i = 1, s;
    const o = [];
    for (; n < this.e; ) {
      const a = this.start.plus(r.mapUnits((l) => l * i));
      s = +a > +this.e ? this.e : a, o.push(mr.fromDateTimes(n, s)), n = s, i += 1;
    }
    return o;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(t) {
    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(t) {
    return this.e > t.s && this.s < t.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(t) {
    return this.isValid ? +this.e == +t.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(t) {
    return this.isValid ? +t.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(t) {
    return this.isValid ? this.s <= t.s && this.e >= t.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(t) {
    return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(t) {
    if (!this.isValid)
      return this;
    const r = this.s > t.s ? this.s : t.s, n = this.e < t.e ? this.e : t.e;
    return r >= n ? null : mr.fromDateTimes(r, n);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(t) {
    if (!this.isValid)
      return this;
    const r = this.s < t.s ? this.s : t.s, n = this.e > t.e ? this.e : t.e;
    return mr.fromDateTimes(r, n);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(t) {
    const [r, n] = t.sort((i, s) => i.s - s.s).reduce(
      ([i, s], o) => s ? s.overlaps(o) || s.abutsStart(o) ? [i, s.union(o)] : [i.concat([s]), o] : [i, o],
      [[], null]
    );
    return n && r.push(n), r;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(t) {
    let r = null, n = 0;
    const i = [], s = t.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), o = Array.prototype.concat(...s), a = o.sort((l, c) => l.time - c.time);
    for (const l of a)
      n += l.type === "s" ? 1 : -1, n === 1 ? r = l.time : (r && +r != +l.time && i.push(mr.fromDateTimes(r, l.time)), r = null);
    return mr.merge(i);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...t) {
    return mr.xor([this].concat(t)).map((r) => this.intersection(r)).filter((r) => r && !r.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : dp;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(t = Fb, r = {}) {
    return this.isValid ? $n.create(this.s.loc.clone(r), t).formatInterval(this) : dp;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(t) {
    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : dp;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : dp;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(t) {
    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : dp;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(t, { separator: r = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(t)}${r}${this.e.toFormat(t)}` : dp;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(t, r) {
    return this.isValid ? this.e.diff(this.s, t, r) : yt.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(t) {
    return mr.fromDateTimes(t(this.s), t(this.e));
  }
}
class P0 {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(t = Ir.defaultZone) {
    const r = We.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && r.offset !== r.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(t) {
    return ol.isValidZone(t);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(t) {
    return yu(t, Ir.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(t = "long", { locale: r = null, numberingSystem: n = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || Kt.create(r, n, s)).months(t);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(t = "long", { locale: r = null, numberingSystem: n = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || Kt.create(r, n, s)).months(t, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(t = "long", { locale: r = null, numberingSystem: n = null, locObj: i = null } = {}) {
    return (i || Kt.create(r, n, null)).weekdays(t);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(t = "long", { locale: r = null, numberingSystem: n = null, locObj: i = null } = {}) {
    return (i || Kt.create(r, n, null)).weekdays(t, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: t = null } = {}) {
    return Kt.create(t).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(t = "short", { locale: r = null } = {}) {
    return Kt.create(r, null, "gregory").eras(t);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hD() };
  }
}
function IA(e, t) {
  const r = (i) => i.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), n = r(t) - r(e);
  return Math.floor(yt.fromMillis(n).as("days"));
}
function hre(e, t, r) {
  const n = [
    ["years", (l, c) => c.year - l.year],
    ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4],
    ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12],
    [
      "weeks",
      (l, c) => {
        const h = IA(l, c);
        return (h - h % 7) / 7;
      }
    ],
    ["days", IA]
  ], i = {}, s = e;
  let o, a;
  for (const [l, c] of n)
    r.indexOf(l) >= 0 && (o = l, i[l] = c(e, t), a = s.plus(i), a > t ? (i[l]--, e = s.plus(i)) : e = a);
  return [e, i, a, o];
}
function fre(e, t, r, n) {
  let [i, s, o, a] = hre(e, t, r);
  const l = t - i, c = r.filter(
    (f) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(f) >= 0
  );
  c.length === 0 && (o < t && (o = i.plus({ [a]: 1 })), o !== i && (s[a] = (s[a] || 0) + l / (o - i)));
  const h = yt.fromObject(s, n);
  return c.length > 0 ? yt.fromMillis(l, n).shiftTo(...c).plus(h) : h;
}
const FM = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, MA = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, mre = FM.hanidec.replace(/[\[|\]]/g, "").split("");
function yre(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let r = 0; r < e.length; r++) {
      const n = e.charCodeAt(r);
      if (e[r].search(FM.hanidec) !== -1)
        t += mre.indexOf(e[r]);
      else
        for (const i in MA) {
          const [s, o] = MA[i];
          n >= s && n <= o && (t += n - s);
        }
    }
    return parseInt(t, 10);
  } else
    return t;
}
function Os({ numberingSystem: e }, t = "") {
  return new RegExp(`${FM[e || "latn"]}${t}`);
}
const gre = "missing Intl.DateTimeFormat.formatToParts support";
function _t(e, t = (r) => r) {
  return { regex: e, deser: ([r]) => t(yre(r)) };
}
const vre = " ", kD = `[ ${vre}]`, AD = new RegExp(kD, "g");
function bre(e) {
  return e.replace(/\./g, "\\.?").replace(AD, kD);
}
function OA(e) {
  return e.replace(/\./g, "").replace(AD, " ").toLowerCase();
}
function Cs(e, t) {
  return e === null ? null : {
    regex: RegExp(e.map(bre).join("|")),
    deser: ([r]) => e.findIndex((n) => OA(r) === OA(n)) + t
  };
}
function CA(e, t) {
  return { regex: e, deser: ([, r, n]) => f_(r, n), groups: t };
}
function R0(e) {
  return { regex: e, deser: ([t]) => t };
}
function wre(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function _re(e, t) {
  const r = Os(t), n = Os(t, "{2}"), i = Os(t, "{3}"), s = Os(t, "{4}"), o = Os(t, "{6}"), a = Os(t, "{1,2}"), l = Os(t, "{1,3}"), c = Os(t, "{1,6}"), h = Os(t, "{1,9}"), f = Os(t, "{2,4}"), m = Os(t, "{4,6}"), y = (b) => ({ regex: RegExp(wre(b.val)), deser: ([w]) => w, literal: !0 }), v = ((b) => {
    if (e.literal)
      return y(b);
    switch (b.val) {
      case "G":
        return Cs(t.eras("short", !1), 0);
      case "GG":
        return Cs(t.eras("long", !1), 0);
      case "y":
        return _t(c);
      case "yy":
        return _t(f, yx);
      case "yyyy":
        return _t(s);
      case "yyyyy":
        return _t(m);
      case "yyyyyy":
        return _t(o);
      case "M":
        return _t(a);
      case "MM":
        return _t(n);
      case "MMM":
        return Cs(t.months("short", !0, !1), 1);
      case "MMMM":
        return Cs(t.months("long", !0, !1), 1);
      case "L":
        return _t(a);
      case "LL":
        return _t(n);
      case "LLL":
        return Cs(t.months("short", !1, !1), 1);
      case "LLLL":
        return Cs(t.months("long", !1, !1), 1);
      case "d":
        return _t(a);
      case "dd":
        return _t(n);
      case "o":
        return _t(l);
      case "ooo":
        return _t(i);
      case "HH":
        return _t(n);
      case "H":
        return _t(a);
      case "hh":
        return _t(n);
      case "h":
        return _t(a);
      case "mm":
        return _t(n);
      case "m":
        return _t(a);
      case "q":
        return _t(a);
      case "qq":
        return _t(n);
      case "s":
        return _t(a);
      case "ss":
        return _t(n);
      case "S":
        return _t(l);
      case "SSS":
        return _t(i);
      case "u":
        return R0(h);
      case "uu":
        return R0(a);
      case "uuu":
        return _t(r);
      case "a":
        return Cs(t.meridiems(), 0);
      case "kkkk":
        return _t(s);
      case "kk":
        return _t(f, yx);
      case "W":
        return _t(a);
      case "WW":
        return _t(n);
      case "E":
      case "c":
        return _t(r);
      case "EEE":
        return Cs(t.weekdays("short", !1, !1), 1);
      case "EEEE":
        return Cs(t.weekdays("long", !1, !1), 1);
      case "ccc":
        return Cs(t.weekdays("short", !0, !1), 1);
      case "cccc":
        return Cs(t.weekdays("long", !0, !1), 1);
      case "Z":
      case "ZZ":
        return CA(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
      case "ZZZ":
        return CA(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
      case "z":
        return R0(/[a-z_+-/]{1,256}?/i);
      case " ":
        return R0(/[^\S\n\r]/);
      default:
        return y(b);
    }
  })(e) || {
    invalidReason: gre
  };
  return v.token = e, v;
}
const Sre = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function $re(e, t) {
  const { type: r, value: n } = e;
  if (r === "literal") {
    const o = /^\s+$/.test(n);
    return {
      literal: !o,
      val: o ? " " : n
    };
  }
  const i = t[r];
  let s = Sre[r];
  if (typeof s == "object" && (s = s[i]), s)
    return {
      literal: !1,
      val: s
    };
}
function xre(e) {
  return [`^${e.map((r) => r.regex).reduce((r, n) => `${r}(${n.source})`, "")}$`, e];
}
function Tre(e, t, r) {
  const n = e.match(t);
  if (n) {
    const i = {};
    let s = 1;
    for (const o in r)
      if (jh(r, o)) {
        const a = r[o], l = a.groups ? a.groups + 1 : 1;
        !a.literal && a.token && (i[a.token.val[0]] = a.deser(n.slice(s, s + l))), s += l;
      }
    return [n, i];
  } else
    return [n, {}];
}
function Ere(e) {
  const t = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let r = null, n;
  return dt(e.z) || (r = ol.create(e.z)), dt(e.Z) || (r || (r = new Tn(e.Z)), n = e.Z), dt(e.q) || (e.M = (e.q - 1) * 3 + 1), dt(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), dt(e.u) || (e.S = kM(e.u)), [Object.keys(e).reduce((s, o) => {
    const a = t(o);
    return a && (s[a] = e[o]), s;
  }, {}), r, n];
}
let H2 = null;
function Ire() {
  return H2 || (H2 = We.fromMillis(1555555555555)), H2;
}
function Mre(e, t) {
  if (e.literal)
    return e;
  const r = $n.macroTokenToFormatOpts(e.val), n = LD(r, t);
  return n == null || n.includes(void 0) ? e : n;
}
function PD(e, t) {
  return Array.prototype.concat(...e.map((r) => Mre(r, t)));
}
function RD(e, t, r) {
  const n = PD($n.parseFormat(r), e), i = n.map((o) => _re(o, e)), s = i.find((o) => o.invalidReason);
  if (s)
    return { input: t, tokens: n, invalidReason: s.invalidReason };
  {
    const [o, a] = xre(i), l = RegExp(o, "i"), [c, h] = Tre(t, l, a), [f, m, y] = h ? Ere(h) : [null, null, void 0];
    if (jh(h, "a") && jh(h, "H"))
      throw new mm(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: t, tokens: n, regex: l, rawMatches: c, matches: h, result: f, zone: m, specificOffset: y };
  }
}
function Ore(e, t, r) {
  const { result: n, zone: i, specificOffset: s, invalidReason: o } = RD(e, t, r);
  return [n, i, s, o];
}
function LD(e, t) {
  return e ? $n.create(t, e).formatDateTimeParts(Ire()).map((i) => $re(i, e)) : null;
}
const ND = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], FD = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function ds(e, t) {
  return new so(
    "unit out of range",
    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`
  );
}
function DD(e, t, r) {
  const n = new Date(Date.UTC(e, t - 1, r));
  e < 100 && e >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
  const i = n.getUTCDay();
  return i === 0 ? 7 : i;
}
function jD(e, t, r) {
  return r + (Dg(e) ? FD : ND)[t - 1];
}
function VD(e, t) {
  const r = Dg(e) ? FD : ND, n = r.findIndex((s) => s < t), i = t - r[n];
  return { month: n + 1, day: i };
}
function gx(e) {
  const { year: t, month: r, day: n } = e, i = jD(t, r, n), s = DD(t, r, n);
  let o = Math.floor((i - s + 10) / 7), a;
  return o < 1 ? (a = t - 1, o = jb(a)) : o > jb(t) ? (a = t + 1, o = 1) : a = t, { weekYear: a, weekNumber: o, weekday: s, ...m_(e) };
}
function kA(e) {
  const { weekYear: t, weekNumber: r, weekday: n } = e, i = DD(t, 1, 4), s = vy(t);
  let o = r * 7 + n - i - 3, a;
  o < 1 ? (a = t - 1, o += vy(a)) : o > s ? (a = t + 1, o -= vy(t)) : a = t;
  const { month: l, day: c } = VD(a, o);
  return { year: a, month: l, day: c, ...m_(e) };
}
function W2(e) {
  const { year: t, month: r, day: n } = e, i = jD(t, r, n);
  return { year: t, ordinal: i, ...m_(e) };
}
function AA(e) {
  const { year: t, ordinal: r } = e, { month: n, day: i } = VD(t, r);
  return { year: t, month: n, day: i, ...m_(e) };
}
function Cre(e) {
  const t = h_(e.weekYear), r = Za(e.weekNumber, 1, jb(e.weekYear)), n = Za(e.weekday, 1, 7);
  return t ? r ? n ? !1 : ds("weekday", e.weekday) : ds("week", e.week) : ds("weekYear", e.weekYear);
}
function kre(e) {
  const t = h_(e.year), r = Za(e.ordinal, 1, vy(e.year));
  return t ? r ? !1 : ds("ordinal", e.ordinal) : ds("year", e.year);
}
function zD(e) {
  const t = h_(e.year), r = Za(e.month, 1, 12), n = Za(e.day, 1, Db(e.year, e.month));
  return t ? r ? n ? !1 : ds("day", e.day) : ds("month", e.month) : ds("year", e.year);
}
function UD(e) {
  const { hour: t, minute: r, second: n, millisecond: i } = e, s = Za(t, 0, 23) || t === 24 && r === 0 && n === 0 && i === 0, o = Za(r, 0, 59), a = Za(n, 0, 59), l = Za(i, 0, 999);
  return s ? o ? a ? l ? !1 : ds("millisecond", i) : ds("second", n) : ds("minute", r) : ds("hour", t);
}
const J2 = "Invalid DateTime", PA = 864e13;
function L0(e) {
  return new so("unsupported zone", `the zone "${e.name}" is not supported`);
}
function Z2(e) {
  return e.weekData === null && (e.weekData = gx(e.c)), e.weekData;
}
function jf(e, t) {
  const r = {
    ts: e.ts,
    zone: e.zone,
    c: e.c,
    o: e.o,
    loc: e.loc,
    invalid: e.invalid
  };
  return new We({ ...r, ...t, old: r });
}
function BD(e, t, r) {
  let n = e - t * 60 * 1e3;
  const i = r.offset(n);
  if (t === i)
    return [n, t];
  n -= (i - t) * 60 * 1e3;
  const s = r.offset(n);
  return i === s ? [n, i] : [e - Math.min(i, s) * 60 * 1e3, Math.max(i, s)];
}
function RA(e, t) {
  e += t * 60 * 1e3;
  const r = new Date(e);
  return {
    year: r.getUTCFullYear(),
    month: r.getUTCMonth() + 1,
    day: r.getUTCDate(),
    hour: r.getUTCHours(),
    minute: r.getUTCMinutes(),
    second: r.getUTCSeconds(),
    millisecond: r.getUTCMilliseconds()
  };
}
function Kv(e, t, r) {
  return BD(PM(e), t, r);
}
function LA(e, t) {
  const r = e.o, n = e.c.year + Math.trunc(t.years), i = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3, s = {
    ...e.c,
    year: n,
    month: i,
    day: Math.min(e.c.day, Db(n, i)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
  }, o = yt.fromObject({
    years: t.years - Math.trunc(t.years),
    quarters: t.quarters - Math.trunc(t.quarters),
    months: t.months - Math.trunc(t.months),
    weeks: t.weeks - Math.trunc(t.weeks),
    days: t.days - Math.trunc(t.days),
    hours: t.hours,
    minutes: t.minutes,
    seconds: t.seconds,
    milliseconds: t.milliseconds
  }).as("milliseconds"), a = PM(s);
  let [l, c] = BD(a, r, e.zone);
  return o !== 0 && (l += o, c = e.zone.offset(l)), { ts: l, o: c };
}
function Vf(e, t, r, n, i, s) {
  const { setZone: o, zone: a } = r;
  if (e && Object.keys(e).length !== 0 || t) {
    const l = t || a, c = We.fromObject(e, {
      ...r,
      zone: l,
      specificOffset: s
    });
    return o ? c : c.setZone(a);
  } else
    return We.invalid(
      new so("unparsable", `the input "${i}" can't be parsed as ${n}`)
    );
}
function N0(e, t, r = !0) {
  return e.isValid ? $n.create(Kt.create("en-US"), {
    allowZ: r,
    forceSimple: !0
  }).formatDateTimeFromString(e, t) : null;
}
function K2(e, t) {
  const r = e.c.year > 9999 || e.c.year < 0;
  let n = "";
  return r && e.c.year >= 0 && (n += "+"), n += Mr(e.c.year, r ? 6 : 4), t ? (n += "-", n += Mr(e.c.month), n += "-", n += Mr(e.c.day)) : (n += Mr(e.c.month), n += Mr(e.c.day)), n;
}
function NA(e, t, r, n, i, s) {
  let o = Mr(e.c.hour);
  return t ? (o += ":", o += Mr(e.c.minute), (e.c.second !== 0 || !r) && (o += ":")) : o += Mr(e.c.minute), (e.c.second !== 0 || !r) && (o += Mr(e.c.second), (e.c.millisecond !== 0 || !n) && (o += ".", o += Mr(e.c.millisecond, 3))), i && (e.isOffsetFixed && e.offset === 0 && !s ? o += "Z" : e.o < 0 ? (o += "-", o += Mr(Math.trunc(-e.o / 60)), o += ":", o += Mr(Math.trunc(-e.o % 60))) : (o += "+", o += Mr(Math.trunc(e.o / 60)), o += ":", o += Mr(Math.trunc(e.o % 60)))), s && (o += "[" + e.zone.ianaName + "]"), o;
}
const qD = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Are = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Pre = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, GD = ["year", "month", "day", "hour", "minute", "second", "millisecond"], Rre = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], Lre = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function FA(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[e.toLowerCase()];
  if (!t)
    throw new W8(e);
  return t;
}
function DA(e, t) {
  const r = yu(t.zone, Ir.defaultZone), n = Kt.fromObject(t), i = Ir.now();
  let s, o;
  if (dt(e.year))
    s = i;
  else {
    for (const c of GD)
      dt(e[c]) && (e[c] = qD[c]);
    const a = zD(e) || UD(e);
    if (a)
      return We.invalid(a);
    const l = r.offset(i);
    [s, o] = Kv(e, l, r);
  }
  return new We({ ts: s, zone: r, loc: n, o });
}
function jA(e, t, r) {
  const n = dt(r.round) ? !0 : r.round, i = (o, a) => (o = AM(o, n || r.calendary ? 0 : 2, !0), t.loc.clone(r).relFormatter(r).format(o, a)), s = (o) => r.calendary ? t.hasSame(e, o) ? 0 : t.startOf(o).diff(e.startOf(o), o).get(o) : t.diff(e, o).get(o);
  if (r.unit)
    return i(s(r.unit), r.unit);
  for (const o of r.units) {
    const a = s(o);
    if (Math.abs(a) >= 1)
      return i(a, o);
  }
  return i(e > t ? -0 : 0, r.units[r.units.length - 1]);
}
function VA(e) {
  let t = {}, r;
  return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1], r = Array.from(e).slice(0, e.length - 1)) : r = Array.from(e), [t, r];
}
class We {
  /**
   * @access private
   */
  constructor(t) {
    const r = t.zone || Ir.defaultZone;
    let n = t.invalid || (Number.isNaN(t.ts) ? new so("invalid input") : null) || (r.isValid ? null : L0(r));
    this.ts = dt(t.ts) ? Ir.now() : t.ts;
    let i = null, s = null;
    if (!n)
      if (t.old && t.old.ts === this.ts && t.old.zone.equals(r))
        [i, s] = [t.old.c, t.old.o];
      else {
        const a = r.offset(this.ts);
        i = RA(this.ts, a), n = Number.isNaN(i.year) ? new so("invalid input") : null, i = n ? null : i, s = n ? null : a;
      }
    this._zone = r, this.loc = t.loc || Kt.create(), this.invalid = n, this.weekData = null, this.c = i, this.o = s, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new We({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [t, r] = VA(arguments), [n, i, s, o, a, l, c] = r;
    return DA({ year: n, month: i, day: s, hour: o, minute: a, second: l, millisecond: c }, t);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [t, r] = VA(arguments), [n, i, s, o, a, l, c] = r;
    return t.zone = Tn.utcInstance, DA({ year: n, month: i, day: s, hour: o, minute: a, second: l, millisecond: c }, t);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(t, r = {}) {
    const n = ote(t) ? t.valueOf() : NaN;
    if (Number.isNaN(n))
      return We.invalid("invalid input");
    const i = yu(r.zone, Ir.defaultZone);
    return i.isValid ? new We({
      ts: n,
      zone: i,
      loc: Kt.fromObject(r)
    }) : We.invalid(L0(i));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(t, r = {}) {
    if (gd(t))
      return t < -PA || t > PA ? We.invalid("Timestamp out of range") : new We({
        ts: t,
        zone: yu(r.zone, Ir.defaultZone),
        loc: Kt.fromObject(r)
      });
    throw new us(
      `fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(t, r = {}) {
    if (gd(t))
      return new We({
        ts: t * 1e3,
        zone: yu(r.zone, Ir.defaultZone),
        loc: Kt.fromObject(r)
      });
    throw new us("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(t, r = {}) {
    t = t || {};
    const n = yu(r.zone, Ir.defaultZone);
    if (!n.isValid)
      return We.invalid(L0(n));
    const i = Ir.now(), s = dt(r.specificOffset) ? n.offset(i) : r.specificOffset, o = Vb(t, FA), a = !dt(o.ordinal), l = !dt(o.year), c = !dt(o.month) || !dt(o.day), h = l || c, f = o.weekYear || o.weekNumber, m = Kt.fromObject(r);
    if ((h || a) && f)
      throw new mm(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && a)
      throw new mm("Can't mix ordinal dates with month/day");
    const y = f || o.weekday && !h;
    let g, v, b = RA(i, s);
    y ? (g = Rre, v = Are, b = gx(b)) : a ? (g = Lre, v = Pre, b = W2(b)) : (g = GD, v = qD);
    let w = !1;
    for (const M of g) {
      const L = o[M];
      dt(L) ? w ? o[M] = v[M] : o[M] = b[M] : w = !0;
    }
    const x = y ? Cre(o) : a ? kre(o) : zD(o), $ = x || UD(o);
    if ($)
      return We.invalid($);
    const T = y ? kA(o) : a ? AA(o) : o, [C, I] = Kv(T, s, n), O = new We({
      ts: C,
      zone: n,
      o: I,
      loc: m
    });
    return o.weekday && h && t.weekday !== O.weekday ? We.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${O.toISO()}`
    ) : O;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(t, r = {}) {
    const [n, i] = Zte(t);
    return Vf(n, i, r, "ISO 8601", t);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(t, r = {}) {
    const [n, i] = Kte(t);
    return Vf(n, i, r, "RFC 2822", t);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(t, r = {}) {
    const [n, i] = Yte(t);
    return Vf(n, i, r, "HTTP", r);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(t, r, n = {}) {
    if (dt(t) || dt(r))
      throw new us("fromFormat requires an input string and a format");
    const { locale: i = null, numberingSystem: s = null } = n, o = Kt.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    }), [a, l, c, h] = Ore(o, t, r);
    return h ? We.invalid(h) : Vf(a, l, n, `format ${r}`, t, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(t, r, n = {}) {
    return We.fromFormat(t, r, n);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(t, r = {}) {
    const [n, i] = ire(t);
    return Vf(n, i, r, "SQL", t);
  }
  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(t, r = null) {
    if (!t)
      throw new us("need to specify a reason the DateTime is invalid");
    const n = t instanceof so ? t : new so(t, r);
    if (Ir.throwOnInvalid)
      throw new Fee(n);
    return new We({ invalid: n });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(t) {
    return t && t.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(t, r = {}) {
    const n = LD(t, Kt.fromObject(r));
    return n ? n.map((i) => i ? i.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(t, r = {}) {
    return PD($n.parseFormat(t), Kt.fromObject(r)).map((i) => i.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(t) {
    return this[t];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? Z2(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? Z2(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? Z2(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? W2(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? P0.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? P0.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? P0.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? P0.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Dg(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return Db(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? vy(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? jb(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(t = {}) {
    const { locale: r, numberingSystem: n, calendar: i } = $n.create(
      this.loc.clone(t),
      t
    ).resolvedOptions(this);
    return { locale: r, numberingSystem: n, outputCalendar: i };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(t = 0, r = {}) {
    return this.setZone(Tn.instance(t), r);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Ir.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(t, { keepLocalTime: r = !1, keepCalendarTime: n = !1 } = {}) {
    if (t = yu(t, Ir.defaultZone), t.equals(this.zone))
      return this;
    if (t.isValid) {
      let i = this.ts;
      if (r || n) {
        const s = t.offset(this.ts), o = this.toObject();
        [i] = Kv(o, s, t);
      }
      return jf(this, { ts: i, zone: t });
    } else
      return We.invalid(L0(t));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: t, numberingSystem: r, outputCalendar: n } = {}) {
    const i = this.loc.clone({ locale: t, numberingSystem: r, outputCalendar: n });
    return jf(this, { loc: i });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(t) {
    return this.reconfigure({ locale: t });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(t) {
    if (!this.isValid)
      return this;
    const r = Vb(t, FA), n = !dt(r.weekYear) || !dt(r.weekNumber) || !dt(r.weekday), i = !dt(r.ordinal), s = !dt(r.year), o = !dt(r.month) || !dt(r.day), a = s || o, l = r.weekYear || r.weekNumber;
    if ((a || i) && l)
      throw new mm(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (o && i)
      throw new mm("Can't mix ordinal dates with month/day");
    let c;
    n ? c = kA({ ...gx(this.c), ...r }) : dt(r.ordinal) ? (c = { ...this.toObject(), ...r }, dt(r.day) && (c.day = Math.min(Db(c.year, c.month), c.day))) : c = AA({ ...W2(this.c), ...r });
    const [h, f] = Kv(c, this.o, this.zone);
    return jf(this, { ts: h, o: f });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(t) {
    if (!this.isValid)
      return this;
    const r = yt.fromDurationLike(t);
    return jf(this, LA(this, r));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(t) {
    if (!this.isValid)
      return this;
    const r = yt.fromDurationLike(t).negate();
    return jf(this, LA(this, r));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(t) {
    if (!this.isValid)
      return this;
    const r = {}, n = yt.normalizeUnit(t);
    switch (n) {
      case "years":
        r.month = 1;
      case "quarters":
      case "months":
        r.day = 1;
      case "weeks":
      case "days":
        r.hour = 0;
      case "hours":
        r.minute = 0;
      case "minutes":
        r.second = 0;
      case "seconds":
        r.millisecond = 0;
        break;
    }
    if (n === "weeks" && (r.weekday = 1), n === "quarters") {
      const i = Math.ceil(this.month / 3);
      r.month = (i - 1) * 3 + 1;
    }
    return this.set(r);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(t) {
    return this.isValid ? this.plus({ [t]: 1 }).startOf(t).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(t, r = {}) {
    return this.isValid ? $n.create(this.loc.redefaultToEN(r)).formatDateTimeFromString(this, t) : J2;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(t = Fb, r = {}) {
    return this.isValid ? $n.create(this.loc.clone(r), t).formatDateTime(this) : J2;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(t = {}) {
    return this.isValid ? $n.create(this.loc.clone(t), t).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: t = "extended",
    suppressSeconds: r = !1,
    suppressMilliseconds: n = !1,
    includeOffset: i = !0,
    extendedZone: s = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const o = t === "extended";
    let a = K2(this, o);
    return a += "T", a += NA(this, o, r, n, i, s), a;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: t = "extended" } = {}) {
    return this.isValid ? K2(this, t === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return N0(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: t = !1,
    suppressSeconds: r = !1,
    includeOffset: n = !0,
    includePrefix: i = !1,
    extendedZone: s = !1,
    format: o = "extended"
  } = {}) {
    return this.isValid ? (i ? "T" : "") + NA(
      this,
      o === "extended",
      r,
      t,
      n,
      s
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return N0(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return N0(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? K2(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: t = !0, includeZone: r = !1, includeOffsetSpace: n = !0 } = {}) {
    let i = "HH:mm:ss.SSS";
    return (r || t) && (n && (i += " "), r ? i += "z" : t && (i += "ZZ")), N0(this, i, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(t = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : J2;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(t = {}) {
    if (!this.isValid)
      return {};
    const r = { ...this.c };
    return t.includeConfig && (r.outputCalendar = this.outputCalendar, r.numberingSystem = this.loc.numberingSystem, r.locale = this.loc.locale), r;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(t, r = "milliseconds", n = {}) {
    if (!this.isValid || !t.isValid)
      return yt.invalid("created by diffing an invalid DateTime");
    const i = { locale: this.locale, numberingSystem: this.numberingSystem, ...n }, s = ate(r).map(yt.normalizeUnit), o = t.valueOf() > this.valueOf(), a = o ? this : t, l = o ? t : this, c = fre(a, l, s, i);
    return o ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(t = "milliseconds", r = {}) {
    return this.diff(We.now(), t, r);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(t) {
    return this.isValid ? mr.fromDateTimes(this, t) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(t, r) {
    if (!this.isValid)
      return !1;
    const n = t.valueOf(), i = this.setZone(t.zone, { keepLocalTime: !0 });
    return i.startOf(r) <= n && n <= i.endOf(r);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(t) {
    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(t = {}) {
    if (!this.isValid)
      return null;
    const r = t.base || We.fromObject({}, { zone: this.zone }), n = t.padding ? this < r ? -t.padding : t.padding : 0;
    let i = ["years", "months", "days", "hours", "minutes", "seconds"], s = t.unit;
    return Array.isArray(t.unit) && (i = t.unit, s = void 0), jA(r, this.plus(n), {
      ...t,
      numeric: "always",
      units: i,
      unit: s
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(t = {}) {
    return this.isValid ? jA(t.base || We.fromObject({}, { zone: this.zone }), this, {
      ...t,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...t) {
    if (!t.every(We.isDateTime))
      throw new us("min requires all arguments be DateTimes");
    return xA(t, (r) => r.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...t) {
    if (!t.every(We.isDateTime))
      throw new us("max requires all arguments be DateTimes");
    return xA(t, (r) => r.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(t, r, n = {}) {
    const { locale: i = null, numberingSystem: s = null } = n, o = Kt.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    });
    return RD(o, t, r);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(t, r, n = {}) {
    return We.fromFormatExplain(t, r, n);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return Fb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return J8;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return Vee;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return Z8;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return K8;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return Y8;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return Q8;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return X8;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return eD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return tD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return rD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return nD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return iD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return sD;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return oD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return aD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return lD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return zee;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return uD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return cD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return dD;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return pD;
  }
}
function zf(e) {
  if (We.isDateTime(e))
    return e;
  if (e && e.valueOf && gd(e.valueOf()))
    return We.fromJSDate(e);
  if (e && typeof e == "object")
    return We.fromObject(e);
  throw new us(
    `Unknown datetime argument: ${e}, of type ${typeof e}`
  );
}
const Nre = { year: void 0, month: void 0, day: void 0, weekday: void 0 }, Fre = { hour: void 0, minute: void 0, second: void 0 }, Dre = { timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone }, DM = { timeZone: "Etc/UTC" }, $o = { year: "numeric", month: "numeric", day: "numeric" }, Uf = { year: "numeric", month: "long", day: "numeric" }, Bf = { year: "numeric", month: "short", day: "numeric" }, qf = { year: "numeric", month: "long", weekday: "long", day: "numeric" }, Yi = { hour: "numeric", minute: "numeric" }, ks = { ...Yi, second: "numeric" }, pf = { "short-date": $o, "short-date-short-time": { ...$o, ...Yi }, "short-date-short-time-24": { ...$o, ...Yi, hour12: !1 }, "short-date-long-time": { ...$o, ...ks }, "short-date-long-time-24": { ...$o, ...ks, hour12: !1 }, "short-date-le": $o, "short-date-le-short-time": { ...$o, ...Yi }, "short-date-le-short-time-24": { ...$o, ...Yi, hour12: !1 }, "short-date-le-long-time": { ...$o, ...ks }, "short-date-le-long-time-24": { ...$o, ...ks, hour12: !1 }, "long-month-day-year": Uf, "long-month-day-year-short-time": { ...Uf, ...Yi }, "long-month-day-year-short-time-24": { ...Uf, ...Yi, hour12: !1 }, "long-month-day-year-long-time": { ...Uf, ...ks }, "long-month-day-year-long-time-24": { ...Uf, ...ks, hour12: !1 }, "day-short-month-year": Bf, "day-short-month-year-short-time": { ...Bf, ...Yi }, "day-short-month-year-short-time-24": { ...Bf, ...Yi, hour12: !1 }, "day-short-month-year-long-time": { ...Bf, ...ks }, "day-short-month-year-long-time-24": { ...Bf, ...ks, hour12: !1 }, "long-date": qf, "long-date-short-time": { ...qf, ...Yi }, "long-date-short-time-24": { ...qf, ...Yi, hour12: !1 }, "long-date-long-time": { ...qf, ...ks }, "long-date-long-time-24": { ...qf, ...ks, hour12: !1 }, "long-month-year": { month: "long", year: "numeric" }, "short-month-year": { month: "short", year: "numeric" }, year: { year: "numeric" }, "short-time": Yi, "long-time": ks }, jre = Mn()({ shortDate: "short-date", shortDateShortTime: "short-date-short-time", shortDateShortTime24: "short-date-short-time-24", shortDateLongTime: "short-date-long-time", shortDateLongTime24: "short-date-long-time-24", shortDateLE: "short-date-le", shortDateLEShortTime: "short-date-le-short-time", shortDateLEShortTime24: "short-date-le-short-time-24", shortDateLELongTime: "short-date-le-long-time", shortDateLELongTime24: "short-date-le-long-time-24", longMonthDayYear: "long-month-day-year", longMonthDayYearShortTime: "long-month-day-year-short-time", longMonthDayYearShortTime24: "long-month-day-year-short-time-24", longMonthDayYearLongTime: "long-month-day-year-long-time", longMonthDayYearLongTime24: "long-month-day-year-long-time-24", dayShortMonthYear: "day-short-month-year", dayShortMonthYearShortTime: "day-short-month-year-short-time", dayShortMonthYearShortTime24: "day-short-month-year-short-time-24", dayShortMonthYearLongTime: "day-short-month-year-long-time", dayShortMonthYearLongTime24: "day-short-month-year-long-time-24", longDate: "long-date", longDateShortTime: "long-date-short-time", longDateShortTime24: "long-date-short-time-24", longDateLongTime: "long-date-long-time", longDateLongTime24: "long-date-long-time-24", longMonthYear: "long-month-year", shortMonthYear: "short-month-year", year: "year" }), HD = { ar: "ar-u-nu-latn-ca-gregory" };
let vx = /* @__PURE__ */ new WeakMap(), WD = pf["short-date-short-time"];
function Vre(e) {
  const t = e || WD;
  let r = vx.get(t);
  if (!r) {
    const n = uo(), i = HD[n] || n;
    r = new Intl.DateTimeFormat(i, t), vx.set(t, r);
  }
  return r;
}
function F0(e) {
  return pf[e];
}
function Ld(e, t) {
  return Vre(t).format(e);
}
function zre(e, t = pf["short-date"]) {
  return Ld(new Date(e), { ...t, ...DM, ...Fre });
}
function Ure(e, t = pf["short-time"]) {
  return Ld(/* @__PURE__ */ new Date(`1970-01-01T${e}Z`), { ...t, ...DM, ...Nre });
}
function Bre(e, t = pf["short-date-short-time"]) {
  const r = We.fromISO(e, { setZone: !0 }), n = uo(), i = HD[n] ?? n;
  return r.toLocaleString({ ...Dre, ...t }, { locale: i });
}
pM(() => {
  vx = /* @__PURE__ */ new WeakMap(), WD = pf["short-date-short-time"];
});
const qre = { ar: "ar-u-nu-latn" };
let Yv = /* @__PURE__ */ new WeakMap(), JD = {};
function Gre(e) {
  const t = e || JD;
  if (!Yv.has(t)) {
    const r = uo(), n = qre[uo()] || r;
    Yv.set(t, new Intl.NumberFormat(n, e));
  }
  return Yv.get(t);
}
function Hre(e = {}) {
  const t = {};
  return e.digitSeparator != null && (t.useGrouping = e.digitSeparator), e.places != null && (t.minimumFractionDigits = t.maximumFractionDigits = e.places), t;
}
function Xy(e, t) {
  return Object.is(e, -0) && (e = 0), Gre(t).format(e);
}
pM(() => {
  Yv = /* @__PURE__ */ new WeakMap(), JD = {};
});
let Ip = class extends Rt(re) {
  constructor(t) {
    super(t), this.dateFormat = null, this.digitSeparator = !1, this.places = null;
  }
  formatNumber(t) {
    return Xy(t, Hre(this));
  }
  formatDate(t, r = !1) {
    return this.dateFormat ? Ld(t, { ...F0(this.dateFormat), ...r && DM }) : this.formatNumber(t);
  }
  formatDateOnly(t) {
    const r = (this.dateFormat && F0(this.dateFormat)) ?? void 0;
    return zre(t, r);
  }
  formatTimeOnly(t) {
    const r = (this.dateFormat && F0(this.dateFormat)) ?? void 0;
    return Ure(t, r);
  }
  formatTimestamp(t) {
    const r = (this.dateFormat && F0(this.dateFormat)) ?? void 0;
    return Bre(t, r);
  }
  formatRasterPixelValue(t) {
    return t.includes("-") ? t : t.trim().includes(",") ? this._formatDelimitedString(t, ",", ", ") : t.trim().includes(";") ? this._formatDelimitedString(t, ";", "; ") : t.trim().includes(" ") ? this._formatDelimitedString(t, " ", " ") : this.formatNumber(Number(t));
  }
  _formatDelimitedString(t, r, n) {
    return t && r && n ? t.trim().split(r).map((i) => this.formatNumber(Number(i))).join(n) : t;
  }
};
u([Ie(jre)], Ip.prototype, "dateFormat", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ip.prototype, "digitSeparator", void 0), u([d({ type: Ot, json: { write: !0 } })], Ip.prototype, "places", void 0), Ip = u([E("geoscene.popup.support.FieldInfoFormat")], Ip);
const gm = Ip;
var bx;
let Fs = bx = class extends re {
  constructor(e) {
    super(e), this.fieldName = null, this.format = null, this.isEditable = !0, this.label = null, this.stringFieldOption = "text-box", this.statisticType = null, this.tooltip = null, this.visible = !0;
  }
  clone() {
    return new bx({ fieldName: this.fieldName, format: this.format ? j(this.format) : null, isEditable: this.isEditable, label: this.label, stringFieldOption: this.stringFieldOption, statisticType: this.statisticType, tooltip: this.tooltip, visible: this.visible });
  }
};
u([d({ type: String, json: { write: !0 } })], Fs.prototype, "fieldName", void 0), u([d({ type: gm, json: { write: !0 } })], Fs.prototype, "format", void 0), u([d({ type: Boolean, json: { write: { alwaysWriteDefaults: !0 }, default: !0 } })], Fs.prototype, "isEditable", void 0), u([d({ type: String, json: { write: !0 } })], Fs.prototype, "label", void 0), u([Ie(new et({ richtext: "rich-text", textarea: "text-area", textbox: "text-box" }), { default: "text-box" })], Fs.prototype, "stringFieldOption", void 0), u([d({ type: ["count", "sum", "min", "max", "avg", "stddev", "var"], json: { write: !0 } })], Fs.prototype, "statisticType", void 0), u([d({ type: String, json: { write: !0 } })], Fs.prototype, "tooltip", void 0), u([d({ type: Boolean, json: { write: !0 } })], Fs.prototype, "visible", void 0), Fs = bx = u([E("geoscene.popup.FieldInfo")], Fs);
const jM = Fs;
var wx;
let Ta = wx = class extends qu {
  constructor(e) {
    super(e), this.attributes = null, this.description = null, this.fieldInfos = null, this.title = null, this.type = "fields";
  }
  writeFieldInfos(e, t) {
    t.fieldInfos = e && e.map((r) => r.toJSON());
  }
  clone() {
    return new wx(j({ attributes: this.attributes, description: this.description, fieldInfos: this.fieldInfos, title: this.title }));
  }
};
u([d({ type: Object, json: { write: !0 } })], Ta.prototype, "attributes", void 0), u([d({ type: String, json: { write: !0 } })], Ta.prototype, "description", void 0), u([d({ type: [jM] })], Ta.prototype, "fieldInfos", void 0), u([ge("fieldInfos")], Ta.prototype, "writeFieldInfos", null), u([d({ type: String, json: { write: !0 } })], Ta.prototype, "title", void 0), u([d({ type: ["fields"], readOnly: !0, json: { read: !1, write: !0 } })], Ta.prototype, "type", void 0), Ta = wx = u([E("geoscene.popup.content.FieldsContent")], Ta);
const eg = Ta;
let mc = class extends re {
  constructor(t) {
    super(t), this.altText = null, this.caption = "", this.title = "", this.type = null;
  }
};
u([d({ type: String, json: { write: !0 } })], mc.prototype, "altText", void 0), u([d({ type: String, json: { write: !0 } })], mc.prototype, "caption", void 0), u([d({ type: String, json: { write: !0 } })], mc.prototype, "title", void 0), u([d({ type: ["image", "bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: !0, json: { read: !1, write: !0 } })], mc.prototype, "type", void 0), mc = u([E("geoscene.popup.content.mixins.MediaInfo")], mc);
const VM = mc;
var _x;
let Mp = _x = class extends Ae {
  constructor(e) {
    super(e), this.fieldName = null, this.tooltip = null, this.value = null;
  }
  clone() {
    return new _x({ fieldName: this.fieldName, tooltip: this.tooltip, value: this.value });
  }
};
u([d()], Mp.prototype, "fieldName", void 0), u([d()], Mp.prototype, "tooltip", void 0), u([d()], Mp.prototype, "value", void 0), Mp = _x = u([E("geoscene.popup.content.support.ChartMediaInfoValueSeries")], Mp);
const Wre = Mp;
var Sx;
let yc = Sx = class extends re {
  constructor(e) {
    super(e), this.fields = [], this.normalizeField = null, this.series = [], this.tooltipField = null;
  }
  clone() {
    return new Sx({ fields: j(this.fields), normalizeField: this.normalizeField, tooltipField: this.tooltipField });
  }
};
u([d({ type: [String], json: { write: !0 } })], yc.prototype, "fields", void 0), u([d({ type: String, json: { write: !0 } })], yc.prototype, "normalizeField", void 0), u([d({ type: [Wre], json: { read: !1 } })], yc.prototype, "series", void 0), u([d({ type: String, json: { write: !0 } })], yc.prototype, "tooltipField", void 0), yc = Sx = u([E("geoscene.popup.content.support.ChartMediaInfoValue")], yc);
const Jre = yc;
let vm = class extends VM {
  constructor(t) {
    super(t), this.type = null, this.value = null;
  }
};
u([d({ type: ["bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: !0, json: { read: !1, write: !0 } })], vm.prototype, "type", void 0), u([d({ type: Jre, json: { write: !0 } })], vm.prototype, "value", void 0), vm = u([E("geoscene.popup.content.mixins.ChartMediaInfo")], vm);
const y_ = vm, g_ = Mn()({ barchart: "bar-chart", columnchart: "column-chart", linechart: "line-chart", piechart: "pie-chart" });
var $x;
let Qv = $x = class extends y_ {
  constructor(e) {
    super(e), this.type = "bar-chart";
  }
  clone() {
    return new $x({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["bar-chart"], readOnly: !0, json: { type: ["barchart"], read: !1, write: g_.write } })], Qv.prototype, "type", void 0), Qv = $x = u([E("geoscene.popup.content.BarChartMediaInfo")], Qv);
const ZD = Qv;
var xx;
let Xv = xx = class extends y_ {
  constructor(e) {
    super(e), this.type = "column-chart";
  }
  clone() {
    return new xx({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["column-chart"], readOnly: !0, json: { type: ["columnchart"], read: !1, write: g_.write } })], Xv.prototype, "type", void 0), Xv = xx = u([E("geoscene.popup.content.ColumnChartMediaInfo")], Xv);
const KD = Xv;
var Tx;
let bm = Tx = class extends re {
  constructor(e) {
    super(e), this.linkURL = null, this.sourceURL = null;
  }
  clone() {
    return new Tx({ linkURL: this.linkURL, sourceURL: this.sourceURL });
  }
};
u([d({ type: String, json: { write: !0 } })], bm.prototype, "linkURL", void 0), u([d({ type: String, json: { write: !0 } })], bm.prototype, "sourceURL", void 0), bm = Tx = u([E("geoscene.popup.content.support.ImageMediaInfoValue")], bm);
const Zre = bm;
var Ex;
let Op = Ex = class extends VM {
  constructor(e) {
    super(e), this.refreshInterval = null, this.type = "image", this.value = null;
  }
  clone() {
    return new Ex({ altText: this.altText, title: this.title, caption: this.caption, refreshInterval: this.refreshInterval, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: Number, json: { write: !0 } })], Op.prototype, "refreshInterval", void 0), u([d({ type: ["image"], readOnly: !0, json: { read: !1, write: !0 } })], Op.prototype, "type", void 0), u([d({ type: Zre, json: { write: !0 } })], Op.prototype, "value", void 0), Op = Ex = u([E("geoscene.popup.content.ImageMediaInfo")], Op);
const YD = Op;
var Ix;
let e1 = Ix = class extends y_ {
  constructor(e) {
    super(e), this.type = "line-chart";
  }
  clone() {
    return new Ix({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["line-chart"], readOnly: !0, json: { type: ["linechart"], read: !1, write: g_.write } })], e1.prototype, "type", void 0), e1 = Ix = u([E("geoscene.popup.content.LineChartMediaInfo")], e1);
const QD = e1;
var Mx;
let t1 = Mx = class extends y_ {
  constructor(e) {
    super(e), this.type = "pie-chart";
  }
  clone() {
    return new Mx({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
u([d({ type: ["pie-chart"], readOnly: !0, json: { type: ["piechart"], read: !1, write: g_.write } })], t1.prototype, "type", void 0), t1 = Mx = u([E("geoscene.popup.content.PieChartMediaInfo")], t1);
const XD = t1, ej = { base: VM, key: "type", defaultKeyValue: "image", typeMap: { "bar-chart": ZD, "column-chart": KD, "line-chart": QD, "pie-chart": XD, image: YD } };
var Ox;
let Ds = Ox = class extends qu {
  constructor(e) {
    super(e), this.activeMediaInfoIndex = null, this.attributes = null, this.description = null, this.mediaInfos = null, this.title = null, this.type = "media";
  }
  readMediaInfos(e) {
    return e && e.map((t) => t.type === "image" ? YD.fromJSON(t) : t.type === "barchart" ? ZD.fromJSON(t) : t.type === "columnchart" ? KD.fromJSON(t) : t.type === "linechart" ? QD.fromJSON(t) : t.type === "piechart" ? XD.fromJSON(t) : void 0).filter(Boolean);
  }
  writeMediaInfos(e, t) {
    t.mediaInfos = e && e.map((r) => r.toJSON());
  }
  clone() {
    return new Ox(j({ activeMediaInfoIndex: this.activeMediaInfoIndex, attributes: this.attributes, description: this.description, mediaInfos: this.mediaInfos, title: this.title }));
  }
};
u([d()], Ds.prototype, "activeMediaInfoIndex", void 0), u([d({ type: Object, json: { write: !0 } })], Ds.prototype, "attributes", void 0), u([d({ type: String, json: { write: !0 } })], Ds.prototype, "description", void 0), u([d({ types: [ej] })], Ds.prototype, "mediaInfos", void 0), u([ce("mediaInfos")], Ds.prototype, "readMediaInfos", null), u([ge("mediaInfos")], Ds.prototype, "writeMediaInfos", null), u([d({ type: String, json: { write: !0 } })], Ds.prototype, "title", void 0), u([d({ type: ["media"], readOnly: !0, json: { read: !1, write: !0 } })], Ds.prototype, "type", void 0), Ds = Ox = u([E("geoscene.popup.content.MediaContent")], Ds);
const zb = Ds;
var Cx;
let wm = Cx = class extends re {
  constructor(e) {
    super(e), this.field = null, this.order = null;
  }
  clone() {
    return new Cx({ field: this.field, order: this.order });
  }
};
u([d({ type: String, json: { write: !0 } })], wm.prototype, "field", void 0), u([d({ type: ["asc", "desc"], json: { write: !0 } })], wm.prototype, "order", void 0), wm = Cx = u([E("geoscene.popup.support.RelatedRecordsInfoFieldOrder")], wm);
const zM = wm;
let Co = class extends Rt(qu) {
  constructor(t) {
    super(t), this.description = null, this.displayCount = null, this.displayType = "list", this.orderByFields = null, this.relationshipId = null, this.title = null, this.type = "relationship";
  }
};
u([d({ type: String, json: { write: !0 } })], Co.prototype, "description", void 0), u([d({ type: Number, json: { type: Ot, write: !0 } })], Co.prototype, "displayCount", void 0), u([d({ type: ["list"], json: { write: !0 } })], Co.prototype, "displayType", void 0), u([d({ type: [zM], json: { write: !0 } })], Co.prototype, "orderByFields", void 0), u([d({ type: Number, json: { type: Ot, write: !0 } })], Co.prototype, "relationshipId", void 0), u([d({ type: String, json: { write: !0 } })], Co.prototype, "title", void 0), u([d({ type: ["relationship"], readOnly: !0, json: { read: !1, write: !0 } })], Co.prototype, "type", void 0), Co = u([E("geoscene.popup.content.RelationshipContent")], Co);
const Ub = Co;
var kx;
let _m = kx = class extends qu {
  constructor(e) {
    super(e), this.text = null, this.type = "text";
  }
  clone() {
    return new kx({ text: this.text });
  }
};
u([d({ type: String, json: { write: !0 } })], _m.prototype, "text", void 0), u([d({ type: ["text"], readOnly: !0, json: { read: !1, write: !0 } })], _m.prototype, "type", void 0), _m = kx = u([E("geoscene.popup.content.TextContent")], _m);
const Bb = _m, Kre = { base: null, key: "type", typeMap: { attachment: Qy, media: zb, text: Bb, expression: CM, field: eg, relationship: Ub } };
var Ax;
let gc = Ax = class extends re {
  constructor(e) {
    super(e), this.name = null, this.title = null, this.expression = null, this.returnType = null;
  }
  clone() {
    return new Ax({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
u([d({ type: String, json: { write: !0 } })], gc.prototype, "name", void 0), u([d({ type: String, json: { write: !0 } })], gc.prototype, "title", void 0), u([d({ type: String, json: { write: !0 } })], gc.prototype, "expression", void 0), u([d({ type: ["string", "number"], json: { write: !0 } })], gc.prototype, "returnType", void 0), gc = Ax = u([E("geoscene.popup.ExpressionInfo")], gc);
const Yre = gc;
var Px;
let Sm = Px = class extends re {
  constructor(e) {
    super(e), this.returnTopmostRaster = null, this.showNoDataRecords = null;
  }
  clone() {
    return new Px({ showNoDataRecords: this.showNoDataRecords, returnTopmostRaster: this.returnTopmostRaster });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Sm.prototype, "returnTopmostRaster", void 0), u([d({ type: Boolean, json: { write: !0 } })], Sm.prototype, "showNoDataRecords", void 0), Sm = Px = u([E("geoscene.popup.LayerOptions")], Sm);
const Qre = Sm;
var Rx;
let $m = Rx = class extends re {
  constructor(e) {
    super(e), this.showRelatedRecords = null, this.orderByFields = null;
  }
  clone() {
    return new Rx({ showRelatedRecords: this.showRelatedRecords, orderByFields: this.orderByFields ? j(this.orderByFields) : null });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], $m.prototype, "showRelatedRecords", void 0), u([d({ type: [zM], json: { write: !0 } })], $m.prototype, "orderByFields", void 0), $m = Rx = u([E("geoscene.popup.RelatedRecordsInfo")], $m);
const Xre = $m;
var Lx;
let Qi = Lx = class extends xM(Ae) {
  constructor(e) {
    super(e), this.active = !1, this.className = null, this.disabled = !1, this.icon = null, this.id = null, this.indicator = !1, this.title = null, this.type = null, this.visible = !0;
  }
  clone() {
    return new Lx({ active: this.active, className: this.className, disabled: this.disabled, icon: this.icon, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible });
  }
};
u([d()], Qi.prototype, "active", void 0), u([d()], Qi.prototype, "className", void 0), u([d()], Qi.prototype, "disabled", void 0), u([d()], Qi.prototype, "icon", void 0), u([d()], Qi.prototype, "id", void 0), u([d()], Qi.prototype, "indicator", void 0), u([d()], Qi.prototype, "title", void 0), u([d()], Qi.prototype, "type", void 0), u([d()], Qi.prototype, "visible", void 0), Qi = Lx = u([E("geoscene.support.actions.ActionBase")], Qi);
const UM = Qi;
var Nx;
let r1 = Nx = class extends UM {
  constructor(e) {
    super(e), this.image = null, this.type = "button";
  }
  clone() {
    return new Nx({ active: this.active, className: this.className, disabled: this.disabled, icon: this.icon, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image });
  }
};
u([d()], r1.prototype, "image", void 0), r1 = Nx = u([E("geoscene.support.Action.ActionButton")], r1);
const ene = r1;
var Fx;
let xm = Fx = class extends UM {
  constructor(e) {
    super(e), this.image = null, this.type = "toggle", this.value = !1;
  }
  clone() {
    return new Fx({ active: this.active, className: this.className, disabled: this.disabled, icon: this.icon, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image, value: this.value });
  }
};
u([d()], xm.prototype, "image", void 0), u([d()], xm.prototype, "value", void 0), xm = Fx = u([E("geoscene.support.Action.ActionToggle")], xm);
const tne = xm, rne = "geoscene.PopupTemplate", nne = se.getLogger(rne), Gf = "relationships/", zA = "expression/", ine = je.ofType({ key: "type", defaultKeyValue: "button", base: UM, typeMap: { button: ene, toggle: tne } }), sne = { base: qu, key: "type", typeMap: { media: zb, custom: Lee, text: Bb, attachments: Qy, fields: eg, expression: CM, relationship: Ub } }, one = ["attachments", "fields", "media", "text", "expression", "relationship"];
let Fr = class extends Rt(re) {
  constructor() {
    super(...arguments), this.actions = null, this.content = "", this.expressionInfos = null, this.fieldInfos = null, this.layerOptions = null, this.lastEditInfoEnabled = !0, this.outFields = null, this.overwriteActions = !1, this.returnGeometry = !1, this.title = "";
  }
  castContent(t) {
    return Array.isArray(t) ? t.map((r) => na(sne, r)) : typeof t == "string" || typeof t == "function" || t instanceof HTMLElement || pl(t) ? t : (nne.error("content error", "unsupported content value", { value: t }), null);
  }
  readContent(t, r) {
    const { popupElements: n } = r;
    return Array.isArray(n) && n.length > 0 ? this._readPopupInfoElements(r.description, r.mediaInfos, n) : this._readPopupInfo(r);
  }
  writeContent(t, r, n, i) {
    typeof t != "string" ? Array.isArray(t) && (r.popupElements = t.filter((s) => one.includes(s.type)).map((s) => s && s.toJSON(i)), r.popupElements.forEach((s) => {
      s.type === "attachments" ? this._writeAttachmentContent(r) : s.type === "media" ? this._writeMediaContent(s, r) : s.type === "text" ? this._writeTextContent(s, r) : s.type === "relationship" && this._writeRelationshipContent(s, r);
    })) : r.description = t;
  }
  writeFieldInfos(t, r, n, i) {
    const { content: s } = this, o = Array.isArray(s) ? s : null;
    if (t) {
      const a = o ? o.filter((c) => c.type === "fields") : [], l = a.length && a.every((c) => {
        var h;
        return (h = c.fieldInfos) == null ? void 0 : h.length;
      });
      r.fieldInfos = t.filter(Boolean).map((c) => {
        const h = c.toJSON(i);
        return l && (h.visible = !1), h;
      });
    }
    if (o)
      for (const a of o)
        a.type === "fields" && this._writeFieldsContent(a, r);
  }
  writeLayerOptions(t, r, n, i) {
    r[n] = !t || t.showNoDataRecords === null && t.returnTopmostRaster === null ? null : t.toJSON(i);
  }
  writeTitle(t, r) {
    r.title = t || "";
  }
  async collectRequiredFields(t, r) {
    const n = this.expressionInfos || [];
    await this._collectExpressionInfoFields(t, r, [...n, ...this._getContentExpressionInfos(this.content, n)]), Yy(t, r, [...this.outFields || [], ...this._getActionsFields(this.actions), ...this._getTitleFields(this.title), ...this._getContentFields(this.content)]);
  }
  async getRequiredFields(t) {
    const r = /* @__PURE__ */ new Set();
    return await this.collectRequiredFields(r, t), [...r].sort();
  }
  _writeFieldsContent(t, r) {
    if (!Array.isArray(t.fieldInfos) || !t.fieldInfos.length)
      return;
    const n = j(t.fieldInfos);
    Array.isArray(r.fieldInfos) ? n.forEach((i) => {
      const s = r.fieldInfos.find((o) => o.fieldName.toLowerCase() === i.fieldName.toLowerCase());
      s ? s.visible = !0 : r.fieldInfos.push(i);
    }) : r.fieldInfos = n;
  }
  _writeAttachmentContent(t) {
    t.showAttachments || (t.showAttachments = !0);
  }
  _writeRelationshipContent(t, r) {
    var s, o;
    const n = ((s = t.orderByFields) == null ? void 0 : s.map((a) => this._toFieldOrderJSON(a, t.relationshipId))) || [], i = [...((o = r.relatedRecordsInfo) == null ? void 0 : o.orderByFields) || [], ...n];
    r.relatedRecordsInfo = { showRelatedRecords: !0, ...(i == null ? void 0 : i.length) && { orderByFields: i } };
  }
  _writeTextContent(t, r) {
    !r.description && t.text && (r.description = t.text);
  }
  _writeMediaContent(t, r) {
    if (!Array.isArray(t.mediaInfos) || !t.mediaInfos.length)
      return;
    const n = j(t.mediaInfos);
    Array.isArray(r.mediaInfos) ? r.mediaInfos = [...r.mediaInfos, ...n] : r.mediaInfos = n;
  }
  _readPopupInfoElements(t, r, n) {
    const i = { description: !1, mediaInfos: !1 };
    return n.map((s) => s.type === "media" ? (s.mediaInfos || !r || i.mediaInfos || (s.mediaInfos = r, i.mediaInfos = !0), zb.fromJSON(s)) : s.type === "text" ? (s.text || !t || i.description || (s.text = t, i.description = !0), Bb.fromJSON(s)) : s.type === "attachments" ? Qy.fromJSON(s) : s.type === "fields" ? eg.fromJSON(s) : s.type === "expression" ? CM.fromJSON(s) : s.type === "relationship" ? Ub.fromJSON(s) : void 0).filter(Boolean);
  }
  _toRelationshipContent(t) {
    const { field: r, order: n } = t;
    if (!(r != null && r.startsWith(Gf)))
      return null;
    const i = r.replace(Gf, "").split("/");
    if (i.length !== 2)
      return null;
    const s = parseInt(i[0], 10), o = i[1];
    return typeof s == "number" && o ? Ub.fromJSON({ relationshipId: s, orderByFields: [{ field: o, order: n }] }) : null;
  }
  _toFieldOrderJSON(t, r) {
    const { order: n, field: i } = t;
    return { field: `${Gf}${r}/${i}`, order: n };
  }
  _readPopupInfo({ description: t, mediaInfos: r, showAttachments: n, relatedRecordsInfo: i = { showRelatedRecords: !1 } }) {
    const s = [];
    t ? s.push(new Bb({ text: t })) : s.push(new eg()), Array.isArray(r) && r.length && s.push(zb.fromJSON({ mediaInfos: r })), n && s.push(Qy.fromJSON({ displayType: "auto" }));
    const { showRelatedRecords: o, orderByFields: a } = i;
    return o && (a != null && a.length) && a.forEach((l) => {
      const c = this._toRelationshipContent(l);
      c && s.push(c);
    }), s.length ? s : t;
  }
  _getContentElementFields(t) {
    const r = t == null ? void 0 : t.type;
    if (r === "attachments")
      return [...this._extractFieldNames(t.title), ...this._extractFieldNames(t.description)];
    if (r === "custom")
      return t.outFields || [];
    if (r === "fields")
      return [...this._extractFieldNames(t.title), ...this._extractFieldNames(t.description), ...this._getFieldInfoFields(t.fieldInfos ?? this.fieldInfos)];
    if (r === "media") {
      const n = t.mediaInfos || [];
      return [...this._extractFieldNames(t.title), ...this._extractFieldNames(t.description), ...n.reduce((i, s) => [...i, ...this._getMediaInfoFields(s)], [])];
    }
    return r === "text" ? this._extractFieldNames(t.text) : [];
  }
  _getMediaInfoFields(t) {
    const { caption: r, title: n, value: i } = t, s = i || {}, { fields: o, normalizeField: a, tooltipField: l, sourceURL: c, linkURL: h } = s, f = [...this._extractFieldNames(n), ...this._extractFieldNames(r), ...this._extractFieldNames(c), ...this._extractFieldNames(h), ...o ?? []];
    return a && f.push(a), l && f.push(l), f;
  }
  _getContentExpressionInfos(t, r) {
    return Array.isArray(t) ? t.reduce((n, i) => [...n, ...i.type === "expression" && i.expressionInfo ? [i.expressionInfo] : []], r) : [];
  }
  _getContentFields(t) {
    return typeof t == "string" ? this._extractFieldNames(t) : Array.isArray(t) ? t.reduce((r, n) => [...r, ...this._getContentElementFields(n)], []) : [];
  }
  async _collectExpressionInfoFields(t, r, n) {
    n && await Promise.all(n.map((i) => qn(t, r, i.expression)));
  }
  _getFieldInfoFields(t) {
    return t ? t.filter((r) => r.visible === void 0 || !!r.visible).map((r) => r.fieldName).filter((r) => !r.startsWith(Gf) && !r.startsWith(zA)) : [];
  }
  _getActionsFields(t) {
    return t ? t.toArray().reduce((r, n) => [...r, ...this._getActionFields(n)], []) : [];
  }
  _getActionFields(t) {
    const { className: r, title: n, type: i } = t, s = i === "button" || i === "toggle" ? t.image : "";
    return [...this._extractFieldNames(n), ...this._extractFieldNames(r), ...this._extractFieldNames(s)];
  }
  _getTitleFields(t) {
    return typeof t == "string" ? this._extractFieldNames(t) : [];
  }
  _extractFieldNames(t) {
    if (!t || typeof t != "string")
      return [];
    const r = /{[^}]*}/g, n = t.match(r);
    if (!n)
      return [];
    const i = /\{(\w+):.+\}/, s = n.filter((o) => !(o.indexOf(`{${Gf}`) === 0 || o.indexOf(`{${zA}`) === 0)).map((o) => o.replace(i, "{$1}"));
    return s ? s.map((o) => o.slice(1, -1)) : [];
  }
};
u([d({ type: ine })], Fr.prototype, "actions", void 0), u([d()], Fr.prototype, "content", void 0), u([xt("content")], Fr.prototype, "castContent", null), u([ce("content", ["description", "fieldInfos", "popupElements", "mediaInfos", "showAttachments", "relatedRecordsInfo"])], Fr.prototype, "readContent", null), u([ge("content", { popupElements: { type: je.ofType(Kre) }, showAttachments: { type: Boolean }, mediaInfos: { type: je.ofType(ej) }, description: { type: String }, relatedRecordsInfo: { type: Xre } })], Fr.prototype, "writeContent", null), u([d({ type: [Yre], json: { write: !0 } })], Fr.prototype, "expressionInfos", void 0), u([d({ type: [jM] })], Fr.prototype, "fieldInfos", void 0), u([ge("fieldInfos")], Fr.prototype, "writeFieldInfos", null), u([d({ type: Qre })], Fr.prototype, "layerOptions", void 0), u([ge("layerOptions")], Fr.prototype, "writeLayerOptions", null), u([d({ type: Boolean, json: { read: { source: "showLastEditInfo" }, write: { target: "showLastEditInfo" }, default: !0 } })], Fr.prototype, "lastEditInfoEnabled", void 0), u([d()], Fr.prototype, "outFields", void 0), u([d()], Fr.prototype, "overwriteActions", void 0), u([d()], Fr.prototype, "returnGeometry", void 0), u([d({ json: { type: String } })], Fr.prototype, "title", void 0), u([ge("title")], Fr.prototype, "writeTitle", null), Fr = u([E("geoscene.PopupTemplate")], Fr);
const zg = Fr, UA = new et({ esriSMS: "simple-marker", esriPMS: "picture-marker", esriSLS: "simple-line", esriSFS: "simple-fill", esriPFS: "picture-fill", esriTS: "text", esriSHD: "shield-label-symbol", PointSymbol3D: "point-3d", LineSymbol3D: "line-3d", PolygonSymbol3D: "polygon-3d", WebStyleSymbol: "web-style", MeshSymbol3D: "mesh-3d", LabelSymbol3D: "label-3d", CIMSymbolReference: "cim" });
let ane = 0, Cp = class extends re {
  constructor(t) {
    super(t), this.id = "sym" + ane++, this.type = null, this.color = new Me([0, 0, 0, 1]);
  }
  readColor(t) {
    return t && t[0] != null ? [t[0], t[1], t[2], t[3] / 255] : t;
  }
  async collectRequiredFields(t, r) {
  }
  hash() {
    return JSON.stringify(this.toJSON());
  }
  clone() {
  }
};
u([d({ type: UA.apiValues, readOnly: !0, json: { read: !1, write: { ignoreOrigin: !0, writer: UA.write } } })], Cp.prototype, "type", void 0), u([d({ type: Me, json: { write: { allowNull: !0 } } })], Cp.prototype, "color", void 0), u([ce("color")], Cp.prototype, "readColor", null), Cp = u([E("geoscene.symbols.Symbol")], Cp);
const hi = Cp;
var Dx;
let Vl = Dx = class extends hi {
  constructor(e) {
    super(e), this.data = null, this.type = "cim";
  }
  readData(e, t) {
    return t;
  }
  writeData(e, t) {
    Object.assign(t, e);
  }
  async collectRequiredFields(e, t) {
    var r;
    if (((r = this.data) == null ? void 0 : r.type) === "CIMSymbolReference") {
      const n = this.data.primitiveOverrides;
      if (n) {
        const i = n.map((s) => {
          const o = s.valueExpressionInfo;
          return qn(e, t, o.expression);
        });
        await Promise.all(i);
      }
    }
  }
  clone() {
    return new Dx({ data: j(this.data) });
  }
  hash() {
    return j3(JSON.stringify(this.data)).toString();
  }
};
u([d({ json: { write: !1 } })], Vl.prototype, "color", void 0), u([d({ json: { write: !0 } })], Vl.prototype, "data", void 0), u([ce("data", ["symbol"])], Vl.prototype, "readData", null), u([ge("data", {})], Vl.prototype, "writeData", null), u([Ie({ CIMSymbolReference: "cim" }, { readOnly: !0 })], Vl.prototype, "type", void 0), Vl = Dx = u([E("geoscene.symbols.CIMSymbol")], Vl);
const Ug = Vl;
let kp = class extends re {
  constructor(t) {
    super(t), this.enabled = !0, this.type = null, this.ignoreDrivers = !1;
  }
  writeEnabled(t, r, n) {
    t || (r[n] = t);
  }
};
u([d({ type: Boolean, json: { read: { source: "enable" }, write: { target: "enable" } } })], kp.prototype, "enabled", void 0), u([ge("enabled")], kp.prototype, "writeEnabled", null), u([d({ type: ["icon", "object", "line", "path", "fill", "water", "extrude", "text"], readOnly: !0 })], kp.prototype, "type", void 0), kp = u([E("geoscene.symbols.Symbol3DLayer")], kp);
const pa = kp, lne = /^-?(\d+(\.\d+)?)\s*((px)|(pt))?$/i, une = "screenUtils.toPt: input not recognized!", tj = 96;
function rj(e) {
  return e ? e / 72 * tj : 0;
}
function al(e) {
  return e ? 72 * e / tj : 0;
}
function ut(e) {
  if (typeof e == "string") {
    const t = e.match(lne);
    if (t) {
      const r = Number(t[1]), n = t[3] && t[3].toLowerCase(), i = e.charAt(0) === "-", s = n === "px" ? al(r) : r;
      return i ? -s : s;
    }
    return console.warn(une), null;
  }
  return e;
}
function Vn(e = 0, t = 0) {
  return { x: e, y: t };
}
function QRe(e = 0, t = 0) {
  return [e, t];
}
function cne(e, t) {
  const r = t.transparency != null ? Zy(t.transparency) : 1, n = t.color;
  return n && Array.isArray(n) ? new Me([n[0] || 0, n[1] || 0, n[2] || 0, r]) : null;
}
function dne(e, t) {
  t.color = e.toJSON().slice(0, 3);
  const r = u_(e.a);
  r !== 0 && (t.transparency = r);
}
const Gu = { type: Me, json: { type: [Ot], default: null, read: { source: ["color", "transparency"], reader: cne }, write: { target: { color: { type: [Ot] }, transparency: { type: Ot } }, writer: dne } } }, oa = { type: Number, cast: ut, json: { write: !0 } };
let vc = class extends re {
  constructor(t) {
    super(t), this.color = new Me([0, 0, 0, 1]), this.extensionLength = 0, this.size = al(1);
  }
  clone() {
  }
  cloneProperties() {
    return { color: j(this.color), size: this.size, extensionLength: this.extensionLength };
  }
};
u([d({ type: ["solid", "sketch"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], vc.prototype, "type", void 0), u([d(Gu)], vc.prototype, "color", void 0), u([d({ ...oa, json: { write: { overridePolicy: (e) => ({ enabled: !!e }) } } })], vc.prototype, "extensionLength", void 0), u([d(oa)], vc.prototype, "size", void 0), vc = u([E("geoscene.symbols.edges.Edges3D")], vc);
const BM = vc;
var jx;
let n1 = jx = class extends BM {
  constructor(e) {
    super(e), this.type = "sketch";
  }
  clone() {
    return new jx(this.cloneProperties());
  }
};
u([Ie({ sketch: "sketch" }, { readOnly: !0 })], n1.prototype, "type", void 0), n1 = jx = u([E("geoscene.symbols.edges.SketchEdges3D")], n1);
const pne = n1;
var Vx;
let i1 = Vx = class extends BM {
  constructor(e) {
    super(e), this.type = "solid";
  }
  clone() {
    return new Vx(this.cloneProperties());
  }
};
u([Ie({ solid: "solid" }, { readOnly: !0 })], i1.prototype, "type", void 0), i1 = Vx = u([E("geoscene.symbols.support.SolidEdges3D")], i1);
const hne = i1, nj = { types: { key: "type", base: BM, typeMap: { solid: hne, sketch: pne } }, json: { write: !0 } };
var zx;
let ms = zx = class extends re {
  constructor(e) {
    super(e), this.color = null;
  }
  clone() {
    const e = { color: this.color != null ? this.color.clone() : null };
    return new zx(e);
  }
};
u([d(Gu)], ms.prototype, "color", void 0), ms = zx = u([E("geoscene.symbols.support.Symbol3DMaterial")], ms);
var Ux;
let zl = Ux = class extends pa {
  constructor(e) {
    super(e), this.type = "extrude", this.size = 1, this.material = null, this.castShadows = !0, this.edges = null;
  }
  clone() {
    return new Ux({ edges: this.edges && this.edges.clone(), enabled: this.enabled, material: this.material != null ? this.material.clone() : null, castShadows: this.castShadows, size: this.size });
  }
};
u([Ie({ Extrude: "extrude" }, { readOnly: !0 })], zl.prototype, "type", void 0), u([d({ type: Number, json: { write: { enabled: !0, isRequired: !0 } }, nonNullable: !0 })], zl.prototype, "size", void 0), u([d({ type: ms, json: { write: !0 } })], zl.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], zl.prototype, "castShadows", void 0), u([d(nj)], zl.prototype, "edges", void 0), zl = Ux = u([E("geoscene.symbols.ExtrudeSymbol3DLayer")], zl);
const ij = zl;
let Tm = class extends hi {
  constructor(t) {
    super(t), this.type = "simple-line", this.width = 0.75;
  }
  hash() {
    return `${this.type}.${this.width}`;
  }
};
u([Ie({ esriSLS: "simple-line" }, { readOnly: !0 })], Tm.prototype, "type", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Tm.prototype, "width", void 0), Tm = u([E("geoscene.symbols.LineSymbol")], Tm);
const fne = Tm, mne = ["begin", "end", "begin-end"], sj = ["arrow", "circle", "square", "diamond", "cross", "x"];
var Bx;
let ko = Bx = class extends re {
  constructor(e) {
    super(e), this.placement = "begin-end", this.type = "line-marker", this.style = "arrow";
  }
  writeStyle(e, t, r, n) {
    t[r] = (n == null ? void 0 : n.origin) === "web-map" ? "arrow" : e;
  }
  set color(e) {
    this._set("color", e);
  }
  readColor(e) {
    return e && e[0] != null ? [e[0], e[1], e[2], e[3] / 255] : e;
  }
  writeColor(e, t, r, n) {
    (n == null ? void 0 : n.origin) === "web-map" || (t[r] = e);
  }
  clone() {
    return new Bx({ color: j(this.color), placement: this.placement, style: this.style });
  }
  hash() {
    var e;
    return `${this.placement}.${(e = this.color) == null ? void 0 : e.hash()}.${this.style}`;
  }
};
u([d({ type: ["begin", "end", "begin-end"], json: { write: !0 } })], ko.prototype, "placement", void 0), u([Ie({ "line-marker": "line-marker" }, { readOnly: !0 }), d({ json: { origins: { "web-map": { write: !1 } } } })], ko.prototype, "type", void 0), u([d({ type: sj })], ko.prototype, "style", void 0), u([ge("style")], ko.prototype, "writeStyle", null), u([d({ type: Me, value: null, json: { write: { allowNull: !0 } } })], ko.prototype, "color", null), u([ce("color")], ko.prototype, "readColor", null), u([ge("color")], ko.prototype, "writeColor", null), ko = Bx = u([E("geoscene.symbols.LineSymbolMarker")], ko);
const yne = ko;
var qx;
const Y2 = new et({ esriSLSSolid: "solid", esriSLSDash: "dash", esriSLSDot: "dot", esriSLSDashDot: "dash-dot", esriSLSDashDotDot: "long-dash-dot-dot", esriSLSNull: "none", esriSLSInsideFrame: "inside-frame", esriSLSShortDash: "short-dash", esriSLSShortDot: "short-dot", esriSLSShortDashDot: "short-dash-dot", esriSLSShortDashDotDot: "short-dash-dot-dot", esriSLSLongDash: "long-dash", esriSLSLongDashDot: "long-dash-dot" });
let Ea = qx = class extends fne {
  constructor(...e) {
    super(...e), this.type = "simple-line", this.style = "solid", this.cap = "round", this.join = "round", this.marker = null, this.miterLimit = 2;
  }
  normalizeCtorArgs(e, t, r, n, i, s) {
    if (e && typeof e != "string")
      return e;
    const o = {};
    return e != null && (o.style = e), t != null && (o.color = t), r != null && (o.width = ut(r)), n != null && (o.cap = n), i != null && (o.join = i), s != null && (o.miterLimit = ut(s)), o;
  }
  clone() {
    var e;
    return new qx({ color: j(this.color), style: this.style, width: this.width, cap: this.cap, join: this.join, miterLimit: this.miterLimit, marker: (e = this.marker) == null ? void 0 : e.clone() });
  }
  hash() {
    var e, t;
    return `${super.hash()}.${(e = this.color) == null ? void 0 : e.hash()}.${this.style}.${this.cap}.${this.join}.${this.miterLimit}.${(t = this.marker) == null ? void 0 : t.hash()}`;
  }
};
u([Ie({ esriSLS: "simple-line" }, { readOnly: !0 })], Ea.prototype, "type", void 0), u([d({ type: Y2.apiValues, json: { read: Y2.read, write: Y2.write } })], Ea.prototype, "style", void 0), u([d({ type: ["butt", "round", "square"], json: { write: { overridePolicy: (e, t, r) => ({ enabled: e !== "round" && (r == null || r.origin == null) }) } } })], Ea.prototype, "cap", void 0), u([d({ type: ["miter", "round", "bevel"], json: { write: { overridePolicy: (e, t, r) => ({ enabled: e !== "round" && (r == null || r.origin == null) }) } } })], Ea.prototype, "join", void 0), u([d({ types: { key: "type", base: null, defaultKeyValue: "line-marker", typeMap: { "line-marker": yne } }, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], Ea.prototype, "marker", void 0), u([d({ type: Number, json: { read: !1, write: !1 } })], Ea.prototype, "miterLimit", void 0), Ea = qx = u([E("geoscene.symbols.SimpleLineSymbol")], Ea);
const ji = Ea;
let Em = class extends hi {
  constructor(t) {
    super(t), this.outline = null, this.type = null;
  }
  hash() {
    return `${this.type}.${this.outline && this.outline.hash()}`;
  }
};
u([d({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": ji } }, json: { default: null, write: !0 } })], Em.prototype, "outline", void 0), u([d({ type: ["simple-fill", "picture-fill"], readOnly: !0 })], Em.prototype, "type", void 0), Em = u([E("geoscene.symbols.FillSymbol")], Em);
const oj = Em;
let s1 = class extends re {
  constructor(t) {
    super(t);
  }
  clone() {
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], s1.prototype, "type", void 0), s1 = u([E("geoscene.symbols.patterns.LinePattern3D")], s1);
const aj = s1, gne = ["dash", "dash-dot", "dot", "long-dash", "long-dash-dot", "long-dash-dot-dot", "none", "short-dash", "short-dash-dot", "short-dash-dot-dot", "short-dot", "solid"];
var Gx;
const vne = Mn()({ dash: "dash", "dash-dot": "dash-dot", "dash-dot-dot": "long-dash-dot-dot", dot: "dot", "long-dash": "long-dash", "long-dash-dot": "long-dash-dot", null: "none", "short-dash": "short-dash", "short-dash-dot": "short-dash-dot", "short-dash-dot-dot": "short-dash-dot-dot", "short-dot": "short-dot", solid: "solid" });
let Im = Gx = class extends aj {
  constructor(e) {
    super(e), this.type = "style", this.style = "solid";
  }
  clone() {
    const e = { style: this.style };
    return new Gx(e);
  }
};
u([d({ type: ["style"] })], Im.prototype, "type", void 0), u([Ie(vne), d({ type: gne })], Im.prototype, "style", void 0), Im = Gx = u([E("geoscene.symbols.patterns.LineStylePattern3D")], Im);
const qM = Im;
let o1 = class extends re {
  constructor(t) {
    super(t);
  }
  clone() {
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], o1.prototype, "type", void 0), o1 = u([E("geoscene.symbols.patterns.Pattern3D")], o1);
const lj = o1, bne = ["backward-diagonal", "cross", "diagonal-cross", "forward-diagonal", "horizontal", "none", "solid", "vertical"];
var Hx;
let Mm = Hx = class extends lj {
  constructor(e) {
    super(e), this.type = "style", this.style = "solid";
  }
  clone() {
    const e = { style: this.style };
    return new Hx(e);
  }
};
u([d({ type: ["style"] })], Mm.prototype, "type", void 0), u([d({ type: bne, json: { read: !0, write: !0 } })], Mm.prototype, "style", void 0), Mm = Hx = u([E("geoscene.symbols.patterns.StylePattern3D")], Mm);
const uj = Mm, wne = { types: { key: "type", base: lj, typeMap: { style: uj } }, json: { write: !0 } }, cj = { types: { key: "type", base: aj, typeMap: { style: qM } }, json: { write: !0 } }, wy = new Me("white");
new Me("black");
const _ne = new Me([255, 255, 255, 0]);
function Sne(e) {
  return e.r === 0 && e.g === 0 && e.b === 0;
}
var Wx;
let _y = Wx = class extends ms {
  constructor(e) {
    super(e), this.colorMixMode = null;
  }
  clone() {
    const e = { color: this.color != null ? this.color.clone() : null, colorMixMode: this.colorMixMode };
    return new Wx(e);
  }
};
u([Ie({ multiply: "multiply", replace: "replace", tint: "tint" })], _y.prototype, "colorMixMode", void 0), _y = Wx = u([E("geoscene.symbols.support.Symbol3DFillMaterial")], _y);
function GM(e = Ine) {
  return [e[0], e[1], e[2], e[3], e[4], e[5]];
}
function HM(e, t, r, n, i, s, o = GM()) {
  return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o[4] = i, o[5] = s, o;
}
function i4e(e, t) {
  const r = isFinite(e[2]) || isFinite(e[5]);
  return new Ct(r ? { xmin: e[0], xmax: e[3], ymin: e[1], ymax: e[4], zmin: e[2], zmax: e[5], spatialReference: t } : { xmin: e[0], xmax: e[3], ymin: e[1], ymax: e[4], spatialReference: t });
}
function s4e(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.min(e[2], t[2]), e[3] = Math.max(e[3], t[3]), e[4] = Math.max(e[4], t[4]), e[5] = Math.max(e[5], t[5]);
}
function o4e(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.min(e[2], t[2]), e[3] = Math.max(e[3], t[0]), e[4] = Math.max(e[4], t[1]), e[5] = Math.max(e[5], t[2]);
}
function $ne(e) {
  return e[0] >= e[3] ? 0 : e[3] - e[0];
}
function xne(e) {
  return e[1] >= e[4] ? 0 : e[4] - e[1];
}
function Tne(e) {
  return e[2] >= e[5] ? 0 : e[5] - e[2];
}
function a4e(e, t = [0, 0, 0]) {
  return t[0] = $ne(e), t[1] = xne(e), t[2] = Tne(e), t;
}
function l4e(e, t, r = e) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r !== e && (r[3] = e[3], r[4] = e[4], r[5] = e[5]), r;
}
function u4e(e, t, r = e) {
  return r[3] = t[0], r[4] = t[1], r[5] = t[2], r !== e && (r[0] = e[0], r[1] = e[1], r[2] = e[2]), e;
}
function Ene(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function c4e(e) {
  return e ? Ene(e, qA) : GM(qA);
}
function d4e(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = Number.NEGATIVE_INFINITY, e[3] = t[2], e[4] = t[3], e[5] = Number.POSITIVE_INFINITY, e;
}
function p4e(e, t, r, n, i) {
  return e[0] = t, e[1] = r, e[2] = Number.NEGATIVE_INFINITY, e[3] = n, e[4] = i, e[5] = Number.POSITIVE_INFINITY, e;
}
function BA(e) {
  return e.length === 6;
}
function h4e(e, t, r) {
  if (e == null || t == null)
    return e === t;
  if (!BA(e) || !BA(t))
    return !1;
  if (r) {
    for (let n = 0; n < e.length; n++)
      if (!r(e[n], t[n]))
        return !1;
  } else
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n])
        return !1;
  return !0;
}
const qA = [1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0], Ine = [0, 0, 0, 0, 0, 0];
GM();
const Mne = HM(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5), One = HM(-0.5, -0.5, 0, 0.5, 0.5, 1), Cne = HM(-0.5, -0.5, 0, 0.5, 0.5, 0.5);
function f4e(e) {
  switch (e) {
    case "sphere":
    case "cube":
    case "diamond":
      return Mne;
    case "cylinder":
    case "cone":
    case "inverted-cone":
      return One;
    case "tetrahedron":
      return Cne;
    default:
      return;
  }
}
const WM = ["butt", "square", "round"], kne = [...WM, "none"], dj = ["miter", "bevel", "round"];
var Jx;
let bc = Jx = class extends re {
  constructor(e) {
    super(e), this.color = new Me([0, 0, 0, 1]), this.size = al(1), this.pattern = null, this.patternCap = "butt";
  }
  clone() {
    const e = { color: this.color != null ? this.color.clone() : null, size: this.size, pattern: this.pattern != null ? this.pattern.clone() : null, patternCap: this.patternCap };
    return new Jx(e);
  }
};
u([d(Gu)], bc.prototype, "color", void 0), u([d(oa)], bc.prototype, "size", void 0), u([d(cj)], bc.prototype, "pattern", void 0), u([d({ type: WM, json: { default: "butt", write: { overridePolicy() {
  return { enabled: this.pattern != null };
} } } })], bc.prototype, "patternCap", void 0), bc = Jx = u([E("geoscene.symbols.support.Symbol3DOutline")], bc);
var a1;
let Ia = a1 = class extends pa {
  constructor(e) {
    super(e), this.type = "fill", this.material = null, this.pattern = null, this.castShadows = !0, this.outline = null, this.edges = null;
  }
  clone() {
    const e = { edges: this.edges != null ? this.edges.clone() : null, enabled: this.enabled, material: this.material != null ? this.material.clone() : null, pattern: this.pattern != null ? this.pattern.clone() : null, castShadows: this.castShadows, outline: this.outline != null ? this.outline.clone() : null };
    return new a1(e);
  }
  static fromSimpleFillSymbol(e) {
    var n, i, s;
    const t = e.outline && e.outline.style && e.outline.style !== "inside-frame" && e.outline.style !== "solid" ? new qM({ style: e.outline.style }) : null, r = { size: ((n = e.outline) == null ? void 0 : n.width) ?? 0, color: (((i = e.outline) == null ? void 0 : i.color) ?? wy).clone(), pattern: t };
    return t && ((s = e.outline) != null && s.cap) && (r.patternCap = e.outline.cap), new a1({ material: new _y({ color: (e.color ?? _ne).clone() }), pattern: e.style && e.style !== "solid" ? new uj({ style: e.style }) : null, outline: r });
  }
};
u([Ie({ Fill: "fill" }, { readOnly: !0 })], Ia.prototype, "type", void 0), u([d({ type: _y, json: { write: !0 } })], Ia.prototype, "material", void 0), u([d(wne)], Ia.prototype, "pattern", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], Ia.prototype, "castShadows", void 0), u([d({ type: bc, json: { write: !0 } })], Ia.prototype, "outline", void 0), u([d(nj)], Ia.prototype, "edges", void 0), Ia = a1 = u([E("geoscene.symbols.FillSymbol3DLayer")], Ia);
const Bg = Ia, Ane = ["none", "underline", "line-through"], Pne = ["normal", "italic", "oblique"], Rne = ["normal", "lighter", "bold", "bolder"], pj = { type: Number, cast: (e) => {
  const t = ls(e);
  return t === 0 ? 1 : ws(t, 0.1, 4);
}, nonNullable: !0 }, Lne = ["left", "right", "center"], Nne = ["baseline", "top", "middle", "bottom"], hj = { type: Lne, nonNullable: !0 }, fj = { type: Nne, nonNullable: !0 }, m4e = 8;
var Zx;
let Ma = Zx = class extends re {
  constructor(e) {
    super(e), this.decoration = "none", this.family = "sans-serif", this.size = 9, this.style = "normal", this.weight = "normal";
  }
  castSize(e) {
    return ut(e);
  }
  clone() {
    return new Zx({ decoration: this.decoration, family: this.family, size: this.size, style: this.style, weight: this.weight });
  }
  hash() {
    return `${this.decoration}.${this.family}.${this.size}.${this.style}.${this.weight}`;
  }
};
u([d({ type: Ane, json: { default: "none", write: !0 } })], Ma.prototype, "decoration", void 0), u([d({ type: String, json: { write: !0 } })], Ma.prototype, "family", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e, t, r) => ({ enabled: !r || !r.textSymbol3D }) } } })], Ma.prototype, "size", void 0), u([xt("size")], Ma.prototype, "castSize", null), u([d({ type: Pne, json: { default: "normal", write: !0 } })], Ma.prototype, "style", void 0), u([d({ type: Rne, json: { default: "normal", write: !0 } })], Ma.prototype, "weight", void 0), Ma = Zx = u([E("geoscene.symbols.Font")], Ma);
const v_ = Ma;
function hf(e, t) {
  const r = t && t.url && t.url.path;
  if (e && r && (e = cs(e, r, { preserveProtocolRelative: !0 }), t.portalItem && t.readResourcePaths)) {
    const n = tM(e, t.portalItem.itemUrl);
    n != null && Fne.test(n) && t.readResourcePaths.push(t.portalItem.resourceFromPath(n).path);
  }
  return Kx(e, t && t.portal);
}
function qg(e, t, r = tg.YES) {
  if (e == null)
    return e;
  !Ai(e) && t && t.blockedRelativeUrls && t.blockedRelativeUrls.push(e);
  let n = cs(e);
  if (t) {
    const i = t.verifyItemRelativeUrls && t.verifyItemRelativeUrls.rootPath || t.url && t.url.path;
    if (i) {
      const s = Kx(i, t.portal), o = Kx(n, t.portal);
      n = tM(o, s, s), n != null && n !== o && n !== e && t.verifyItemRelativeUrls && t.verifyItemRelativeUrls.writtenUrls.push(n);
    }
  }
  return n = yj(n, t == null ? void 0 : t.portal), Ai(n) && (n = ao(n)), t != null && t.resources && (t != null && t.portalItem) && !Ai(n) && !Kd(n) && r === tg.YES && t.resources.toKeep.push({ resource: t.portalItem.resourceFromPath(n), compress: !1 }), n;
}
function JM(e, t, r) {
  return hf(e, r);
}
function Nd(e, t, r, n) {
  const i = qg(e, n);
  i !== void 0 && (t[r] = i);
}
const mj = /\/items\/([^\/]+)\/resources\/(.*)/, Fne = /^\.\/resources\//;
function Dne(e) {
  const t = (e == null ? void 0 : e.match(mj)) ?? null;
  return (t == null ? void 0 : t[1]) ?? null;
}
function jne(e) {
  const t = (e == null ? void 0 : e.match(mj)) ?? null;
  if (t == null)
    return null;
  const r = t[2], n = r.lastIndexOf("/");
  if (n === -1) {
    const { path: o, extension: a } = Dk(r);
    return { prefix: null, filename: o, extension: a };
  }
  const { path: i, extension: s } = Dk(r.slice(n + 1));
  return { prefix: r.slice(0, n), filename: i, extension: s };
}
function yj(e, t) {
  return t && !t.isPortal && t.urlKey && t.customBaseUrl ? U$(e, `${t.urlKey}.${t.customBaseUrl}`, t.portalHostname) : e;
}
function Kx(e, t) {
  if (!t || t.isPortal || !t.urlKey || !t.customBaseUrl)
    return e;
  const r = `${t.urlKey}.${t.customBaseUrl}`, n = Y3();
  return Ph(n, `${n.scheme}://${r}`) ? U$(e, t.portalHostname, r) : U$(e, r, t.portalHostname);
}
var tg;
(function(e) {
  e[e.YES = 0] = "YES", e[e.NO = 1] = "NO";
})(tg || (tg = {}));
const y4e = Object.freeze(Object.defineProperty({ __proto__: null, get MarkKeep() {
  return tg;
}, ensureMainOnlineDomain: yj, fromJSON: hf, itemIdFromResourceUrl: Dne, prefixAndFilenameFromResourceUrl: jne, read: JM, toJSON: qg, write: Nd }, Symbol.toStringTag, { value: "Module" }));
var Yx;
const Vne = Mn()({ circle: "circle", square: "square", cross: "cross", x: "x", kite: "kite", triangle: "triangle" });
let wc = Yx = class extends re {
  constructor(e) {
    super(e);
  }
  readHref(e, t, r) {
    return e ? hf(e, r) : t.dataURI;
  }
  writeHref(e, t, r, n) {
    e && (Kd(e) ? t.dataURI = e : (t.href = qg(e, n), Ai(t.href) && (t.href = ao(t.href))));
  }
  clone() {
    return new Yx({ href: this.href, primitive: this.primitive });
  }
};
u([d({ type: String, json: { write: !0, read: { source: ["href", "dataURI"] } } })], wc.prototype, "href", void 0), u([ce("href")], wc.prototype, "readHref", null), u([ge("href", { href: { type: String }, dataURI: { type: String } })], wc.prototype, "writeHref", null), u([Ie(Vne)], wc.prototype, "primitive", void 0), wc = Yx = u([E("geoscene.symbols.support.IconSymbol3DLayerResource")], wc);
var Qx;
let ch = Qx = class extends Ae {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0;
  }
  clone() {
    return new Qx({ x: this.x, y: this.y });
  }
};
u([d({ type: Number })], ch.prototype, "x", void 0), u([d({ type: Number })], ch.prototype, "y", void 0), ch = Qx = u([E("geoscene.symbols.support.Symbol3DAnchorPosition2D")], ch);
var Xx;
let Om = Xx = class extends re {
  constructor(e) {
    super(e), this.color = new Me([0, 0, 0, 1]), this.size = al(1);
  }
  clone() {
    const e = { color: this.color != null ? this.color.clone() : null, size: this.size };
    return new Xx(e);
  }
};
u([d(Gu)], Om.prototype, "color", void 0), u([d(oa)], Om.prototype, "size", void 0), Om = Xx = u([E("geoscene.symbols.support.Symbol3DIconOutline")], Om);
var Ap;
const gj = "geoscene.symbols.IconSymbol3DLayer";
let Ao = Ap = class extends pa {
  constructor(e) {
    super(e), this.material = null, this.resource = null, this.type = "icon", this.size = 12, this.anchor = "center", this.anchorPosition = null, this.outline = null;
  }
  clone() {
    return new Ap({ anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), enabled: this.enabled, material: this.material != null ? this.material.clone() : null, outline: this.outline != null ? this.outline.clone() : null, resource: this.resource && this.resource.clone(), size: this.size });
  }
  static fromSimpleMarkerSymbol(e) {
    const t = e.color || wy, r = GA(e), n = e.outline && e.outline.width > 0 ? { size: e.outline.width, color: (e.outline.color || wy).clone() } : null;
    return new Ap({ size: e.size, resource: { primitive: Une(e.style) }, material: { color: t }, outline: n, anchor: r ? "relative" : void 0, anchorPosition: r });
  }
  static fromPictureMarkerSymbol(e) {
    const t = !e.color || Sne(e.color) ? wy : e.color, r = GA(e);
    return new Ap({ size: e.width <= e.height ? e.height : e.width, resource: { href: e.url }, material: { color: t.clone() }, anchor: r ? "relative" : void 0, anchorPosition: r });
  }
  static fromCIMSymbol(e) {
    return new Ap({ resource: { href: s6({ mediaType: "application/json", data: JSON.stringify(e.data) }) } });
  }
};
function GA(e) {
  const t = "width" in e ? e.width : e.size, r = "height" in e ? e.height : e.size, n = HA(e.xoffset), i = HA(e.yoffset);
  return (n || i) && t && r ? { x: -n / t, y: i / r } : null;
}
function HA(e) {
  return isFinite(e) ? e : 0;
}
u([d({ type: ms, json: { write: !0 } })], Ao.prototype, "material", void 0), u([d({ type: wc, json: { write: !0 } })], Ao.prototype, "resource", void 0), u([Ie({ Icon: "icon" }, { readOnly: !0 })], Ao.prototype, "type", void 0), u([d(oa)], Ao.prototype, "size", void 0), u([Ie({ center: "center", left: "left", right: "right", top: "top", bottom: "bottom", topLeft: "top-left", topRight: "top-right", bottomLeft: "bottom-left", bottomRight: "bottom-right", relative: "relative" }), d({ json: { default: "center" } })], Ao.prototype, "anchor", void 0), u([d({ type: ch, json: { type: [Number], read: { reader: (e) => new ch({ x: e[0], y: e[1] }) }, write: { writer: (e, t) => {
  t.anchorPosition = [e.x, e.y];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], Ao.prototype, "anchorPosition", void 0), u([d({ type: Om, json: { write: !0 } })], Ao.prototype, "outline", void 0), Ao = Ap = u([E(gj)], Ao);
const zne = { circle: "circle", cross: "cross", diamond: "kite", square: "square", x: "x", triangle: "triangle", path: null };
function Une(e) {
  return zne[e] || (se.getLogger(gj).warn(`${e} cannot be mapped to Icon symbol. Fallback to "circle"`), "circle");
}
const rd = Ao;
let _c = class extends Rt(re) {
  constructor(t) {
    super(t), this.type = "style", this.placement = "begin-end", this.style = "arrow", this.color = null;
  }
  equals(t) {
    return t != null && t.placement === this.placement && t.style === this.style && (this.color == null && t.color == null || this.color != null && t.color != null && this.color.toJSON() === t.color.toJSON());
  }
};
u([d({ type: ["style"], readOnly: !0, json: { read: !0, write: { ignoreOrigin: !0 } } })], _c.prototype, "type", void 0), u([d({ type: mne, json: { default: "begin-end", write: !0 } })], _c.prototype, "placement", void 0), u([d({ type: sj, json: { default: "arrow", write: !0 } })], _c.prototype, "style", void 0), u([d({ type: Me, json: { type: [Ot], default: null, write: !0 } })], _c.prototype, "color", void 0), _c = u([E("geoscene.symbols.LineStyleMarker3D")], _c);
const eT = _c;
var l1;
let Po = l1 = class extends pa {
  constructor(e) {
    super(e), this.material = null, this.type = "line", this.join = "miter", this.cap = "butt", this.size = al(1), this.pattern = null, this.marker = null;
  }
  clone() {
    const e = { enabled: this.enabled, material: this.material != null ? this.material.clone() : null, size: this.size, join: this.join, cap: this.cap, pattern: this.pattern != null ? this.pattern.clone() : null, marker: this.marker != null ? this.marker.clone() : null };
    return new l1(e);
  }
  static fromSimpleLineSymbol(e) {
    var r;
    const t = { enabled: !0, size: e.width ?? al(1), cap: e.cap || "butt", join: e.join || "miter", pattern: e.style && e.style !== "inside-frame" ? new qM({ style: e.style }) : null, material: new ms({ color: (e.color || wy).clone() }), marker: e.marker ? new eT({ placement: e.marker.placement, style: e.marker.style, color: ((r = e.marker.color) == null ? void 0 : r.clone()) ?? null }) : null };
    return new l1(t);
  }
};
u([d({ type: ms, json: { write: !0 } })], Po.prototype, "material", void 0), u([Ie({ Line: "line" }, { readOnly: !0 })], Po.prototype, "type", void 0), u([d({ type: dj, json: { write: !0, default: "miter" } })], Po.prototype, "join", void 0), u([d({ type: WM, json: { write: !0, default: "butt" } })], Po.prototype, "cap", void 0), u([d(oa)], Po.prototype, "size", void 0), u([d(cj)], Po.prototype, "pattern", void 0), u([d({ types: { key: "type", base: eT, typeMap: { style: eT } }, json: { write: !0 } })], Po.prototype, "marker", void 0), Po = l1 = u([E("geoscene.symbols.LineSymbol3DLayer")], Po);
const Gg = Po;
var tT;
const Bne = Mn()({ sphere: "sphere", cylinder: "cylinder", cube: "cube", cone: "cone", diamond: "diamond", tetrahedron: "tetrahedron", invertedCone: "inverted-cone" });
let Cm = tT = class extends re {
  clone() {
    return new tT({ href: this.href, primitive: this.primitive });
  }
};
u([d({ type: String, json: { read: JM, write: Nd } })], Cm.prototype, "href", void 0), u([Ie(Bne)], Cm.prototype, "primitive", void 0), Cm = tT = u([E("geoscene.symbols.support.ObjectSymbol3DLayerResource")], Cm);
var rT;
let Jc = rT = class extends Ae {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0, this.z = 0;
  }
  clone() {
    return new rT({ x: this.x, y: this.y, z: this.z });
  }
};
u([d({ type: Number })], Jc.prototype, "x", void 0), u([d({ type: Number })], Jc.prototype, "y", void 0), u([d({ type: Number })], Jc.prototype, "z", void 0), Jc = rT = u([E("geoscene.symbols.support.Symbol3DAnchorPosition3D")], Jc);
var nT;
let vn = nT = class extends pa {
  constructor(e) {
    super(e), this.material = null, this.castShadows = !0, this.resource = null, this.type = "object", this.width = void 0, this.height = void 0, this.depth = void 0, this.anchor = void 0, this.anchorPosition = void 0, this.heading = void 0, this.tilt = void 0, this.roll = void 0;
  }
  clone() {
    return new nT({ heading: this.heading, tilt: this.tilt, roll: this.roll, anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), depth: this.depth, enabled: this.enabled, height: this.height, material: this.material != null ? this.material.clone() : null, castShadows: this.castShadows, resource: this.resource && this.resource.clone(), width: this.width });
  }
  get isPrimitive() {
    return !this.resource || typeof this.resource.href != "string";
  }
};
u([d({ type: ms, json: { write: !0 } })], vn.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], vn.prototype, "castShadows", void 0), u([d({ type: Cm, json: { write: !0 } })], vn.prototype, "resource", void 0), u([Ie({ Object: "object" }, { readOnly: !0 })], vn.prototype, "type", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "width", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "height", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "depth", void 0), u([Ie({ center: "center", top: "top", bottom: "bottom", origin: "origin", relative: "relative" }), d({ json: { default: "origin" } })], vn.prototype, "anchor", void 0), u([d({ type: Jc, json: { type: [Number], read: { reader: (e) => new Jc({ x: e[0], y: e[1], z: e[2] }) }, write: { writer: (e, t) => {
  t.anchorPosition = [e.x, e.y, e.z];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], vn.prototype, "anchorPosition", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "heading", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "tilt", void 0), u([d({ type: Number, json: { write: !0 } })], vn.prototype, "roll", void 0), u([d({ readOnly: !0 })], vn.prototype, "isPrimitive", null), vn = nT = u([E("geoscene.symbols.ObjectSymbol3DLayer")], vn);
const ZM = vn;
var iT;
let Ln = iT = class extends pa {
  constructor(e) {
    super(e), this.material = null, this.castShadows = !0, this.type = "path", this.profile = "circle", this.join = "miter", this.cap = "butt", this.width = void 0, this.height = void 0, this.anchor = "center", this.profileRotation = "all";
  }
  readWidth(e, t) {
    return e ?? (t.height == null && t.size != null ? t.size : void 0);
  }
  readHeight(e, t) {
    return e ?? (t.width == null && t.size != null ? t.size : void 0);
  }
  clone() {
    return new iT({ enabled: this.enabled, material: this.material != null ? this.material.clone() : null, castShadows: this.castShadows, profile: this.profile, join: this.join, cap: this.cap, width: this.width, height: this.height, profileRotation: this.profileRotation, anchor: this.anchor });
  }
};
u([d({ type: ms, json: { write: !0 } })], Ln.prototype, "material", void 0), u([d({ type: Boolean, nonNullable: !0, json: { write: !0, default: !0 } })], Ln.prototype, "castShadows", void 0), u([Ie({ Path: "path" }, { readOnly: !0 })], Ln.prototype, "type", void 0), u([d({ type: ["circle", "quad"], json: { write: !0, default: "circle" } })], Ln.prototype, "profile", void 0), u([d({ type: dj, json: { write: !0, default: "miter" } })], Ln.prototype, "join", void 0), u([d({ type: kne, json: { write: !0, default: "butt" } })], Ln.prototype, "cap", void 0), u([d({ type: Number, json: { write: { enabled: !0, target: { width: { type: Number }, size: { type: Number } } } } })], Ln.prototype, "width", void 0), u([ce("width", ["width", "size", "height"])], Ln.prototype, "readWidth", null), u([d({ type: Number, json: { write: !0 } })], Ln.prototype, "height", void 0), u([ce("height", ["height", "size", "width"])], Ln.prototype, "readHeight", null), u([d({ type: ["center", "bottom", "top"], json: { write: !0, default: "center" } })], Ln.prototype, "anchor", void 0), u([d({ type: ["heading", "all"], json: { write: !0, default: "all" } })], Ln.prototype, "profileRotation", void 0), Ln = iT = u([E("geoscene.symbols.PathSymbol3DLayer")], Ln);
const KM = Ln;
var sT;
let dh = sT = class extends re {
  constructor() {
    super(...arguments), this.color = new Me([0, 0, 0, 1]), this.size = 0;
  }
  clone() {
    const e = { color: j(this.color), size: this.size };
    return new sT(e);
  }
};
u([d(Gu)], dh.prototype, "color", void 0), u([d(oa)], dh.prototype, "size", void 0), dh = sT = u([E("geoscene.symbols.support.Symbol3DHalo")], dh);
let Sy = class extends Rt(re) {
  constructor(t) {
    super(t), this.color = null;
  }
};
u([d(Gu)], Sy.prototype, "color", void 0), Sy = u([E("geoscene.symbols.support.Symbol3DTextBackground")], Sy);
var u1;
let ei = u1 = class extends pa {
  constructor(e) {
    super(e), this._userSize = void 0, this.halo = null, this.horizontalAlignment = "center", this.lineHeight = 1, this.material = null, this.background = null, this.text = null, this.type = "text", this.verticalAlignment = "baseline";
  }
  get font() {
    return this._get("font") || null;
  }
  set font(e) {
    e != null && this._userSize != null && (e.size = this._userSize), this._set("font", e);
  }
  writeFont(e, t, r, n) {
    const i = { ...n, textSymbol3D: !0 };
    t.font = e.write({}, i), delete t.font.size;
  }
  get size() {
    return this._userSize != null ? this._userSize : this.font != null && this.font.size != null ? this.font.size : 9;
  }
  set size(e) {
    this._userSize = e, this.font != null && (this.font.size = this._userSize), this.notifyChange("size");
  }
  clone() {
    const e = new u1({ enabled: this.enabled, font: this.font && j(this.font), halo: this.halo && j(this.halo), horizontalAlignment: this.horizontalAlignment, lineHeight: this.lineHeight, material: this.material != null ? this.material.clone() : null, text: this.text, verticalAlignment: this.verticalAlignment, background: j(this.background) });
    return e._userSize = this._userSize, e;
  }
  static fromTextSymbol(e) {
    return new u1({ font: e.font != null ? e.font.clone() : new v_(), halo: qne(e.haloColor, e.haloSize), horizontalAlignment: e.horizontalAlignment, lineHeight: e.lineHeight, material: e.color ? new ms({ color: e.color.clone() }) : null, text: e.text, verticalAlignment: e.verticalAlignment, background: e.backgroundColor ? new Sy({ color: e.backgroundColor.clone() }) : null });
  }
};
function qne(e, t) {
  return e && t != null && t > 0 ? new dh({ color: j(e), size: t }) : null;
}
u([d({ type: v_, json: { write: !0 } })], ei.prototype, "font", null), u([ge("font")], ei.prototype, "writeFont", null), u([d({ type: dh, json: { write: !0 } })], ei.prototype, "halo", void 0), u([d({ ...hj, json: { default: "center", write: !0 } })], ei.prototype, "horizontalAlignment", void 0), u([d({ ...pj, json: { default: 1, write: !0 } })], ei.prototype, "lineHeight", void 0), u([d({ type: ms, json: { write: !0 } })], ei.prototype, "material", void 0), u([d({ type: Sy, json: { write: !0 } })], ei.prototype, "background", void 0), u([d(oa)], ei.prototype, "size", null), u([d({ type: String, json: { write: !0 } })], ei.prototype, "text", void 0), u([Ie({ Text: "text" }, { readOnly: !0 })], ei.prototype, "type", void 0), u([d({ ...fj, json: { default: "baseline", write: !0 } })], ei.prototype, "verticalAlignment", void 0), ei = u1 = u([E("geoscene.symbols.TextSymbol3DLayer")], ei);
const ff = ei;
var oT;
let Ul = oT = class extends pa {
  constructor(e) {
    super(e), this.color = aT.clone(), this.type = "water", this.waterbodySize = "medium", this.waveDirection = null, this.waveStrength = "moderate";
  }
  clone() {
    return new oT({ color: j(this.color), waterbodySize: this.waterbodySize, waveDirection: this.waveDirection, waveStrength: this.waveStrength });
  }
};
u([d({ type: Me, nonNullable: !0, json: { type: [Ot], write: (e, t, r) => t[r] = e.toArray(Me.AlphaMode.UNLESS_OPAQUE), default: () => aT.clone(), defaultEquals: (e) => e.toCss(!0) === aT.toCss(!0) } })], Ul.prototype, "color", void 0), u([Ie({ Water: "water" }, { readOnly: !0 })], Ul.prototype, "type", void 0), u([d({ type: ["small", "medium", "large"], json: { write: !0, default: "medium" } })], Ul.prototype, "waterbodySize", void 0), u([d({ type: Number, json: { write: !0, default: null } })], Ul.prototype, "waveDirection", void 0), u([d({ type: ["calm", "rippled", "slight", "moderate"], json: { write: !0, default: "moderate" } })], Ul.prototype, "waveStrength", void 0), Ul = oT = u([E("geoscene.symbols.WaterSymbol3DLayer")], Ul);
const aT = new Me([0, 119, 190]), vj = Ul;
var lT;
let Sc = lT = class extends Ae {
  constructor(e) {
    super(e), this.name = null, this.styleUrl = null, this.styleName = null, this.portal = null;
  }
  clone() {
    return new lT({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
};
u([d({ type: String })], Sc.prototype, "name", void 0), u([d({ type: String })], Sc.prototype, "styleUrl", void 0), u([d({ type: String })], Sc.prototype, "styleName", void 0), u([d({ type: pi })], Sc.prototype, "portal", void 0), Sc = lT = u([E("geoscene.symbols.support.StyleOrigin")], Sc);
const uT = Sc;
var cT;
let $y = cT = class extends Ae {
  constructor() {
    super(...arguments), this.url = "";
  }
  clone() {
    return new cT({ url: this.url });
  }
};
u([d({ type: String })], $y.prototype, "url", void 0), $y = cT = u([E("geoscene.symbols.support.Thumbnail")], $y);
const bj = { icon: rd, object: ZM, line: Gg, path: KM, fill: Bg, extrude: ij, text: ff, water: vj }, Gne = je.ofType({ base: pa, key: "type", typeMap: bj, errorContext: "symbol-layer" });
let Ro = class extends hi {
  constructor(t) {
    super(t), this.styleOrigin = null, this.thumbnail = null, this.type = null;
    const r = this.__accessor__ && this.__accessor__.metadatas && this.__accessor__.metadatas.symbolLayers, n = r && r.type || je;
    this._set("symbolLayers", new n());
  }
  get color() {
    return null;
  }
  set color(t) {
    this.constructed && se.getLogger(this).error("Symbol3D does not support colors on the symbol level. Colors may be set on individual symbol layer materials instead.");
  }
  set symbolLayers(t) {
    Ed(t, this._get("symbolLayers"));
  }
  readStyleOrigin(t, r, n) {
    if (t.styleUrl && t.name) {
      const i = hf(t.styleUrl, n);
      return new uT({ styleUrl: i, name: t.name });
    }
    if (t.styleName && t.name)
      return new uT({ portal: n && n.portal || pi.getDefault(), styleName: t.styleName, name: t.name });
    n && n.messages && n.messages.push(new bs("symbol3d:incomplete-style-origin", "Style origin requires either a 'styleUrl' or 'styleName' and a 'name' property", { context: n, definition: t }));
  }
  writeStyleOrigin(t, r, n, i) {
    if (t.styleUrl && t.name) {
      let s = qg(t.styleUrl, i);
      Ai(s) && (s = ao(s)), r.styleOrigin = { styleUrl: s, name: t.name };
    } else
      t.styleName && t.name && (t.portal && i && i.portal && !n6(t.portal.restUrl, i.portal.restUrl) ? i && i.messages && i.messages.push(new bs("symbol:cross-portal", "The symbol style origin cannot be persisted because it refers to an item on a different portal than the one being saved to.", { symbol: this })) : r.styleOrigin = { styleName: t.styleName, name: t.name });
  }
  normalizeCtorArgs(t) {
    return t instanceof pa || t && bj[t.type] ? { symbolLayers: [t] } : Array.isArray(t) ? { symbolLayers: t } : t;
  }
};
u([d({ json: { read: !1, write: !1 } })], Ro.prototype, "color", null), u([d({ type: Gne, nonNullable: !0, json: { write: !0 } }), xt(GF)], Ro.prototype, "symbolLayers", null), u([d({ type: uT })], Ro.prototype, "styleOrigin", void 0), u([ce("styleOrigin")], Ro.prototype, "readStyleOrigin", null), u([ge("styleOrigin", { "styleOrigin.styleUrl": { type: String }, "styleOrigin.styleName": { type: String }, "styleOrigin.name": { type: String } })], Ro.prototype, "writeStyleOrigin", null), u([d({ type: $y, json: { read: !1 } })], Ro.prototype, "thumbnail", void 0), u([d({ type: ["point-3d", "line-3d", "polygon-3d", "mesh-3d", "label-3d"], readOnly: !0 })], Ro.prototype, "type", void 0), Ro = u([E("geoscene.symbols.Symbol3D")], Ro);
const mf = Ro;
let km = class extends re {
  constructor(t) {
    super(t), this.visible = !0;
  }
  clone() {
  }
};
u([d({ type: ["line"], readOnly: !0, json: { read: !1, write: { ignoreOrigin: !0 } } })], km.prototype, "type", void 0), u([d({ readOnly: !0 })], km.prototype, "visible", void 0), km = u([E("geoscene.symbols.callouts.Callout3D")], km);
const wj = km;
var dT;
let c1 = dT = class extends re {
  constructor() {
    super(...arguments), this.color = new Me("white");
  }
  clone() {
    return new dT({ color: j(this.color) });
  }
};
u([d(Gu)], c1.prototype, "color", void 0), c1 = dT = u([E("geoscene.symbols.callouts.LineCallout3DBorder")], c1);
const _j = c1;
Object.freeze(Object.defineProperty({ __proto__: null, default: _j }, Symbol.toStringTag, { value: "Module" }));
var pT;
let Bl = pT = class extends wj {
  constructor(e) {
    super(e), this.type = "line", this.color = new Me([0, 0, 0, 1]), this.size = al(1), this.border = null;
  }
  get visible() {
    return this.size > 0 && this.color != null && this.color.a > 0;
  }
  clone() {
    return new pT({ color: j(this.color), size: this.size, border: j(this.border) });
  }
};
u([Ie({ line: "line" }, { readOnly: !0 })], Bl.prototype, "type", void 0), u([d(Gu)], Bl.prototype, "color", void 0), u([d(oa)], Bl.prototype, "size", void 0), u([d({ type: _j, json: { write: !0 } })], Bl.prototype, "border", void 0), u([d({ readOnly: !0 })], Bl.prototype, "visible", null), Bl = pT = u([E("geoscene.symbols.callouts.LineCallout3D")], Bl);
const Hne = Bl;
function YM(e) {
  if (!e)
    return !1;
  const t = e.verticalOffset;
  return !!t && !(t.screenLength <= 0 || t.maxWorldLength != null && t.maxWorldLength <= 0);
}
function Sj(e) {
  if (!e || !e.supportsCallout || !e.supportsCallout())
    return !1;
  const t = e.callout;
  return !!t && !!t.visible && !!YM(e);
}
const $j = { types: { key: "type", base: wj, typeMap: { line: Hne } }, json: { write: !0 } };
var hT;
let Pp = hT = class extends re {
  constructor(e) {
    super(e), this.screenLength = 0, this.minWorldLength = 0, this.maxWorldLength = null;
  }
  clone() {
    return new hT({ screenLength: this.screenLength, minWorldLength: this.minWorldLength, maxWorldLength: this.maxWorldLength });
  }
};
u([d(oa)], Pp.prototype, "screenLength", void 0), u([d({ type: Number, nonNullable: !0, json: { write: !0, default: 0 } })], Pp.prototype, "minWorldLength", void 0), u([d({ type: Number, json: { write: !0 } })], Pp.prototype, "maxWorldLength", void 0), Pp = hT = u([E("geoscene.symbols.support.Symbol3DVerticalOffset")], Pp);
const xj = Pp;
var d1;
const Tj = je.ofType({ base: null, key: "type", typeMap: { text: ff } });
let ql = d1 = class extends mf {
  constructor(e) {
    super(e), this.verticalOffset = null, this.callout = null, this.styleOrigin = null, this.symbolLayers = new Tj(), this.type = "label-3d";
  }
  supportsCallout() {
    return !0;
  }
  hasVisibleCallout() {
    return Sj(this);
  }
  hasVisibleVerticalOffset() {
    return YM(this);
  }
  clone() {
    return new d1({ styleOrigin: j(this.styleOrigin), symbolLayers: j(this.symbolLayers), thumbnail: j(this.thumbnail), callout: j(this.callout), verticalOffset: j(this.verticalOffset) });
  }
  static fromTextSymbol(e) {
    return new d1({ symbolLayers: [ff.fromTextSymbol(e)] });
  }
};
u([d({ type: xj, json: { write: !0 } })], ql.prototype, "verticalOffset", void 0), u([d($j)], ql.prototype, "callout", void 0), u([d({ json: { read: !1, write: !1 } })], ql.prototype, "styleOrigin", void 0), u([d({ type: Tj })], ql.prototype, "symbolLayers", void 0), u([Ie({ LabelSymbol3D: "label-3d" }, { readOnly: !0 })], ql.prototype, "type", void 0), ql = d1 = u([E("geoscene.symbols.LabelSymbol3D")], ql);
const b_ = ql;
var p1;
const Ej = je.ofType({ base: null, key: "type", typeMap: { line: Gg, path: KM } }), Wne = je.ofType({ base: null, key: "type", typeMap: { line: Gg, path: KM } });
let Am = p1 = class extends mf {
  constructor(e) {
    super(e), this.symbolLayers = new Ej(), this.type = "line-3d";
  }
  clone() {
    return new p1({ styleOrigin: j(this.styleOrigin), symbolLayers: j(this.symbolLayers), thumbnail: j(this.thumbnail) });
  }
  static fromSimpleLineSymbol(e) {
    return new p1({ symbolLayers: [Gg.fromSimpleLineSymbol(e)] });
  }
};
u([d({ type: Ej, json: { type: Wne } })], Am.prototype, "symbolLayers", void 0), u([Ie({ LineSymbol3D: "line-3d" }, { readOnly: !0 })], Am.prototype, "type", void 0), Am = p1 = u([E("geoscene.symbols.LineSymbol3D")], Am);
const w_ = Am;
let Gl = class extends hi {
  constructor(t) {
    super(t), this.angle = 0, this.type = null, this.xoffset = 0, this.yoffset = 0, this.size = 9;
  }
  hash() {
    return `${this.type}.${this.angle}.${this.size}.${this.xoffset}.${this.yoffset}`;
  }
};
u([d({ type: Number, json: { read: (e) => e && -1 * e, write: (e, t) => t.angle = e && -1 * e } })], Gl.prototype, "angle", void 0), u([d({ type: ["simple-marker", "picture-marker"], readOnly: !0 })], Gl.prototype, "type", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Gl.prototype, "xoffset", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Gl.prototype, "yoffset", void 0), u([d({ type: Number, cast: (e) => e === "auto" ? e : ut(e), json: { write: !0 } })], Gl.prototype, "size", void 0), Gl = u([E("geoscene.symbols.MarkerSymbol")], Gl);
const Ij = Gl;
var h1;
const Mj = je.ofType({ base: null, key: "type", typeMap: { fill: Bg } });
let Pm = h1 = class extends mf {
  constructor(e) {
    super(e), this.symbolLayers = new Mj(), this.type = "mesh-3d";
  }
  clone() {
    return new h1({ styleOrigin: j(this.styleOrigin), symbolLayers: j(this.symbolLayers), thumbnail: j(this.thumbnail) });
  }
  static fromSimpleFillSymbol(e) {
    return new h1({ symbolLayers: [Bg.fromSimpleFillSymbol(e)] });
  }
};
u([d({ type: Mj })], Pm.prototype, "symbolLayers", void 0), u([Ie({ MeshSymbol3D: "mesh-3d" }, { readOnly: !0 })], Pm.prototype, "type", void 0), Pm = h1 = u([E("geoscene.symbols.MeshSymbol3D")], Pm);
const __ = Pm;
function Jne(e, t, r) {
  return t.imageData ? s6({ mediaType: t.contentType || "image/png", isBase64: !0, data: t.imageData }) : Oj(t.url, r);
}
function Oj(e, t) {
  var r;
  return Kne(t) && !Ai(e) && ((r = t == null ? void 0 : t.layer) != null && r.parsedUrl) ? Rh(t.layer.parsedUrl.path, "images", e) : hf(e, t);
}
function Zne(e, t, r, n) {
  if (Kd(e)) {
    const i = Hy(e);
    if (!i)
      return;
    t.contentType = i.mediaType, t.imageData = i.data, r && r.imageData === t.imageData && r.url && Nd(r.url, t, "url", n);
  } else
    Nd(e, t, "url", n);
}
const Cj = { json: { read: { source: ["imageData", "url"], reader: Jne }, write: { writer(e, t, r, n) {
  Zne(e, t, this.source, n);
} } } }, kj = { readOnly: !0, json: { read: { source: ["imageData", "url"], reader(e, t, r) {
  const n = {};
  return t.imageData && (n.imageData = t.imageData), t.contentType && (n.contentType = t.contentType), t.url && (n.url = Oj(t.url, r)), n;
} } } };
function Kne(e) {
  var t, r;
  return !(e == null || e.origin !== "service" && e.origin !== "portal-item" || ((t = e.layer) == null ? void 0 : t.type) !== "feature" && ((r = e.layer) == null ? void 0 : r.type) !== "stream");
}
var fT;
let Xi = fT = class extends oj {
  constructor(...e) {
    super(...e), this.type = "picture-fill", this.url = null, this.xscale = 1, this.yscale = 1, this.width = 12, this.height = 12, this.xoffset = 0, this.yoffset = 0, this.source = null;
  }
  normalizeCtorArgs(e, t, r, n) {
    if (e && typeof e != "string" && e.imageData == null)
      return e;
    const i = {};
    return e && (i.url = e), t && (i.outline = t), r != null && (i.width = ut(r)), n != null && (i.height = ut(n)), i;
  }
  clone() {
    const e = new fT({ color: j(this.color), height: this.height, outline: this.outline && this.outline.clone(), url: this.url, width: this.width, xoffset: this.xoffset, xscale: this.xscale, yoffset: this.yoffset, yscale: this.yscale });
    return e._set("source", j(this.source)), e;
  }
  hash() {
    var e;
    return `${super.hash()}.${(e = this.color) == null ? void 0 : e.hash()}.${this.height}.${this.url}.${this.width}.${this.xoffset}.${this.xscale}.${this.yoffset}.${this.yscale}`;
  }
};
u([Ie({ esriPFS: "picture-fill" }, { readOnly: !0 })], Xi.prototype, "type", void 0), u([d(Cj)], Xi.prototype, "url", void 0), u([d({ type: Number, json: { write: !0 } })], Xi.prototype, "xscale", void 0), u([d({ type: Number, json: { write: !0 } })], Xi.prototype, "yscale", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Xi.prototype, "width", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Xi.prototype, "height", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Xi.prototype, "xoffset", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Xi.prototype, "yoffset", void 0), u([d(kj)], Xi.prototype, "source", void 0), Xi = fT = u([E("geoscene.symbols.PictureFillSymbol")], Xi);
const Aj = Xi;
var mT;
let js = mT = class extends Ij {
  constructor(...e) {
    super(...e), this.color = null, this.type = "picture-marker", this.url = null, this.source = null, this.height = 12, this.width = 12, this.size = null;
  }
  normalizeCtorArgs(e, t, r) {
    if (e && typeof e != "string" && e.imageData == null)
      return e;
    const n = {};
    return e && (n.url = e), t != null && (n.width = ut(t)), r != null && (n.height = ut(r)), n;
  }
  readHeight(e, t) {
    return t.size || e;
  }
  readWidth(e, t) {
    return t.size || e;
  }
  clone() {
    const e = new mT({ angle: this.angle, height: this.height, url: this.url, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
    return e._set("source", j(this.source)), e;
  }
  hash() {
    return `${super.hash()}.${this.height}.${this.url}.${this.width}`;
  }
};
u([d({ json: { write: !1 } })], js.prototype, "color", void 0), u([Ie({ esriPMS: "picture-marker" }, { readOnly: !0 })], js.prototype, "type", void 0), u([d(Cj)], js.prototype, "url", void 0), u([d(kj)], js.prototype, "source", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], js.prototype, "height", void 0), u([ce("height", ["height", "size"])], js.prototype, "readHeight", null), u([d({ type: Number, cast: ut, json: { write: !0 } })], js.prototype, "width", void 0), u([d({ json: { write: !1 } })], js.prototype, "size", void 0), js = mT = u([E("geoscene.symbols.PictureMarkerSymbol")], js);
const S_ = js;
var $c;
const Pj = je.ofType({ base: null, key: "type", typeMap: { icon: rd, object: ZM, text: ff } });
let xc = $c = class extends mf {
  constructor(e) {
    super(e), this.verticalOffset = null, this.callout = null, this.symbolLayers = new Pj(), this.type = "point-3d";
  }
  supportsCallout() {
    if ((this.symbolLayers ? this.symbolLayers.length : 0) < 1)
      return !1;
    for (const e of this.symbolLayers.items)
      switch (e.type) {
        case "icon":
        case "text":
        case "object":
          continue;
        default:
          return !1;
      }
    return !0;
  }
  hasVisibleCallout() {
    return Sj(this);
  }
  hasVisibleVerticalOffset() {
    return YM(this);
  }
  clone() {
    return new $c({ verticalOffset: j(this.verticalOffset), callout: j(this.callout), styleOrigin: j(this.styleOrigin), symbolLayers: j(this.symbolLayers), thumbnail: j(this.thumbnail) });
  }
  static fromSimpleMarkerSymbol(e) {
    return new $c({ symbolLayers: [rd.fromSimpleMarkerSymbol(e)] });
  }
  static fromPictureMarkerSymbol(e) {
    return new $c({ symbolLayers: [rd.fromPictureMarkerSymbol(e)] });
  }
  static fromCIMSymbol(e) {
    var n, i;
    if (((i = (n = e.data) == null ? void 0 : n.symbol) == null ? void 0 : i.type) !== "CIMPointSymbol")
      return null;
    const r = e.data.symbol;
    return new $c(r != null && r.callout ? { symbolLayers: [rd.fromCIMSymbol(e)], callout: { type: "line", size: 0.5, color: [0, 0, 0] }, verticalOffset: { screenLength: 40 } } : { symbolLayers: [rd.fromCIMSymbol(e)] });
  }
  static fromTextSymbol(e) {
    return new $c({ symbolLayers: [ff.fromTextSymbol(e)] });
  }
};
u([d({ type: xj, json: { write: !0 } })], xc.prototype, "verticalOffset", void 0), u([d($j)], xc.prototype, "callout", void 0), u([d({ type: Pj, json: { origins: { "web-scene": { write: !0 } } } })], xc.prototype, "symbolLayers", void 0), u([Ie({ PointSymbol3D: "point-3d" }, { readOnly: !0 })], xc.prototype, "type", void 0), xc = $c = u([E("geoscene.symbols.PointSymbol3D")], xc);
const nd = xc;
var Rm;
const Rj = je.ofType({ base: null, key: "type", typeMap: { extrude: ij, fill: Bg, icon: rd, line: Gg, object: ZM, text: ff, water: vj } });
let Lm = Rm = class extends mf {
  constructor(e) {
    super(e), this.symbolLayers = new Rj(), this.type = "polygon-3d";
  }
  clone() {
    return new Rm({ styleOrigin: j(this.styleOrigin), symbolLayers: j(this.symbolLayers), thumbnail: j(this.thumbnail) });
  }
  static fromJSON(e) {
    const t = new Rm();
    if (t.read(e), t.symbolLayers.length === 2 && t.symbolLayers.at(0).type === "fill" && t.symbolLayers.at(1).type === "line") {
      const r = t.symbolLayers.at(0), n = t.symbolLayers.at(1);
      !n.enabled || e.symbolLayers && e.symbolLayers[1] && e.symbolLayers[1].enable === !1 || (r.outline = { size: n.size, color: n.material != null ? n.material.color : null }), t.symbolLayers.removeAt(1);
    }
    return t;
  }
  static fromSimpleFillSymbol(e) {
    return new Rm({ symbolLayers: [Bg.fromSimpleFillSymbol(e)] });
  }
};
u([d({ type: Rj, json: { write: !0 } })], Lm.prototype, "symbolLayers", void 0), u([Ie({ PolygonSymbol3D: "polygon-3d" }, { readOnly: !0 })], Lm.prototype, "type", void 0), Lm = Rm = u([E("geoscene.symbols.PolygonSymbol3D")], Lm);
const Hg = Lm;
var yT;
const Q2 = new et({ esriSFSSolid: "solid", esriSFSNull: "none", esriSFSHorizontal: "horizontal", esriSFSVertical: "vertical", esriSFSForwardDiagonal: "forward-diagonal", esriSFSBackwardDiagonal: "backward-diagonal", esriSFSCross: "cross", esriSFSDiagonalCross: "diagonal-cross" });
let Tc = yT = class extends oj {
  constructor(...e) {
    super(...e), this.color = new Me([0, 0, 0, 0.25]), this.outline = new ji(), this.type = "simple-fill", this.style = "solid";
  }
  normalizeCtorArgs(e, t, r) {
    if (e && typeof e != "string")
      return e;
    const n = {};
    return e && (n.style = e), t && (n.outline = t), r && (n.color = r), n;
  }
  clone() {
    return new yT({ color: j(this.color), outline: this.outline && this.outline.clone(), style: this.style });
  }
  hash() {
    return `${super.hash()}${this.style}.${this.color && this.color.hash()}`;
  }
};
u([d()], Tc.prototype, "color", void 0), u([d()], Tc.prototype, "outline", void 0), u([Ie({ esriSFS: "simple-fill" }, { readOnly: !0 })], Tc.prototype, "type", void 0), u([d({ type: Q2.apiValues, json: { read: Q2.read, write: Q2.write } })], Tc.prototype, "style", void 0), Tc = yT = u([E("geoscene.symbols.SimpleFillSymbol")], Tc);
const ep = Tc;
var gT;
const X2 = new et({ esriSMSCircle: "circle", esriSMSSquare: "square", esriSMSCross: "cross", esriSMSX: "x", esriSMSDiamond: "diamond", esriSMSTriangle: "triangle", esriSMSPath: "path" });
let Lo = gT = class extends Ij {
  constructor(...e) {
    super(...e), this.color = new Me([255, 255, 255, 0.25]), this.type = "simple-marker", this.size = 12, this.style = "circle", this.outline = new ji();
  }
  normalizeCtorArgs(e, t, r, n) {
    if (e && typeof e != "string")
      return e;
    const i = {};
    return e && (i.style = e), t != null && (i.size = ut(t)), r && (i.outline = r), n && (i.color = n), i;
  }
  writeColor(e, t) {
    e && this.style !== "x" && this.style !== "cross" && (t.color = e.toJSON()), e === null && (t.color = null);
  }
  set path(e) {
    this.style = "path", this._set("path", e);
  }
  clone() {
    return new gT({ angle: this.angle, color: j(this.color), outline: this.outline && this.outline.clone(), path: this.path, size: this.size, style: this.style, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    var e;
    return `${super.hash()}.${this.color && this.color.hash()}.${this.path}.${this.style}.${(e = this.outline) == null ? void 0 : e.hash()}`;
  }
};
u([d()], Lo.prototype, "color", void 0), u([ge("color")], Lo.prototype, "writeColor", null), u([Ie({ esriSMS: "simple-marker" }, { readOnly: !0 })], Lo.prototype, "type", void 0), u([d()], Lo.prototype, "size", void 0), u([d({ type: X2.apiValues, json: { read: X2.read, write: X2.write } })], Lo.prototype, "style", void 0), u([d({ type: String, json: { write: !0 } })], Lo.prototype, "path", null), u([d({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": ji } }, json: { default: null, write: !0 } })], Lo.prototype, "outline", void 0), Lo = gT = u([E("geoscene.symbols.SimpleMarkerSymbol")], Lo);
const Hu = Lo;
var vT;
let Ht = vT = class extends hi {
  constructor(...e) {
    super(...e), this.backgroundColor = null, this.borderLineColor = null, this.borderLineSize = null, this.font = new v_(), this.horizontalAlignment = "center", this.kerning = !0, this.haloColor = null, this.haloSize = null, this.rightToLeft = null, this.rotated = !1, this.text = "", this.type = "text", this.verticalAlignment = "baseline", this.xoffset = 0, this.yoffset = 0, this.angle = 0, this.width = null, this.lineWidth = 192, this.lineHeight = 1;
  }
  normalizeCtorArgs(e, t, r) {
    if (e && typeof e != "string")
      return e;
    const n = {};
    return e && (n.text = e), t && (n.font = t), r && (n.color = r), n;
  }
  writeLineWidth(e, t, r, n) {
    n && typeof n != "string" ? n.origin : t[r] = e;
  }
  castLineWidth(e) {
    return ut(e);
  }
  writeLineHeight(e, t, r, n) {
    n && typeof n != "string" ? n.origin : t[r] = e;
  }
  clone() {
    return new vT({ angle: this.angle, backgroundColor: j(this.backgroundColor), borderLineColor: j(this.borderLineColor), borderLineSize: this.borderLineSize, color: j(this.color), font: this.font && this.font.clone(), haloColor: j(this.haloColor), haloSize: this.haloSize, horizontalAlignment: this.horizontalAlignment, kerning: this.kerning, lineHeight: this.lineHeight, lineWidth: this.lineWidth, rightToLeft: this.rightToLeft, rotated: this.rotated, text: this.text, verticalAlignment: this.verticalAlignment, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    var e;
    return `${this.backgroundColor && this.backgroundColor.hash()}.${this.borderLineColor}.${this.borderLineSize}.${(e = this.color) == null ? void 0 : e.hash()}.${this.font && this.font.hash()}.${this.haloColor && this.haloColor.hash()}.${this.haloSize}.${this.horizontalAlignment}.${this.kerning}.${this.rightToLeft}.${this.rotated}.${this.text}.${this.verticalAlignment}.${this.width}.${this.xoffset}.${this.yoffset}.${this.lineHeight}.${this.lineWidth}.${this.angle}`;
  }
};
u([d({ type: Me, json: { write: !0 } })], Ht.prototype, "backgroundColor", void 0), u([d({ type: Me, json: { write: !0 } })], Ht.prototype, "borderLineColor", void 0), u([d({ type: Number, json: { write: !0 }, cast: ut })], Ht.prototype, "borderLineSize", void 0), u([d({ type: v_, json: { write: !0 } })], Ht.prototype, "font", void 0), u([d({ ...hj, json: { write: !0 } })], Ht.prototype, "horizontalAlignment", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ht.prototype, "kerning", void 0), u([d({ type: Me, json: { write: !0 } })], Ht.prototype, "haloColor", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Ht.prototype, "haloSize", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ht.prototype, "rightToLeft", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ht.prototype, "rotated", void 0), u([d({ type: String, json: { write: !0 } })], Ht.prototype, "text", void 0), u([Ie({ esriTS: "text" }, { readOnly: !0 })], Ht.prototype, "type", void 0), u([d({ ...fj, json: { write: !0 } })], Ht.prototype, "verticalAlignment", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Ht.prototype, "xoffset", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Ht.prototype, "yoffset", void 0), u([d({ type: Number, json: { read: (e) => e && -1 * e, write: (e, t) => t.angle = e && -1 * e } })], Ht.prototype, "angle", void 0), u([d({ type: Number, json: { write: !0 } })], Ht.prototype, "width", void 0), u([d({ type: Number })], Ht.prototype, "lineWidth", void 0), u([ge("lineWidth")], Ht.prototype, "writeLineWidth", null), u([xt("lineWidth")], Ht.prototype, "castLineWidth", null), u([d(pj)], Ht.prototype, "lineHeight", void 0), u([ge("lineHeight")], Ht.prototype, "writeLineHeight", null), Ht = vT = u([E("geoscene.symbols.TextSymbol")], Ht);
const mo = Ht;
var bT;
let Vs = bT = class extends hi {
  constructor(e) {
    super(e), this.styleName = null, this.portal = null, this.styleUrl = null, this.thumbnail = null, this.name = null, this.type = "web-style";
  }
  get _fetchCacheKey() {
    const e = this.portal != null ? this.portal : pi.getDefault(), t = e.user ? e.user.username : null;
    return `${this.styleName}:${this.styleUrl}:${this.name}:${t}:${e.url}`;
  }
  read(e, t) {
    this.portal = t == null ? void 0 : t.portal, super.read(e, t);
  }
  clone() {
    return new bT({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
  fetchSymbol(e) {
    return this._fetchSymbol("webRef", e);
  }
  fetchCIMSymbol(e) {
    return this._fetchSymbol("cimRef", e);
  }
  async _fetchSymbol(e, t) {
    const r = t != null ? t.cache : null, n = r ? this._fetchCacheKey : null;
    if (r != null) {
      const a = n && r.get(n);
      if (a)
        return a.clone();
    }
    const { resolveWebStyleSymbol: i } = await import("./webStyleSymbolUtils-jwA3T6ex.js");
    lr(t);
    const s = i(this, { portal: this.portal }, e, t);
    s.catch((a) => {
      se.getLogger(this).error("#fetchSymbol()", "Failed to create symbol from style", a);
    });
    const o = await s;
    return e === "webRef" && o.type === "point-3d" || e === "cimRef" && o.type === "cim" ? (r != null && r.set(n, o.clone()), o) : null;
  }
};
u([d({ json: { write: !1 } })], Vs.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], Vs.prototype, "styleName", void 0), u([d({ type: pi, json: { write: !1 } })], Vs.prototype, "portal", void 0), u([d({ type: String, json: { read: JM, write: Nd } })], Vs.prototype, "styleUrl", void 0), u([d({ type: $y, json: { read: !1 } })], Vs.prototype, "thumbnail", void 0), u([d({ type: String, json: { write: !0 } })], Vs.prototype, "name", void 0), u([Ie({ styleSymbolReference: "web-style" }, { readOnly: !0 })], Vs.prototype, "type", void 0), u([d()], Vs.prototype, "_fetchCacheKey", null), Vs = bT = u([E("geoscene.symbols.WebStyleSymbol")], Vs);
const tp = Vs;
function S4e(e) {
  if (!e)
    return !1;
  switch (e.type) {
    case "picture-fill":
    case "picture-marker":
    case "simple-fill":
    case "simple-line":
    case "simple-marker":
    case "text":
    case "cim":
      return !0;
    default:
      return !1;
  }
}
function WA(e) {
  if (!e)
    return !1;
  switch (e.type) {
    case "label-3d":
    case "line-3d":
    case "mesh-3d":
    case "point-3d":
    case "polygon-3d":
      return !0;
    default:
      return !1;
  }
}
const vd = { base: hi, key: "type", typeMap: { "simple-fill": ep, "picture-fill": Aj, "picture-marker": S_, "simple-line": ji, "simple-marker": Hu, text: mo, "label-3d": b_, "line-3d": w_, "mesh-3d": __, "point-3d": nd, "polygon-3d": Hg, "web-style": tp, cim: Ug }, errorContext: "symbol" }, Yne = { base: hi, key: "type", typeMap: { "picture-marker": S_, "simple-marker": Hu, text: mo, "web-style": tp, cim: Ug }, errorContext: "symbol" }, Qne = sf({ types: vd }), Lj = { base: hi, key: "type", typeMap: { "simple-fill": ep, "picture-fill": Aj, "picture-marker": S_, "simple-line": ji, "simple-marker": Hu, text: mo, "line-3d": w_, "mesh-3d": __, "point-3d": nd, "polygon-3d": Hg, "web-style": tp, cim: Ug }, errorContext: "symbol" }, Xne = { base: hi, key: "type", typeMap: { text: mo, "label-3d": b_ }, errorContext: "symbol" }, JA = { base: hi, key: "type", typeMap: { "line-3d": w_, "mesh-3d": __, "point-3d": nd, "polygon-3d": Hg, "web-style": tp, cim: Ug }, errorContext: "symbol" }, eie = { base: hi, key: "type", typeMap: { "label-3d": b_ }, errorContext: "symbol" }, Nj = na(vd);
var wT;
function tie(e) {
  if (!e)
    return null;
  const t = {};
  for (const r in e) {
    const n = Pd(e[r]);
    n && (t[r] = n);
  }
  return Object.keys(t).length !== 0 ? t : null;
}
function rie(e) {
  if (e == null)
    return null;
  const t = {};
  for (const r in e) {
    const n = e[r];
    n && (t[r] = n.toJSON());
  }
  return Object.keys(t).length !== 0 ? t : null;
}
let ti = wT = class extends Rt(re) {
  constructor(...e) {
    super(...e), this.isAggregate = !1, this.layer = null, this.popupTemplate = null, this.sourceLayer = null, Object.defineProperty(this, "uid", { value: dy(), configurable: !0 });
  }
  normalizeCtorArgs(e, t, r, n) {
    return e && !e.declaredClass ? e : { geometry: e, symbol: t, attributes: r, popupTemplate: n };
  }
  set aggregateGeometries(e) {
    const t = this._get("aggregateGeometries");
    JSON.stringify(t) !== JSON.stringify(e) && this._set("aggregateGeometries", e);
  }
  set attributes(e) {
    const t = this._get("attributes");
    t !== e && (this._set("attributes", e), this._notifyLayer("attributes", t, e));
  }
  set geometry(e) {
    const t = this._get("geometry");
    t !== e && (this._set("geometry", e), this._notifyLayer("geometry", t, e));
  }
  set symbol(e) {
    const t = this._get("symbol");
    t !== e && (this._set("symbol", e), this._notifyLayer("symbol", t, e));
  }
  set visible(e) {
    const t = this._get("visible");
    t !== e && (this._set("visible", e), this._notifyLayer("visible", t, e));
  }
  cloneShallow() {
    return new wT({ aggregateGeometries: this.aggregateGeometries, attributes: this.attributes, geometry: this.geometry, isAggregate: this.isAggregate, layer: this.layer, popupTemplate: this.popupTemplate, sourceLayer: this.sourceLayer, symbol: this.symbol, visible: this.visible });
  }
  getEffectivePopupTemplate(e = !1) {
    if (this.popupTemplate)
      return this.popupTemplate;
    for (const t of [this.sourceLayer, this.layer])
      if (t) {
        if ("popupTemplate" in t && t.popupTemplate)
          return t.popupTemplate;
        if (e && "defaultPopupTemplate" in t && t.defaultPopupTemplate != null)
          return t.defaultPopupTemplate;
      }
    return null;
  }
  getAttribute(e) {
    var t;
    return (t = this.attributes) == null ? void 0 : t[e];
  }
  setAttribute(e, t) {
    if (this.attributes) {
      const r = this.getAttribute(e);
      this.attributes[e] = t, this._notifyLayer("attributes", r, t, e);
    } else
      this.attributes = { [e]: t }, this._notifyLayer("attributes", void 0, t, e);
  }
  getObjectId() {
    return this.sourceLayer && "objectIdField" in this.sourceLayer && this.sourceLayer.objectIdField ? this.getAttribute(this.sourceLayer.objectIdField) : null;
  }
  toJSON() {
    return { aggregateGeometries: rie(this.aggregateGeometries), geometry: this.geometry != null ? this.geometry.toJSON() : null, symbol: this.symbol != null ? this.symbol.toJSON() : null, attributes: { ...this.attributes }, popupTemplate: this.popupTemplate && this.popupTemplate.toJSON() };
  }
  notifyGeometryChanged() {
    this._notifyLayer("geometry", this.geometry, this.geometry);
  }
  notifyMeshTransformChanged(e = {}) {
    const { geometry: t } = this;
    if ((t == null ? void 0 : t.type) === "mesh") {
      const r = { origin: t.origin, transform: t.transform };
      this._notifyLayer("origin-transform", r, r, e.action);
    }
  }
  _notifyLayer(e, t, r, n) {
    if (!this.layer || !("graphicChanged" in this.layer))
      return;
    const i = { graphic: this, property: e, oldValue: t, newValue: r };
    e === "origin-transform" && (i.action = n), e === "attributes" && (i.attributeName = n), this.layer.graphicChanged(i);
  }
};
u([d({ value: null, json: { read: tie } })], ti.prototype, "aggregateGeometries", null), u([d({ value: null })], ti.prototype, "attributes", null), u([d({ value: null, types: Qd, json: { read: Pd } })], ti.prototype, "geometry", null), u([d({ type: Boolean })], ti.prototype, "isAggregate", void 0), u([d({ clonable: "reference" })], ti.prototype, "layer", void 0), u([d({ type: zg })], ti.prototype, "popupTemplate", void 0), u([d({ clonable: "reference" })], ti.prototype, "sourceLayer", void 0), u([d({ value: null, types: vd })], ti.prototype, "symbol", null), u([d({ type: Boolean, value: !0 })], ti.prototype, "visible", null), ti = wT = u([E("geoscene.Graphic")], ti), function(e) {
  e.generateUID = dy;
}(ti || (ti = {}));
const vr = ti;
let QM = class {
  constructor(t, r) {
    this.min = t, this.max = r, this.range = r - t;
  }
  ndiff(t, r = 0) {
    return Math.ceil((t - r) / this.range) * this.range + r;
  }
  _normalize(t, r, n, i = 0, s = !1) {
    return (n -= i) < t ? n += this.ndiff(t - n) : n > r && (n -= this.ndiff(n - r)), s && n === r && (n = t), n + i;
  }
  normalize(t, r = 0, n = !1) {
    return this._normalize(this.min, this.max, t, r, n);
  }
  clamp(t, r = 0) {
    return ws(t - r, this.min, this.max) + r;
  }
  monotonic(t, r, n) {
    return t < r ? r : r + this.ndiff(t - r, n);
  }
  minimalMonotonic(t, r, n) {
    return this._normalize(t, t + this.range, r, n);
  }
  center(t, r, n) {
    return r = this.monotonic(t, r, n), this.normalize((t + r) / 2, n);
  }
  diff(t, r, n) {
    return this.monotonic(t, r, n) - t;
  }
  shortestSignedDiff(t, r) {
    t = this.normalize(t);
    const n = (r = this.normalize(r)) - t, i = r < t ? this.minimalMonotonic(t, r) - t : r - this.minimalMonotonic(r, t);
    return Math.abs(n) < Math.abs(i) ? n : i;
  }
  contains(t, r, n) {
    return r = this.minimalMonotonic(t, r), (n = this.minimalMonotonic(t, n)) > t && n < r;
  }
};
function XM(e) {
  for (const t in e) {
    const r = e[t];
    r instanceof Function && (e[t] = r.bind(e));
  }
  return e;
}
XM(new QM(0, 2 * Math.PI));
XM(new QM(-Math.PI, Math.PI));
const nie = XM(new QM(0, 360));
let Oa = class extends Rt(re) {
  constructor(...t) {
    super(...t), this.position = new Re([0, 0, 0]), this.heading = 0, this.tilt = 0, this.fov = 55;
  }
  normalizeCtorArgs(t, r, n, i) {
    if (t && typeof t == "object" && ("x" in t || Array.isArray(t))) {
      const s = { position: t };
      return r != null && (s.heading = r), n != null && (s.tilt = n), i != null && (s.fov = i), s;
    }
    return t;
  }
  writePosition(t, r, n, i) {
    const s = t.clone();
    s.x = ls(t.x || 0), s.y = ls(t.y || 0), s.z = t.hasZ ? ls(t.z || 0) : t.z, r[n] = s.write({}, i);
  }
  readPosition(t, r) {
    const n = new Re();
    return n.read(t, r), n.x = ls(n.x || 0), n.y = ls(n.y || 0), n.z = n.hasZ ? ls(n.z || 0) : n.z, n;
  }
  equals(t) {
    return t != null && this.tilt === t.tilt && this.heading === t.heading && this.fov === t.fov && this.position.equals(t.position);
  }
};
u([d({ type: Re, json: { write: { isRequired: !0 } } })], Oa.prototype, "position", void 0), u([ge("position")], Oa.prototype, "writePosition", null), u([ce("position")], Oa.prototype, "readPosition", null), u([d({ type: Number, nonNullable: !0, json: { write: { isRequired: !0 } } }), xt((e) => nie.normalize(ls(e)))], Oa.prototype, "heading", void 0), u([d({ type: Number, nonNullable: !0, json: { write: { isRequired: !0 } } }), xt((e) => ws(ls(e), -180, 180))], Oa.prototype, "tilt", void 0), u([d({ type: Number, nonNullable: !0, json: { read: !1, write: !1 } })], Oa.prototype, "fov", void 0), Oa = u([E("geoscene.Camera")], Oa);
const iie = Oa;
var _T;
let Hl = _T = class extends re {
  constructor(e) {
    super(e), this.rotation = 0, this.scale = 0, this.targetGeometry = null, this.camera = null;
  }
  castRotation(e) {
    return (e %= 360) < 0 && (e += 360), e;
  }
  clone() {
    return new _T({ rotation: this.rotation, scale: this.scale, targetGeometry: this.targetGeometry != null ? this.targetGeometry.clone() : null, camera: this.camera != null ? this.camera.clone() : null });
  }
};
function eS() {
  return { enabled: !this.camera };
}
u([d({ type: Number, json: { write: !0, origins: { "web-map": { default: 0, write: !0 }, "web-scene": { write: { overridePolicy: eS } } } } })], Hl.prototype, "rotation", void 0), u([xt("rotation")], Hl.prototype, "castRotation", null), u([d({ type: Number, json: { write: !0, origins: { "web-map": { default: 0, write: !0 }, "web-scene": { write: { overridePolicy: eS } } } } })], Hl.prototype, "scale", void 0), u([d({ types: Qd, json: { read: Pd, write: !0, origins: { "web-scene": { read: Pd, write: { overridePolicy: eS } } } } })], Hl.prototype, "targetGeometry", void 0), u([d({ type: iie, json: { write: !0 } })], Hl.prototype, "camera", void 0), Hl = _T = u([E("geoscene.Viewpoint")], Hl);
const Qo = Hl;
function ze(e, t, r = {}) {
  return eO(e, t, r, Fj);
}
function Au(e, t, r = {}) {
  return eO(e, t, r, Dj);
}
function eO(e, t, r = {}, n) {
  let i = null;
  const s = r.once ? (o, a) => {
    n(o) && (tr(i), t(o, a));
  } : (o, a) => {
    n(o) && t(o, a);
  };
  if (i = XW(e, s, r.sync, r.equals), r.initial) {
    const o = e();
    s(o, o);
  }
  return i;
}
function rg(e, t, r, n = {}) {
  let i = null, s = null, o = null;
  function a() {
    var h;
    i && s && (s.remove(), (h = n.onListenerRemove) == null || h.call(n, i), i = null, s = null);
  }
  function l(h) {
    n.once && n.once && tr(o), r(h);
  }
  const c = ze(e, (h, f) => {
    var m;
    a(), Jw(h) && (i = h, s = Zw(h, t, l), (m = n.onListenerAdd) == null || m.call(n, h));
  }, { sync: n.sync, initial: !0 });
  return o = nl(() => {
    c.remove(), a();
  }), o;
}
function tO(e, t) {
  return sie(e, Dj, t);
}
function sie(e, t, r) {
  if (ho(r))
    return Promise.reject(rr());
  const n = e();
  if (t != null && t(n))
    return Promise.resolve(n);
  let i = null;
  function s() {
    i = tr(i);
  }
  return new Promise((o, a) => {
    i = Uw([fs(r, () => {
      s(), a(rr());
    }), eO(e, (l) => {
      s(), o(l);
    }, { sync: !1, once: !0 }, t ?? Fj)]);
  });
}
function Fj(e) {
  return !0;
}
function Dj(e) {
  return !!e;
}
const Wg = { sync: !0 }, ln = { initial: !0 }, cu = { sync: !0, initial: !0 };
let qb = class {
  constructor(t = (r) => r.values().next().value) {
    this._peeker = t, this._observable = new t_(), this._items = /* @__PURE__ */ new Set();
  }
  get length() {
    return Ve(this._observable), this._items.size;
  }
  clear() {
    this.length !== 0 && (this._items.clear(), this._observable.notify());
  }
  last() {
    if (this.length === 0)
      return;
    let t;
    for (t of this._items)
      ;
    return t;
  }
  peek() {
    if (this.length !== 0)
      return this._peeker(this._items);
  }
  push(t) {
    this.contains(t) || (this._items.add(t), this._observable.notify());
  }
  contains(t) {
    return Ve(this._observable), this._items.has(t);
  }
  pop() {
    if (this.length === 0)
      return;
    const t = this.peek();
    return this._items.delete(t), this._observable.notify(), t;
  }
  popLast() {
    if (this.length === 0)
      return;
    const t = this.last();
    return this._items.delete(t), this._observable.notify(), t;
  }
  remove(t) {
    this.contains(t) && (this._items.delete(t), this._observable.notify());
  }
  filter(t) {
    const r = this.length;
    return this._items.forEach((n) => {
      t(n) || this._items.delete(n);
    }), r !== this._items.size && this._observable.notify(), this;
  }
  *[Symbol.iterator]() {
    Ve(this._observable), yield* this._items;
  }
};
const oie = { statsWorker: () => import("./statsWorker-pggc0J10.js"), geometryEngineWorker: () => import("./geometryEngineWorker-pO57H5n7.js"), CSVSourceWorker: () => import("./CSVSourceWorker-L1PALkyY.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-LKtukbtd.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker--7gjssvf.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-OoKdeaRz.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-h23BGC-s.js"), LercWorker: () => import("./LercWorker-uOGDjik0.js"), MemorySourceWorker: () => import("./MemorySourceWorker-ZLcyrGyp.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-Y2RLBpoD.js"), Pipeline: () => import("./Pipeline-QGEIhk5z.js"), PointCloudWorker: () => import("./PointCloudWorker-1ZAmz4J8.js"), RasterWorker: () => import("./RasterWorker-5Zhcz264.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-e3R0w7Yd.js"), SceneLayerWorker: () => import("./SceneLayerWorker-DoKaaZwe.js"), WFSSourceWorker: () => import("./WFSSourceWorker-UdpikUri.js"), WorkerTileHandler: () => import("./WorkerTileHandler-EXnKVSsI.js") };
var Xr;
(function(e) {
  e[e.HANDSHAKE = 0] = "HANDSHAKE", e[e.OPEN = 1] = "OPEN", e[e.OPENED = 2] = "OPENED", e[e.RESPONSE = 3] = "RESPONSE", e[e.INVOKE = 4] = "INVOKE", e[e.ABORT = 5] = "ABORT", e[e.CLOSE = 6] = "CLOSE", e[e.OPEN_PORT = 7] = "OPEN_PORT", e[e.ON = 8] = "ON";
})(Xr || (Xr = {}));
let aie = 0;
function jj() {
  return aie++;
}
function lie(e) {
  return e && typeof e == "object" && ("result" in e || "transferList" in e);
}
function ng(e) {
  return e ? typeof e == "string" ? JSON.stringify({ name: "message", message: e }) : e.toJSON ? JSON.stringify(e) : JSON.stringify({ name: e.name, message: e.message, details: e.details || { stack: e.stack } }) : null;
}
function rO(e, t, r, n) {
  if (t.type === Xr.OPEN_PORT)
    return void e.postMessage(t, [t.port]);
  if (t.type !== Xr.INVOKE && t.type !== Xr.RESPONSE)
    return void e.postMessage(t);
  let i;
  if (lie(r) ? (i = ZA(r.transferList), t.data = r.result) : (i = ZA(n), t.data = r), i) {
    if (U("ff")) {
      for (const s of i)
        if ("byteLength" in s && s.byteLength > 267386880) {
          const o = "Worker call with large ArrayBuffer would crash Firefox";
          switch (t.type) {
            case Xr.INVOKE:
              throw o;
            case Xr.RESPONSE:
              return void rO(e, { type: Xr.RESPONSE, jobId: t.jobId, error: ng(o) });
          }
        }
    }
    e.postMessage(t, i);
  } else
    e.postMessage(t);
}
function ig(e) {
  if (!e)
    return null;
  const t = e.data;
  return t ? typeof t == "string" ? JSON.parse(t) : t : null;
}
function ZA(e) {
  if (!e || !e.length)
    return null;
  if (U("geoscene-workers-arraybuffer-transfer"))
    return e;
  const t = e.filter((r) => !uie(r));
  return t.length ? t : null;
}
function uie(e) {
  var t;
  return e instanceof ArrayBuffer || ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) === "ArrayBuffer";
}
const { CLOSE: KA, ABORT: YA, INVOKE: QA, RESPONSE: Hf, OPEN_PORT: XA, ON: cie } = Xr, die = 2;
let pie = class {
  constructor(t) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = t, this._timer = null, this._process = this._process.bind(this);
  }
  push(t) {
    t.type === Xr.ABORT ? this._cancelledJobIds.add(t.jobId) : (this._invokeMessages.push(t), this._timer === null && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const t of this._invokeMessages)
      this._cancelledJobIds.has(t.jobId) || this._invoke(t);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
}, Pu = class Rp {
  static connect(t) {
    const r = new MessageChannel();
    let n;
    n = typeof t == "function" ? new t() : "default" in t && typeof t.default == "function" ? new t.default() : t;
    const i = new Rp(r.port1, { channel: r, client: n }, () => null);
    return typeof n == "object" && "remoteClient" in n && (n.remoteClient = i), Rp.clients.set(i, n), r.port2;
  }
  static loadWorker(t) {
    const r = oie[t];
    return r ? r() : Promise.resolve(null);
  }
  constructor(t, r, n) {
    this._port = t, this._getNextJob = n, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new pie((i) => this._onInvokeMessage(i)), this._client = r.client, this._onMessage = this._onMessage.bind(this), this._channel = r.channel, this._schedule = r.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  close() {
    this._post({ type: KA }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(t, r, n) {
    const i = n == null ? void 0 : n.signal, s = n == null ? void 0 : n.transferList;
    if (!this._port)
      return Promise.reject(new G("worker:port-closed", `Cannot call invoke('${t}'), port is closed`, { methodName: t, data: r }));
    const o = jj();
    return new Promise((a, l) => {
      if (ho(i))
        return this._processWork(), void l(rr());
      const c = fs(i, () => {
        const f = this._outJobs.get(o);
        f && (this._outJobs.delete(o), this._processWork(), tr(f.abortHandle), this._post({ type: YA, jobId: o }), l(rr()));
      }), h = { resolve: a, reject: l, abortHandle: c, debugInfo: t };
      this._outJobs.set(o, h), this._post({ type: QA, jobId: o, methodName: t, abortable: i != null }, r, s);
    });
  }
  on(t, r) {
    const n = new MessageChannel();
    function i(s) {
      r(s.data);
    }
    return this._port.postMessage({ type: Xr.ON, eventType: t, port: n.port2 }, [n.port2]), n.port1.addEventListener("message", i), n.port1.start(), { remove() {
      n.port1.postMessage({ type: Xr.CLOSE }), n.port1.close(), n.port1.removeEventListener("message", i);
    } };
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const t = new MessageChannel();
    return this._post({ type: XA, port: t.port2 }), t.port1;
  }
  _processWork() {
    if (this._outJobs.size >= die)
      return;
    const t = this._getNextJob();
    if (!t)
      return;
    const { methodName: r, data: n, invokeOptions: i, resolver: s } = t;
    this.invoke(r, n, i).then((o) => s.resolve(o)).catch((o) => s.reject(o));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((t) => {
      tr(t.abortHandle), t.reject(rr(`Worker closing, aborting job calling '${t.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = null, this._client = null, this._schedule = null;
  }
  _onMessage(t) {
    this._schedule != null ? this._schedule(() => this._processMessage(t)) : this._processMessage(t);
  }
  _processMessage(t) {
    const r = ig(t);
    if (r)
      switch (r.type) {
        case Hf:
          this._onResponseMessage(r);
          break;
        case QA:
          this._invokeQueue.push(r);
          break;
        case YA:
          this._onAbortMessage(r);
          break;
        case KA:
          this._onCloseMessage();
          break;
        case XA:
          this._onOpenPortMessage(r);
          break;
        case cie:
          this._onOnMessage(r);
      }
  }
  _onAbortMessage(t) {
    const r = this._inJobs, n = t.jobId, i = r.get(n);
    this._invokeQueue.push(t), i && (i.controller && i.controller.abort(), r.delete(n));
  }
  _onCloseMessage() {
    const t = this._client;
    this._close(), t && "destroy" in t && Rp.clients.get(this) === t && t.destroy(), Rp.clients.delete(this), t != null && t.remoteClient && (t.remoteClient = null);
  }
  _onInvokeMessage(t) {
    const { methodName: r, jobId: n, data: i, abortable: s } = t, o = s ? new AbortController() : null, a = this._inJobs;
    let l, c = this._client, h = c[r];
    try {
      if (!h && r && r.includes(".")) {
        const f = r.split(".");
        for (let m = 0; m < f.length - 1; m++)
          c = c[f[m]], h = c[f[m + 1]];
      }
      if (typeof h != "function")
        throw new TypeError(`${r} is not a function`);
      l = h.call(c, i, { client: this, signal: o ? o.signal : null });
    } catch (f) {
      return void this._post({ type: Hf, jobId: n, error: ng(f) });
    }
    pl(l) ? (a.set(n, { controller: o, promise: l }), l.then((f) => {
      a.has(n) && (a.delete(n), this._post({ type: Hf, jobId: n }, f));
    }, (f) => {
      a.has(n) && (a.delete(n), Fi(f) || this._post({ type: Hf, jobId: n, error: ng(f || { message: `Error encountered at method ${r}` }) }));
    })) : this._post({ type: Hf, jobId: n }, l);
  }
  _onOpenPortMessage(t) {
    new Rp(t.port, { client: this._client }, () => null);
  }
  _onOnMessage(t) {
    const { port: r } = t, n = this._client.on(t.eventType, (s) => {
      r.postMessage(s);
    }), i = Zw(t.port, "message", (s) => {
      const o = ig(s);
      (o == null ? void 0 : o.type) === Xr.CLOSE && (i.remove(), n.remove(), r.close());
    });
  }
  _onResponseMessage(t) {
    const { jobId: r, error: n, data: i } = t, s = this._outJobs;
    if (!s.has(r))
      return;
    const o = s.get(r);
    s.delete(r), this._processWork(), tr(o.abortHandle), n ? o.reject(G.fromJSON(JSON.parse(n))) : o.resolve(i);
  }
  _post(t, r, n) {
    return rO(this._port, t, r, n);
  }
};
Pu.kernelInfo = { buildDate: _6, fullVersion: cM, revision: S6 }, Pu.clients = /* @__PURE__ */ new Map();
let hie = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new qb();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(t, r) {
    return new Promise((n, i) => {
      let s = !0;
      const o = (a) => {
        lr(r.signal), s && (s = !1, a());
      };
      this._clients.length = t.length, this._clientPromises.length = t.length, this._inUseClients.length = t.length;
      for (let a = 0; a < t.length; ++a) {
        const l = t[a];
        pl(l) ? this._clientPromises[a] = l.then((c) => (this._clients[a] = new Pu(c, r, () => this._ongoingJobsQueue.pop() ?? null), o(n), this._clients[a]), () => (o(i), null)) : (this._clients[a] = new Pu(l, r, () => this._ongoingJobsQueue.pop() ?? null), this._clientPromises[a] = Promise.resolve(this._clients[a]), o(n));
      }
    });
  }
  broadcast(t, r, n) {
    const i = new Array(this._clientPromises.length);
    for (let s = 0; s < this._clientPromises.length; ++s) {
      const o = this._clientPromises[s];
      i[s] = o.then((a) => a == null ? void 0 : a.invoke(t, r, n));
    }
    return i;
  }
  close() {
    let t;
    for (; t = this._ongoingJobsQueue.pop(); )
      t.resolver.reject(rr(`Worker closing, aborting job calling '${t.methodName}'`));
    for (const r of this._clientPromises)
      r.then((n) => n == null ? void 0 : n.close());
    this._clients.length = 0, this._clientPromises.length = 0, this._inUseClients.length = 0;
  }
  invoke(t, r, n) {
    let i;
    Array.isArray(n) ? (se.getLogger("geoscene.core.workers.Connection").warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), i = { transferList: n }) : i = n;
    const s = vs();
    this._ongoingJobsQueue.push({ methodName: t, data: r, invokeOptions: i, resolver: s });
    for (let o = 0; o < this._clientPromises.length; o++) {
      const a = this._clients[o];
      a ? a.jobAdded() : this._clientPromises[o].then((l) => l == null ? void 0 : l.jobAdded());
    }
    return s.promise;
  }
  on(t, r) {
    return Promise.all(this._clientPromises).then(() => Uw(this._clients.map((n) => n.on(t, r))));
  }
  openPorts() {
    return new Promise((t) => {
      const r = new Array(this._clientPromises.length);
      let n = r.length;
      for (let i = 0; i < this._clientPromises.length; ++i)
        this._clientPromises[i].then((s) => {
          s && (r[i] = s.openPort()), --n == 0 && t(r);
        });
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};
const Vj = se.getLogger("geoscene.intl.substitute");
function M4e(e, t, r = {}) {
  const { format: n = {} } = r;
  return Ww(e, (i) => fie(i, t, n));
}
function fie(e, t, r) {
  let n, i;
  const s = e.indexOf(":");
  if (s === -1 ? n = e.trim() : (n = e.slice(0, s).trim(), i = e.slice(s + 1).trim()), !n)
    return "";
  const o = Pg(n, t);
  if (o == null)
    return "";
  const a = (i ? r == null ? void 0 : r[i] : null) ?? (r == null ? void 0 : r[n]);
  return a ? mie(o, a) : i ? yie(o, i) : nO(o);
}
function mie(e, t) {
  switch (t.type) {
    case "date":
      return Ld(e, t.intlOptions);
    case "number":
      return Xy(e, t.intlOptions);
    default:
      return Vj.warn("missing format descriptor for key {key}"), nO(e);
  }
}
function yie(e, t) {
  switch (t.toLowerCase()) {
    case "dateformat":
      return Ld(e);
    case "numberformat":
      return Xy(e);
    default:
      return Vj.warn(`inline format is unsupported since 4.12: ${t}`), /^(dateformat|datestring)/i.test(t) ? Ld(e) : /^numberformat/i.test(t) ? Xy(e) : nO(e);
  }
}
function nO(e) {
  switch (typeof e) {
    case "string":
      return e;
    case "number":
      return Xy(e);
    case "boolean":
      return "" + e;
    default:
      return e instanceof Date ? Ld(e) : "";
  }
}
async function gie(e, t, r, n) {
  const i = t.exec(r);
  if (!i)
    throw new G("geoscene-intl:invalid-bundle", `Bundle id "${r}" is not compatible with the pattern "${t}"`);
  const s = i[1] ? `${i[1]}/` : "", o = i[2], a = dY(n), l = `${s}${o}.json`, c = a ? `${s}${o}_${a}.json` : l;
  let h;
  try {
    h = await eP(e(c));
  } catch (f) {
    if (c === l)
      throw new G("intl:unknown-bundle", `Bundle "${r}" cannot be loaded`, { error: f });
    try {
      h = await eP(e(l));
    } catch (m) {
      throw new G("intl:unknown-bundle", `Bundle "${r}" cannot be loaded`, { error: m });
    }
  }
  return h;
}
async function eP(e) {
  if (tP.fetchBundleAsset != null)
    return tP.fetchBundleAsset(e);
  const t = await zr(e, { responseType: "text" });
  return JSON.parse(t.data);
}
let vie = class {
  constructor({ base: t = "", pattern: r, location: n = new URL(window.location.href) }) {
    let i;
    i = typeof n == "string" ? (s) => new URL(s, new URL(n, window.location.href)).href : n instanceof URL ? (s) => new URL(s, n).href : n, this.pattern = typeof r == "string" ? new RegExp(`^${r}`) : r, this.getAssetUrl = i, t = t ? t.endsWith("/") ? t : t + "/" : "", this.matcher = new RegExp(`^${t}(?:(.*)/)?(.*)$`);
  }
  fetchMessageBundle(t, r) {
    return gie(this.getAssetUrl, this.matcher, t, r);
  }
};
function bie(e) {
  return new vie(e);
}
const tP = {};
cY(bie({ pattern: "geoscene/", location: Ja }));
const wie = {};
function _ie(e) {
  const t = { async: e.async, isDebug: e.isDebug, locale: e.locale, baseUrl: e.baseUrl, has: { ...e.has }, map: { ...e.map }, packages: e.packages && e.packages.concat() || [], paths: { ...e.paths } };
  return e.hasOwnProperty("async") || (t.async = !0), e.hasOwnProperty("isDebug") || (t.isDebug = !1), e.baseUrl || (t.baseUrl = wie.baseUrl), t;
}
let Sie = class {
  constructor() {
    const t = document.createDocumentFragment();
    ["addEventListener", "dispatchEvent", "removeEventListener"].forEach((r) => {
      this[r] = (...n) => t[r](...n);
    });
  }
}, f1 = class {
  constructor() {
    this._dispatcher = new Sie(), this._workerPostMessage({ type: Xr.HANDSHAKE });
  }
  terminate() {
  }
  get onmessage() {
    return this._onmessageHandler;
  }
  set onmessage(t) {
    this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler), this._onmessageHandler = t, t && this.addEventListener("message", t);
  }
  get onmessageerror() {
    return this._onmessageerrorHandler;
  }
  set onmessageerror(t) {
    this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler), this._onmessageerrorHandler = t, t && this.addEventListener("messageerror", t);
  }
  get onerror() {
    return this._onerrorHandler;
  }
  set onerror(t) {
    this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler), this._onerrorHandler = t, t && this.addEventListener("error", t);
  }
  postMessage(t) {
    hb(() => {
      this._workerMessageHandler(new MessageEvent("message", { data: t }));
    });
  }
  dispatchEvent(t) {
    return this._dispatcher.dispatchEvent(t);
  }
  addEventListener(t, r, n) {
    this._dispatcher.addEventListener(t, r, n);
  }
  removeEventListener(t, r, n) {
    this._dispatcher.removeEventListener(t, r, n);
  }
  _workerPostMessage(t) {
    hb(() => {
      this.dispatchEvent(new MessageEvent("message", { data: t }));
    });
  }
  async _workerMessageHandler(t) {
    const r = ig(t);
    if (r && r.type === Xr.OPEN) {
      const { modulePath: n, jobId: i } = r;
      let s = await Pu.loadWorker(n);
      s || (s = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        n
      ));
      const o = Pu.connect(s);
      this._workerPostMessage({ type: Xr.OPENED, jobId: i, data: o });
    }
  }
};
const ST = se.getLogger("geoscene.core.workers.workerFactory"), { HANDSHAKE: $ie } = Xr, xie = 'let globalId=0;const outgoing=new Map,configuration=JSON.parse("{CONFIGURATION}");self.geosceneConfig=configuration.geosceneConfig;const workerPath=self.geosceneConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;return new Promise(((r,s)=>{if(t){if(t.aborted)return s(createAbortError());t.addEventListener("abort",(()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:ABORT,jobId:n}),s(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:s}),self.postMessage({type:INVOKE,jobId:n,methodName:e,abortable:null!=t,data:o})}))}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,fullVersion:r}=configuration.kernelInfo,{revision:t,fullVersion:n,version:s}=e.kernelInfo;geosceneConfig.assetsPath!==geosceneConfig.defaultAssetsPath&&o!==t&&console.warn(`Version mismatch detected between GeoScene Maps SDK for JavaScript modules and assets. For more information visit https://bit.ly/3QnsuSo.\\nModules version: ${r}\\nAssets version: ${n??s}\\nAssets path: ${geosceneConfig.assetsPath}`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case OPEN:let n;function t(e){const o=n.connect(e);self.postMessage({type:OPENED,jobId:r,data:o},[o])}"function"==typeof define&&define.amd?require([workerPath],(e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||new Promise((e=>{require([o.modulePath],e)})))).then(t)})):"System"in self&&"function"==typeof System.import?System.import(workerPath).then((e=>(n=e.default,checkWorkerRevision(n),n.loadWorker(o.modulePath)))).then((e=>e||System.import(o.modulePath))).then(t):geosceneConfig.workers.useDynamicImport?import(workerPath).then((e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),n=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case RESPONSE:if(outgoing.has(r)){const s=outgoing.get(r);outgoing.delete(r),o.error?s.reject(JSON.parse(o.error)):s.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,geosceneConfig.workers.loaderUrl&&(self.importScripts(geosceneConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});';
let D0, j0;
const rP = "Failed to create Worker. Fallback to execute module in main thread";
async function Tie() {
  if (!U("geoscene-workers") || (U("mozilla"), 0))
    return nP(new f1());
  if (!D0 && !j0)
    try {
      const t = xie.split('"{CONFIGURATION}"').join(`'${Eie()}'`);
      D0 = URL.createObjectURL(new Blob([t], { type: "text/javascript" }));
    } catch (t) {
      j0 = t || {};
    }
  let e;
  if (D0)
    try {
      e = new Worker(D0, { name: "geoscene-worker-" + Iie++ });
    } catch {
      ST.warn(rP, j0), e = new f1();
    }
  else
    ST.warn(rP, j0), e = new f1();
  return nP(e);
}
async function nP(e) {
  return new Promise((t) => {
    function r(i) {
      const s = ig(i);
      s && s.type === $ie && (e.removeEventListener("message", r), e.removeEventListener("error", n), t(e));
    }
    function n(i) {
      i.preventDefault(), e.removeEventListener("message", r), e.removeEventListener("error", n), ST.warn("Failed to create Worker. Fallback to execute module in main thread", i), (e = new f1()).addEventListener("message", r), e.addEventListener("error", n);
    }
    e.addEventListener("message", r), e.addEventListener("error", n);
  });
}
function Eie() {
  let e;
  if (bt.default != null) {
    const i = { ...bt };
    delete i.default, e = JSON.parse(JSON.stringify(i));
  } else
    e = JSON.parse(JSON.stringify(bt));
  e.assetsPath = cs(e.assetsPath), e.defaultAssetsPath = e.defaultAssetsPath ? cs(e.defaultAssetsPath) : void 0, e.request.interceptors = [], e.log.interceptors = [], e.locale = uo(), e.has = { "geoscene-csp-restrictions": U("geoscene-csp-restrictions"), "geoscene-2d-debug": !1, "geoscene-2d-update-debug": U("geoscene-2d-update-debug"), "geoscene-2d-log-updating": U("geoscene-2d-log-updating"), "featurelayer-pbf": U("featurelayer-pbf"), "featurelayer-simplify-thresholds": U("featurelayer-simplify-thresholds"), "featurelayer-simplify-payload-size-factors": U("featurelayer-simplify-payload-size-factors"), "featurelayer-simplify-mobile-factor": U("featurelayer-simplify-mobile-factor"), "geoscene-atomics": U("geoscene-atomics"), "geoscene-shared-array-buffer": U("geoscene-shared-array-buffer"), "geoscene-tiles-debug": U("geoscene-tiles-debug"), "geoscene-workers-arraybuffer-transfer": U("geoscene-workers-arraybuffer-transfer"), "feature-polyline-generalization-factor": U("feature-polyline-generalization-factor"), "host-webworker": 1, "polylabel-placement-enabled": U("polylabel-placement-enabled") }, e.workers.loaderUrl && (e.workers.loaderUrl = cs(e.workers.loaderUrl)), e.workers.workerPath ? e.workers.workerPath = cs(e.workers.workerPath) : e.workers.workerPath = cs(Ja("geoscene/core/workers/RemoteClient.js")), e.workers.useDynamicImport = !1;
  const t = bt.workers.loaderConfig, r = _ie({ baseUrl: t == null ? void 0 : t.baseUrl, locale: uo(), has: { "csp-restrictions": 1, "dojo-test-sniff": 0, "host-webworker": 1, ...t == null ? void 0 : t.has }, map: { ...t == null ? void 0 : t.map }, paths: { ...t == null ? void 0 : t.paths }, packages: (t == null ? void 0 : t.packages) || [] });
  return JSON.stringify({ geosceneConfig: e, loaderConfig: r, kernelInfo: { buildDate: _6, fullVersion: cM, revision: S6 } });
}
let Iie = 0;
const { ABORT: iP, INVOKE: Mie, OPEN: Oie, OPENED: Cie, RESPONSE: Wf } = Xr;
let kie = class zj {
  static async create(t) {
    const r = await Tie();
    return new zj(r, t);
  }
  constructor(t, r) {
    this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this.worker = t, this.id = r, t.addEventListener("message", this._onMessage.bind(this)), t.addEventListener("error", (n) => {
      n.preventDefault(), se.getLogger("geoscene.core.workers.WorkerOwner").error(n);
    });
  }
  terminate() {
    this.worker.terminate();
  }
  async open(t, r = {}) {
    const { signal: n } = r, i = jj();
    return new Promise((s, o) => {
      const a = { resolve: s, reject: o, abortHandle: z3(n, () => {
        this._outJobs.delete(i), this._post({ type: iP, jobId: i });
      }) };
      this._outJobs.set(i, a), this._post({ type: Oie, jobId: i, modulePath: t });
    });
  }
  _onMessage(t) {
    const r = ig(t);
    if (r)
      switch (r.type) {
        case Cie:
          this._onOpenedMessage(r);
          break;
        case Wf:
          this._onResponseMessage(r);
          break;
        case iP:
          this._onAbortMessage(r);
          break;
        case Mie:
          this._onInvokeMessage(r);
      }
  }
  _onAbortMessage(t) {
    const r = this._inJobs, n = t.jobId, i = r.get(n);
    i && (i.controller && i.controller.abort(), r.delete(n));
  }
  _onInvokeMessage(t) {
    const { methodName: r, jobId: n, data: i, abortable: s } = t, o = s ? new AbortController() : null, a = this._inJobs, l = uK[r];
    let c;
    try {
      if (typeof l != "function")
        throw new TypeError(`${r} is not a function`);
      c = l.call(null, i, { signal: o ? o.signal : null });
    } catch (h) {
      return void this._post({ type: Wf, jobId: n, error: ng(h) });
    }
    pl(c) ? (a.set(n, { controller: o, promise: c }), c.then((h) => {
      a.has(n) && (a.delete(n), this._post({ type: Wf, jobId: n }, h));
    }, (h) => {
      a.has(n) && (a.delete(n), h || (h = { message: "Error encountered at method" + r }), Fi(h) || this._post({ type: Wf, jobId: n, error: ng(h || { message: `Error encountered at method ${r}` }) }));
    })) : this._post({ type: Wf, jobId: n }, c);
  }
  _onOpenedMessage(t) {
    const { jobId: r, data: n } = t, i = this._outJobs.get(r);
    i && (this._outJobs.delete(r), tr(i.abortHandle), i.resolve(n));
  }
  _onResponseMessage(t) {
    const { jobId: r, error: n, data: i } = t, s = this._outJobs.get(r);
    s && (this._outJobs.delete(r), tr(s.abortHandle), n ? s.reject(G.fromJSON(JSON.parse(n))) : s.resolve(i));
  }
  _post(t, r, n) {
    return rO(this.worker, t, r, n);
  }
};
const sP = U("host-browser") ? Math.min(navigator.hardwareConcurrency - 1, U("workers-pool-size")) : 0;
let id = U("geoscene-mobile") ? Math.min(sP, 3) : sP;
id || (id = U("safari") && U("mac") ? 7 : 2);
let oP = 0;
const m1 = [];
function Aie() {
  Uj();
}
async function V0(e, t) {
  const r = new hie();
  return await r.open(e, t), r;
}
async function Pie(e, t = {}) {
  if (typeof e != "string")
    throw new G("workers:undefined-module", "modulePath is missing");
  let r = t.strategy || "distributed";
  if (U("host-webworker") && !U("geoscene-workers") && (r = "local"), r === "local") {
    let n = await Pu.loadWorker(e);
    n || (n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e
    )), lr(t.signal);
    const i = t.client || n;
    return V0([Pu.connect(n)], { ...t, client: i });
  }
  if (await Uj(), lr(t.signal), r === "dedicated") {
    const n = oP++ % id;
    return V0([await m1[n].open(e, t)], t);
  }
  if (t.maxNumWorkers && t.maxNumWorkers > 0) {
    const n = Math.min(t.maxNumWorkers, id);
    if (n < id) {
      const i = new Array(n);
      for (let s = 0; s < n; ++s) {
        const o = oP++ % id;
        i[s] = m1[o].open(e, t);
      }
      return V0(i, t);
    }
  }
  return V0(m1.map((n) => n.open(e, t)), t);
}
let z0 = null;
async function Uj() {
  if (z0)
    return z0;
  new AbortController();
  const e = [];
  for (let t = 0; t < id; t++) {
    const r = kie.create(t).then((n) => (m1[t] = n, n));
    e.push(r);
  }
  return z0 = Promise.all(e), z0;
}
function Rie(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
}
function Wu(e, t, r, n, i, s, o, a, l, c, h, f, m, y, g, v, b) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e[4] = s, e[5] = o, e[6] = a, e[7] = l, e[8] = c, e[9] = h, e[10] = f, e[11] = m, e[12] = y, e[13] = g, e[14] = v, e[15] = b, e;
}
function Jg(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function hl(e, t) {
  if (e === t) {
    const r = t[1], n = t[2], i = t[3], s = t[6], o = t[7], a = t[11];
    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = s, e[11] = t[14], e[12] = i, e[13] = o, e[14] = a;
  } else
    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
  return e;
}
function Lie(e, t) {
  return Bj(e, t) || Jg(e), e;
}
function Bj(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], f = t[9], m = t[10], y = t[11], g = t[12], v = t[13], b = t[14], w = t[15], x = r * a - n * o, $ = r * l - i * o, T = r * c - s * o, C = n * l - i * a, I = n * c - s * a, O = i * c - s * l, M = h * v - f * g, L = h * b - m * g, N = h * w - y * g, ee = f * b - m * v, D = f * w - y * v, H = m * w - y * b;
  let J = x * H - $ * D + T * ee + C * N - I * L + O * M;
  return J ? (J = 1 / J, e[0] = (a * H - l * D + c * ee) * J, e[1] = (i * D - n * H - s * ee) * J, e[2] = (v * O - b * I + w * C) * J, e[3] = (m * I - f * O - y * C) * J, e[4] = (l * N - o * H - c * L) * J, e[5] = (r * H - i * N + s * L) * J, e[6] = (b * T - g * O - w * $) * J, e[7] = (h * O - m * T + y * $) * J, e[8] = (o * D - a * N + c * M) * J, e[9] = (n * N - r * D - s * M) * J, e[10] = (g * I - v * T + w * x) * J, e[11] = (f * T - h * I - y * x) * J, e[12] = (a * L - o * ee - l * M) * J, e[13] = (r * ee - n * L + i * M) * J, e[14] = (v * $ - g * C - b * x) * J, e[15] = (h * C - f * $ + m * x) * J, e) : null;
}
function Nie(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], f = t[9], m = t[10], y = t[11], g = t[12], v = t[13], b = t[14], w = t[15];
  return e[0] = a * (m * w - y * b) - f * (l * w - c * b) + v * (l * y - c * m), e[1] = -(n * (m * w - y * b) - f * (i * w - s * b) + v * (i * y - s * m)), e[2] = n * (l * w - c * b) - a * (i * w - s * b) + v * (i * c - s * l), e[3] = -(n * (l * y - c * m) - a * (i * y - s * m) + f * (i * c - s * l)), e[4] = -(o * (m * w - y * b) - h * (l * w - c * b) + g * (l * y - c * m)), e[5] = r * (m * w - y * b) - h * (i * w - s * b) + g * (i * y - s * m), e[6] = -(r * (l * w - c * b) - o * (i * w - s * b) + g * (i * c - s * l)), e[7] = r * (l * y - c * m) - o * (i * y - s * m) + h * (i * c - s * l), e[8] = o * (f * w - y * v) - h * (a * w - c * v) + g * (a * y - c * f), e[9] = -(r * (f * w - y * v) - h * (n * w - s * v) + g * (n * y - s * f)), e[10] = r * (a * w - c * v) - o * (n * w - s * v) + g * (n * c - s * a), e[11] = -(r * (a * y - c * f) - o * (n * y - s * f) + h * (n * c - s * a)), e[12] = -(o * (f * b - m * v) - h * (a * b - l * v) + g * (a * m - l * f)), e[13] = r * (f * b - m * v) - h * (n * b - i * v) + g * (n * m - i * f), e[14] = -(r * (a * b - l * v) - o * (n * b - i * v) + g * (n * l - i * a)), e[15] = r * (a * m - l * f) - o * (n * m - i * f) + h * (n * l - i * a), e;
}
function Fie(e) {
  const t = e[0], r = e[1], n = e[2], i = e[3], s = e[4], o = e[5], a = e[6], l = e[7], c = e[8], h = e[9], f = e[10], m = e[11], y = e[12], g = e[13], v = e[14], b = e[15];
  return (t * o - r * s) * (f * b - m * v) - (t * a - n * s) * (h * b - m * g) + (t * l - i * s) * (h * v - f * g) + (r * a - n * o) * (c * b - m * y) - (r * l - i * o) * (c * v - f * y) + (n * l - i * a) * (c * g - h * y);
}
function qj(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], f = t[8], m = t[9], y = t[10], g = t[11], v = t[12], b = t[13], w = t[14], x = t[15];
  let $ = r[0], T = r[1], C = r[2], I = r[3];
  return e[0] = $ * n + T * a + C * f + I * v, e[1] = $ * i + T * l + C * m + I * b, e[2] = $ * s + T * c + C * y + I * w, e[3] = $ * o + T * h + C * g + I * x, $ = r[4], T = r[5], C = r[6], I = r[7], e[4] = $ * n + T * a + C * f + I * v, e[5] = $ * i + T * l + C * m + I * b, e[6] = $ * s + T * c + C * y + I * w, e[7] = $ * o + T * h + C * g + I * x, $ = r[8], T = r[9], C = r[10], I = r[11], e[8] = $ * n + T * a + C * f + I * v, e[9] = $ * i + T * l + C * m + I * b, e[10] = $ * s + T * c + C * y + I * w, e[11] = $ * o + T * h + C * g + I * x, $ = r[12], T = r[13], C = r[14], I = r[15], e[12] = $ * n + T * a + C * f + I * v, e[13] = $ * i + T * l + C * m + I * b, e[14] = $ * s + T * c + C * y + I * w, e[15] = $ * o + T * h + C * g + I * x, e;
}
function Die(e, t, r) {
  const n = r[0], i = r[1], s = r[2];
  if (t === e)
    e[12] = t[0] * n + t[4] * i + t[8] * s + t[12], e[13] = t[1] * n + t[5] * i + t[9] * s + t[13], e[14] = t[2] * n + t[6] * i + t[10] * s + t[14], e[15] = t[3] * n + t[7] * i + t[11] * s + t[15];
  else {
    const o = t[0], a = t[1], l = t[2], c = t[3], h = t[4], f = t[5], m = t[6], y = t[7], g = t[8], v = t[9], b = t[10], w = t[11];
    e[0] = o, e[1] = a, e[2] = l, e[3] = c, e[4] = h, e[5] = f, e[6] = m, e[7] = y, e[8] = g, e[9] = v, e[10] = b, e[11] = w, e[12] = o * n + h * i + g * s + t[12], e[13] = a * n + f * i + v * s + t[13], e[14] = l * n + m * i + b * s + t[14], e[15] = c * n + y * i + w * s + t[15];
  }
  return e;
}
function jie(e, t, r) {
  const n = r[0], i = r[1], s = r[2];
  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
}
function Vie(e, t, r, n) {
  let i, s, o, a, l, c, h, f, m, y, g, v, b, w, x, $, T, C, I, O, M, L, N, ee, D = n[0], H = n[1], J = n[2], oe = Math.sqrt(D * D + H * H + J * J);
  return oe < Es() ? null : (oe = 1 / oe, D *= oe, H *= oe, J *= oe, i = Math.sin(r), s = Math.cos(r), o = 1 - s, a = t[0], l = t[1], c = t[2], h = t[3], f = t[4], m = t[5], y = t[6], g = t[7], v = t[8], b = t[9], w = t[10], x = t[11], $ = D * D * o + s, T = H * D * o + J * i, C = J * D * o - H * i, I = D * H * o - J * i, O = H * H * o + s, M = J * H * o + D * i, L = D * J * o + H * i, N = H * J * o - D * i, ee = J * J * o + s, e[0] = a * $ + f * T + v * C, e[1] = l * $ + m * T + b * C, e[2] = c * $ + y * T + w * C, e[3] = h * $ + g * T + x * C, e[4] = a * I + f * O + v * M, e[5] = l * I + m * O + b * M, e[6] = c * I + y * O + w * M, e[7] = h * I + g * O + x * M, e[8] = a * L + f * N + v * ee, e[9] = l * L + m * N + b * ee, e[10] = c * L + y * N + w * ee, e[11] = h * L + g * N + x * ee, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);
}
function zie(e, t, r) {
  const n = Math.sin(r), i = Math.cos(r), s = t[4], o = t[5], a = t[6], l = t[7], c = t[8], h = t[9], f = t[10], m = t[11];
  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = s * i + c * n, e[5] = o * i + h * n, e[6] = a * i + f * n, e[7] = l * i + m * n, e[8] = c * i - s * n, e[9] = h * i - o * n, e[10] = f * i - a * n, e[11] = m * i - l * n, e;
}
function Uie(e, t, r) {
  const n = Math.sin(r), i = Math.cos(r), s = t[0], o = t[1], a = t[2], l = t[3], c = t[8], h = t[9], f = t[10], m = t[11];
  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * i - c * n, e[1] = o * i - h * n, e[2] = a * i - f * n, e[3] = l * i - m * n, e[8] = s * n + c * i, e[9] = o * n + h * i, e[10] = a * n + f * i, e[11] = l * n + m * i, e;
}
function Bie(e, t, r) {
  const n = Math.sin(r), i = Math.cos(r), s = t[0], o = t[1], a = t[2], l = t[3], c = t[4], h = t[5], f = t[6], m = t[7];
  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * i + c * n, e[1] = o * i + h * n, e[2] = a * i + f * n, e[3] = l * i + m * n, e[4] = c * i - s * n, e[5] = h * i - o * n, e[6] = f * i - a * n, e[7] = m * i - l * n, e;
}
function Gj(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;
}
function qie(e, t) {
  return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function Gie(e, t, r) {
  if (t === 0)
    return Jg(e);
  let n, i, s, o = r[0], a = r[1], l = r[2], c = Math.sqrt(o * o + a * a + l * l);
  return c < Es() ? null : (c = 1 / c, o *= c, a *= c, l *= c, n = Math.sin(t), i = Math.cos(t), s = 1 - i, e[0] = o * o * s + i, e[1] = a * o * s + l * n, e[2] = l * o * s - a * n, e[3] = 0, e[4] = o * a * s - l * n, e[5] = a * a * s + i, e[6] = l * a * s + o * n, e[7] = 0, e[8] = o * l * s + a * n, e[9] = a * l * s - o * n, e[10] = l * l * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);
}
function Hie(e, t) {
  const r = Math.sin(t), n = Math.cos(t);
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function Wie(e, t) {
  const r = Math.sin(t), n = Math.cos(t);
  return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function Jie(e, t) {
  const r = Math.sin(t), n = Math.cos(t);
  return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function Hj(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = n + n, l = i + i, c = s + s, h = n * a, f = n * l, m = n * c, y = i * l, g = i * c, v = s * c, b = o * a, w = o * l, x = o * c;
  return e[0] = 1 - (y + v), e[1] = f + x, e[2] = m - w, e[3] = 0, e[4] = f - x, e[5] = 1 - (h + v), e[6] = g + b, e[7] = 0, e[8] = m + w, e[9] = g - b, e[10] = 1 - (h + y), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;
}
function Zie(e, t) {
  const r = Kie, n = -t[0], i = -t[1], s = -t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], f = n * n + i * i + s * s + o * o;
  return f > 0 ? (r[0] = 2 * (a * o + h * n + l * s - c * i) / f, r[1] = 2 * (l * o + h * i + c * n - a * s) / f, r[2] = 2 * (c * o + h * s + a * i - l * n) / f) : (r[0] = 2 * (a * o + h * n + l * s - c * i), r[1] = 2 * (l * o + h * i + c * n - a * s), r[2] = 2 * (c * o + h * s + a * i - l * n)), Hj(e, t, r), e;
}
const Kie = da();
function Yie(e, t) {
  return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;
}
function Qie(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[4], o = t[5], a = t[6], l = t[8], c = t[9], h = t[10];
  return e[0] = Math.sqrt(r * r + n * n + i * i), e[1] = Math.sqrt(s * s + o * o + a * a), e[2] = Math.sqrt(l * l + c * c + h * h), e;
}
function Xie(e, t) {
  const r = t[0] + t[5] + t[10];
  let n = 0;
  return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = 0.25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = 0.25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = 0.25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = 0.25 * n), e;
}
function ese(e, t, r, n) {
  const i = t[0], s = t[1], o = t[2], a = t[3], l = i + i, c = s + s, h = o + o, f = i * l, m = i * c, y = i * h, g = s * c, v = s * h, b = o * h, w = a * l, x = a * c, $ = a * h, T = n[0], C = n[1], I = n[2];
  return e[0] = (1 - (g + b)) * T, e[1] = (m + $) * T, e[2] = (y - x) * T, e[3] = 0, e[4] = (m - $) * C, e[5] = (1 - (f + b)) * C, e[6] = (v + w) * C, e[7] = 0, e[8] = (y + x) * I, e[9] = (v - w) * I, e[10] = (1 - (f + g)) * I, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;
}
function tse(e, t, r, n, i) {
  const s = t[0], o = t[1], a = t[2], l = t[3], c = s + s, h = o + o, f = a + a, m = s * c, y = s * h, g = s * f, v = o * h, b = o * f, w = a * f, x = l * c, $ = l * h, T = l * f, C = n[0], I = n[1], O = n[2], M = i[0], L = i[1], N = i[2], ee = (1 - (v + w)) * C, D = (y + T) * C, H = (g - $) * C, J = (y - T) * I, oe = (1 - (m + w)) * I, ye = (b + x) * I, Q = (g + $) * O, ve = (b - x) * O, Ee = (1 - (m + v)) * O;
  return e[0] = ee, e[1] = D, e[2] = H, e[3] = 0, e[4] = J, e[5] = oe, e[6] = ye, e[7] = 0, e[8] = Q, e[9] = ve, e[10] = Ee, e[11] = 0, e[12] = r[0] + M - (ee * M + J * L + Q * N), e[13] = r[1] + L - (D * M + oe * L + ve * N), e[14] = r[2] + N - (H * M + ye * L + Ee * N), e[15] = 1, e;
}
function rse(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = r + r, a = n + n, l = i + i, c = r * o, h = n * o, f = n * a, m = i * o, y = i * a, g = i * l, v = s * o, b = s * a, w = s * l;
  return e[0] = 1 - f - g, e[1] = h + w, e[2] = m - b, e[3] = 0, e[4] = h - w, e[5] = 1 - c - g, e[6] = y + v, e[7] = 0, e[8] = m + b, e[9] = y - v, e[10] = 1 - c - f, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function nse(e, t, r, n, i, s, o) {
  const a = 1 / (r - t), l = 1 / (i - n), c = 1 / (s - o);
  return e[0] = 2 * s * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * s * l, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (i + n) * l, e[10] = (o + s) * c, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * s * 2 * c, e[15] = 0, e;
}
function ise(e, t, r, n, i) {
  const s = 1 / Math.tan(t / 2);
  let o;
  return e[0] = s / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, i != null && i !== 1 / 0 ? (o = 1 / (n - i), e[10] = (i + n) * o, e[14] = 2 * i * n * o) : (e[10] = -1, e[14] = -2 * n), e;
}
function sse(e, t, r, n) {
  const i = Math.tan(t.upDegrees * Math.PI / 180), s = Math.tan(t.downDegrees * Math.PI / 180), o = Math.tan(t.leftDegrees * Math.PI / 180), a = Math.tan(t.rightDegrees * Math.PI / 180), l = 2 / (o + a), c = 2 / (i + s);
  return e[0] = l, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = c, e[6] = 0, e[7] = 0, e[8] = -(o - a) * l * 0.5, e[9] = (i - s) * c * 0.5, e[10] = n / (r - n), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = n * r / (r - n), e[15] = 0, e;
}
function ose(e, t, r, n, i, s, o) {
  const a = 1 / (t - r), l = 1 / (n - i), c = 1 / (s - o);
  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + r) * a, e[13] = (i + n) * l, e[14] = (o + s) * c, e[15] = 1, e;
}
function ase(e, t, r, n) {
  const i = t[0], s = t[1], o = t[2];
  let a = i - r[0], l = s - r[1], c = o - r[2];
  const h = Es();
  if (Math.abs(a) < h && Math.abs(l) < h && Math.abs(c) < h)
    return void Jg(e);
  let f = 1 / Math.sqrt(a * a + l * l + c * c);
  a *= f, l *= f, c *= f;
  const m = n[0], y = n[1], g = n[2];
  let v = y * c - g * l, b = g * a - m * c, w = m * l - y * a;
  f = Math.sqrt(v * v + b * b + w * w), f ? (f = 1 / f, v *= f, b *= f, w *= f) : (v = 0, b = 0, w = 0);
  let x = l * w - c * b, $ = c * v - a * w, T = a * b - l * v;
  f = Math.sqrt(x * x + $ * $ + T * T), f ? (f = 1 / f, x *= f, $ *= f, T *= f) : (x = 0, $ = 0, T = 0), e[0] = v, e[1] = x, e[2] = a, e[3] = 0, e[4] = b, e[5] = $, e[6] = l, e[7] = 0, e[8] = w, e[9] = T, e[10] = c, e[11] = 0, e[12] = -(v * i + b * s + w * o), e[13] = -(x * i + $ * s + T * o), e[14] = -(a * i + l * s + c * o), e[15] = 1;
}
function lse(e, t, r, n) {
  const i = t[0], s = t[1], o = t[2], a = n[0], l = n[1], c = n[2];
  let h = i - r[0], f = s - r[1], m = o - r[2], y = h * h + f * f + m * m;
  y > 0 && (y = 1 / Math.sqrt(y), h *= y, f *= y, m *= y);
  let g = l * m - c * f, v = c * h - a * m, b = a * f - l * h;
  return y = g * g + v * v + b * b, y > 0 && (y = 1 / Math.sqrt(y), g *= y, v *= y, b *= y), e[0] = g, e[1] = v, e[2] = b, e[3] = 0, e[4] = f * b - m * v, e[5] = m * g - h * b, e[6] = h * v - f * g, e[7] = 0, e[8] = h, e[9] = f, e[10] = m, e[11] = 0, e[12] = i, e[13] = s, e[14] = o, e[15] = 1, e;
}
function use(e) {
  return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")";
}
function cse(e) {
  return Math.sqrt(e[0] ** 2 + e[1] ** 2 + e[2] ** 2 + e[3] ** 2 + e[4] ** 2 + e[5] ** 2 + e[6] ** 2 + e[7] ** 2 + e[8] ** 2 + e[9] ** 2 + e[10] ** 2 + e[11] ** 2 + e[12] ** 2 + e[13] ** 2 + e[14] ** 2 + e[15] ** 2);
}
function dse(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;
}
function Wj(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;
}
function pse(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;
}
function hse(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;
}
function fse(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
}
function mse(e, t) {
  if (e === t)
    return !0;
  const r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], f = e[9], m = e[10], y = e[11], g = e[12], v = e[13], b = e[14], w = e[15], x = t[0], $ = t[1], T = t[2], C = t[3], I = t[4], O = t[5], M = t[6], L = t[7], N = t[8], ee = t[9], D = t[10], H = t[11], J = t[12], oe = t[13], ye = t[14], Q = t[15], ve = Es();
  return Math.abs(r - x) <= ve * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(n - $) <= ve * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(i - T) <= ve * Math.max(1, Math.abs(i), Math.abs(T)) && Math.abs(s - C) <= ve * Math.max(1, Math.abs(s), Math.abs(C)) && Math.abs(o - I) <= ve * Math.max(1, Math.abs(o), Math.abs(I)) && Math.abs(a - O) <= ve * Math.max(1, Math.abs(a), Math.abs(O)) && Math.abs(l - M) <= ve * Math.max(1, Math.abs(l), Math.abs(M)) && Math.abs(c - L) <= ve * Math.max(1, Math.abs(c), Math.abs(L)) && Math.abs(h - N) <= ve * Math.max(1, Math.abs(h), Math.abs(N)) && Math.abs(f - ee) <= ve * Math.max(1, Math.abs(f), Math.abs(ee)) && Math.abs(m - D) <= ve * Math.max(1, Math.abs(m), Math.abs(D)) && Math.abs(y - H) <= ve * Math.max(1, Math.abs(y), Math.abs(H)) && Math.abs(g - J) <= ve * Math.max(1, Math.abs(g), Math.abs(J)) && Math.abs(v - oe) <= ve * Math.max(1, Math.abs(v), Math.abs(oe)) && Math.abs(b - ye) <= ve * Math.max(1, Math.abs(b), Math.abs(ye)) && Math.abs(w - Q) <= ve * Math.max(1, Math.abs(w), Math.abs(Q));
}
function yse(e) {
  const t = Es(), r = e[0], n = e[1], i = e[2], s = e[4], o = e[5], a = e[6], l = e[8], c = e[9], h = e[10];
  return Math.abs(1 - (r * r + s * s + l * l)) <= t && Math.abs(1 - (n * n + o * o + c * c)) <= t && Math.abs(1 - (i * i + a * a + h * h)) <= t;
}
function gse(e) {
  return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1;
}
const vse = qj, bse = Wj;
Object.freeze(Object.defineProperty({ __proto__: null, add: dse, adjoint: Nie, copy: Rie, determinant: Fie, equals: mse, exactEquals: fse, frob: cse, fromQuat: rse, fromQuat2: Zie, fromRotation: Gie, fromRotationTranslation: Hj, fromRotationTranslationScale: ese, fromRotationTranslationScaleOrigin: tse, fromScaling: qie, fromTranslation: Gj, fromXRotation: Hie, fromYRotation: Wie, fromZRotation: Jie, frustum: nse, getRotation: Xie, getScaling: Qie, getTranslation: Yie, hasIdentityRotation: gse, identity: Jg, invert: Bj, invertOrIdentity: Lie, isOrthoNormal: yse, lookAt: ase, mul: vse, multiply: qj, multiplyScalar: pse, multiplyScalarAndAdd: hse, ortho: ose, perspective: ise, perspectiveFromFieldOfView: sse, rotate: Vie, rotateX: zie, rotateY: Uie, rotateZ: Bie, scale: jie, set: Wu, str: use, sub: bse, subtract: Wj, targetTo: lse, translate: Die, transpose: hl }, Symbol.toStringTag, { value: "Module" }));
let tS, F = null;
function iO() {
  return !!F;
}
function wse() {
  return !!U("geoscene-wasm");
}
function Jj() {
  return tS || (tS = import("./pe-wasm-WuFL1Ucs.js").then((e) => e.p).then(({ default: e }) => e({ locateFile: (t) => Ja(`geoscene/geometry/support/${t}`) })).then((e) => {
    Kj(e);
  }), tS);
}
var $T, Zt, xT;
(function(e) {
  function t(s, o, a) {
    F.ensureCache.prepare();
    const l = Zc(a), c = a === l, h = F.ensureFloat64(l), f = F._pe_geog_to_proj(F.getPointer(s), o, h);
    return f && gu(a, o, h, c), f;
  }
  function r(s, o, a, l) {
    switch (l) {
      case Zt.PE_TRANSFORM_P_TO_G:
        return n(s, o, a);
      case Zt.PE_TRANSFORM_G_TO_P:
        return t(s, o, a);
    }
    return 0;
  }
  function n(s, o, a) {
    return i(s, o, a, 0);
  }
  function i(s, o, a, l) {
    F.ensureCache.prepare();
    const c = Zc(a), h = a === c, f = F.ensureFloat64(c), m = F._pe_proj_to_geog_center(F.getPointer(s), o, f, l);
    return m && gu(a, o, f, h), m;
  }
  e.geogToProj = t, e.projGeog = r, e.projToGeog = n, e.projToGeogCenter = i;
})($T || ($T = {})), function(e) {
  function t() {
    e.PE_BUFFER_MAX = F.PeDefs.prototype.PE_BUFFER_MAX, e.PE_NAME_MAX = F.PeDefs.prototype.PE_NAME_MAX, e.PE_MGRS_MAX = F.PeDefs.prototype.PE_MGRS_MAX, e.PE_USNG_MAX = F.PeDefs.prototype.PE_USNG_MAX, e.PE_DD_MAX = F.PeDefs.prototype.PE_DD_MAX, e.PE_DDM_MAX = F.PeDefs.prototype.PE_DDM_MAX, e.PE_DMS_MAX = F.PeDefs.prototype.PE_DMS_MAX, e.PE_UTM_MAX = F.PeDefs.prototype.PE_UTM_MAX, e.PE_PARM_MAX = F.PeDefs.prototype.PE_PARM_MAX, e.PE_TYPE_NONE = F.PeDefs.prototype.PE_TYPE_NONE, e.PE_TYPE_GEOGCS = F.PeDefs.prototype.PE_TYPE_GEOGCS, e.PE_TYPE_PROJCS = F.PeDefs.prototype.PE_TYPE_PROJCS, e.PE_TYPE_GEOGTRAN = F.PeDefs.prototype.PE_TYPE_GEOGTRAN, e.PE_TYPE_COORDSYS = F.PeDefs.prototype.PE_TYPE_COORDSYS, e.PE_TYPE_UNIT = F.PeDefs.prototype.PE_TYPE_UNIT, e.PE_TYPE_LINUNIT = F.PeDefs.prototype.PE_TYPE_LINUNIT, e.PE_STR_OPTS_NONE = F.PeDefs.prototype.PE_STR_OPTS_NONE, e.PE_STR_AUTH_NONE = F.PeDefs.prototype.PE_STR_AUTH_NONE, e.PE_STR_AUTH_TOP = F.PeDefs.prototype.PE_STR_AUTH_TOP, e.PE_STR_NAME_CANON = F.PeDefs.prototype.PE_STR_NAME_CANON, e.PE_PARM_X0 = F.PeDefs.prototype.PE_PARM_X0, e.PE_PARM_ND = F.PeDefs.prototype.PE_PARM_ND, e.PE_TRANSFORM_1_TO_2 = F.PeDefs.prototype.PE_TRANSFORM_1_TO_2, e.PE_TRANSFORM_2_TO_1 = F.PeDefs.prototype.PE_TRANSFORM_2_TO_1, e.PE_TRANSFORM_P_TO_G = F.PeDefs.prototype.PE_TRANSFORM_P_TO_G, e.PE_TRANSFORM_G_TO_P = F.PeDefs.prototype.PE_TRANSFORM_G_TO_P, e.PE_HORIZON_RECT = F.PeDefs.prototype.PE_HORIZON_RECT, e.PE_HORIZON_POLY = F.PeDefs.prototype.PE_HORIZON_POLY, e.PE_HORIZON_LINE = F.PeDefs.prototype.PE_HORIZON_LINE, e.PE_HORIZON_DELTA = F.PeDefs.prototype.PE_HORIZON_DELTA;
  }
  e.init = t;
}(Zt || (Zt = {})), function(e) {
  const t = {}, r = {}, n = (y) => {
    if (y) {
      const g = y.getType();
      switch (g) {
        case Zt.PE_TYPE_GEOGCS:
          y = F.castObject(y, F.PeGeogcs);
          break;
        case Zt.PE_TYPE_PROJCS:
          y = F.castObject(y, F.PeProjcs);
          break;
        case Zt.PE_TYPE_GEOGTRAN:
          y = F.castObject(y, F.PeGeogtran);
          break;
        default:
          g & Zt.PE_TYPE_UNIT && (y = F.castObject(y, F.PeUnit));
      }
    }
    return y;
  };
  function i() {
    F.PeFactory.prototype.initialize(null);
  }
  function s(y) {
    return o(Zt.PE_TYPE_COORDSYS, y);
  }
  function o(y, g) {
    let v = null, b = t[y];
    if (b || (b = {}, t[y] = b), b.hasOwnProperty(String(g)))
      v = b[g];
    else {
      const w = F.PeFactory.prototype.factoryByType(y, g);
      F.compare(w, F.NULL) || (v = w, b[g] = v);
    }
    return v = n(v), v;
  }
  function a(y, g) {
    let v = null, b = r[y];
    if (b || (b = {}, r[y] = b), b.hasOwnProperty(g))
      v = b[g];
    else {
      const w = F.PeFactory.prototype.fromString(y, g);
      F.compare(w, F.NULL) || (v = w, b[g] = v);
    }
    return v = n(v), v;
  }
  function l(y) {
    return o(Zt.PE_TYPE_GEOGCS, y);
  }
  function c(y) {
    return o(Zt.PE_TYPE_GEOGTRAN, y);
  }
  function h(y) {
    return F.PeFactory.prototype.getCode(y);
  }
  function f(y) {
    return o(Zt.PE_TYPE_PROJCS, y);
  }
  function m(y) {
    return o(Zt.PE_TYPE_UNIT, y);
  }
  e.initialize = i, e.coordsys = s, e.factoryByType = o, e.fromString = a, e.geogcs = l, e.geogtran = c, e.getCode = h, e.projcs = f, e.unit = m;
}(xT || (xT = {}));
let Zj = null;
var Gb, TT, ET, IT, Hb, MT, Wb, Jb, OT;
function Kj(e) {
  function t(s, o, a) {
    s[o] = a(s[o]);
  }
  F = e, Zt.init(), Gb.init(), Hb.init(), Wb.init(), Jb.init(), Zj = class extends F.PeGCSExtent {
    destroy() {
      F.destroy(this);
    }
  };
  const r = [F.PeDatum, F.PeGeogcs, F.PeGeogtran, F.PeObject, F.PeParameter, F.PePrimem, F.PeProjcs, F.PeSpheroid, F.PeUnit];
  for (const s of r)
    t(s.prototype, "getName", (o) => function() {
      return o.call(this, new Array(Zt.PE_NAME_MAX));
    });
  for (const s of [F.PeGeogtran, F.PeProjcs])
    t(s.prototype, "getParameters", (o) => function() {
      const a = new Array(Zt.PE_PARM_MAX);
      let l = o.call(this);
      for (let c = 0; c < a.length; c++) {
        const h = F.getValue(l, "*");
        a[c] = h ? F.wrapPointer(h, F.PeParameter) : null, l += Int32Array.BYTES_PER_ELEMENT;
      }
      return a;
    });
  t(F.PeHorizon.prototype, "getCoord", (s) => function() {
    const o = this.getSize();
    if (!o)
      return null;
    const a = [];
    return gu(a, o, s.call(this)), a;
  }), t(F.PeGTlistExtendedEntry.prototype, "getEntries", (s) => {
    const o = F._pe_getPeGTlistExtendedGTsSize();
    return function() {
      let a = null;
      const l = s.call(this);
      if (!F.compare(l, F.NULL)) {
        a = [l];
        const c = this.getSteps();
        if (c > 1) {
          const h = F.getPointer(l);
          for (let f = 1; f < c; f++)
            a.push(F.wrapPointer(h + o * f, F.PeGTlistExtendedGTs));
        }
      }
      return a;
    };
  });
  const n = F._pe_getPeHorizonSize(), i = (s) => function() {
    let o = this._cache;
    if (o || (o = /* @__PURE__ */ new Map(), this._cache = o), o.has(s))
      return o.get(s);
    let a = null;
    const l = s.call(this);
    if (!F.compare(l, F.NULL)) {
      a = [l];
      const c = l.getNump();
      if (c > 1) {
        const h = F.getPointer(l);
        for (let f = 1; f < c; f++)
          a.push(F.wrapPointer(h + n * f, F.PeHorizon));
      }
    }
    return o.set(s, a), a;
  };
  t(F.PeProjcs.prototype, "horizonGcsGenerate", i), t(F.PeProjcs.prototype, "horizonPcsGenerate", i), F.PeObject.prototype.toString = function(s = Zt.PE_STR_OPTS_NONE) {
    F.ensureCache.prepare();
    const o = F.getPointer(this), a = F.ensureInt8(new Array(Zt.PE_BUFFER_MAX));
    return F.UTF8ToString(F._pe_object_to_string_ext(o, s, a));
  };
}
function ma(e) {
  if (!e)
    return;
  const t = F.getClass(e);
  if (!t)
    return;
  const r = F.getCache(t);
  if (!r)
    return;
  const n = F.getPointer(e);
  n && delete r[n];
}
function U0(e, t) {
  const r = [], n = new Array(t);
  for (let i = 0; i < e; i++)
    r.push(F.ensureInt8(n));
  return r;
}
function Zc(e) {
  let t;
  return Array.isArray(e[0]) ? (t = [], e.forEach((r) => {
    t.push(r[0], r[1]);
  })) : t = e, t;
}
function gu(e, t, r, n = !1) {
  if (n)
    for (let i = 0; i < 2 * t; i++)
      e[i] = F.getValue(r + i * Float64Array.BYTES_PER_ELEMENT, "double");
  else {
    const i = e.length === 0;
    for (let s = 0; s < t; s++)
      i && (e[s] = new Array(2)), e[s][0] = F.getValue(r, "double"), e[s][1] = F.getValue(r + Float64Array.BYTES_PER_ELEMENT, "double"), r += 2 * Float64Array.BYTES_PER_ELEMENT;
  }
}
(function(e) {
  let t;
  function r() {
    e.PE_GTLIST_OPTS_COMMON = F.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON, t = F._pe_getPeGTlistExtendedEntrySize();
  }
  function n(i, s, o, a, l, c) {
    let h = null;
    const f = new F.PeInteger(c);
    try {
      const m = F.PeGTlistExtended.prototype.getGTlist(i, s, o, a, l, f);
      if ((c = f.val) && (h = [m], c > 1)) {
        const y = F.getPointer(m);
        for (let g = 1; g < c; g++)
          h.push(F.wrapPointer(y + t * g, F.PeGTlistExtendedEntry));
      }
    } finally {
      F.destroy(f);
    }
    return h;
  }
  e.init = r, e.getGTlist = n;
})(Gb || (Gb = {})), function(e) {
  function t(r) {
    if (r && r.length) {
      for (const n of r)
        ma(n), n.getEntries().forEach((i) => {
          ma(i);
          const s = i.getGeogtran();
          ma(s), s.getParameters().forEach(ma), [s.getGeogcs1(), s.getGeogcs2()].forEach((o) => {
            ma(o);
            const a = o.getDatum();
            ma(a), ma(a.getSpheroid()), ma(o.getPrimem()), ma(o.getUnit());
          });
        });
      F.PeGTlistExtendedEntry.prototype.Delete(r[0]);
    }
  }
  e.destroy = t;
}(TT || (TT = {})), function(e) {
  function t(r, n, i, s, o) {
    F.ensureCache.prepare();
    const a = Zc(i), l = i === a, c = F.ensureFloat64(a);
    let h = 0;
    s && (h = F.ensureFloat64(s));
    const f = F._pe_geog_to_geog(F.getPointer(r), n, c, h, o);
    return f && gu(i, n, c, l), f;
  }
  e.geogToGeog = t;
}(ET || (ET = {})), function(e) {
  const t = (c, h, f, m, y, g) => {
    let v, b;
    switch (F.ensureCache.prepare(), c) {
      case "dd":
        v = F._pe_geog_to_dd, b = Zt.PE_DD_MAX;
        break;
      case "ddm":
        v = F._pe_geog_to_ddm, b = Zt.PE_DDM_MAX;
        break;
      case "dms":
        v = F._pe_geog_to_dms, b = Zt.PE_DMS_MAX;
    }
    let w = 0;
    h && (w = F.getPointer(h));
    const x = Zc(m), $ = F.ensureFloat64(x), T = U0(f, b), C = v(w, f, $, y, F.ensureInt32(T));
    if (C)
      for (let I = 0; I < f; I++)
        g[I] = F.UTF8ToString(T[I]);
    return C;
  }, r = (c, h, f, m, y) => {
    let g;
    switch (F.ensureCache.prepare(), c) {
      case "dd":
        g = F._pe_dd_to_geog;
        break;
      case "ddm":
        g = F._pe_ddm_to_geog;
        break;
      case "dms":
        g = F._pe_dms_to_geog;
    }
    let v = 0;
    h && (v = F.getPointer(h));
    const b = m.map((T) => F.ensureString(T)), w = F.ensureInt32(b), x = F.ensureFloat64(new Array(2 * f)), $ = g(v, f, w, x);
    return $ && gu(y, f, x), $;
  };
  function n(c, h, f, m, y) {
    return t("dms", c, h, f, m, y);
  }
  function i(c, h, f, m) {
    return r("dms", c, h, f, m);
  }
  function s(c, h, f, m, y) {
    return t("ddm", c, h, f, m, y);
  }
  function o(c, h, f, m) {
    return r("ddm", c, h, f, m);
  }
  function a(c, h, f, m, y) {
    return t("dd", c, h, f, m, y);
  }
  function l(c, h, f, m) {
    return r("dd", c, h, f, m);
  }
  e.geogToDms = n, e.dmsToGeog = i, e.geogToDdm = s, e.ddmToGeog = o, e.geogToDd = a, e.ddToGeog = l;
}(IT || (IT = {})), function(e) {
  function t() {
    e.PE_MGRS_STYLE_NEW = F.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW, e.PE_MGRS_STYLE_OLD = F.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD, e.PE_MGRS_STYLE_AUTO = F.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO, e.PE_MGRS_180_ZONE_1_PLUS = F.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS, e.PE_MGRS_ADD_SPACES = F.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES;
  }
  function r(i, s, o, a, l, c, h) {
    F.ensureCache.prepare();
    let f = 0;
    i && (f = F.getPointer(i));
    const m = Zc(o), y = F.ensureFloat64(m), g = U0(s, Zt.PE_MGRS_MAX), v = F.ensureInt32(g), b = F._pe_geog_to_mgrs_extended(f, s, y, a, l, c, v);
    if (b)
      for (let w = 0; w < s; w++)
        h[w] = F.UTF8ToString(g[w]);
    return b;
  }
  function n(i, s, o, a, l) {
    F.ensureCache.prepare();
    let c = 0;
    i && (c = F.getPointer(i));
    const h = o.map((g) => F.ensureString(g)), f = F.ensureInt32(h), m = F.ensureFloat64(new Array(2 * s)), y = F._pe_mgrs_to_geog_extended(c, s, f, a, m);
    return y && gu(l, s, m), y;
  }
  e.init = t, e.geogToMgrsExtended = r, e.mgrsToGeogExtended = n;
}(Hb || (Hb = {})), function(e) {
  function t(n, i, s, o, a, l, c) {
    F.ensureCache.prepare();
    let h = 0;
    n && (h = F.getPointer(n));
    const f = Zc(s), m = F.ensureFloat64(f), y = U0(i, Zt.PE_MGRS_MAX), g = F.ensureInt32(y), v = F._pe_geog_to_usng(h, i, m, o, a, l, g);
    if (v)
      for (let b = 0; b < i; b++)
        c[b] = F.UTF8ToString(y[b]);
    return v;
  }
  function r(n, i, s, o) {
    F.ensureCache.prepare();
    let a = 0;
    n && (a = F.getPointer(n));
    const l = s.map((m) => F.ensureString(m)), c = F.ensureInt32(l), h = F.ensureFloat64(new Array(2 * i)), f = F._pe_usng_to_geog(a, i, c, h);
    return f && gu(o, i, h), f;
  }
  e.geogToUsng = t, e.usngToGeog = r;
}(MT || (MT = {})), function(e) {
  function t() {
    e.PE_UTM_OPTS_NONE = F.PeNotationUtm.prototype.PE_UTM_OPTS_NONE, e.PE_UTM_OPTS_ADD_SPACES = F.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES, e.PE_UTM_OPTS_NS = F.PeNotationUtm.prototype.PE_UTM_OPTS_NS;
  }
  function r(i, s, o, a, l) {
    F.ensureCache.prepare();
    let c = 0;
    i && (c = F.getPointer(i));
    const h = Zc(o), f = F.ensureFloat64(h), m = U0(s, Zt.PE_UTM_MAX), y = F.ensureInt32(m), g = F._pe_geog_to_utm(c, s, f, a, y);
    if (g)
      for (let v = 0; v < s; v++)
        l[v] = F.UTF8ToString(m[v]);
    return g;
  }
  function n(i, s, o, a, l) {
    F.ensureCache.prepare();
    let c = 0;
    i && (c = F.getPointer(i));
    const h = o.map((g) => F.ensureString(g)), f = F.ensureInt32(h), m = F.ensureFloat64(new Array(2 * s)), y = F._pe_utm_to_geog(c, s, f, a, m);
    return y && gu(l, s, m), y;
  }
  e.init = t, e.geogToUtm = r, e.utmToGeog = n;
}(Wb || (Wb = {})), function(e) {
  const t = /* @__PURE__ */ new Map();
  function r() {
    e.PE_PCSINFO_OPTION_NONE = F.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE, e.PE_PCSINFO_OPTION_DOMAIN = F.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN, e.PE_POLE_OUTSIDE_BOUNDARY = F.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY, e.PE_POLE_POINT = F.PePCSInfo.prototype.PE_POLE_POINT;
  }
  function n(i, s = e.PE_PCSINFO_OPTION_DOMAIN) {
    let o = null, a = null;
    return t.has(i) && (a = t.get(i), a[s] && (o = a[s])), o || (o = F.PePCSInfo.prototype.generate(i, s), a || (a = [], t.set(i, a)), a[s] = o), o;
  }
  e.init = r, e.generate = n;
}(Jb || (Jb = {})), function(e) {
  function t() {
    return F.PeVersion.prototype.version_string();
  }
  e.versionString = t;
}(OT || (OT = {}));
const _se = Object.freeze(Object.defineProperty({ __proto__: null, get PeCSTransformations() {
  return $T;
}, get PeDefs() {
  return Zt;
}, get PeFactory() {
  return xT;
}, get PeGCSExtent() {
  return Zj;
}, get PeGTTransformations() {
  return ET;
}, get PeGTlistExtended() {
  return Gb;
}, get PeGTlistExtendedEntry() {
  return TT;
}, get PeNotationDms() {
  return IT;
}, get PeNotationMgrs() {
  return Hb;
}, get PeNotationUsng() {
  return MT;
}, get PeNotationUtm() {
  return Wb;
}, get PePCSInfo() {
  return Jb;
}, get PeVersion() {
  return OT;
}, _init: Kj, get _pe() {
  return F;
}, isLoaded: iO, isSupported: wse, load: Jj }, Symbol.toStringTag, { value: "Module" })), El = Bt.radius, As = Bt.eccentricitySquared, Sse = { a1: El * As, a2: El * As * El * As, a3: El * As * As / 2, a4: El * As * El * As * 2.5, a5: El * As + El * As * As / 2, a6: 1 - As };
1 / 294.9786982, 1 / 298.257222101, Bt.radius, Bt.flattening, ku.radius, ku.flattening, 1 / 192.0430107526882, Xa.radius, Xa.flattening, 1 / 10.2079945799458, 1 / 43.61604095563141, Xa.radius;
let B0 = 0, rS = class CT {
  static fromGE(t) {
    const r = new CT();
    return r._wkt = t.wkt, r._wkid = t.wkid, r._isInverse = t.isInverse, r;
  }
  constructor(t) {
    this.uid = B0++, t ? (this._wkt = t.wkt != null ? t.wkt : null, this._wkid = t.wkid != null ? t.wkid : -1, this._isInverse = t.isInverse != null && t.isInverse === !0) : (this._wkt = null, this._wkid = -1, this._isInverse = !1);
  }
  get wkt() {
    return this._wkt;
  }
  set wkt(t) {
    this._wkt = t, this.uid = B0++;
  }
  get wkid() {
    return this._wkid;
  }
  set wkid(t) {
    this._wkid = t, this.uid = B0++;
  }
  get isInverse() {
    return this._isInverse;
  }
  set isInverse(t) {
    this._isInverse = t, this.uid = B0++;
  }
  getInverse() {
    const t = new CT();
    return t._wkt = this.wkt, t._wkid = this._wkid, t._isInverse = !this.isInverse, t;
  }
}, kT = class Nm {
  static cacheKey(t, r) {
    return [t.wkid !== void 0 && t.wkid !== null ? t.wkid.toString() : "-1", t.wkt !== void 0 && t.wkt !== null ? t.wkt.toString() : "", r.wkid !== void 0 && r.wkid !== null ? r.wkid.toString() : "-1", r.wkt !== void 0 && r.wkt !== null ? r.wkt.toString() : ""].join(",");
  }
  static fromGE(t) {
    const r = new Nm();
    let n = "";
    for (const i of t.steps) {
      const s = rS.fromGE(i);
      r.steps.push(s), n += s.uid.toString() + ",";
    }
    return r._cachedProjection = {}, r._gtlistentry = null, r._chain = n, r;
  }
  constructor(t) {
    if (this.steps = [], this._cachedProjection = {}, this._chain = "", this._gtlistentry = null, t && t.steps)
      for (const r of t.steps)
        r instanceof rS ? this.steps.push(r) : this.steps.push(new rS({ wkid: r.wkid, wkt: r.wkt, isInverse: r.isInverse }));
  }
  getInverse() {
    const t = new Nm();
    t.steps = [];
    for (let r = this.steps.length - 1; r >= 0; r--) {
      const n = this.steps[r];
      t.steps.push(n.getInverse());
    }
    return t;
  }
  getGTListEntry() {
    let t = "";
    for (const r of this.steps)
      t += r.uid.toString() + ",";
    return t !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = t), this._gtlistentry;
  }
  assignCachedGe(t, r, n) {
    this._cachedProjection[Nm.cacheKey(t, r)] = n;
  }
  getCachedGeTransformation(t, r) {
    let n = "";
    for (const s of this.steps)
      n += s.uid.toString() + ",";
    n !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = n);
    const i = this._cachedProjection[Nm.cacheKey(t, r)];
    return i === void 0 ? null : i;
  }
};
function Yj(e, t, r) {
  if (t == null || r == null || r.vcsWkid || tn(t, r))
    return null;
  const n = Ib(t) / Ib(r);
  if (n === 1)
    return null;
  switch (e) {
    case "point":
    case "esriGeometryPoint":
      return (i) => $se(i, n);
    case "polyline":
    case "esriGeometryPolyline":
      return (i) => Tse(i, n);
    case "polygon":
    case "esriGeometryPolygon":
      return (i) => xse(i, n);
    case "multipoint":
    case "esriGeometryMultipoint":
      return (i) => Ese(i, n);
    case "extent":
    case "esriGeometryEnvelope":
      return (i) => Ise(i, n);
    default:
      return null;
  }
}
function $se(e, t) {
  e && e.z != null && (e.z *= t);
}
function xse(e, t) {
  if (e)
    for (const r of e.rings)
      for (const n of r)
        n.length > 2 && (n[2] *= t);
}
function Tse(e, t) {
  if (e)
    for (const r of e.paths)
      for (const n of r)
        n.length > 2 && (n[2] *= t);
}
function Ese(e, t) {
  if (e)
    for (const r of e.points)
      r.length > 2 && (r[2] *= t);
}
function Ise(e, t) {
  e && e.zmin != null && e.zmax != null && (e.zmin *= t, e.zmax *= t);
}
let Eu = null, sg = null, nS = null, iS = {};
const Qj = new t_();
function rp() {
  return !!Eu && iO();
}
function Ru(e) {
  return nS == null && (nS = Promise.all([Jj(), import("./geometryEngineBase-pA8XZVjJ.js").then((t) => t.g), import("./hydrated-9SHPxADM.js")])), nS.then(([, t, { hydratedAdapter: r }]) => {
    lr(e), sg = r, Eu = t.default, Eu._enableProjection(_se), Qj.notify();
  });
}
function Ju(e, t, r = null, n = null) {
  return Array.isArray(e) ? e.length === 0 ? [] : AT(sg, e, e[0].spatialReference, t, r, n) : AT(sg, [e], e.spatialReference, t, r, n)[0];
}
function AT(e, t, r, n, i = null, s = null) {
  if (r == null || n == null)
    return t;
  if (ll(r, n, i))
    return t.map((o) => n9(o, r, n));
  if (i == null) {
    const o = kT.cacheKey(r, n);
    iS[o] !== void 0 ? i = iS[o] : ((i = e9(r, n, void 0)) == null && (i = new kT()), iS[o] = i);
  }
  if (Eu == null || e == null)
    throw new sO();
  return s != null ? Eu._project(e, t, r, n, i, s) : Eu._project(e, t, r, n, i);
}
function Mse(e, t) {
  const r = Xj([e], t);
  return r.pending != null ? { pending: r.pending, geometry: null } : r.geometries != null ? { pending: null, geometry: r.geometries[0] } : { pending: null, geometry: null };
}
function Xj(e, t) {
  if (!rp()) {
    for (const r of e)
      if (r != null && !tn(r.spatialReference, t) && en(r.spatialReference) && en(t) && !ll(r.spatialReference, t))
        return Ve(Qj), { pending: Ru(), geometries: null };
  }
  return { pending: null, geometries: e.map((r) => r == null ? null : tn(r.spatialReference, t) ? r : en(r.spatialReference) && en(t) ? t9(r, t) : null) };
}
function e9(e, t, r = null) {
  if (e == null || t == null)
    return null;
  if (Eu == null || sg == null)
    throw new sO();
  const n = Eu._getTransformation(sg, e, t, r, r == null ? void 0 : r.spatialReference);
  return n !== null ? kT.fromGE(n) : null;
}
class sO extends G {
  constructor() {
    super("projection:not-loaded", "projection engine not fully loaded yet, please call load()");
  }
}
var P;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.SPHERICAL_ECEF = 1] = "SPHERICAL_ECEF", e[e.WGS84 = 2] = "WGS84", e[e.WEB_MERCATOR = 3] = "WEB_MERCATOR", e[e.WGS84_ECEF = 4] = "WGS84_ECEF", e[e.CGCS2000 = 5] = "CGCS2000", e[e.WGS84_COMPARABLE_LON_LAT = 6] = "WGS84_COMPARABLE_LON_LAT", e[e.SPHERICAL_MARS_PCPF = 7] = "SPHERICAL_MARS_PCPF", e[e.GCSMARS2000 = 8] = "GCSMARS2000", e[e.SPHERICAL_MOON_PCPF = 9] = "SPHERICAL_MOON_PCPF", e[e.GCSMOON2000 = 10] = "GCSMOON2000", e[e.LON_LAT = 11] = "LON_LAT", e[e.PLATE_CARREE = 12] = "PLATE_CARREE";
})(P || (P = {}));
function t9(e, t) {
  try {
    const r = Ju(e, t);
    if (r == null)
      return null;
    "xmin" in e && "xmin" in r && (r.zmin = e.zmin, r.zmax = e.zmax);
    const n = Yj(r.type, e.spatialReference, t);
    return n != null && n(r), r;
  } catch (r) {
    if (!(r instanceof sO))
      throw r;
    return null;
  }
}
function ll(e, t, r) {
  return !r && (!!tn(e, t) || en(e) && en(t) && !!l9(e, t, u9));
}
async function r9(e, t, r, n) {
  if (rp())
    return Sk(n);
  if (Array.isArray(e)) {
    for (const { source: i, dest: s, geographicTransformation: o } of e)
      if (!ll(i, s, o))
        return Ru(n);
  } else if (!ll(e, t, r))
    return Ru(n);
  return Sk(n);
}
function n9(e, t, r) {
  return e ? "x" in e ? Ose(e, t, new Re(), r, 0) : "xmin" in e ? Pse(e, t, new Ct(), r, 0) : "rings" in e ? i9(e, t, new af(), r, 0) : "paths" in e ? kse(e, t, new d_(), r, 0) : "points" in e ? Cse(e, t, new c_(), r, 0) : null : null;
}
function Ose(e, t, r, n, i) {
  Cr[0] = e.x, Cr[1] = e.y;
  const s = e.z;
  return Cr[2] = s !== void 0 ? s : i, yf(Cr, t, 0, Cr, n, 0, 1) ? (r.x = Cr[0], r.y = Cr[1], r.spatialReference = n, s === void 0 ? (r.z = void 0, r.hasZ = !1) : (r.z = Cr[2], r.hasZ = !0), e.m === void 0 ? (r.m = void 0, r.hasM = !1) : (r.m = e.m, r.hasM = !0), r) : null;
}
function Cse(e, t, r, n, i) {
  const { points: s, hasZ: o, hasM: a } = e, l = [], c = s.length, h = [];
  for (const f of s)
    h.push(f[0], f[1], o ? f[2] : i);
  if (!yf(h, t, 0, h, n, 0, c))
    return null;
  for (let f = 0; f < c; ++f) {
    const m = 3 * f, y = h[m], g = h[m + 1];
    o && a ? l.push([y, g, h[m + 2], s[f][3]]) : o ? l.push([y, g, h[m + 2]]) : a ? l.push([y, g, s[f][2]]) : l.push([y, g]);
  }
  return r.points = l, r.spatialReference = n, r.hasZ = o, r.hasM = a, r;
}
function kse(e, t, r, n, i) {
  const { paths: s, hasZ: o, hasM: a } = e, l = [];
  return s9(s, o ?? !1, a ?? !1, t, l, n, i) ? (r.paths = l, r.spatialReference = n, r.hasZ = o, r.hasM = a, r) : null;
}
function Ase(e, t, r = t.spatialReference, n = 0) {
  return e.spatialReference != null && r != null && i9(e, e.spatialReference, t, r, n) != null;
}
function i9(e, t, r, n, i) {
  const { rings: s, hasZ: o, hasM: a } = e, l = [];
  return s9(s, o ?? !1, a ?? !1, t, l, n, i) ? (r.rings = l, r.spatialReference = n, r.hasZ = o, r.hasM = a, r) : null;
}
function Pse(e, t, r, n, i) {
  const { xmin: s, ymin: o, xmax: a, ymax: l, hasZ: c, hasM: h } = e;
  return PT(s, o, c ? e.zmin : i, t, Cr, n) ? (r.xmin = Cr[0], r.ymin = Cr[1], c && (r.zmin = Cr[2]), PT(a, l, c ? e.zmax : i, t, Cr, n) ? (r.xmax = Cr[0], r.ymax = Cr[1], c && (r.zmax = Cr[2]), h && (r.mmin = e.mmin, r.mmax = e.mmax), r.spatialReference = n, r) : null) : null;
}
function Rse(e, t, r, n = 0) {
  Cr[0] = e.x, Cr[1] = e.y;
  const i = e.z;
  return Cr[2] = i !== void 0 ? i : n, yf(Cr, e.spatialReference, 0, t, r, 0, 1);
}
function PT(e, t, r, n, i, s) {
  return q0[0] = e, q0[1] = t, q0[2] = r, yf(q0, n, 0, i, s, 0, 1);
}
function yf(e, t, r, n, i, s, o = 1) {
  const a = l9(t, i, u9);
  if (a == null)
    return !1;
  if (a === It) {
    if (e === n && r === s)
      return !0;
    const c = r + 3 * o;
    for (let h = r, f = s; h < c; h++, f++)
      n[f] = e[h];
    return !0;
  }
  const l = r + 3 * o;
  for (let c = r, h = s; c < l; c += 3, h += 3)
    a(e, c, n, h);
  return !0;
}
function s9(e, t, r, n, i, s, o = 0) {
  const a = new Array();
  for (const c of e)
    for (const h of c)
      a.push(h[0], h[1], t ? h[2] : o);
  if (!yf(a, n, 0, a, s, 0, a.length / 3))
    return !1;
  let l = 0;
  i.length = 0;
  for (const c of e) {
    const h = new Array();
    for (const f of c)
      t && r ? h.push([a[l++], a[l++], a[l++], f[3]]) : t ? h.push([a[l++], a[l++], a[l++]]) : r ? (h.push([a[l++], a[l++], f[2]]), l++) : (h.push([a[l++], a[l++]]), l++);
    i.push(h);
  }
  return !0;
}
function Lse(e, t, r, n) {
  if (e == null || n == null)
    return !1;
  const i = Zb(e, Kse), s = Zb(n, Yse);
  if (i === s && !aP(s) && (i !== P.UNKNOWN || tn(e, n)))
    return Gj(r, t), !0;
  if (aP(s)) {
    const o = Fm[i][P.LON_LAT], a = Fm[P.LON_LAT][s];
    return o != null && a != null && (o(t, 0, Il, 0), a(Il, 0, Ml, 0), oO(Zo * Il[0], Zo * Il[1], r), r[12] = Ml[0], r[13] = Ml[1], r[14] = Ml[2], !0);
  }
  if ((s === P.WEB_MERCATOR || s === P.PLATE_CARREE) && (i === P.WGS84 || i === P.CGCS2000 && s === P.PLATE_CARREE || i === P.SPHERICAL_ECEF || i === P.WEB_MERCATOR)) {
    const o = Fm[i][P.LON_LAT], a = Fm[P.LON_LAT][s];
    return o != null && a != null && (o(t, 0, Il, 0), a(Il, 0, Ml, 0), i === P.SPHERICAL_ECEF ? o9(Zo * Il[0], Zo * Il[1], r) : Jg(r), r[12] = Ml[0], r[13] = Ml[1], r[14] = Ml[2], !0);
  }
  return !1;
}
function aP(e) {
  return e === P.SPHERICAL_ECEF || e === P.SPHERICAL_MARS_PCPF || e === P.SPHERICAL_MOON_PCPF;
}
function oO(e, t, r) {
  const n = Math.sin(e), i = Math.cos(e), s = Math.sin(t), o = Math.cos(t), a = r;
  return a[0] = -n, a[4] = -s * i, a[8] = o * i, a[12] = 0, a[1] = i, a[5] = -s * n, a[9] = o * n, a[13] = 0, a[2] = 0, a[6] = o, a[10] = s, a[14] = 0, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, a;
}
function o9(e, t, r) {
  return oO(e, t, r), hl(r, r), r;
}
function Zb(e, t) {
  return e ? t.spatialReference === e ? t.spatialReferenceId : (t.spatialReference = e, "metersPerUnit" in t && (t.metersPerUnit = Yd(e, 1)), e.wkt === BZ.wkt ? t.spatialReferenceId = P.SPHERICAL_ECEF : Wy(e) ? t.spatialReferenceId = P.WGS84 : Md(e) ? t.spatialReferenceId = P.WEB_MERCATOR : DZ(e) ? t.spatialReferenceId = P.PLATE_CARREE : e.wkt === qZ.wkt ? t.spatialReferenceId = P.WGS84_ECEF : e.wkid === Id.CGCS2000 ? t.spatialReferenceId = P.CGCS2000 : e.wkt === p6.wkt ? t.spatialReferenceId = P.SPHERICAL_MARS_PCPF : e.wkt === h6.wkt ? t.spatialReferenceId = P.SPHERICAL_MOON_PCPF : oM(e) ? t.spatialReferenceId = P.GCSMARS2000 : lM(e) ? t.spatialReferenceId = P.GCSMOON2000 : t.spatialReferenceId = P.UNKNOWN) : P.UNKNOWN;
}
function It(e, t, r, n) {
  e !== r && (r[n++] = e[t++], r[n++] = e[t++], r[n] = e[t]);
}
function wh(e, t, r, n) {
  r[n++] = Vh * (e[t++] / Bt.radius), r[n++] = Vh * (Math.PI / 2 - 2 * Math.atan(Math.exp(-e[t++] / Bt.radius))), r[n] = e[t];
}
function Nse(e, t, r, n) {
  wh(e, t, r, n), ad(r, n, r, n);
}
function Fse(e, t, r, n) {
  wh(e, t, r, n), ud(r, n, r, n);
}
function a9(e, t, r, n, i) {
  const s = 0.4999999 * Math.PI, o = ws(Zo * e[t + 1], -s, s), a = Math.sin(o);
  r[n++] = Zo * e[t] * i.radius, r[n++] = i.halfSemiMajorAxis * Math.log((1 + a) / (1 - a)), r[n] = e[t + 2];
}
function og(e, t, r, n) {
  a9(e, t, r, n, Bt);
}
const lP = Bt.radius * Math.PI / 180, uP = 180 / (Bt.radius * Math.PI);
function sd(e, t, r, n) {
  r[n] = e[t] * lP, r[n + 1] = e[t + 1] * lP, r[n + 2] = e[t + 2];
}
function od(e, t, r, n) {
  r[n] = e[t] * uP, r[n + 1] = e[t + 1] * uP, r[n + 2] = e[t + 2];
}
function Dse(e, t, r, n) {
  wh(e, t, r, n), sd(r, n, r, n);
}
function jse(e, t, r, n) {
  cd(e, t, r, n), sd(r, n, r, n);
}
function Vse(e, t, r, n) {
  ld(e, t, r, n), sd(r, n, r, n);
}
function zse(e, t, r, n) {
  od(e, t, r, n), ad(r, n, r, n);
}
function Use(e, t, r, n) {
  od(e, t, r, n), og(r, n, r, n);
}
function Bse(e, t, r, n) {
  od(e, t, r, n), ud(r, n, r, n);
}
function aO(e, t, r, n, i) {
  const s = i + e[t + 2], o = Zo * e[t + 1], a = Zo * e[t], l = Math.cos(o);
  r[n++] = Math.cos(a) * l * s, r[n++] = Math.sin(a) * l * s, r[n] = Math.sin(o) * s;
}
function cP(e, t, r, n) {
  aO(e, t, r, n, ku.radius);
}
function dP(e, t, r, n) {
  aO(e, t, r, n, Xa.radius);
}
function ad(e, t, r, n) {
  aO(e, t, r, n, Bt.radius);
}
function $_(e, t, r, n, i) {
  const s = e[t], o = e[t + 1], a = e[t + 2], l = Math.sqrt(s * s + o * o + a * a), c = u8(a / (l === 0 ? 1 : l)), h = Math.atan2(o, s);
  r[n++] = Vh * h, r[n++] = Vh * c, r[n] = l - i;
}
function pP(e, t, r, n) {
  $_(e, t, r, n, ku.radius);
}
function hP(e, t, r, n) {
  $_(e, t, r, n, Xa.radius);
}
function ld(e, t, r, n) {
  $_(e, t, r, n, Bt.radius);
}
function qse(e, t, r, n) {
  ld(e, t, r, n), og(r, n, r, n);
}
function Gse(e, t, r, n) {
  ld(e, t, r, n), ud(r, n, r, n);
}
function Hse(e, t, r, n, i) {
  const s = Zo * e[t], o = Zo * e[t + 1], a = e[t + 2], l = Math.sin(o), c = Math.cos(o), h = i.radius / Math.sqrt(1 - i.eccentricitySquared * l * l);
  r[n++] = (h + a) * c * Math.cos(s), r[n++] = (h + a) * c * Math.sin(s), r[n++] = (h * (1 - i.eccentricitySquared) + a) * l;
}
function ud(e, t, r, n) {
  Hse(e, t, r, n, Bt);
}
function cd(e, t, r, n) {
  const i = Sse, s = e[t], o = e[t + 1], a = e[t + 2];
  let l, c, h, f, m, y, g, v, b, w, x, $, T, C, I, O, M, L, N, ee, D;
  l = Math.abs(a), c = s * s + o * o, h = Math.sqrt(c), f = c + a * a, m = Math.sqrt(f), ee = Math.atan2(o, s), y = a * a / f, g = c / f, C = i.a2 / m, I = i.a3 - i.a4 / m, g > 0.3 ? (v = l / m * (1 + g * (i.a1 + C + y * I) / m), N = Math.asin(v), w = v * v, b = Math.sqrt(1 - w)) : (b = h / m * (1 - y * (i.a5 - C - g * I) / m), N = Math.acos(b), w = 1 - b * b, v = Math.sqrt(w)), x = 1 - Bt.eccentricitySquared * w, $ = Bt.radius / Math.sqrt(x), T = i.a6 * $, C = h - $ * b, I = l - T * v, M = b * C + v * I, O = b * I - v * C, L = O / (T / x + M), N += L, D = M + O * L / 2, a < 0 && (N = -N), r[n++] = Vh * ee, r[n++] = Vh * N, r[n] = D;
}
function Wse(e, t, r, n) {
  cd(e, t, r, n), ad(r, n, r, n);
}
function Jse(e, t, r, n) {
  cd(e, t, r, n), og(r, n, r, n);
}
const Fm = { [P.WGS84]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: It, [P.SPHERICAL_ECEF]: ad, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: og, [P.PLATE_CARREE]: sd, [P.WGS84]: It, [P.WGS84_ECEF]: ud }, [P.CGCS2000]: { [P.CGCS2000]: It, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: It, [P.SPHERICAL_ECEF]: ad, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: sd, [P.WGS84]: null, [P.WGS84_ECEF]: ud }, [P.GCSMARS2000]: { [P.CGCS2000]: null, [P.GCSMARS2000]: It, [P.GCSMOON2000]: null, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: null, [P.SPHERICAL_ECEF]: null, [P.SPHERICAL_MARS_PCPF]: dP, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: null, [P.WGS84]: null, [P.WGS84_ECEF]: null }, [P.GCSMOON2000]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: It, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: null, [P.SPHERICAL_ECEF]: null, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: cP, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: null, [P.WGS84]: null, [P.WGS84_ECEF]: null }, [P.WEB_MERCATOR]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: wh, [P.WGS84_COMPARABLE_LON_LAT]: wh, [P.SPHERICAL_ECEF]: Nse, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: It, [P.PLATE_CARREE]: Dse, [P.WGS84]: wh, [P.WGS84_ECEF]: Fse }, [P.WGS84_ECEF]: { [P.CGCS2000]: cd, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: cd, [P.WGS84_COMPARABLE_LON_LAT]: cd, [P.SPHERICAL_ECEF]: Wse, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: Jse, [P.PLATE_CARREE]: jse, [P.WGS84]: cd, [P.WGS84_ECEF]: It }, [P.SPHERICAL_ECEF]: { [P.CGCS2000]: ld, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: ld, [P.WGS84_COMPARABLE_LON_LAT]: ld, [P.SPHERICAL_ECEF]: It, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: qse, [P.PLATE_CARREE]: Vse, [P.WGS84]: ld, [P.WGS84_ECEF]: Gse }, [P.SPHERICAL_MARS_PCPF]: { [P.CGCS2000]: null, [P.GCSMARS2000]: hP, [P.GCSMOON2000]: null, [P.LON_LAT]: hP, [P.WGS84_COMPARABLE_LON_LAT]: null, [P.SPHERICAL_ECEF]: null, [P.SPHERICAL_MARS_PCPF]: It, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: null, [P.WGS84]: null, [P.WGS84_ECEF]: null }, [P.SPHERICAL_MOON_PCPF]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: pP, [P.LON_LAT]: pP, [P.WGS84_COMPARABLE_LON_LAT]: null, [P.SPHERICAL_ECEF]: null, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: It, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: null, [P.WGS84]: null, [P.WGS84_ECEF]: null }, [P.UNKNOWN]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: null, [P.WGS84_COMPARABLE_LON_LAT]: null, [P.SPHERICAL_ECEF]: null, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: It, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: null, [P.WGS84]: null, [P.WGS84_ECEF]: null }, [P.LON_LAT]: { [P.CGCS2000]: It, [P.GCSMARS2000]: It, [P.GCSMOON2000]: It, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: It, [P.SPHERICAL_ECEF]: ad, [P.SPHERICAL_MARS_PCPF]: dP, [P.SPHERICAL_MOON_PCPF]: cP, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: og, [P.PLATE_CARREE]: sd, [P.WGS84]: It, [P.WGS84_ECEF]: ud }, [P.WGS84_COMPARABLE_LON_LAT]: { [P.CGCS2000]: null, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: It, [P.WGS84_COMPARABLE_LON_LAT]: It, [P.SPHERICAL_ECEF]: ad, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: null, [P.PLATE_CARREE]: sd, [P.WGS84]: It, [P.WGS84_ECEF]: ud }, [P.PLATE_CARREE]: { [P.CGCS2000]: od, [P.GCSMARS2000]: null, [P.GCSMOON2000]: null, [P.LON_LAT]: od, [P.WGS84_COMPARABLE_LON_LAT]: od, [P.SPHERICAL_ECEF]: zse, [P.SPHERICAL_MARS_PCPF]: null, [P.SPHERICAL_MOON_PCPF]: null, [P.UNKNOWN]: null, [P.WEB_MERCATOR]: Use, [P.PLATE_CARREE]: It, [P.WGS84]: od, [P.WGS84_ECEF]: Bse } };
function l9(e, t, r = lO()) {
  return e == null || t == null ? null : Zse(e, t, r).projector;
}
function Zse(e, t, r) {
  if (e == null || t == null || r.source.spatialReference === e && r.dest.spatialReference === t)
    return r;
  const n = Zb(e, r.source), i = Zb(t, r.dest);
  return n === P.UNKNOWN && i === P.UNKNOWN ? tn(e, t) ? r.projector = It : r.projector = null : r.projector = Fm[n][i], r;
}
function lO() {
  return { source: { spatialReference: null, spatialReferenceId: P.UNKNOWN, metersPerUnit: 1 }, dest: { spatialReference: null, spatialReferenceId: P.UNKNOWN, metersPerUnit: 1 }, projector: It };
}
const Kse = { spatialReference: null, spatialReferenceId: P.UNKNOWN }, Yse = { spatialReference: null, spatialReferenceId: P.UNKNOWN }, u9 = lO();
lO();
const Zo = YQ(1), Vh = l8(1), q0 = da(), Il = da(), Ml = da(), Cr = da(), A4e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canProjectWithoutEngine: ll,
  computeENUToSphericalPCPFLocalRotation: oO,
  computeSphericalPCPFToENULocalRotation: o9,
  computeTranslationToOriginAndRotation: Lse,
  getTransformation: e9,
  initializeProjection: r9,
  isLoaded: rp,
  load: Ru,
  lonLatToWebMercatorComparable: a9,
  project: Ju,
  projectBuffer: yf,
  projectMany: AT,
  projectOrLoad: Mse,
  projectOrLoadMany: Xj,
  projectPointToVector: Rse,
  projectPolygon: Ase,
  projectWithoutEngine: n9,
  projectXYZToVector: PT,
  sphericalPCPFtoLonLatElevation: $_,
  tryProjectWithZConversion: t9
}, Symbol.toStringTag, { value: "Module" }));
var RT;
let No = RT = class extends re {
  constructor(e) {
    super(e), this.cols = null, this.level = 0, this.levelValue = null, this.origin = null, this.resolution = 0, this.rows = null, this.scale = 0;
  }
  clone() {
    return new RT({ cols: this.cols, level: this.level, levelValue: this.levelValue, resolution: this.resolution, rows: this.rows, scale: this.scale });
  }
};
u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], No.prototype, "cols", void 0), u([d({ type: Ot, json: { write: !0 } })], No.prototype, "level", void 0), u([d({ type: String, json: { write: !0 } })], No.prototype, "levelValue", void 0), u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], No.prototype, "origin", void 0), u([d({ type: Number, json: { write: !0 } })], No.prototype, "resolution", void 0), u([d({ json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], No.prototype, "rows", void 0), u([d({ type: Number, json: { write: !0 } })], No.prototype, "scale", void 0), No = RT = u([E("geoscene.layers.support.LOD")], No);
const du = No;
let Qse = class {
  constructor(t, r, n, i, s = void 0) {
    this.id = t, this.level = r, this.row = n, this.col = i, this.extent = s;
  }
};
var Wl;
const fP = new et({ PNG: "png", PNG8: "png8", PNG24: "png24", PNG32: "png32", JPEG: "jpg", JPG: "jpg", DIB: "dib", TIFF: "tiff", EMF: "emf", PS: "ps", PDF: "pdf", GIF: "gif", SVG: "svg", SVGZ: "svgz", Mixed: "mixed", MIXED: "mixed", LERC: "lerc", LERC2D: "lerc2d", RAW: "raw", pbf: "pbf" });
let an = Wl = class extends re {
  static create(e = {}) {
    const { resolutionFactor: t = 1, scales: r, size: n = 256, spatialReference: i = tt.WebMercator, numLODs: s = 24 } = e;
    if (!en(i)) {
      const f = [];
      if (r)
        for (let m = 0; m < r.length; m++) {
          const y = r[m];
          f.push(new du({ level: m, scale: y, resolution: y }));
        }
      else {
        let m = 5e-4;
        for (let y = s - 1; y >= 0; y--)
          f.unshift(new du({ level: y, scale: m, resolution: m })), m *= 2;
      }
      return new Wl({ dpi: 96, lods: f, origin: new Re(0, 0, i), size: [n, n], spatialReference: i });
    }
    const o = el(i), a = e.origin ? new Re({ x: e.origin.x, y: e.origin.y, spatialReference: i }) : new Re(o ? { x: o.origin[0], y: o.origin[1], spatialReference: i } : { x: 0, y: 0, spatialReference: i }), l = 96, c = 1 / (Yd(i) * 39.37 * l), h = [];
    if (r)
      for (let f = 0; f < r.length; f++) {
        const m = r[f], y = m * c;
        h.push(new du({ level: f, scale: m, resolution: y }));
      }
    else {
      let f = d6(i) ? 512 / n * 5916575275917094e-7 : 256 / n * 591657527591555e-6;
      const m = Math.ceil(s / t);
      h.push(new du({ level: 0, scale: f, resolution: f * c }));
      for (let y = 1; y < m; y++) {
        const g = f / 2 ** t, v = g * c;
        h.push(new du({ level: y, scale: g, resolution: v })), f = g;
      }
    }
    return new Wl({ dpi: l, lods: h, origin: a, size: [n, n], spatialReference: i });
  }
  constructor(e) {
    super(e), this.dpi = 96, this.format = null, this.origin = null, this.size = null, this.spatialReference = null;
  }
  get isWrappable() {
    const { spatialReference: e, origin: t } = this;
    if (e && t) {
      const r = el(e);
      return e.isWrappable && !!r && Math.abs(r.origin[0] - t.x) <= r.dx;
    }
    return !1;
  }
  readOrigin(e, t) {
    return Re.fromJSON({ spatialReference: t.spatialReference, ...e });
  }
  set lods(e) {
    let t = 0, r = 0;
    const n = [], i = this._levelToLOD = {};
    e && (t = -1 / 0, r = 1 / 0, e.forEach((s) => {
      n.push(s.scale), t = s.scale > t ? s.scale : t, r = s.scale < r ? s.scale : r, i[s.level] = s;
    })), this._set("scales", n), this._set("lods", e), this._initializeUpsampleLevels();
  }
  readSize(e, t) {
    return [t.cols, t.rows];
  }
  writeSize(e, t) {
    t.cols = e[0], t.rows = e[1];
  }
  zoomToScale(e) {
    const t = this.scales;
    if (e <= 0)
      return t[0];
    if (e >= t.length - 1)
      return t[t.length - 1];
    const r = Math.floor(e), n = r + 1;
    return t[r] / (t[r] / t[n]) ** (e - r);
  }
  scaleToZoom(e) {
    const t = this.scales, r = t.length - 1;
    let n = 0;
    for (; n < r; n++) {
      const i = t[n], s = t[n + 1];
      if (i <= e)
        return n;
      if (s === e)
        return n + 1;
      if (i > e && s < e)
        return n + Math.log(i / e) / Math.log(i / s);
    }
    return n;
  }
  snapScale(e, t = 0.95) {
    const r = this.scaleToZoom(e);
    return r % Math.floor(r) >= t ? this.zoomToScale(Math.ceil(r)) : this.zoomToScale(Math.floor(r));
  }
  tileAt(e, t, r, n) {
    const i = this.lodAt(e);
    if (!i)
      return null;
    let s, o;
    if (typeof t == "number")
      s = t, o = r;
    else if (tn(t.spatialReference, this.spatialReference))
      s = t.x, o = t.y, n = r;
    else {
      const c = o_(t, this.spatialReference);
      if (c == null)
        return null;
      s = c.x, o = c.y, n = r;
    }
    const a = i.resolution * this.size[0], l = i.resolution * this.size[1];
    return n || (n = new Qse(null, 0, 0, 0, sa())), n.level = e, n.row = Math.floor((this.origin.y - o) / l + 1e-3), n.col = Math.floor((s - this.origin.x) / a + 1e-3), this.updateTileInfo(n), n;
  }
  updateTileInfo(e, t = Wl.ExtrapolateOptions.NONE) {
    let r = this.lodAt(e.level);
    if (!r && t === Wl.ExtrapolateOptions.POWER_OF_TWO) {
      const o = this.lods[this.lods.length - 1];
      o.level < e.level && (r = o);
    }
    if (!r)
      return;
    const n = e.level - r.level, i = r.resolution * this.size[0] / 2 ** n, s = r.resolution * this.size[1] / 2 ** n;
    e.id = `${e.level}/${e.row}/${e.col}`, e.extent || (e.extent = sa()), e.extent[0] = this.origin.x + e.col * i, e.extent[1] = this.origin.y - (e.row + 1) * s, e.extent[2] = e.extent[0] + i, e.extent[3] = e.extent[1] + s;
  }
  upsampleTile(e) {
    const t = this._upsampleLevels[e.level];
    return !(!t || t.parentLevel === -1) && (e.level = t.parentLevel, e.row = Math.floor(e.row / t.factor + 1e-3), e.col = Math.floor(e.col / t.factor + 1e-3), this.updateTileInfo(e), !0);
  }
  getTileBounds(e, t) {
    const r = this.lodAt(t.level);
    if (r == null)
      return null;
    const { resolution: n } = r, i = n * this.size[0], s = n * this.size[1];
    return e[0] = this.origin.x + t.col * i, e[1] = this.origin.y - (t.row + 1) * s, e[2] = e[0] + i, e[3] = e[1] + s, e;
  }
  lodAt(e) {
    var t;
    return ((t = this._levelToLOD) == null ? void 0 : t[e]) ?? null;
  }
  clone() {
    return Wl.fromJSON(this.write({}));
  }
  getOrCreateCompatible(e, t) {
    if (this.size[0] === 256 && this.size[1] === 256)
      return e === 256 ? this : null;
    const r = [], n = this.lods.length;
    for (let i = 0; i < n; i++) {
      const s = this.lods[i], o = s.resolution * t;
      r.push(new du({ level: s.level, scale: s.scale, resolution: o }));
    }
    return new Wl({ size: [e, e], dpi: this.dpi, format: this.format, compressionQuality: this.compressionQuality, origin: this.origin, spatialReference: this.spatialReference, lods: r });
  }
  _initializeUpsampleLevels() {
    const e = this.lods;
    this._upsampleLevels = [];
    let t = null;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      this._upsampleLevels[n.level] = { parentLevel: t ? t.level : -1, factor: t ? t.resolution / n.resolution : 0 }, t = n;
    }
  }
};
u([d({ type: Number, json: { write: !0 } })], an.prototype, "compressionQuality", void 0), u([d({ type: Number, json: { write: !0 } })], an.prototype, "dpi", void 0), u([d({ type: String, json: { read: fP.read, write: fP.write, origins: { "web-scene": { read: !1, write: !1 } } } })], an.prototype, "format", void 0), u([d({ readOnly: !0 })], an.prototype, "isWrappable", null), u([d({ type: Re, json: { write: !0 } })], an.prototype, "origin", void 0), u([ce("origin")], an.prototype, "readOrigin", null), u([d({ type: [du], value: null, json: { write: !0 } })], an.prototype, "lods", null), u([d({ readOnly: !0 })], an.prototype, "scales", void 0), u([d({ cast: (e) => Array.isArray(e) ? e : typeof e == "number" ? [e, e] : [256, 256] })], an.prototype, "size", void 0), u([ce("size", ["rows", "cols"])], an.prototype, "readSize", null), u([ge("size", { cols: { type: Ot }, rows: { type: Ot } })], an.prototype, "writeSize", null), u([d({ type: tt, json: { write: !0 } })], an.prototype, "spatialReference", void 0), an = Wl = u([E("geoscene.layers.support.TileInfo")], an), function(e) {
  var t;
  (t = e.ExtrapolateOptions || (e.ExtrapolateOptions = {}))[t.NONE = 0] = "NONE", t[t.POWER_OF_TWO = 1] = "POWER_OF_TWO";
}(an || (an = {}));
const Xse = an, y1 = { widthBreakpoint: { getValue(e) {
  const t = e.viewSize[0], r = e.breakpoints, n = this.values;
  return t <= r.xsmall ? n.xsmall : t <= r.small ? n.small : t <= r.medium ? n.medium : t <= r.large ? n.large : n.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "geoscene-view-width-xsmall geoscene-view-width-less-than-small geoscene-view-width-less-than-medium geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", small: "geoscene-view-width-small geoscene-view-width-greater-than-xsmall geoscene-view-width-less-than-medium geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", medium: "geoscene-view-width-medium geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-less-than-large geoscene-view-width-less-than-xlarge", large: "geoscene-view-width-large geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-greater-than-medium geoscene-view-width-less-than-xlarge", xlarge: "geoscene-view-width-xlarge geoscene-view-width-greater-than-xsmall geoscene-view-width-greater-than-small geoscene-view-width-greater-than-medium geoscene-view-width-greater-than-large" } }, heightBreakpoint: { getValue(e) {
  const t = e.viewSize[1], r = e.breakpoints, n = this.values;
  return t <= r.xsmall ? n.xsmall : t <= r.small ? n.small : t <= r.medium ? n.medium : t <= r.large ? n.large : n.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "geoscene-view-height-xsmall geoscene-view-height-less-than-small geoscene-view-height-less-than-medium geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", small: "geoscene-view-height-small geoscene-view-height-greater-than-xsmall geoscene-view-height-less-than-medium geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", medium: "geoscene-view-height-medium geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-less-than-large geoscene-view-height-less-than-xlarge", large: "geoscene-view-height-large geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-greater-than-medium geoscene-view-height-less-than-xlarge", xlarge: "geoscene-view-height-xlarge geoscene-view-height-greater-than-xsmall geoscene-view-height-greater-than-small geoscene-view-height-greater-than-medium geoscene-view-height-greater-than-large" } }, orientation: { getValue(e) {
  const t = e.viewSize, r = t[0], n = t[1], i = this.values;
  return n >= r ? i.portrait : i.landscape;
}, values: { portrait: "portrait", landscape: "landscape" }, valueToClassName: { portrait: "geoscene-view-orientation-portrait", landscape: "geoscene-view-orientation-landscape" } } }, sS = { xsmall: 544, small: 768, medium: 992, large: 1200 };
function eoe(e) {
  const t = e;
  return t && t.xsmall < t.small && t.small < t.medium && t.medium < t.large;
}
function oS(e, t) {
  return t ? y1[e].valueToClassName[t].split(" ") : [];
}
const toe = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this._breakpointsHandles = new ca(), this.orientation = null, this.widthBreakpoint = null, this.heightBreakpoint = null, this.breakpoints = sS;
    }
    initialize() {
      this._breakpointsHandles.add(ze(() => [this.breakpoints, this.size], () => this._updateClassNames(), ln));
    }
    destroy() {
      this.destroyed || (this._removeActiveClassNames(), this._breakpointsHandles = Vt(this._breakpointsHandles));
    }
    set breakpoints(r) {
      if (r === this._get("breakpoints"))
        return;
      const n = eoe(r);
      if (!n) {
        const i = JSON.stringify(sS, null, 2);
        console.warn("provided breakpoints are not valid, using defaults:" + i);
      }
      r = n ? r : sS, this._set("breakpoints", { ...r });
    }
    _updateClassNames() {
      if (!this.container)
        return;
      const r = jn.acquire(), n = jn.acquire();
      let i, s = !1;
      for (i in y1) {
        const o = this[i], a = y1[i].getValue({ viewSize: this.size, breakpoints: this.breakpoints });
        o !== a && (s = !0, this[i] = a, oS(i, o).forEach((l) => n.push(l)), oS(i, a).forEach((l) => r.push(l)));
      }
      s && (this._applyClassNameChanges(r, n), jn.release(r), jn.release(n));
    }
    _applyClassNameChanges(r, n) {
      const i = this.container;
      i && (n.forEach((s) => i.classList.remove(s)), r.forEach((s) => i.classList.add(s)));
    }
    _removeActiveClassNames() {
      const r = this.container;
      if (!r)
        return;
      let n;
      for (n in y1)
        oS(n, this[n]).forEach((i) => r.classList.remove(i));
    }
  };
  return u([d()], t.prototype, "breakpoints", null), u([d()], t.prototype, "orientation", void 0), u([d()], t.prototype, "widthBreakpoint", void 0), u([d()], t.prototype, "heightBreakpoint", void 0), t = u([E("geoscene.views.BreakpointsOwner")], t), t;
};
function uO(e) {
  return typeof e == "string" ? document.getElementById(e) : e ?? null;
}
function c9(e) {
  for (; e.hasChildNodes(); )
    e.removeChild(e.firstChild);
}
function mP(e, t) {
  const r = t.parentNode;
  r && r.insertBefore(e, t);
}
function yP(e, t) {
  for (; ; ) {
    const r = e.firstChild;
    if (!r)
      break;
    t.appendChild(r);
  }
}
let _h = class extends Ae {
  constructor() {
    super(...arguments), this.updating = !1, this._handleId = 0, this._handles = new ca(), this._scheduleHandleId = 0, this._pendingPromises = /* @__PURE__ */ new Set();
  }
  destroy() {
    this.removeAll(), this._handles.destroy();
  }
  add(t, r, n = {}) {
    return this._installWatch(t, r, n, ze);
  }
  addWhen(t, r, n = {}) {
    return this._installWatch(t, r, n, Au);
  }
  addOnCollectionChange(t, r, { initial: n = !1, final: i = !1 } = {}) {
    const s = ++this._handleId;
    return this._handles.add([rg(t, "after-changes", this._createSyncUpdatingCallback(), Wg), rg(t, "change", r, { onListenerAdd: n ? (o) => r({ added: o.toArray(), removed: [] }) : void 0, onListenerRemove: i ? (o) => r({ added: [], removed: o.toArray() }) : void 0 })], s), nl(() => this._handles.remove(s));
  }
  addPromise(t) {
    if (t == null)
      return t;
    const r = ++this._handleId;
    this._handles.add({ remove: () => {
      this._pendingPromises.delete(t) && (this._pendingPromises.size !== 0 || this._handles.has(G0) || this._set("updating", !1));
    } }, r), this._pendingPromises.add(t), this._set("updating", !0);
    const n = () => this._handles.remove(r);
    return t.then(n, n), t;
  }
  removeAll() {
    this._pendingPromises.clear(), this._handles.removeAll(), this._set("updating", !1);
  }
  _installWatch(t, r, n = {}, i) {
    const s = ++this._handleId;
    n.sync || this._installSyncUpdatingWatch(t, s);
    const o = i(t, r, n);
    return this._handles.add(o, s), nl(() => this._handles.remove(s));
  }
  _installSyncUpdatingWatch(t, r) {
    const n = this._createSyncUpdatingCallback(), i = ze(t, n, { sync: !0, equals: () => !1 });
    return this._handles.add(i, r), i;
  }
  _createSyncUpdatingCallback() {
    return () => {
      this._handles.remove(G0), ++this._scheduleHandleId;
      const t = this._scheduleHandleId;
      this._get("updating") || this._set("updating", !0), this._handles.add(nf(() => {
        t === this._scheduleHandleId && (this._set("updating", this._pendingPromises.size > 0), this._handles.remove(G0));
      }), G0);
    };
  }
};
u([d({ readOnly: !0 })], _h.prototype, "updating", void 0), _h = u([E("geoscene.core.support.WatchUpdatingTracking")], _h);
const G0 = -42;
/*!
 * @esri/arcgis-html-sanitizer - v3.0.1 - Tue Nov 15 2022 09:46:54 GMT-0800 (Pacific Standard Time)
 * Copyright (c) 2022 - Environmental Systems Research Institute, Inc.
 * Apache-2.0
 * 
 * js-xss
 * Copyright (c) 2012-2018 Zongmin Lei(雷宗民) <leizongmin@gmail.com>
 * http://ucdok.com
 * MIT License, see https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 */
var roe = function(e) {
  if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  var t = Object.getPrototypeOf(e);
  if (t === null)
    return !0;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}, Kc = { exports: {} }, ur = {}, ag = { exports: {} }, np = {};
function d9() {
  var e = {};
  return e["align-content"] = !1, e["align-items"] = !1, e["align-self"] = !1, e["alignment-adjust"] = !1, e["alignment-baseline"] = !1, e.all = !1, e["anchor-point"] = !1, e.animation = !1, e["animation-delay"] = !1, e["animation-direction"] = !1, e["animation-duration"] = !1, e["animation-fill-mode"] = !1, e["animation-iteration-count"] = !1, e["animation-name"] = !1, e["animation-play-state"] = !1, e["animation-timing-function"] = !1, e.azimuth = !1, e["backface-visibility"] = !1, e.background = !0, e["background-attachment"] = !0, e["background-clip"] = !0, e["background-color"] = !0, e["background-image"] = !0, e["background-origin"] = !0, e["background-position"] = !0, e["background-repeat"] = !0, e["background-size"] = !0, e["baseline-shift"] = !1, e.binding = !1, e.bleed = !1, e["bookmark-label"] = !1, e["bookmark-level"] = !1, e["bookmark-state"] = !1, e.border = !0, e["border-bottom"] = !0, e["border-bottom-color"] = !0, e["border-bottom-left-radius"] = !0, e["border-bottom-right-radius"] = !0, e["border-bottom-style"] = !0, e["border-bottom-width"] = !0, e["border-collapse"] = !0, e["border-color"] = !0, e["border-image"] = !0, e["border-image-outset"] = !0, e["border-image-repeat"] = !0, e["border-image-slice"] = !0, e["border-image-source"] = !0, e["border-image-width"] = !0, e["border-left"] = !0, e["border-left-color"] = !0, e["border-left-style"] = !0, e["border-left-width"] = !0, e["border-radius"] = !0, e["border-right"] = !0, e["border-right-color"] = !0, e["border-right-style"] = !0, e["border-right-width"] = !0, e["border-spacing"] = !0, e["border-style"] = !0, e["border-top"] = !0, e["border-top-color"] = !0, e["border-top-left-radius"] = !0, e["border-top-right-radius"] = !0, e["border-top-style"] = !0, e["border-top-width"] = !0, e["border-width"] = !0, e.bottom = !1, e["box-decoration-break"] = !0, e["box-shadow"] = !0, e["box-sizing"] = !0, e["box-snap"] = !0, e["box-suppress"] = !0, e["break-after"] = !0, e["break-before"] = !0, e["break-inside"] = !0, e["caption-side"] = !1, e.chains = !1, e.clear = !0, e.clip = !1, e["clip-path"] = !1, e["clip-rule"] = !1, e.color = !0, e["color-interpolation-filters"] = !0, e["column-count"] = !1, e["column-fill"] = !1, e["column-gap"] = !1, e["column-rule"] = !1, e["column-rule-color"] = !1, e["column-rule-style"] = !1, e["column-rule-width"] = !1, e["column-span"] = !1, e["column-width"] = !1, e.columns = !1, e.contain = !1, e.content = !1, e["counter-increment"] = !1, e["counter-reset"] = !1, e["counter-set"] = !1, e.crop = !1, e.cue = !1, e["cue-after"] = !1, e["cue-before"] = !1, e.cursor = !1, e.direction = !1, e.display = !0, e["display-inside"] = !0, e["display-list"] = !0, e["display-outside"] = !0, e["dominant-baseline"] = !1, e.elevation = !1, e["empty-cells"] = !1, e.filter = !1, e.flex = !1, e["flex-basis"] = !1, e["flex-direction"] = !1, e["flex-flow"] = !1, e["flex-grow"] = !1, e["flex-shrink"] = !1, e["flex-wrap"] = !1, e.float = !1, e["float-offset"] = !1, e["flood-color"] = !1, e["flood-opacity"] = !1, e["flow-from"] = !1, e["flow-into"] = !1, e.font = !0, e["font-family"] = !0, e["font-feature-settings"] = !0, e["font-kerning"] = !0, e["font-language-override"] = !0, e["font-size"] = !0, e["font-size-adjust"] = !0, e["font-stretch"] = !0, e["font-style"] = !0, e["font-synthesis"] = !0, e["font-variant"] = !0, e["font-variant-alternates"] = !0, e["font-variant-caps"] = !0, e["font-variant-east-asian"] = !0, e["font-variant-ligatures"] = !0, e["font-variant-numeric"] = !0, e["font-variant-position"] = !0, e["font-weight"] = !0, e.grid = !1, e["grid-area"] = !1, e["grid-auto-columns"] = !1, e["grid-auto-flow"] = !1, e["grid-auto-rows"] = !1, e["grid-column"] = !1, e["grid-column-end"] = !1, e["grid-column-start"] = !1, e["grid-row"] = !1, e["grid-row-end"] = !1, e["grid-row-start"] = !1, e["grid-template"] = !1, e["grid-template-areas"] = !1, e["grid-template-columns"] = !1, e["grid-template-rows"] = !1, e["hanging-punctuation"] = !1, e.height = !0, e.hyphens = !1, e.icon = !1, e["image-orientation"] = !1, e["image-resolution"] = !1, e["ime-mode"] = !1, e["initial-letters"] = !1, e["inline-box-align"] = !1, e["justify-content"] = !1, e["justify-items"] = !1, e["justify-self"] = !1, e.left = !1, e["letter-spacing"] = !0, e["lighting-color"] = !0, e["line-box-contain"] = !1, e["line-break"] = !1, e["line-grid"] = !1, e["line-height"] = !1, e["line-snap"] = !1, e["line-stacking"] = !1, e["line-stacking-ruby"] = !1, e["line-stacking-shift"] = !1, e["line-stacking-strategy"] = !1, e["list-style"] = !0, e["list-style-image"] = !0, e["list-style-position"] = !0, e["list-style-type"] = !0, e.margin = !0, e["margin-bottom"] = !0, e["margin-left"] = !0, e["margin-right"] = !0, e["margin-top"] = !0, e["marker-offset"] = !1, e["marker-side"] = !1, e.marks = !1, e.mask = !1, e["mask-box"] = !1, e["mask-box-outset"] = !1, e["mask-box-repeat"] = !1, e["mask-box-slice"] = !1, e["mask-box-source"] = !1, e["mask-box-width"] = !1, e["mask-clip"] = !1, e["mask-image"] = !1, e["mask-origin"] = !1, e["mask-position"] = !1, e["mask-repeat"] = !1, e["mask-size"] = !1, e["mask-source-type"] = !1, e["mask-type"] = !1, e["max-height"] = !0, e["max-lines"] = !1, e["max-width"] = !0, e["min-height"] = !0, e["min-width"] = !0, e["move-to"] = !1, e["nav-down"] = !1, e["nav-index"] = !1, e["nav-left"] = !1, e["nav-right"] = !1, e["nav-up"] = !1, e["object-fit"] = !1, e["object-position"] = !1, e.opacity = !1, e.order = !1, e.orphans = !1, e.outline = !1, e["outline-color"] = !1, e["outline-offset"] = !1, e["outline-style"] = !1, e["outline-width"] = !1, e.overflow = !1, e["overflow-wrap"] = !1, e["overflow-x"] = !1, e["overflow-y"] = !1, e.padding = !0, e["padding-bottom"] = !0, e["padding-left"] = !0, e["padding-right"] = !0, e["padding-top"] = !0, e.page = !1, e["page-break-after"] = !1, e["page-break-before"] = !1, e["page-break-inside"] = !1, e["page-policy"] = !1, e.pause = !1, e["pause-after"] = !1, e["pause-before"] = !1, e.perspective = !1, e["perspective-origin"] = !1, e.pitch = !1, e["pitch-range"] = !1, e["play-during"] = !1, e.position = !1, e["presentation-level"] = !1, e.quotes = !1, e["region-fragment"] = !1, e.resize = !1, e.rest = !1, e["rest-after"] = !1, e["rest-before"] = !1, e.richness = !1, e.right = !1, e.rotation = !1, e["rotation-point"] = !1, e["ruby-align"] = !1, e["ruby-merge"] = !1, e["ruby-position"] = !1, e["shape-image-threshold"] = !1, e["shape-outside"] = !1, e["shape-margin"] = !1, e.size = !1, e.speak = !1, e["speak-as"] = !1, e["speak-header"] = !1, e["speak-numeral"] = !1, e["speak-punctuation"] = !1, e["speech-rate"] = !1, e.stress = !1, e["string-set"] = !1, e["tab-size"] = !1, e["table-layout"] = !1, e["text-align"] = !0, e["text-align-last"] = !0, e["text-combine-upright"] = !0, e["text-decoration"] = !0, e["text-decoration-color"] = !0, e["text-decoration-line"] = !0, e["text-decoration-skip"] = !0, e["text-decoration-style"] = !0, e["text-emphasis"] = !0, e["text-emphasis-color"] = !0, e["text-emphasis-position"] = !0, e["text-emphasis-style"] = !0, e["text-height"] = !0, e["text-indent"] = !0, e["text-justify"] = !0, e["text-orientation"] = !0, e["text-overflow"] = !0, e["text-shadow"] = !0, e["text-space-collapse"] = !0, e["text-transform"] = !0, e["text-underline-position"] = !0, e["text-wrap"] = !0, e.top = !1, e.transform = !1, e["transform-origin"] = !1, e["transform-style"] = !1, e.transition = !1, e["transition-delay"] = !1, e["transition-duration"] = !1, e["transition-property"] = !1, e["transition-timing-function"] = !1, e["unicode-bidi"] = !1, e["vertical-align"] = !1, e.visibility = !1, e["voice-balance"] = !1, e["voice-duration"] = !1, e["voice-family"] = !1, e["voice-pitch"] = !1, e["voice-range"] = !1, e["voice-rate"] = !1, e["voice-stress"] = !1, e["voice-volume"] = !1, e.volume = !1, e["white-space"] = !1, e.widows = !1, e.width = !0, e["will-change"] = !1, e["word-break"] = !0, e["word-spacing"] = !0, e["word-wrap"] = !0, e["wrap-flow"] = !1, e["wrap-through"] = !1, e["writing-mode"] = !1, e["z-index"] = !1, e;
}
function noe(e, t, r) {
}
function ioe(e, t, r) {
}
var soe = /javascript\s*\:/img;
function ooe(e, t) {
  return soe.test(t) ? "" : t;
}
np.whiteList = d9();
np.getDefaultWhiteList = d9;
np.onAttr = noe;
np.onIgnoreAttr = ioe;
np.safeAttrValue = ooe;
var aoe = {
  indexOf: function(e, t) {
    var r, n;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (r = 0, n = e.length; r < n; r++)
      if (e[r] === t)
        return r;
    return -1;
  },
  forEach: function(e, t, r) {
    var n, i;
    if (Array.prototype.forEach)
      return e.forEach(t, r);
    for (n = 0, i = e.length; n < i; n++)
      t.call(r, e[n], n, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(e) {
    return String.prototype.trimRight ? e.trimRight() : e.replace(/(\s*$)/g, "");
  }
}, Jf = aoe;
function loe(e, t) {
  e = Jf.trimRight(e), e[e.length - 1] !== ";" && (e += ";");
  var r = e.length, n = !1, i = 0, s = 0, o = "";
  function a() {
    if (!n) {
      var h = Jf.trim(e.slice(i, s)), f = h.indexOf(":");
      if (f !== -1) {
        var m = Jf.trim(h.slice(0, f)), y = Jf.trim(h.slice(f + 1));
        if (m) {
          var g = t(i, o.length, m, y, h);
          g && (o += g + "; ");
        }
      }
    }
    i = s + 1;
  }
  for (; s < r; s++) {
    var l = e[s];
    if (l === "/" && e[s + 1] === "*") {
      var c = e.indexOf("*/", s + 2);
      if (c === -1)
        break;
      s = c + 1, i = s + 1, n = !1;
    } else
      l === "(" ? n = !0 : l === ")" ? n = !1 : l === ";" ? n || a() : l === `
` && a();
  }
  return Jf.trim(o);
}
var uoe = loe, H0 = np, coe = uoe;
function gP(e) {
  return e == null;
}
function doe(e) {
  var t = {};
  for (var r in e)
    t[r] = e[r];
  return t;
}
function p9(e) {
  e = doe(e || {}), e.whiteList = e.whiteList || H0.whiteList, e.onAttr = e.onAttr || H0.onAttr, e.onIgnoreAttr = e.onIgnoreAttr || H0.onIgnoreAttr, e.safeAttrValue = e.safeAttrValue || H0.safeAttrValue, this.options = e;
}
p9.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, r = t.options, n = r.whiteList, i = r.onAttr, s = r.onIgnoreAttr, o = r.safeAttrValue, a = coe(e, function(l, c, h, f, m) {
    var y = n[h], g = !1;
    if (y === !0 ? g = y : typeof y == "function" ? g = y(f) : y instanceof RegExp && (g = y.test(f)), g !== !0 && (g = !1), f = o(h, f), !!f) {
      var v = {
        position: c,
        sourcePosition: l,
        source: m,
        isWhite: g
      };
      if (g) {
        var b = i(h, f, v);
        return gP(b) ? h + ":" + f : b;
      } else {
        var b = s(h, f, v);
        if (!gP(b))
          return b;
      }
    }
  });
  return a;
};
var poe = p9;
(function(e, t) {
  var r = np, n = poe;
  function i(o, a) {
    var l = new n(a);
    return l.process(o);
  }
  t = e.exports = i, t.FilterCSS = n;
  for (var s in r)
    t[s] = r[s];
})(ag, ag.exports);
var cO = {
  indexOf: function(e, t) {
    var r, n;
    if (Array.prototype.indexOf)
      return e.indexOf(t);
    for (r = 0, n = e.length; r < n; r++)
      if (e[r] === t)
        return r;
    return -1;
  },
  forEach: function(e, t, r) {
    var n, i;
    if (Array.prototype.forEach)
      return e.forEach(t, r);
    for (n = 0, i = e.length; n < i; n++)
      t.call(r, e[n], n, e);
  },
  trim: function(e) {
    return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(e) {
    var t = /\s|\n|\t/, r = t.exec(e);
    return r ? r.index : -1;
  }
}, hoe = ag.exports.FilterCSS, foe = ag.exports.getDefaultWhiteList, Kb = cO;
function h9() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var f9 = new hoe();
function moe(e, t, r) {
}
function yoe(e, t, r) {
}
function goe(e, t, r) {
}
function voe(e, t, r) {
}
function m9(e) {
  return e.replace(woe, "&lt;").replace(_oe, "&gt;");
}
function boe(e, t, r, n) {
  if (r = _9(r), t === "href" || t === "src") {
    if (r = Kb.trim(r), r === "#")
      return "#";
    if (!(r.substr(0, 7) === "http://" || r.substr(0, 8) === "https://" || r.substr(0, 7) === "mailto:" || r.substr(0, 4) === "tel:" || r.substr(0, 11) === "data:image/" || r.substr(0, 6) === "ftp://" || r.substr(0, 2) === "./" || r.substr(0, 3) === "../" || r[0] === "#" || r[0] === "/"))
      return "";
  } else if (t === "background") {
    if (W0.lastIndex = 0, W0.test(r))
      return "";
  } else if (t === "style") {
    if (vP.lastIndex = 0, vP.test(r) || (bP.lastIndex = 0, bP.test(r) && (W0.lastIndex = 0, W0.test(r))))
      return "";
    n !== !1 && (n = n || f9, r = n.process(r));
  }
  return r = S9(r), r;
}
var woe = /</g, _oe = />/g, Soe = /"/g, $oe = /&quot;/g, xoe = /&#([a-zA-Z0-9]*);?/gim, Toe = /&colon;?/gim, Eoe = /&newline;?/gim, W0 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, vP = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, bP = /u\s*r\s*l\s*\(.*/gi;
function y9(e) {
  return e.replace(Soe, "&quot;");
}
function g9(e) {
  return e.replace($oe, '"');
}
function v9(e) {
  return e.replace(xoe, function(r, n) {
    return n[0] === "x" || n[0] === "X" ? String.fromCharCode(parseInt(n.substr(1), 16)) : String.fromCharCode(parseInt(n, 10));
  });
}
function b9(e) {
  return e.replace(Toe, ":").replace(Eoe, " ");
}
function w9(e) {
  for (var t = "", r = 0, n = e.length; r < n; r++)
    t += e.charCodeAt(r) < 32 ? " " : e.charAt(r);
  return Kb.trim(t);
}
function _9(e) {
  return e = g9(e), e = v9(e), e = b9(e), e = w9(e), e;
}
function S9(e) {
  return e = y9(e), e = m9(e), e;
}
function Ioe() {
  return "";
}
function Moe(e, t) {
  typeof t != "function" && (t = function() {
  });
  var r = !Array.isArray(e);
  function n(o) {
    return r ? !0 : Kb.indexOf(e, o) !== -1;
  }
  var i = [], s = !1;
  return {
    onIgnoreTag: function(o, a, l) {
      if (n(o))
        if (l.isClosing) {
          var c = "[/removed]", h = l.position + c.length;
          return i.push([
            s !== !1 ? s : l.position,
            h
          ]), s = !1, c;
        } else
          return s || (s = l.position), "[removed]";
      else
        return t(o, a, l);
    },
    remove: function(o) {
      var a = "", l = 0;
      return Kb.forEach(i, function(c) {
        a += o.slice(l, c[0]), l = c[1];
      }), a += o.slice(l), a;
    }
  };
}
function Ooe(e) {
  for (var t = "", r = 0; r < e.length; ) {
    var n = e.indexOf("<!--", r);
    if (n === -1) {
      t += e.slice(r);
      break;
    }
    t += e.slice(r, n);
    var i = e.indexOf("-->", n);
    if (i === -1)
      break;
    r = i + 3;
  }
  return t;
}
function Coe(e) {
  var t = e.split("");
  return t = t.filter(function(r) {
    var n = r.charCodeAt(0);
    return n === 127 ? !1 : n <= 31 ? n === 10 || n === 13 : !0;
  }), t.join("");
}
ur.whiteList = h9();
ur.getDefaultWhiteList = h9;
ur.onTag = moe;
ur.onIgnoreTag = yoe;
ur.onTagAttr = goe;
ur.onIgnoreTagAttr = voe;
ur.safeAttrValue = boe;
ur.escapeHtml = m9;
ur.escapeQuote = y9;
ur.unescapeQuote = g9;
ur.escapeHtmlEntities = v9;
ur.escapeDangerHtml5Entities = b9;
ur.clearNonPrintableCharacter = w9;
ur.friendlyAttrValue = _9;
ur.escapeAttrValue = S9;
ur.onIgnoreTagStripAll = Ioe;
ur.StripTagBody = Moe;
ur.stripCommentTag = Ooe;
ur.stripBlankChar = Coe;
ur.cssFilter = f9;
ur.getDefaultCSSWhiteList = foe;
var x_ = {}, pu = cO;
function koe(e) {
  var t = pu.spaceIndex(e), r;
  return t === -1 ? r = e.slice(1, -1) : r = e.slice(1, t + 1), r = pu.trim(r).toLowerCase(), r.slice(0, 1) === "/" && (r = r.slice(1)), r.slice(-1) === "/" && (r = r.slice(0, -1)), r;
}
function Aoe(e) {
  return e.slice(0, 2) === "</";
}
function Poe(e, t, r) {
  var n = "", i = 0, s = !1, o = !1, a = 0, l = e.length, c = "", h = "";
  e:
    for (a = 0; a < l; a++) {
      var f = e.charAt(a);
      if (s === !1) {
        if (f === "<") {
          s = a;
          continue;
        }
      } else if (o === !1) {
        if (f === "<") {
          n += r(e.slice(i, a)), s = a, i = a;
          continue;
        }
        if (f === ">") {
          n += r(e.slice(i, s)), h = e.slice(s, a + 1), c = koe(h), n += t(
            s,
            n.length,
            c,
            h,
            Aoe(h)
          ), i = a + 1, s = !1;
          continue;
        }
        if (f === '"' || f === "'")
          for (var m = 1, y = e.charAt(a - m); y.trim() === "" || y === "="; ) {
            if (y === "=") {
              o = f;
              continue e;
            }
            y = e.charAt(a - ++m);
          }
      } else if (f === o) {
        o = !1;
        continue;
      }
    }
  return i < e.length && (n += r(e.substr(i))), n;
}
var Roe = /[^a-zA-Z0-9\\_:.-]/gim;
function Loe(e, t) {
  var r = 0, n = 0, i = [], s = !1, o = e.length;
  function a(m, y) {
    if (m = pu.trim(m), m = m.replace(Roe, "").toLowerCase(), !(m.length < 1)) {
      var g = t(m, y || "");
      g && i.push(g);
    }
  }
  for (var l = 0; l < o; l++) {
    var c = e.charAt(l), h, f;
    if (s === !1 && c === "=") {
      s = e.slice(r, l), r = l + 1, n = e.charAt(r) === '"' || e.charAt(r) === "'" ? r : Foe(e, l + 1);
      continue;
    }
    if (s !== !1 && l === n) {
      if (f = e.indexOf(c, l + 1), f === -1)
        break;
      h = pu.trim(e.slice(n + 1, f)), a(s, h), s = !1, l = f, r = l + 1;
      continue;
    }
    if (/\s|\n|\t/.test(c))
      if (e = e.replace(/\s|\n|\t/g, " "), s === !1)
        if (f = Noe(e, l), f === -1) {
          h = pu.trim(e.slice(r, l)), a(h), s = !1, r = l + 1;
          continue;
        } else {
          l = f - 1;
          continue;
        }
      else if (f = Doe(e, l - 1), f === -1) {
        h = pu.trim(e.slice(r, l)), h = wP(h), a(s, h), s = !1, r = l + 1;
        continue;
      } else
        continue;
  }
  return r < e.length && (s === !1 ? a(e.slice(r)) : a(s, wP(pu.trim(e.slice(r))))), pu.trim(i.join(" "));
}
function Noe(e, t) {
  for (; t < e.length; t++) {
    var r = e[t];
    if (r !== " ")
      return r === "=" ? t : -1;
  }
}
function Foe(e, t) {
  for (; t < e.length; t++) {
    var r = e[t];
    if (r !== " ")
      return r === "'" || r === '"' ? t : -1;
  }
}
function Doe(e, t) {
  for (; t > 0; t--) {
    var r = e[t];
    if (r !== " ")
      return r === "=" ? t : -1;
  }
}
function joe(e) {
  return e[0] === '"' && e[e.length - 1] === '"' || e[0] === "'" && e[e.length - 1] === "'";
}
function wP(e) {
  return joe(e) ? e.substr(1, e.length - 2) : e;
}
x_.parseTag = Poe;
x_.parseAttr = Loe;
var Voe = ag.exports.FilterCSS, Xs = ur, $9 = x_, zoe = $9.parseTag, Uoe = $9.parseAttr, g1 = cO;
function J0(e) {
  return e == null;
}
function Boe(e) {
  var t = g1.spaceIndex(e);
  if (t === -1)
    return {
      html: "",
      closing: e[e.length - 2] === "/"
    };
  e = g1.trim(e.slice(t + 1, -1));
  var r = e[e.length - 1] === "/";
  return r && (e = g1.trim(e.slice(0, -1))), {
    html: e,
    closing: r
  };
}
function qoe(e) {
  var t = {};
  for (var r in e)
    t[r] = e[r];
  return t;
}
function Goe(e) {
  var t = {};
  for (var r in e)
    Array.isArray(e[r]) ? t[r.toLowerCase()] = e[r].map(function(n) {
      return n.toLowerCase();
    }) : t[r.toLowerCase()] = e[r];
  return t;
}
function x9(e) {
  e = qoe(e || {}), e.stripIgnoreTag && (e.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), e.onIgnoreTag = Xs.onIgnoreTagStripAll), e.whiteList || e.allowList ? e.whiteList = Goe(e.whiteList || e.allowList) : e.whiteList = Xs.whiteList, e.onTag = e.onTag || Xs.onTag, e.onTagAttr = e.onTagAttr || Xs.onTagAttr, e.onIgnoreTag = e.onIgnoreTag || Xs.onIgnoreTag, e.onIgnoreTagAttr = e.onIgnoreTagAttr || Xs.onIgnoreTagAttr, e.safeAttrValue = e.safeAttrValue || Xs.safeAttrValue, e.escapeHtml = e.escapeHtml || Xs.escapeHtml, this.options = e, e.css === !1 ? this.cssFilter = !1 : (e.css = e.css || {}, this.cssFilter = new Voe(e.css));
}
x9.prototype.process = function(e) {
  if (e = e || "", e = e.toString(), !e)
    return "";
  var t = this, r = t.options, n = r.whiteList, i = r.onTag, s = r.onIgnoreTag, o = r.onTagAttr, a = r.onIgnoreTagAttr, l = r.safeAttrValue, c = r.escapeHtml, h = t.cssFilter;
  r.stripBlankChar && (e = Xs.stripBlankChar(e)), r.allowCommentTag || (e = Xs.stripCommentTag(e));
  var f = !1;
  r.stripIgnoreTagBody && (f = Xs.StripTagBody(
    r.stripIgnoreTagBody,
    s
  ), s = f.onIgnoreTag);
  var m = zoe(
    e,
    function(y, g, v, b, w) {
      var x = {
        sourcePosition: y,
        position: g,
        isClosing: w,
        isWhite: Object.prototype.hasOwnProperty.call(n, v)
      }, $ = i(v, b, x);
      if (!J0($))
        return $;
      if (x.isWhite) {
        if (x.isClosing)
          return "</" + v + ">";
        var T = Boe(b), C = n[v], I = Uoe(T.html, function(O, M) {
          var L = g1.indexOf(C, O) !== -1, N = o(v, O, M, L);
          return J0(N) ? L ? (M = l(v, O, M, h), M ? O + '="' + M + '"' : O) : (N = a(v, O, M, L), J0(N) ? void 0 : N) : N;
        });
        return b = "<" + v, I && (b += " " + I), T.closing && (b += " /"), b += ">", b;
      } else
        return $ = s(v, b, x), J0($) ? c(b) : $;
    },
    c
  );
  return f && (m = f.remove(m)), m;
};
var Hoe = x9;
(function(e, t) {
  var r = ur, n = x_, i = Hoe;
  function s(a, l) {
    var c = new i(l);
    return c.process(a);
  }
  t = e.exports = s, t.filterXSS = s, t.FilterXSS = i, function() {
    for (var a in r)
      t[a] = r[a];
    for (var l in n)
      t[l] = n[l];
  }();
  function o() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  o() && (self.filterXSS = e.exports);
})(Kc, Kc.exports);
var Woe = (
  /** @class */
  function() {
    function e(t, r) {
      var n = this;
      this.arcgisWhiteList = {
        a: ["href", "style", "target"],
        abbr: ["title"],
        audio: ["autoplay", "controls", "loop", "muted", "preload"],
        b: [],
        br: [],
        dd: ["style"],
        div: ["align", "style"],
        dl: ["style"],
        dt: ["style"],
        em: [],
        figcaption: ["style"],
        figure: ["style"],
        font: ["color", "face", "size", "style"],
        h1: ["style"],
        h2: ["style"],
        h3: ["style"],
        h4: ["style"],
        h5: ["style"],
        h6: ["style"],
        hr: [],
        i: [],
        img: ["alt", "border", "height", "src", "style", "width"],
        li: [],
        ol: [],
        p: ["style"],
        source: ["media", "src", "type"],
        span: ["style"],
        strong: [],
        sub: ["style"],
        sup: ["style"],
        table: ["border", "cellpadding", "cellspacing", "height", "style", "width"],
        tbody: [],
        tr: ["align", "height", "style", "valign"],
        td: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        th: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "height",
          "loop",
          "muted",
          "poster",
          "preload",
          "width"
        ]
      }, this.allowedProtocols = [
        "http",
        "https",
        "mailto",
        "iform",
        "tel",
        "flow",
        "lfmobile",
        "arcgis-navigator",
        "arcgis-appstudio-player",
        "arcgis-survey123",
        "arcgis-collector",
        "arcgis-workforce",
        "arcgis-explorer",
        "arcgis-trek2there",
        "arcgis-quickcapture",
        "mspbi",
        "comgooglemaps",
        "pdfefile",
        "pdfehttp",
        "pdfehttps",
        "boxapp",
        "boxemm",
        "awb",
        "awbs",
        "gropen",
        "radarscope"
      ], this.arcgisFilterOptions = {
        allowCommentTag: !0,
        safeAttrValue: function(s, o, a, l) {
          return s === "a" && o === "href" || (s === "img" || s === "source") && o === "src" ? n.sanitizeUrl(a) : Kc.exports.safeAttrValue(s, o, a, l);
        }
      }, this._entityMap = {
        "&": "&#x38;",
        "<": "&#x3C;",
        ">": "&#x3E;",
        '"': "&#x22;",
        "'": "&#x27;",
        "/": "&#x2F;"
      };
      var i;
      t && !r ? i = t : t && r ? (i = Object.create(this.arcgisFilterOptions), Object.keys(t).forEach(function(s) {
        s === "whiteList" ? i.whiteList = n._extendObjectOfArrays([
          n.arcgisWhiteList,
          t.whiteList || {}
        ]) : i[s] = t[s];
      })) : (i = Object.create(this.arcgisFilterOptions), i.whiteList = this.arcgisWhiteList), this.xssFilterOptions = i, this._xssFilter = new Kc.exports.FilterXSS(i);
    }
    return e.prototype.sanitize = function(t, r) {
      switch (r === void 0 && (r = {}), typeof t) {
        case "number":
          return isNaN(t) || !isFinite(t) ? null : t;
        case "boolean":
          return t;
        case "string":
          return this._xssFilter.process(t);
        case "object":
          return this._iterateOverObject(t, r);
        default:
          return r.allowUndefined && typeof t > "u" ? void 0 : null;
      }
    }, e.prototype.sanitizeUrl = function(t, r) {
      var n = (r ?? {}).isProtocolRequired, i = n === void 0 ? !0 : n, s = this._trim(t.substring(0, t.indexOf(":"))), o = t === "/", a = /^#/.test(t), l = s && this.allowedProtocols.indexOf(s.toLowerCase()) > -1;
      return o || a || l ? Kc.exports.escapeAttrValue(t) : !s && !i ? Kc.exports.escapeAttrValue("https://".concat(t)) : "";
    }, e.prototype.sanitizeHTMLAttribute = function(t, r, n, i) {
      return typeof this.xssFilterOptions.safeAttrValue == "function" ? this.xssFilterOptions.safeAttrValue(
        t,
        r,
        n,
        // @ts-expect-error safeAttrValue does handle undefined cssFilter
        i
      ) : Kc.exports.safeAttrValue(t, r, n, i);
    }, e.prototype.validate = function(t, r) {
      r === void 0 && (r = {});
      var n = this.sanitize(t, r);
      return {
        isValid: t === n,
        sanitized: n
      };
    }, e.prototype.encodeHTML = function(t) {
      var r = this;
      return String(t).replace(/[&<>"'\/]/g, function(n) {
        return r._entityMap[n];
      });
    }, e.prototype.encodeAttrValue = function(t) {
      var r = /^[a-zA-Z0-9]$/;
      return String(t).replace(/[\x00-\xFF]/g, function(n, i) {
        return r.test(n) ? n : "&#x".concat(Number(t.charCodeAt(i)).toString(16), ";");
      });
    }, e.prototype._extendObjectOfArrays = function(t) {
      var r = {};
      return t.forEach(function(n) {
        Object.keys(n).forEach(function(i) {
          Array.isArray(n[i]) && Array.isArray(r[i]) ? r[i] = r[i].concat(n[i]) : r[i] = n[i];
        });
      }), r;
    }, e.prototype._iterateOverObject = function(t, r) {
      var n = this;
      r === void 0 && (r = {});
      try {
        var i = !1, s = void 0;
        if (Array.isArray(t))
          s = t.reduce(function(a, l) {
            var c = n.validate(l, r);
            return c.isValid ? a.concat([l]) : (i = !0, a.concat([c.sanitized]));
          }, []);
        else if (roe(t)) {
          var o = Object.keys(t);
          s = o.reduce(function(a, l) {
            var c = t[l], h = n.validate(c, r);
            return h.isValid ? a[l] = c : (i = !0, a[l] = h.sanitized), a;
          }, {});
        } else
          return r.allowUndefined && typeof t > "u" ? void 0 : null;
        return i ? s : t;
      } catch {
        return null;
      }
    }, e.prototype._trim = function(t) {
      return String.prototype.trim ? t.trim() : t.replace(/(^\s*)|(\s*$)/g, "");
    }, e;
  }()
);
const T_ = /* @__PURE__ */ new Map();
function T9() {
  T_.clear();
}
function Joe(e) {
  return T_.get(e);
}
function Zoe(e, t) {
  T_.set(e, t);
}
function aS(e) {
  T_.delete(e);
}
var Fd, zh, Koe = function(e) {
  if ("WebkitTransition" in e.style)
    Fd = "webkitTransitionEnd", zh = "webkitAnimationEnd";
  else {
    if (!("transition" in e.style))
      throw new Error("Your browser is not supported!");
    Fd = "transitionend", zh = "animationend";
  }
}, E9 = function(e) {
  Fd || Koe(e);
}, Yoe = function(e, t) {
  return t === void 0 && (t = e + "-active"), function(r) {
    E9(r);
    var n = !1, i = function(s) {
      n || (n = !0, r.removeEventListener(Fd, i), r.removeEventListener(zh, i), r.classList.remove(e), r.classList.remove(t));
    };
    r.classList.add(e), r.addEventListener(Fd, i), r.addEventListener(zh, i), requestAnimationFrame(function() {
      r.classList.add(t);
    });
  };
}, Qoe = function(e, t) {
  return t === void 0 && (t = e + "-active"), function(r, n) {
    E9(r);
    var i = !1, s = function(o) {
      i || (i = !0, r.removeEventListener(Fd, s), r.removeEventListener(zh, s), n());
    };
    r.classList.add(e), r.addEventListener(Fd, s), r.addEventListener(zh, s), requestAnimationFrame(function() {
      r.classList.add(t);
    });
  };
};
const Xoe = se.getLogger("geoscene.widgets.support.widgetUtils");
function eae(e) {
  const t = jn.acquire();
  for (let n = 0; n < arguments.length; n++) {
    const i = arguments[n], s = typeof i;
    if (s === "string")
      t.push(i);
    else if (Array.isArray(i))
      t.push.apply(t, i);
    else if (s === "object")
      for (const o in i)
        i[o] && t.push(o);
  }
  const r = t.join(" ");
  return jn.release(t), r;
}
(() => {
  const e = /* @__PURE__ */ new Map(), t = new ResizeObserver((n) => {
    var i;
    T9();
    for (const s of n)
      (i = e.get(s.target)) == null || i(s);
  }), r = (n, i, s) => (e.has(n) && Xoe.error("Already observing element", n), e.set(n, i), t.observe(n, s), nl(() => {
    t.unobserve(n), e.delete(n);
  }));
  return (n, i, s) => {
    let o = null;
    return ze(() => typeof n == "function" ? n() : n, (a) => {
      o == null || o.remove(), a && (o = r(a, i, s));
    }, cu);
  };
})();
function tae(e) {
  const t = e == null ? void 0 : e.closest("[dir]");
  return t !== null && t instanceof HTMLElement && t.dir === "rtl" || document.dir === "rtl";
}
function L4e(e) {
  const t = "data-node-ref";
  this[e.getAttribute(t)] = null;
}
function N4e(e) {
  const t = "data-node-ref";
  this[e.getAttribute(t)] = e;
}
function F4e(e, t) {
  return (e === "enter" ? Yoe : Qoe)(t);
}
const rae = ["dd", "dl", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "sub", "sup", "animate", "animatetransform", "circle", "clippath", "defs", "ellipse", "g", "image", "line", "lineargradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "svg", "switch", "symbol", "text", "textpath", "tspan", "use"], nae = rae.reduce((e, t) => (e[t] = [], e), {}), iae = ["align", "alink", "alt", "bgcolor", "border", "cellpadding", "cellspacing", "class", "color", "cols", "colspan", "coords", "d", "dir", "face", "height", "hspace", "ismap", "lang", "marginheight", "marginwidth", "multiple", "nohref", "noresize", "noshade", "nowrap", "ref", "rel", "rev", "rows", "rowspan", "scrolling", "shape", "span", "summary", "tabindex", "title", "usemap", "valign", "value", "vlink", "vspace", "width"], I9 = new Woe({ whiteList: nae, onTagAttr: (e, t, r) => {
  const n = `${t}="${r}"`;
  if (iae.includes(t))
    return n;
}, stripIgnoreTag: !0, stripIgnoreTagBody: ["script", "style"] }, !0);
function sae(e) {
  return e === "Enter" || e === " ";
}
const M9 = "http://www.w3.org/", E_ = `${M9}2000/svg`, O9 = `${M9}1999/xlink`;
let _P = [], dO = (e, t) => {
  let r = {};
  return Object.keys(e).forEach((n) => {
    r[n] = e[n];
  }), t && Object.keys(t).forEach((n) => {
    r[n] = t[n];
  }), r;
}, pO = (e, t) => e.vnodeSelector === t.vnodeSelector && (e.properties && t.properties ? e.properties.key === t.properties.key && e.properties.bind === t.properties.bind : !e.properties && !t.properties), C9 = (e) => {
  if (typeof e != "string")
    throw new Error("Style values must be strings");
}, oae = (e, t, r) => {
  if (t.vnodeSelector !== "") {
    for (let n = r; n < e.length; n++)
      if (pO(e[n], t))
        return n;
  }
  return -1;
}, lS = (e, t, r, n) => {
  let i = e[t];
  if (i.vnodeSelector === "")
    return;
  let s = i.properties;
  if (!(s && (s.key === void 0 ? s.bind : s.key))) {
    for (let o = 0; o < e.length; o++)
      if (o !== t) {
        let a = e[o];
        if (pO(a, i))
          throw new Error(`${r.vnodeSelector} had a ${i.vnodeSelector} child ${n === "added" ? n : "removed"}, but there is now more than one. You must add unique key properties to make them distinguishable.`);
      }
  }
}, aae = (e) => {
  if (e.properties) {
    let t = e.properties.enterAnimation;
    t && t(e.domNode, e.properties);
  }
}, LT = [], NT = !1, k9 = (e) => {
  (e.children || []).forEach(k9), e.properties && e.properties.afterRemoved && e.properties.afterRemoved.apply(e.properties.bind || e.properties, [e.domNode]);
}, SP = () => {
  NT = !1, LT.forEach(k9), LT.length = 0;
}, $P = (e) => {
  LT.push(e), NT || (NT = !0, typeof window < "u" && "requestIdleCallback" in window ? window.requestIdleCallback(SP, { timeout: 16 }) : setTimeout(SP, 16));
}, xP = (e) => {
  let t = e.domNode;
  if (e.properties) {
    let r = e.properties.exitAnimation;
    if (r)
      return t.style.pointerEvents = "none", void r(t, () => {
        t.parentNode && (t.parentNode.removeChild(t), $P(e));
      }, e.properties);
  }
  t.parentNode && (t.parentNode.removeChild(t), $P(e));
}, lae = (e, t, r) => {
  if (!t)
    return;
  let n = r.eventHandlerInterceptor, i = Object.keys(t), s = i.length;
  for (let o = 0; o < s; o++) {
    let a = i[o], l = t[a];
    if (a === "className")
      throw new Error('Property "className" is not supported, use "class".');
    if (a === "class")
      FT(e, l, !0);
    else if (a === "classes") {
      let c = Object.keys(l), h = c.length;
      for (let f = 0; f < h; f++) {
        let m = c[f];
        l[m] && e.classList.add(m);
      }
    } else if (a === "styles") {
      let c = Object.keys(l), h = c.length;
      for (let f = 0; f < h; f++) {
        let m = c[f], y = l[m];
        y && (C9(y), r.styleApplyer(e, m, y));
      }
    } else if (a !== "key" && l != null) {
      let c = typeof l;
      c === "function" ? (a.lastIndexOf("on", 0) === 0 && (n && (l = n(a, l, e, t)), a === "oninput" && function() {
        let h = l;
        l = function(f) {
          h.apply(this, [f]), f.target["oninput-value"] = f.target.value;
        };
      }()), e[a] = l) : r.namespace === E_ ? a === "href" ? e.setAttributeNS(O9, a, l) : e.setAttribute(a, l) : c === "string" && a !== "value" ? a === "innerHTML" ? e[a] = I9.sanitize(l) : A9(e) && a in e ? e[a] = l : e.setAttribute(a, l) : e[a] = l;
    }
  }
};
function A9(e) {
  if (!(e instanceof Element && e.tagName.includes("-")))
    return !1;
  const t = window.customElements.get(e.tagName.toLowerCase());
  return !!t && e instanceof t;
}
let Yb, uae = (e, t, r) => {
  if (t)
    for (let n of t)
      ph(n, e, void 0, r);
}, P9 = (e, t, r) => {
  uae(e, t.children, r), t.text && (e.textContent = t.text), lae(e, t.properties, r), t.properties && t.properties.afterCreate && t.properties.afterCreate.apply(t.properties.bind || t.properties, [e, r, t.vnodeSelector, t.properties, t.children]);
}, ph = (e, t, r, n) => {
  let i, s = 0, o = e.vnodeSelector, a = t.ownerDocument;
  if (o === "")
    i = e.domNode = a.createTextNode(e.text), r !== void 0 ? t.insertBefore(i, r) : t.appendChild(i);
  else {
    for (let l = 0; l <= o.length; ++l) {
      let c = o.charAt(l);
      if (l === o.length || c === "." || c === "#") {
        let h = o.charAt(s - 1), f = o.slice(s, l);
        h === "." ? i.classList.add(f) : h === "#" ? i.id = f : (f === "svg" && (n = dO(n, { namespace: E_ })), n.namespace !== void 0 ? i = e.domNode = a.createElementNS(n.namespace, f) : (i = e.domNode = e.domNode || a.createElement(f), f === "input" && e.properties && e.properties.type !== void 0 && i.setAttribute("type", e.properties.type)), r !== void 0 ? t.insertBefore(i, r) : i.parentNode !== t && t.appendChild(i)), s = l + 1;
      }
    }
    P9(i, e, n);
  }
}, FT = (e, t, r) => {
  t && t.split(" ").forEach((n) => {
    n && e.classList.toggle(n, r);
  });
}, cae = (e, t, r, n) => {
  if (!r)
    return;
  let i = !1, s = Object.keys(r), o = s.length;
  for (let a = 0; a < o; a++) {
    let l = s[a], c = r[l], h = t[l];
    if (l === "class")
      h !== c && (FT(e, h, !1), FT(e, c, !0));
    else if (l === "classes") {
      let f = e.classList, m = Object.keys(c), y = m.length;
      for (let g = 0; g < y; g++) {
        let v = m[g], b = !!c[v];
        b !== !!h[v] && (i = !0, b ? f.add(v) : f.remove(v));
      }
    } else if (l === "styles") {
      let f = Object.keys(c), m = f.length;
      for (let y = 0; y < m; y++) {
        let g = f[y], v = c[g];
        v !== h[g] && (i = !0, v ? (C9(v), n.styleApplyer(e, g, v)) : n.styleApplyer(e, g, ""));
      }
    } else if (c || typeof h != "string" || (c = ""), l === "value") {
      let f = e[l];
      f !== c && (e["oninput-value"] ? f === e["oninput-value"] : c !== h) && (e[l] = c, e["oninput-value"] = void 0), c !== h && (i = !0);
    } else if (c !== h) {
      let f = typeof c;
      f === "function" && n.eventHandlerInterceptor || (n.namespace === E_ ? l === "href" ? e.setAttributeNS(O9, l, c) : e.setAttribute(l, c) : f === "string" ? l === "innerHTML" ? e[l] = I9.sanitize(c) : l === "role" && c === "" ? e.removeAttribute(l) : A9(e) && l in e ? e[l] = c : e.setAttribute(l, c) : e[l] !== c && (e[l] = c), i = !0);
    }
  }
  return i;
}, dae = (e, t, r, n, i) => {
  if (r === n)
    return !1;
  n = n || _P;
  let s, o = (r = r || _P).length, a = n.length, l = 0, c = 0, h = !1;
  for (; c < a; ) {
    let f = l < o ? r[l] : void 0, m = n[c];
    if (f !== void 0 && pO(f, m))
      h = Yb(f, m, i) || h, l++;
    else {
      let y = oae(r, m, l + 1);
      if (y >= 0) {
        for (s = l; s < y; s++)
          xP(r[s]), lS(r, s, e, "removed");
        h = Yb(r[y], m, i) || h, l = y + 1;
      } else
        ph(m, t, l < o ? r[l].domNode : void 0, i), aae(m), lS(n, c, e, "added");
    }
    c++;
  }
  if (o > l)
    for (s = l; s < o; s++)
      xP(r[s]), lS(r, s, e, "removed");
  return h;
};
Yb = (e, t, r) => {
  let n = e.domNode, i = !1;
  if (e === t)
    return !1;
  let s = !1;
  if (t.vnodeSelector === "") {
    if (t.text !== e.text) {
      let o = n.ownerDocument.createTextNode(t.text);
      return n.parentNode.replaceChild(o, n), t.domNode = o, i = !0, i;
    }
    t.domNode = n;
  } else
    t.vnodeSelector.lastIndexOf("svg", 0) === 0 && (r = dO(r, { namespace: E_ })), e.text !== t.text && (s = !0, t.text === void 0 ? n.removeChild(n.firstChild) : n.textContent = t.text), t.domNode = n, s = dae(t, n, e.children, t.children, r) || s, s = cae(n, e.properties, t.properties, r) || s, t.properties && t.properties.afterUpdate && t.properties.afterUpdate.apply(t.properties.bind || t.properties, [n, r, t.vnodeSelector, t.properties, t.children]);
  return s && t.properties && t.properties.updateAnimation && t.properties.updateAnimation(n, t.properties, e.properties), i;
};
let Zf = (e, t) => ({ getLastRender: () => e, update: (r) => {
  if (e.vnodeSelector !== r.vnodeSelector)
    throw new Error("The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)");
  let n = e;
  e = r, Yb(n, r, t);
}, domNode: e.domNode });
const pae = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e, t, r) => {
  t.charAt(0) === "-" ? e.style.setProperty(t, r) : e.style[t] = r;
} };
let Lp = (e) => dO(pae, e), Su = { create: (e, t) => (t = Lp(t), ph(e, document.createElement("div"), void 0, t), Zf(e, t)), append: (e, t, r) => (r = Lp(r), ph(t, e, void 0, r), Zf(t, r)), insertBefore: (e, t, r) => (r = Lp(r), ph(t, e.parentNode, e, r), Zf(t, r)), merge: (e, t, r) => (r = Lp(r), t.domNode = e, P9(e, t, r), Zf(t, r)), replace: (e, t, r) => (r = Lp(r), ph(t, e.parentNode, e, r), e.parentNode.removeChild(e), Zf(t, r)) }, R9, hae = (e, t) => {
  let r = [];
  for (; e && e !== t; )
    r.push(e), e = e.parentNode;
  return r;
};
R9 = Array.prototype.find ? (e, t) => e.find(t) : (e, t) => e.filter(t)[0];
let fae = (e, t) => {
  let r = e;
  return t.forEach((n) => {
    r = r && r.children ? R9(r.children, (i) => i.domNode === n) : void 0;
  }), r;
}, mae = (e, t, r) => {
  let n = function(i) {
    r("domEvent", i);
    let s = t(), o = hae(i.currentTarget, s.domNode);
    o.reverse();
    let a, l = fae(s.getLastRender(), o);
    return e.scheduleRender(), l && (a = l.properties[`on${i.type}`].apply(l.properties.bind || this, arguments)), r("domEventProcessed", i), a;
  };
  return (i, s, o, a) => n;
}, TP = (e) => {
  let t, r, n = Lp(e), i = n.performanceLogger, s = !0, o = !1, a = [], l = [], c = (f, m, y) => {
    let g, v = () => g;
    n.eventHandlerInterceptor = mae(t, v, i), g = f(m, y(), n), a.push(g), l.push(y);
  }, h = () => {
    if (r = void 0, s) {
      s = !1, i("renderStart", void 0);
      for (let f = 0; f < a.length; f++) {
        let m = l[f]();
        i("rendered", void 0), a[f].update(m), i("patched", void 0);
      }
      i("renderDone", void 0), s = !0;
    }
  };
  return t = { renderNow: h, scheduleRender: () => {
    r || o || (r = requestAnimationFrame(h));
  }, stop: () => {
    r && (cancelAnimationFrame(r), r = void 0), o = !0;
  }, resume: () => {
    o = !1, s = !0, t.scheduleRender();
  }, append: (f, m) => {
    c(Su.append, f, m);
  }, insertBefore: (f, m) => {
    c(Su.insertBefore, f, m);
  }, merge: (f, m) => {
    c(Su.merge, f, m);
  }, replace: (f, m) => {
    c(Su.replace, f, m);
  }, detach: (f) => {
    for (let m = 0; m < l.length; m++)
      if (l[m] === f)
        return l.splice(m, 1), a.splice(m, 1)[0];
    throw new Error("renderFunction was not found");
  } }, t;
}, Jl = class extends Ae {
  constructor() {
    super(...arguments), this.items = new je(), this._watchUpdatingTracking = new _h(), this._callbacks = /* @__PURE__ */ new Map(), this._projector = TP(), this._hiddenProjector = TP();
  }
  get needsRender() {
    return this.items.length > 0;
  }
  get updating() {
    var t;
    return ((t = this._watchUpdatingTracking) == null ? void 0 : t.updating) ?? !1;
  }
  initialize() {
    const t = document.createElement("div");
    t.className = "geoscene-overlay-surface", this._set("surface", t), this._hiddenSurface = document.createElement("div"), this._hiddenSurface.setAttribute("style", "visibility: hidden;"), t.appendChild(this._hiddenSurface), this._watchUpdatingTracking.addOnCollectionChange(() => this.items, (r) => {
      for (const n of r.added) {
        const i = () => n.render();
        this._callbacks.set(n, i), this._projector.append(this.surface, i);
      }
      for (const n of r.removed) {
        const i = this._projector.detach(this._callbacks.get(n));
        this.surface.removeChild(i.domNode), this._callbacks.delete(n);
      }
    });
  }
  addItem(t) {
    this.items.add(t);
  }
  removeItem(t) {
    this.items.remove(t);
  }
  destroy() {
    this.items.removeAll(), this._callbacks.forEach((t) => this._projector.detach(t)), this._callbacks = null, this._projector = null, this._watchUpdatingTracking.destroy();
  }
  render() {
    this._projector.renderNow();
  }
  computeBoundingRect(t) {
    const r = this._hiddenSurface, n = this._hiddenProjector;
    let i;
    const s = () => (i = t.render(), i);
    n.append(r, s), n.renderNow();
    const o = { left: 0, top: 0, right: 0, bottom: 0 };
    if (i && i.domNode) {
      const a = i.domNode.getBoundingClientRect();
      o.left = a.left, o.top = a.top, o.right = a.right, o.bottom = a.bottom;
    }
    for (n.detach(s); r.firstChild; )
      r.removeChild(r.firstChild);
    return o;
  }
  overlaps(t, r) {
    const n = this.computeBoundingRect(t), i = this.computeBoundingRect(r);
    return Math.max(n.left, i.left) <= Math.min(n.right, i.right) && Math.max(n.top, i.top) <= Math.min(n.bottom, i.bottom);
  }
  get hasVisibleItems() {
    return this.items.some((t) => t.visible);
  }
  async prepare() {
    await document.fonts.load(this._fontString()).catch(() => {
    });
  }
  renderCanvas(t) {
    if (!this.items.some((n) => n.visible))
      return;
    const r = t.getContext("2d");
    r.save(), r.font = this._fontString(), this.items.forEach((n) => {
      r.save(), n.renderCanvas(r), r.restore();
    }), r.restore();
  }
  _fontString() {
    return `10px ${getComputedStyle(this.surface).fontFamily}`;
  }
};
u([d({ readOnly: !0 })], Jl.prototype, "surface", void 0), u([d({ readOnly: !0 })], Jl.prototype, "items", void 0), u([d({ readOnly: !0 })], Jl.prototype, "needsRender", null), u([d({ readOnly: !0 })], Jl.prototype, "_watchUpdatingTracking", void 0), u([d({ readOnly: !0 })], Jl.prototype, "updating", null), Jl = u([E("geoscene.views.overlay.ViewOverlay")], Jl);
const EP = Jl, uS = [0, 0];
function yae(e) {
  const t = (e.ownerDocument || window.document).defaultView, r = e.getBoundingClientRect();
  return uS[0] = r.left + ((t == null ? void 0 : t.pageXOffset) ?? 0), uS[1] = r.top + ((t == null ? void 0 : t.pageYOffset) ?? 0), uS;
}
function IP(e) {
  e && (c9(e), e.parentNode && e.parentNode.removeChild(e));
}
function gae(e) {
  const t = document.createElement("div");
  return e.appendChild(t), t;
}
const Kf = 16, Z0 = 750, vae = 512, bae = 2, wae = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this._freqInfo = { freq: Kf, time: Z0 }, this._overlayRenderTaskHandle = null, this.height = 0, this.overlay = null, this.position = null, this.resizing = !1, this.root = null, this.surface = null, this.suspended = !0, this.ui = null, this.userContent = null, this.width = 0, this.widthBreakpoint = null, this.addHandles([ze(() => this.cursor, (n) => {
        const { surface: i } = this;
        i && i.setAttribute("data-cursor", n);
      }), ze(() => this.navigating, (n) => {
        const { surface: i } = this;
        i && i.setAttribute("data-navigating", n.toString());
      })]);
    }
    initialize() {
      this.addHandles([ze(() => this.ui, (r, n) => this._handleUIChange(r, n), ln), this.on("focus", () => this.notifyChange("focused")), this.on("blur", () => this.notifyChange("focused"))]);
    }
    destroy() {
      this.destroyed || (this.ui = Vt(this.ui), this.container = null);
    }
    get container() {
      return this._get("container") ?? null;
    }
    set container(r) {
      const n = this._get("container"), i = uO(r);
      if (i || typeof r != "string" || se.getLogger(this).error("#container", `element with id '${r}' not found`), n === i)
        return;
      if (this._stopMeasuring(), n && (n.classList.remove("geoscene-view"), this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null), this.overlay && (this.overlay.destroy(), this._set("overlay", null)), this.root && (IP(this.root), this._set("root", null)), this.userContent && (yP(this.userContent, n), IP(this.userContent), this._set("userContent", null))), !i)
        return this._set("width", 0), this._set("height", 0), this._set("position", null), this._set("suspended", !0), this._set("surface", null), void this._set("container", null);
      i.classList.add("geoscene-view");
      const s = document.createElement("div");
      s.className = "geoscene-view-user-storage", yP(i, s), i.appendChild(s), this._set("userContent", s);
      const o = document.createElement("div");
      o.className = "geoscene-view-root", i.insertBefore(o, i.firstChild), this._set("root", o);
      const a = document.createElement("div");
      a.className = "geoscene-view-surface", a.setAttribute("role", "application"), a.tabIndex = 0, o.appendChild(a), this._set("surface", a);
      const l = new EP();
      o.appendChild(l.surface), this._set("overlay", l), this.addHandles(ze(() => l.needsRender, (c) => {
        c && !this._overlayRenderTaskHandle ? this._overlayRenderTaskHandle = Ah({ render: () => {
          var h;
          return (h = this.overlay) == null ? void 0 : h.render();
        } }) : this._overlayRenderTaskHandle = tr(this._overlayRenderTaskHandle);
      })), this.forceDOMReadyCycle(), this._set("container", i), this._startMeasuring();
    }
    get focused() {
      const r = document.activeElement === this.surface;
      return document.hasFocus() && r;
    }
    get size() {
      return [this.width, this.height];
    }
    blur() {
      var r;
      (r = this.surface) == null || r.blur();
    }
    focus() {
      var r;
      (r = this.surface) == null || r.focus();
    }
    pageToContainer(r, n, i) {
      const s = this.position;
      return r -= s ? s[0] : 0, n -= s ? s[1] : 0, i ? (i[0] = r, i[1] = n) : i = [r, n], i;
    }
    containerToPage(r, n, i) {
      const s = this.position;
      return r += s ? s[0] : 0, n += s ? s[1] : 0, i ? (i[0] = r, i[1] = n) : i = [r, n], i;
    }
    _handleUIChange(r, n) {
      this.removeHandles("ui"), n && n !== r && n.destroy(), r && (r.view = this, this.addHandles(ze(() => this.root, (i) => {
        r.container = i ? gae(i) : null;
      }, ln), "ui")), this._set("ui", r);
    }
    _stopMeasuring() {
      this.removeHandles("measuring"), this._get("resizing") && this._set("resizing", !1);
    }
    _startMeasuring() {
      const r = this._freqInfo;
      r.freq = Kf, r.time = Z0, this.addHandles([(() => {
        const n = () => {
          r.freq = Kf, r.time = Z0;
        };
        return window.addEventListener("resize", n), { remove() {
          window.removeEventListener("resize", n);
        } };
      })(), Ah({ prepare: (n) => {
        const i = this._measure(), s = this._freqInfo;
        if (s.time += n.deltaTime, i && (s.freq = Kf, this._get("resizing") || this._set("resizing", !0)), s.time < s.freq)
          return;
        s.time = 0;
        const o = this._position();
        s.freq = o || i ? Kf : Math.min(Z0, s.freq * bae), !i && s.freq >= vae && this._get("resizing") && this._set("resizing", !1);
      } })], "measuring"), this._measure(), this._position();
    }
    _measure() {
      const r = this.container, n = r ? r.clientWidth : 0, i = r ? r.clientHeight : 0;
      if (n === 0 || i === 0)
        return this.suspended || this._set("suspended", !0), !1;
      const s = this.width, o = this.height;
      return n === s && i === o ? (this.suspended && this._set("suspended", !1), !1) : (this._set("width", n), this._set("height", i), this.suspended && this._set("suspended", !1), this.emit("resize", { oldWidth: s, oldHeight: o, width: n, height: i }), !0);
    }
    _position() {
      const r = this.container, n = this.position, i = r && yae(r);
      return !!i && (!n || i[0] !== n[0] || i[1] !== n[1]) && (this._set("position", [i[0], i[1]]), !0);
    }
    forceDOMReadyCycle() {
    }
  };
  return u([d()], t.prototype, "container", null), u([d({ readOnly: !0 })], t.prototype, "focused", null), u([d({ readOnly: !0 })], t.prototype, "height", void 0), u([d({ type: EP })], t.prototype, "overlay", void 0), u([d({ readOnly: !0 })], t.prototype, "position", void 0), u([d({ readOnly: !0 })], t.prototype, "resizing", void 0), u([d({ readOnly: !0 })], t.prototype, "root", void 0), u([d({ value: null, readOnly: !0 })], t.prototype, "size", null), u([d({ readOnly: !0 })], t.prototype, "surface", void 0), u([d({ readOnly: !0 })], t.prototype, "suspended", void 0), u([d()], t.prototype, "ui", void 0), u([d({ readOnly: !0 })], t.prototype, "userContent", void 0), u([d({ readOnly: !0 })], t.prototype, "width", void 0), u([d()], t.prototype, "widthBreakpoint", void 0), t = u([E("geoscene.views.DOMContainer")], t), t;
};
let _ae = class {
  constructor(t, r) {
    this._owner = r, this._properties = {}, this._afterDispatchHandle = null;
    for (const n in t) {
      const i = t[n], s = new fF(i, void 0, void 0, 2, 2);
      this._properties[n] = { pool: s, acquired: [] };
    }
    this._afterDispatchHandle = WW(() => this._release());
  }
  destroy() {
    this._afterDispatchHandle && (this._afterDispatchHandle.remove(), this._afterDispatchHandle = null);
    for (const t in this._properties) {
      const r = this._properties[t];
      for (const n of r.acquired)
        xk(n) || r.pool.release(n);
      r.pool.destroy(), r.pool = null, r.acquired = null;
    }
    this._properties = null, this._owner = null;
  }
  get(t) {
    const r = this._owner._get(t), n = this._properties[t];
    let i = n.pool.acquire();
    for (n.acquired.push(i); i === r; )
      n.acquired.push(i), i = n.pool.acquire();
    return i;
  }
  _release() {
    for (const t in this._properties) {
      const r = this._properties[t];
      let n = 0;
      for (const i of r.acquired)
        xk(i) ? r.acquired[n++] = i : r.pool.release(i);
      r.acquired.length = n;
    }
  }
};
const Sae = U("mac") ? "Meta" : "Ctrl", I_ = { 8: "Backspace", 9: "Tab", 13: "Enter", 27: "Escape", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete" };
for (let e = 48; e < 58; e++)
  I_[e] = String.fromCharCode(e);
for (let e = 1; e < 25; e++)
  I_[111 + e] = `F${e}`;
for (let e = 65; e < 91; e++)
  I_[e] = [String.fromCharCode(e + 32), String.fromCharCode(e)];
function $ae(e) {
  if (e.key !== void 0)
    return OW(e);
  const t = I_[e.keyCode];
  return Array.isArray(t) ? e.shiftKey ? t[1] : t[0] : t;
}
function xae(e) {
  switch (e) {
    case "Ctrl":
    case "Alt":
    case "Shift":
    case "Meta":
    case "Primary":
      return !0;
  }
  return !1;
}
let Tae = class {
  constructor(t, r = []) {
    this.eventType = t, this.keyModifiers = r;
  }
  matches(t) {
    if (t.type !== this.eventType)
      return !1;
    if (this.keyModifiers.length === 0)
      return !0;
    const r = t.modifiers;
    for (const n of this.keyModifiers)
      if (!r.has(n))
        return !1;
    return !0;
  }
};
const MP = se.getLogger("geoscene.views.input.InputHandler");
let Br = class {
  constructor(t) {
    this._manager = null, this._incoming = {}, this._outgoing = {}, this._incomingEventMatches = null, this._incomingEventTypes = null, this._outgoingEventTypes = null, this._hasSideEffects = t;
  }
  get incomingEventMatches() {
    if (!this._incomingEventMatches) {
      this._incomingEventMatches = [];
      for (const t in this._incoming) {
        const r = this._incoming[t];
        for (const n of r)
          this._incomingEventMatches.push(n.match);
      }
    }
    return this._incomingEventMatches;
  }
  get incomingEventTypes() {
    return this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map((t) => t.eventType)), this._incomingEventTypes;
  }
  get outgoingEventTypes() {
    return this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing)), this._outgoingEventTypes;
  }
  get hasSideEffects() {
    return this._hasSideEffects;
  }
  get hasPendingInputs() {
    return !1;
  }
  onInstall(t) {
    this._manager ? MP.error("This InputHandler has already been registered with an InputManager") : (t.setEventCallback((r) => this._handleEvent(r)), t.setUninstallCallback(() => this._onUninstall()), this._manager = t);
  }
  onUninstall() {
  }
  registerIncoming(t, r, n) {
    let i;
    typeof r == "function" ? (n = r, i = []) : i = r || [];
    const s = typeof t == "string" ? new Tae(t, i) : t, o = () => {
      this._incomingEventTypes = null, this._incomingEventMatches = null;
    }, a = (h) => {
      const f = this._incoming[h.match.eventType];
      if (f) {
        const m = f.indexOf(h);
        f.splice(m, 1), o(), this._manager && this._manager.updateDependencies();
      }
    }, l = new Eae(s, n, { onPause: a, onRemove: a, onResume: (h) => {
      const f = this._incoming[h.match.eventType];
      f && !f.includes(h) && (f.push(h), o(), this._manager && this._manager.updateDependencies());
    } });
    let c = this._incoming[s.eventType];
    return c || (c = [], this._incoming[s.eventType] = c), c.push(l), o(), this._manager && this._manager.updateDependencies(), l;
  }
  registerOutgoing(t) {
    if (this._outgoing[t])
      throw new Error("There is already a callback registered for this outgoing InputEvent: " + t);
    const r = new Iae(t, { onEmit: (n, i, s, o) => {
      var a;
      (a = this._manager) == null || a.emit(n.eventType, i, s, o);
    }, onRemove: (n) => {
      var i;
      delete this._outgoing[n.eventType], (i = this._manager) == null || i.updateDependencies();
    } });
    return this._outgoing[t] = r, this._outgoingEventTypes = null, this._manager && this._manager.updateDependencies(), r;
  }
  startCapturingPointer(t) {
    var r;
    (r = this._manager) == null || r.setPointerCapture(t, !0);
  }
  stopCapturingPointer(t) {
    var r;
    (r = this._manager) == null || r.setPointerCapture(t, !1);
  }
  refreshHasPendingInputs() {
    var t;
    (t = this._manager) == null || t.refreshHasPendingInputs();
  }
  _onUninstall() {
    this._manager ? (this.onUninstall(), this._manager = null) : MP.error("This InputHandler is not registered with an InputManager");
  }
  _handleEvent(t) {
    var n;
    const r = this._incoming[t.type];
    if (r) {
      for (const i of r)
        if (i.match.matches(t) && ((n = i.callback) == null || n.call(i, t), t.shouldStopPropagation()))
          break;
    }
  }
}, Eae = class {
  constructor(t, r, n) {
    this.match = t, this._callback = r, this._handler = n;
  }
  pause() {
    this._handler.onPause(this);
  }
  resume() {
    this._handler.onResume(this);
  }
  remove() {
    this._handler.onRemove(this);
  }
  get callback() {
    return this._callback;
  }
}, Iae = class {
  constructor(t, r) {
    this.eventType = t, this._removed = !1, this._handler = r;
  }
  emit(t, r, n) {
    this._removed || this._handler.onEmit(this, t, r, n);
  }
  remove() {
    this._removed = !0, this._handler.onRemove(this);
  }
}, Mae = class extends Br {
  constructor(t) {
    super(!0), this._onChange = t, this._value = "mouse", this._x = null, this._y = null, this.registerIncoming("pointer-move", (r) => {
      this._update(r.data);
    });
  }
  _update(t) {
    const r = t.native.pointerType === "touch" ? "touch" : "mouse", { x: n, y: i } = t;
    r === this._value && this._x === n && this._y === i || (this._value = r, this._x = n, this._y = i, this._onChange(r, n, i));
  }
}, Oae = class {
  constructor(t, r) {
    this._observable = new t_(), this._value = t, this._equalityFunction = r;
  }
  get value() {
    return Ve(this._observable), this._value;
  }
  set value(t) {
    this._equalityFunction(t, this._value) || (this._value = t, this._observable.notify());
  }
  mutate(t) {
    t(this._value), this._observable.notify();
  }
};
function Qb(e, t = Y5) {
  return new Oae(e, t);
}
let Cae = class extends Br {
  get multiTouchActive() {
    return this._multiTouchActive.value;
  }
  constructor() {
    super(!0), this._activeTouchPointerIds = /* @__PURE__ */ new Set(), this._multiTouchActive = Qb(!1), this._onPointerAdd = ({ data: t }) => {
      t.pointerType === "touch" && (this._activeTouchPointerIds.add(t.native.pointerId), this._update());
    }, this._onPointerRemove = ({ data: t }) => {
      t.pointerType === "touch" && (this._activeTouchPointerIds.delete(t.native.pointerId), this._update());
    }, this.registerIncoming("pointer-down", this._onPointerAdd), this.registerIncoming("pointer-up", this._onPointerRemove), this.registerIncoming("pointer-capture-lost", this._onPointerRemove), this.registerIncoming("pointer-cancel", this._onPointerRemove);
  }
  _update() {
    this._multiTouchActive.value = this._activeTouchPointerIds.size > 1;
  }
}, es = class extends Ae {
  constructor(t) {
    super(t), this._pointerCaptures = /* @__PURE__ */ new Map(), this._nameToGroup = {}, this._handlers = [], this._handlersPriority = [], this._currentPropagation = null, this._updateDependenciesAfterPropagation = !1, this._sourceEvents = /* @__PURE__ */ new Set(), this._keyModifiers = /* @__PURE__ */ new Set(), this._activeKeyModifiers = /* @__PURE__ */ new Set(), this._stoppedPropagationEventIds = /* @__PURE__ */ new Set(), this.primaryKey = Sae, this._latestPointerType = "mouse", this._propertiesPool = new _ae({ latestPointerLocation: Pae }, this), this.latestPointerLocation = null, this._paused = !1, this.test = { timestamp: void 0, hasCurrentPropagation: () => !!this._currentPropagation };
  }
  initialize() {
    this.eventSource.onEventReceived = this._onEventReceived.bind(this), this._installRecognizers();
  }
  destroy() {
    const t = Object.keys(this._nameToGroup);
    for (const r of t)
      this.uninstallHandlers(r);
    this.eventSource.destroy(), this._currentPropagation = null, this._propertiesPool.destroy();
  }
  get hasPendingInputs() {
    return this._handlers.some((t) => t.handler.hasPendingInputs);
  }
  get latestPointerType() {
    return this._latestPointerType;
  }
  get multiTouchActive() {
    return this._multiTouchHandler.multiTouchActive;
  }
  get updating() {
    return this.hasPendingInputs || this._paused;
  }
  installHandlers(t, r, n = Iu.INTERNAL) {
    if (this._nameToGroup[t])
      return void se.getLogger(this).error("There is already an InputHandler group registered under the name `" + t + "`");
    if (r.length === 0)
      return void se.getLogger(this).error("Can't register a group of zero handlers");
    const i = { name: t, handlers: r.map((s) => ({ handler: s, active: !0, removed: !1, priorityIndex: 0, groupPriority: n, eventCallback: null, uninstallCallback: null })) };
    this._nameToGroup[t] = i;
    for (let s = i.handlers.length - 1; s >= 0; s--) {
      const o = i.handlers[s];
      this._handlers.push(o), o.handler.onInstall({ updateDependencies: () => {
        this.updateDependencies();
      }, emit: (a, l, c, h, f) => {
        this._emitInputEvent(o.priorityIndex + 1, a, l, c, f, h);
      }, setPointerCapture: (a, l) => {
        this._setPointerCapture(i, o, a, l);
      }, setEventCallback: (a) => {
        o.eventCallback = a;
      }, setUninstallCallback: (a) => {
        o.uninstallCallback = a;
      }, refreshHasPendingInputs: () => {
        this.notifyChange("hasPendingInputs");
      } });
    }
    this.updateDependencies();
  }
  uninstallHandlers(t) {
    const r = this._nameToGroup[t];
    r ? (r.handlers.forEach((n) => {
      var i;
      n.removed = !0, (i = n.uninstallCallback) == null || i.call(n);
    }), delete this._nameToGroup[t], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = !0 : this._garbageCollectRemovedHandlers()) : se.getLogger(this).error("There is no InputHandler group registered under the name `" + t + "`");
  }
  hasHandlers(t) {
    return this._nameToGroup[t] !== void 0;
  }
  updateDependencies() {
    if (this._currentPropagation)
      return void (this._updateDependenciesAfterPropagation = !0);
    this._updateDependenciesAfterPropagation = !1;
    const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
    this._handlersPriority = [];
    for (let n = this._handlers.length - 1; n >= 0; n--) {
      const i = this._handlers[n];
      i.priorityIndex = n, this._handlersPriority.push(i);
    }
    this._handlersPriority = this._sortHandlersPriority(this._handlersPriority);
    for (let n = this._handlersPriority.length - 1; n >= 0; n--) {
      const i = this._handlersPriority[n];
      i.priorityIndex = n;
      let s = i.handler.hasSideEffects;
      if (!s) {
        for (const o of i.handler.outgoingEventTypes)
          if (t.has(o)) {
            s = !0;
            break;
          }
      }
      if (s)
        for (const o of i.handler.incomingEventMatches) {
          t.add(o.eventType);
          for (const a of o.keyModifiers)
            xae(a) || r.add(a);
        }
      i.active = s;
    }
    this._sourceEvents = t, this._keyModifiers = r, this._pointerCaptures.size > 0 && this._sourceEvents.add("pointer-capture-lost"), this._keyModifiers.size > 0 && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up")), this.eventSource && (this.eventSource.activeEvents = this._sourceEvents);
  }
  _setLatestPointer(t, r, n) {
    this._latestPointerType = t;
    const i = this._get("latestPointerLocation");
    if (i == null || i.x !== r || i.y !== n) {
      const s = this._propertiesPool.get("latestPointerLocation");
      s.x = r, s.y = n, this._set("latestPointerLocation", s);
    }
  }
  _onEventReceived(t, r) {
    if (t === "pointer-capture-lost") {
      const s = r;
      this._pointerCaptures.delete(s.native.pointerId);
    }
    this._updateKeyModifiers(t, r);
    const n = this.test.timestamp != null ? this.test.timestamp : r.native ? r.native.timestamp : void 0, i = r.native ? r.native.cancelable : void 0;
    this._emitInputEventFromSource(t, r, n, i);
  }
  _updateKeyModifiers(t, r) {
    if (!r)
      return;
    let n = !1;
    const i = () => {
      if (!n) {
        const a = /* @__PURE__ */ new Set();
        this._activeKeyModifiers.forEach((l) => {
          a.add(l);
        }), this._activeKeyModifiers = a, n = !0;
      }
    }, s = (a, l) => {
      l && !this._activeKeyModifiers.has(a) ? (i(), this._activeKeyModifiers.add(a)) : !l && this._activeKeyModifiers.has(a) && (i(), this._activeKeyModifiers.delete(a));
    };
    if (t === "key-down" || t === "key-up") {
      const a = r.key;
      this._keyModifiers.has(a) && s(a, t === "key-down");
    }
    const o = r.native;
    s("Alt", !(!o || !o.altKey)), s("Ctrl", !(!o || !o.ctrlKey)), s("Shift", !(!o || !o.shiftKey)), s("Meta", !(!o || !o.metaKey)), s("Primary", this._activeKeyModifiers.has(this.primaryKey));
  }
  _installRecognizers() {
    this._latestPointerHandler = new Mae((t, r, n) => this._setLatestPointer(t, r, n)), this._multiTouchHandler = new Cae(), this.installHandlers("input-manager-logic", [this._latestPointerHandler, this._multiTouchHandler], Iu.ALWAYS), this.recognizers.length > 0 && this.installHandlers("default", this.recognizers, Iu.INTERNAL);
  }
  _setPointerCapture(t, r, n, i) {
    const s = t.name + "-" + r.priorityIndex, o = this._pointerCaptures.get(n.pointerId) || /* @__PURE__ */ new Set();
    this._pointerCaptures.set(n.pointerId, o), i ? (o.add(s), o.size === 1 && this.eventSource && this.eventSource.setPointerCapture(n, !0)) : o.has(s) && (o.delete(s), o.size === 0 && (this._pointerCaptures.delete(n.pointerId), this.eventSource && this.eventSource.setPointerCapture(n, !1)));
  }
  _garbageCollectRemovedHandlers() {
    this._handlers = this._handlers.filter((t) => !t.removed), this.updateDependencies();
  }
  _emitInputEventFromSource(t, r, n, i) {
    this._emitInputEvent(0, t, r, n, i);
  }
  _emitInputEvent(t, r, n, i, s, o) {
    const a = i !== void 0 ? i : this._currentPropagation ? this._currentPropagation.timestamp : performance.now(), l = s !== void 0 && s, c = { event: new kae(r, n, a, o || this._activeKeyModifiers, l), priorityIndex: t };
    this._currentPropagation ? this._currentPropagation.events.push(c) : this._doNewPropagation(c);
  }
  _doNewPropagation(t) {
    this._currentPropagation = { events: new qb(), currentHandler: null, needsHandlerGarbageCollect: !1, timestamp: t.event.timestamp }, this._currentPropagation.events.push(t), this._continuePropagation();
  }
  _continuePropagation() {
    var r, n;
    this._paused = !1;
    const t = this._currentPropagation;
    if (t) {
      for (; t.events.length > 0; ) {
        const { event: i, priorityIndex: s } = t.events.pop(), o = i.data && i.data.eventId;
        if (!(o != null && this._stoppedPropagationEventIds.has(o)))
          for (t.currentHandler = this._handlersPriority[s]; t.currentHandler; ) {
            if (t.currentHandler.removed)
              t.needsHandlerGarbageCollect = !0;
            else {
              if (t.currentHandler.active && !i.shouldStopPropagation() && ((n = (r = t.currentHandler).eventCallback) == null || n.call(r, i)), i.shouldStopPropagation()) {
                o != null && this._stoppedPropagationEventIds.add(o);
                break;
              }
              if (i.shouldPausePropagation(() => this._continuePropagation()))
                return void this._pausePropagation({ event: i, priorityIndex: t.currentHandler.priorityIndex + 1 });
            }
            t.currentHandler = this._handlersPriority[t.currentHandler.priorityIndex + 1];
          }
      }
      t.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers(), this.hasPendingInputs || this._stoppedPropagationEventIds.clear(), this._currentPropagation = null, this._updateDependenciesAfterPropagation && this.updateDependencies();
    }
  }
  _pausePropagation(t) {
    const r = new qb();
    r.push(t);
    const n = this._currentPropagation;
    if (n) {
      for (; n.events.length; )
        r.push(n.events.pop());
      n.events = r, n.currentHandler = null, this._paused = !0;
    }
  }
  _compareHandlerPriority(t, r) {
    if (t.handler.hasSideEffects !== r.handler.hasSideEffects)
      return t.handler.hasSideEffects ? 1 : -1;
    if (t.groupPriority !== r.groupPriority)
      return t.groupPriority > r.groupPriority ? -1 : 1;
    for (const n of t.handler.incomingEventMatches)
      for (const i of r.handler.incomingEventMatches) {
        if (n.eventType !== i.eventType)
          continue;
        const s = n.keyModifiers.filter((o) => i.keyModifiers.includes(o));
        if (s.length === n.keyModifiers.length != (s.length === i.keyModifiers.length))
          return n.keyModifiers.length > i.keyModifiers.length ? -1 : 1;
      }
    return t.priorityIndex > r.priorityIndex ? -1 : 1;
  }
  _sortHandlersPriority(t) {
    const r = [];
    for (const n of t) {
      let i = 0;
      for (; i < r.length && this._compareHandlerPriority(n, r[i]) >= 0; )
        i++;
      r.splice(i, 0, n);
    }
    return r;
  }
  get debug() {
    const t = (r) => {
      const n = this._setPointerCapture;
      this._setPointerCapture = () => {
      }, r(), this._setPointerCapture = n;
    };
    return { injectEvent: (r, n) => {
      t(() => {
        this._onEventReceived(r, n);
      });
    }, disablePointerCapture: t };
  }
};
u([d({ readOnly: !0 })], es.prototype, "hasPendingInputs", null), u([d({ constructOnly: !0 })], es.prototype, "eventSource", void 0), u([d({ constructOnly: !0 })], es.prototype, "recognizers", void 0), u([d()], es.prototype, "_latestPointerType", void 0), u([d()], es.prototype, "latestPointerType", null), u([d()], es.prototype, "multiTouchActive", null), u([d({ readOnly: !0 })], es.prototype, "latestPointerLocation", void 0), u([d()], es.prototype, "_paused", void 0), u([d({ readOnly: !0 })], es.prototype, "updating", null), es = u([E("geoscene.views.input.InputManager")], es);
let kae = class {
  constructor(t, r, n, i, s) {
    this.type = t, this.data = r, this.timestamp = n, this.modifiers = i, this.cancelable = s, this._propagationState = hu.NONE, this._resumeCallback = null;
  }
  stopPropagation() {
    this._propagationState |= hu.STOPPED;
  }
  shouldStopPropagation() {
    return (this._propagationState & hu.STOPPED) != 0;
  }
  async(t) {
    this._propagationState |= hu.PAUSED;
    const r = (n, i) => {
      this._propagationState &= ~hu.PAUSED;
      const s = this._resumeCallback;
      if (this._resumeCallback = null, s && s(), i)
        throw n;
      return n;
    };
    return (typeof t == "function" ? t() : t).then((n) => r(n, !1), (n) => r(n, !0));
  }
  shouldPausePropagation(t) {
    return !!(this._propagationState & hu.PAUSED) && (this._resumeCallback = t, !0);
  }
  preventDefault() {
    this.data.native.preventDefault();
  }
};
var hu;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.STOPPED = 1] = "STOPPED", e[e.PAUSED = 2] = "PAUSED";
})(hu || (hu = {}));
const Iu = { ALWAYS: 1, DEFAULT: 0, TOOL: -1, WIDGET: -2, INTERNAL: -3 };
let Aae = class {
};
const Pae = Aae;
function xo(e) {
  return e != null && "open" in e && "declaredClass" in e;
}
function OP(e) {
  return e != null && "declaredClass" in e && "dockOptions" in e;
}
const Rae = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this._popupSetupTask = null, this.popup = {}, this.popupEnabled = !0;
    }
    initialize() {
      this.addHandles([ze(() => [this.ui, this.popup], ([r, n], i) => {
        const s = "popup", o = "manual";
        if (i) {
          const [a, l] = i;
          a && xo(l) && (l.view = null, OP(l) && a.remove(l, s));
        }
        r && xo(n) && (n.view = this, OP(n) && r.add(n, { key: s, position: o, internal: !0 }));
      }, ln), this.on("click", (r) => {
        this.popup && this.popupEnabled && (r.pointerType !== "mouse" || r.button === 0) && (!xo(this.popup) && "autoOpenEnabled" in this.popup && this.popup.autoOpenEnabled === !1 || (xo(this.popup) ? this.popup.viewModel.handleViewClick(r) : r.async(async () => {
          await this.setupPopup(), xo(this.popup) && !this.destroyed && this.ready && this.popupEnabled && this.popup.viewModel.handleViewClick(r);
        })));
      }, Iu.WIDGET)]), tO(() => this.ready && this.popupEnabled && !this.updating).then(() => {
        import("./Popup-qMNqY8kU.js").then((r) => r.a0);
      });
    }
    destroy() {
      this.destroyed || this.closePopup();
    }
    async openPopup(r) {
      xo(this.popup) && this.popup.open(r);
      try {
        if (await this.setupPopup(), !this.popup)
          return void se.getLogger(this).error(new G("view:null-popup", "Popup is null and can't be opened"));
        this.popup.open(r);
      } catch {
      }
    }
    closePopup() {
      var r;
      (r = this._popupSetupTask) == null || r.abort(), xo(this.popup) && this.popup.close();
    }
    async fetchPopupFeatures(r, n) {
      await this.when();
      const { location: i, queryArea: s, layerViewsAndGraphics: o, clientOnlyGraphics: a } = await this._prepareFetchPopupFeatures(r, n), l = Promise.resolve(a), c = this._queryLayerPopupFeatures(s, o, n), h = c.map((f) => f.promise);
      return { location: i, clientOnlyGraphics: a, allGraphicsPromise: kW([l, ...h]).then((f) => Array.from(new Set(f.flat()))), promisesPerLayerView: c };
    }
    async setupPopup() {
      var r;
      if ((r = this._popupSetupTask) == null || r.abort(), this.popup && !xo(this.popup))
        return this._popupSetupTask = Z3(async (n) => {
          const { default: i } = await import("./Popup-qMNqY8kU.js").then((o) => o.a0);
          if (lr(n), !this.popup || xo(this.popup))
            return;
          const s = this.popup;
          delete s.open, delete s.close, this.popup = new i(s);
        }), this._popupSetupTask.promise;
    }
    _queryLayerPopupFeatures(r, n, i) {
      return n.map(({ layerView: s, graphics: o }) => {
        const a = { clientGraphics: o, event: i != null ? i.event : void 0, signal: i != null ? i.signal : void 0, defaultPopupTemplateEnabled: i != null && !!i.defaultPopupTemplateEnabled }, l = s.fetchPopupFeatures(r, a);
        return { layerView: s, promise: l };
      });
    }
    _isValidPopupGraphic(r, n) {
      return r && !!r.getEffectivePopupTemplate(n != null && n.defaultPopupTemplateEnabled);
    }
    async _prepareFetchPopupFeatures(r, n) {
      const { clientGraphics: i, queryArea: s, location: o } = await this._popupHitTestGraphics(r, n), a = this._getFetchPopupLayerViews(), { layerViewsAndGraphics: l, clientOnlyGraphics: c } = this._graphicsPerFetchPopupLayerView(i, a);
      return { clientOnlyGraphics: c, layerViewsAndGraphics: l, queryArea: s, location: o };
    }
    async _popupHitTestGraphics(r, n) {
      const i = await this.popupHitTest(r), s = i.results, o = i.mapPoint, a = s.filter((c) => c.type === "graphic" && this._isValidPopupGraphic(c.graphic, n)), l = a.length ? a[0].mapPoint : null;
      return { clientGraphics: a.map((c) => c.graphic), queryArea: o, location: o || l };
    }
    _getFetchPopupLayerViews() {
      const r = [];
      return this.allLayerViews.forEach((n) => {
        this._isValidPopupLayerView(n) && r.push(n);
      }), this.graphicsView != null && this._isValidPopupLayerView(this.graphicsView) && r.push(this.graphicsView), r.reverse();
    }
    _isValidPopupLayerView(r) {
      return r != null && (!("layer" in r) || !r.suspended) && "fetchPopupFeatures" in r;
    }
    _graphicsPerFetchPopupLayerView(r, n) {
      const i = [], s = /* @__PURE__ */ new Map(), o = n.map((a) => {
        const l = [];
        return "layer" in a ? s.set(a.layer, l) : s.set(a.graphics, l), { layerView: a, graphics: l };
      });
      for (const a of r) {
        const l = s.get(a.layer) || s.get(a.sourceLayer) || null;
        l ? l.push(a) : i.push(a);
      }
      return { layerViewsAndGraphics: o, clientOnlyGraphics: i };
    }
  };
  return u([d({ cast(r) {
    return !r || xo(r) || typeof r == "object" && (r.open = (n) => ($b(se.getLogger(this), "view.popup is no longer created by default. view.popup.open() will stop working when the popup isn't created", { replacement: "Use view.openPopup() instead.", version: "4.27" }), this.openPopup(n)), r.close = () => ($b(se.getLogger(this), "view.popup is no longer created by default. view.popup.close() will stop working when the popup isn't created", { replacement: "Use view.closePopup() instead.", version: "4.27" }), this.closePopup())), r;
  } })], t.prototype, "popup", void 0), u([d()], t.prototype, "popupEnabled", void 0), t = u([E("geoscene.views.PopupView")], t), t;
}, CP = { milliseconds: 1, seconds: 1e3, minutes: 6e4, hours: 36e5, days: 864e5, weeks: 6048e5, months: 26784e5, years: 31536e6, decades: 31536e7, centuries: 31536e8 }, Lae = { milliseconds: { getter: "getMilliseconds", setter: "setMilliseconds", multiplier: 1 }, seconds: { getter: "getSeconds", setter: "setSeconds", multiplier: 1 }, minutes: { getter: "getMinutes", setter: "setMinutes", multiplier: 1 }, hours: { getter: "getHours", setter: "setHours", multiplier: 1 }, days: { getter: "getDate", setter: "setDate", multiplier: 1 }, weeks: { getter: "getDate", setter: "setDate", multiplier: 7 }, months: { getter: "getMonth", setter: "setMonth", multiplier: 1 }, years: { getter: "getFullYear", setter: "setFullYear", multiplier: 1 }, decades: { getter: "getFullYear", setter: "setFullYear", multiplier: 10 }, centuries: { getter: "getFullYear", setter: "setFullYear", multiplier: 100 } };
function Nae(e, t) {
  const r = new Date(e, t + 1, 1);
  return r.setDate(0), r.getDate();
}
function bd(e, t, r) {
  const n = new Date(e.getTime());
  if (t && r) {
    const i = Lae[r], { getter: s, setter: o, multiplier: a } = i;
    if (r === "months") {
      const l = Nae(n.getFullYear(), n.getMonth() + t);
      n.getDate() > l && n.setDate(l);
    }
    n[o](n[s]() + t * a);
  }
  return n;
}
function kP(e, t) {
  switch (t) {
    case "milliseconds":
      return new Date(e.getTime());
    case "seconds":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds());
    case "minutes":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes());
    case "hours":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours());
    case "days":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate());
    case "weeks":
      return new Date(e.getFullYear(), e.getMonth(), e.getDate() - e.getDay());
    case "months":
      return new Date(e.getFullYear(), e.getMonth(), 1);
    case "years":
      return new Date(e.getFullYear(), 0, 1);
    case "decades":
      return new Date(e.getFullYear() - e.getFullYear() % 10, 0, 1);
    case "centuries":
      return new Date(e.getFullYear() - e.getFullYear() % 100, 0, 1);
    default:
      return /* @__PURE__ */ new Date();
  }
}
function Fae(e, t, r) {
  return e === 0 ? 0 : e * CP[t] / CP[r];
}
var zs;
let Ti = zs = class extends re {
  static get allTime() {
    return AP;
  }
  static get empty() {
    return Dae;
  }
  constructor(e) {
    super(e), this.end = null, this.start = null;
  }
  readEnd(e, t) {
    return t.end != null ? new Date(t.end) : null;
  }
  writeEnd(e, t) {
    t.end = e ? e.getTime() : null;
  }
  get isAllTime() {
    return this.equals(zs.allTime);
  }
  get isEmpty() {
    return this.equals(zs.empty);
  }
  readStart(e, t) {
    return t.start != null ? new Date(t.start) : null;
  }
  writeStart(e, t) {
    t.start = e ? e.getTime() : null;
  }
  clone() {
    return new zs({ end: this.end, start: this.start });
  }
  equals(e) {
    if (!e)
      return !1;
    const t = this.start != null ? this.start.getTime() : this.start, r = this.end != null ? this.end.getTime() : this.end, n = e.start != null ? e.start.getTime() : e.start, i = e.end != null ? e.end.getTime() : e.end;
    return t === n && r === i;
  }
  expandTo(e) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const t = td(this.start, (n) => kP(n, e)), r = td(this.end, (n) => {
      const i = kP(n, e);
      return n.getTime() === i.getTime() ? i : bd(i, 1, e);
    });
    return new zs({ start: t, end: r });
  }
  intersection(e) {
    var a, l, c, h;
    if (!e)
      return this.clone();
    if (this.isEmpty || e.isEmpty)
      return zs.empty;
    if (this.isAllTime)
      return e.clone();
    if (e.isAllTime)
      return this.clone();
    const t = ((a = this.start) == null ? void 0 : a.getTime()) ?? -1 / 0, r = ((l = this.end) == null ? void 0 : l.getTime()) ?? 1 / 0, n = ((c = e.start) == null ? void 0 : c.getTime()) ?? -1 / 0, i = ((h = e.end) == null ? void 0 : h.getTime()) ?? 1 / 0;
    let s, o;
    if (n >= t && n <= r ? s = n : t >= n && t <= i && (s = t), r >= n && r <= i ? o = r : i >= t && i <= r && (o = i), s != null && o != null && !isNaN(s) && !isNaN(o)) {
      const f = new zs();
      return f.start = s === -1 / 0 ? null : new Date(s), f.end = o === 1 / 0 ? null : new Date(o), f;
    }
    return zs.empty;
  }
  offset(e, t) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const r = new zs(), { start: n, end: i } = this;
    return n != null && (r.start = bd(n, e, t)), i != null && (r.end = bd(i, e, t)), r;
  }
  union(e) {
    if (!e || e.isEmpty)
      return this.clone();
    if (this.isEmpty)
      return e.clone();
    if (this.isAllTime || e.isAllTime)
      return AP.clone();
    const t = this.start != null && e.start != null ? new Date(Math.min(this.start.getTime(), e.start.getTime())) : null, r = this.end != null && e.end != null ? new Date(Math.max(this.end.getTime(), e.end.getTime())) : null;
    return new zs({ start: t, end: r });
  }
};
u([d({ type: Date, json: { write: { allowNull: !0 } } })], Ti.prototype, "end", void 0), u([ce("end")], Ti.prototype, "readEnd", null), u([ge("end")], Ti.prototype, "writeEnd", null), u([d({ readOnly: !0, json: { read: !1 } })], Ti.prototype, "isAllTime", null), u([d({ readOnly: !0, json: { read: !1 } })], Ti.prototype, "isEmpty", null), u([d({ type: Date, json: { write: { allowNull: !0 } } })], Ti.prototype, "start", void 0), u([ce("start")], Ti.prototype, "readStart", null), u([ge("start")], Ti.prototype, "writeStart", null), Ti = zs = u([E("geoscene.TimeExtent")], Ti);
const AP = new Ti(), Dae = new Ti({ start: void 0, end: void 0 }), ha = Ti, M_ = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this._handles = new ca(), this._updatingHandles = new _h();
    }
    destroy() {
      this.destroyed || (this._handles.destroy(), this._updatingHandles.destroy());
    }
    get handles() {
      return this._handles;
    }
    get updatingHandles() {
      return this._updatingHandles;
    }
  };
  return u([d({ readOnly: !0 })], t.prototype, "handles", null), u([d({ readOnly: !0 })], t.prototype, "updatingHandles", null), t = u([E("geoscene.core.HandleOwner")], t), t;
};
let Xb = class extends M_(Ae) {
};
Xb = u([E("geoscene.core.HandleOwner")], Xb);
let xy = class extends M_(je) {
  constructor(t) {
    super(t), this.handles.add([this.on("before-add", (r) => {
      r.item == null && r.preventDefault();
    }), this.on("after-add", (r) => this._own(r.item)), this.on("after-remove", (r) => this._release(r.item))]);
  }
  get owner() {
    return this._get("owner");
  }
  set owner(t) {
    t !== this._get("owner") && (this._releaseAll(), this._set("owner", t), this._ownAll());
  }
  _ownAll() {
    for (const t of this.items)
      this._own(t);
  }
  _releaseAll() {
    for (const t of this.items)
      this._release(t);
  }
  _createNewInstance(t) {
    return this.itemType ? new (je.ofType(this.itemType.Type))(t) : new je(t);
  }
};
function DT(e, t) {
  return { type: e, cast: GF, set(r) {
    const n = Ed(r, this._get(t), e);
    n.owner = this, this._set(t, n);
  } };
}
u([d()], xy.prototype, "owner", null), xy = u([E("geoscene.core.support.OwningCollection")], xy);
var Dm;
const ew = Mn()({ orthometric: "gravity-related-height", gravity_related_height: "gravity-related-height", ellipsoidal: "ellipsoidal" }), L9 = ew.jsonValues.slice();
ZH(L9, "orthometric");
const Ty = Mn()({ meter: "meters", foot: "feet", "us-foot": "us-feet", "clarke-foot": "clarke-feet", "clarke-yard": "clarke-yards", "clarke-link": "clarke-links", "sears-yard": "sears-yards", "sears-foot": "sears-feet", "sears-chain": "sears-chains", "benoit-1895-b-chain": "benoit-1895-b-chains", "indian-yard": "indian-yards", "indian-1937-yard": "indian-1937-yards", "gold-coast-foot": "gold-coast-feet", "sears-1922-truncated-chain": "sears-1922-truncated-chains", "50-kilometers": "50-kilometers", "150-kilometers": "150-kilometers" });
let Us = Dm = class extends re {
  constructor(e) {
    super(e), this.heightModel = "gravity-related-height", this.heightUnit = "meters", this.vertCRS = null;
  }
  writeHeightModel(e, t, r) {
    return ew.write(e, t, r);
  }
  readHeightModel(e, t, r) {
    return ew.read(e) || (r && r.messages && r.messages.push(jae(e, { context: r })), null);
  }
  readHeightUnit(e, t, r) {
    return Ty.read(e) || (r && r.messages && r.messages.push(PP(e, { context: r })), null);
  }
  readHeightUnitService(e, t, r) {
    return y6(e) || Ty.read(e) || (r && r.messages && r.messages.push(PP(e, { context: r })), null);
  }
  readVertCRS(e, t) {
    return t.vertCRS || t.ellipsoid || t.geoid;
  }
  clone() {
    return new Dm({ heightModel: this.heightModel, heightUnit: this.heightUnit, vertCRS: this.vertCRS });
  }
  equals(e) {
    return !!e && (this === e || this.heightModel === e.heightModel && this.heightUnit === e.heightUnit && this.vertCRS === e.vertCRS);
  }
  static deriveUnitFromSR(e, t) {
    const r = XZ(t);
    return new Dm({ heightModel: e.heightModel, heightUnit: r, vertCRS: e.vertCRS });
  }
  write(e, t) {
    return t = { origin: "web-scene", ...t }, super.write(e, t);
  }
  static fromJSON(e) {
    if (!e)
      return null;
    const t = new Dm();
    return t.read(e, { origin: "web-scene" }), t;
  }
};
function PP(e, t) {
  return new bs("height-unit:unsupported", `Height unit of value '${e}' is not supported`, t);
}
function jae(e, t) {
  return new bs("height-model:unsupported", `Height model of value '${e}' is not supported`, t);
}
u([d({ type: ew.apiValues, constructOnly: !0, json: { origins: { "web-scene": { type: L9, default: "ellipsoidal" } } } })], Us.prototype, "heightModel", void 0), u([ge("web-scene", "heightModel")], Us.prototype, "writeHeightModel", null), u([ce(["web-scene", "service"], "heightModel")], Us.prototype, "readHeightModel", null), u([d({ type: Ty.apiValues, constructOnly: !0, json: { origins: { "web-scene": { type: Ty.jsonValues, write: Ty.write } } } })], Us.prototype, "heightUnit", void 0), u([ce("web-scene", "heightUnit")], Us.prototype, "readHeightUnit", null), u([ce("service", "heightUnit")], Us.prototype, "readHeightUnitService", null), u([d({ type: String, constructOnly: !0, json: { origins: { "web-scene": { write: !0 } } } })], Us.prototype, "vertCRS", void 0), u([ce("service", "vertCRS", ["vertCRS", "ellipsoid", "geoid"])], Us.prototype, "readVertCRS", null), Us = Dm = u([E("geoscene.geometry.HeightModelInfo")], Us);
const O_ = Us;
let tw = class extends xy {
  constructor(t) {
    super(t), this.handles.add(this.on("before-add", (r) => {
      r.item != null && r.item.parent === this.owner && (se.getLogger(this).warn("Analysis inside the collection must be unique. Not adding this element again."), r.preventDefault());
    }));
  }
  _own(t) {
    t.parent = this.owner;
  }
  _release(t) {
    t.parent = null;
  }
};
tw = u([E("geoscene.support.AnalysesCollection")], tw);
let wd = class extends xy {
  _own(t) {
    t.layer && "remove" in t.layer && t.layer !== this.owner && t.layer.remove(t), t.layer = this.owner;
  }
  _release(t) {
    t.layer === this.owner && (t.layer = null);
  }
};
u([H3({ Type: vr, ensureType: br(vr) })], wd.prototype, "itemType", void 0), wd = u([E("geoscene.support.GraphicsCollection")], wd);
const RP = /* @__PURE__ */ new Map([["AUS Central Standard Time", "Australia/Darwin"], ["AUS Eastern Standard Time", "Australia/Sydney"], ["Afghanistan Standard Time", "Asia/Kabul"], ["Alaskan Standard Time", "America/Anchorage"], ["Aleutian Standard Time", "America/Adak"], ["Altai Standard Time", "Asia/Barnaul"], ["Arab Standard Time", "Asia/Riyadh"], ["Arabian Standard Time", "Asia/Dubai"], ["Arabic Standard Time", "Asia/Baghdad"], ["Argentina Standard Time", "America/Buenos_Aires"], ["Astrakhan Standard Time", "Europe/Astrakhan"], ["Atlantic Standard Time", "America/Halifax"], ["Aus Central W. Standard Time", "Australia/Eucla"], ["Azerbaijan Standard Time", "Asia/Baku"], ["Azores Standard Time", "Atlantic/Azores"], ["Bahia Standard Time", "America/Bahia"], ["Bangladesh Standard Time", "Asia/Dhaka"], ["Belarus Standard Time", "Europe/Minsk"], ["Bougainville Standard Time", "Pacific/Bougainville"], ["Canada Central Standard Time", "America/Regina"], ["Cape Verde Standard Time", "Atlantic/Cape_Verde"], ["Caucasus Standard Time", "Asia/Yerevan"], ["Cen. Australia Standard Time", "Australia/Adelaide"], ["Central America Standard Time", "America/Guatemala"], ["Central Asia Standard Time", "Asia/Almaty"], ["Central Brazilian Standard Time", "America/Cuiaba"], ["Central Europe Standard Time", "Europe/Budapest"], ["Central European Standard Time", "Europe/Warsaw"], ["Central Pacific Standard Time", "Pacific/Guadalcanal"], ["Central Standard Time", "America/Chicago"], ["Central Standard Time (Mexico)", "America/Mexico_City"], ["Chatham Islands Standard Time", "Pacific/Chatham"], ["China Standard Time", "Asia/Shanghai"], ["Cuba Standard Time", "America/Havana"], ["Dateline Standard Time", "Etc/GMT+12"], ["E. Africa Standard Time", "Africa/Nairobi"], ["E. Australia Standard Time", "Australia/Brisbane"], ["E. Europe Standard Time", "Europe/Chisinau"], ["E. South America Standard Time", "America/Sao_Paulo"], ["Easter Island Standard Time", "Pacific/Easter"], ["Eastern Standard Time", "America/New_York"], ["Eastern Standard Time (Mexico)", "America/Cancun"], ["Egypt Standard Time", "Africa/Cairo"], ["Ekaterinburg Standard Time", "Asia/Yekaterinburg"], ["FLE Standard Time", "Europe/Kiev"], ["Fiji Standard Time", "Pacific/Fiji"], ["GMT Standard Time", "Europe/London"], ["GTB Standard Time", "Europe/Bucharest"], ["Georgian Standard Time", "Asia/Tbilisi"], ["Greenland Standard Time", "America/Godthab"], ["Greenwich Standard Time", "Atlantic/Reykjavik"], ["Haiti Standard Time", "America/Port-au-Prince"], ["Hawaiian Standard Time", "Pacific/Honolulu"], ["India Standard Time", "Asia/Calcutta"], ["Iran Standard Time", "Asia/Tehran"], ["Israel Standard Time", "Asia/Jerusalem"], ["Jordan Standard Time", "Asia/Amman"], ["Kaliningrad Standard Time", "Europe/Kaliningrad"], ["Korea Standard Time", "Asia/Seoul"], ["Libya Standard Time", "Africa/Tripoli"], ["Line Islands Standard Time", "Pacific/Kiritimati"], ["Lord Howe Standard Time", "Australia/Lord_Howe"], ["Magadan Standard Time", "Asia/Magadan"], ["Magallanes Standard Time", "America/Punta_Arenas"], ["Marquesas Standard Time", "Pacific/Marquesas"], ["Mauritius Standard Time", "Indian/Mauritius"], ["Middle East Standard Time", "Asia/Beirut"], ["Montevideo Standard Time", "America/Montevideo"], ["Morocco Standard Time", "Africa/Casablanca"], ["Mountain Standard Time", "America/Denver"], ["Mountain Standard Time (Mexico)", "America/Mazatlan"], ["Myanmar Standard Time", "Asia/Rangoon"], ["N. Central Asia Standard Time", "Asia/Novosibirsk"], ["Namibia Standard Time", "Africa/Windhoek"], ["Nepal Standard Time", "Asia/Katmandu"], ["New Zealand Standard Time", "Pacific/Auckland"], ["Newfoundland Standard Time", "America/St_Johns"], ["Norfolk Standard Time", "Pacific/Norfolk"], ["North Asia East Standard Time", "Asia/Irkutsk"], ["North Asia Standard Time", "Asia/Krasnoyarsk"], ["North Korea Standard Time", "Asia/Pyongyang"], ["Omsk Standard Time", "Asia/Omsk"], ["Pacific SA Standard Time", "America/Santiago"], ["Pacific Standard Time", "America/Los_Angeles"], ["Pacific Standard Time (Mexico)", "America/Tijuana"], ["Pakistan Standard Time", "Asia/Karachi"], ["Paraguay Standard Time", "America/Asuncion"], ["Qyzylorda Standard Time", "Asia/Qyzylorda"], ["Romance Standard Time", "Europe/Paris"], ["Russia Time Zone 10", "Asia/Srednekolymsk"], ["Russia Time Zone 11", "Asia/Kamchatka"], ["Russia Time Zone 3", "Europe/Samara"], ["Russian Standard Time", "Europe/Moscow"], ["SA Eastern Standard Time", "America/Cayenne"], ["SA Pacific Standard Time", "America/Bogota"], ["SA Western Standard Time", "America/La_Paz"], ["SE Asia Standard Time", "Asia/Bangkok"], ["Saint Pierre Standard Time", "America/Miquelon"], ["Sakhalin Standard Time", "Asia/Sakhalin"], ["Samoa Standard Time", "Pacific/Apia"], ["Sao Tome Standard Time", "Africa/Sao_Tome"], ["Saratov Standard Time", "Europe/Saratov"], ["Singapore Standard Time", "Asia/Singapore"], ["South Africa Standard Time", "Africa/Johannesburg"], ["South Sudan Standard Time", "Africa/Juba"], ["Sri Lanka Standard Time", "Asia/Colombo"], ["Sudan Standard Time", "Africa/Khartoum"], ["Syria Standard Time", "Asia/Damascus"], ["Taipei Standard Time", "Asia/Taipei"], ["Tasmania Standard Time", "Australia/Hobart"], ["Tocantins Standard Time", "America/Araguaina"], ["Tokyo Standard Time", "Asia/Tokyo"], ["Tomsk Standard Time", "Asia/Tomsk"], ["Tonga Standard Time", "Pacific/Tongatapu"], ["Transbaikal Standard Time", "Asia/Chita"], ["Turkey Standard Time", "Europe/Istanbul"], ["Turks And Caicos Standard Time", "America/Grand_Turk"], ["US Eastern Standard Time", "America/Indianapolis"], ["US Mountain Standard Time", "America/Phoenix"], ["UTC", "Etc/GMT"], ["UTC+01", "Etc/GMT-1"], ["UTC+02", "Etc/GMT-2"], ["UTC+03", "Etc/GMT-3"], ["UTC+04", "Etc/GMT-4"], ["UTC+05", "Etc/GMT-5"], ["UTC+06", "Etc/GMT-6"], ["UTC+07", "Etc/GMT-7"], ["UTC+08", "Etc/GMT-8"], ["UTC+09", "Etc/GMT-9"], ["UTC+10", "Etc/GMT-10"], ["UTC+11", "Etc/GMT-11"], ["UTC+12", "Etc/GMT-12"], ["UTC+13", "Etc/GMT-13"], ["UTC+14", "Etc/GMT-14"], ["UTC-01", "Etc/GMT+1"], ["UTC-02", "Etc/GMT+2"], ["UTC-03", "Etc/GMT+3"], ["UTC-04", "Etc/GMT+4"], ["UTC-05", "Etc/GMT+5"], ["UTC-06", "Etc/GMT+6"], ["UTC-07", "Etc/GMT+7"], ["UTC-08", "Etc/GMT+8"], ["UTC-09", "Etc/GMT+9"], ["UTC-10", "Etc/GMT+10"], ["UTC-11", "Etc/GMT+11"], ["UTC-12", "Etc/GMT+12"], ["Ulaanbaatar Standard Time", "Asia/Ulaanbaatar"], ["Venezuela Standard Time", "America/Caracas"], ["Vladivostok Standard Time", "Asia/Vladivostok"], ["Volgograd Standard Time", "Europe/Volgograd"], ["W. Australia Standard Time", "Australia/Perth"], ["W. Central Africa Standard Time", "Africa/Lagos"], ["W. Europe Standard Time", "Europe/Berlin"], ["W. Mongolia Standard Time", "Asia/Hovd"], ["West Asia Standard Time", "Asia/Tashkent"], ["West Bank Standard Time", "Asia/Hebron"], ["West Pacific Standard Time", "Pacific/Port_Moresby"], ["Yakutsk Standard Time", "Asia/Yakutsk"], ["Yukon Standard Time", "America/Whitehorse"]]);
function Vae(e, t = "system") {
  if (!e || !RP.has(e.timeZone))
    return t;
  const r = RP.get(e.timeZone);
  return Uae(e.timeZone) || e.respectsDaylightSaving ? r : zae(r);
}
function zae(e) {
  const t = We.local().setZone(e), r = Math.min(t.set({ month: 1, day: 1 }).offset, t.set({ month: 5 }).offset);
  return r === 0 ? "Etc/UTC" : `Etc/GMT${Tn.instance(-r).formatOffset(0, "narrow")}`;
}
function Uae(e) {
  return e.startsWith("UTC");
}
let Zl = class extends Rt(re) {
  constructor(t) {
    super(t), this.legacy = null, this.timeZone = "system";
  }
  readLegacy(t, r) {
    const { timeZone: n, respectsDaylightSaving: i } = r;
    return { timeZone: n, respectsDaylightSaving: i };
  }
  readTimeZone(t, r) {
    return "timeZoneIANA" in r ? r.timeZoneIANA : Vae(r);
  }
  writeTimeZone(t, r) {
    r.timeZoneIANA = t;
  }
  equals(t) {
    return t != null && this.timeZone != null && t.timeZone != null && this.timeZone === t.timeZone;
  }
};
u([d()], Zl.prototype, "legacy", void 0), u([ce("legacy", ["timeZone"])], Zl.prototype, "readLegacy", null), u([d({ type: String, nonNullable: !0 })], Zl.prototype, "timeZone", void 0), u([ce("timeZone", ["timeZone", "timeZoneIANA", "respectsDaylightSaving"])], Zl.prototype, "readTimeZone", null), u([ge("timeZone")], Zl.prototype, "writeTimeZone", null), Zl = u([E("geoscene.time.TimeReference")], Zl);
const Uh = Zl;
let Kl = class extends Ae {
  constructor(t) {
    super(t), this.view = null, this.baseLayerViews = new je(), this.referenceLayerViews = new je(), this._loadingHandle = ze(() => {
      var r, n;
      return (n = (r = this.view) == null ? void 0 : r.map) == null ? void 0 : n.basemap;
    }, (r) => {
      r && r.load().catch(() => {
      });
    }, ln);
  }
  destroy() {
    this._set("view", null), this._loadingHandle && (this._loadingHandle.remove(), this._loadingHandle = null);
    for (const t of this.baseLayerViews)
      t.destroy();
    this.baseLayerViews.length = 0;
    for (const t of this.referenceLayerViews)
      t.destroy();
    this.referenceLayerViews.length = 0;
  }
  get suspended() {
    return !this.view || this.view.suspended;
  }
  get updating() {
    var r, n;
    if (this.view && this.view.suspended)
      return !1;
    const t = (n = (r = this.view) == null ? void 0 : r.map) == null ? void 0 : n.basemap;
    return !!t && !!t.loaded && (this.baseLayerViews.some((i) => i.updating) || this.referenceLayerViews.some((i) => i.updating));
  }
};
u([d({ constructOnly: !0 })], Kl.prototype, "view", void 0), u([d({ readOnly: !0 })], Kl.prototype, "baseLayerViews", void 0), u([d({ readOnly: !0 })], Kl.prototype, "referenceLayerViews", void 0), u([d({ readOnly: !0 })], Kl.prototype, "suspended", null), u([d({ type: Boolean, readOnly: !0 })], Kl.prototype, "updating", null), Kl = u([E("geoscene.views.BasemapView")], Kl);
function Bae(e) {
  return "tryRecycleWith" in e;
}
let qae = class {
  constructor(t, r, n) {
    this.layer = t, this.view = r, this.layerViewImporter = n, this._controller = new AbortController(), this._deferred = vs(), this._started = !1, this.done = !1, this.promise = this._deferred.promise, fs(this._controller.signal, () => {
      const i = new G("cancelled:layerview-create", "layerview creation cancelled", { layer: t });
      this._deferred.reject(i);
    });
  }
  tryRecycle(t) {
    if (!this.done || !this.layerView || !Bae(this.layerView))
      return null;
    const r = this.layer.type, n = this._controller.signal;
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (s.type !== r)
        continue;
      const o = this.layerView.tryRecycleWith(s, { signal: n });
      if (o) {
        t.splice(i, 1), this.layer = s;
        const a = this.layerView, l = a.view;
        return this.promise = Promise.race([o.then(() => (lr(this._controller.signal), s.emit("layerview-destroy", { view: l, layerView: a }), l.emit("layerview-destroy", { view: l, layerView: a }), s.emit("layerview-create", { view: l, layerView: a }), l.emit("layerview-create", { view: l, layerView: a }), a)), new Promise((c, h) => fs(this._controller.signal, () => h(rr())))]), this.promise;
      }
    }
    return null;
  }
  destroy() {
    this._controller.abort();
    const { layerView: t } = this;
    if (t) {
      const { layer: r, view: n } = this;
      r.emit("layerview-destroy", { view: n, layerView: t }), n.emit("layerview-destroy", { layer: r, layerView: t });
    }
    this.done = !0, this.layer = null, this.layerView = null, this.view = null, this.layerViewImporter = null, this._map = null;
  }
  async start() {
    var i, s, o;
    if (this._started)
      return;
    this._started = !0;
    const { _controller: { signal: t }, layer: r, view: n } = this;
    this._map = n.map;
    try {
      let a, l;
      if (await r.load({ signal: t }), "prefetchResources" in r && await ((i = r.prefetchResources) == null ? void 0 : i.call(r, { signal: t })), Hae(r))
        a = await r.createLayerView(n, { signal: t });
      else {
        if (!this.layerViewImporter.hasLayerViewModule(r))
          throw new G("layer:view-not-supported", "No layerview implementation was found");
        const f = await this.layerViewImporter.importLayerView(r);
        lr(t), a = "default" in f ? new f.default({ layer: r, view: n }) : new f({ layer: r, view: n });
      }
      const c = () => {
        l = tr(l), a.destroyed || a.destroy(), a.layer = null, a.parent = null, a.view = null, this.done = !0;
      };
      l = fs(t, c), lr(t);
      try {
        await a.when();
      } catch (f) {
        throw c(), f;
      }
      if (!((o = (s = this._map) == null ? void 0 : s.allLayers) == null ? void 0 : o.includes(r)))
        return c(), void this._deferred.reject(new G("view:no-layerview-for-layer", "The layer has been removed from the map", { layer: r }));
      this.layerView = a, r.emit("layerview-create", { view: n, layerView: a }), n.emit("layerview-create", { layer: r, layerView: a }), this.done = !0, this._deferred.resolve(a);
    } catch (a) {
      r.emit("layerview-create-error", { view: n, error: a }), n.emit("layerview-create-error", { layer: r, error: a }), this.done = !0, this._deferred.reject(new G("layerview:create-error", "layerview creation failed", { layer: r, error: a }));
    }
  }
}, ts = class extends Ae {
  constructor(t) {
    super(t), this._layerLayerViewInfoMap = /* @__PURE__ */ new Map(), this._recyclingInfoMap = /* @__PURE__ */ new Map(), this._watchUpdatingTracking = new _h(), this.supportsGround = !0, this._preloadLayerViewModules = () => {
      var n;
      const r = (n = this.view.map) == null ? void 0 : n.allLayers;
      if (r)
        for (const i of r)
          this.layerViewImporter.hasLayerViewModule(i) && this.layerViewImporter.importLayerView(i);
    }, this._reschedule = () => this.destroyed ? Promise.reject() : (this._workPromise == null && (this._workPromise = vs(), this._workPromise.promise.catch(() => {
    })), this.removeHandles("reschedule"), this.addHandles(nf(this._doWork), "reschedule"), this._workPromise.promise), this._doWork = () => {
      var l, c, h;
      if (this.destroyed)
        return;
      const r = this.view.map;
      if (this._map !== r && (this.clear(), this._map = r), this._workPromise == null)
        return void this.notifyChange("updating");
      this.removeHandles("reschedule"), this.removeHandles("collection-change");
      const n = /* @__PURE__ */ new Set(), i = [], s = this.view.ready, o = (f) => {
        if (f != null) {
          for (const m of f)
            if (m) {
              n.add(m);
              const y = this._layerLayerViewInfoMap.get(m);
              y && s ? y.start() : y || this._recyclingInfoMap.has(m) || i.push(m), "layers" in m && m.layers && o(m.layers);
            }
        }
      };
      for (const f of this._rootCollectionNames)
        o(this.get(f));
      for (const [f, m] of this._layerLayerViewInfoMap)
        if (!n.has(f)) {
          this._layerLayerViewInfoMap.delete(m.layer);
          const y = m.tryRecycle(i);
          y ? (this.notifyChange("updating"), this._recyclingInfoMap.set(m.layer, m), y.then(() => {
            this.notifyChange("updating"), this._recyclingInfoMap.delete(m.layer), this._layerLayerViewInfoMap.set(m.layer, m), this._reschedule();
          }).catch(() => {
            this.notifyChange("updating"), this._recyclingInfoMap.delete(m.layer), m.destroy(), this._reschedule();
          })) : m.destroy();
        }
      for (const [f, m] of this._recyclingInfoMap)
        n.has(f) || (this.notifyChange("updating"), this._recyclingInfoMap.delete(m.layer), m.destroy());
      for (const f of i)
        this._createLayerView(f);
      this._refreshCollections();
      const a = [(l = r == null ? void 0 : r.ground) == null ? void 0 : l.layers, (c = r == null ? void 0 : r.basemap) == null ? void 0 : c.baseLayers, (h = r == null ? void 0 : r.basemap) == null ? void 0 : h.referenceLayers, r == null ? void 0 : r.layers].filter((f) => !!f);
      n.forEach((f) => "layers" in f && a.push(f.layers)), this.addHandles(a.map((f) => this._watchUpdatingTracking.addOnCollectionChange(() => f, this._reschedule)), "collection-change"), this._workPromise.resolve(), this._workPromise = null;
    };
  }
  initialize() {
    this.own([rg(() => {
      var t, r;
      return (r = (t = this.view) == null ? void 0 : t.map) == null ? void 0 : r.allLayers;
    }, "change", this._preloadLayerViewModules, { onListenerAdd: this._preloadLayerViewModules }), ze(() => {
      const t = this.view, r = t == null ? void 0 : t.map;
      return [r == null ? void 0 : r.basemap, r == null ? void 0 : r.ground, r == null ? void 0 : r.layers, t == null ? void 0 : t.ready];
    }, () => this._reschedule(), cu)]), this._preloadLayerViewModules(), this._reschedule();
  }
  destroy() {
    this.clear(), V2(this._recyclingInfoMap), V2(this._layerLayerViewInfoMap), this._watchUpdatingTracking.destroy(), this._map = null, this._workPromise != null && (this._workPromise.reject(rr()), this._workPromise = null);
  }
  get _layersToLayerViews() {
    const t = [["view.map.basemap.baseLayers", "view.basemapView.baseLayerViews"], ["view.map.layers", "view.layerViews"], ["view.map.basemap.referenceLayers", "view.basemapView.referenceLayerViews"]];
    return this.supportsGround && t.push(["view.map.ground.layers", "view.groundView.layerViews"]), new Map(t);
  }
  get _rootCollectionNames() {
    return Array.from(this._layersToLayerViews.keys());
  }
  get updating() {
    return this._workPromise != null || this._watchUpdatingTracking.updating || Qw(this._layerLayerViewInfoMap, (t) => !t.done) || this._recyclingInfoMap.size > 0;
  }
  get updatingRemaining() {
    let t = 0;
    for (const r of this._layerLayerViewInfoMap.values())
      r.done || ++t;
    return t;
  }
  clear() {
    this.destroyed || (V2(this._layerLayerViewInfoMap), this._refreshCollections());
  }
  async whenLayerView(t) {
    if (await this._reschedule(), !this._layerLayerViewInfoMap.has(t)) {
      if (this._recyclingInfoMap.has(t))
        return this._recyclingInfoMap.get(t).promise;
      throw new G("view:no-layerview-for-layer", "No layerview has been found for the layer", { layer: t });
    }
    return this._layerLayerViewInfoMap.get(t).promise;
  }
  _refreshCollections() {
    for (const [t, r] of this._layersToLayerViews)
      this._populateLayerViewsOwners(this.get(t), this.get(r), this.view);
    this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  _populateLayerViewsOwners(t, r, n) {
    if (!t || !r)
      return void (r && r.removeAll());
    let i = 0;
    for (const s of t) {
      const o = this._layerLayerViewInfoMap.get(s);
      if (!o || !o.layerView)
        continue;
      const a = o.layerView;
      a.layer = s, a.parent = n, r.at(i) !== a && r.splice(i, 0, a), s.layers && this._populateLayerViewsOwners(s.layers, a.layerViews, a), i += 1;
    }
    i < r.length && r.splice(i, r.length);
  }
  _createLayerView(t) {
    t.load().catch(() => {
    }), this.layerViewImporter.hasLayerViewModule(t) && this.layerViewImporter.importLayerView(t);
    const r = new qae(t, this.view, this.layerViewImporter);
    r.promise.then(() => this._refreshCollections(), (n) => {
      n && (Fi(n) || n.name === "cancelled:layerview-create") || se.getLogger(this).error(`Failed to create layerview for layer title:'${t.title ?? "no title"}', id:'${t.id ?? "no id"}' of type '${t.type}'.`, { layer: t, error: n }), this._refreshCollections();
    }), this._layerLayerViewInfoMap.set(t, r), this.view.ready && r.start(), this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
};
u([d()], ts.prototype, "_workPromise", void 0), u([d({ readOnly: !0 })], ts.prototype, "_watchUpdatingTracking", void 0), u([d({ readOnly: !0 })], ts.prototype, "_layersToLayerViews", null), u([d({ readOnly: !0 })], ts.prototype, "_rootCollectionNames", null), u([d()], ts.prototype, "layerViewImporter", void 0), u([d()], ts.prototype, "supportsGround", void 0), u([d({ readOnly: !0 })], ts.prototype, "updating", null), u([d({ readOnly: !0 })], ts.prototype, "updatingRemaining", null), u([d({ constructOnly: !0 })], ts.prototype, "view", void 0), ts = u([E("geoscene.views.LayerViewManager")], ts);
const Gae = ts;
function Hae(e) {
  return "createLayerView" in e && e.createLayerView != null;
}
let bi = class extends Ae {
  constructor(t) {
    super(t), this.factor = 1.5, this.offset = Vn(0, 0), this.position = null, this.size = 120, this.maskUrl = null, this.maskEnabled = !0, this.overlayUrl = null, this.overlayEnabled = !0, this.visible = !0;
  }
  get version() {
    return this.commitProperty("factor"), this.commitProperty("offset"), this.commitProperty("position"), this.commitProperty("visible"), this.commitProperty("size"), this.commitProperty("maskUrl"), this.commitProperty("maskEnabled"), this.commitProperty("overlayUrl"), this.commitProperty("overlayEnabled"), (this._get("version") || 0) + 1;
  }
};
u([d({ type: Number })], bi.prototype, "factor", void 0), u([d({ nonNullable: !0 })], bi.prototype, "offset", void 0), u([d()], bi.prototype, "position", void 0), u([d({ type: Number, range: { min: 0 } })], bi.prototype, "size", void 0), u([d()], bi.prototype, "maskUrl", void 0), u([d()], bi.prototype, "maskEnabled", void 0), u([d()], bi.prototype, "overlayUrl", void 0), u([d()], bi.prototype, "overlayEnabled", void 0), u([d({ readOnly: !0 })], bi.prototype, "version", null), u([d({ type: Boolean })], bi.prototype, "visible", void 0), bi = u([E("geoscene.views.Magnifier")], bi);
const N9 = bi;
let Wae = class {
  constructor() {
    this._tasks = new Array(), this._running = Qb(!1);
  }
  get length() {
    return this._tasks.length;
  }
  get running() {
    return this._running.value;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(t) {
    for (; !t.done && this._process(t); )
      t.madeProgress();
  }
  push(t, r, n) {
    return this._running.value = !0, new Promise((i, s) => this._tasks.push(new LP(i, s, t, r, n)));
  }
  unshift(t, r, n) {
    return this._running.value = !0, new Promise((i, s) => this._tasks.unshift(new LP(i, s, t, r, n)));
  }
  _process(t) {
    var n;
    if (this._tasks.length === 0)
      return !1;
    const r = this._tasks.shift();
    try {
      const i = ho(r.signal);
      if (i && !r.abortCallback)
        r.reject(rr());
      else {
        const s = i ? (n = r.abortCallback) == null ? void 0 : n.call(r, rr()) : r.callback(t);
        pl(s) ? s.then(r.resolve, r.reject) : r.resolve(s);
      }
    } catch (i) {
      r.reject(i);
    }
    return this._running.value = this._tasks.length > 0, !0;
  }
  cancelAll() {
    const t = rr();
    for (const r of this._tasks)
      if (r.abortCallback) {
        const n = r.abortCallback(t);
        r.resolve(n);
      } else
        r.reject(t);
    this._tasks.length = 0, this._running.value = !1;
  }
}, LP = class {
  constructor(t, r, n, i = void 0, s = void 0) {
    this.resolve = t, this.reject = r, this.callback = n, this.signal = i, this.abortCallback = s;
  }
}, jm = class extends Ae {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = !1, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = !1;
  }
};
u([d()], jm.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), u([d()], jm.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), jm = u([E("geoscene.views.support.DebugFlags")], jm);
const Jae = new jm();
var xi;
(function(e) {
  e[e.ANIMATING = 0] = "ANIMATING", e[e.INTERACTING = 1] = "INTERACTING", e[e.IDLE = 2] = "IDLE";
})(xi || (xi = {}));
var jT, Ke;
(function(e) {
  e[e.YIELD = 1] = "YIELD";
})(jT || (jT = {})), function(e) {
  e.RESOURCE_CONTROLLER_IMMEDIATE = "immediate", e.RESOURCE_CONTROLLER = "schedule", e.SLIDE = "slide", e.STREAM_DATA_LOADER = "stream loader", e.ELEVATION_QUERY = "elevation query", e.TERRAIN_SURFACE = "terrain", e.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e.LOD_RENDERER = "LoD renderer", e.GRAPHICS_CORE = "Graphics3D", e.I3S_CONTROLLER = "I3S", e.POINT_CLOUD_LAYER = "point cloud", e.FEATURE_TILE_FETCHER = "feature fetcher", e.OVERLAY = "overlay", e.STAGE = "stage", e.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e.FILTER_VISIBILITY = "Graphics3D filter visibility", e.SCALE_VISIBILITY = "Graphics3D scale visibility", e.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e.POINT_OF_INTEREST_FREQUENT = "POI frequent", e.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e.LABELER = "labeler", e.FEATURE_QUERY_ENGINE = "feature query", e.FEATURE_TILE_TREE = "feature tile tree", e.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e.ELEVATION_ALIGNMENT = "elevation alignment", e.TEXT_TEXTURE_ATLAS = "text texture atlas", e.TEXTURE_UNLOAD = "texture unload", e.LINE_OF_SIGHT_TOOL = "line of sight tool", e.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e.ELEVATION_PROFILE = "elevation profile", e.SNAPPING = "snapping", e.SHADOW_ACCUMULATOR = "shadow accumulator", e.CLOUDS_GENERATOR = "clouds generator", e[e.NONE = 0] = "NONE", e[e.TEST_PRIO = 1] = "TEST_PRIO";
}(Ke || (Ke = {}));
const qo = 0, NP = /* @__PURE__ */ new Map([[Ke.RESOURCE_CONTROLLER_IMMEDIATE, qo], [Ke.RESOURCE_CONTROLLER, 4], [Ke.SLIDE, qo], [Ke.STREAM_DATA_LOADER, qo], [Ke.ELEVATION_QUERY, qo], [Ke.TERRAIN_SURFACE, 1], [Ke.SURFACE_GEOMETRY_UPDATES, 1], [Ke.LOD_RENDERER, 2], [Ke.GRAPHICS_CORE, 2], [Ke.I3S_CONTROLLER, 2], [Ke.POINT_CLOUD_LAYER, 2], [Ke.FEATURE_TILE_FETCHER, 2], [Ke.OVERLAY, 4], [Ke.STAGE, 4], [Ke.GRAPHICS_DECONFLICTOR, 4], [Ke.FILTER_VISIBILITY, 4], [Ke.SCALE_VISIBILITY, 4], [Ke.FRUSTUM_VISIBILITY, 4], [Ke.CLOUDS_GENERATOR, 4], [Ke.POINT_OF_INTEREST_FREQUENT, 6], [Ke.POINT_OF_INTEREST_INFREQUENT, 30], [Ke.LABELER, 8], [Ke.FEATURE_QUERY_ENGINE, 8], [Ke.FEATURE_TILE_TREE, 16], [Ke.FEATURE_TILE_TREE_ACTIVE, qo], [Ke.ELEVATION_ALIGNMENT, 12], [Ke.TEXT_TEXTURE_ATLAS, 12], [Ke.TEXTURE_UNLOAD, 12], [Ke.LINE_OF_SIGHT_TOOL, 16], [Ke.LINE_OF_SIGHT_TOOL_INTERACTIVE, qo], [Ke.SNAPPING, qo], [Ke.SHADOW_ACCUMULATOR, 30]]);
function FP(e) {
  return NP.has(e) ? NP.get(e) : typeof e == "number" ? e : 1;
}
const DP = 6.5, jP = 1, Zae = 30, VP = 1e3 / 30, zP = 100, UP = 0.9;
var VT, ec;
(function(e) {
  class t {
    get updating() {
      return this._updating.value;
    }
    _updatingChanged() {
      this._updating.value = this._tasks.some((s) => s.needsUpdate);
    }
    constructor() {
      this._updating = Qb(!0), this._microTaskQueued = !1, this._frameNumber = 0, this.performanceInfo = { total: new cy("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new n(), this._state = xi.INTERACTING, this._tasks = new md(), this._runQueue = new md(), this._load = 0, this._idleStateCallbacks = new md(), this._idleUpdatesStartFired = !1, this._forceTask = !1, this._debug = !1, this._debugHandle = ze(() => Jae.SCHEDULER_LOG_SLOW_TASKS, (o) => this._debug = o, ln);
      for (const o of Object.keys(Ke))
        this.performanceInfo.tasks.set(Ke[o], new cy(Ke[o]));
      const s = this;
      this._test = { FRAME_SAFETY_BUDGET: DP, INTERACTING_BUDGET: VP, IDLE_BUDGET: zP, get availableBudget() {
        return s._budget.budget;
      }, usedBudget: 0, getBudget: () => s._budget, setBudget: (o) => s._budget = o, updateTask: (o) => this._updateTask(o), getState: (o) => this._getState(o), getRuntime: (o) => this._getRuntime(o), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    destroy() {
      this._tasks.toArray().forEach((s) => s.remove()), this._tasks.clear(), tr(this._debugHandle), this._microTaskQueued = !1, this._updatingChanged();
    }
    taskRunningChanged(s) {
      this._updatingChanged(), s && this._budget.remaining > 0 && !this._microTaskQueued && (this._microTaskQueued = !0, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = !1, this._budget.remaining > 0 && this._schedule() && this.frame());
      }));
    }
    registerTask(s, o) {
      const a = FP(s), l = new r(this, s, o, a);
      return this._tasks.push(l), this._updatingChanged(), this.performanceInfo.tasks.has(s) || this.performanceInfo.tasks.set(s, new cy(s)), l;
    }
    registerIdleStateCallbacks(s, o) {
      const a = { idleBegin: s, idleEnd: o };
      this._idleStateCallbacks.push(a), this.state === xi.IDLE && this._idleUpdatesStartFired && a.idleBegin();
      const l = this;
      return { remove: () => this._removeIdleStateCallbacks(a), set idleBegin(c) {
        l._idleUpdatesStartFired && (a.idleEnd(), l._state === xi.IDLE && c()), a.idleBegin = c;
      }, set idleEnd(c) {
        a.idleEnd = c;
      } };
    }
    get load() {
      return this._load;
    }
    set state(s) {
      this._state !== s && (this._state = s, this.state !== xi.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = !1, this._idleStateCallbacks.forAll((o) => o.idleEnd())));
    }
    get state() {
      return this._state;
    }
    updateBudget(s) {
      this._test.usedBudget = 0, ++this._frameNumber;
      let o = DP, a = s.frameDuration, l = jP;
      switch (this.state) {
        case xi.IDLE:
          o = 0, a = Math.max(zP, s.frameDuration), l = Zae;
          break;
        case xi.INTERACTING:
          a = Math.max(VP, s.frameDuration);
        case xi.ANIMATING:
      }
      return a = a - s.elapsedFrameTime - o, this.state !== xi.IDLE && a < jP && !this._forceTask ? (this._forceTask = !0, !1) : (a = Math.max(a, l), this._budget.reset(a, this.state), this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = !1, this._microTaskQueued = !1, this.state) {
        case xi.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = !0, this._idleStateCallbacks.forAll((s) => s.idleBegin())), this._runIdle();
          break;
        case xi.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(0, this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(s) {
      this._idleUpdatesStartFired && s.idleEnd(), this._idleStateCallbacks.removeUnordered(s);
    }
    removeTask(s) {
      this._tasks.removeUnordered(s), this._runQueue.removeUnordered(s), this._updatingChanged();
    }
    _updateTask(s) {
      this._tasks.forAll((o) => {
        o.name === s && o.setPriority(s);
      });
    }
    _getState(s) {
      if (this._runQueue.some((a) => a.name === s))
        return ec.SCHEDULED;
      let o = ec.IDLE;
      return this._tasks.forAll((a) => {
        a.name === s && a.needsUpdate && (a.schedulePriority <= 1 ? o = ec.READY : o !== ec.READY && (o = ec.WAITING));
      }), o;
    }
    _getRuntime(s) {
      let o = 0;
      return this._tasks.forAll((a) => {
        a.name === s && (o += a.runtime);
      }), o;
    }
    _resetRuntimes() {
      this._tasks.forAll((s) => s.runtime = 0);
    }
    _getRunning() {
      const s = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((a) => {
        a.needsUpdate && s.set(a.name, (s.get(a.name) || 0) + 1);
      }), s.size === 0)
        return null;
      let o = "";
      return s.forEach((a, l) => {
        o += a > 1 ? ` ${a}x ${l}` : ` ${l}`;
      }), o;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const s = this._tasks.reduce((o, a) => a.needsUpdate ? ++o : o, 0);
      this._load = this._load * UP + s * (1 - UP);
    }
    _schedule() {
      for (this._runQueue.filterInPlace((s) => !!s.needsUpdate || (s.schedulePriority = s.basePriority, !1)), this._tasks.forAll((s) => {
        s.basePriority === qo && s.needsUpdate && !this._runQueue.includes(s) && s.blockFrame !== this._frameNumber && this._runQueue.unshift(s);
      }); this._runQueue.length === 0; ) {
        let s = !1, o = 0;
        if (this._tasks.forAll((a) => {
          a.needsUpdate && a.schedulePriority !== 0 && a.basePriority !== qo && a.blockFrame !== this._frameNumber && (s = !0, o = Math.max(o, a.basePriority), a.schedulePriority === 1 ? (a.schedulePriority = 0, this._runQueue.push(a)) : --a.schedulePriority);
        }), !s)
          return this._updatingChanged(), !1;
      }
      return this._updatingChanged(), !0;
    }
    _run() {
      const s = this._budget.now();
      this._startFrameTaskTimes();
      do
        for (; this._runQueue.length > 0; ) {
          const o = this._budget.now(), a = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            a.task.runTask(this._budget) === jT.YIELD && (a.blockFrame = this._frameNumber);
          } catch (c) {
            se.getLogger("geoscene.views.support.Scheduler").error(`Exception in task "${a.name}"`, c);
          }
          !this._budget.hasProgressed && a.blockFrame !== this._frameNumber && a.needsUpdate && (a.name, Ke.I3S_CONTROLLER, a.blockFrame = this._frameNumber), a.schedulePriority = a.basePriority;
          const l = this._budget.now() - o;
          if (a.runtime += l, this._frameTaskTimes.set(a.priority, this._frameTaskTimes.get(a.priority) + l), this._debug && l > 2 * this._budget.budget && console.log("Task", a.name, "used", l, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this._updatingChanged(), void this._recordFrameTaskTimes(this._budget.now() - s);
        }
      while (this._schedule());
      this._updatingChanged(), this._recordFrameTaskTimes(this._budget.now() - s);
    }
    _startFrameTaskTimes() {
      for (const s of Object.keys(Ke))
        this._frameTaskTimes.set(Ke[s], 0);
    }
    _recordFrameTaskTimes(s) {
      this._frameTaskTimes.forEach((o, a) => this.performanceInfo.tasks.get(a).record(o)), this.performanceInfo.total.record(s);
    }
    get test() {
      return this._test;
    }
  }
  e.Scheduler = t;
  class r {
    get task() {
      return this._task.value;
    }
    get updating() {
      return this._queue.running;
    }
    constructor(s, o, a, l) {
      this._scheduler = s, this.name = o, this._basePriority = l, this.blockFrame = 0, this.runtime = 0, this._queue = new Wae(), this._handles = new ca(), this.schedulePriority = this._basePriority, this._task = Qb(a ?? this._queue), this._handles.add(Au(() => this.task.running, (c) => s.taskRunningChanged(c)));
    }
    remove() {
      this.processQueue(F9), this._scheduler.removeTask(this), this.schedule = zT.schedule, this.reschedule = zT.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(s) {
      this.name = s;
      const o = FP(s);
      this._basePriority !== qo && this.schedulePriority === 0 || (this.schedulePriority = o), this._basePriority = o;
    }
    get priority() {
      return this.name;
    }
    set priority(s) {
      this.setPriority(s);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(s, o, a) {
      return this._queue.push(s, o, a);
    }
    reschedule(s, o, a) {
      return this._queue.unshift(s, o, a);
    }
    processQueue(s) {
      this._queue.runTask(s);
    }
  }
  class n {
    constructor() {
      this._begin = typeof performance < "u" ? performance.now() : 0, this._budget = 0, this._state = xi.IDLE, this._done = !1, this._progressed = !1, this._enabled = !0;
    }
    run(s) {
      return !this.done && (s() === !0 && this.madeProgress(), !0);
    }
    get done() {
      return this._done;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      return this._progressed = !0, this._done = this.elapsed >= this._budget && this._enabled, this._done;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(s) {
      this._enabled = s;
    }
    reset(s, o) {
      this._begin = this.now(), this._budget = s, this._state = o, this.resetProgress();
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return performance.now() - this._begin;
    }
    resetProgress() {
      this._progressed = !1, this._done = !1;
    }
    get hasProgressed() {
      return this._progressed;
    }
  }
  e.Budget = n;
})(VT || (VT = {})), function(e) {
  e.SCHEDULED = "s", e.READY = "r", e.WAITING = "w", e.IDLE = "i";
}(ec || (ec = {}));
const F9 = (() => {
  const e = new VT.Budget();
  return e.enabled = !1, e;
})();
let Kae = class {
  remove() {
  }
  processQueue() {
  }
  schedule(t, r, n) {
    try {
      if (ho(r)) {
        const i = rr();
        return n ? Promise.resolve(n(i)) : Promise.reject(i);
      }
      return I$(t(F9));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  reschedule(t, r, n) {
    return this.schedule(t, r, n);
  }
};
const zT = new Kae();
let Vm = class extends Ae {
  constructor(t, r) {
    super({}), this._stage = t, this._textureRequests = /* @__PURE__ */ new Map(), this._frameTask = (r == null ? void 0 : r.registerTask(Ke.TEXTURE_UNLOAD)) ?? zT;
  }
  normalizeCtorArgs() {
    return {};
  }
  destroy() {
    var t, r, n;
    super.destroy(), (t = this._frameTask) == null || t.remove(), (r = this._textureRequests) == null || r.forEach((i) => this._releaseTextureRequest(i)), (n = this._textureRequests) == null || n.clear();
  }
  get updating() {
    return this._frameTask.updating;
  }
  fromData(t, r, n) {
    var o, a;
    const i = this.makeUid(t);
    let s = this._textureRequests.get(i);
    if (!s) {
      const l = new Yae(n);
      l.texture = r(), (o = this._stage) == null || o.add(l.texture), (a = this._stage) == null || a.loadImmediate(l.texture), this._textureRequests.set(i, l), s = l;
    }
    return s.referenceCount++, { uid: i, texture: s.texture, release: () => this._release(i) };
  }
  _release(t) {
    const r = this._textureRequests.get(t);
    r ? (r.referenceCount < 1 && console.warn("TextureCollection: reference count is < 1 for " + t), r.referenceCount--, r.referenceCount < 1 && this._frameTask.schedule(() => this._releaseNow(t))) : console.warn(`TextureCollection: texture doesn't exist: '${t}'`);
  }
  get test() {
    return { textureRequests: this._textureRequests };
  }
  _releaseNow(t) {
    if (!this._textureRequests)
      return;
    const r = this._textureRequests.get(t);
    !r || r.referenceCount > 0 || (this._releaseTextureRequest(r), this._textureRequests.delete(t));
  }
  _releaseTextureRequest(t) {
    var r;
    t.onRemove && t.onRemove(), t.texture ? (r = this._stage) == null || r.remove(t.texture) : t.abortController && (t.abortController.abort(), t.abortController = null);
  }
  makeUid(t, r = null) {
    return r != null ? `${t}.${r}px` : t;
  }
};
u([d()], Vm.prototype, "_frameTask", void 0), u([d()], Vm.prototype, "updating", null), Vm = u([E("geoscene.views.3d.support.TextureCollection")], Vm);
let Yae = class {
  constructor(t) {
    this.onRemove = t, this.referenceCount = 0;
  }
};
var BP;
(function(e) {
  e[e.Left = 0] = "Left", e[e.Middle = 1] = "Middle", e[e.Right = 2] = "Right";
})(BP || (BP = {}));
const D9 = ["click", "double-click", "immediate-click", "immediate-double-click", "hold", "drag", "key-down", "key-up", "pointer-down", "pointer-move", "pointer-up", "pointer-drag", "mouse-wheel", "pointer-enter", "pointer-leave", "gamepad", "focus", "blur"], j9 = {};
function V9(e) {
  return !!j9[e];
}
function Qae(e) {
  for (const t of e)
    if (!V9(t))
      return !1;
  return !0;
}
D9.forEach((e) => {
  j9[e] = !0;
});
let Xae = class {
  constructor(t) {
    this._handlers = /* @__PURE__ */ new Map(), this._counter = 0, this._handlerCounts = /* @__PURE__ */ new Map(), this.view = t, this.inputManager = null;
  }
  connect(t) {
    t && this.disconnect(), this.inputManager = t, this._handlers.forEach(({ handler: r, priority: n }, i) => {
      var s;
      return (s = this.inputManager) == null ? void 0 : s.installHandlers(i, [r], n);
    });
  }
  disconnect() {
    this.inputManager && this._handlers.forEach((t, r) => {
      var n;
      return (n = this.inputManager) == null ? void 0 : n.uninstallHandlers(r);
    }), this.inputManager = null;
  }
  destroy() {
    this.disconnect(), this._handlers.clear(), this.view = null;
  }
  on(t, r, n, i) {
    const s = Array.isArray(t) ? t : t.split(",");
    if (!Qae(s))
      return s.some(V9) && console.error("Error: registering input events and other events on the view at the same time is not supported."), null;
    let o, a;
    Array.isArray(r) ? a = r : (o = r, a = []), typeof n == "function" ? o = n : i = n, i = i ?? Iu.DEFAULT;
    const l = this._createUniqueGroupName(), c = new ele(this.view, s, a, o);
    this._handlers.set(l, { handler: c, priority: i });
    for (const h of s) {
      const f = this._handlerCounts.get(h) || 0;
      this._handlerCounts.set(h, f + 1);
    }
    return this.inputManager && this.inputManager.installHandlers(l, [c], i), { remove: () => this._removeHandler(l, s) };
  }
  hasHandler(t) {
    return !!this._handlerCounts.get(t);
  }
  _removeHandler(t, r) {
    if (this._handlers.has(t)) {
      this._handlers.delete(t);
      for (const n of r) {
        const i = this._handlerCounts.get(n);
        i === void 0 ? console.error("Trying to remove handler for event that has no handlers registered: ", n) : i === 1 ? this._handlerCounts.delete(n) : this._handlerCounts.set(n, i - 1);
      }
    }
    this.inputManager && this.inputManager.uninstallHandlers(t);
  }
  _createUniqueGroupName() {
    return this._counter += 1, `viewEvents_${this._counter}`;
  }
}, ele = class extends Br {
  constructor(t, r, n, i) {
    super(!0), this._latestDragStart = void 0, this.view = t;
    for (const s of r)
      switch (s) {
        case "click":
          this.registerIncoming("click", n, (o) => i(this._wrapClick(o)));
          break;
        case "double-click":
          this.registerIncoming("double-click", n, (o) => i(this._wrapDoubleClick(o)));
          break;
        case "immediate-click":
          this.registerIncoming("immediate-click", n, (o) => i(this._wrapImmediateClick(o)));
          break;
        case "immediate-double-click":
          this.registerIncoming("immediate-double-click", n, (o) => i(this._wrapImmediateDoubleClick(o)));
          break;
        case "hold":
          this.registerIncoming("hold", n, (o) => i(this._wrapHold(o)));
          break;
        case "drag":
          this.registerIncoming("drag", n, (o) => {
            const a = this._wrapDrag(o);
            a && i(a);
          });
          break;
        case "key-down":
          this.registerIncoming("key-down", n, (o) => i(this._wrapKeyDown(o)));
          break;
        case "key-up":
          this.registerIncoming("key-up", n, (o) => i(this._wrapKeyUp(o)));
          break;
        case "pointer-down":
          this.registerIncoming("pointer-down", n, (o) => i(this._wrapPointer(o, "pointer-down")));
          break;
        case "pointer-move":
          this.registerIncoming("pointer-move", n, (o) => i(this._wrapPointer(o, "pointer-move")));
          break;
        case "pointer-up":
          this.registerIncoming("pointer-up", n, (o) => i(this._wrapPointer(o, "pointer-up")));
          break;
        case "pointer-drag":
          this.registerIncoming("pointer-drag", n, (o) => i(this._wrapPointerDrag(o)));
          break;
        case "mouse-wheel":
          this.registerIncoming("mouse-wheel", n, (o) => i(this._wrapMouseWheel(o)));
          break;
        case "pointer-enter":
          this.registerIncoming("pointer-enter", n, (o) => i(this._wrapPointer(o, "pointer-enter")));
          break;
        case "pointer-leave":
          this.registerIncoming("pointer-leave", n, (o) => i(this._wrapPointer(o, "pointer-leave")));
          break;
        case "gamepad":
          this.registerIncoming("gamepad", n, (o) => {
            i(this._wrapGamepad(o));
          });
          break;
        case "focus":
          this.registerIncoming("focus", n, (o) => {
            i(this._wrapFocus(o));
          });
          break;
        case "blur":
          this.registerIncoming("blur", n, (o) => {
            i(this._wrapBlur(o));
          });
      }
  }
  _wrapFocus(t) {
    return { type: "focus", timestamp: t.timestamp, native: t.data.native, cancelable: t.cancelable, stopPropagation: () => t.stopPropagation(), async: (r) => t.async(r), preventDefault: () => t.preventDefault() };
  }
  _wrapBlur(t) {
    return { type: "blur", timestamp: t.timestamp, native: t.data.native, cancelable: t.cancelable, stopPropagation: () => t.stopPropagation(), async: (r) => t.async(r), preventDefault: () => t.preventDefault() };
  }
  _wrapClick(t) {
    const { pointerType: r, button: n, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, { cancelable: c, timestamp: h } = t;
    return { type: "click", pointerType: r, button: n, buttons: i, x: s, y: o, native: a, timestamp: h, screenPoint: Vn(s, o), mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: c, stopPropagation: () => t.stopPropagation(), async: (f) => t.async(f), preventDefault: () => t.preventDefault() };
  }
  _wrapDoubleClick(t) {
    const { pointerType: r, button: n, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, { cancelable: c, timestamp: h } = t;
    return { type: "double-click", pointerType: r, button: n, buttons: i, x: s, y: o, native: a, timestamp: h, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: c, stopPropagation: () => t.stopPropagation(), async: (f) => t.async(f), preventDefault: () => t.preventDefault() };
  }
  _wrapImmediateClick(t) {
    const { pointerType: r, button: n, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, c = a.pointerId, { cancelable: h, timestamp: f } = t;
    return { type: "immediate-click", pointerId: c, pointerType: r, button: n, buttons: i, x: s, y: o, native: a, timestamp: f, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: h, stopPropagation: () => t.stopPropagation(), async: (m) => t.async(m), preventDefault: () => t.preventDefault() };
  }
  _wrapImmediateDoubleClick(t) {
    const { pointerType: r, button: n, buttons: i, x: s, y: o, native: a, eventId: l } = t.data, c = a.pointerId, { cancelable: h, timestamp: f } = t;
    return { type: "immediate-double-click", pointerId: c, pointerType: r, button: n, buttons: i, x: s, y: o, native: a, timestamp: f, mapPoint: this._getMapPoint(s, o), eventId: l, cancelable: h, stopPropagation: () => t.stopPropagation(), async: (m) => t.async(m), preventDefault: () => t.preventDefault() };
  }
  _wrapHold(t) {
    const { pointerType: r, button: n, buttons: i, x: s, y: o, native: a } = t.data, { cancelable: l, timestamp: c } = t;
    return { type: "hold", pointerType: r, button: n, buttons: i, x: s, y: o, native: a, timestamp: c, mapPoint: this._getMapPoint(s, o), cancelable: l, stopPropagation: () => t.stopPropagation(), async: (h) => t.async(h), preventDefault: () => t.preventDefault() };
  }
  _getMapPoint(t, r) {
    return this.view.toMap(Vn(t, r), { exclude: [] });
  }
  _wrapDrag(t) {
    const r = t.data, { x: n, y: i } = r.center, { action: s, pointerType: o, button: a } = r;
    if (s === "start" && (this._latestDragStart = r), !this._latestDragStart)
      return;
    const l = r.pointer.native, c = r.buttons, { cancelable: h, timestamp: f } = t, m = { x: this._latestDragStart.center.x, y: this._latestDragStart.center.y };
    return s === "end" && (this._latestDragStart = void 0), { type: "drag", action: s, x: n, y: i, origin: m, pointerType: o, button: a, buttons: c, radius: r.radius, angle: l8(r.angle), native: l, timestamp: f, cancelable: h, stopPropagation: () => t.stopPropagation(), async: (y) => t.async(y), preventDefault: () => t.preventDefault() };
  }
  _wrapKeyDown(t) {
    const { key: r, repeat: n, native: i } = t.data, { cancelable: s, timestamp: o } = t;
    return { type: "key-down", key: r, repeat: n, native: i, timestamp: o, cancelable: s, stopPropagation: () => t.stopPropagation(), async: (a) => t.async(a), preventDefault: () => t.preventDefault() };
  }
  _wrapKeyUp(t) {
    const { key: r, native: n } = t.data, { cancelable: i, timestamp: s } = t;
    return { type: "key-up", key: r, native: n, timestamp: s, cancelable: i, stopPropagation: () => t.stopPropagation(), async: (o) => t.async(o), preventDefault: () => t.preventDefault() };
  }
  _wrapPointer(t, r) {
    const { x: n, y: i, button: s, buttons: o, native: a, eventId: l } = t.data, c = a.pointerId, h = a.pointerType, { cancelable: f, timestamp: m } = t;
    return { type: r, x: n, y: i, pointerId: c, pointerType: h, button: s, buttons: o, native: a, timestamp: m, eventId: l, cancelable: f, stopPropagation: () => t.stopPropagation(), async: (y) => t.async(y), preventDefault: () => t.preventDefault() };
  }
  _wrapPointerDrag(t) {
    const { x: r, y: n, buttons: i, native: s, eventId: o } = t.data.currentEvent, { button: a } = t.data.startEvent, l = t.data.startEvent.native.pointerId, c = t.data.startEvent.native.pointerType, h = t.data.action, f = { x: t.data.startEvent.x, y: t.data.startEvent.y }, { cancelable: m, timestamp: y } = t;
    return { type: "pointer-drag", x: r, y: n, pointerId: l, pointerType: c, button: a, buttons: i, action: h, origin: f, native: s, timestamp: y, eventId: o, cancelable: m, stopPropagation: () => t.stopPropagation(), async: (g) => t.async(g), preventDefault: () => t.preventDefault() };
  }
  _wrapMouseWheel(t) {
    const { cancelable: r, data: n, timestamp: i } = t, { x: s, y: o, deltaY: a, native: l } = n;
    return { type: "mouse-wheel", x: s, y: o, deltaY: a, native: l, timestamp: i, cancelable: r, stopPropagation: () => t.stopPropagation(), async: (c) => t.async(c), preventDefault: () => t.preventDefault() };
  }
  _wrapGamepad(t) {
    const { action: r, state: n, device: i } = t.data, { cancelable: s, timestamp: o } = t, { buttons: a, axes: l } = n;
    return { type: "gamepad", device: i, timestamp: o, action: r, buttons: a, axes: l, cancelable: s, stopPropagation: () => t.stopPropagation(), async: (c) => t.async(c), preventDefault: () => t.preventDefault() };
  }
};
var lg, qP, GP;
(function(e) {
  e[e.USER = 0] = "USER", e[e.MANAGER = 1] = "MANAGER";
})(lg || (lg = {})), function(e) {
  e[e.None = 0] = "None", e[e.Unfocused = 1] = "Unfocused", e[e.Focused = 2] = "Focused", e[e.Unselected = 4] = "Unselected", e[e.Selected = 8] = "Selected", e[e.All = 15] = "All";
}(qP || (qP = {})), function(e) {
  e[e.None = 0] = "None", e[e.Custom1 = 16] = "Custom1", e[e.Custom2 = 32] = "Custom2", e[e.Custom3 = 64] = "Custom3", e[e.Custom4 = 128] = "Custom4", e[e.Custom5 = 256] = "Custom5", e[e.Custom6 = 512] = "Custom6", e[e.Custom7 = 1024] = "Custom7", e[e.Custom8 = 2048] = "Custom8", e[e.Custom9 = 4096] = "Custom9", e[e.Custom10 = 8192] = "Custom10", e[e.Custom11 = 16384] = "Custom11", e[e.Custom12 = 32768] = "Custom12", e[e.All = 65520] = "All";
}(GP || (GP = {}));
function tle(e) {
  return [e.on("before-add", (t) => {
    const r = t.item;
    if (r == null || e.includes(r))
      return se.getLogger("geoscene.views.interactive.interactiveToolUtils").warn("Tool is either already in the list of tools or tool is `null`. Not adding tool."), void t.preventDefault();
    r.onAdd();
  }), e.on("after-remove", (t) => {
    const r = t.item;
    r.active && (r.view.activeTool = null), r.destroy();
  })];
}
function UT(e) {
  return e.visible && e.getEditableFlag != null && e.getEditableFlag(lg.USER) && e.getEditableFlag(lg.MANAGER);
}
function Fo(e) {
  return Vn(e.x, e.y);
}
function z9(e, t) {
  var n;
  const r = (n = e instanceof HTMLElement ? e : e.surface) == null ? void 0 : n.getBoundingClientRect();
  return r ? Vn(t.clientX - r.left, t.clientY - r.top) : Vn(0, 0);
}
function HP(e, t) {
  return t instanceof Event ? z9(e, t) : Fo(t);
}
function WP(e) {
  if (e instanceof Event)
    return !0;
  if (typeof e == "object" && "type" in e)
    switch (e.type) {
      case "click":
      case "double-click":
      case "pointer-down":
      case "pointer-drag":
      case "pointer-enter":
      case "pointer-leave":
      case "pointer-up":
      case "pointer-move":
      case "immediate-click":
      case "immediate-double-click":
      case "hold":
      case "drag":
      case "mouse-wheel":
        return !0;
      default:
        return !1;
    }
  return !1;
}
let rle = class {
  constructor() {
    this._pointerLocations = /* @__PURE__ */ new Map(), this._hoveredManipulators = /* @__PURE__ */ new Map(), this._grabbedManipulators = /* @__PURE__ */ new Map(), this._draggedManipulators = /* @__PURE__ */ new Map(), this._stopDrag = !1, this._revertToNullActiveTool = !1, this._cursor = null;
  }
  get cursor() {
    return this._cursor;
  }
  hasFocusedManipulators() {
    return this._grabbedManipulators.size > 0 || this._draggedManipulators.size > 0;
  }
  handleInputEvent(t, r) {
    const n = () => t.stopPropagation();
    switch (t.type) {
      case "pointer-move":
        JP(t.pointerType) && this._pointerLocations.set(t.pointerId, { x: t.x, y: t.y, pointerType: t.pointerType });
        break;
      case "drag":
        this._grabbedManipulators.size > 0 && (this._stopDrag = !0), this._stopDrag && (n(), t.action === "end" && (this._stopDrag = !1));
        break;
      case "pointer-down": {
        if (!ZP(t))
          break;
        const i = Fo(t), s = this._intersect(i, t.pointerType, r.forEachTool);
        if (s == null)
          break;
        const o = s.manipulator, a = s.tool;
        o == null || a == null || !o.interactive || o.grabbable && o.grabbableForEvent(t) || !o.grabbing || o.dragging || this._ungrabManipulatorBeforeDragging(o, t, r), o != null && a != null && o.interactive && o.grabbable && o.grabbableForEvent(t) && !o.grabbing && (this._grabbedManipulators.set(t.pointerId, { manipulator: o, tool: a, start: i, pointerType: t.pointerType }), this._grabbedManipulators.size === 1 && r.activeTool == null && (this._revertToNullActiveTool = !0, r.setActiveTool(s.tool)), o.grabbing = !0, o.events.emit("grab-changed", { action: "start", pointerType: t.pointerType, screenPoint: i }), n());
        break;
      }
      case "pointer-up":
        this._draggedManipulators.has(t.pointerId) || this._handlePointerEnd(t, r);
        break;
      case "pointer-drag": {
        if (!ZP(t))
          break;
        const i = this._grabbedManipulators.get(t.pointerId), s = td(i, ({ manipulator: h }) => h), o = td(i, ({ tool: h }) => h);
        if (s == null || o == null)
          break;
        const a = Fo(t);
        a.x = ws(a.x, 0, r.view.width), a.y = ws(a.y, 0, r.view.height);
        const l = i.start, c = this._draggedManipulators.get(t.pointerId);
        switch (t.action) {
          case "start":
          case "update":
            t.action !== "update" && this._grabbedManipulators.size !== 1 || (s.dragging = !0, c ? s.events.emit("drag", { action: "update", start: l, screenPoint: a }) : s.events.emit("drag", { action: "start", start: l, screenPoint: a, pointerType: t.pointerType }), this._draggedManipulators.set(t.pointerId, { tool: o, manipulator: s, start: l }));
            break;
          case "end":
            s.dragging = !1, c && s.events.emit("drag", { action: "end", start: l, screenPoint: a }), this._draggedManipulators.delete(t.pointerId), this._handlePointerEnd(t, r);
        }
        n();
        break;
      }
      case "immediate-click": {
        const i = Fo(t), s = this._intersect(i, t.pointerType, r.forEachTool);
        if (nle(t) || r.forEachTool((c) => {
          if ((s == null || s.tool !== c || c.automaticManipulatorSelection) && c.manipulators) {
            let h = !1;
            c.manipulators.forEach(({ manipulator: f }) => {
              f.selected && (f.selected = !1, h = !0);
            }), h && c.onManipulatorSelectionChanged && c.onManipulatorSelectionChanged();
          }
        }), s == null)
          break;
        const { manipulator: o, tool: a } = s;
        if (!o.interactive)
          break;
        o.selectable && a.automaticManipulatorSelection && (o.selected = !o.selected, a.onManipulatorSelectionChanged && a.onManipulatorSelectionChanged());
        const l = t.native.shiftKey;
        o.events.emit("immediate-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: l, stopPropagation: n });
        break;
      }
      case "click": {
        const i = Fo(t), s = this._intersect(i, t.pointerType, r.forEachTool), o = s != null ? s.manipulator : null;
        if (o == null || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit(t.type, { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a }), n();
        break;
      }
      case "double-click": {
        const i = Fo(t), s = this._intersect(i, t.pointerType, r.forEachTool), o = s != null ? s.manipulator : null;
        if (o == null || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit("double-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a, stopPropagation: n });
        break;
      }
      case "immediate-double-click": {
        const i = Fo(t), s = this._intersect(i, t.pointerType, r.forEachTool), o = s != null ? s.manipulator : null;
        if (o == null || !o.interactive)
          break;
        const a = t.native.shiftKey;
        o.events.emit("immediate-double-click", { screenPoint: i, button: t.button, pointerType: t.pointerType, shiftKey: a, stopPropagation: n });
        break;
      }
    }
    this._onFocusChange(r.forEachTool);
  }
  _ungrabManipulatorBeforeDragging(t, r, n) {
    t.grabbing = !1, t.events.emit("grab-changed", { action: "end", pointerType: r.pointerType, screenPoint: Fo(r) }), this._grabbedManipulators.forEach(({ manipulator: i }, s) => {
      i === t && this._grabbedManipulators.delete(s);
    }), this._afterManipulatorUngrab(n.setActiveTool);
  }
  _handlePointerEnd(t, r) {
    const n = td(this._grabbedManipulators.get(t.pointerId), ({ manipulator: i }) => i);
    n != null && n.grabbing && (n.grabbing = !1, n.events.emit("grab-changed", { action: "end", pointerType: t.pointerType, screenPoint: Fo(t) }), this._grabbedManipulators.delete(t.pointerId), this._afterManipulatorUngrab(r.setActiveTool));
  }
  _cursorFromMap(t) {
    let r = null;
    return Qw(t, ({ manipulator: n }) => !(n == null || !n.interactive) && (n.grabbing && n.grabCursor ? (r = n.grabCursor, !0) : !!n.cursor && (r = n.cursor, !0))), r;
  }
  _onFocusChange(t) {
    this._updateCursor(), this._updateFocusedManipulatorTools(t);
  }
  _updateCursor() {
    this._grabbedManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._grabbedManipulators) || "grabbing" : this._hoveredManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._hoveredManipulators) || "pointer" : this._cursor = null;
  }
  _updateFocusedManipulatorTools(t) {
    const r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
    this._grabbedManipulators.forEach(({ tool: i }) => {
      r.add(i);
    }), this._hoveredManipulators.forEach(({ tool: i }) => {
      n.add(i);
    }), t((i) => {
      i.hasGrabbedManipulators = r.has(i), i.hasHoveredManipulators = n.has(i);
      const s = this._grabbedManipulators.values(), o = GH(s, ({ tool: a }) => a === i);
      i.firstGrabbedManipulator = o != null ? o.manipulator : null;
    });
  }
  clearPointers(t, { forEachTool: r, setActiveTool: n }, i = !0, s) {
    const o = (a, l) => a === t && (s == null || s === l);
    this._grabbedManipulators.forEach(({ tool: a, manipulator: l, pointerType: c }, h) => {
      o(a, l) && (this._grabbedManipulators.delete(h), l.grabbing = !1, l.events.emit("grab-changed", { action: "end", screenPoint: null, pointerType: c }));
    }), this._draggedManipulators.forEach(({ tool: a, manipulator: l }, c) => {
      o(a, l) && (this._draggedManipulators.delete(c), l.dragging = !1, l.events.emit("drag", { action: "cancel" }));
    }), i && this._hoveredManipulators.forEach(({ tool: a, manipulator: l }, c) => {
      o(a, l) && (this._hoveredManipulators.delete(c), l.hovering = !1);
    }), this._afterManipulatorUngrab(n), this._onFocusChange(r);
  }
  _intersect(t, r, n) {
    let i = null;
    return n((s) => {
      if (s.manipulators == null || !UT(s))
        return !1;
      const o = s.manipulators.intersect(t, r);
      return o != null && (i = { tool: s, manipulator: o }, !0);
    }), i;
  }
  updateHoveredStateFromKnownPointers(t) {
    this._pointerLocations.forEach((r, n) => {
      this._updateHoveredStateForPointerAtScreenPosition(Vn(r.x, r.y), n, r.pointerType, t);
    });
  }
  handleHoverEvent(t, r) {
    t.type !== "pointer-up" && t.type !== "immediate-click" && t.type !== "pointer-move" || !JP(t.pointerType) || this._updateHoveredStateForPointerAtScreenPosition(Fo(t), t.pointerId, t.pointerType, r);
  }
  _updateHoveredStateForPointerAtScreenPosition(t, r, n, i) {
    let s = this._intersect(t, n, i);
    const o = td(this._hoveredManipulators.get(r), ({ manipulator: a }) => a);
    s == null || s.manipulator.interactive || (s = null), s != null && o === s.manipulator || (o != null && (o.hovering = !1), s != null ? (s.manipulator.hovering = !0, this._hoveredManipulators.set(r, s)) : this._hoveredManipulators.delete(r), this._onFocusChange(i));
  }
  _afterManipulatorUngrab(t) {
    this._grabbedManipulators.size === 0 && this._revertToNullActiveTool && (t(null), this._revertToNullActiveTool = !1);
  }
};
function JP(e) {
  return e === "mouse";
}
function ZP(e) {
  return e.pointerType !== "mouse" || e.button === 0;
}
function nle(e) {
  return !!e.native.shiftKey;
}
const KP = "attached", cS = "tools", ile = 1e3;
let Bs = class extends Xb {
  constructor(t) {
    super(t), this._clock = rf, this._manipulatorState = new rle(), this.tools = new je(), this.cursor = null, this._interacting = !1, this._interactingTimeout = null, this._forEachTool = (r) => {
      for (const n of this.tools.items)
        if (r(n))
          return;
    };
  }
  initialize() {
    this.handles.add([this.view.on(D9, (t) => {
      this._handleInputEvent(t);
    }, Iu.TOOL), ...tle(this.tools), this.tools.on("before-add", ({ item: t }) => {
      this._updateToolEditableFlag(t);
    }), this.tools.on("before-remove", ({ item: t }) => {
      this._manipulatorState.clearPointers(t, this._manipulatorStateEventArgs), this._updateCursor();
    }), this.tools.on("change", () => {
      this._refreshToolWatchers();
    })]);
  }
  destroy() {
    this.detach(), this.handles.removeAll();
  }
  get _manipulatorStateEventArgs() {
    return { forEachTool: this._forEachTool, activeTool: this.activeTool, setActiveTool: (t) => {
      this.activeTool = t;
    }, view: this.view };
  }
  set activeTool(t) {
    if (t != null && !this.view.ready)
      return void se.getLogger(this).error("Cannot set active tool while view is not ready.");
    if (t === this.activeTool)
      return;
    const r = this.activeTool;
    this._set("activeTool", t), r != null && r.deactivate(), t != null && t.activate(), this._removeIncompleteTools(t);
    for (const n of this.tools) {
      this._updateToolEditableFlag(n);
      const i = UT(n);
      this.activeTool != null && i || this._manipulatorState.clearPointers(n, this._manipulatorStateEventArgs, !i);
    }
    this._updateCursor();
  }
  get updating() {
    var t;
    return this.updatingHandles.updating || this.tools.some((r) => r.updating) || (((t = this.textures) == null ? void 0 : t.updating) ?? !1);
  }
  get interacting() {
    return this._interacting;
  }
  _clearInteractingTimeout() {
    this._interactingTimeout = tr(this._interactingTimeout);
  }
  _startInteractingTimeout() {
    this._clearInteractingTimeout(), this._interactingTimeout = this._clock.setTimeout(() => this._interacting = !1, ile);
  }
  attach() {
    var t;
    this.view.type === "3d" ? (this._set("textures", new Vm(this.view._stage, this.view.resourceController.scheduler)), this.handles.add([ze(() => {
      const { state: r } = this.view;
      return "camera" in r && r.camera;
    }, () => this._forEachManipulator((r) => r.onViewChange())), (t = this.view.elevationProvider) == null ? void 0 : t.on("elevation-change", (r) => this._forEachManipulator((n) => n.onElevationChange(r))), nl(() => this._set("textures", Vt(this.textures)))], KP)) : this.handles.add(ze(() => this.view.extent, () => this._forEachManipulator((r) => r.onViewChange())));
  }
  detach() {
    this.activeTool = null, this.tools.removeAll(), this.handles.remove(KP), this._clearInteractingTimeout(), this._interacting = !1;
  }
  _forEachManipulator(t) {
    this._forEachTool((r) => {
      r.manipulators && r.manipulators.forEach(({ manipulator: n }) => t(n, r));
    });
  }
  _handleInputEvent(t) {
    let r = !1;
    const n = { ...t, stopPropagation: () => {
      r = !0, t.stopPropagation();
    } };
    this.activeTool != null ? this.activeTool.handleInputEvent && this.activeTool.handleInputEvent(n) : this._forEachTool((i) => {
      !r && i.visible && i.handleInputEvent(n);
    }), !r && t.type === "key-down" && t.key === "Escape" && this.activeTool && (t.stopPropagation(), this.activeTool = null), this._manipulatorState.handleInputEvent(n, this._manipulatorStateEventArgs), r || this.activeTool == null || this.activeTool.handleInputEventAfter(n), this._manipulatorState.handleHoverEvent(n, this._forEachTool), this._updateCursor(), t.type === "pointer-move" && (this._manipulatorState.hasFocusedManipulators() || this.activeTool) && (this._interacting = !0, this._startInteractingTimeout());
  }
  _refreshToolWatchers() {
    this.handles.remove(cS), this._forEachTool((t) => {
      if (t instanceof Ae) {
        const r = ze(() => [t.cursor, t.visible, t.editable], () => {
          UT(t) || this._manipulatorState.clearPointers(t, this._manipulatorStateEventArgs), this._updateCursor();
        });
        this.handles.add(r, cS);
      }
      t.manipulators && this.handles.add([t.manipulators.on("after-remove", (r) => {
        this._manipulatorState.clearPointers(t, this._manipulatorStateEventArgs, !0, r.item.manipulator);
      }), t.manipulators.on("change", () => {
        this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
      })], cS);
    }), this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
  }
  _updateToolEditableFlag(t) {
    var r;
    (r = t.setEditableFlag) == null || r.call(t, lg.MANAGER, this.activeTool == null || t === this.activeTool);
  }
  _updateCursor() {
    let t = this._manipulatorState.cursor;
    t == null && this._forEachTool((r) => !(r.cursor == null || !r.visible) && (t = r.cursor, !0)), this._get("cursor") !== t && this._set("cursor", t);
  }
  _removeIncompleteTools(t) {
    this.tools.filter((r) => (t == null || r !== t) && !r.created && r.removeIncompleteOnCancel).forEach((r) => {
      this.tools.remove(r);
    });
  }
  get test() {
    return { setClock: (t) => this._clock = t };
  }
};
u([d({ constructOnly: !0, nonNullable: !0 })], Bs.prototype, "view", void 0), u([d({ readOnly: !0, nonNullable: !0 })], Bs.prototype, "textures", void 0), u([d({ value: null })], Bs.prototype, "activeTool", null), u([d({ readOnly: !0, type: je })], Bs.prototype, "tools", void 0), u([d({ readOnly: !0 })], Bs.prototype, "cursor", void 0), u([d({ readOnly: !0 })], Bs.prototype, "updating", null), u([d()], Bs.prototype, "_interacting", void 0), u([d({ readOnly: !0 })], Bs.prototype, "interacting", null), Bs = u([E("geoscene.views.ToolViewManager")], Bs);
let Np = class extends Ae {
  constructor(t) {
    super(), this.nativeIndex = null, this._detectedDeviceType = "unknown", t.mapping === "standard" ? this._detectedDeviceType = "standard" : sle.test(t.id) ? this._detectedDeviceType = "spacemouse" : this._detectedDeviceType = "unknown", this.nativeIndex = t.index;
  }
  get native() {
    const t = navigator.getGamepads ? navigator.getGamepads() : [];
    return this.nativeIndex != null && this.nativeIndex < t.length ? t[this.nativeIndex] : null;
  }
  get deviceType() {
    return this._detectedDeviceType;
  }
  get axisThreshold() {
    return ole[this.deviceType];
  }
};
u([d({ nonNullable: !0, readOnly: !0 })], Np.prototype, "nativeIndex", void 0), u([d({ type: String, readOnly: !0 })], Np.prototype, "deviceType", null), u([d({ type: Number, readOnly: !0 })], Np.prototype, "axisThreshold", null), Np = u([E("geoscene.views.input.gamepad.GamepadInputDevice")], Np);
const sle = new RegExp("^(3dconnexion|space(mouse|navigator|pilot|explorer))", "i"), ole = { standard: 0.15, spacemouse: 0.025, unknown: 0 }, hO = Np;
let zm = class extends Ae {
  constructor(...t) {
    super(...t), this.devices = new je(), this.enabledFocusMode = "document";
  }
};
u([d({ type: je.ofType(hO), readOnly: !0 })], zm.prototype, "devices", void 0), u([d({ type: ["document", "view", "none"] })], zm.prototype, "enabledFocusMode", void 0), zm = u([E("geoscene.views.input.gamepad.GamepadSettings")], zm);
const ale = zm;
let v1 = class extends Ae {
  constructor() {
    super(...arguments), this.gamepad = new ale();
  }
};
u([d({ readOnly: !0 })], v1.prototype, "gamepad", void 0), v1 = u([E("geoscene.views.input.Input")], v1);
const lle = v1;
let Yl = class extends Ae {
  constructor(t) {
    super(t), this.enabled = !0, this.device = null, this.mode = "pan", this.tiltDirection = "forward-down", this.velocityFactor = 1;
  }
};
u([d({ type: Boolean, nonNullable: !0 })], Yl.prototype, "enabled", void 0), u([d({ type: hO })], Yl.prototype, "device", void 0), u([d({ type: ["pan", "zoom"], nonNullable: !0 })], Yl.prototype, "mode", void 0), u([d({ type: ["forward-down", "forward-up"], nonNullable: !0 })], Yl.prototype, "tiltDirection", void 0), u([d({ type: Number, nonNullable: !0 })], Yl.prototype, "velocityFactor", void 0), Yl = u([E("geoscene.views.navigation.gamepad.GamepadSettings")], Yl);
const U9 = Yl;
let Ec = class extends Ae {
  constructor(t) {
    super(t), this.browserTouchPanEnabled = !0, this.gamepad = new U9(), this.momentumEnabled = !0, this.mouseWheelZoomEnabled = !0;
  }
};
u([d({ type: Boolean })], Ec.prototype, "browserTouchPanEnabled", void 0), u([d({ type: U9, nonNullable: !0 })], Ec.prototype, "gamepad", void 0), u([d({ type: Boolean })], Ec.prototype, "momentumEnabled", void 0), u([d({ type: Boolean })], Ec.prototype, "mouseWheelZoomEnabled", void 0), Ec = u([E("geoscene.views.navigation.Navigation")], Ec);
const B9 = Ec, q9 = { mapserver: "MapServer", imageserver: "ImageServer", featureserver: "FeatureServer", sceneserver: "SceneServer", streamserver: "StreamServer", vectortileserver: "VectorTileServer" }, G9 = Object.values(q9), H9 = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/rest\\/services\\/(.+?)\\/(${G9.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), ule = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/([^\\/\\n]+)\\/(${G9.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), cle = /(.*?)\/(?:layers\/)?(\d+)\/?$/i;
function wLe(e) {
  return !!H9.test(e);
}
function gf(e) {
  if (e == null)
    return null;
  const t = Di(e), r = t.path.match(H9) || t.path.match(ule);
  if (!r)
    return null;
  const [, n, i, s, o] = r, a = i.indexOf("/");
  return { title: fO(a !== -1 ? i.slice(a + 1) : i), serverType: q9[s.toLowerCase()], sublayer: o != null && o !== "" ? parseInt(o, 10) : null, url: { path: n } };
}
function dle(e) {
  const t = Di(e).path.match(cle);
  return t ? { serviceUrl: t[1], sublayerId: Number(t[2]) } : null;
}
function fO(e) {
  return (e = e.replaceAll(/\s*[/_]+\s*/g, " "))[0].toUpperCase() + e.slice(1);
}
function ple(e, t) {
  const r = [];
  if (e) {
    const n = gf(e);
    n != null && n.title && r.push(n.title);
  }
  if (t) {
    const n = fO(t);
    r.push(n);
  }
  if (r.length === 2) {
    if (r[0].toLowerCase().includes(r[1].toLowerCase()))
      return r[0];
    if (r[1].toLowerCase().includes(r[0].toLowerCase()))
      return r[1];
  }
  return r.join(" - ");
}
function W9(e) {
  if (!e)
    return !1;
  const t = ".arcgis.com/", r = "//services", n = "//tiles", i = "//features", s = (e = e.toLowerCase()).includes(t), o = e.includes(r) || e.includes(n) || e.includes(i);
  return s && o;
}
function hle(e, t) {
  return e && o6(a6(e, t));
}
function fle(e) {
  let { url: t } = e;
  if (!t)
    return { url: t };
  t = a6(t, e.logger);
  const r = Di(t), n = gf(r.path);
  let i;
  if (n != null)
    n.sublayer != null && e.layer.layerId == null && (i = n.sublayer), t = n.url.path;
  else if (e.nonStandardUrlAllowed) {
    const s = dle(r.path);
    s != null && (t = s.serviceUrl, i = s.sublayerId);
  }
  return { url: o6(t), layerId: i };
}
function mle(e, t, r, n, i) {
  Nd(t, n, "url", i), n.url && e.layerId != null && (n.url = Rh(n.url, r, e.layerId.toString()));
}
function _Le(e) {
  if (!e)
    return !1;
  const t = e.toLowerCase(), r = t.includes("/services/"), n = t.includes("/mapserver/wmsserver"), i = t.includes("/imageserver/wmsserver"), s = t.includes("/wmsserver");
  return r && (n || i || s);
}
var YP;
function yle(e) {
  var n;
  const t = e.url ? gf(e.url) : void 0;
  return !(((n = e.spatialReference) == null ? void 0 : n.vcsWkid) == null && t != null && t.serverType === "ImageServer") && J9(e) && e.heightModelInfo ? e.heightModelInfo : gle(e) ? O_.deriveUnitFromSR(ble, e.spatialReference) : null;
}
function J9(e) {
  return "heightModelInfo" in e;
}
function Z9(e) {
  if (e.type === "unknown" || !("capabilities" in e))
    return !1;
  switch (e.type) {
    case "csv":
    case "feature":
    case "geojson":
    case "subtype-group":
    case "ogc-feature":
    case "oriented-imagery":
    case "wfs":
    case "knowledge-graph-sublayer":
      return !0;
    default:
      return !1;
  }
}
function gle(e) {
  return Z9(e) ? !!(e.capabilities && e.capabilities.data && e.capabilities.data.supportsZ) : K9(e);
}
function vle(e) {
  return e.layers != null || K9(e) || Z9(e) || J9(e);
}
function K9(e) {
  switch (e.type) {
    case "building-scene":
    case "elevation":
    case "integrated-mesh":
    case "point-cloud":
    case "scene":
    case "voxel":
      return !0;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "csv":
    case "dimension":
    case "geojson":
    case "feature":
    case "subtype-group":
    case "geo-rss":
    case "graphics":
    case "group":
    case "imagery":
    case "imagery-tile":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-image":
    case "map-notes":
    case "media":
    case "ogc-feature":
    case "open-street-map":
    case "oriented-imagery":
    case "route":
    case "stream":
    case "tile":
    case "unknown":
    case "unsupported":
    case "vector-tile":
    case "video":
    case "wcs":
    case "web-tile":
    case "wfs":
    case "wms":
    case "wmts":
    case null:
      return !1;
  }
  return !1;
}
(function(e) {
  e[e.Ok = 0] = "Ok", e[e.Units = 1] = "Units", e[e.HeightModel = 2] = "HeightModel", e[e.CRS = 3] = "CRS", e[e.Unsupported = 4] = "Unsupported";
})(YP || (YP = {}));
const ble = new O_({ heightModel: "gravity-related-height" });
var rw;
(function(e) {
  e[e.Global = 1] = "Global", e[e.Local = 2] = "Local";
})(rw || (rw = {}));
let BT, dS = null;
async function wle(e) {
  dS || (dS = import("./geometryServiceUtils-TspRE0Qd.js").then((t) => BT = t)), await dS, lr(e);
}
async function Y9(e, t, r, n) {
  if (!e)
    return null;
  const i = e.spatialReference;
  return rp() || ll(i, t) ? Ju(e, t) : BT ? BT.projectGeometry(e, t, r, n) : (await Promise.race([wle(n), Ru(n)]), Y9(e, t, r, n));
}
let Et = class extends Ae {
  constructor(t) {
    super(t), this.required = { tileInfo: !1, heightModelInfo: !1, extent: !1 }, this.defaultSpatialReference = null, this.userSpatialReference = null, this.sourcePreloadCount = 10, this.priorityCollection = null, this.requiresExtentInSpatialReference = !0, this.suspended = !1, this._projectExtentTask = { task: null, input: null, output: null, spatialReference: null };
  }
  destroy() {
    this._projectExtentTask.task && (this._projectExtentTask.task = zy(this._projectExtentTask.task)), this._set("map", null);
  }
  get ready() {
    return !this._spatialReferenceTask.updating && !this._tileInfoTask.updating && !this._extentTask.updating;
  }
  get heightModelInfoReady() {
    return !this._heightModelInfoTask.updating;
  }
  get spatialReference() {
    return this.userSpatialReference != null ? this.userSpatialReference : this._spatialReferenceTask.spatialReference;
  }
  get extent() {
    return this._extentTask.extent;
  }
  get heightModelInfo() {
    return this._heightModelInfoTask.heightModelInfo;
  }
  get vcsWkid() {
    return this._heightModelInfoTask.vcsWkid;
  }
  get latestVcsWkid() {
    return this._heightModelInfoTask.latestVcsWkid;
  }
  get viewingMode() {
    return this.userSpatialReference == null || this.userSpatialReference.equals(this._spatialReferenceTask.spatialReference) ? this._spatialReferenceTask.viewingMode : null;
  }
  get tileInfo() {
    return this._tileInfoTask.tileInfo;
  }
  get mapCollections() {
    var n, i, s, o;
    const t = (n = this.map) == null ? void 0 : n.call(this), r = [];
    return this.priorityCollection != null && r.push(this.priorityCollection), r.push({ parent: t == null ? void 0 : t.basemap, layers: (i = t == null ? void 0 : t.basemap) == null ? void 0 : i.baseLayers }, { layers: t == null ? void 0 : t.layers }, { parent: t == null ? void 0 : t.ground, layers: (s = t == null ? void 0 : t.ground) == null ? void 0 : s.layers }, { parent: t == null ? void 0 : t.basemap, layers: (o = t == null ? void 0 : t.basemap) == null ? void 0 : o.referenceLayers }), r;
  }
  get _allLayers() {
    return this._collectLayers(this.mapCollections);
  }
  get _spatialReferenceTask() {
    if (this.suspended)
      return this._get("_spatialReferenceTask") ?? { updating: !1 };
    const { layers: t, updating: r } = this._allLayers;
    let n = null;
    for (const s of t) {
      const o = this._getSupportedSpatialReferences(s);
      if (o.length > 0) {
        const a = this._narrowDownSpatialReferenceCandidates(n, o);
        a != null && (n = a);
      }
      if (n != null && n.length === 1)
        break;
    }
    if (r && (n == null || n.length !== 1))
      return { updating: !0 };
    const i = this._pickSpatialReferenceCandidate(n);
    return { spatialReference: i != null ? i.spatialReference : null, viewingMode: i != null ? i.viewingMode : null, updating: !1 };
  }
  get _tileInfoTask() {
    var n, i, s, o, a, l, c;
    if (!this.required.tileInfo)
      return this._get("_tileInfoTask") ?? { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const { layers: t, updating: r } = this._collectLayers([{ parent: (i = (n = this.map) == null ? void 0 : n.call(this)) == null ? void 0 : i.basemap, layers: (a = (o = (s = this.map) == null ? void 0 : s.call(this)) == null ? void 0 : o.basemap) == null ? void 0 : a.baseLayers }, { layers: (c = (l = this.map) == null ? void 0 : l.call(this)) == null ? void 0 : c.layers }]);
    if (t && t.length > 0 && "tileInfo" in t[0]) {
      const h = t[0].tileInfo;
      return { tileInfo: h && h.spatialReference.equals(this.spatialReference) ? h : null, updating: !1 };
    }
    return { updating: r };
  }
  get _heightModelInfoTask() {
    var n, i, s;
    if (!this.required.heightModelInfo || this.suspended && ((n = this._get("_heightModelInfoTask")) != null && n.heightModelInfo))
      return this._get("_heightModelInfoTask") ?? { updating: !1 };
    const { layers: t, updating: r } = this._allLayers;
    for (const o of t)
      if (vle(o)) {
        const a = yle(o);
        if (a)
          return { heightModelInfo: a, vcsWkid: (i = o.spatialReference) == null ? void 0 : i.vcsWkid, latestVcsWkid: (s = o.spatialReference) == null ? void 0 : s.latestVcsWkid, updating: !1 };
      }
    return { updating: r };
  }
  get _extentCandidatesTask() {
    if (this.suspended || !this.required.extent)
      return this._get("_extentCandidatesTask") ?? { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const t = this._allLayers, r = t.updating, n = [];
    for (const i of t.layers) {
      const s = "fullExtents" in i && i.fullExtents || (i.fullExtent != null ? [i.fullExtent] : []), o = this.requiresExtentInSpatialReference ? null : s[0], a = s.find((l) => l.spatialReference.equals(this.spatialReference)) ?? o;
      if (a)
        return { candidates: [{ extent: a, layer: i }], updating: !1 };
      if (this._getSupportedSpatialReferences(i).length > 0)
        for (const l of s)
          n.push({ extent: l, layer: i });
    }
    return { candidates: n, updating: r };
  }
  get _extentTask() {
    const { candidates: t, updating: r } = this._extentCandidatesTask;
    if (r)
      return { updating: r };
    if (t == null || t.length === 0)
      return { updating: !1 };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const n = this._pickExtentCandidate(t), i = this.spatialReference;
    return n.extent.equals(this._projectExtentTask.input) && i.equals(this._projectExtentTask.spatialReference) ? { extent: this._projectExtentTask.output, updating: this._projectExtentTask.task != null && !this._projectExtentTask.task.finished } : (this._projectExtentTask.task != null && (this._projectExtentTask.task = zy(this._projectExtentTask.task)), this._projectExtentTask = { input: n.extent.clone(), output: null, spatialReference: i.clone(), task: Z3(async (s) => {
      try {
        const o = await Y9(n.extent, i, "portalItem" in n.layer ? n.layer.portalItem : void 0, s);
        this._projectExtentTask = { ...this._projectExtentTask, task: null, output: o };
      } catch {
        if (ho(s))
          return;
        this._projectExtentTask = { ...this._projectExtentTask, task: null };
      }
    }) }, { updating: !0 });
  }
  _narrowDownSpatialReferenceCandidates(t, r) {
    if (t == null)
      return r;
    const n = [], i = (s, o) => s != null ? o != null ? s === o && s : s : o;
    for (const s of t)
      for (const o of r) {
        if (!s.spatialReference.equals(o.spatialReference))
          continue;
        const a = i(s.viewingMode, o.viewingMode);
        if (a !== !1) {
          n.push({ spatialReference: s.spatialReference, viewingMode: a });
          break;
        }
      }
    return n.length > 0 ? n : null;
  }
  _pickSpatialReferenceCandidate(t) {
    const r = this.defaultSpatialReference;
    return t == null || t.length < 1 ? r != null ? { spatialReference: r, viewingMode: null } : null : (r != null && t.length > 1 && t.some(({ spatialReference: n }) => n.equals(r)) && (t = t.filter(({ spatialReference: n }) => n.equals(r))), t.length > 1 && t.some(({ viewingMode: n }) => n !== rw.Local) && (t = t.filter(({ viewingMode: n }) => n !== rw.Local)), t[0]);
  }
  _getSupportedSpatialReferences(t) {
    const r = "supportedSpatialReferences" in t && t.supportedSpatialReferences || (t.spatialReference ? [t.spatialReference] : []);
    if (r.length === 0)
      return [];
    const n = [];
    for (const i of r) {
      const s = this.getSpatialReferenceSupport({ spatialReference: i, layer: t });
      if (s != null) {
        const o = s.constraints != null ? s.constraints : [{ spatialReference: i, viewingMode: null }];
        for (const { spatialReference: a, viewingMode: l } of o)
          this.requiresExtentInSpatialReference && this.userSpatialReference != null && !a.equals(this.userSpatialReference) || n.push({ spatialReference: a, viewingMode: l });
      }
    }
    return n;
  }
  _pickExtentCandidate(t) {
    const r = this.spatialReference;
    return t.find(({ extent: n }) => r.equals(n.spatialReference)) || t[0];
  }
  _collectLayers(t) {
    var n;
    if (this._loadMaybe((n = this.map) == null ? void 0 : n.call(this)) !== "loaded")
      return { layers: [], updating: !0 };
    const r = new _le();
    for (const i of t)
      if (this._collectCollection(i, r), r.preloading === this.sourcePreloadCount)
        break;
    return { layers: r.layers, updating: r.updating };
  }
  _collectCollection(t, r) {
    if (t.layers) {
      switch (this._loadMaybe(t.parent)) {
        case "loading":
          return r.updating = !0, void ++r.preloading;
        case "failed":
          return;
      }
      for (const n of t.layers) {
        switch (this._loadMaybe(n)) {
          case "failed":
            continue;
          case "loading":
            r.updating = !0, ++r.preloading;
            break;
          case "loaded":
            r.updating || r.layers.push(n), "layers" in n && this._collectCollection({ layers: n.layers }, r);
        }
        if (r.preloading === this.sourcePreloadCount)
          break;
      }
    }
  }
  _loadMaybe(t) {
    return t && "loadStatus" in t && t.loadStatus != null ? t.loadStatus === "not-loaded" ? (t.load().catch((r) => {
      Fi(r) || console.log(r);
    }), "loading") : t.loadStatus : "loaded";
  }
};
u([d()], Et.prototype, "required", void 0), u([d({ constructOnly: !0 })], Et.prototype, "map", void 0), u([d({ constructOnly: !0 })], Et.prototype, "getSpatialReferenceSupport", void 0), u([d()], Et.prototype, "defaultSpatialReference", void 0), u([d()], Et.prototype, "userSpatialReference", void 0), u([d()], Et.prototype, "sourcePreloadCount", void 0), u([d()], Et.prototype, "priorityCollection", void 0), u([d()], Et.prototype, "requiresExtentInSpatialReference", void 0), u([d()], Et.prototype, "suspended", void 0), u([d({ readOnly: !0 })], Et.prototype, "ready", null), u([d({ readOnly: !0 })], Et.prototype, "heightModelInfoReady", null), u([d({ readOnly: !0 })], Et.prototype, "spatialReference", null), u([d({ readOnly: !0 })], Et.prototype, "extent", null), u([d({ readOnly: !0 })], Et.prototype, "heightModelInfo", null), u([d({ readOnly: !0 })], Et.prototype, "vcsWkid", null), u([d({ readOnly: !0 })], Et.prototype, "latestVcsWkid", null), u([d({ readOnly: !0 })], Et.prototype, "viewingMode", null), u([d({ readOnly: !0 })], Et.prototype, "tileInfo", null), u([d({ readOnly: !0 })], Et.prototype, "mapCollections", null), u([d({ readOnly: !0 })], Et.prototype, "_allLayers", null), u([d({ readOnly: !0 })], Et.prototype, "_spatialReferenceTask", null), u([d({ readOnly: !0 })], Et.prototype, "_tileInfoTask", null), u([d({ readOnly: !0 })], Et.prototype, "_heightModelInfoTask", null), u([d({ readOnly: !0 })], Et.prototype, "_extentCandidatesTask", null), u([d()], Et.prototype, "_extentTask", null), u([d()], Et.prototype, "_projectExtentTask", void 0), Et = u([E("geoscene.views.support.DefaultsFromMap")], Et);
let _le = class {
  constructor() {
    this.layers = new Array(), this.preloading = -1, this.updating = !1;
  }
};
var Um;
let Oe = Um = class extends M_(Uu.EventedMixin(r_(Ae))) {
  constructor(e) {
    super(e), this._userSpatialReference = null, this._cursor = null, this.allLayerViews = new Ky({ getCollections: () => {
      var t, r, n;
      return [(t = this.basemapView) == null ? void 0 : t.baseLayerViews, (r = this.groundView) == null ? void 0 : r.layerViews, this.layerViews, (n = this.basemapView) == null ? void 0 : n.referenceLayerViews];
    }, getChildrenFunction: $le }), this.groundView = null, this.basemapView = null, this.fatalError = null, this.graphics = new wd(), this.analyses = new tw(), this.typeSpecificPreconditionsReady = !0, this.layerViews = new je(), this.magnifier = new N9(), this.padding = { left: 0, top: 0, right: 0, bottom: 0 }, this.ready = !1, this.spatialReferenceWarningDelay = 1e3, this.supportsGround = !0, this.timeExtent = null, this.timeReference = new Uh(), this.type = null, this.scale = null, this.updating = !1, this.initialExtentRequired = !0, this.input = new lle(), this.navigation = new B9(), this.layerViewManager = null, this.analysisViewManager = null, this.isHeightModelInfoRequired = !1, this.width = null, this.height = null, this.resizing = !1, this.suspended = !1, this.viewEvents = new Xae(this), this.persistableViewModels = new je(), this._isValid = !1, this._readyCycleForced = !1, this._currentSpatialReference = null, this.handles.add(ze(() => this.preconditionsReady, (t) => {
      var r, n;
      t ? (this._currentSpatialReference = this.spatialReference, Um.views.add(this)) : (this._currentSpatialReference = null, Um.views.remove(this)), this.notifyChange("spatialReference"), !t && this.ready ? ((r = this.toolViewManager) == null || r.detach(), this.analysisViewManager != null && this.analysisViewManager.detach(), (n = this.layerViewManager) == null || n.clear(), this._teardown()) : t && !this.ready && (this._startup(), this.analysisViewManager != null && this.analysisViewManager.attach(), this.toolViewManager.attach());
    }, Wg));
  }
  initialize() {
    this.addResolvingPromise(this.validate().then(() => (this._isValid = !0, tO(() => this.ready)))), this.basemapView = new Kl({ view: this }), this.layerViewManager = new Gae({ view: this, layerViewImporter: { importLayerView: (e) => this.importLayerView(e), hasLayerViewModule: (e) => this.hasLayerViewModule(e) }, supportsGround: this.supportsGround }), this.toolViewManager = new Bs({ view: this }), this._setupSpatialReferenceLogger(), this.handles.add([ze(() => this.initialExtentRequired, (e) => this.defaultsFromMap.required = { ...this.defaultsFromMap.required, extent: e }, { sync: !0, initial: !0 }), ze(() => this.ready, (e) => {
      this.defaultsFromMap && (this.defaultsFromMap.suspended = e, this.defaultsFromMap.userSpatialReference = e ? this.spatialReference : this._userSpatialReference);
    }, { sync: !0 }), ze(() => this._userSpatialReference, (e) => {
      this.defaultsFromMap && (this.defaultsFromMap.userSpatialReference = e);
    }, { sync: !0, initial: !0 })]);
  }
  _setupSpatialReferenceLogger() {
    let e = null;
    this.handles.add([ze(() => {
      var t;
      return (t = this.defaultsFromMap) == null ? void 0 : t.ready;
    }, (t) => {
      var n;
      const r = ((n = this.map) == null ? void 0 : n.allLayers.length) > 0;
      if (t && !this.spatialReference && r) {
        if (e != null)
          return;
        const i = nl(() => e = zy(e));
        e = Z3(async (s) => {
          try {
            await yF(this.spatialReferenceWarningDelay, null, s);
          } catch {
            return;
          } finally {
            e = null;
          }
          se.getLogger(this).warn("#spatialReference", "no spatial reference could be derived from the currently added map layers");
        }), this.handles.add(i, "spatial-reference-logger-task");
      } else
        this.handles.remove("spatial-reference-logger-task");
    }, { sync: !0 })]);
  }
  destroy() {
    var e, t;
    this.destroyed || (Um.views.remove(this), this.viewEvents.destroy(), this.allLayerViews.destroy(), this.navigation && (this.navigation.destroy(), this._set("navigation", null)), this.graphics = Vt(this.graphics), this.analyses = Vt(this.analyses), this.handles.remove("defaultsFromMap"), this.defaultsFromMap.destroy(), this._set("defaultsFromMap", null), Vt(this.analysisViewManager), this.toolViewManager = Vt(this.toolViewManager), this.layerViewManager = Vt(this.layerViewManager), this.basemapView = Vt(this.basemapView), (e = this.groundView) == null || e.destroy(), (t = this.layerViews) == null || t.forEach((r) => r.destroy()), this.layerViews.length = 0, this.invalidate(), this._emitter.clear(), this.handles.removeAll(), this.map = Vt(this.map));
  }
  _startup() {
    this._set("ready", !0);
  }
  _teardown() {
    this._set("ready", !1);
  }
  whenReady() {
    return Promise.resolve(this);
  }
  toMap() {
    return se.getLogger(this).error("#toMap()", "Not implemented on this instance of View"), null;
  }
  get activeTool() {
    var e;
    return (e = this.toolViewManager) == null ? void 0 : e.activeTool;
  }
  set activeTool(e) {
    this.toolViewManager && (this.toolViewManager.activeTool = e);
  }
  get animation() {
    return this._get("animation");
  }
  set animation(e) {
    this._set("animation", e);
  }
  get center() {
    return null;
  }
  get _defaultsFromMapSettings() {
    return {};
  }
  get defaultsFromMap() {
    return new Et({ required: { tileInfo: !1, heightModelInfo: !1, extent: !1 }, map: () => this.map, getSpatialReferenceSupport: (e) => this.getSpatialReferenceSupport(e), ...this._defaultsFromMapSettings });
  }
  get extent() {
    return this._get("extent");
  }
  set extent(e) {
    this._set("extent", e);
  }
  get heightModelInfo() {
    return this.getDefaultHeightModelInfo();
  }
  get interacting() {
    return this.navigating;
  }
  get navigating() {
    return !1;
  }
  get preconditionsReady() {
    var e;
    return !(this.fatalError || !this._isValid || this._readyCycleForced || !this.map || sl.isLoadable(this.map) && !this.map.loaded || this.width === 0 || this.height === 0 || !this.spatialReference || !this._validateSpatialReference(this.spatialReference) || !this._currentSpatialReference && !((e = this.defaultsFromMap) != null && e.ready) || !this.typeSpecificPreconditionsReady);
  }
  get resolution() {
    return 0;
  }
  set map(e) {
    e !== this._get("map") && (e != null && e.destroyed && (se.getLogger(this).warn("#map", "The provided map is already destroyed", { map: e }), e = null), sl.isLoadable(e) && e.load().catch(() => {
    }), this.constructed && !this.destroyed && (this.forceReadyCycle(), this._currentSpatialReference = null), this._set("map", e));
  }
  get spatialReference() {
    var t, r;
    let e = this._userSpatialReference || this._currentSpatialReference || this.getDefaultSpatialReference() || null;
    return e && ((r = (t = this.defaultsFromMap) == null ? void 0 : t.required) != null && r.heightModelInfo) && (e = e.clone(), e.vcsWkid = this.defaultsFromMap.vcsWkid, e.latestVcsWkid = this.defaultsFromMap.latestVcsWkid), e;
  }
  set spatialReference(e) {
    const t = !tn(e, this._get("spatialReference"));
    this._set("_userSpatialReference", e), t && (this._set("spatialReference", e), this._spatialReferenceChanged(e));
  }
  _spatialReferenceChanged(e) {
  }
  get stationary() {
    return !this.animation && !this.navigating && !this.resizing;
  }
  get tools() {
    var e;
    return (e = this.toolViewManager) == null ? void 0 : e.tools;
  }
  get initialExtent() {
    var e;
    return (e = this.defaultsFromMap) == null ? void 0 : e.extent;
  }
  get cursor() {
    const e = this.toolViewManager ? this.toolViewManager.cursor : null;
    return e ?? (this._cursor || "default");
  }
  set cursor(e) {
    this._cursor = e, this.notifyChange("cursor");
  }
  get size() {
    return [this.width, this.height];
  }
  whenLayerView(e) {
    var t;
    return ((t = this.layerViewManager) == null ? void 0 : t.whenLayerView(e)) ?? Promise.reject();
  }
  getDefaultSpatialReference() {
    var e;
    return (e = this.defaultsFromMap) == null ? void 0 : e.spatialReference;
  }
  getDefaultHeightModelInfo() {
    var e;
    return (this.map && "heightModelInfo" in this.map ? this.map.heightModelInfo : void 0) ?? ((e = this.defaultsFromMap) == null ? void 0 : e.heightModelInfo) ?? null;
  }
  importLayerView(e) {
    throw new G("importLayerView() not implemented");
  }
  hasLayerViewModule(e) {
    return !1;
  }
  async validate() {
  }
  invalidate() {
    this._isValid = !1;
  }
  getSpatialReferenceSupport() {
    return { constraints: null };
  }
  _validateSpatialReference(e) {
    return this.getSpatialReferenceSupport({ spatialReference: e }) != null;
  }
  when(e, t) {
    return this.isResolved() && !this.ready && se.getLogger(this).warn("#when()", "Calling view.when() while the view is no longer ready but was already resolved once will resolve immediately. Use reactiveUtils.whenOnce(() => view.ready).then(...) instead."), super.when(e, t);
  }
  forceReadyCycle() {
    this.ready && (Au(() => this.destroyed || this.preconditionsReady === !1, () => this._readyCycleForced = !1, { once: !0 }), this._readyCycleForced = !0);
  }
  addAndActivateTool(e) {
    this.toolViewManager.tools.add(e), this.activeTool = e;
  }
  tryFatalErrorRecovery() {
    this.fatalError = null;
  }
};
Oe.views = new je(), u([d()], Oe.prototype, "_userSpatialReference", void 0), u([d()], Oe.prototype, "activeTool", null), u([d({ readOnly: !0 })], Oe.prototype, "allLayerViews", void 0), u([d()], Oe.prototype, "groundView", void 0), u([d()], Oe.prototype, "animation", null), u([d()], Oe.prototype, "basemapView", void 0), u([d()], Oe.prototype, "center", null), u([d({ readOnly: !0 })], Oe.prototype, "_defaultsFromMapSettings", null), u([d()], Oe.prototype, "defaultsFromMap", null), u([d()], Oe.prototype, "fatalError", void 0), u([d({ type: Ct })], Oe.prototype, "extent", null), u([d(DT(wd, "graphics"))], Oe.prototype, "graphics", void 0), u([d(DT(tw, "analyses"))], Oe.prototype, "analyses", void 0), u([d({ readOnly: !0, type: O_ })], Oe.prototype, "heightModelInfo", null), u([d({ readOnly: !0 })], Oe.prototype, "interacting", null), u([d({ readOnly: !0 })], Oe.prototype, "navigating", null), u([d({ readOnly: !0, dependsOn: ["fatalError", "_isValid", "_readyCycleForced", "map", "map.loaded?", "width", "height", "spatialReference", "_currentSpatialReference", "defaultsFromMap.ready", "typeSpecificPreconditionsReady"] })], Oe.prototype, "preconditionsReady", null), u([d({ readOnly: !0 })], Oe.prototype, "typeSpecificPreconditionsReady", void 0), u([d({ type: je, readOnly: !0 })], Oe.prototype, "layerViews", void 0), u([d()], Oe.prototype, "resolution", null), u([d({ type: N9 })], Oe.prototype, "magnifier", void 0), u([d({ value: null, type: N8 })], Oe.prototype, "map", null), u([d()], Oe.prototype, "padding", void 0), u([d({ readOnly: !0 })], Oe.prototype, "ready", void 0), u([d({ type: tt })], Oe.prototype, "spatialReference", null), u([d()], Oe.prototype, "spatialReferenceWarningDelay", void 0), u([d()], Oe.prototype, "stationary", null), u([d({ readOnly: !0 })], Oe.prototype, "supportsGround", void 0), u([d({ type: ha })], Oe.prototype, "timeExtent", void 0), u([d({ type: Uh, nonNullable: !0 })], Oe.prototype, "timeReference", void 0), u([d()], Oe.prototype, "tools", null), u([d()], Oe.prototype, "toolViewManager", void 0), u([d({ readOnly: !0 })], Oe.prototype, "type", void 0), u([d({ type: Number })], Oe.prototype, "scale", void 0), u([d({ readOnly: !0 })], Oe.prototype, "updating", void 0), u([d({ readOnly: !0 })], Oe.prototype, "initialExtentRequired", void 0), u([d({ readOnly: !0 })], Oe.prototype, "initialExtent", null), u([d()], Oe.prototype, "cursor", null), u([d({ readOnly: !0 })], Oe.prototype, "input", void 0), u([d({ type: B9, nonNullable: !0 })], Oe.prototype, "navigation", void 0), u([d()], Oe.prototype, "layerViewManager", void 0), u([d()], Oe.prototype, "analysisViewManager", void 0), u([d()], Oe.prototype, "width", void 0), u([d()], Oe.prototype, "height", void 0), u([d({ readOnly: !0 })], Oe.prototype, "resizing", void 0), u([d({ value: null, readOnly: !0 })], Oe.prototype, "size", null), u([d({ readOnly: !0 })], Oe.prototype, "suspended", void 0), u([d({ readOnly: !0 })], Oe.prototype, "viewEvents", void 0), u([d({ readOnly: !0 })], Oe.prototype, "persistableViewModels", void 0), u([d()], Oe.prototype, "_isValid", void 0), u([d()], Oe.prototype, "_readyCycleForced", void 0), u([d()], Oe.prototype, "_currentSpatialReference", void 0), Oe = Um = u([E("geoscene.views.View")], Oe);
const Sle = Oe;
function $le(e) {
  return e.layerViews;
}
let Ql = class extends xb {
  constructor(t) {
    super(t), this.state = "running", this.target = null, this._resolver = null;
  }
  initialize() {
    this._resolver = vs(), this.addResolvingPromise(this._resolver.promise);
  }
  get done() {
    return this.state === "finished" || this.state === "stopped";
  }
  stop() {
    var t;
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "stopped"), (t = this._resolver) == null || t.reject(new G("ViewAnimation stopped")));
  }
  finish() {
    var t;
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "finished"), (t = this._resolver) == null || t.resolve());
  }
  update(t, r) {
    r || (r = pl(t) ? "waiting-for-target" : "running"), this._set("target", t), this._set("state", r);
  }
};
u([d({ readOnly: !0 })], Ql.prototype, "done", null), u([d({ readOnly: !0, type: String })], Ql.prototype, "state", void 0), u([d()], Ql.prototype, "target", void 0), Ql = u([E("geoscene.views.ViewAnimation")], Ql), function(e) {
  e.State = { RUNNING: "running", STOPPED: "stopped", FINISHED: "finished", WAITING_FOR_TARGET: "waiting-for-target" };
}(Ql || (Ql = {}));
const qT = Ql;
function Yc(e, t, r, n) {
  const i = 3 * e, s = 3 * (r - e) - i, o = 1 - i - s, a = 3 * t, l = 3 * (n - t) - a, c = 1 - a - l;
  function h(g) {
    return ((o * g + s) * g + i) * g;
  }
  function f(g) {
    return ((c * g + l) * g + a) * g;
  }
  function m(g) {
    return (3 * o * g + 2 * s) * g + i;
  }
  function y(g, v) {
    let b, w, x, $, T, C;
    for (x = g, C = 0; C < 8; C++) {
      if ($ = h(x) - g, Math.abs($) < v)
        return x;
      if (T = m(x), Math.abs(T) < 1e-6)
        break;
      x -= $ / T;
    }
    if (b = 0, w = 1, x = g, x < b)
      return b;
    if (x > w)
      return w;
    for (; b < w; ) {
      if ($ = h(x), Math.abs($ - g) < v)
        return x;
      g > $ ? b = x : w = x, x = 0.5 * (w - b) + b;
    }
    return x;
  }
  return function(g, v = 1e-6) {
    return f(y(g, v));
  };
}
const xle = /^cubic-bezier\((.*)\)/, os = {};
function Tle(e) {
  let t = os[e] || null;
  if (!t) {
    const r = xle.exec(e);
    if (r) {
      const n = r[1].split(",").map((i) => parseFloat(i.trim()));
      n.length !== 4 || n.some((i) => isNaN(i)) || (t = Yc.apply(Yc, n));
    }
  }
  return t;
}
os.ease = Yc(0.25, 0.1, 0.25, 1), os.linear = Yc(0, 0, 1, 1), os.easeIn = os["ease-in"] = Yc(0.42, 0, 1, 1), os.easeOut = os["ease-out"] = Yc(0, 0, 0.58, 1), os.easeInOut = os["ease-in-out"] = Yc(0.42, 0, 0.58, 1);
function Ele(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function Ile(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function Mle(e, t, r, n, i, s, o) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e[4] = s, e[5] = o, e;
}
function mO(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5];
  let l = r * s - n * i;
  return l ? (l = 1 / l, e[0] = s * l, e[1] = -n * l, e[2] = -i * l, e[3] = r * l, e[4] = (i * a - s * o) * l, e[5] = (n * o - r * a) * l, e) : null;
}
function Ole(e) {
  return e[0] * e[3] - e[1] * e[2];
}
function Q9(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = r[0], h = r[1], f = r[2], m = r[3], y = r[4], g = r[5];
  return e[0] = n * c + s * h, e[1] = i * c + o * h, e[2] = n * f + s * m, e[3] = i * f + o * m, e[4] = n * y + s * g + a, e[5] = i * y + o * g + l, e;
}
function C_(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = Math.sin(r), h = Math.cos(r);
  return e[0] = n * h + s * c, e[1] = i * h + o * c, e[2] = n * -c + s * h, e[3] = i * -c + o * h, e[4] = a, e[5] = l, e;
}
function yO(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = r[0], h = r[1];
  return e[0] = n * c, e[1] = i * c, e[2] = s * h, e[3] = o * h, e[4] = a, e[5] = l, e;
}
function ug(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = r[0], h = r[1];
  return e[0] = n, e[1] = i, e[2] = s, e[3] = o, e[4] = n * c + s * h + a, e[5] = i * c + o * h + l, e;
}
function X9(e, t) {
  const r = Math.sin(t), n = Math.cos(t);
  return e[0] = n, e[1] = r, e[2] = -r, e[3] = n, e[4] = 0, e[5] = 0, e;
}
function eV(e, t) {
  return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e;
}
function gO(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e;
}
function Cle(e) {
  return "mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")";
}
function kle(e) {
  return Math.sqrt(e[0] ** 2 + e[1] ** 2 + e[2] ** 2 + e[3] ** 2 + e[4] ** 2 + e[5] ** 2 + 1);
}
function Ale(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e;
}
function tV(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e;
}
function Ple(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e;
}
function Rle(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e;
}
function Lle(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5];
}
function Nle(e, t) {
  const r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = t[0], c = t[1], h = t[2], f = t[3], m = t[4], y = t[5], g = Es();
  return Math.abs(r - l) <= g * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - c) <= g * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(i - h) <= g * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(s - f) <= g * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(o - m) <= g * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - y) <= g * Math.max(1, Math.abs(a), Math.abs(y));
}
const Fle = Q9, Dle = tV;
Object.freeze(Object.defineProperty({ __proto__: null, add: Ale, copy: Ele, determinant: Ole, equals: Nle, exactEquals: Lle, frob: kle, fromRotation: X9, fromScaling: eV, fromTranslation: gO, identity: Ile, invert: mO, mul: Fle, multiply: Q9, multiplyScalar: Ple, multiplyScalarAndAdd: Rle, rotate: C_, scale: yO, set: Mle, str: Cle, sub: Dle, subtract: tV, translate: ug }, Symbol.toStringTag, { value: "Module" }));
function Mu() {
  return [1, 0, 0, 1, 0, 0];
}
function jle(e) {
  return [e[0], e[1], e[2], e[3], e[4], e[5]];
}
function Vle(e, t, r, n, i, s) {
  return [e, t, r, n, i, s];
}
function zle(e, t) {
  return new Float64Array(e, t, 6);
}
Object.freeze(Object.defineProperty({ __proto__: null, clone: jle, create: Mu, createView: zle, fromValues: Vle }, Symbol.toStringTag, { value: "Module" }));
function cg(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function Qr(e, t, r) {
  return e[0] = t, e[1] = r, e;
}
function rV(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;
}
function dg(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;
}
function nV(e, t, r) {
  return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;
}
function iV(e, t, r) {
  return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;
}
function Ule(e, t) {
  return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;
}
function Ble(e, t) {
  return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;
}
function qle(e, t, r) {
  return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;
}
function Gle(e, t, r) {
  return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;
}
function Hle(e, t) {
  return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;
}
function Zg(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e;
}
function Wle(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;
}
function Kg(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1];
  return Math.sqrt(r * r + n * n);
}
function nw(e, t) {
  const r = t[0] - e[0], n = t[1] - e[1];
  return r * r + n * n;
}
function iw(e) {
  const t = e[0], r = e[1];
  return Math.sqrt(t * t + r * r);
}
function sV(e) {
  const t = e[0], r = e[1];
  return t * t + r * r;
}
function oV(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e;
}
function Jle(e, t) {
  return e[0] = 1 / t[0], e[1] = 1 / t[1], e;
}
function GT(e, t) {
  const r = t[0], n = t[1];
  let i = r * r + n * n;
  return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i), e;
}
function aV(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function lV(e, t, r) {
  const n = t[0] * r[1] - t[1] * r[0];
  return e[0] = e[1] = 0, e[2] = n, e;
}
function Zle(e, t, r, n) {
  const i = t[0], s = t[1];
  return e[0] = i + n * (r[0] - i), e[1] = s + n * (r[1] - s), e;
}
function Kle(e, t) {
  t = t || 1;
  const r = 2 * l_() * Math.PI;
  return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;
}
function Yle(e, t, r) {
  const n = t[0], i = t[1];
  return e[0] = r[0] * n + r[2] * i, e[1] = r[1] * n + r[3] * i, e;
}
function Ho(e, t, r) {
  const n = t[0], i = t[1];
  return e[0] = r[0] * n + r[2] * i + r[4], e[1] = r[1] * n + r[3] * i + r[5], e;
}
function Qle(e, t, r) {
  const n = t[0], i = t[1];
  return e[0] = r[0] * n + r[3] * i + r[6], e[1] = r[1] * n + r[4] * i + r[7], e;
}
function Xle(e, t, r) {
  const n = t[0], i = t[1];
  return e[0] = r[0] * n + r[4] * i + r[12], e[1] = r[1] * n + r[5] * i + r[13], e;
}
function eue(e, t, r, n) {
  const i = t[0] - r[0], s = t[1] - r[1], o = Math.sin(n), a = Math.cos(n);
  return e[0] = i * a - s * o + r[0], e[1] = i * o + s * a + r[1], e;
}
function tue(e, t) {
  const r = e[0], n = e[1], i = t[0], s = t[1];
  let o = r * r + n * n;
  o > 0 && (o = 1 / Math.sqrt(o));
  let a = i * i + s * s;
  a > 0 && (a = 1 / Math.sqrt(a));
  const l = (r * i + n * s) * o * a;
  return l > 1 ? 0 : l < -1 ? Math.PI : Math.acos(l);
}
function rue(e) {
  return "vec2(" + e[0] + ", " + e[1] + ")";
}
function nue(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function iue(e, t) {
  const r = e[0], n = e[1], i = t[0], s = t[1], o = Es();
  return Math.abs(r - i) <= o * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(n - s) <= o * Math.max(1, Math.abs(n), Math.abs(s));
}
function sue(e, t, r, n, i) {
  let s = t[0] - r[0], o = t[1] - r[1];
  const a = (n[0] * s + n[1] * o) * (i - 1);
  return s = n[0] * a, o = n[1] * a, e[0] = t[0] + s, e[1] = t[1] + o, e;
}
const oue = iw, vO = dg, aue = nV, lue = iV, uue = Kg, cue = nw, due = sV;
Object.freeze(Object.defineProperty({ __proto__: null, add: rV, angle: tue, ceil: Ule, copy: cg, cross: lV, dist: uue, distance: Kg, div: lue, divide: iV, dot: aV, equals: iue, exactEquals: nue, floor: Ble, inverse: Jle, len: oue, length: iw, lerp: Zle, max: Gle, min: qle, mul: aue, multiply: nV, negate: oV, normalize: GT, projectAndScale: sue, random: Kle, rotate: eue, round: Hle, scale: Zg, scaleAndAdd: Wle, set: Qr, sqrDist: cue, sqrLen: due, squaredDistance: nw, squaredLength: sV, str: rue, sub: vO, subtract: dg, transformMat2: Yle, transformMat2d: Ho, transformMat3: Qle, transformMat4: Xle }, Symbol.toStringTag, { value: "Module" }));
function yr() {
  return [0, 0];
}
function pue(e) {
  return [e[0], e[1]];
}
function Yg(e, t) {
  return [e, t];
}
function hue(e) {
  const t = yr(), r = Math.min(2, e.length);
  for (let n = 0; n < r; ++n)
    t[n] = e[n];
  return t;
}
function fue(e, t) {
  return new Float64Array(e, t, 2);
}
function uV() {
  return yr();
}
function cV() {
  return Yg(1, 1);
}
function dV() {
  return Yg(1, 0);
}
function pV() {
  return Yg(0, 1);
}
const mue = uV(), yue = cV(), gue = dV(), vue = pV();
Object.freeze(Object.defineProperty({ __proto__: null, ONES: yue, UNIT_X: gue, UNIT_Y: vue, ZEROS: mue, clone: pue, create: yr, createView: fue, fromArray: hue, fromValues: Yg, ones: cV, unitX: dV, unitY: pV, zeros: uV }, Symbol.toStringTag, { value: "Module" }));
const hV = 96, fV = 39.37, bue = 180 / Math.PI;
function mV(e) {
  return e.wkid ? e : e.spatialReference || tt.WGS84;
}
function bO(e, t) {
  return t.type ? Qr(e, t.x, t.y) : cg(e, t);
}
function yV(e) {
  return Yd(e);
}
function Sh(e, t) {
  const r = Math.max(1, t[0]), n = Math.max(1, t[1]);
  return Math.max(e.width / r, e.height / n) * Mue(e.spatialReference);
}
async function Bm(e, t, r, n) {
  var a, l;
  let i, s;
  if (!e || Array.isArray(e) && !e.length)
    return null;
  if (je.isCollection(e) && (e = e.toArray()), Array.isArray(e) && e.length && typeof e[0] == "object") {
    const c = e.every((m) => "attributes" in m), h = e.some((m) => !m.geometry);
    let f = e;
    if (c && h && t && t.allLayerViews) {
      const m = /* @__PURE__ */ new Map();
      for (const b of e) {
        const w = b.layer, x = m.get(w) || [], $ = b.attributes[w.objectIdField];
        $ != null && x.push($), m.set(w, x);
      }
      const y = [];
      m.forEach((b, w) => {
        const x = t.allLayerViews.find(($) => $.layer.id === w.id);
        if (x && "queryFeatures" in x) {
          const $ = w.createQuery();
          $.objectIds = b, $.returnGeometry = !0, y.push(x.queryFeatures($));
        }
      });
      const g = await Promise.all(y), v = [];
      for (const b of g)
        if (b && b.features && b.features.length)
          for (const w of b.features)
            w.geometry != null && v.push(w.geometry);
      f = v;
    }
    for (const m of f)
      n = await Bm(m, t, r, n);
    return n;
  }
  if (Array.isArray(e) && e.length === 2 && typeof e[0] == "number" && typeof e[1] == "number")
    i = new Re(e);
  else if (e instanceof Bu)
    i = e;
  else if ("geometry" in e) {
    if (e.geometry)
      i = e.geometry;
    else if (e.layer) {
      const c = e.layer, h = t.allLayerViews.find((f) => f.layer.id === c.id);
      if (h && "queryFeatures" in h) {
        const f = c.createQuery();
        f.objectIds = [e.attributes[c.objectIdField]], f.returnGeometry = !0;
        const m = await h.queryFeatures(f);
        i = (l = (a = m == null ? void 0 : m.features) == null ? void 0 : a[0]) == null ? void 0 : l.geometry;
      }
    }
  }
  if (i == null || (s = i.type === "point" ? new Ct({ xmin: i.x, ymin: i.y, xmax: i.x, ymax: i.y, spatialReference: i.spatialReference }) : i.extent, !s))
    return null;
  rp() || ll(s.spatialReference, r) || await Ru();
  const o = Ju(s, r);
  return o ? n = n ? n.union(o) : o : null;
}
function wue(e) {
  if (e && (!Array.isArray(e) || typeof e[0] != "number") && (typeof e == "object" || Array.isArray(e) && typeof e[0] == "object")) {
    if ("layer" in e && e.layer && e.layer.minScale && e.layer.maxScale) {
      const t = e.layer;
      return { min: t.minScale, max: t.maxScale };
    }
    if (Array.isArray(e) && e.length && e.every((t) => "layer" in t)) {
      let t = 0, r = 0;
      for (const n of e) {
        const i = n.layer;
        i && i.minScale && i.maxScale && (t = i.minScale < t ? i.minScale : t, r = i.maxScale > r ? i.maxScale : r);
      }
      return t && r ? { min: t, max: r } : null;
    }
  }
}
function pS(e, t) {
  return tn(mV(e), t) ? e : Ju(e, t);
}
async function _ue(e, t) {
  if (!e || !t)
    return new Qo({ targetGeometry: new Re(), scale: 0, rotation: 0 });
  let r = t.spatialReference;
  const { constraints: n, padding: i, viewpoint: s, size: o } = t, a = [i ? o[0] - i.left - i.right : o[0], i ? o[1] - i.top - i.bottom : o[1]];
  let l = null;
  e instanceof Qo ? l = e : e.viewpoint ? l = e.viewpoint : e.target && e.target.declaredClass === "geoscene.Viewpoint" && (l = e.target);
  let c = null;
  l && l.targetGeometry ? c = l.targetGeometry : e instanceof Ct ? c = e : (e || e && ("center" in e || "extent" in e || "target" in e)) && (c = await Bm(e.center, t, r) || await Bm(e.extent, t, r) || await Bm(e.target, t, r) || await Bm(e, t, r)), !c && s && s.targetGeometry ? c = s.targetGeometry : !c && t.extent && (c = t.extent), r || (r = mV(t.spatialReference || t.extent || c)), rp() || tn(c.spatialReference, r) || ll(c, r) || await Ru();
  const h = pS(c.center ?? c, r);
  let f = 0;
  if (l && l.targetGeometry != null && l.targetGeometry.type === "point")
    f = l.scale;
  else if ("scale" in e && e.scale)
    f = e.scale;
  else if ("zoom" in e && e.zoom !== -1 && n && n.effectiveLODs)
    f = n.zoomToScale(e.zoom);
  else if (Array.isArray(c) || c.type === "point" || c.type === "extent" && c.width === 0 && c.height === 0) {
    const v = pS(t.extent, r);
    f = v != null ? Sh(v, a) : t.extent ? Sh(t.extent, a) : s.scale;
  } else
    f = Sh(pS(c.extent, r), a);
  const m = wue(e);
  m && (m.min && m.min > f ? f = m.min : m.max && m.max < f && (f = m.max));
  let y = 0;
  l ? y = l.rotation : e.hasOwnProperty("rotation") ? y = e.rotation : s && (y = s.rotation);
  let g = new Qo({ targetGeometry: h, scale: f, rotation: y });
  return n && (g = n.fit(g), n.constrainByGeometry(g), n.rotationEnabled || (g.rotation = y)), g;
}
function vo(e, t) {
  const r = e.targetGeometry, n = t.targetGeometry;
  return r.x = n.x, r.y = n.y, r.spatialReference = n.spatialReference, e.scale = t.scale, e.rotation = t.rotation, e;
}
function Sue(e, t, r) {
  return r ? Qr(e, 0.5 * (t[0] - r.right + r.left), 0.5 * (t[1] - r.bottom + r.top)) : Zg(e, t, 0.5);
}
const $ue = function() {
  const e = yr();
  return function(t, r, n) {
    const i = r.targetGeometry;
    bO(e, i);
    const s = 0.5 * vf(r);
    return t.xmin = e[0] - s * n[0], t.ymin = e[1] - s * n[1], t.xmax = e[0] + s * n[0], t.ymax = e[1] + s * n[1], t.spatialReference = i.spatialReference, t;
  };
}();
function xue(e, t, r, n, i) {
  var s;
  return HT(e, t, r.center), e.scale = Sh(r, n), (s = i == null ? void 0 : i.constraints) == null || s.constrain(e), e;
}
function Tue(e, t, r, n) {
  return SO(e, t, r, n), mO(e, e);
}
const gV = function() {
  const e = yr();
  return function(t, r, n) {
    return vO(t, Oue(t, r), Sue(e, r, n));
  };
}(), Eue = function() {
  const e = Mu(), t = yr();
  return function(r, n, i, s) {
    const o = vf(n), a = wO(n);
    return Qr(t, o, o), eV(e, t), C_(e, e, a), ug(e, e, gV(t, i, s)), ug(e, e, [0, s.top - s.bottom]), Qr(r, e[4], e[5]);
  };
}();
function vf(e) {
  return e.scale * Iue(e.targetGeometry);
}
function Iue(e) {
  return e != null && en(e.spatialReference) ? 1 / (yV(e.spatialReference) * fV * hV) : 1;
}
function wO(e) {
  return gM(e.rotation) || 0;
}
function Mue(e) {
  return en(e) ? yV(e) * fV * hV : 1;
}
function Oue(e, t) {
  return Zg(e, t, 0.5);
}
const _O = function() {
  const e = yr(), t = yr(), r = yr();
  return function(n, i, s, o, a, l) {
    return oV(e, i), Zg(t, s, 0.5 * l), Qr(r, 1 / o * l, -1 / o * l), gO(n, t), a && C_(n, n, a), yO(n, n, r), ug(n, n, e), n;
  };
}(), SO = function() {
  const e = yr();
  return function(t, r, n, i) {
    const s = vf(r), o = wO(r);
    return bO(e, r.targetGeometry), _O(t, e, n, s, o, i);
  };
}(), Cue = function() {
  const e = yr();
  return function(t, r, n, i) {
    const s = vf(r);
    return bO(e, r.targetGeometry), _O(t, e, n, s, 0, i);
  };
}();
function kue(e) {
  const t = el(e);
  return t ? t.valid[1] - t.valid[0] : 0;
}
function Aue(e, t) {
  return Math.round(kue(e) / t);
}
const Pue = function() {
  const e = yr(), t = yr(), r = [0, 0, 0];
  return function(n, i, s) {
    dg(e, n, i), GT(e, e), dg(t, n, s), GT(t, t), lV(r, e, t);
    let o = Math.acos(aV(e, t) / (iw(e) * iw(t))) * bue;
    return r[2] < 0 && (o = -o), isNaN(o) && (o = 0), o;
  };
}(), Rue = function() {
  const e = yr();
  return function(t, r, n, i) {
    const s = t.targetGeometry;
    return vo(t, r), Eue(e, r, n, i), s.x += e[0], s.y += e[1], t;
  };
}(), HT = function(e, t, r) {
  vo(e, t);
  const n = e.targetGeometry;
  return n.x = r.x, n.y = r.y, n.spatialReference = r.spatialReference, e;
}, Lue = function() {
  const e = yr();
  return function(t, r, n, i, s) {
    s || (s = "center"), vO(e, n, i), Zg(e, e, 0.5);
    const o = e[0], a = e[1];
    switch (s) {
      case "center":
        Qr(e, 0, 0);
        break;
      case "left":
        Qr(e, -o, 0);
        break;
      case "top":
        Qr(e, 0, a);
        break;
      case "right":
        Qr(e, o, 0);
        break;
      case "bottom":
        Qr(e, 0, -a);
        break;
      case "top-left":
        Qr(e, -o, a);
        break;
      case "bottom-left":
        Qr(e, -o, -a);
        break;
      case "top-right":
        Qr(e, o, a);
        break;
      case "bottom-right":
        Qr(e, o, -a);
    }
    return k_(t, r, e), t;
  };
}();
function TLe(e, t, r) {
  return vo(e, t), e.rotation += r, e;
}
function Nue(e, t, r) {
  return vo(e, t), e.rotation = r, e;
}
const Fue = function() {
  const e = yr();
  return function(t, r, n, i, s) {
    return vo(t, r), isNaN(n) || n === 0 || (bV(e, i, r, s), t.scale = r.scale * n, wV(e, e, t, s), k_(t, t, Qr(e, e[0] - i[0], i[1] - e[1]))), t;
  };
}();
function QP(e, t, r) {
  return vo(e, t), e.scale = r, e;
}
const vV = function() {
  const e = yr();
  return function(t, r, n, i, s, o) {
    return vo(t, r), isNaN(n) || n === 0 || (bV(e, s, r, o), t.scale = r.scale * n, t.rotation += i, wV(e, e, t, o), k_(t, t, Qr(e, e[0] - s[0], s[1] - e[1]))), t;
  };
}(), ELe = function() {
  const e = yr(), t = yr();
  return function(r, n, i, s, o, a, l) {
    return gV(t, a, l), rV(e, o, t), s ? vV(r, n, i, s, e, a) : Fue(r, n, i, e, a);
  };
}(), bV = function() {
  const e = Mu();
  return function(t, r, n, i) {
    return Ho(t, r, Tue(e, n, i, 1));
  };
}(), wV = function() {
  const e = Mu();
  return function(t, r, n, i) {
    return Ho(t, r, SO(e, n, i, 1));
  };
}(), k_ = function() {
  const e = yr(), t = Mu();
  return function(r, n, i) {
    vo(r, n);
    const s = vf(n), o = r.targetGeometry;
    return X9(t, wO(n)), yO(t, t, Yg(s, s)), Ho(e, i, t), o.x += e[0], o.y += e[1], r;
  };
}();
let Due = class {
  constructor(t, r, n, i) {
    const s = t.targetGeometry, o = r.targetGeometry;
    i ? typeof i == "string" && (i = Tle(i) || os.ease) : i = os.ease, this.easing = i, this.duration = n, this.sCenterX = s.x, this.sCenterY = s.y, this.sScale = t.scale, this.sRotation = t.rotation, this.tCenterX = o.x, this.tCenterY = o.y, this.tScale = r.scale, this.tRotation = r.rotation, this.dCenterX = this.tCenterX - this.sCenterX, this.dCenterY = this.tCenterY - this.sCenterY, this.dScale = this.tScale - this.sScale, this.dRotation = this.tRotation - this.sRotation, this.dRotation > 180 ? this.dRotation -= 360 : this.dRotation < -180 && (this.dRotation += 360);
  }
  applyRatio(t, r) {
    const n = this.easing(r);
    let i, s, o, a;
    r >= 1 ? (i = this.tCenterX, s = this.tCenterY, o = this.tRotation, a = this.tScale) : (i = this.sCenterX + n * this.dCenterX, s = this.sCenterY + n * this.dCenterY, o = this.sRotation + n * this.dRotation, a = this.sScale + n * this.dScale), t.targetGeometry.x = i, t.targetGeometry.y = s, t.scale = a, t.rotation = o;
  }
}, Ca = class extends Ae {
  constructor(t) {
    super(t), this.updateFunction = null, this.animation = null, this.duration = 200, this.transition = null, this.easing = os.ease, this.view = null, this.viewpoint = new Qo({ targetGeometry: new Re(), scale: 0, rotation: 0 }), this._updateTask = Ah({ postRender: this._postRender.bind(this) }), this._updateTask.pause();
  }
  destroy() {
    this._updateTask = tr(this._updateTask);
  }
  animate(t, r, n) {
    this.stop();
    const i = this.viewpoint;
    vo(i, r), this.transition = new Due(this.viewpoint, t.target, n && n.duration || this.duration, n && n.easing || this.easing);
    const s = () => {
      var o, a;
      this.animation === t && this._updateTask && (t.state === "finished" && ((o = this.transition) == null || o.applyRatio(this.viewpoint, 1), (a = this.view) != null && a.state && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t.when(s, s), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t, t;
  }
  animateContinous(t, r) {
    this.stop(), this.updateFunction = r, this.viewpoint = t;
    const n = new qT({ target: t.clone() }), i = () => {
      this.animation === n && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return n.when(i, i), this._startTime = performance.now(), this._updateTask.resume(), this.animation = n, n;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t) {
    var n, i;
    const r = this.animation;
    if (r && r.state !== qT.State.STOPPED) {
      if (this.updateFunction)
        this.updateFunction(this.viewpoint, t.deltaTime);
      else {
        const s = this.transition, o = (performance.now() - this._startTime) / s.duration, a = o >= 1;
        s.applyRatio(this.viewpoint, o), a && ((n = this.animation) == null || n.finish());
      }
      (i = this.view) != null && i.state && (this.view.state.viewpoint = this.viewpoint.clone());
    } else
      this._updateTask.pause();
  }
};
u([d()], Ca.prototype, "animation", void 0), u([d()], Ca.prototype, "duration", void 0), u([d()], Ca.prototype, "transition", void 0), u([d()], Ca.prototype, "easing", void 0), u([d()], Ca.prototype, "view", void 0), u([d()], Ca.prototype, "viewpoint", void 0), Ca = u([E("geoscene.views.2d.AnimationManager")], Ca);
const jue = Ca;
let Vue = class {
  constructor(t) {
    this.view = t, this._stationaryHandle = null, this._frameTaskHandle = null, this._updateParameters = null, this._updateRequested = !1, this.stationary = !0, this.animationInProgress = !1, this.prepare = () => {
      this._updateParameters && (this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions);
    }, this.update = () => {
      var o, a;
      if (this._updateRequested = !1, (o = this.view) == null ? void 0 : o.destroyed)
        return;
      const { allLayerViews: r, graphicsView: n, labelManager: i, state: { id: s } } = this.view;
      r.forEach(this._updateLayerView, this), i != null && (i.lastUpdateId !== s && (i.viewChange(), i.lastUpdateId = s), i.updateRequested && i.processUpdate(this._updateParameters)), n != null && (n.lastUpdateId !== s && (n.viewChange(), n.lastUpdateId = s), n.updateRequested && n.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || ((a = this._frameTaskHandle) == null || a.pause());
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    if (this._frameTaskHandle)
      return;
    const t = this.view;
    this.stationary = t.stationary, this._updateParameters = { state: t.state, pixelRatio: window.devicePixelRatio, stationary: this.stationary, renderingOptions: t.renderingOptions }, this._stationaryHandle = ze(() => t.stationary, (r) => {
      this.stationary = r, this.requestFrame();
    }), this._frameTaskHandle = Ah(this), this.requestUpdate();
  }
  stop() {
    var t;
    this._frameTaskHandle && (this._updateRequested = !1, (t = this._stationaryHandle) == null || t.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = !0, this.animationInProgress = !1);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = !0, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(t) {
    var i;
    if (!t.attached)
      return void this.requestUpdate();
    const r = this.view.state, n = t.lastUpdateId;
    n != null && (this.stationary || t.moving) || (t.moving = !0, t.moveStart()), n !== r.id && t.viewChange(), this.stationary && t.moving && (t.moving = !1, t.moveEnd()), t.lastUpdateId = r.id, t.updateRequested && t.processUpdate(this._updateParameters), "layerViews" in t && ((i = t.layerViews) == null || i.forEach(this._updateLayerView, this));
  }
};
function or() {
  return Promise.all([import("./webglDeps-SoGCl3pt.js"), import("./mapViewDeps-VYQCxM0W.js")]);
}
const Yf = () => or().then(() => import("./TileLayerView2D-bWB4h7aF.js")), pp = () => or().then(() => import("./FeatureLayerView2D-dw5mIx3P.js")), XP = { "base-dynamic": () => or().then(() => import("./BaseDynamicLayerView2D-6njZPwAi.js")), "base-tile": Yf, "bing-maps": Yf, csv: pp, "geo-rss": () => or().then(() => import("./GeoRSSLayerView2D-eDbVoUvu.js")), feature: pp, geojson: pp, graphics: () => or().then(() => import("./GraphicsLayerView2D-0s-rK2fU.js")), group: () => or().then(() => import("./GroupLayerView2D-OHWZ1-r_.js")), imagery: () => or().then(() => import("./ImageryLayerView2D-OGCxkvpK.js")), "imagery-tile": () => or().then(() => import("./ImageryTileLayerView2D-7e0opR_3.js")), kml: () => or().then(() => import("./KMLLayerView2D-1CjWMft8.js")), "knowledge-graph": () => or().then(() => import("./KnowledgeGraphLayerView2D-GfCgDg5C.js")), "link-chart": () => or().then(() => import("./KnowledgeGraphLayerView2D-GfCgDg5C.js")), "knowledge-graph-sublayer": pp, "map-image": () => or().then(() => import("./MapImageLayerView2D-2C8jLmh4.js")), "map-notes": () => or().then(() => import("./MapNotesLayerView2D-E4_6DU4G.js")), media: () => or().then(() => import("./MediaLayerView2D-o3I_jUFV.js")), "ogc-feature": () => or().then(() => import("./OGCFeatureLayerView2D-mQWRTISf.js")), "open-street-map": Yf, "oriented-imagery": pp, route: () => or().then(() => import("./RouteLayerView2D-pA20o5rA.js")), stream: () => or().then(() => import("./StreamLayerView2D-2HzyS3Zb.js")), "subtype-group": () => or().then(() => import("./SubtypeGroupLayerView2D-D3si76xg.js")), tile: Yf, "vector-tile": () => or().then(() => import("./VectorTileLayerView2D-f-OTM19Q.js")), video: () => or().then(() => import("./VideoLayerView2D-WYjVDD1u.js")), wcs: () => or().then(() => import("./ImageryTileLayerView2D-7e0opR_3.js")), "web-tile": Yf, wfs: pp, wms: () => or().then(() => import("./WMSLayerView2D-f-IQ5HWa.js")), wmts: () => or().then(() => import("./WMTSLayerView2D-zW9hBEAC.js")), "line-of-sight": null, "base-elevation": null, "building-scene": null, dimension: null, elevation: null, "integrated-mesh": null, "point-cloud": null, voxel: null, scene: null, unknown: null, unsupported: null };
function zue(e) {
  const t = e.declaredClass ? e.declaredClass.slice(e.declaredClass.lastIndexOf(".") + 1) : "Unknown", r = t.replaceAll(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new G(`${r}:view-not-supported`, `${t} is not supported in 2D`);
}
const eR = { hasLayerViewModule: (e) => XP[e.type] != null, importLayerView: (e) => {
  const t = XP[e.type];
  if (t == null)
    throw zue(e);
  return t(e);
} };
function Uue(e, t) {
  const { spatialReference: r } = t, n = [t.x, t.y];
  let i = Number.POSITIVE_INFINITY, s = 0, o = 0;
  const a = [0, 0], l = e.type === "extent" ? [[[e.xmin, e.ymin], [e.xmin, e.ymax], [e.xmax, e.ymax], [e.xmax, e.ymin], [e.xmin, e.ymin]]] : e.rings;
  for (const c of l)
    for (let h = 0; h < c.length - 1; h++) {
      wX(a, n, c, h);
      const f = Kg(n, a);
      f < i && (i = f, s = a[0], o = a[1]);
    }
  return { coordinate: new Re({ x: s, y: o, spatialReference: r }), distance: i };
}
var WT;
let Qc = WT = class extends TM(Ae) {
  constructor(e) {
    super(e), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (this.geometry == null || !this.spatialReference)
      return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference))
      try {
        return Ju(this.geometry, this.spatialReference);
      } catch (e) {
        return se.getLogger(this).error("#constraints.geometry", "could not project the geometry to the view's spatial reference", { geometry: this.geometry, spatialReference: this.spatialReference, error: e }), null;
      }
    return this.geometry;
  }
  constrain(e, t) {
    if (this.normalizedGeometry == null)
      return e;
    const r = e.targetGeometry;
    if (this.normalizedGeometry.type === "extent" ? a_(this.normalizedGeometry, r) : E6(this.normalizedGeometry, r))
      return e;
    const { coordinate: n } = Uue(this.normalizedGeometry, r);
    return n && (e.targetGeometry = n), e;
  }
  clone() {
    var e, t;
    return new WT({ geometry: (e = this.geometry) == null ? void 0 : e.clone(), spatialReference: (t = this.spatialReference) == null ? void 0 : t.clone() });
  }
};
u([d({ constructOnly: !0 })], Qc.prototype, "geometry", void 0), u([d({ readOnly: !0 })], Qc.prototype, "normalizedGeometry", null), u([d({ constructOnly: !0 })], Qc.prototype, "spatialReference", void 0), Qc = WT = u([E("geoscene.views.2d.constraints.GeometryConstraint")], Qc);
var JT;
let qm = JT = class extends TM(Ae) {
  constructor() {
    super(...arguments), this.enabled = !0, this.rotationEnabled = !0;
  }
  constrain(e, t) {
    return this.enabled && t && (this.rotationEnabled || (e.rotation = t.rotation)), e;
  }
  clone() {
    return new JT({ enabled: this.enabled, rotationEnabled: this.rotationEnabled });
  }
};
u([d()], qm.prototype, "enabled", void 0), u([d()], qm.prototype, "rotationEnabled", void 0), qm = JT = u([E("geoscene.views.2d.constraints.RotationConstraint")], qm);
const _V = qm;
var ZT;
let ri = ZT = class extends TM(Ae) {
  constructor(e) {
    super(e), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = !0;
  }
  initialize() {
    let e, { lods: t, minScale: r, maxScale: n, minZoom: i, maxZoom: s } = this, o = -1, a = -1, l = !1, c = !1;
    if (r !== 0 && n !== 0 && r < n && ([r, n] = [n, r]), !t || !t.length)
      return this._set("effectiveMinScale", r), void this._set("effectiveMaxScale", n);
    t = t.map((h) => h.clone()), t.sort((h, f) => f.scale - h.scale), t.forEach((h, f) => h.level = f);
    for (const h of t)
      !l && r > 0 && r >= h.scale && (o = h.level, l = !0), !c && n > 0 && n >= h.scale && (a = e ? e.level : -1, c = !0), e = h;
    i === -1 && (i = r === 0 ? 0 : o), s === -1 && (s = n === 0 ? t.length - 1 : a), i = Math.max(i, 0), i = Math.min(i, t.length - 1), s = Math.max(s, 0), s = Math.min(s, t.length - 1), i > s && ([i, s] = [s, i]), r = t[i].scale, n = t[s].scale, t.splice(0, i), t.splice(s - i + 1, t.length), t.forEach((h, f) => {
      this._lodByScale[h.scale] = h, this._scales[f] = h.scale;
    }), this._set("effectiveLODs", t), this._set("effectiveMinZoom", i), this._set("effectiveMaxZoom", s), this._set("effectiveMinScale", r), this._set("effectiveMaxScale", n);
  }
  constrain(e, t) {
    if (t && e.scale === t.scale)
      return e;
    const r = this.effectiveMinScale, n = this.effectiveMaxScale, i = e.targetGeometry, s = t && t.targetGeometry, o = n !== 0 && e.scale < n, a = r !== 0 && e.scale > r;
    if (o || a) {
      const l = a ? r : n;
      if (t && s) {
        const c = (l - t.scale) / (e.scale - t.scale);
        i.x = s.x + (i.x - s.x) * c, i.y = s.y + (i.y - s.y) * c;
      }
      e.scale = l;
    }
    return this.snapToZoom && this.effectiveLODs && (e.scale = this._getClosestScale(e.scale)), e;
  }
  fit(e) {
    if (!this.effectiveLODs || !this.snapToZoom)
      return this.constrain(e, null);
    const t = this.scaleToZoom(e.scale), r = Math.abs(t - Math.floor(t));
    return e.scale = this.zoomToScale(r > 0.99 ? Math.round(t) : Math.floor(t)), e;
  }
  zoomToScale(e) {
    if (!this.effectiveLODs)
      return 0;
    e -= this.effectiveMinZoom, e = Math.max(0, e);
    const t = this._scales;
    if (e <= 0)
      return t[0];
    if (e >= t.length)
      return t[t.length - 1];
    const r = Math.round(e - 0.5), n = Math.round(e);
    return t[n] + (n - e) * (t[r] - t[n]);
  }
  scaleToZoom(e) {
    if (!this.effectiveLODs)
      return -1;
    const t = this._scales;
    let r, n;
    if (e >= t[0])
      return this.effectiveMinZoom;
    if (e <= t[t.length - 1])
      return this.effectiveMaxZoom;
    for (let i = 0; i < t.length - 1; i++) {
      if (r = t[i], n = t[i + 1], n === e)
        return i + this.effectiveMinZoom + 1;
      if (r > e && n < e)
        return i + this.effectiveMinZoom + 1 - (e - n) / (r - n);
    }
    return -1;
  }
  snapToClosestScale(e) {
    if (!this.effectiveLODs)
      return e;
    const t = this.scaleToZoom(e);
    return this.zoomToScale(Math.round(t));
  }
  snapToNextScale(e, t = 0.5) {
    if (!this.effectiveLODs)
      return e * t;
    const r = Math.round(this.scaleToZoom(e));
    return this.zoomToScale(r + 1);
  }
  snapToPreviousScale(e, t = 2) {
    if (!this.effectiveLODs)
      return e * t;
    const r = Math.round(this.scaleToZoom(e));
    return this.zoomToScale(r - 1);
  }
  clone() {
    return new ZT({ lods: this.lods, minZoom: this.minZoom, maxZoom: this.maxZoom, minScale: this.minScale, maxScale: this.maxScale });
  }
  _getClosestScale(e) {
    return this._lodByScale[e] || (e = this._scales.reduce((t, r) => Math.abs(r - e) <= Math.abs(t - e) ? r : t, this._scales[0])), this._lodByScale[e].scale;
  }
};
u([d({ readOnly: !0 })], ri.prototype, "effectiveLODs", void 0), u([d({ readOnly: !0 })], ri.prototype, "effectiveMinZoom", void 0), u([d({ readOnly: !0 })], ri.prototype, "effectiveMaxZoom", void 0), u([d({ readOnly: !0 })], ri.prototype, "effectiveMinScale", void 0), u([d({ readOnly: !0 })], ri.prototype, "effectiveMaxScale", void 0), u([d()], ri.prototype, "lods", void 0), u([d()], ri.prototype, "minZoom", void 0), u([d()], ri.prototype, "maxZoom", void 0), u([d()], ri.prototype, "minScale", void 0), u([d()], ri.prototype, "maxScale", void 0), u([d()], ri.prototype, "snapToZoom", void 0), ri = ZT = u([E("geoscene.views.2d.constraints.ZoomConstraint")], ri);
const SV = ri, Bue = { base: null, key: "type", typeMap: { extent: Ct, polygon: af } };
let hr = class extends Ae {
  constructor(t) {
    super(t), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = !0, this.snapToZoom = !0, this.customConstraints = new je();
  }
  destroy() {
    this.view = null;
  }
  get effectiveLODs() {
    return this._zoom.effectiveLODs;
  }
  get effectiveMinScale() {
    return this._zoom.effectiveMinScale;
  }
  get effectiveMaxScale() {
    return this._zoom.effectiveMaxScale;
  }
  get effectiveMinZoom() {
    return this._zoom.effectiveMinZoom;
  }
  get effectiveMaxZoom() {
    return this._zoom.effectiveMaxZoom;
  }
  set geometry(t) {
    t ? this._set("geometry", t) : this._set("geometry", null);
  }
  get version() {
    var t, r, n;
    return `${(t = this._zoom) == null ? void 0 : t.uid}/${(r = this._rotation) == null ? void 0 : r.uid}/${(n = this._geometry) == null ? void 0 : n.uid}`;
  }
  get _geometry() {
    var r, n;
    const t = this._get("_geometry");
    return t && this.geometry === t.geometry && ((r = this.view) == null ? void 0 : r.constraintsInfo.spatialReference) === t.spatialReference ? t : new Qc({ geometry: this.geometry, spatialReference: (n = this.view) == null ? void 0 : n.constraintsInfo.spatialReference });
  }
  get _rotation() {
    return new _V({ rotationEnabled: this.rotationEnabled });
  }
  get _zoom() {
    var l;
    const t = this._get("_zoom"), r = this.lods || ((l = this.view) == null ? void 0 : l.constraintsInfo.lods), n = this.minZoom, i = this.maxZoom, s = this.minScale, o = this.maxScale, a = this.snapToZoom;
    return t && t.lods === r && t.minZoom === n && t.maxZoom === i && t.minScale === s && t.maxScale === o && t.snapToZoom === a ? t : new SV({ lods: r, minZoom: n, maxZoom: i, minScale: s, maxScale: o, snapToZoom: a });
  }
  canZoomInTo(t) {
    const r = this.effectiveMaxScale;
    return r === 0 || t >= r;
  }
  canZoomOutTo(t) {
    const r = this.effectiveMinScale;
    return r === 0 || t <= r;
  }
  constrain(t, r) {
    return this._zoom.constrain(t, r), this._rotation.constrain(t, r), this._geometry.constrain(t, r), this.customConstraints.forEach((n) => n.constrain(t, r)), t;
  }
  constrainByGeometry(t) {
    return this._geometry.constrain(t);
  }
  fit(t) {
    return this._zoom.fit(t);
  }
  zoomToScale(t) {
    return this._zoom.zoomToScale(t);
  }
  scaleToZoom(t) {
    return this._zoom.scaleToZoom(t);
  }
  snapScale(t) {
    return this._zoom.snapToClosestScale(t);
  }
  snapToNextScale(t) {
    return this._zoom.snapToNextScale(t);
  }
  snapToPreviousScale(t) {
    return this._zoom.snapToPreviousScale(t);
  }
};
u([d({ readOnly: !0 })], hr.prototype, "effectiveLODs", null), u([d({ readOnly: !0 })], hr.prototype, "effectiveMinScale", null), u([d({ readOnly: !0 })], hr.prototype, "effectiveMaxScale", null), u([d({ readOnly: !0 })], hr.prototype, "effectiveMinZoom", null), u([d({ readOnly: !0 })], hr.prototype, "effectiveMaxZoom", null), u([d({ types: Bue, value: null })], hr.prototype, "geometry", null), u([d({ type: [du] })], hr.prototype, "lods", void 0), u([d()], hr.prototype, "minScale", void 0), u([d()], hr.prototype, "maxScale", void 0), u([d()], hr.prototype, "minZoom", void 0), u([d()], hr.prototype, "maxZoom", void 0), u([d()], hr.prototype, "rotationEnabled", void 0), u([d()], hr.prototype, "snapToZoom", void 0), u([d({ type: je })], hr.prototype, "customConstraints", void 0), u([d()], hr.prototype, "view", void 0), u([d({ readOnly: !0 })], hr.prototype, "version", null), u([d({ type: Qc, readOnly: !0 })], hr.prototype, "_geometry", null), u([d({ type: _V })], hr.prototype, "_rotation", null), u([d({ readOnly: !0, type: SV })], hr.prototype, "_zoom", null), hr = u([E("geoscene.views.2d.MapViewConstraints")], hr);
const $V = hr;
let que = class {
  constructor(t, r) {
    this.item = t, this.controller = r, this.promise = null;
  }
}, xV = class {
  constructor(t) {
    this._deferreds = /* @__PURE__ */ new Map(), this._controllers = /* @__PURE__ */ new Map(), this._processingItems = /* @__PURE__ */ new Map(), this._isPaused = !1, this._schedule = null, this._task = null, this.concurrency = 1, t.concurrency && (this.concurrency = t.concurrency), this._queue = new qb(t.peeker), this.process = t.process;
    const r = t.scheduler;
    t.priority && r && (this._task = r.registerTask(t.priority, this));
  }
  destroy() {
    this.clear(), this._schedule = tr(this._schedule), this._task = tr(this._task);
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(t) {
    const r = this._controllers.get(t);
    r && r.abort();
  }
  clear() {
    this._queue.clear();
    const t = [];
    this._controllers.forEach((r) => t.push(r)), this._controllers.clear(), t.forEach((r) => r.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(t) {
    this._deferreds.forEach((r, n) => t(n));
  }
  get(t) {
    const r = this._deferreds.get(t);
    return r ? r.promise : void 0;
  }
  isOngoing(t) {
    return this._processingItems.has(t);
  }
  has(t) {
    return this._deferreds.has(t);
  }
  pause() {
    this._isPaused || (this._isPaused = !0, this._cancelNext());
  }
  push(t, r) {
    const n = this.get(t);
    if (n)
      return n;
    const i = new AbortController();
    let s = null;
    r && (s = fs(r, () => i.abort()));
    const o = () => {
      const h = this._processingItems.get(t);
      h && h.controller.abort(), a(), c.reject(rr());
    }, a = () => {
      l.remove(), s != null && s.remove(), this._deferreds.delete(t), this._controllers.delete(t), this._queue.remove(t), this._processingItems.delete(t), this._scheduleNext();
    }, l = z3(i.signal, o), c = vs();
    return this._deferreds.set(t, c), this._controllers.set(t, i), c.promise.then(a, a), this._queue.push(t), this._scheduleNext(), c.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const t = [];
    this._processingItems.forEach((r) => t.push(r)), this._processingItems.clear();
    for (const r of t)
      this._queue.push(r.item), r.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._isPaused && (this._isPaused = !1, this._scheduleNext());
  }
  takeAll() {
    const t = [];
    for (; this._queue.length; )
      t.push(this._queue.pop());
    return this.clear(), t;
  }
  get running() {
    return !this._isPaused && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(t) {
    for (; !t.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), t.madeProgress();
  }
  _scheduleNext() {
    this._task || this._isPaused || this._schedule || (this._schedule = nf(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(t, r) {
    this._canProcessFulfillment(t) && (this._scheduleNext(), this._deferreds.get(t.item).resolve(r));
  }
  _processError(t, r) {
    this._canProcessFulfillment(t) && (this._scheduleNext(), this._deferreds.get(t.item).reject(r));
  }
  _canProcessFulfillment(t) {
    return !!this._deferreds.get(t.item) && this._processingItems.get(t.item) === t;
  }
  _process(t) {
    if (t == null)
      return;
    let r;
    const n = new AbortController(), i = new que(t, n);
    this._processingItems.set(t, i);
    try {
      r = this.process(t, n.signal);
    } catch (s) {
      this._processError(i, s);
    }
    pl(r) ? (i.promise = r, r.then((s) => this._processResult(i, s), (s) => this._processError(i, s))) : this._processResult(i, r);
  }
  get test() {
    return { update: (t) => this.runTask(t) };
  }
};
function Gue(e, t) {
  return e.length = 0, t.forEach((r) => e.push(r)), e;
}
const hS = /* @__PURE__ */ new Set(), K0 = [], hp = /* @__PURE__ */ new Map(), tR = [0, 0];
let Ol = class extends Ae {
  constructor(t) {
    super(t), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: t, process: r } = this;
    this._queue = new xV({ concurrency: t, process: (n, i) => {
      const s = this._keyToItem.get(n);
      return r(s, { signal: i });
    }, peeker: (n) => n.values().next().value });
  }
  destroy() {
    this.clear(), this._queue = Vt(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(t) {
    const r = typeof t == "string" ? t : t.id;
    this._queue.abort(r);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(t) {
    return typeof t == "string" ? this._keyToItem.has(t) : this._keyToItem.has(t.id);
  }
  isOngoing(t) {
    const r = typeof t == "string" ? t : t.id;
    return this.has(r) && this._queue.isOngoing(r);
  }
  pause() {
    this._queue.pause();
  }
  push(t, r) {
    const n = t.key.id + "-" + r;
    if (this.has(n))
      return this.get(n);
    const i = this._queue.push(n), s = () => {
      this._keyToItem.delete(n), this.notifyChange("updating");
    };
    return this._keyToItem.set(n, t), i.then(s, s), this.notifyChange("updating"), i;
  }
  reset() {
    this._queue.reset(), this.notifyChange("updating");
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const r = this.tileInfoView;
    let n = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    t.forEach((h) => {
      const f = this._keyToItem.get(h), m = this.tileInfoView.getTileScale(f.key);
      hp.has(m) || (hp.set(m, []), n = Math.max(m, n), i = Math.min(m, i)), hp.get(m).push(f.key), hS.add(m);
    });
    let s = this.state.scale;
    hp.has(s) || (Gue(K0, hS), K0.sort((h, f) => h - f), s = K0.reduce((h, f) => Math.abs(f - s) < Math.abs(h - s) ? f : h, K0[0])), s = Math.min(s, n), s = Math.max(s, i);
    const o = hp.get(s), a = r.getClosestInfoForScale(s), l = a.getColumnForX(this.state.center[0]), c = a.getRowForY(this.state.center[1]);
    return o.sort((h, f) => {
      const m = a.denormalizeCol(h.col, h.world), y = a.denormalizeCol(f.col, f.world);
      return Math.sqrt((l - m) * (l - m) + (c - h.row) * (c - h.row)) - Math.sqrt((l - y) * (l - y) + (c - f.row) * (c - f.row));
    }), hS.clear(), hp.clear(), o[0].id;
  }
  _peekByCenterFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const r = this.tileInfoView, n = this.state.center;
    let i, s = Number.POSITIVE_INFINITY;
    return t.forEach((o) => {
      const a = this._keyToItem.get(o);
      r.getTileCoords(tR, a.key);
      const l = Kg(tR, n);
      l < s && (s = l, i = a.key);
    }), i.id;
  }
};
u([d({ constructOnly: !0 })], Ol.prototype, "concurrency", void 0), u([d({ constructOnly: !0 })], Ol.prototype, "process", void 0), u([d()], Ol.prototype, "state", void 0), u([d({ constructOnly: !0 })], Ol.prototype, "strategy", void 0), u([d({ constructOnly: !0 })], Ol.prototype, "tileInfoView", void 0), u([d({ readOnly: !0 })], Ol.prototype, "updating", null), Ol = u([E("geoscene.views.2d.tiling.PagedTileQueue")], Ol);
let Dd = class Ic {
  static getId(t, r, n, i) {
    return typeof t == "object" ? `${t.level}/${t.row}/${t.col}/${t.world}` : `${t}/${r}/${n}/${i}`;
  }
  constructor(t, r, n, i) {
    this.set(t, r, n, i);
  }
  get key() {
    return this;
  }
  get id() {
    return this.toString();
  }
  set id(t) {
    this.set(t);
  }
  get hash() {
    const t = 4095 & this.row, r = 4095 & this.col, n = 63 & this.level;
    return (3 & this.world) << 30 | r << 22 | t << 8 | n;
  }
  acquire(t, r, n, i) {
    this.set(t, r, n, i);
  }
  contains(t) {
    const r = t.level - this.level;
    return r >= 0 && this.row === t.row >> r && this.col === t.col >> r && this.world === t.world;
  }
  equals(t) {
    return this.level === t.level && this.row === t.row && this.col === t.col && this.world === t.world;
  }
  clone() {
    return new Ic(this);
  }
  release() {
    this.level = 0, this.row = 0, this.col = 0, this.world = 0;
  }
  set(t, r, n, i) {
    if (t == null)
      this.level = 0, this.row = 0, this.col = 0, this.world = 0;
    else if (typeof t == "object")
      this.level = t.level || 0, this.row = t.row || 0, this.col = t.col || 0, this.world = t.world || 0;
    else if (typeof t == "string") {
      const [s, o, a, l] = t.split("/");
      this.level = parseFloat(s), this.row = parseFloat(o), this.col = parseFloat(a), this.world = parseFloat(l);
    } else
      this.level = +t, this.row = +r, this.col = +n, this.world = +i || 0;
    return this;
  }
  toString() {
    return `${this.level}/${this.row}/${this.col}/${this.world}`;
  }
  getParentKey() {
    return this.level <= 0 ? null : new Ic(this.level - 1, this.row >> 1, this.col >> 1, this.world);
  }
  getChildKeys() {
    const t = this.level + 1, r = this.row << 1, n = this.col << 1, i = this.world;
    return [new Ic(t, r, n, i), new Ic(t, r, n + 1, i), new Ic(t, r + 1, n, i), new Ic(t, r + 1, n + 1, i)];
  }
  compareRowMajor(t) {
    return this.row < t.row ? -1 : this.row > t.row ? 1 : this.col < t.col ? -1 : this.col > t.col ? 1 : 0;
  }
};
Dd.pool = new Jd(Dd, null, null, 25, 50);
function Cl(e, t) {
  return [e, t];
}
function tc(e, t, r) {
  return e[0] = t, e[1] = r, e;
}
function Hue(e, t, r, n, i) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e;
}
const Ps = new Dd("0/0/0/0");
let Wue = class TV {
  static create(t, r, n = null) {
    const i = el(t.spatialReference), s = r.origin || Cl(t.origin.x, t.origin.y), o = Cl(t.size[0] * r.resolution, t.size[1] * r.resolution), a = Cl(-1 / 0, -1 / 0), l = Cl(1 / 0, 1 / 0), c = Cl(1 / 0, 1 / 0);
    n != null && (tc(a, Math.max(0, Math.floor((n.xmin - s[0]) / o[0])), Math.max(0, Math.floor((s[1] - n.ymax) / o[1]))), tc(l, Math.max(0, Math.floor((n.xmax - s[0]) / o[0])), Math.max(0, Math.floor((s[1] - n.ymin) / o[1]))), tc(c, l[0] - a[0] + 1, l[1] - a[1] + 1));
    const { cols: h, rows: f } = r;
    let m, y, g, v;
    return !n && h && f && (tc(a, h[0], f[0]), tc(l, h[1], f[1]), tc(c, h[1] - h[0] + 1, f[1] - f[0] + 1)), t.isWrappable ? (m = Cl(Math.ceil(Math.round((i.valid[1] - i.valid[0]) / r.resolution) / t.size[0]), c[1]), y = Cl(Math.floor((i.origin[0] - s[0]) / o[0]), a[1]), g = Cl(m[0] + y[0] - 1, l[1]), v = !0) : (y = a, g = l, m = c, v = !1), new TV(r.level, r.resolution, r.scale, s, a, l, c, o, y, g, m, v);
  }
  constructor(t, r, n, i, s, o, a, l, c, h, f, m) {
    this.level = t, this.resolution = r, this.scale = n, this.origin = i, this.first = s, this.last = o, this.size = a, this.norm = l, this.worldStart = c, this.worldEnd = h, this.worldSize = f, this.wrap = m;
  }
  normalizeCol(t) {
    if (!this.wrap)
      return t;
    const r = this.worldSize[0];
    return t < 0 ? r - 1 - Math.abs((t + 1) % r) : t % r;
  }
  denormalizeCol(t, r) {
    return this.wrap ? this.worldSize[0] * r + t : t;
  }
  getWorldForColumn(t) {
    return this.wrap ? Math.floor(t / this.worldSize[0]) : 0;
  }
  getFirstColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0];
  }
  getLastColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0] + this.size[0] - 1;
  }
  getColumnForX(t) {
    return (t - this.origin[0]) / this.norm[0];
  }
  getXForColumn(t) {
    return this.origin[0] + t * this.norm[0];
  }
  getRowForY(t) {
    return (this.origin[1] - t) / this.norm[1];
  }
  getYForRow(t) {
    return this.origin[1] - t * this.norm[1];
  }
  getTileBounds(t, r, n = !1) {
    Ps.set(r);
    const i = n ? Ps.col : this.denormalizeCol(Ps.col, Ps.world), s = Ps.row;
    return Hue(t, this.getXForColumn(i), this.getYForRow(s + 1), this.getXForColumn(i + 1), this.getYForRow(s)), t;
  }
  getTileCoords(t, r, n = !1) {
    Ps.set(r);
    const i = n ? Ps.col : this.denormalizeCol(Ps.col, Ps.world);
    return Array.isArray(t) ? tc(t, this.getXForColumn(i), this.getYForRow(Ps.row)) : (t.x = this.getXForColumn(i), t.y = this.getYForRow(Ps.row)), t;
  }
}, pg = class {
  constructor() {
    this.spans = [];
  }
  acquire(t) {
    this.lodInfo = t;
  }
  release() {
    this.lodInfo = null, this.spans.length = 0;
  }
  forEach(t, r) {
    const { spans: n, lodInfo: i } = this, { level: s } = i;
    if (n.length !== 0)
      for (const { row: o, colFrom: a, colTo: l } of n)
        for (let c = a; c <= l; c++)
          t.call(r, s, o, i.normalizeCol(c), i.getWorldForColumn(c));
  }
};
pg.pool = new Jd(pg);
let fS = class {
  constructor(t, r, n) {
    this.row = t, this.colFrom = r, this.colTo = n;
  }
};
const Gt = new Dd("0/0/0/0");
let Jue = class EV {
  static create(t, r) {
    t[1] > r[1] && ([t, r] = [r, t]);
    const [n, i] = t, [s, o] = r, a = s - n, l = o - i, c = l !== 0 ? a / l : 0, h = (Math.ceil(i) - i) * c, f = (Math.floor(i) - i) * c;
    return new EV(n, Math.floor(i), Math.ceil(o), c, a < 0 ? h : f, a < 0 ? f : h, a < 0 ? s : n, a < 0 ? n : s);
  }
  constructor(t, r, n, i, s, o, a, l) {
    this.x = t, this.ymin = r, this.ymax = n, this.invM = i, this.leftAdjust = s, this.rightAdjust = o, this.leftBound = a, this.rightBound = l;
  }
  incrRow() {
    this.x += this.invM;
  }
  getLeftCol() {
    return Math.max(this.x + this.leftAdjust, this.leftBound);
  }
  getRightCol() {
    return Math.min(this.x + this.rightAdjust, this.rightBound);
  }
};
const vi = [[0, 0], [0, 0], [0, 0], [0, 0]], Zue = 1e-6;
let Kue = class {
  constructor(t, r = null, n = t.lods[0].level, i = t.lods[t.lods.length - 1].level) {
    this.tileInfo = t, this.fullExtent = r, this.scales = [], this._infoByScale = {}, this._infoByLevel = {};
    const s = t.lods.filter((a) => a.level >= n && a.level <= i);
    this.minScale = s[0].scale, this.maxScale = s[s.length - 1].scale;
    const o = this._lodInfos = s.map((a) => Wue.create(t, a, r));
    s.forEach((a, l) => {
      this._infoByLevel[a.level] = o[l], this._infoByScale[a.scale] = o[l], this.scales[l] = a.scale;
    }, this), this._wrap = t.isWrappable;
  }
  get spatialReference() {
    return this.tileInfo.spatialReference;
  }
  getLODInfoAt(t) {
    return this._infoByLevel[typeof t == "number" ? t : t.level];
  }
  getTileBounds(t, r, n = !1) {
    Gt.set(r);
    const i = this._infoByLevel[Gt.level];
    return i ? i.getTileBounds(t, Gt, n) : t;
  }
  getTileCoords(t, r, n = !1) {
    Gt.set(r);
    const i = this._infoByLevel[Gt.level];
    return i ? i.getTileCoords(t, Gt, n) : t;
  }
  getTileCoverage(t, r = 192, n = !0, i = "closest") {
    if (!n && (t.scale > this.minScale || t.scale < this.maxScale))
      return null;
    const s = i === "closest" ? this.getClosestInfoForScale(t.scale) : this.getSmallestInfoForScale(t.scale), o = pg.pool.acquire(s), a = this._wrap;
    let l, c, h, f = 1 / 0, m = -1 / 0;
    const y = o.spans;
    vi[0][0] = vi[0][1] = vi[1][1] = vi[3][0] = -r, vi[1][0] = vi[2][0] = t.size[0] + r, vi[2][1] = vi[3][1] = t.size[1] + r;
    for (const w of vi)
      t.toMap(w, w), w[0] = s.getColumnForX(w[0]), w[1] = s.getRowForY(w[1]);
    const g = [];
    let v = 3;
    for (let w = 0; w < 4; w++) {
      if (vi[w][1] === vi[v][1]) {
        v = w;
        continue;
      }
      const x = Jue.create(vi[w], vi[v]);
      f = Math.min(x.ymin, f), m = Math.max(x.ymax, m), g[x.ymin] === void 0 && (g[x.ymin] = []), g[x.ymin].push(x), v = w;
    }
    if (f == null || m == null || m - f > 100)
      return null;
    let b = [];
    for (l = f; l < m; ) {
      g[l] != null && (b = b.concat(g[l])), c = 1 / 0, h = -1 / 0;
      for (let w = b.length - 1; w >= 0; w--) {
        const x = b[w];
        c = Math.min(c, x.getLeftCol()), h = Math.max(h, x.getRightCol());
      }
      if (c = Math.floor(c), h = Math.floor(h), l >= s.first[1] && l <= s.last[1])
        if (a)
          if (s.size[0] < s.worldSize[0]) {
            const w = Math.floor(h / s.worldSize[0]);
            for (let x = Math.floor(c / s.worldSize[0]); x <= w; x++)
              y.push(new fS(l, Math.max(s.getFirstColumnForWorld(x), c), Math.min(s.getLastColumnForWorld(x), h)));
          } else
            y.push(new fS(l, c, h));
        else
          c > s.last[0] || h < s.first[0] || (c = Math.max(c, s.first[0]), h = Math.min(h, s.last[0]), y.push(new fS(l, c, h)));
      l += 1;
      for (let w = b.length - 1; w >= 0; w--) {
        const x = b[w];
        x.ymax >= l ? x.incrRow() : b.splice(w, 1);
      }
    }
    return o;
  }
  getTileParentId(t) {
    Gt.set(t);
    const r = this._infoByLevel[Gt.level], n = this._lodInfos.indexOf(r) - 1;
    return n < 0 ? null : (this._getTileIdAtLOD(Gt, this._lodInfos[n], Gt), Gt.id);
  }
  getTileResolution(t) {
    const r = this._infoByLevel[typeof t == "object" ? t.level : t];
    return r ? r.resolution : -1;
  }
  getTileScale(t) {
    const r = this._infoByLevel[t.level];
    return r ? r.scale : -1;
  }
  intersects(t, r) {
    Gt.set(r);
    const n = this._infoByLevel[Gt.level], i = t.lodInfo;
    if (i.resolution > n.resolution) {
      this._getTileIdAtLOD(Gt, i, Gt);
      const o = i.denormalizeCol(Gt.col, Gt.world);
      for (const a of t.spans)
        if (a.row === Gt.row && a.colFrom <= o && a.colTo >= o)
          return !0;
    }
    if (i.resolution < n.resolution) {
      const [o, a, l, c] = t.spans.reduce((v, b) => (v[0] = Math.min(v[0], b.row), v[1] = Math.max(v[1], b.row), v[2] = Math.min(v[2], b.colFrom), v[3] = Math.max(v[3], b.colTo), v), [1 / 0, -1 / 0, 1 / 0, -1 / 0]), h = n.denormalizeCol(Gt.col, Gt.world), f = i.getColumnForX(n.getXForColumn(h)), m = i.getRowForY(n.getYForRow(Gt.row)), y = i.getColumnForX(n.getXForColumn(h + 1)) - 1, g = i.getRowForY(n.getYForRow(Gt.row + 1)) - 1;
      return !(f > c || y < l || m > a || g < o);
    }
    const s = i.denormalizeCol(Gt.col, Gt.world);
    return t.spans.some((o) => o.row === Gt.row && o.colFrom <= s && o.colTo >= s);
  }
  normalizeBounds(t, r, n) {
    if (t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], this._wrap) {
      const i = el(this.tileInfo.spatialReference), s = -n * (i.valid[1] - i.valid[0]);
      t[0] += s, t[2] += s;
    }
    return t;
  }
  getSmallestInfoForScale(t) {
    const r = this.scales;
    if (this._infoByScale[t])
      return this._infoByScale[t];
    if (t > r[0])
      return this._infoByScale[r[0]];
    for (let n = 1; n < r.length - 1; n++)
      if (t > r[n] + Zue)
        return this._infoByScale[r[n - 1]];
    return this._infoByScale[r[r.length - 1]];
  }
  getClosestInfoForScale(t) {
    const r = this.scales;
    return this._infoByScale[t] || (t = r.reduce((n, i) => Math.abs(i - t) < Math.abs(n - t) ? i : n, r[0])), this._infoByScale[t];
  }
  scaleToLevel(t) {
    const r = this.scales;
    if (this._infoByScale[t])
      return this._infoByScale[t].level;
    for (let n = r.length - 1; n >= 0; n--)
      if (t < r[n])
        return n === r.length - 1 ? this._infoByScale[r[r.length - 1]].level : this._infoByScale[r[n]].level + (r[n] - t) / (r[n] - r[n + 1]);
    return this._infoByScale[r[0]].level;
  }
  scaleToZoom(t) {
    return this.tileInfo.scaleToZoom(t);
  }
  _getTileIdAtLOD(t, r, n) {
    const i = this._infoByLevel[n.level];
    return t.set(n), r.resolution < i.resolution ? null : (r.resolution === i.resolution || (t.level = r.level, t.col = Math.floor(n.col * i.resolution / r.resolution + 0.01), t.row = Math.floor(n.row * i.resolution / r.resolution + 0.01)), t);
  }
};
function Yue(e, t) {
  return e.length = 0, t.forEach((r) => e.push(r)), e;
}
const mS = /* @__PURE__ */ new Set(), Y0 = [], fp = /* @__PURE__ */ new Map(), rR = [0, 0];
let ka = class extends Ae {
  constructor(t) {
    super(t), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: t, process: r, strategy: n } = this;
    this._queue = new xV({ concurrency: t, process: (i, s) => {
      const o = this._keyToItem.get(i);
      return r(o, { signal: s });
    }, peeker: n === "scale-first" ? (i) => this._peekByScaleFirst(i) : (i) => this._peekByCenterFirst(i) });
  }
  destroy() {
    this.clear(), this._queue = Vt(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(t) {
    const r = typeof t == "string" ? t : t.id;
    this._queue.abort(r);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(t) {
    return typeof t == "string" ? this._keyToItem.has(t) : this._keyToItem.has(t.id);
  }
  isOngoing(t) {
    const r = typeof t == "string" ? t : t.id;
    return this.has(r) && this._queue.isOngoing(r);
  }
  pause() {
    this._queue.pause();
  }
  push(t) {
    const r = t.key.id;
    if (this._queue.has(r))
      return this._queue.get(r);
    const n = this._queue.push(r), i = () => {
      this._keyToItem.delete(r), this.notifyChange("updating");
    };
    return this._keyToItem.set(r, t), n.then(i, i), this.notifyChange("updating"), n;
  }
  reset() {
    this._queue.reset();
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const r = this.tileInfoView;
    let n = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    t.forEach((h) => {
      const f = this._keyToItem.get(h), m = this.tileInfoView.getTileScale(f.key);
      fp.has(m) || (fp.set(m, []), n = Math.max(m, n), i = Math.min(m, i)), fp.get(m).push(f.key), mS.add(m);
    });
    let s = this.state.scale;
    fp.has(s) || (Yue(Y0, mS), Y0.sort((h, f) => h - f), s = Y0.reduce((h, f) => Math.abs(f - s) < Math.abs(h - s) ? f : h, Y0[0])), s = Math.min(s, n), s = Math.max(s, i);
    const o = fp.get(s), a = r.getClosestInfoForScale(s), l = a.getColumnForX(this.state.center[0]), c = a.getRowForY(this.state.center[1]);
    return o.sort((h, f) => {
      const m = a.denormalizeCol(h.col, h.world), y = a.denormalizeCol(f.col, f.world);
      return Math.sqrt((l - m) * (l - m) + (c - h.row) * (c - h.row)) - Math.sqrt((l - y) * (l - y) + (c - f.row) * (c - f.row));
    }), mS.clear(), fp.clear(), o[0].id;
  }
  _peekByCenterFirst(t) {
    if (!this.state)
      return t.values().next().value;
    const r = this.tileInfoView, n = this.state.center;
    let i, s = Number.POSITIVE_INFINITY;
    return t.forEach((o) => {
      const a = this._keyToItem.get(o);
      r.getTileCoords(rR, a.key);
      const l = Kg(rR, n);
      l < s && (s = l, i = a.key);
    }), i.id;
  }
};
u([d({ constructOnly: !0 })], ka.prototype, "concurrency", void 0), u([d({ constructOnly: !0 })], ka.prototype, "process", void 0), u([d()], ka.prototype, "state", void 0), u([d({ constructOnly: !0 })], ka.prototype, "strategy", void 0), u([d({ constructOnly: !0 })], ka.prototype, "tileInfoView", void 0), u([d({ readOnly: !0 })], ka.prototype, "updating", null), ka = u([E("geoscene.views.2d.tiling.TileQueue")], ka);
const DLe = ka;
let Que = class {
  constructor(t, r, n) {
    this.maxSize = t, this._tileInfoView = r, this._removedFunc = n, this._tilePerId = /* @__PURE__ */ new Map(), this._tileKeysPerLevel = [];
  }
  clear() {
    this._tilePerId.clear(), this._tileKeysPerLevel = [];
  }
  has(t) {
    return this._tilePerId.has(t);
  }
  get(t) {
    return this._tilePerId.get(t);
  }
  pop(t) {
    const r = this._tilePerId.get(t);
    if (!r)
      return;
    const n = r.key.level, i = this._tileKeysPerLevel[n];
    nR(this._tilePerId, t);
    for (let s = 0; s < i.length; s++)
      if (i[s].id === t) {
        i.splice(s, 1);
        break;
      }
    return r.visible = !0, r;
  }
  add(t) {
    t.visible = !1;
    const r = t.key, n = r.id;
    if (this._tilePerId.has(n))
      return;
    this._tilePerId.set(n, t);
    const i = r.level;
    this._tileKeysPerLevel[i] || (this._tileKeysPerLevel[i] = []), this._tileKeysPerLevel[i].push(r);
  }
  prune(t, r, n) {
    let i = this._tilePerId.size;
    if (i <= this.maxSize)
      return;
    let s = this._tileKeysPerLevel.length - 1;
    for (; i > this.maxSize && s >= 0; )
      s !== t && (i = this._pruneAroundCenterTile(i, r, n, s)), s--;
    i > this.maxSize && (i = this._pruneAroundCenterTile(i, r, n, t));
  }
  _pruneAroundCenterTile(t, r, n, i) {
    const s = this._tileKeysPerLevel[i];
    if (!s || s.length === 0)
      return t;
    const { size: o, origin: a } = this._tileInfoView.tileInfo, l = n * o[0], c = n * o[1], h = [0, 0], f = [0, 0];
    for (s.sort((m, y) => (h[0] = a.x + l * (m.col + 0.5), h[1] = a.y - c * (m.row + 0.5), f[0] = a.x + l * (y.col + 0.5), f[1] = a.y - c * (y.row + 0.5), nw(h, r) - nw(f, r))); s.length > 0; ) {
      const m = s.pop();
      if (this._removeTile(m.id), --t === this.maxSize)
        break;
    }
    return t;
  }
  _removeTile(t) {
    const r = this._tilePerId.get(t);
    this._removedFunc && r && this._removedFunc(r), nR(this._tilePerId, t);
  }
};
function nR(e, t) {
  e.delete(t);
}
const rc = new Dd(0, 0, 0, 0), ya = /* @__PURE__ */ new Map(), nc = [], yS = [];
let VLe = class {
  constructor(t) {
    this._previousScale = Number.POSITIVE_INFINITY, this.cachePolicy = "keep", this.coveragePolicy = "closest", this.resampling = !0, this.tileIndex = /* @__PURE__ */ new Map(), this.tiles = [], this.buffer = 192, this.acquireTile = t.acquireTile, this.releaseTile = t.releaseTile, this.tileInfoView = t.tileInfoView, t.resampling != null && (this.resampling = t.resampling), t.cachePolicy && (this.cachePolicy = t.cachePolicy), t.coveragePolicy && (this.coveragePolicy = t.coveragePolicy), t.buffer != null && (this.buffer = t.buffer), t.cacheSize && (this._tileCache = new Que(t.cacheSize, this.tileInfoView, (r) => {
      this.releaseTile(r);
    }));
  }
  destroy() {
    this.tileIndex.clear();
  }
  update(t) {
    var w, x;
    const { resampling: r, tileIndex: n } = this, { scale: i, center: s, resolution: o } = t.state, { minScale: a, maxScale: l } = this.tileInfoView, c = !t.stationary && i > this._previousScale;
    if (this._previousScale = i, !r && (i > a || i < l))
      return this.tiles.length = 0, void this.clear();
    const h = this.tileInfoView.getTileCoverage(t.state, this.buffer, this.resampling, this.coveragePolicy);
    if (!h)
      return this.tiles.length = 0, void this.clear();
    const { spans: f, lodInfo: m } = h, { level: y } = m;
    this.tiles.length = 0, n.forEach(($) => $.visible = !0);
    let g = 0, v = 0;
    if (f.length > 0)
      for (const { row: $, colFrom: T, colTo: C } of f)
        for (let I = T; I <= C; I++) {
          g++;
          const O = rc.set(y, $, m.normalizeCol(I), m.getWorldForColumn(I)).id;
          let M = n.get(O);
          if (M)
            M.isReady ? (ya.set(O, M), v++) : c || this._addParentTile(O, ya);
          else {
            if ((w = this._tileCache) != null && w.has(O)) {
              if (M = this._tileCache.pop(O), this.tileIndex.set(O, M), M.isReady) {
                ya.set(O, M), v++;
                continue;
              }
            } else
              M = this.acquireTile(rc), this.tileIndex.set(O, M);
            c || this._addParentTile(O, ya);
          }
        }
    const b = v === g;
    for (const [$, T] of n) {
      if (ya.has($))
        continue;
      rc.set($);
      const C = this.tileInfoView.intersects(h, rc), I = this.cachePolicy === "purge" ? rc.level !== y : rc.level > y;
      !C || !c && b ? !I && C || nc.push(T) : T.isReady ? I && this.cachePolicy === "purge" && this._hasReadyAncestor(rc, y) ? nc.push(T) : yS.push(T) : I && nc.push(T);
    }
    for (const $ of yS)
      $.isReady && ya.set($.key.id, $);
    for (const $ of nc)
      this._tileCache ? this._tileCache.add($) : this.releaseTile($), n.delete($.key.id);
    for (const $ of ya.values())
      this.tiles.push($);
    for (const $ of n.values())
      ya.has($.key.id) || ($.visible = !1);
    (x = this._tileCache) == null || x.prune(y, s, o), pg.pool.release(h), yS.length = 0, nc.length = 0, ya.clear();
  }
  clear() {
    const { tileIndex: t } = this;
    for (const r of t.values())
      this.releaseTile(r);
    t.clear();
  }
  refresh(t) {
    var r;
    for (const n of this.tileIndex.values())
      this.tiles.includes(n) ? t(n) : nc.push(n);
    for (const n of nc)
      this.releaseTile(n), this.tileIndex.delete(n.key.id);
    (r = this._tileCache) == null || r.clear();
  }
  updateCacheSize(t) {
    this._tileCache && (this._tileCache.maxSize = t);
  }
  _addParentTile(t, r) {
    var s;
    let n = t, i = null;
    for (; n = this.tileInfoView.getTileParentId(n), n; )
      if (this.tileIndex.has(n)) {
        if (i = this.tileIndex.get(n), i == null ? void 0 : i.isReady) {
          r.has(i.key.id) || r.set(i.key.id, i);
          break;
        }
      } else if ((s = this._tileCache) != null && s.has(n) && (i = this._tileCache.pop(n), this.tileIndex.set(n, i), i == null ? void 0 : i.isReady)) {
        r.has(i.key.id) || r.set(i.key.id, i);
        break;
      }
  }
  _hasReadyAncestor(t, r) {
    const n = sa();
    this.tileInfoView.getTileBounds(n, t, !0);
    for (const i of this.tileIndex.values())
      if (i.isReady && i.key.level >= r && i.key.level < t.level) {
        const s = sa();
        if (this.tileInfoView.getTileBounds(s, i.key, !0), RX(s, n))
          return !0;
      }
    return !1;
  }
};
function IV() {
  const e = new Float32Array(6);
  return e[0] = 1, e[3] = 1, e;
}
function Xue(e) {
  const t = new Float32Array(6);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
}
function ece(e, t, r, n, i, s) {
  const o = new Float32Array(6);
  return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o[4] = i, o[5] = s, o;
}
function tce(e, t) {
  return new Float32Array(e, t, 6);
}
function MV(e, t, r, n) {
  const i = t[n], s = t[n + 1];
  e[n] = r[0] * i + r[2] * s + r[4], e[n + 1] = r[1] * i + r[3] * s + r[5];
}
function rce(e, t, r, n = 0, i = 0, s = 2) {
  const o = i || t.length / s;
  for (let a = n; a < o; a++)
    MV(e, t, r, a * s);
}
Object.freeze(Object.defineProperty({ __proto__: null, clone: Xue, create: IV, createView: tce, fromValues: ece, transform: MV, transformMany: rce }, Symbol.toStringTag, { value: "Module" }));
function nce(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;
}
function ice(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
}
function OV(e, t, r, n, i, s, o, a, l, c) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e[4] = s, e[5] = o, e[6] = a, e[7] = l, e[8] = c, e;
}
function CV(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
}
function sce(e, t) {
  if (e === t) {
    const r = t[1], n = t[2], i = t[5];
    e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = i;
  } else
    e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
  return e;
}
function oce(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], f = h * o - a * c, m = -h * s + a * l, y = c * s - o * l;
  let g = r * f + n * m + i * y;
  return g ? (g = 1 / g, e[0] = f * g, e[1] = (-h * n + i * c) * g, e[2] = (a * n - i * o) * g, e[3] = m * g, e[4] = (h * r - i * l) * g, e[5] = (-a * r + i * s) * g, e[6] = y * g, e[7] = (-c * r + n * l) * g, e[8] = (o * r - n * s) * g, e) : null;
}
function ace(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8];
  return e[0] = o * h - a * c, e[1] = i * c - n * h, e[2] = n * a - i * o, e[3] = a * l - s * h, e[4] = r * h - i * l, e[5] = i * s - r * a, e[6] = s * c - o * l, e[7] = n * l - r * c, e[8] = r * o - n * s, e;
}
function lce(e) {
  const t = e[0], r = e[1], n = e[2], i = e[3], s = e[4], o = e[5], a = e[6], l = e[7], c = e[8];
  return t * (c * s - o * l) + r * (-c * i + o * a) + n * (l * i - s * a);
}
function $O(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], f = t[8], m = r[0], y = r[1], g = r[2], v = r[3], b = r[4], w = r[5], x = r[6], $ = r[7], T = r[8];
  return e[0] = m * n + y * o + g * c, e[1] = m * i + y * a + g * h, e[2] = m * s + y * l + g * f, e[3] = v * n + b * o + w * c, e[4] = v * i + b * a + w * h, e[5] = v * s + b * l + w * f, e[6] = x * n + $ * o + T * c, e[7] = x * i + $ * a + T * h, e[8] = x * s + $ * l + T * f, e;
}
function KT(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], f = t[8], m = r[0], y = r[1];
  return e[0] = n, e[1] = i, e[2] = s, e[3] = o, e[4] = a, e[5] = l, e[6] = m * n + y * o + c, e[7] = m * i + y * a + h, e[8] = m * s + y * l + f, e;
}
function kV(e, t, r) {
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], l = t[5], c = t[6], h = t[7], f = t[8], m = Math.sin(r), y = Math.cos(r);
  return e[0] = y * n + m * o, e[1] = y * i + m * a, e[2] = y * s + m * l, e[3] = y * o - m * n, e[4] = y * a - m * i, e[5] = y * l - m * s, e[6] = c, e[7] = h, e[8] = f, e;
}
function uce(e, t, r) {
  const n = r[0], i = r[1], s = r[2];
  return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e[6] = s * t[6], e[7] = s * t[7], e[8] = s * t[8], e;
}
function cce(e, t, r) {
  const n = r[0], i = r[1];
  return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e;
}
function dce(e, t) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;
}
function pce(e, t) {
  const r = Math.sin(t), n = Math.cos(t);
  return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
}
function hce(e, t) {
  return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
}
function fce(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e;
}
function mce(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = r + r, a = n + n, l = i + i, c = r * o, h = n * o, f = n * a, m = i * o, y = i * a, g = i * l, v = s * o, b = s * a, w = s * l;
  return e[0] = 1 - f - g, e[3] = h - w, e[6] = m + b, e[1] = h + w, e[4] = 1 - c - g, e[7] = y - v, e[2] = m - b, e[5] = y + v, e[8] = 1 - c - f, e;
}
function yce(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[4], o = t[5], a = t[6], l = t[8], c = t[9], h = t[10], f = h * o - a * c, m = -h * s + a * l, y = c * s - o * l, g = r * f + n * m + i * y;
  if (!g)
    return null;
  const v = 1 / g;
  return e[0] = f * v, e[1] = (-h * n + i * c) * v, e[2] = (a * n - i * o) * v, e[3] = m * v, e[4] = (h * r - i * l) * v, e[5] = (-a * r + i * s) * v, e[6] = y * v, e[7] = (-c * r + n * l) * v, e[8] = (o * r - n * s) * v, e;
}
function gce(e, t) {
  const r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], f = t[9], m = t[10], y = t[11], g = t[12], v = t[13], b = t[14], w = t[15], x = r * a - n * o, $ = r * l - i * o, T = r * c - s * o, C = n * l - i * a, I = n * c - s * a, O = i * c - s * l, M = h * v - f * g, L = h * b - m * g, N = h * w - y * g, ee = f * b - m * v, D = f * w - y * v, H = m * w - y * b;
  let J = x * H - $ * D + T * ee + C * N - I * L + O * M;
  return J ? (J = 1 / J, e[0] = (a * H - l * D + c * ee) * J, e[1] = (l * N - o * H - c * L) * J, e[2] = (o * D - a * N + c * M) * J, e[3] = (i * D - n * H - s * ee) * J, e[4] = (r * H - i * N + s * L) * J, e[5] = (n * N - r * D - s * M) * J, e[6] = (v * O - b * I + w * C) * J, e[7] = (b * T - g * O - w * $) * J, e[8] = (g * I - v * T + w * x) * J, e) : null;
}
function vce(e, t, r) {
  return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / r, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e;
}
function bce(e) {
  return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")";
}
function wce(e) {
  return Math.sqrt(e[0] ** 2 + e[1] ** 2 + e[2] ** 2 + e[3] ** 2 + e[4] ** 2 + e[5] ** 2 + e[6] ** 2 + e[7] ** 2 + e[8] ** 2);
}
function _ce(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;
}
function AV(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;
}
function Sce(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;
}
function $ce(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;
}
function xce(e, t) {
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];
}
function Tce(e, t) {
  const r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], f = t[0], m = t[1], y = t[2], g = t[3], v = t[4], b = t[5], w = t[6], x = t[7], $ = t[8], T = Es();
  return Math.abs(r - f) <= T * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(n - m) <= T * Math.max(1, Math.abs(n), Math.abs(m)) && Math.abs(i - y) <= T * Math.max(1, Math.abs(i), Math.abs(y)) && Math.abs(s - g) <= T * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(o - v) <= T * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(a - b) <= T * Math.max(1, Math.abs(a), Math.abs(b)) && Math.abs(l - w) <= T * Math.max(1, Math.abs(l), Math.abs(w)) && Math.abs(c - x) <= T * Math.max(1, Math.abs(c), Math.abs(x)) && Math.abs(h - $) <= T * Math.max(1, Math.abs(h), Math.abs($));
}
function Ece(e) {
  const t = Es(), r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
  return Math.abs(1 - (r * r + s * s + l * l)) <= t && Math.abs(1 - (n * n + o * o + c * c)) <= t && Math.abs(1 - (i * i + a * a + h * h)) <= t;
}
const Ice = $O, Mce = AV;
Object.freeze(Object.defineProperty({ __proto__: null, add: _ce, adjoint: ace, copy: ice, determinant: lce, equals: Tce, exactEquals: xce, frob: wce, fromMat2d: fce, fromMat4: nce, fromQuat: mce, fromRotation: pce, fromScaling: hce, fromTranslation: dce, identity: CV, invert: oce, isOrthoNormal: Ece, mul: Ice, multiply: $O, multiplyScalar: Sce, multiplyScalarAndAdd: $ce, normalFromMat4: gce, normalFromMat4Legacy: yce, projection: vce, rotate: kV, scale: uce, scaleByVec2: cce, set: OV, str: bce, sub: Mce, subtract: AV, translate: KT, transpose: sce }, Symbol.toStringTag, { value: "Module" }));
function b1() {
  const e = new Float32Array(9);
  return e[0] = 1, e[4] = 1, e[8] = 1, e;
}
function Oce(e) {
  const t = new Float32Array(9);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function Cce(e, t, r, n, i, s, o, a, l) {
  const c = new Float32Array(9);
  return c[0] = e, c[1] = t, c[2] = r, c[3] = n, c[4] = i, c[5] = s, c[6] = o, c[7] = a, c[8] = l, c;
}
function kce(e, t) {
  return new Float32Array(e, t, 9);
}
Object.freeze(Object.defineProperty({ __proto__: null, clone: Oce, create: b1, createView: kce, fromValues: Cce }, Symbol.toStringTag, { value: "Module" }));
function PV() {
  return new Float32Array(2);
}
function Ace(e) {
  const t = new Float32Array(2);
  return t[0] = e[0], t[1] = e[1], t;
}
function Bh(e, t) {
  const r = new Float32Array(2);
  return r[0] = e, r[1] = t, r;
}
function Pce(e, t) {
  return new Float32Array(e, t, 2);
}
function RV() {
  return PV();
}
function LV() {
  return Bh(1, 1);
}
function NV() {
  return Bh(1, 0);
}
function FV() {
  return Bh(0, 1);
}
const Rce = RV(), Lce = LV(), Nce = NV(), Fce = FV();
Object.freeze(Object.defineProperty({ __proto__: null, ONES: Lce, UNIT_X: Nce, UNIT_Y: Fce, ZEROS: Rce, clone: Ace, create: PV, createView: Pce, fromValues: Bh, ones: LV, unitX: NV, unitY: FV, zeros: RV }, Symbol.toStringTag, { value: "Module" }));
function Dce(e) {
  return e instanceof Float32Array && e.length >= 2;
}
function jce(e) {
  return Array.isArray(e) && e.length >= 2;
}
function gS(e) {
  return Dce(e) || jce(e);
}
var YT;
const ga = [0, 0];
let Xl = YT = class extends re {
  constructor(e) {
    super(e), this._viewpoint2D = { center: yr(), rotation: 0, scale: 0, spatialReference: void 0 }, this.center = [0, 0], this.extent = new Ct(), this.id = 0, this.inverseTransform = Mu(), this.resolution = 0, this.rotation = 0, this.scale = 0, this.transform = Mu(), this.transformNoRotation = Mu(), this.displayMat3 = b1(), this.displayViewMat3 = b1(), this.viewMat3 = b1(), this.viewMat2d = IV(), this.worldScreenWidth = 0, this.size = [0, 0];
  }
  set pixelRatio(e) {
    this._set("pixelRatio", e), this._update();
  }
  set size(e) {
    this._set("size", e), this._update();
  }
  set viewpoint(e) {
    if (e) {
      const t = this._viewpoint2D, r = e.targetGeometry;
      t.center[0] = r.x, t.center[1] = r.y, t.rotation = e.rotation, t.scale = e.scale, t.spatialReference = r.spatialReference;
    }
    this._update();
  }
  copy(e) {
    const t = this.size, r = this.viewpoint;
    return r && t ? (this.viewpoint = vo(r, e.viewpoint), this._set("size", cg(t, e.size))) : (this.viewpoint = e.viewpoint.clone(), this._set("size", [e.size[0], e.size[1]])), this._set("pixelRatio", e.pixelRatio), this;
  }
  clone() {
    return new YT({ size: this.size, viewpoint: this.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
  toMap(e, t, r) {
    return gS(t) ? Ho(e, t, this.inverseTransform) : (ga[0] = t, ga[1] = r, Ho(e, ga, this.inverseTransform));
  }
  toScreen(e, t, r) {
    return gS(t) ? Ho(e, t, this.transform) : (ga[0] = t, ga[1] = r, Ho(e, ga, this.transform));
  }
  toScreenNoRotation(e, t, r) {
    return gS(t) ? Ho(e, t, this.transformNoRotation) : (ga[0] = t, ga[1] = r, Ho(e, ga, this.transformNoRotation));
  }
  getScreenTransform(e, t) {
    const { center: r } = this._viewpoint2D, n = this._get("pixelRatio") || 1, i = this._get("size");
    return _O(e, r, i, t, 0, n), e;
  }
  _update() {
    const { center: e, spatialReference: t, scale: r, rotation: n } = this._viewpoint2D, i = this._get("pixelRatio") || 1, s = this._get("size"), o = new Qo({ targetGeometry: new Re(e[0], e[1], t), scale: r, rotation: n });
    if (this._set("viewpoint", o), !s || !t || !r)
      return;
    this.resolution = vf(o), this.rotation = n, this.scale = r, this.spatialReference = t, cg(this.center, e);
    const a = s[0] !== 0 ? 2 / s[0] : 0, l = s[1] !== 0 ? -2 / s[1] : 0;
    OV(this.displayMat3, a, 0, 0, 0, l, 0, -1, 1, 1);
    const c = CV(this.viewMat3), h = Bh(s[0] / 2, s[1] / 2), f = Bh(-s[0] / 2, -s[1] / 2), m = gM(n);
    KT(c, c, h), kV(c, c, m), KT(c, c, f), $O(this.displayViewMat3, this.displayMat3, c);
    const y = gO(this.viewMat2d, h);
    return C_(y, y, m), ug(y, y, f), $ue(this.extent, o, s), SO(this.transform, o, s, i), mO(this.inverseTransform, this.transform), Cue(this.transformNoRotation, o, s, i), this.worldScreenWidth = Aue(this.spatialReference, this.resolution), this._set("id", this.id + 1), this;
  }
};
u([d({ readOnly: !0 })], Xl.prototype, "id", void 0), u([d({ value: 1, json: { write: !0 } })], Xl.prototype, "pixelRatio", null), u([d({ json: { write: !0 } })], Xl.prototype, "size", null), u([d()], Xl.prototype, "spatialReference", void 0), u([d({ type: Qo, json: { write: !0 } })], Xl.prototype, "viewpoint", null), Xl = YT = u([E("geoscene.views.2d.ViewState")], Xl);
const iR = Xl;
var QT, XT;
let Ga = QT = class extends Ae {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new QT({ left: this.left, top: this.top, right: this.right, bottom: this.bottom });
  }
};
u([d()], Ga.prototype, "left", void 0), u([d()], Ga.prototype, "top", void 0), u([d()], Ga.prototype, "right", void 0), u([d()], Ga.prototype, "bottom", void 0), Ga = QT = u([E("geoscene.views.2d.PaddedViewState.Padding")], Ga);
let Fp = XT = class extends iR {
  constructor(...e) {
    super(...e), this.paddedViewState = new iR(), this._updateContent = (() => {
      const t = yr();
      return () => {
        const r = this._get("size"), n = this._get("padding");
        if (!r || !n)
          return;
        const i = this.paddedViewState;
        Qr(t, n.left + n.right, n.top + n.bottom), dg(t, r, t), cg(i.size, t);
        const s = i.viewpoint;
        s && (this.viewpoint = s);
      };
    })(), this.addHandles(ze(() => [this.size, this.padding], () => this._updateContent(), Wg)), this.padding = new Ga(), this.size = [0, 0];
  }
  set padding(e) {
    this._set("padding", e || new Ga());
  }
  set viewpoint(e) {
    if (e) {
      const t = e.clone();
      this.paddedViewState.viewpoint = e, Rue(t, e, this._get("size"), this._get("padding"));
      const r = this._viewpoint2D, n = t.targetGeometry;
      r.center[0] = n.x, r.center[1] = n.y, r.rotation = t.rotation, r.scale = t.scale, r.spatialReference = n.spatialReference, this._update();
    }
  }
  clone() {
    return new XT({ padding: this.padding.clone(), size: this.size.slice(), viewpoint: this.paddedViewState.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
};
u([d()], Fp.prototype, "paddedViewState", void 0), u([d({ type: Ga })], Fp.prototype, "padding", null), u([d()], Fp.prototype, "viewpoint", null), Fp = XT = u([E("geoscene.views.2d.PaddedViewState")], Fp);
const Vce = Fp;
let Nn = class extends Ae {
  constructor(t) {
    super(t), this.constraints = null, this.ready = !1, this.resizeAlign = "center", this.addHandles([ze(() => {
      var r;
      return (r = this.constraints) == null ? void 0 : r.version;
    }, (r) => {
      this.constraints && r && this.ready && (this.state.viewpoint = this.constraints.fit(this.state.paddedViewState.viewpoint));
    }, Wg)]);
  }
  get center() {
    if (!this.ready)
      return this._get("center");
    const { center: t, spatialReference: r } = this.state.paddedViewState;
    return this.state.commitProperty("id"), new Re({ x: t[0], y: t[1], spatialReference: r });
  }
  set center(t) {
    if (t == null)
      return;
    if (!this.ready)
      return void this._set("center", t);
    let r;
    try {
      r = this._project(t, this.state.spatialReference);
    } catch (i) {
      return void se.getLogger(this).error(new G("mapview:invalid-center", "could not project the value in the view's spatial reference", { input: t, error: i }));
    }
    const n = this.viewpoint;
    HT(n, n, r), this.viewpoint = n;
  }
  get extent() {
    return this.ready ? (this.state.commitProperty("id"), this.state.paddedViewState.extent.clone()) : this._get("extent");
  }
  set extent(t) {
    if (t == null)
      return;
    if (!t.width || !t.height)
      return void se.getLogger(this).error(new G("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready)
      return this._set("extent", t), this._set("center", void 0), this._set("viewpoint", void 0), this._set("scale", void 0), void this._set("zoom", void 0);
    let r;
    try {
      r = this._project(t, this.state.spatialReference);
    } catch (i) {
      return void se.getLogger(this).error(new G("mapview:invalid-extent", "could not project the value in the view's spatial reference", { error: i }));
    }
    const n = this.viewpoint;
    xue(n, n, r, this.state.size, { constraints: this.constraints }), this.viewpoint = n;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(t) {
    this.ready ? (this.state.padding = t, this._set("padding", this.state.padding)) : this._set("padding", t);
  }
  get resolution() {
    return this.ready ? (this.state.commitProperty("id"), this.state.resolution) : 0;
  }
  get rotation() {
    return this.ready ? (this.state.commitProperty("id"), this.state.rotation) : this._get("rotation");
  }
  set rotation(t) {
    if (isNaN(t))
      return;
    if (!this.ready)
      return void this._set("rotation", t);
    const r = this.viewpoint;
    Nue(r, r, t), this.viewpoint = r;
  }
  get scale() {
    return this.ready ? (this.state.commitProperty("id"), this.state.scale) : this._get("scale");
  }
  set scale(t) {
    if (!t || isNaN(t))
      return;
    if (!this.ready) {
      this._set("scale", t), this._set("zoom", void 0);
      const n = this._get("extent");
      return void (n && (this._set("extent", void 0), this._set("center", n.center)));
    }
    const r = this.viewpoint;
    QP(r, r, t), this.viewpoint = r;
  }
  get viewpoint() {
    return this.ready ? this.state.paddedViewState.viewpoint.clone() : this._get("viewpoint");
  }
  set viewpoint(t) {
    var s;
    if (t == null)
      return;
    if (!this.ready)
      return this._set("viewpoint", t), this._set("extent", void 0), this._set("center", void 0), this._set("zoom", void 0), void this._set("scale", void 0);
    let r, n;
    try {
      r = this._project(t, this.state.spatialReference), !t.scale || isNaN(t.scale) ? n = new G("mapview:invalid-viewpoint", `invalid scale value of ${t.scale}`) : t.targetGeometry == null && (n = new G("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (o) {
      n = new G("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", { error: o });
    }
    if (n)
      return void se.getLogger(this).error(n);
    this._scaleBeforeChangingSpatialReference = null;
    const i = new Qo({ targetGeometry: new Re(), scale: 0, rotation: 0 });
    vo(i, r), (s = this.constraints) == null || s.constrain(i, this.state.paddedViewState.viewpoint), this.state.viewpoint = i, this._set("viewpoint", i);
  }
  get zoom() {
    var t;
    return this.ready ? ((t = this.constraints) == null ? void 0 : t.scaleToZoom(this.scale)) ?? -1 : this._get("zoom");
  }
  set zoom(t) {
    var i, s;
    if (!(t >= 0))
      return;
    if (!this.ready) {
      this._set("zoom", t), this._set("scale", void 0);
      const o = this._get("extent");
      return void (o && (this._set("extent", void 0), this._set("center", o.center)));
    }
    const r = ((i = this.constraints) == null ? void 0 : i.zoomToScale(t)) ?? 0;
    if (!r)
      return void this._set("zoom", -1);
    const n = this.viewpoint;
    QP(n, n, r), this.viewpoint = n, this._set("zoom", ((s = this.constraints) == null ? void 0 : s.scaleToZoom(this.scale)) ?? -1);
  }
  getUserStartupOptions(t) {
    if (!t[0] && !t[1])
      return { center: void 0, rotation: void 0, scale: void 0 };
    const { padding: r, constraints: n } = this, i = this._get("center"), s = this._get("extent"), o = this._get("scale"), a = this._get("rotation"), l = this._get("viewpoint"), c = this._get("zoom"), h = c != null && n != null && n.zoomToScale(c) || void 0;
    let f, m, y;
    const g = l == null ? void 0 : l.rotation, v = l == null ? void 0 : l.targetGeometry;
    (v == null ? void 0 : v.type) === "extent" ? f = v : (v == null ? void 0 : v.type) === "point" && (m = v, y = l == null ? void 0 : l.scale);
    const b = s ?? f;
    return { center: i ?? m ?? (b == null ? void 0 : b.center), rotation: a ?? g, scale: (o ?? h ?? y ?? (b && Sh(b, [t[0] - r.left - r.right, t[1] - r.top - r.bottom]))) || void 0 };
  }
  startup(t, r, n, i) {
    var o;
    const s = t.targetGeometry;
    try {
      this._project(t, n);
    } catch (a) {
      se.getLogger(this).warn(new bs("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", { center: s.toJSON(), spatialReference: n, error: a })), t.targetGeometry = i || new Re({ x: 0, y: 0, spatialReference: n });
    }
    (o = this.constraints) == null || o.fit(t), this._set("state", new Vce({ padding: this.padding, size: r, viewpoint: t })), this._set("ready", !0);
  }
  teardown() {
    this._set("ready", !1);
    const { center: [t, r], spatialReference: n, rotation: i, scale: s } = this.state.paddedViewState, o = new Re({ x: t, y: r, spatialReference: n });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", o), this._set("zoom", -1), this._set("rotation", i), this._set("scale", s), this._set("state", null);
  }
  changeSpatialReference(t) {
    var l;
    const r = this.state.paddedViewState.clone();
    if (this._scaleBeforeChangingSpatialReference == null)
      this._scaleBeforeChangingSpatialReference = r.scale;
    else {
      const c = r.viewpoint.clone();
      c.scale = this._scaleBeforeChangingSpatialReference, r.viewpoint = c;
    }
    const n = r.clone(), [i, s] = r.center;
    let o = null;
    try {
      o = this._project(new Re({ x: i, y: s, spatialReference: r.spatialReference }), t);
    } catch (c) {
      iO() || se.getLogger(this).warn(new bs("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", { center: o == null ? void 0 : o.toJSON(), spatialReference: t, error: c }));
    }
    o || (o = new Re({ x: 0, y: 0, spatialReference: t }));
    const a = HT(new Qo({ targetGeometry: new Re(), scale: 0, rotation: 0 }), r.viewpoint, o);
    n.viewpoint = a;
    try {
      const h = [r.size[0] / 2, r.size[1] / 2], f = [h[0] + 20, h[1]], m = r.toMap([0, 0], f), { x: y, y: g } = this._project(new Re({ x: m[0], y: m[1], spatialReference: r.spatialReference }), t);
      m[0] = y, m[1] = g, n.toScreen(m, m);
      const v = Pue(h, m, f), b = Math.hypot(m[0] - h[0], m[1] - h[1]) / 20;
      !Number.isFinite(b) || Math.abs(b) > 4 ? (a.rotation = 0, a.targetGeometry = new Re({ x: 0, y: 0, spatialReference: t })) : (a.scale *= b, a.scale > U("mapview-srswitch-adjust-rotation-scale-threshold") ? a.rotation = 0 : a.rotation += Number.isFinite(v) ? v : 0);
    } catch {
    }
    (l = this._get("constraints")) == null || l.constrain(a, void 0), this._get("state").viewpoint = a;
  }
  resize(t, r) {
    var o;
    if (!this.ready)
      return;
    const n = this.state;
    let i = this.state.paddedViewState.viewpoint;
    const s = this.state.paddedViewState.size.concat();
    n.size = [t, r], Lue(i, i, s, this.state.paddedViewState.size, this.resizeAlign), i = ((o = this.constraints) == null ? void 0 : o.constrain(i, void 0)) ?? i, this.state.viewpoint = i;
  }
  toMap(t) {
    if (!this.ready)
      return null;
    const r = [0, 0], [n, i] = this.state.toMap(r, [t.x, t.y]), s = this.state.spatialReference;
    return new Re({ x: n, y: i, spatialReference: s });
  }
  toScreen(t) {
    if (!this.ready)
      return null;
    const r = this._project(t, this.state.spatialReference), n = [r.x, r.y];
    return this.state.toScreen(n, n), Vn(n[0], n[1]);
  }
  _project(t, r) {
    var s;
    const n = t && t.targetGeometry || t;
    if (!r)
      return t;
    if (!n)
      return null;
    if (r.imageCoordinateSystem || (s = n.spatialReference) != null && s.imageCoordinateSystem || tn(r, n.spatialReference))
      return t;
    const i = Ju(n, r);
    if (!i)
      throw new G("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", { geometry: n, spatialReference: r });
    return zce(t) ? (t.targetGeometry = i, t) : i;
  }
};
function zce(e) {
  return (e == null ? void 0 : e.declaredClass) === "geoscene.Viewpoint";
}
u([d({ type: Re })], Nn.prototype, "center", null), u([d()], Nn.prototype, "constraints", void 0), u([d({ type: Ct })], Nn.prototype, "extent", null), u([d({ value: { top: 0, right: 0, bottom: 0, left: 0 }, cast: (e) => ({ top: 0, right: 0, bottom: 0, left: 0, ...e }) })], Nn.prototype, "padding", null), u([d()], Nn.prototype, "ready", void 0), u([d()], Nn.prototype, "resizeAlign", void 0), u([d({ readOnly: !0 })], Nn.prototype, "resolution", null), u([d({ type: Number })], Nn.prototype, "rotation", null), u([d({ type: Number })], Nn.prototype, "scale", null), u([d({ readOnly: !0 })], Nn.prototype, "state", void 0), u([d({ type: Qo })], Nn.prototype, "viewpoint", null), u([d()], Nn.prototype, "zoom", null), Nn = u([E("geoscene.views.2d.ViewStateManager")], Nn);
function xO(e, t) {
  switch (t) {
    case "primary":
      return e.pointerType === "touch" || e.button === 0;
    case "secondary":
      return e.pointerType !== "touch" && e.button === 2;
    case "tertiary":
      return e.pointerType !== "touch" && e.button === 1;
  }
}
let sR = class extends Br {
  constructor(t, r) {
    super(!0), this._view = t, this.registerIncoming("double-click", r, (n) => this._handleDoubleClick(n, r));
  }
  _handleDoubleClick(t, r) {
    xO(t.data, "primary") && (t.stopPropagation(), r ? this._view.mapViewNavigation.zoomOut([t.data.x, t.data.y]) : this._view.mapViewNavigation.zoomIn([t.data.x, t.data.y]));
  }
}, Uce = class extends Br {
  constructor(t, r, n) {
    super(!0), this.view = t, this.pointerType = r, this.registerIncoming("double-tap-drag", n, (i) => this._handleDoubleTapDrag(i));
  }
  _handleDoubleTapDrag(t) {
    const { data: r } = t, { pointerType: n } = r;
    if (n !== this.pointerType)
      return;
    t.stopPropagation();
    const { action: i, delta: s } = r, { view: o } = this, { mapViewNavigation: a } = o;
    switch (i) {
      case "begin": {
        const { scale: l } = o;
        this._startScale = l, this._currentScale = l, this._previousDelta = s, a.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === s.y)
          return;
        this._previousDelta = s;
        const l = 1.015 ** s.y, c = this._startScale * l, h = c / this._currentScale;
        a.setViewpointImmediate(h), this._currentScale = c;
        break;
      }
      case "end": {
        const { constraints: l } = o, { effectiveLODs: c, snapToZoom: h } = l;
        if (!h || !c)
          return void a.end();
        const f = l.snapScale(this._currentScale), m = (s.y > 0 ? Math.max(f, l.snapToPreviousScale(this._startScale)) : Math.min(f, l.snapToNextScale(this._startScale))) / this._currentScale;
        a.zoom(m);
        break;
      }
    }
  }
}, A_ = class {
  constructor(t) {
    this._callbacks = t, this._currentCount = 0, this._callbacks.condition || (this._callbacks.condition = () => !0);
  }
  handle(t) {
    const r = t.data, n = r.pointers.size;
    switch (r.action) {
      case "start":
        this._currentCount = n, this._emitStart(t);
        break;
      case "added":
        this._emitEnd(this._previousEvent), this._currentCount = n, this._emitStart(t);
        break;
      case "update":
        this._emitUpdate(t);
        break;
      case "removed":
        this._startEvent && this._emitEnd(this._previousEvent), this._currentCount = n, this._emitStart(t);
        break;
      case "end":
        this._emitEnd(t), this._currentCount = 0;
    }
    this._previousEvent = t;
  }
  _emitStart(t) {
    var r, n;
    this._startEvent = t, (n = (r = this._callbacks).condition) != null && n.call(r, this._currentCount, t) && this._callbacks.start(this._currentCount, t, this._startEvent);
  }
  _emitUpdate(t) {
    var r, n;
    (n = (r = this._callbacks).condition) != null && n.call(r, this._currentCount, t) && this._callbacks.update(this._currentCount, t, this._startEvent);
  }
  _emitEnd(t) {
    var r, n;
    (n = (r = this._callbacks).condition) != null && n.call(r, this._currentCount, t) && this._callbacks.end(this._currentCount, t, this._startEvent), this._startEvent = null;
  }
}, Bce = class extends Br {
  constructor(t, r, n) {
    super(!0), this.view = t, this.pointerAction = r, this.registerIncoming("drag", n, (i) => this._handleDrag(i)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(t) {
    super.onInstall(t), this._dragEventSeparator = new A_({ start: (r, n) => {
      this.view.mapViewNavigation.pan.begin(this.view, n.data), n.stopPropagation();
    }, update: (r, n) => {
      this.view.mapViewNavigation.pan.update(this.view, n.data), n.stopPropagation();
    }, end: (r, n) => {
      this.view.mapViewNavigation.pan.end(this.view, n.data), n.stopPropagation();
    }, condition: (r, n) => r === 1 && xO(n.data, this.pointerAction) });
  }
  _handleDrag(t) {
    const r = this.view.mapViewNavigation;
    r.pinch.zoomMomentum || r.pinch.rotateMomentum ? this.stopMomentumNavigation() : this._dragEventSeparator.handle(t);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
}, qce = class extends Br {
  constructor(t, r, n) {
    super(!0), this._view = t, this.pointerAction = r;
    const i = this._view.mapViewNavigation;
    this._dragEventSeparator = new A_({ start: (s, o) => {
      i.rotate.begin(this._view, o.data), o.stopPropagation();
    }, update: (s, o) => {
      i.rotate.update(this._view, o.data), o.stopPropagation();
    }, end: (s, o) => {
      i.rotate.end(), o.stopPropagation();
    }, condition: (s, o) => s === 1 && xO(o.data, this.pointerAction) }), this.registerIncoming("drag", n, (s) => this._dragEventSeparator.handle(s));
  }
};
function Rs(e) {
  let t = e * e;
  return e < 0 && (t *= -1), t;
}
function Gce(e) {
  return e.translation[0] = 0, e.translation[1] = 0, e.translation[2] = 0, e.heading = 0, e.tilt = 0, e;
}
function Hce(e, t, r) {
  const n = r, i = e.state, s = e.device, o = t.tiltDirection === "forward-down" ? 1 : -1, a = 1;
  return s.deviceType === "standard" ? (n.translation[0] = Rs(i.axes[0]), n.translation[1] = Rs(i.axes[1]), n.translation[2] = Rs(i.buttons[7]) - Rs(i.buttons[6]), n.heading = Rs(i.axes[2]), n.tilt = Rs(i.axes[3])) : s.deviceType === "spacemouse" && (n.translation[0] = 1.2 * Rs(i.axes[0]), n.translation[1] = 1.2 * Rs(i.axes[1]), n.translation[2] = 2 * -Rs(i.axes[2]), n.heading = 1.2 * Rs(i.axes[5]), n.tilt = 1.2 * Rs(i.axes[3])), n.tilt *= o, Z6(n.translation, n.translation, a), n;
}
function Wce(e) {
  return e.translation[0] === 0 && e.translation[1] === 0 && e.translation[2] === 0 && e.heading === 0 && e.tilt === 0 && e.zoom === 0;
}
let Jce = class extends Br {
  constructor(t) {
    super(!0), this._view = t, this._frameTask = null, this._watchHandles = new ca(), this._currentDevice = null, this._transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, this._handle = this.registerIncoming("gamepad", (r) => this._handleGamePadEvent(r)), this._handle.pause();
  }
  onInstall(t) {
    super.onInstall(t), this._watchHandles.add([ze(() => {
      var r;
      return (r = this._view.navigation.gamepad) == null ? void 0 : r.enabled;
    }, (r) => {
      r ? (this._handle.resume(), this._frameTask || (this._frameTask = Ah({ update: (n) => this._frameUpdate(n.deltaTime) }))) : (this._handle.pause(), this._frameTask && (this._frameTask.remove(), this._frameTask = null));
    }, ln)]);
  }
  onUninstall() {
    this._watchHandles.removeAll(), this._frameTask && (this._frameTask.remove(), this._frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t) {
    const r = this._view.navigation.gamepad.device;
    r && t.data.device !== r || this._currentDevice && this._currentDevice !== t.data.device || (t.data.action === "end" ? (this._currentDevice = null, Gce(this._transformation)) : (this._currentDevice = t.data.device, Hce(t.data, this._view.navigation.gamepad, this._transformation)));
  }
  _frameUpdate(t) {
    const r = this._transformation;
    if (Wce(r))
      return;
    const n = this._view.viewpoint.clone(), i = this._view.navigation.gamepad.velocityFactor, s = Kce * i * t;
    k_(n, n, [r.translation[0] * s, -r.translation[1] * s]);
    const o = 1 + r.translation[2] * Yce * t, a = this._view.constraints.rotationEnabled ? -r.heading * Zce * t : 0, l = this._view.size, c = [l[0] / 2, l[1]];
    vV(n, n, o, a, c, l);
    const h = this._view.constraints.constrain(n, this._view.viewpoint);
    this._view.viewpoint = h;
  }
};
const Zce = 0.06, Kce = 0.7, Yce = 6e-4;
let Qce = class extends Br {
  constructor(t, r, n) {
    super(!0), this.view = t, this.keys = r, this._pressed = !1, this._keyMap = { [r.left]: "left", [r.right]: "right", [r.up]: "up", [r.down]: "down" }, this.registerIncoming("key-down", n, (i) => this._handleKeyDown(i)), this.registerIncoming("key-up", n, (i) => this._handleKeyUp(i)), this.registerIncoming("blur", n, () => this._handleBlur());
  }
  _handleKeyDown(t) {
    t.data.repeat || this._handleKey(t, !0);
  }
  _handleKeyUp(t) {
    this._handleKey(t, !1);
  }
  _handleBlur() {
    this._pressed && (this._pressed = !1, this.view.mapViewNavigation.stop());
  }
  _handleKey(t, r) {
    const n = this._keyMap[t.data.key];
    if (this._pressed = n != null, this._pressed) {
      if (r)
        switch (this.view.mapViewNavigation.begin(), n) {
          case "left":
            this.view.mapViewNavigation.continousPanLeft();
            break;
          case "right":
            this.view.mapViewNavigation.continousPanRight();
            break;
          case "up":
            this.view.mapViewNavigation.continousPanUp();
            break;
          case "down":
            this.view.mapViewNavigation.continousPanDown();
        }
      else
        this._pressed = !1, this.view.mapViewNavigation.stop();
      t.stopPropagation();
    }
  }
}, Xce = class extends Br {
  constructor(t, r, n) {
    super(!0), this.view = t, this.keys = r, this._pressed = !1, this._keyToDirection = { [r.clockwiseOption1]: "clockwise", [r.clockwiseOption2]: "clockwise", [r.counterClockwiseOption1]: "counterClockwise", [r.counterClockwiseOption2]: "counterClockwise", [r.resetOption1]: "reset", [r.resetOption2]: "reset" }, this.registerIncoming("key-down", n, (i) => this._handleKeyDown(i)), this.registerIncoming("key-up", n, (i) => this._handleKeyUp(i)), this.registerIncoming("blur", n, () => this._handleBlur());
  }
  _handleKeyDown(t) {
    t.data.repeat || this._handleKey(t, !0);
  }
  _handleKeyUp(t) {
    this._handleKey(t, !1);
  }
  _handleBlur() {
    this._pressed && (this._pressed = !1, this.view.mapViewNavigation.stop());
  }
  _handleKey(t, r) {
    const n = t.modifiers;
    if (n.size > 0 && !n.has("Shift") || !this.view.constraints.rotationEnabled)
      return;
    const i = this._keyToDirection[t.data.key];
    if (this._pressed = i != null, this._pressed) {
      if (r)
        switch (this.view.mapViewNavigation.begin(), i) {
          case "clockwise":
            this.view.mapViewNavigation.continousRotateClockwise();
            break;
          case "counterClockwise":
            this.view.mapViewNavigation.continousRotateCounterclockwise();
            break;
          case "reset":
            this.view.mapViewNavigation.resetRotation();
        }
      else
        this._pressed = !1, this.view.mapViewNavigation.stop();
      t.stopPropagation();
    }
  }
};
var hh;
(function(e) {
  e[e.IN = 0] = "IN", e[e.OUT = 1] = "OUT";
})(hh || (hh = {}));
let ede = class extends Br {
  constructor(t, r, n) {
    super(!0), this.view = t, this.keys = r, this._keysToZoomAction = {}, this.registerIncoming("key-down", n, (i) => this._handleKeyDown(i)), r.zoomIn.forEach((i) => this._keysToZoomAction[i] = hh.IN), r.zoomOut.forEach((i) => this._keysToZoomAction[i] = hh.OUT);
  }
  _handleKeyDown(t) {
    this._handleKey(t);
  }
  _handleKey(t) {
    const r = t.modifiers;
    if (r.size > 0 && !r.has("Shift"))
      return;
    const { key: n } = t.data;
    if (!(n in this._keysToZoomAction))
      return;
    const i = this._keysToZoomAction[n], { mapViewNavigation: s } = this.view;
    let o = null;
    switch (i) {
      case hh.IN:
        o = s.zoomIn();
        break;
      case hh.OUT:
        o = s.zoomOut();
        break;
      default:
        return;
    }
    s.begin(), o.then(() => s.end()), t.stopPropagation();
  }
};
const tde = 0.6;
let rde = class extends Br {
  constructor(t, r) {
    super(!0), this._view = t, this._canZoom = !0, this.registerIncoming("mouse-wheel", r, (n) => this._handleMouseWheel(n));
  }
  _handleMouseWheel(t) {
    if (!this._view.navigation.mouseWheelZoomEnabled || (t.preventDefault(), t.stopPropagation(), !this._canZoom))
      return;
    const r = this._view.mapViewNavigation, { x: n, y: i, deltaY: s } = t.data, o = 1 / tde ** (1 / 60 * s), a = r.zoom(o, [n, i]);
    a && (this._canZoom = !1, a.catch(() => {
    }).then(() => {
      this._canZoom = !0, r.end();
    }));
  }
}, nde = class extends Br {
  constructor(t) {
    super(!0), this.view = t, this.registerIncoming("drag", (n) => this._handleDrag(n)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const r = this.view.mapViewNavigation;
    this._dragEventSeparator = new A_({ start: (n, i) => {
      r.pinch.begin(this.view, i.data), i.stopPropagation();
    }, update: (n, i) => {
      r.pinch.update(this.view, i.data), i.stopPropagation();
    }, end: (n, i) => {
      r.pinch.end(this.view), i.stopPropagation();
    }, condition: (n) => n >= 2 });
  }
  _handleDrag(t) {
    this._dragEventSeparator.handle(t);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
};
function oR(e) {
  const t = e.native;
  return t ? { buttons: t.buttons.map((r) => r.pressed ? r.value || 1 : 0), axes: t.axes.map((r) => ode(r, e.axisThreshold)) } : { buttons: [], axes: [] };
}
function ide(e, t) {
  if (e.axes.length !== t.axes.length || e.buttons.length !== t.buttons.length)
    return !1;
  for (let r = 0; r < e.axes.length; r++)
    if (e.axes[r] !== t.axes[r])
      return !1;
  for (let r = 0; r < e.buttons.length; r++)
    if (e.buttons[r] !== t.buttons[r])
      return !1;
  return !0;
}
function sde(e) {
  for (let t = 0; t < e.axes.length; t++)
    if (e.axes[t] !== 0)
      return !1;
  for (let t = 0; t < e.buttons.length; t++)
    if (e.buttons[t] !== 0)
      return !1;
  return !0;
}
function ode(e, t) {
  const r = Math.abs(e);
  return r < t ? 0 : Math.sign(e) * (r - t) / (1 - t);
}
let ade = class {
  constructor(t, r) {
    this._element = t, this._input = r, this._hasEventListeners = !1, this._onConnectGamepad = (s) => {
      this._connectGamepad(s.gamepad);
    }, this._onDisconnectGamepad = (s) => {
      const o = s.gamepad, a = o.index, l = this._inputDevices[a];
      l && (this._emitGamepadEvent(o, oR(l), !1), this._inputDevices.splice(a, 1), this._latestUpdate.splice(a, 1), this._input.gamepad.devices.remove(l), this.ensurePollingState());
    }, this._frameTask = null, this._latestUpdate = new Array(), this._inputDevices = new Array(), this._callback = null;
    const n = "getGamepads" in window.navigator, i = window.isSecureContext;
    this.supported = n && i, this.supported && (this._forEachGamepad((s) => this._connectGamepad(s)), window.addEventListener("gamepadconnected", this._onConnectGamepad), window.addEventListener("gamepaddisconnected", this._onDisconnectGamepad), this.ensurePollingState());
  }
  destroy() {
    this.hasEventListeners = !1, this.supported && (window.removeEventListener("gamepadconnected", this._onConnectGamepad), window.removeEventListener("gamepaddisconnected", this._onDisconnectGamepad));
  }
  set hasEventListeners(t) {
    this._hasEventListeners !== t && (this._hasEventListeners = t, this.ensurePollingState());
  }
  get _eventsEnabled() {
    return this.supported && this._inputDevices.length > 0 && this._hasEventListeners;
  }
  set onEvent(t) {
    this._callback = t;
  }
  _connectGamepad(t) {
    const r = new hO(t);
    r.deviceType !== "unknown" && (this._inputDevices[t.index] = r, this._input.gamepad.devices.add(r)), this.ensurePollingState();
  }
  ensurePollingState() {
    this._eventsEnabled ? this._startPolling() : this._stopPolling();
  }
  _startPolling() {
    this._frameTask == null && (this._frameTask = Ah({ update: () => this._readGamepadState() }));
  }
  _stopPolling() {
    this._frameTask != null && (this._frameTask.remove(), this._frameTask = null, this._latestUpdate = new Array());
  }
  _readGamepadState() {
    const t = document.hasFocus(), r = this._element.contains(document.activeElement), n = this._input.gamepad.enabledFocusMode === "document" && !t || this._input.gamepad.enabledFocusMode === "view" && !r;
    this._forEachGamepad((i) => {
      const s = this._inputDevices[i.index];
      if (!s)
        return;
      const o = this._latestUpdate[i.index], a = oR(s), l = n || sde(a);
      o && (o.timestamp === i.timestamp || !o.active && l || ide(o.state, a)) || this._emitGamepadEvent(i, a, !l);
    });
  }
  _forEachGamepad(t) {
    const r = window.navigator.getGamepads();
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      this._validate(i) && t(i);
    }
  }
  _emitGamepadEvent(t, r, n) {
    const i = this._latestUpdate[t.index], s = i && i.active;
    if (!s && !n)
      return;
    const o = !s && n ? "start" : s && n ? "update" : "end";
    this._latestUpdate[t.index] = { timestamp: t.timestamp, state: r, active: n }, this._callback && this._callback({ device: this._inputDevices[t.index], state: r, action: o });
  }
  _validate(t) {
    if (!t || !t.connected)
      return !1;
    for (let r = 0; r < t.axes.length; r++)
      if (isNaN(t.axes[r]))
        return !1;
    return !0;
  }
};
const aR = U("edge"), lde = U("chrome"), ude = U("ff"), cde = U("safari"), lR = "geoscene-view-surface", mp = { touchNone: `${lR}--touch-none`, touchPan: `${lR}--touch-pan` };
let DV = class jV {
  constructor(t, r) {
    this._input = r, this._active = {}, this._callback = () => {
    }, this._activePointerCaptures = /* @__PURE__ */ new Set(), this._keyDownState = /* @__PURE__ */ new Set(), this._eventId = 1, this._browserTouchPanningEnabled = !1, this._element = t, t.getAttribute("tabindex") || t.setAttribute("tabindex", "0"), this._eventHandlers = { "key-down": this._handleKey, "key-up": this._handleKey, "pointer-down": this._handlePointer, "pointer-move": this._handlePointerPreventDefault, "pointer-up": this._handlePointerPreventDefault, "pointer-enter": this._handlePointer, "pointer-leave": this._handlePointer, "pointer-cancel": this._handlePointer, "mouse-wheel": this._handleMouseWheel, "pointer-capture-lost": this._handlePointerCaptureLost }, this._updateTouchAction(), this._element.addEventListener("keydown", this._preventAltKeyDefault), this._gamepadSource = new ade(t, this._input), this._gamepadSource.onEvent = (n) => this._callback("gamepad", n);
  }
  destroy() {
    this._callback = () => {
    }, this.activeEvents = null, this._activePointerCaptures.forEach((t) => {
      this._releasePointerCaptureSafe(t);
    }), this._gamepadSource = Vt(this._gamepadSource), this._activePointerCaptures = null, this._removeTouchAction(), this._element.removeEventListener("keydown", this._preventAltKeyDefault);
  }
  get browserTouchPanningEnabled() {
    return this._browserTouchPanningEnabled;
  }
  set browserTouchPanningEnabled(t) {
    this._browserTouchPanningEnabled = t, this._updateTouchAction(), this._updateTouchEventHandling();
  }
  set onEventReceived(t) {
    this._callback = t;
  }
  set activeEvents(t) {
    for (const r in this._active)
      if (!t || !t.has(r)) {
        const n = this._active[r];
        this._element.removeEventListener(vS[r], n), delete this._active[r];
      }
    t && t.forEach((r) => {
      if (!this._active[r] && vS[r]) {
        const n = (this._eventHandlers[r] || this._handleDefault).bind(this, r);
        this._element.addEventListener(vS[r], n), this._active[r] = n;
      }
    }), this._gamepadSource.hasEventListeners = (t == null ? void 0 : t.has("gamepad")) ?? !1;
  }
  setPointerCapture(t, r) {
    r ? this._setPointerCatpureSafe(t.pointerId) : (this._releasePointerCaptureSafe(t.pointerId), this._activePointerCaptures.delete(t.pointerId));
  }
  _updateTouchAction() {
    this._element.classList.remove(this._browserTouchPanningEnabled ? mp.touchNone : mp.touchPan), this._element.classList.add(this._browserTouchPanningEnabled ? mp.touchPan : mp.touchNone);
  }
  _updateTouchEventHandling() {
    this._browserTouchPanningEnabled ? this._element.addEventListener("touchmove", this._preventMultiTouchPanning) : this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _removeTouchAction() {
    this._element.classList.remove(mp.touchNone), this._element.classList.remove(mp.touchPan), this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _setPointerCatpureSafe(t) {
    try {
      this._element.setPointerCapture(t), this._activePointerCaptures.add(t);
    } catch {
    }
  }
  _releasePointerCaptureSafe(t) {
    try {
      if (this._element.hasPointerCapture && !this._element.hasPointerCapture(t))
        return;
      this._element.releasePointerCapture(t);
    } catch {
    }
  }
  _updateNormalizedPointerLikeEvent(t, r) {
    const n = z9(this._element, t);
    return jV.test.disableSubpixelCoordinates && (n.x = Math.round(n.x), n.y = Math.round(n.y)), r.x = n.x, r.y = n.y, r;
  }
  _handleKey(t, r) {
    const n = $ae(r);
    n && t === "key-up" && this._keyDownState.delete(n);
    const i = { native: r, key: n, repeat: !!n && this._keyDownState.has(n) };
    n && t === "key-down" && this._keyDownState.add(i.key), this._callback(t, i);
  }
  _handlePointer(t, r) {
    const n = this._updateNormalizedPointerLikeEvent(r, { native: r, x: 0, y: 0, pointerType: r.pointerType, button: r.button, buttons: r.buttons, eventId: this._eventId++ });
    this._callback(t, n);
  }
  _handlePointerPreventDefault(t, r) {
    const n = this._updateNormalizedPointerLikeEvent(r, { native: r, x: 0, y: 0, pointerType: r.pointerType, button: r.button, buttons: r.buttons, eventId: this._eventId++ });
    r.preventDefault(), this._callback(t, n);
  }
  _handleMouseWheel(t, r) {
    let n = r.deltaY;
    switch (r.deltaMode) {
      case 0:
        aR && (n = n / document.documentElement.clientHeight * 600);
        break;
      case 1:
        n *= 30;
        break;
      case 2:
        n *= 900;
    }
    aR ? n *= 0.7 : lde || cde ? n *= 0.6 : ude && (n *= 1.375);
    const i = 100, s = Math.abs(n);
    s > i && (n = n / s * 200 / (1 + Math.exp(-0.02 * (s - i))));
    const o = this._updateNormalizedPointerLikeEvent(r, { native: r, x: 0, y: 0, deltaY: n });
    this._callback(t, o);
  }
  _handlePointerCaptureLost(t, r) {
    this._activePointerCaptures.delete(r.pointerId), this._handleDefault(t, r);
  }
  _handleDefault(t, r) {
    const n = { native: r };
    r.preventDefault(), this._callback(t, n);
  }
  _preventAltKeyDefault(t) {
    t.key === "Alt" && t.preventDefault();
  }
  _preventMultiTouchPanning(t) {
    t.touches.length > 1 && t.preventDefault();
  }
};
DV.test = { disableSubpixelCoordinates: !1 };
const vS = { "key-down": "keydown", "key-up": "keyup", "pointer-down": "pointerdown", "pointer-up": "pointerup", "pointer-move": "pointermove", "mouse-wheel": "wheel", "pointer-capture-got": "gotpointercapture", "pointer-capture-lost": "lostpointercapture", "context-menu": "contextmenu", "pointer-enter": "pointerenter", "pointer-leave": "pointerleave", "pointer-cancel": "pointercancel", focus: "focus", blur: "blur" };
let dde = class extends Br {
  constructor() {
    super(!0), this.registerIncoming("context-menu", (t) => {
      t.data.native.preventDefault();
    });
  }
};
function TO(e, t) {
  return Math.abs(t.x - e.x) + Math.abs(t.y - e.y);
}
function pde(e, t) {
  const r = t.x - e.x, n = t.y - e.y;
  return Math.sqrt(r * r + n * n);
}
function hde(e, t) {
  if (t ? (t.radius = 0, t.center.x = 0, t.center.y = 0) : t = { radius: 0, center: Vn() }, e.length === 0)
    return t;
  if (e.length === 1)
    return t.center.x = e[0].x, t.center.y = e[0].y, t;
  if (e.length === 2) {
    const [$, T] = e, [C, I] = [T.x - $.x, T.y - $.y];
    return t.radius = Math.sqrt(C * C + I * I) / 2, t.center.x = ($.x + T.x) / 2, t.center.y = ($.y + T.y) / 2, t;
  }
  let r = 0, n = 0;
  for (let $ = 0; $ < e.length; $++)
    r += e[$].x, n += e[$].y;
  r /= e.length, n /= e.length;
  const i = e.map(($) => $.x - r), s = e.map(($) => $.y - n);
  let o = 0, a = 0, l = 0, c = 0, h = 0, f = 0, m = 0;
  for (let $ = 0; $ < i.length; $++) {
    const T = i[$], C = s[$], I = T * T, O = C * C;
    o += I, a += O, l += T * C, c += I * T, h += O * C, f += T * O, m += C * I;
  }
  const y = 0.5 * (c + f), g = 0.5 * (h + m), v = o * a - l * l, b = (y * a - g * l) / v, w = (o * g - l * y) / v, x = Vn(b + r, w + n);
  return { radius: Math.sqrt(b * b + w * w + (o + a) / e.length), center: x };
}
function _d(e) {
  const { native: t } = e, { pointerId: r, button: n, pointerType: i } = t;
  return i === "mouse" ? `${r}:${n}` : `${i}`;
}
const ps = { maximumDoubleClickDelay: 250, maximumDoubleClickDistance: 10, maximumDoubleTouchDelay: 350, maximumDoubleTouchDistance: 35 };
let fde = class extends Br {
  constructor(t = ps.maximumDoubleClickDelay, r = ps.maximumDoubleClickDistance, n = ps.maximumDoubleTouchDelay, i = ps.maximumDoubleTouchDistance, s = rf) {
    super(!1), this._maximumDoubleClickDelay = t, this._maximumDoubleClickDistance = r, this._maximumDoubleTouchDelay = n, this._maximumDoubleTouchDistance = i, this._clock = s, this._pointerState = /* @__PURE__ */ new Map(), this._click = this.registerOutgoing("click"), this._doubleClick = this.registerOutgoing("double-click"), this.registerIncoming("immediate-click", this._handleImmediateClick.bind(this)), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this));
  }
  onUninstall() {
    this._pointerState.forEach((t) => t.doubleClickTimer = tr(t.doubleClickTimer));
  }
  get hasPendingInputs() {
    return Qw(this._pointerState, (t) => t.doubleClickTimer != null);
  }
  _clearDoubleClickTimer(t, r) {
    const n = this._pointerState.get(t);
    n && (n.doubleClickTimer = tr(n.doubleClickTimer), r && this._click.emit(n.event.data, void 0, n.event.modifiers), this._pointerState.delete(t), this.refreshHasPendingInputs());
  }
  _doubleClickTimeoutExceeded(t) {
    const r = this._pointerState.get(t);
    r.pointerDownCount === 1 && this._click.emit(r.event.data, void 0, r.event.modifiers), r.doubleClickTimer = null, this._pointerState.delete(t), this.refreshHasPendingInputs();
  }
  _getPointerId(t) {
    const { pointerId: r, pointerType: n, button: i } = t.native;
    return n === "mouse" ? `${r}:${i}` : `${n}`;
  }
  _handleImmediateClick(t) {
    const r = t.data, { pointerType: n } = r.native, i = this._getPointerId(r);
    if (!this._pointerState.has(i))
      return void this._startClick(t);
    const s = this._pointerState.get(i), { data: o, modifiers: a } = s.event, l = n === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
    TO(o, r) > l ? (this._clearDoubleClickTimer(i, !0), this._startClick(t)) : (this._clearDoubleClickTimer(i, !1), s.pointerDownCount === 2 && this._doubleClick.emit(o, void 0, a));
  }
  _handlePointerDown(t) {
    const r = _d(t.data), n = this._pointerState.get(r);
    n && (n.pointerDownCount += 1);
  }
  _startClick(t) {
    const { data: r } = t, { native: { pointerType: n } } = r, i = _d(r), s = n === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, o = this._clock.setTimeout(() => this._doubleClickTimeoutExceeded(i), s), a = 1;
    this._pointerState.set(i, { event: t, doubleClickTimer: o, pointerDownCount: a }), this.refreshHasPendingInputs();
  }
}, mde = class extends Br {
  constructor(t = ps.maximumDoubleClickDelay, r = ps.maximumDoubleClickDistance, n = ps.maximumDoubleTouchDelay, i = ps.maximumDoubleTouchDistance, s = rf) {
    super(!1), this._maximumDoubleClickDelay = t, this._maximumDoubleClickDistance = r, this._maximumDoubleTouchDelay = n, this._maximumDoubleTouchDistance = i, this._clock = s, this._doubleTapDragReady = !1, this._doubleTapDragActive = !1, this._dragStartCenter = Vn(0, 0), this._pointerState = /* @__PURE__ */ new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new A_({ start: (o, a) => this._dragStart(o, a), update: (o, a) => this._dragUpdate(a), end: (o, a) => this._dragEnd(a) }), this.registerIncoming("drag", (o) => this._dragEventSeparator.handle(o)), this.registerIncoming("pointer-down", (o) => this._handlePointerDown(o)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.doubleTapTimeout = tr(t.doubleTapTimeout);
    });
  }
  get hasPendingInputs() {
    return Qw(this._pointerState, (t) => t.doubleTapTimeout != null);
  }
  _clearPointerDown(t) {
    const r = this._pointerState.get(t);
    r && (r.doubleTapTimeout = tr(r.doubleTapTimeout), this._pointerState.delete(t), this.refreshHasPendingInputs());
  }
  _createDoubleTapDragData(t, r, n) {
    const { button: i, buttons: s, pointer: o, pointers: a, pointerType: l, timestamp: c } = n;
    return { action: t, delta: r, button: i, buttons: s, pointer: o, pointers: a, pointerType: l, timestamp: c };
  }
  _dragStart(t, r) {
    if (!this._doubleTapDragReady || t !== 1)
      return;
    this._doubleTapDragReady = !1, this._doubleTapDragActive = !0;
    const { data: n, modifiers: i } = r, { center: s } = n;
    this._dragStartCenter = s;
    const o = this._createDoubleTapDragData("begin", Vn(0, 0), n);
    this._doubleTapDrag.emit(o, void 0, i), r.stopPropagation();
  }
  _dragUpdate(t) {
    if (!this._doubleTapDragActive)
      return;
    const { data: r, modifiers: n } = t, { center: i } = r, s = Vn(i.x - this._dragStartCenter.x, i.y - this._dragStartCenter.y), o = this._createDoubleTapDragData("update", s, r);
    this._doubleTapDrag.emit(o, void 0, n), t.stopPropagation();
  }
  _dragEnd(t) {
    if (!this._doubleTapDragActive)
      return;
    const { data: r, modifiers: n } = t, { center: i } = r, s = Vn(i.x - this._dragStartCenter.x, i.y - this._dragStartCenter.y), o = this._createDoubleTapDragData("end", s, r);
    this._doubleTapDrag.emit(o, void 0, n), this._doubleTapDragActive = !1, t.stopPropagation();
  }
  _handlePointerDown(t) {
    const { data: r } = t, n = _d(r), i = this._pointerState.get(n), { pointerType: s } = r.native;
    if (i) {
      const o = s === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
      this._clearPointerDown(n), TO(i.event.data, r) > o ? this._storePointerDown(t) : this._doubleTapDragReady = !0;
    } else
      this._storePointerDown(t);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = !1;
  }
  _storePointerDown(t) {
    const { data: r } = t, { pointerType: n } = r.native, i = _d(r), s = n === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, o = this._clock.setTimeout(() => this._clearPointerDown(i), s);
    this._pointerState.set(i, { event: t, doubleTapTimeout: o }), this.refreshHasPendingInputs();
  }
}, yde = class extends Br {
  constructor(t) {
    super(!1), this._navigationTouch = t, this._startStateModifiers = /* @__PURE__ */ new Set(), this._activePointerMap = /* @__PURE__ */ new Map(), this._isDragging = !1, this._isCurrentDragSuppressed = !1, this._drag = this.registerOutgoing("drag"), this.registerIncoming("pointer-drag", this._handlePointerDrag.bind(this)), this.registerIncoming("pointer-up", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-capture-lost", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-cancel", this._handlePointerUpAndPointerLost.bind(this));
  }
  _createPayload(t, r, n, i) {
    return { action: t, pointerType: this._pointerType, button: this._mouseButton, buttons: r.buttons, timestamp: i, pointers: gde(this._activePointerMap), pointer: r, angle: n.angle, radius: n.radius, center: n.center };
  }
  _addPointer(t) {
    const r = t.native.pointerId, n = Q0(this._activePointerMap).angle, i = { event: t, initialAngle: 0, lastAngle: 0 };
    this._activePointerMap.set(r, i);
    const s = w1(i, VV(this._activePointerMap));
    i.initialAngle = s, i.lastAngle = s, this._updatePointerAngles(n);
  }
  _updatePointer(t) {
    if (t && t.x == null && t.y == null)
      return;
    const r = t.native.pointerId, n = this._activePointerMap.get(r);
    n ? n.event = t : this._addPointer(t);
  }
  _removePointer(t) {
    const r = Q0(this._activePointerMap).angle;
    this._activePointerMap.delete(t), this._updatePointerAngles(r);
  }
  _updatePointerAngles(t) {
    const r = Q0(this._activePointerMap);
    this._activePointerMap.forEach((n) => {
      n.initialAngle = w1(n, r) - t, n.lastAngle = w1(n, r) - t;
    });
  }
  _emitEvent(t, r, n) {
    const i = Q0(this._activePointerMap);
    this._drag.emit(this._createPayload(t, r, i, n), void 0, this._startStateModifiers);
  }
  _handlePointerUpAndPointerLost(t) {
    const r = t.data.native.pointerId, n = t.timestamp;
    this._activePointerMap.get(r) && (this._activePointerMap.size === 1 ? (this._updatePointer(t.data), !this._isCurrentDragSuppressed && this._emitEvent("end", t.data, n), this._isDragging = !1, this._isCurrentDragSuppressed = !1, this._removePointer(r)) : (this._removePointer(r), this._emitEvent("removed", t.data, t.timestamp)));
  }
  _handlePointerDrag(t) {
    const r = t.data, n = r.currentEvent, i = t.timestamp;
    switch (r.action) {
      case "start":
      case "update":
        this._isDragging ? this._activePointerMap.has(n.native.pointerId) ? (this._updatePointer(n), !this._isCurrentDragSuppressed && this._emitEvent("update", n, i)) : (this._addPointer(n), this._emitEvent("added", n, i), this._isCurrentDragSuppressed = this._isSuppressed) : (this._updatePointer(n), this._pointerType = t.data.startEvent.pointerType, this._mouseButton = t.data.startEvent.button, this._startStateModifiers = t.modifiers, this._isDragging = !0, this._isCurrentDragSuppressed = this._isSuppressed, !this._isCurrentDragSuppressed && this._emitEvent("start", n, i));
    }
  }
  get _isSuppressed() {
    return !!this._navigationTouch && !this._navigationTouch.browserTouchPanEnabled && this._pointerType === "touch" && this._activePointerMap.size === 1;
  }
};
function VV(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(Vn(r.event.x, r.event.y));
  }), hde(t);
}
function Q0(e) {
  const t = VV(e);
  let r = 0;
  return e.forEach((n) => {
    let i = w1(n, t), s = i - n.lastAngle;
    for (; s > Math.PI; )
      s -= 2 * Math.PI;
    for (; s < -Math.PI; )
      s += 2 * Math.PI;
    i = n.lastAngle + s, n.lastAngle = i;
    const o = i - n.initialAngle;
    r += o;
  }), r /= e.size || 1, { angle: r, radius: t.radius, center: t.center };
}
function gde(e) {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r, n) => t.set(n, r.event)), t;
}
function w1(e, t) {
  const r = e.event, n = r.x - t.center.x, i = r.y - t.center.y;
  return Math.atan2(i, n);
}
var uR;
(function(e) {
  e[e.Left = 0] = "Left", e[e.Middle = 1] = "Middle", e[e.Right = 2] = "Right", e[e.Back = 3] = "Back", e[e.Forward = 4] = "Forward", e[e.Undefined = -1] = "Undefined";
})(uR || (uR = {}));
let vde = class extends Br {
  constructor(t = ps.maximumDoubleClickDelay, r = ps.maximumDoubleClickDistance, n = ps.maximumDoubleTouchDelay, i = ps.maximumDoubleTouchDistance, s = rf) {
    super(!1), this._maximumDoubleClickDelay = t, this._maximumDoubleClickDistance = r, this._maximumDoubleTouchDelay = n, this._maximumDoubleTouchDistance = i, this._clock = s, this._pointerState = /* @__PURE__ */ new Map(), this._immediateDoubleClick = this.registerOutgoing("immediate-double-click"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", this._handlePointerUp.bind(this));
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.immediateDoubleClick && t.immediateDoubleClick.timeoutHandle.remove();
    }), super.onUninstall();
  }
  _handlePointerDown(t) {
    const r = t.data, n = _d(r);
    if (!this._pointerState.has(n)) {
      const i = { downButton: r.native.button, immediateDoubleClick: null };
      this._pointerState.set(n, i), this.startCapturingPointer(r.native);
    }
  }
  _handlePointerUp(t) {
    const r = t.data, n = _d(r), i = this._pointerState.get(n);
    if (i && i.downButton === r.native.button) {
      const s = i.immediateDoubleClick;
      if (s) {
        s.timeoutHandle.remove();
        const o = t.data.native.pointerType === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
        TO(s, t.data) > o ? this._startImmediateDoubleClick(t, i) : (this._immediateDoubleClick.emit(t.data, void 0, s.modifiers), this._removeState(r));
      } else
        this._startImmediateDoubleClick(t, i);
    }
  }
  _startImmediateDoubleClick(t, r) {
    const n = t.data.native.pointerType === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay;
    r.immediateDoubleClick = { x: t.data.x, y: t.data.y, modifiers: t.modifiers, timeoutHandle: this._clock.setTimeout(() => this._removeState(t.data), n) };
  }
  _removeState(t) {
    const r = _d(t);
    this._pointerState.delete(r), this.stopCapturingPointer(t.native), this.refreshHasPendingInputs();
  }
};
const Qf = { maximumClickDelay: 300, movementUntilMouseDrag: 1.5, movementUntilPenDrag: 6, movementUntilTouchDrag: 6, holdDelay: 500 };
let bde = class extends Br {
  constructor(t = Qf.maximumClickDelay, r = Qf.movementUntilMouseDrag, n = Qf.movementUntilPenDrag, i = Qf.movementUntilTouchDrag, s = Qf.holdDelay, o = rf) {
    super(!1), this._maximumClickDelay = t, this._movementUntilMouseDrag = r, this._movementUntilPenDrag = n, this._movementUntilTouchDrag = i, this._holdDelay = s, this._clock = o, this._pointerState = /* @__PURE__ */ new Map(), this._pointerDrag = this.registerOutgoing("pointer-drag"), this._immediateClick = this.registerOutgoing("immediate-click"), this._pointerHold = this.registerOutgoing("hold"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", (a) => {
      this._handlePointerLoss(a, "pointer-up");
    }), this.registerIncoming("pointer-capture-lost", (a) => {
      this._handlePointerLoss(a, "pointer-capture-lost");
    }), this.registerIncoming("pointer-cancel", (a) => {
      this._handlePointerLoss(a, "pointer-cancel");
    }), this._moveHandle = this.registerIncoming("pointer-move", this._handlePointerMove.bind(this)), this._moveHandle.pause();
  }
  onUninstall() {
    this._pointerState.forEach((t) => {
      t.holdTimeout = tr(t.holdTimeout);
    }), super.onUninstall();
  }
  _handlePointerDown(t) {
    const r = t.data, n = r.native.pointerId;
    let i = null;
    this._pointerState.size === 0 && (i = this._clock.setTimeout(() => {
      const o = this._pointerState.get(n);
      if (o) {
        if (!o.isDragging) {
          const a = o.previousEvent;
          this._pointerHold.emit(a, void 0, t.modifiers), o.holdEmitted = !0;
        }
        o.holdTimeout = null;
      }
    }, this._holdDelay));
    const s = { startEvent: r, previousEvent: r, startTimestamp: t.timestamp, isDragging: !1, downButton: r.native.button, holdTimeout: i, modifiers: /* @__PURE__ */ new Set() };
    this._pointerState.set(n, s), this.startCapturingPointer(r.native), this._moveHandle.resume(), this._pointerState.size > 1 && this._startDragging(t);
  }
  _createPointerDragData(t, r, n) {
    return { action: t, startEvent: r.startEvent, previousEvent: r.previousEvent, currentEvent: n };
  }
  _handlePointerMove(t) {
    const r = t.data, n = r.native.pointerId, i = this._pointerState.get(n);
    i && (i.isDragging ? this._pointerDrag.emit(this._createPointerDragData("update", i, r), void 0, i.modifiers) : pde(r, i.startEvent) > this._getDragThreshold(r.native.pointerType) && this._startDragging(t), i.previousEvent = r);
  }
  _getDragThreshold(t) {
    switch (t) {
      case "touch":
        return this._movementUntilTouchDrag;
      case "pen":
        return this._movementUntilPenDrag;
      default:
        return this._movementUntilMouseDrag;
    }
  }
  _startDragging(t) {
    const r = t.data, n = r.native.pointerId;
    this._pointerState.forEach((i) => {
      i.holdTimeout != null && (i.holdTimeout.remove(), i.holdTimeout = null), i.isDragging || (i.modifiers = t.modifiers, i.isDragging = !0, n === i.startEvent.native.pointerId ? this._pointerDrag.emit(this._createPointerDragData("start", i, r)) : this._pointerDrag.emit(this._createPointerDragData("start", i, i.previousEvent), t.timestamp));
    });
  }
  _handlePointerLoss(t, r) {
    const n = t.data, i = n.native.pointerId, s = this._pointerState.get(i);
    s && (s.holdTimeout != null && (s.holdTimeout.remove(), s.holdTimeout = null), s.isDragging ? this._pointerDrag.emit(this._createPointerDragData("end", s, r === "pointer-up" ? n : s.previousEvent), void 0, s.modifiers) : r === "pointer-up" && s.downButton === n.native.button && t.timestamp - s.startTimestamp <= this._maximumClickDelay && !s.holdEmitted && this._immediateClick.emit(n), this._pointerState.delete(i), this.stopCapturingPointer(n.native), this._pointerState.size === 0 && this._moveHandle.pause());
  }
};
const X0 = { counter: "Ctrl", pan: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }, zoom: { zoomIn: ["=", "+"], zoomOut: ["-", "_"] }, rotate: { clockwiseOption1: "a", clockwiseOption2: "A", counterClockwiseOption1: "d", counterClockwiseOption2: "D", resetOption1: "n", resetOption2: "N" } };
let Mc = class extends Ae {
  constructor() {
    super(...arguments), this._handles = new ca();
  }
  initialize() {
    const t = () => {
      var r;
      return (r = this.view) == null ? void 0 : r.ready;
    };
    this._handles.add([Au(() => !t(), () => this._disconnect()), Au(t, () => this._connect())]);
  }
  destroy() {
    this._handles = Vt(this._handles), this._disconnect();
  }
  get latestPointerType() {
    var t;
    return (t = this._inputManager) == null ? void 0 : t.latestPointerType;
  }
  get latestPointerLocation() {
    var t;
    return (t = this._inputManager) == null ? void 0 : t.latestPointerLocation;
  }
  get multiTouchActive() {
    var t;
    return ((t = this._inputManager) == null ? void 0 : t.multiTouchActive) ?? !1;
  }
  _disconnect() {
    this.view.viewEvents.disconnect(), this._inputManager = Vt(this._inputManager);
  }
  _connect() {
    const t = this.view.surface, r = new DV(t, this.view.input), n = [new vde(), new bde(), new fde(), new yde(this.view.navigation), new mde()], i = new es({ eventSource: r, recognizers: n });
    i.installHandlers("prevent-context-menu", [new dde()], Iu.INTERNAL), i.installHandlers("navigation", [new nde(this.view), new Jce(this.view), new rde(this.view), new sR(this.view), new sR(this.view, [X0.counter]), new Bce(this.view, "primary"), new Qce(this.view, X0.pan), new ede(this.view, X0.zoom), new Xce(this.view, X0.rotate), new qce(this.view, "secondary"), new Uce(this.view, "touch")], Iu.INTERNAL), this.view.viewEvents.connect(i), this._source = r, this._inputManager = i, ze(() => {
      var s, o;
      return (o = (s = this.view) == null ? void 0 : s.navigation) == null ? void 0 : o.browserTouchPanEnabled;
    }, (s) => {
      this._source && (this._source.browserTouchPanningEnabled = !s);
    }, ln);
  }
  get test() {
    return { inputManager: this._inputManager };
  }
};
u([d()], Mc.prototype, "view", void 0), u([d()], Mc.prototype, "latestPointerType", null), u([d()], Mc.prototype, "latestPointerLocation", null), u([d()], Mc.prototype, "multiTouchActive", null), Mc = u([E("geoscene.views.2d.input.MapViewInputManager")], Mc);
const wde = Mc;
var lNe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _de(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var cR, dR, pR, eE = { exports: {} };
eE.exports, cR = eE, dR = function() {
  function e(i, s, o, a, l) {
    t(i, s, o || 0, a || i.length - 1, l || n);
  }
  function t(i, s, o, a, l) {
    for (; a > o; ) {
      if (a - o > 600) {
        var c = a - o + 1, h = s - o + 1, f = Math.log(c), m = 0.5 * Math.exp(2 * f / 3), y = 0.5 * Math.sqrt(f * m * (c - m) / c) * (h - c / 2 < 0 ? -1 : 1);
        t(i, s, Math.max(o, Math.floor(s - h * m / c + y)), Math.min(a, Math.floor(s + (c - h) * m / c + y)), l);
      }
      var g = i[s], v = o, b = a;
      for (r(i, o, s), l(i[a], g) > 0 && r(i, o, a); v < b; ) {
        for (r(i, v, b), v++, b--; l(i[v], g) < 0; )
          v++;
        for (; l(i[b], g) > 0; )
          b--;
      }
      l(i[o], g) === 0 ? r(i, o, b) : r(i, ++b, a), b <= s && (o = b + 1), s <= b && (a = b - 1);
    }
  }
  function r(i, s, o) {
    var a = i[s];
    i[s] = i[o], i[o] = a;
  }
  function n(i, s) {
    return i < s ? -1 : i > s ? 1 : 0;
  }
  return e;
}, (pR = dR()) !== void 0 && (cR.exports = pR);
const Sde = _de(eE.exports);
function sw(e, t) {
  if (!(this instanceof sw))
    return new sw(e, t);
  this._maxEntries = Math.max(4, e || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), t && (typeof t == "function" ? this.toBBox = t : this._initFormat(t)), this.clear();
}
function $de(e, t, r) {
  if (!r)
    return t.indexOf(e);
  for (var n = 0; n < t.length; n++)
    if (r(e, t[n]))
      return n;
  return -1;
}
function yp(e, t) {
  Gm(e, 0, e.children.length, t, e);
}
function Gm(e, t, r, n, i) {
  i || (i = Dp(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (var s, o = t; o < r; o++)
    s = e.children[o], Hm(i, e.leaf ? n(s) : s);
  return i;
}
function Hm(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function hR(e, t) {
  return e.minX - t.minX;
}
function fR(e, t) {
  return e.minY - t.minY;
}
function bS(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function ev(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function xde(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function Tde(e, t) {
  var r = Math.max(e.minX, t.minX), n = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);
  return Math.max(0, i - r) * Math.max(0, s - n);
}
function wS(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function tv(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function Dp(e) {
  return { children: e, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function mR(e, t, r, n, i) {
  for (var s, o = [t, r]; o.length; )
    (r = o.pop()) - (t = o.pop()) <= n || (s = t + Math.ceil((r - t) / n / 2) * n, Sde(e, s, t, r, i), o.push(t, s, s, r));
}
sw.prototype = { all: function() {
  return this._all(this.data, []);
}, search: function(e) {
  var t = this.data, r = [], n = this.toBBox;
  if (!tv(e, t))
    return r;
  for (var i, s, o, a, l = []; t; ) {
    for (i = 0, s = t.children.length; i < s; i++)
      o = t.children[i], tv(e, a = t.leaf ? n(o) : o) && (t.leaf ? r.push(o) : wS(e, a) ? this._all(o, r) : l.push(o));
    t = l.pop();
  }
  return r;
}, collides: function(e) {
  var t = this.data, r = this.toBBox;
  if (!tv(e, t))
    return !1;
  for (var n, i, s, o, a = []; t; ) {
    for (n = 0, i = t.children.length; n < i; n++)
      if (s = t.children[n], tv(e, o = t.leaf ? r(s) : s)) {
        if (t.leaf || wS(e, o))
          return !0;
        a.push(s);
      }
    t = a.pop();
  }
  return !1;
}, load: function(e) {
  if (!e || !e.length)
    return this;
  if (e.length < this._minEntries) {
    for (var t = 0, r = e.length; t < r; t++)
      this.insert(e[t]);
    return this;
  }
  var n = this._build(e.slice(), 0, e.length - 1, 0);
  if (this.data.children.length)
    if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        var i = this.data;
        this.data = n, n = i;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
  else
    this.data = n;
  return this;
}, insert: function(e) {
  return e && this._insert(e, this.data.height - 1), this;
}, clear: function() {
  return this.data = Dp([]), this;
}, remove: function(e, t) {
  if (!e)
    return this;
  for (var r, n, i, s, o = this.data, a = this.toBBox(e), l = [], c = []; o || l.length; ) {
    if (o || (o = l.pop(), n = l[l.length - 1], r = c.pop(), s = !0), o.leaf && (i = $de(e, o.children, t)) !== -1)
      return o.children.splice(i, 1), l.push(o), this._condense(l), this;
    s || o.leaf || !wS(o, a) ? n ? (r++, o = n.children[r], s = !1) : o = null : (l.push(o), c.push(r), r = 0, n = o, o = o.children[0]);
  }
  return this;
}, toBBox: function(e) {
  return e;
}, compareMinX: hR, compareMinY: fR, toJSON: function() {
  return this.data;
}, fromJSON: function(e) {
  return this.data = e, this;
}, _all: function(e, t) {
  for (var r = []; e; )
    e.leaf ? t.push.apply(t, e.children) : r.push.apply(r, e.children), e = r.pop();
  return t;
}, _build: function(e, t, r, n) {
  var i, s = r - t + 1, o = this._maxEntries;
  if (s <= o)
    return yp(i = Dp(e.slice(t, r + 1)), this.toBBox), i;
  n || (n = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, n - 1))), (i = Dp([])).leaf = !1, i.height = n;
  var a, l, c, h, f = Math.ceil(s / o), m = f * Math.ceil(Math.sqrt(o));
  for (mR(e, t, r, m, this.compareMinX), a = t; a <= r; a += m)
    for (mR(e, a, c = Math.min(a + m - 1, r), f, this.compareMinY), l = a; l <= c; l += f)
      h = Math.min(l + f - 1, c), i.children.push(this._build(e, l, h, n - 1));
  return yp(i, this.toBBox), i;
}, _chooseSubtree: function(e, t, r, n) {
  for (var i, s, o, a, l, c, h, f; n.push(t), !t.leaf && n.length - 1 !== r; ) {
    for (h = f = 1 / 0, i = 0, s = t.children.length; i < s; i++)
      l = bS(o = t.children[i]), (c = xde(e, o) - l) < f ? (f = c, h = l < h ? l : h, a = o) : c === f && l < h && (h = l, a = o);
    t = a || t.children[0];
  }
  return t;
}, _insert: function(e, t, r) {
  var n = this.toBBox, i = r ? e : n(e), s = [], o = this._chooseSubtree(i, this.data, t, s);
  for (o.children.push(e), Hm(o, i); t >= 0 && s[t].children.length > this._maxEntries; )
    this._split(s, t), t--;
  this._adjustParentBBoxes(i, s, t);
}, _split: function(e, t) {
  var r = e[t], n = r.children.length, i = this._minEntries;
  this._chooseSplitAxis(r, i, n);
  var s = this._chooseSplitIndex(r, i, n), o = Dp(r.children.splice(s, r.children.length - s));
  o.height = r.height, o.leaf = r.leaf, yp(r, this.toBBox), yp(o, this.toBBox), t ? e[t - 1].children.push(o) : this._splitRoot(r, o);
}, _splitRoot: function(e, t) {
  this.data = Dp([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, yp(this.data, this.toBBox);
}, _chooseSplitIndex: function(e, t, r) {
  var n, i, s, o, a, l, c, h;
  for (l = c = 1 / 0, n = t; n <= r - t; n++)
    o = Tde(i = Gm(e, 0, n, this.toBBox), s = Gm(e, n, r, this.toBBox)), a = bS(i) + bS(s), o < l ? (l = o, h = n, c = a < c ? a : c) : o === l && a < c && (c = a, h = n);
  return h;
}, _chooseSplitAxis: function(e, t, r) {
  var n = e.leaf ? this.compareMinX : hR, i = e.leaf ? this.compareMinY : fR;
  this._allDistMargin(e, t, r, n) < this._allDistMargin(e, t, r, i) && e.children.sort(n);
}, _allDistMargin: function(e, t, r, n) {
  e.children.sort(n);
  var i, s, o = this.toBBox, a = Gm(e, 0, t, o), l = Gm(e, r - t, r, o), c = ev(a) + ev(l);
  for (i = t; i < r - t; i++)
    s = e.children[i], Hm(a, e.leaf ? o(s) : s), c += ev(a);
  for (i = r - t - 1; i >= t; i--)
    s = e.children[i], Hm(l, e.leaf ? o(s) : s), c += ev(l);
  return c;
}, _adjustParentBBoxes: function(e, t, r) {
  for (var n = r; n >= 0; n--)
    Hm(t[n], e);
}, _condense: function(e) {
  for (var t, r = e.length - 1; r >= 0; r--)
    e[r].children.length === 0 ? r > 0 ? (t = e[r - 1].children).splice(t.indexOf(e[r]), 1) : this.clear() : yp(e[r], this.toBBox);
}, _initFormat: function(e) {
  var t = ["return a", " - b", ";"];
  this.compareMinX = new Function("a", "b", t.join(e[0])), this.compareMinY = new Function("a", "b", t.join(e[1])), this.toBBox = new Function("a", "return {minX: a" + e[0] + ", minY: a" + e[1] + ", maxX: a" + e[2] + ", maxY: a" + e[3] + "};");
} };
var tE;
const yR = new et({ upperLeft: "upper-left", lowerLeft: "lower-left" });
let Oc = tE = class extends re {
  constructor(e) {
    super(e), this.extent = null, this.mode = "view", this.originPosition = "upper-left", this.tolerance = 1;
  }
  clone() {
    return new tE(j({ extent: this.extent, mode: this.mode, originPosition: this.originPosition, tolerance: this.tolerance }));
  }
};
u([d({ type: Ct, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], Oc.prototype, "extent", void 0), u([d({ type: ["view", "edit"], json: { write: !0 } })], Oc.prototype, "mode", void 0), u([d({ type: String, json: { read: yR.read, write: yR.write } })], Oc.prototype, "originPosition", void 0), u([d({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], Oc.prototype, "tolerance", void 0), Oc = tE = u([E("geoscene.rest.support.QuantizationParameters")], Oc);
const zV = Oc;
let gR = class UV {
  constructor(t, r) {
    this.key = new Dd(0, 0, 0, 0), this.bounds = sa(), this.objectIds = /* @__PURE__ */ new Set(), this.key.set(r);
    const n = t.getLODInfoAt(this.key);
    this.tileInfoView = t, this.tileInfoView.getTileBounds(this.bounds, this.key, !0), this.resolution = n.resolution, this.scale = n.scale, this.level = n.level;
  }
  get id() {
    return this.key.id;
  }
  get extent() {
    return Ct.fromBounds(this.bounds, this.tileInfoView.tileInfo.spatialReference);
  }
  get transform() {
    return { originPosition: "upperLeft", scale: [this.resolution, this.resolution], translate: [this.bounds[0], this.bounds[3]] };
  }
  createChildTiles() {
    const t = this.key.getChildKeys(), r = jn.acquire();
    for (let n = 0; n < t.length; n++)
      r[n] = new UV(this.tileInfoView, t[n]);
    return r;
  }
  getQuantizationParameters() {
    return zV.fromJSON({ mode: "view", originPosition: "upperLeft", tolerance: this.resolution, extent: { xmin: this.bounds[0], ymin: this.bounds[1], xmax: this.bounds[2], ymax: this.bounds[3], spatialReference: this.tileInfoView.tileInfo.spatialReference } });
  }
};
const ic = { added: [], removed: [] }, _S = /* @__PURE__ */ new Set(), Ede = new Dd(0, 0, 0, 0);
let Ide = class extends Uu {
  constructor(t) {
    super(), this._tiles = /* @__PURE__ */ new Map(), this._index = sw(9, U("geoscene-csp-restrictions") ? (r) => ({ minX: r.bounds[0], minY: r.bounds[1], maxX: r.bounds[2], maxY: r.bounds[3] }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = t;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(t) {
    return this._tiles.has(t);
  }
  get(t) {
    return this._tiles.get(t);
  }
  boundsIntersections(t) {
    return this._index.search({ minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] });
  }
  updateTiles(t) {
    const r = { added: [], removed: [] };
    for (const n of t.added)
      if (!this.has(n)) {
        const i = new gR(this.tileScheme, n);
        this._tiles.set(n, i), this._index.insert(i), r.added.push(i);
      }
    for (const n of t.removed)
      if (this.has(n)) {
        const i = this.get(n);
        this._tiles.delete(n), this._index.remove(i), r.removed.push(i);
      }
    this.tiles.length = 0, this._tiles.forEach((n) => this.tiles.push(n)), (r.added.length || r.removed.length) && this.emit("update", r);
  }
  setViewState(t) {
    const r = this.tileScheme.getTileCoverage(t, 0);
    if (!r)
      return;
    const { spans: n, lodInfo: i } = r, { level: s } = i;
    if (n.length > 0)
      for (const { row: o, colFrom: a, colTo: l } of n)
        for (let c = a; c <= l; c++) {
          const h = Ede.set(s, o, i.normalizeCol(c), i.getWorldForColumn(c)).id;
          if (_S.add(h), !this.has(h)) {
            const f = new gR(this.tileScheme, h);
            this._tiles.set(h, f), this._index.insert(f), this.tiles.push(f), ic.added.push(f);
          }
        }
    for (let o = this.tiles.length - 1; o >= 0; o--) {
      const a = this.tiles[o];
      _S.has(a.id) || (this._tiles.delete(a.id), this.tiles.splice(o, 1), this._index.remove(a), ic.removed.push(a));
    }
    (ic.added.length || ic.removed.length) && this.emit("update", ic), pg.pool.release(r), _S.clear(), ic.added.length = 0, ic.removed.length = 0;
  }
}, Cc = class extends Ae {
  constructor() {
    super(...arguments), this.color = new Me([0, 255, 255]), this.haloOpacity = 1, this.fillOpacity = 0.25;
  }
  equals(t) {
    return this.color.equals(t.color) && (this.haloColor || this.color).equals(t.haloColor || t.color) && this.haloOpacity === t.haloOpacity && this.fillOpacity === t.fillOpacity;
  }
};
u([d({ type: Me })], Cc.prototype, "color", void 0), u([d({ type: Me })], Cc.prototype, "haloColor", void 0), u([d()], Cc.prototype, "haloOpacity", void 0), u([d()], Cc.prototype, "fillOpacity", void 0), Cc = u([E("geoscene.views.2d.support.HighlightOptions")], Cc);
const BV = Cc, Mde = (e) => e.includes("Brush");
let qV = class {
  constructor() {
    this._names = /* @__PURE__ */ new Map();
  }
  begin(t) {
    this._names.has(t) || (this._names.set(t, !1), Mde(t) && this.record("Esri.FirstDraw"), performance.mark(`Esri.${t}.Start`));
  }
  end(t) {
    this._names.has(t) && !this._names.get(t) && (this._names.set(t, !0), performance.mark(`Esri.${t}.End`));
  }
  record(t) {
    this._names.has(t) || (this._names.set(t, !0), performance.mark(`Esri.${t}`));
  }
};
function Ode(e, t, r, n, i, s, o, a) {
  e.ignorePadding && (n = { left: 0, right: 0, top: 0, bottom: 0 });
  let l = null;
  e.width != null && e.height != null ? l = [e.width, e.height] : e.width == null && e.height != null ? l = [e.height, e.height] : e.width != null && e.height == null ? l = [e.width, e.width] : e.width == null && e.height == null && (l = null);
  const c = r[0] - (n.left + n.right), h = r[1] - (n.top + n.bottom);
  let f, m, y = e.area || { x: 0, y: 0, width: c, height: h };
  if (l) {
    const g = c / h, v = l[0] / l[1];
    if (v > g) {
      const b = y.width / v;
      y = { x: y.x, y: Math.round(y.y + (y.height - b) / 2), width: y.width, height: Math.round(b) };
    } else {
      const b = y.height * v;
      y = { x: Math.round(y.x + (y.width - b) / 2), y: y.y, width: Math.round(b), height: y.height };
    }
  } else
    l = [y.width, y.height];
  return l[0] > y.width ? (f = Math.min(l[0] / y.width, t), m = l[0] / y.width / f) : (f = 1, m = l[0] / y.width), { resolutionScale: f, cropArea: { x: Math.round((y.x + n.left) * f), y: Math.round((y.y + n.top) * f), width: Math.round(y.width * f), height: Math.round(y.height * f) }, outputScale: m, format: i, quality: s, children: o, rotation: a };
}
function Cde(e, t, r) {
  const { ctx: n, canvas: i } = GV(e, r), s = n.getImageData(0, 0, e.width, e.height), o = Pde(i, t);
  return HV(i), { dataUrl: o, data: s };
}
function kde(e, t) {
  const { ctx: r, canvas: n } = GV(e, t), i = r.getImageData(0, 0, e.width, e.height);
  return HV(n), i;
}
function GV(e, t) {
  const r = Ade();
  t.premultipliedAlpha && Dde(e), r.width = e.width, r.height = e.height;
  const n = r.getContext("2d", { willReadFrequently: !0 });
  return n.putImageData(e, 0, 0), t.flipY && Fde(n), { ctx: n, canvas: r };
}
function HV(e) {
  e.width = 0, e.height = 0;
}
function Ade() {
  return SS == null && (SS = document.createElement("canvas")), SS;
}
let SS = null;
function Pde(e, t) {
  const r = jde[t.format], n = t.quality / 100;
  return e.toDataURL(r, n);
}
function Rde(e, t) {
  const r = Nde(e), n = zde[r];
  return { format: r, quality: ws(t ?? n, 0, 100) };
}
function Lde(e, t) {
  return t / Math.max(e[0], e[1]);
}
function pNe(e, t, r, n = 0, i = 0, s = e.width - n, o = e.height - i, a = !1) {
  const { data: l } = e, { width: c, height: h, data: f } = t, m = s / c, y = o / h, g = Math.ceil(m / 2), v = Math.ceil(y / 2), b = e.width;
  for (let w = 0; w < h; w++)
    for (let x = 0; x < c; x++) {
      const $ = 4 * (x + (a ? h - w - 1 : w) * c);
      let T = 0, C = 0, I = 0, O = 0, M = 0, L = 0;
      const N = (w + 0.5) * y;
      for (let ee = Math.floor(w * y); ee < (w + 1) * y; ee++) {
        const D = Math.abs(N - (ee + 0.5)) / v, H = (x + 0.5) * m, J = D * D;
        for (let oe = Math.floor(x * m); oe < (x + 1) * m; oe++) {
          const ye = Math.abs(H - (oe + 0.5)) / g, Q = Math.sqrt(J + ye * ye);
          if (Q >= 1)
            continue;
          let ve = 2 * Q * Q * Q - 3 * Q * Q + 1;
          const Ee = 4 * (n + oe + (i + ee) * b);
          L += ve * l[Ee + 3], C += ve, !r && l[Ee + 3] < 255 && (ve = ve * l[Ee + 3] / 255), I += ve * l[Ee], O += ve * l[Ee + 1], M += ve * l[Ee + 2], T += ve;
        }
      }
      f[$] = I / T, f[$ + 1] = O / T, f[$ + 2] = M / T, f[$ + 3] = L / C;
    }
  return t;
}
function Nde(e) {
  switch (e) {
    case "png":
    case "jpg":
    case "jpeg":
      return e;
    default:
      return Vde;
  }
}
function Fde(e) {
  e.save(), e.globalCompositeOperation = "copy", e.scale(1, -1), e.translate(0, -e.canvas.height), e.drawImage(e.canvas, 0, 0), e.restore();
}
function Dde(e) {
  const t = e.data, r = t.length;
  for (let n = 0; n < r; n += 4) {
    const i = t[n + 3];
    if (i !== 255 && i > 0) {
      const s = 255 / i;
      t[n] = t[n] * s, t[n + 1] = t[n + 1] * s, t[n + 2] = t[n + 2] * s;
    }
  }
}
const jde = { png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg" }, vR = 98, Vde = "png", zde = { png: 100, jpg: vR, jpeg: vR };
var kr;
function rE(e, t, r = {}) {
  const n = t === kr.WEBGL1 ? ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"] : ["webgl2"];
  for (const i of n) {
    const s = e.getContext(i, r);
    if (s)
      return s;
  }
  return null;
}
function hNe(e, t, r = {}) {
  const n = WV(e);
  for (const i of n) {
    const s = rE(t, i, r);
    if (s)
      return s;
  }
  return null;
}
function WV(e) {
  if (e === "3d")
    return [kr.WEBGL2];
  const t = U("geoscene-force-webgl");
  return t === kr.WEBGL1 || t === kr.WEBGL2 ? [t] : U("mac") && U("chrome") ? [kr.WEBGL1, kr.WEBGL2] : [kr.WEBGL2, kr.WEBGL1];
}
(function(e) {
  e[e.WEBGL1 = 1] = "WEBGL1", e[e.WEBGL2 = 2] = "WEBGL2";
})(kr || (kr = {}));
let $S, xS;
function Ude(e) {
  const t = WV(e);
  for (; t.length > 1; ) {
    const r = bR(t.shift());
    if (r.available)
      return r;
  }
  return bR(t.shift());
}
function bR(e) {
  switch (e) {
    case kr.WEBGL1:
      return Bde();
    case kr.WEBGL2:
      return qde();
  }
}
function Bde() {
  return $S || ($S = Wde()), $S;
}
function qde() {
  return xS || (xS = Jde()), xS;
}
let JV = class {
  constructor() {
    this.available = !1, this.majorPerformanceCaveat = !1, this.maxTextureSize = 0, this.supportsVertexShaderSamplers = !1, this.supportsHighPrecisionFragment = !1, this.supportsElementIndexUint = !1, this.supportsStandardDerivatives = !1, this.supportsInstancedArrays = !1, this.supportsTextureFloat = !1, this.supportsTextureHalfFloat = !1, this.supportsColorBufferFloat = !1, this.supportsColorBufferFloatBlend = !1, this.supportsColorBufferHalfFloat = !1;
  }
}, Gde = class extends JV {
  constructor() {
    super(...arguments), this.type = kr.WEBGL1;
  }
}, Hde = class extends JV {
  constructor() {
    super(...arguments), this.type = kr.WEBGL2, this.supportsElementIndexUint = !0, this.supportsStandardDerivatives = !0, this.supportsInstancedArrays = !0, this.supportsTextureFloat = !0, this.supportsTextureHalfFloat = !0;
  }
};
function ZV(e, t) {
  if (e === kr.WEBGL1 && typeof WebGLRenderingContext > "u" || e === kr.WEBGL2 && typeof WebGL2RenderingContext > "u")
    return null;
  const r = document.createElement("canvas");
  if (!r)
    return null;
  let n = rE(r, e, { failIfMajorPerformanceCaveat: !0 });
  if (n == null && (n = rE(r, e), n != null && (t.majorPerformanceCaveat = !0)), n == null)
    return n;
  if (e === kr.WEBGL1) {
    const s = n.getParameter(n.VERSION), o = s == null ? void 0 : s.match(/^WebGL\s+([\d.]*)/);
    if (o) {
      const a = parseFloat(o[1]);
      t.available = a >= 0.94;
    }
  } else
    t.available = !0;
  t.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), t.supportsVertexShaderSamplers = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
  const i = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT);
  return i && (t.supportsHighPrecisionFragment = i.precision > 0), n;
}
function Wde() {
  const e = new Gde(), t = ZV(kr.WEBGL1, e);
  return t == null || (e.supportsElementIndexUint = t.getExtension("OES_element_index_uint") !== null, e.supportsStandardDerivatives = t.getExtension("OES_standard_derivatives") !== null, e.supportsInstancedArrays = t.getExtension("ANGLE_instanced_arrays") !== null, e.supportsTextureFloat = t.getExtension("OES_texture_float") !== null, e.supportsTextureHalfFloat = t.getExtension("OES_texture_half_float") !== null, e.supportsColorBufferFloat = t.getExtension("WEBGL_color_buffer_float") !== null, e.supportsColorBufferFloatBlend = t.getExtension("EXT_float_blend") !== null, e.supportsColorBufferHalfFloat = t.getExtension("EXT_color_buffer_half_float") !== null), e;
}
function Jde() {
  const e = new Hde(), t = ZV(kr.WEBGL2, e);
  return t == null || (e.supportsColorBufferFloat = t.getExtension("EXT_color_buffer_float") !== null, e.supportsColorBufferFloatBlend = t.getExtension("EXT_float_blend") !== null, e.supportsColorBufferHalfFloat = e.supportsColorBufferFloat || t.getExtension("EXT_color_buffer_half_float") !== null), e;
}
function Zde(e) {
  const t = Ude(e);
  if (!t.available)
    return new G("webgl:required", e === "3d" ? "WebGL2 is required but not supported." : "WebGL is required but not supported.", new Error().stack);
  if (e === "3d" && t.majorPerformanceCaveat)
    return new G("webgl:major-performance-caveat-detected", "Your WebGL implementation doesn't seem to support hardware accelerated rendering. Check your browser settings or if your GPU is in a blocklist.");
  if (!t.supportsHighPrecisionFragment)
    return new G("webgl:high-precision-fragment-required", "WebGL support for high precision fragment shaders is required but not supported.");
  if (!t.supportsVertexShaderSamplers)
    return new G("webgl:vertex-shader-samplers-required", "WebGL support for vertex shader samplers is required but not supported.");
  if (t.type === kr.WEBGL1) {
    if (!t.supportsElementIndexUint)
      return new G("webgl:element-index-uint-required", "WebGL support for uint vertex indices is required but not supported.");
    if (!t.supportsStandardDerivatives)
      return new G("webgl:standard-derivatives-required", "WebGL support for standard derivatives is required but not supported.");
    if (!t.supportsInstancedArrays)
      return new G("webgl:instanced-arrays-required", "WebGL support for instanced rendering is required but not supported.");
  }
  return null;
}
function Kde(e) {
  return e && "nodeType" in e;
}
function Yde(e) {
  return e && typeof e.render == "function";
}
const wR = { component: "geoscene-component" };
let kc = class extends Ae {
  constructor() {
    super(...arguments), this.widget = null;
  }
  destroy() {
    var t;
    this.node = null, (t = this.widget) == null || t.destroy();
  }
  get id() {
    return this.get("widget.id") || this.get("node.id");
  }
  set node(t) {
    const r = this._get("node");
    t !== r && (t && t.classList.add(wR.component), r && r.classList.remove(wR.component), this._set("node", t));
  }
  castNode(t) {
    var r;
    return (r = this.widget) == null || r.destroy(), t ? typeof t == "string" || Kde(t) ? (this._set("widget", null), uO(t)) : (Yde(t) && !t.domNode && (t.domNode = document.createElement("div")), this._set("widget", t), t.domNode) : (this._set("widget", null), null);
  }
};
u([d({ dependsOn: [] })], kc.prototype, "id", null), u([d()], kc.prototype, "node", null), u([xt("node")], kc.prototype, "castNode", null), u([d({ readOnly: !0 })], kc.prototype, "widget", void 0), kc = u([E("geoscene.views.ui.Component")], kc);
const _1 = kc, KV = "calcite-mode-";
function Qde() {
  return getComputedStyle(document.body).getPropertyValue("--geoscene-calcite-mode-name").replaceAll(/\s|'|"/g, "");
}
function Xde() {
  return Qde().startsWith("dark");
}
function epe() {
  return `${KV}${Xde() ? "dark" : "light"}`;
}
function tpe(e) {
  rpe(e), e.classList.add(epe());
}
function rpe(e) {
  Array.from(e.classList).forEach((t) => {
    t.startsWith(KV) && e.classList.remove(t);
  });
}
const npe = { left: 0, top: 0, bottom: 0, right: 0 }, YV = { bottom: 30, top: 15, right: 15, left: 15 }, va = "geoscene-ui", Qn = { ui: va, corner: `${va}-corner`, innerContainer: `${va}-inner-container`, manualContainer: `${va}-manual-container`, cornerContainer: `${va}-corner-container`, topLeft: `${va}-top-left`, topRight: `${va}-top-right`, bottomLeft: `${va}-bottom-left`, bottomRight: `${va}-bottom-right` };
function ipe(e) {
  return e && !e._started && typeof e.postMixInProperties == "function" && typeof e.buildRendering == "function" && typeof e.postCreate == "function" && typeof e.startup == "function";
}
function rv(e) {
  return e === 0 ? "0" : `${e}px`;
}
function TS(e) {
  const t = typeof e == "object" && e !== null && Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype) && ("component" in e || "index" in e || "position" in e) ? e : null;
}
function ES(e, { top: t, bottom: r, left: n, right: i }) {
  e.style.top = t, e.style.bottom = r, e.style.left = n, e.style.right = i;
}
let Do = class extends Uu.EventedAccessor {
  constructor(t) {
    super(t), this._cornerNameToContainerLookup = {}, this._positionNameToContainerLookup = {}, this._components = new Array(), this._componentMap = /* @__PURE__ */ new Map(), this._locale = uo(), this.view = null, this._applyViewPadding = () => {
      const r = this.container;
      r && ES(r, this._toPixelPosition(this._getViewPadding()));
    }, this._applyUIPadding = () => {
      const r = this._innerContainer;
      r && ES(r, this._toPixelPosition(this.padding));
    }, this._initContainers();
  }
  initialize() {
    this.addHandles([ze(() => {
      var t;
      return [(t = this.view) == null ? void 0 : t.padding, this.container];
    }, this._applyViewPadding, ln), ze(() => this.padding, this._applyUIPadding, ln), ze(() => [this.container, this._locale], ([t, r]) => {
      t && t.setAttribute("lang", r);
    }, ln), k6((t) => {
      this._locale = t;
    })]);
  }
  destroy() {
    this.container = null;
    for (const t of this._components)
      t.destroy();
    this._components.length = 0, this._componentMap.clear();
  }
  set container(t) {
    const r = this._get("container");
    t !== r && (t && (t.classList.add(Qn.ui), tpe(t), this._attachContainers(t)), r && (r.classList.remove(Qn.ui), ES(r, { top: "", bottom: "", left: "", right: "" }), c9(r)), this._set("container", t));
  }
  get height() {
    var s;
    const t = ((s = this.view) == null ? void 0 : s.height) ?? 0;
    if (t === 0)
      return t;
    const r = this._getViewPadding(), { top: n, bottom: i } = r;
    return Math.max(t - n - i, 0);
  }
  get padding() {
    return this._get("padding");
  }
  set padding(t) {
    this._overrideIfSome("padding", t);
  }
  castPadding(t) {
    return typeof t == "number" ? { bottom: t, top: t, right: t, left: t } : { ...YV, ...t };
  }
  get width() {
    var s;
    const t = ((s = this.view) == null ? void 0 : s.width) ?? 0;
    if (t === 0)
      return t;
    const r = this._getViewPadding(), { left: n, right: i } = r;
    return Math.max(t - n - i, 0);
  }
  add(t, r) {
    let n, i, s;
    if (Array.isArray(t))
      return void t.forEach((a) => this.add(a, r));
    const o = TS(t);
    o && ({ index: n, position: r, component: t, key: i } = o), r && typeof r == "object" && ({ index: n, key: i, position: r, internal: s } = r), !t || r && !this._isValidPosition(r) || this._add(t, r, n, i, s);
  }
  remove(t, r) {
    var i;
    if (!t)
      return;
    if (Array.isArray(t))
      return t.map((s) => this.remove(s, r));
    const n = this._find(t);
    if (n) {
      if (this._componentMap.has(t) && ((i = this._componentMap.get(t)) == null ? void 0 : i.key) !== r)
        return;
      const s = this._components.indexOf(n), o = n.node.parentNode;
      return o == null || o.removeChild(n.node), this._componentMap.delete(t), this._components.splice(s, 1)[0];
    }
  }
  empty(t, r = { removeInternal: !1 }) {
    if (Array.isArray(t)) {
      for (const s of t)
        this.empty(s, r);
      return;
    }
    const n = this._positionNameToContainerLookup[t ?? "manual"], i = Array.prototype.slice.call(n.children).map((s) => this._findByNode(s)).filter((s) => {
      var o;
      return s == null ? !1 : !(((o = this._componentMap.get(s)) == null ? void 0 : o.internal) ?? !1) || r.removeInternal;
    });
    for (const s of i)
      this.remove(s);
  }
  move(t, r) {
    if (Array.isArray(t) && t.forEach((o) => this.move(o, r)), !t)
      return;
    let n;
    const i = TS(t) || TS(r);
    if (i && (n = i.index, r = i.position, t = i.component || t), r && !this._isValidPosition(r))
      return;
    const s = this.remove(t);
    s && this.add(s, { position: r, index: n });
  }
  find(t) {
    if (!t)
      return null;
    const r = this._findById(t);
    return r && (r.widget || r.node);
  }
  getComponents(t, r = { includeInternal: !1 }) {
    return t ? Array.isArray(t) ? t.map((n) => this._getComponentsAtPosition(n, r)).flat() : this._getComponentsAtPosition(t, r) : this._components.filter((n) => {
      var i;
      return r.includeInternal || !((i = this._componentMap.get(n)) != null && i.internal);
    }).map(({ widget: n, node: i }) => n ?? i);
  }
  getPosition(t) {
    for (const r in this._positionNameToContainerLookup)
      if (this._positionNameToContainerLookup[r].contains(t))
        return r;
    return null;
  }
  _add(t, r, n, i, s) {
    t instanceof _1 || (t = new _1({ node: t })), this._place({ component: t, position: r, index: n }), this._components.push(t), this._componentMap.set(t, { key: i, internal: s });
  }
  _find(t) {
    return t ? t instanceof _1 ? this._findByComponent(t) : typeof t == "string" ? this._findById(t) : this._findByNode(t.domNode || t) : null;
  }
  _getViewPadding() {
    var t;
    return ((t = this.view) == null ? void 0 : t.padding) ?? npe;
  }
  _attachContainers(t) {
    t.appendChild(this._innerContainer), t.appendChild(this._manualContainer);
  }
  _initContainers() {
    const t = document.createElement("div");
    t.classList.add(Qn.innerContainer, Qn.cornerContainer);
    const r = document.createElement("div");
    r.classList.add(Qn.innerContainer, Qn.manualContainer);
    const n = document.createElement("div");
    n.classList.add(Qn.topLeft, Qn.corner), t.appendChild(n);
    const i = document.createElement("div");
    i.classList.add(Qn.topRight, Qn.corner), t.appendChild(i);
    const s = document.createElement("div");
    s.classList.add(Qn.bottomLeft, Qn.corner), t.appendChild(s);
    const o = document.createElement("div");
    o.classList.add(Qn.bottomRight, Qn.corner), t.appendChild(o), this._innerContainer = t, this._manualContainer = r;
    const a = tae();
    this._cornerNameToContainerLookup = { "top-left": n, "top-right": i, "bottom-left": s, "bottom-right": o, "top-leading": a ? i : n, "top-trailing": a ? n : i, "bottom-leading": a ? o : s, "bottom-trailing": a ? s : o }, this._positionNameToContainerLookup = { manual: r, ...this._cornerNameToContainerLookup };
  }
  _isValidPosition(t) {
    return !!this._positionNameToContainerLookup[t];
  }
  _place(t) {
    const r = t.position ?? "manual", { component: n, index: i } = t, s = this._positionNameToContainerLookup[r], o = i != null && i > -1;
    if (ipe(n.widget) && n.widget.startup(), !o)
      return void s.appendChild(n.node);
    const a = Array.from(s.children);
    if (i === 0)
      return void (s.firstChild ? mP(n.node, s.firstChild) : s.appendChild(n.node));
    i >= a.length ? s.appendChild(n.node) : mP(n.node, a[i]);
  }
  _toPixelPosition(t) {
    return { top: rv(t.top), left: rv(t.left), right: rv(t.right), bottom: rv(t.bottom) };
  }
  _findByComponent(t) {
    return this._components.find((r) => r === t) ?? null;
  }
  _findById(t) {
    return this._components.find(({ id: r }) => r === t) ?? null;
  }
  _findByNode(t) {
    return this._components.find(({ node: r }) => r === t) ?? null;
  }
  _getComponentsAtPosition(t, r) {
    const n = this._positionNameToContainerLookup[t];
    return Array.prototype.slice.call(n.children).map((i) => this._findByNode(i)).filter(kh).filter((i) => {
      var s;
      return r.includeInternal || !((s = this._componentMap.get(i)) != null && s.internal);
    }).map(({ widget: i, node: s }) => i ?? s);
  }
};
u([d()], Do.prototype, "_locale", void 0), u([d()], Do.prototype, "container", null), u([d()], Do.prototype, "height", null), u([d({ value: YV })], Do.prototype, "padding", null), u([xt("padding")], Do.prototype, "castPadding", null), u([d()], Do.prototype, "view", void 0), u([d()], Do.prototype, "width", null), Do = u([E("geoscene.views.ui.UI")], Do);
const spe = Do, ope = "randomUUID" in crypto;
function QV() {
  if (ope)
    return crypto.randomUUID();
  const e = crypto.getRandomValues(new Uint16Array(8));
  e[3] = 4095 & e[3] | 16384, e[4] = 16383 & e[4] | 32768;
  const t = (r) => e[r].toString(16).padStart(4, "0");
  return t(0) + t(1) + "-" + t(2) + "-" + t(3) + "-" + t(4) + "-" + t(5) + t(6) + t(7);
}
function bNe() {
  return `{${QV()}}`;
}
const ape = { handleInterceptedEvent: (e, t, r, n) => (e.scheduleRender(), t.properties[`on${n.type}`].apply(t.properties.bind || r, [n])) }, lpe = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e, t, r) => {
  e.style[t] = r;
} }, upe = (e) => ({ ...lpe, ...e }), cpe = (e, t) => {
  const r = [];
  for (; e && e !== t; )
    r.push(e), e = e.parentNode;
  return r;
}, dpe = (e, t) => e.find(t), _R = (e, t, r = !1) => {
  let n = e;
  return t.forEach((i, s) => {
    const o = n != null && n.children ? dpe(n.children, (a) => a.domNode === i) : void 0;
    r && !o && s !== t.length - 1 || (n = o);
  }), n;
}, ppe = (e) => {
  let t;
  const r = { ...ape, ...e }, n = upe(r), i = n.performanceLogger;
  let s, o = !0, a = !1;
  const l = [], c = [], h = (m, y, g) => {
    var w;
    let v;
    n.eventHandlerInterceptor = (x, $, T, C) => function(I) {
      let O;
      i("domEvent", I);
      const M = cpe(I.currentTarget, v.domNode), L = M.some((ee) => {
        var D;
        return customElements.get((D = ee == null ? void 0 : ee.tagName) == null ? void 0 : D.toLowerCase());
      });
      if (I.eventPhase === Event.CAPTURING_PHASE || !L)
        M.reverse(), O = _R(v.getLastRender(), M);
      else {
        const ee = I.composedPath(), D = ee.slice(ee.indexOf(I.currentTarget), ee.indexOf(v.domNode)).filter((H) => H.getRootNode() === H.ownerDocument).reverse();
        O = _R(v.getLastRender(), D, !0);
      }
      let N;
      return O && (N = r.handleInterceptedEvent(t, O, this, I)), i("domEventProcessed", I), N;
    }, (w = r.postProcessProjectionOptions) == null || w.call(r, n);
    const b = g();
    v = m(y, b, n), l.push(v), c.push(g), r.afterFirstVNodeRendered && r.afterFirstVNodeRendered(v, b);
  };
  let f = () => {
    if (s = void 0, o) {
      o = !1, i("renderStart", void 0);
      for (let m = 0; m < l.length; m++) {
        const y = c[m]();
        i("rendered", void 0), l[m].update(y), i("patched", void 0);
      }
      i("renderDone", void 0), o = !0;
    }
  };
  return r.modifyDoRenderImplementation && (f = r.modifyDoRenderImplementation(f, l, c)), t = { renderNow: f, scheduleRender: () => {
    s || a || (s = requestAnimationFrame(f));
  }, stop: () => {
    s && (cancelAnimationFrame(s), s = void 0), a = !0;
  }, resume: () => {
    a = !1, o = !0, t.scheduleRender();
  }, append: (m, y) => {
    h(Su.append, m, y);
  }, insertBefore: (m, y) => {
    h(Su.insertBefore, m, y);
  }, merge: (m, y) => {
    h(Su.merge, m, y);
  }, replace: (m, y) => {
    h(Su.replace, m, y);
  }, detach: (m) => {
    for (let y = 0; y < c.length; y++)
      if (c[y] === m)
        return c.splice(y, 1), l.splice(y, 1)[0];
    throw new Error("renderFunction was not found");
  } }, t;
}, jp = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  appendChildSlotFix: !1,
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  safari10: !1,
  scriptDataOpts: !1,
  scopedSlotTextContentFix: !1,
  shadowDomShim: !1,
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  cssVarShim: !1,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  dynamicImportShim: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0
};
let Vp, XV, P_, e7 = !1, ow = !1, EO = !1, Ei = !1, SR = null, nE = !1;
const hpe = (e) => {
  const t = new URL(e, rn.$resourcesUrl$);
  return t.origin !== e0.location.origin ? t.href : t.pathname;
}, fpe = (e) => rn.$resourcesUrl$ = e, jd = (e, t = "") => () => {
}, $R = "http://www.w3.org/1999/xlink", xR = {}, mpe = "http://www.w3.org/2000/svg", ype = "http://www.w3.org/1999/xhtml", gpe = (e) => e != null, IO = (e) => (e = typeof e, e === "object" || e === "function");
function vpe(e) {
  var t, r, n;
  return (n = (r = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || r === void 0 ? void 0 : r.getAttribute("content")) !== null && n !== void 0 ? n : void 0;
}
const t7 = (e, t, ...r) => {
  let n = null, i = null, s = null, o = !1, a = !1;
  const l = [], c = (f) => {
    for (let m = 0; m < f.length; m++)
      n = f[m], Array.isArray(n) ? c(n) : n != null && typeof n != "boolean" && ((o = typeof e != "function" && !IO(n)) && (n = String(n)), o && a ? l[l.length - 1].$text$ += n : l.push(o ? aw(null, n) : n), a = o);
  };
  if (c(r), t) {
    t.key && (i = t.key), t.name && (s = t.name);
    {
      const f = t.className || t.class;
      f && (t.class = typeof f != "object" ? f : Object.keys(f).filter((m) => f[m]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, l, _pe);
  const h = aw(e, null);
  return h.$attrs$ = t, l.length > 0 && (h.$children$ = l), h.$key$ = i, h.$name$ = s, h;
}, aw = (e, t) => {
  const r = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return r.$attrs$ = null, r.$key$ = null, r.$name$ = null, r;
}, bpe = {}, wpe = (e) => e && e.$tag$ === bpe, _pe = {
  forEach: (e, t) => e.map(TR).forEach(t),
  map: (e, t) => e.map(TR).map(t).map(Spe)
}, TR = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), Spe = (e) => {
  if (typeof e.vtag == "function") {
    const r = Object.assign({}, e.vattrs);
    return e.vkey && (r.key = e.vkey), e.vname && (r.name = e.vname), t7(e.vtag, r, ...e.vchildren || []);
  }
  const t = aw(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, $pe = (e) => Kpe.map((t) => t(e)).find((t) => !!t), xpe = (e, t) => e != null && !IO(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, Tpe = (e) => e, wNe = (e, t, r) => {
  const n = Tpe(e);
  return {
    emit: (i) => Epe(n, t, {
      bubbles: !!(r & 4),
      composed: !!(r & 2),
      cancelable: !!(r & 1),
      detail: i
    })
  };
}, Epe = (e, t, r) => {
  const n = rn.ce(t, r);
  return e.dispatchEvent(n), n;
}, ER = /* @__PURE__ */ new WeakMap(), Ipe = (e, t, r) => {
  let n = uw.get(e);
  Xpe && r ? (n = n || new CSSStyleSheet(), typeof n == "string" ? n = t : n.replaceSync(t)) : n = t, uw.set(e, n);
}, Mpe = (e, t, r, n) => {
  var i;
  let s = r7(t, r);
  const o = uw.get(s);
  if (e = e.nodeType === 11 ? e : co, o)
    if (typeof o == "string") {
      e = e.head || e;
      let a = ER.get(e), l;
      if (a || ER.set(e, a = /* @__PURE__ */ new Set()), !a.has(s)) {
        {
          l = co.createElement("style"), l.innerHTML = o;
          const c = (i = rn.$nonce$) !== null && i !== void 0 ? i : vpe(co);
          c != null && l.setAttribute("nonce", c), e.insertBefore(l, e.querySelector("link"));
        }
        a && a.add(s);
      }
    } else
      e.adoptedStyleSheets.includes(o) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, o]);
  return s;
}, Ope = (e) => {
  const t = e.$cmpMeta$, r = e.$hostElement$, n = t.$flags$, i = jd("attachStyles", t.$tagName$), s = Mpe(r.shadowRoot ? r.shadowRoot : r.getRootNode(), t, e.$modeName$);
  n & 10 && (r["s-sc"] = s, r.classList.add(s + "-h"), n & 2 && r.classList.add(s + "-s")), i();
}, r7 = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), IR = (e, t, r, n, i, s) => {
  if (r !== n) {
    let o = kR(e, t), a = t.toLowerCase();
    if (t === "class") {
      const l = e.classList, c = MR(r), h = MR(n);
      l.remove(...c.filter((f) => f && !h.includes(f))), l.add(...h.filter((f) => f && !c.includes(f)));
    } else if (t === "style") {
      for (const l in r)
        (!n || n[l] == null) && (l.includes("-") ? e.style.removeProperty(l) : e.style[l] = "");
      for (const l in n)
        (!r || n[l] !== r[l]) && (l.includes("-") ? e.style.setProperty(l, n[l]) : e.style[l] = n[l]);
    } else if (t !== "key")
      if (t === "ref")
        n && n(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n")
        t[2] === "-" ? t = t.slice(3) : kR(e0, a) ? t = a.slice(2) : t = a[2] + t.slice(3), r && rn.rel(e, t, r, !1), n && rn.ael(e, t, n, !1);
      else {
        const l = IO(n);
        if ((o || l && n !== null) && !i)
          try {
            if (e.tagName.includes("-"))
              e[t] = n;
            else {
              const h = n ?? "";
              t === "list" ? o = !1 : (r == null || e[t] != h) && (e[t] = h);
            }
          } catch {
          }
        let c = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (t = a, c = !0), n == null || n === !1 ? (n !== !1 || e.getAttribute(t) === "") && (c ? e.removeAttributeNS($R, t) : e.removeAttribute(t)) : (!o || s & 4 || i) && !l && (n = n === !0 ? "" : n, c ? e.setAttributeNS($R, t, n) : e.setAttribute(t, n));
      }
  }
}, Cpe = /\s/, MR = (e) => e ? e.split(Cpe) : [], n7 = (e, t, r, n) => {
  const i = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, s = e && e.$attrs$ || xR, o = t.$attrs$ || xR;
  for (n in s)
    n in o || IR(i, n, s[n], void 0, r, t.$flags$);
  for (n in o)
    IR(i, n, s[n], o[n], r, t.$flags$);
}, lw = (e, t, r, n) => {
  const i = t.$children$[r];
  let s = 0, o, a, l;
  if (e7 || (EO = !0, i.$tag$ === "slot" && (Vp && n.classList.add(Vp + "-s"), i.$flags$ |= i.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), i.$text$ !== null)
    o = i.$elm$ = co.createTextNode(i.$text$);
  else if (i.$flags$ & 1)
    o = i.$elm$ = co.createTextNode("");
  else {
    if (Ei || (Ei = i.$tag$ === "svg"), o = i.$elm$ = co.createElementNS(Ei ? mpe : ype, i.$flags$ & 2 ? "slot-fb" : i.$tag$), Ei && i.$tag$ === "foreignObject" && (Ei = !1), n7(null, i, Ei), gpe(Vp) && o["s-si"] !== Vp && o.classList.add(o["s-si"] = Vp), i.$children$)
      for (s = 0; s < i.$children$.length; ++s)
        a = lw(e, i, s, o), a && o.appendChild(a);
    i.$tag$ === "svg" ? Ei = !1 : o.tagName === "foreignObject" && (Ei = !0);
  }
  return o["s-hn"] = P_, i.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = XV, o["s-sn"] = i.$name$ || "", l = e && e.$children$ && e.$children$[r], l && l.$tag$ === i.$tag$ && e.$elm$ && hg(e.$elm$, !1)), o;
}, hg = (e, t) => {
  rn.$flags$ |= 1;
  const r = e.childNodes;
  for (let n = r.length - 1; n >= 0; n--) {
    const i = r[n];
    i["s-hn"] !== P_ && i["s-ol"] && (o7(i).insertBefore(i, MO(i)), i["s-ol"].remove(), i["s-ol"] = void 0, EO = !0), t && hg(i, t);
  }
  rn.$flags$ &= -2;
}, i7 = (e, t, r, n, i, s) => {
  let o = e["s-cr"] && e["s-cr"].parentNode || e, a;
  for (o.shadowRoot && o.tagName === P_ && (o = o.shadowRoot); i <= s; ++i)
    n[i] && (a = lw(null, r, i, e), a && (n[i].$elm$ = a, o.insertBefore(a, MO(t))));
}, s7 = (e, t, r, n, i) => {
  for (; t <= r; ++t)
    (n = e[t]) && (i = n.$elm$, u7(n), ow = !0, i["s-ol"] ? i["s-ol"].remove() : hg(i, !0), i.remove());
}, kpe = (e, t, r, n) => {
  let i = 0, s = 0, o = 0, a = 0, l = t.length - 1, c = t[0], h = t[l], f = n.length - 1, m = n[0], y = n[f], g, v;
  for (; i <= l && s <= f; )
    if (c == null)
      c = t[++i];
    else if (h == null)
      h = t[--l];
    else if (m == null)
      m = n[++s];
    else if (y == null)
      y = n[--f];
    else if (nv(c, m))
      zp(c, m), c = t[++i], m = n[++s];
    else if (nv(h, y))
      zp(h, y), h = t[--l], y = n[--f];
    else if (nv(c, y))
      (c.$tag$ === "slot" || y.$tag$ === "slot") && hg(c.$elm$.parentNode, !1), zp(c, y), e.insertBefore(c.$elm$, h.$elm$.nextSibling), c = t[++i], y = n[--f];
    else if (nv(h, m))
      (c.$tag$ === "slot" || y.$tag$ === "slot") && hg(h.$elm$.parentNode, !1), zp(h, m), e.insertBefore(h.$elm$, c.$elm$), h = t[--l], m = n[++s];
    else {
      for (o = -1, a = i; a <= l; ++a)
        if (t[a] && t[a].$key$ !== null && t[a].$key$ === m.$key$) {
          o = a;
          break;
        }
      o >= 0 ? (v = t[o], v.$tag$ !== m.$tag$ ? g = lw(t && t[s], r, o, e) : (zp(v, m), t[o] = void 0, g = v.$elm$), m = n[++s]) : (g = lw(t && t[s], r, s, e), m = n[++s]), g && o7(c.$elm$).insertBefore(g, MO(c.$elm$));
    }
  i > l ? i7(e, n[f + 1] == null ? null : n[f + 1].$elm$, r, n, s, f) : s > f && s7(t, i, l);
}, nv = (e, t) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : e.$key$ === t.$key$ : !1, MO = (e) => e && e["s-ol"] || e, o7 = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, zp = (e, t) => {
  const r = t.$elm$ = e.$elm$, n = e.$children$, i = t.$children$, s = t.$tag$, o = t.$text$;
  let a;
  o === null ? (Ei = s === "svg" ? !0 : s === "foreignObject" ? !1 : Ei, s === "slot" || n7(e, t, Ei), n !== null && i !== null ? kpe(r, n, t, i) : i !== null ? (e.$text$ !== null && (r.textContent = ""), i7(r, null, t, i, 0, i.length - 1)) : n !== null && s7(n, 0, n.length - 1), Ei && s === "svg" && (Ei = !1)) : (a = r["s-cr"]) ? a.parentNode.textContent = o : e.$text$ !== o && (r.data = o);
}, a7 = (e) => {
  const t = e.childNodes;
  let r, n, i, s, o, a;
  for (n = 0, i = t.length; n < i; n++)
    if (r = t[n], r.nodeType === 1) {
      if (r["s-sr"]) {
        for (o = r["s-sn"], r.hidden = !1, s = 0; s < i; s++)
          if (a = t[s].nodeType, t[s]["s-hn"] !== r["s-hn"] || o !== "") {
            if (a === 1 && o === t[s].getAttribute("slot")) {
              r.hidden = !0;
              break;
            }
          } else if (a === 1 || a === 3 && t[s].textContent.trim() !== "") {
            r.hidden = !0;
            break;
          }
      }
      a7(r);
    }
}, no = [], l7 = (e) => {
  let t, r, n, i, s, o, a = 0;
  const l = e.childNodes, c = l.length;
  for (; a < c; a++) {
    if (t = l[a], t["s-sr"] && (r = t["s-cr"]) && r.parentNode)
      for (n = r.parentNode.childNodes, i = t["s-sn"], o = n.length - 1; o >= 0; o--)
        r = n[o], !r["s-cn"] && !r["s-nr"] && r["s-hn"] !== t["s-hn"] && (OR(r, i) ? (s = no.find((h) => h.$nodeToRelocate$ === r), ow = !0, r["s-sn"] = r["s-sn"] || i, s ? s.$slotRefNode$ = t : no.push({
          $slotRefNode$: t,
          $nodeToRelocate$: r
        }), r["s-sr"] && no.map((h) => {
          OR(h.$nodeToRelocate$, r["s-sn"]) && (s = no.find((f) => f.$nodeToRelocate$ === r), s && !h.$slotRefNode$ && (h.$slotRefNode$ = s.$slotRefNode$));
        })) : no.some((h) => h.$nodeToRelocate$ === r) || no.push({
          $nodeToRelocate$: r
        }));
    t.nodeType === 1 && l7(t);
  }
}, OR = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", u7 = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(u7);
}, Ape = (e, t) => {
  const r = e.$hostElement$, n = e.$cmpMeta$, i = e.$vnode$ || aw(null, null), s = wpe(t) ? t : t7(null, null, t);
  P_ = r.tagName, n.$attrsToReflect$ && (s.$attrs$ = s.$attrs$ || {}, n.$attrsToReflect$.map(([o, a]) => s.$attrs$[a] = r[o])), s.$tag$ = null, s.$flags$ |= 4, e.$vnode$ = s, s.$elm$ = i.$elm$ = r.shadowRoot || r, Vp = r["s-sc"], XV = r["s-cr"], e7 = (n.$flags$ & 1) !== 0, ow = !1, zp(i, s);
  {
    if (rn.$flags$ |= 1, EO) {
      l7(s.$elm$);
      let o, a, l, c, h, f, m = 0;
      for (; m < no.length; m++)
        o = no[m], a = o.$nodeToRelocate$, a["s-ol"] || (l = co.createTextNode(""), l["s-nr"] = a, a.parentNode.insertBefore(a["s-ol"] = l, a));
      for (m = 0; m < no.length; m++)
        if (o = no[m], a = o.$nodeToRelocate$, o.$slotRefNode$) {
          for (c = o.$slotRefNode$.parentNode, h = o.$slotRefNode$.nextSibling, l = a["s-ol"]; l = l.previousSibling; )
            if (f = l["s-nr"], f && f["s-sn"] === a["s-sn"] && c === f.parentNode && (f = f.nextSibling, !f || !f["s-nr"])) {
              h = f;
              break;
            }
          (!h && c !== a.parentNode || a.nextSibling !== h) && a !== h && (!a["s-hn"] && a["s-ol"] && (a["s-hn"] = a["s-ol"].parentNode.nodeName), c.insertBefore(a, h));
        } else
          a.nodeType === 1 && (a.hidden = !0);
    }
    ow && a7(s.$elm$), rn.$flags$ &= -2, no.length = 0;
  }
}, Ppe = (e, t) => {
}, OO = (e, t) => (e.$flags$ |= 16, Ppe(e, e.$ancestorComponent$), the(() => Rpe(e, t))), Rpe = (e, t) => {
  const r = e.$hostElement$, n = jd("scheduleUpdate", e.$cmpMeta$.$tagName$), i = r;
  let s;
  return t ? s = $h(i, "componentWillLoad") : s = $h(i, "componentWillUpdate"), s = CR(s, () => $h(i, "componentWillRender")), n(), CR(s, () => Lpe(e, i, t));
}, Lpe = async (e, t, r) => {
  const n = e.$hostElement$, i = jd("update", e.$cmpMeta$.$tagName$);
  n["s-rc"], r && Ope(e);
  const s = jd("render", e.$cmpMeta$.$tagName$);
  Npe(e, t, n), s(), i(), Fpe(e);
}, Npe = (e, t, r) => {
  try {
    SR = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (jp.hasRenderFn || jp.reflect) && (jp.vdomRender || jp.reflect) && (jp.hydrateServerSide || Ape(e, t));
  } catch (a) {
    Xg(a, e.$hostElement$);
  }
  return SR = null, null;
}, Fpe = (e) => {
  const t = e.$cmpMeta$.$tagName$, r = e.$hostElement$, n = jd("postUpdate", t), i = r;
  e.$ancestorComponent$, $h(i, "componentDidRender"), e.$flags$ & 64 ? ($h(i, "componentDidUpdate"), n()) : (e.$flags$ |= 64, $h(i, "componentDidLoad"), n());
}, _Ne = (e) => {
  {
    const t = Qg(e), r = t.$hostElement$.isConnected;
    return r && (t.$flags$ & 18) === 2 && OO(t, !1), r;
  }
}, $h = (e, t, r) => {
  if (e && e[t])
    try {
      return e[t](r);
    } catch (n) {
      Xg(n);
    }
}, CR = (e, t) => e && e.then ? e.then(t) : t(), Dpe = (e, t) => Qg(e).$instanceValues$.get(t), jpe = (e, t, r, n) => {
  const i = Qg(e), s = e, o = i.$instanceValues$.get(t), a = i.$flags$, l = s;
  r = xpe(r, n.$members$[t][0]);
  const c = Number.isNaN(o) && Number.isNaN(r);
  if (r !== o && !c) {
    i.$instanceValues$.set(t, r);
    {
      if (n.$watchers$ && a & 128) {
        const f = n.$watchers$[t];
        f && f.map((m) => {
          try {
            l[m](r, o, t);
          } catch (y) {
            Xg(y, s);
          }
        });
      }
      if ((a & 18) === 2) {
        if (l.componentShouldUpdate && l.componentShouldUpdate(r, o, t) === !1)
          return;
        OO(i, !1);
      }
    }
  }
}, Vpe = (e, t, r) => {
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const n = Object.entries(t.$members$), i = e.prototype;
    n.map(([s, [o]]) => {
      (o & 31 || o & 32) && Object.defineProperty(i, s, {
        get() {
          return Dpe(this, s);
        },
        set(a) {
          jpe(this, s, a, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const s = /* @__PURE__ */ new Map();
      i.attributeChangedCallback = function(o, a, l) {
        rn.jmp(() => {
          const c = s.get(o);
          if (this.hasOwnProperty(c))
            l = this[c], delete this[c];
          else if (i.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == l)
            return;
          this[c] = l === null && typeof this[c] == "boolean" ? !1 : l;
        });
      }, e.observedAttributes = n.filter(
        ([o, a]) => a[0] & 15
        /* MEMBER_FLAGS.HasAttribute */
      ).map(([o, a]) => {
        const l = a[1] || o;
        return s.set(l, o), a[0] & 512 && t.$attrsToReflect$.push([o, l]), l;
      });
    }
  }
  return e;
}, zpe = async (e, t, r, n, i) => {
  if (!(t.$flags$ & 32) && (i = e.constructor, t.$flags$ |= 32, customElements.whenDefined(r.$tagName$).then(() => t.$flags$ |= 128), i.style)) {
    let o = i.style;
    typeof o != "string" && (o = o[t.$modeName$ = $pe(e)]);
    const a = r7(r, t.$modeName$);
    if (!uw.has(a)) {
      const l = jd("registerStyles", r.$tagName$);
      Ipe(a, o, !!(r.$flags$ & 1)), l();
    }
  }
  t.$ancestorComponent$, OO(t, !0);
}, Upe = (e) => {
}, Bpe = (e) => {
  if (!(rn.$flags$ & 1)) {
    const t = Qg(e), r = t.$cmpMeta$, n = jd("connectedCallback", r.$tagName$);
    t.$flags$ & 1 ? (c7(e, t, r.$listeners$), Upe(t.$lazyInstance$)) : (t.$flags$ |= 1, r.$flags$ & 12 && qpe(e), r.$members$ && Object.entries(r.$members$).map(([i, [s]]) => {
      if (s & 31 && e.hasOwnProperty(i)) {
        const o = e[i];
        delete e[i], e[i] = o;
      }
    }), zpe(e, t, r)), n();
  }
}, qpe = (e) => {
  const t = e["s-cr"] = co.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Gpe = (e) => {
  if (!(rn.$flags$ & 1)) {
    const t = Qg(e);
    t.$rmListeners$ && (t.$rmListeners$.map((r) => r()), t.$rmListeners$ = void 0);
  }
}, SNe = (e, t) => {
  const r = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  r.$members$ = t[2], r.$listeners$ = t[3], r.$watchers$ = e.$watchers$, r.$attrsToReflect$ = [];
  const n = e.prototype.connectedCallback, i = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      Zpe(this, r);
    },
    connectedCallback() {
      Bpe(this), n && n.call(this);
    },
    disconnectedCallback() {
      Gpe(this), i && i.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(r.$flags$ & 16)
      });
    }
  }), e.is = r.$tagName$, Vpe(e, r);
}, $Ne = (e, t) => t, c7 = (e, t, r, n) => {
  r && r.map(([i, s, o]) => {
    const a = Wpe(e, i), l = Hpe(t, o), c = Jpe(i);
    rn.ael(a, s, l, c), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => rn.rel(a, s, l, c));
  });
}, Hpe = (e, t) => (r) => {
  try {
    jp.lazyLoad || e.$hostElement$[t](r);
  } catch (n) {
    Xg(n);
  }
}, Wpe = (e, t) => t & 4 ? co : t & 8 ? e0 : t & 16 ? co.body : e, Jpe = (e) => Ype ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, d7 = /* @__PURE__ */ new WeakMap(), Qg = (e) => d7.get(e), Zpe = (e, t) => {
  const r = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return c7(e, r, t.$listeners$), d7.set(e, r);
}, kR = (e, t) => t in e, Xg = (e, t) => (0, console.error)(e, t), uw = /* @__PURE__ */ new Map(), Kpe = [], e0 = typeof window < "u" ? window : {}, co = e0.document || { head: {} }, xNe = e0.HTMLElement || class {
}, rn = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, r, n) => e.addEventListener(t, r, n),
  rel: (e, t, r, n) => e.removeEventListener(t, r, n),
  ce: (e, t) => new CustomEvent(e, t)
}, Ype = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    co.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), Qpe = (e) => Promise.resolve(e), Xpe = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), iE = [], p7 = [], h7 = (e, t) => (r) => {
  e.push(r), nE || (nE = !0, t && rn.$flags$ & 4 ? ehe(sE) : rn.raf(sE));
}, AR = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (r) {
      Xg(r);
    }
  e.length = 0;
}, sE = () => {
  AR(iE), AR(p7), (nE = iE.length > 0) && rn.raf(sE);
}, ehe = (e) => Qpe().then(e), TNe = /* @__PURE__ */ h7(iE, !1), the = /* @__PURE__ */ h7(p7, !0);
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
const f7 = "calcite-mode-auto", m7 = "calcite-mode-dark", rhe = "calcite-mode-light", ENe = {
  autoMode: f7,
  darkMode: m7,
  lightMode: rhe,
  rtl: "calcite--rtl",
  calciteAnimate: "calcite-animate",
  calciteAnimateIn: "calcite-animate__in",
  calciteAnimateInUp: "calcite-animate__in-up",
  calciteAnimateInDown: "calcite-animate__in-down",
  calciteAnimateInRight: "calcite-animate__in-right",
  calciteAnimateInLeft: "calcite-animate__in-left",
  calciteAnimateInScale: "calcite-animate__in-scale"
};
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var y7 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], cw = /* @__PURE__ */ y7.join(","), g7 = typeof Element > "u", Vd = g7 ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, dw = !g7 && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, pw = function e(t, r) {
  var n;
  r === void 0 && (r = !0);
  var i = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "inert"), s = i === "" || i === "true", o = s || r && t && e(t.parentNode);
  return o;
}, nhe = function(t) {
  var r, n = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "contenteditable");
  return n === "" || n === "true";
}, v7 = function(t, r, n) {
  if (pw(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(cw));
  return r && Vd.call(t, cw) && i.unshift(t), i = i.filter(n), i;
}, b7 = function e(t, r, n) {
  for (var i = [], s = Array.from(t); s.length; ) {
    var o = s.shift();
    if (!pw(o, !1))
      if (o.tagName === "SLOT") {
        var a = o.assignedElements(), l = a.length ? a : o.children, c = e(l, !0, n);
        n.flatten ? i.push.apply(i, c) : i.push({
          scopeParent: o,
          candidates: c
        });
      } else {
        var h = Vd.call(o, cw);
        h && n.filter(o) && (r || !t.includes(o)) && i.push(o);
        var f = o.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(o), m = !pw(f, !1) && (!n.shadowRootFilter || n.shadowRootFilter(o));
        if (f && m) {
          var y = e(f === !0 ? o.children : f.children, !0, n);
          n.flatten ? i.push.apply(i, y) : i.push({
            scopeParent: o,
            candidates: y
          });
        } else
          s.unshift.apply(s, o.children);
      }
  }
  return i;
}, w7 = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, _7 = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || nhe(t)) && !w7(t) ? 0 : t.tabIndex;
}, ihe = function(t, r) {
  var n = _7(t);
  return n < 0 && r && !w7(t) ? 0 : n;
}, she = function(t, r) {
  return t.tabIndex === r.tabIndex ? t.documentOrder - r.documentOrder : t.tabIndex - r.tabIndex;
}, S7 = function(t) {
  return t.tagName === "INPUT";
}, ohe = function(t) {
  return S7(t) && t.type === "hidden";
}, ahe = function(t) {
  var r = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return r;
}, lhe = function(t, r) {
  for (var n = 0; n < t.length; n++)
    if (t[n].checked && t[n].form === r)
      return t[n];
}, uhe = function(t) {
  if (!t.name)
    return !0;
  var r = t.form || dw(t), n = function(a) {
    return r.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = n(window.CSS.escape(t.name));
  else
    try {
      i = n(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var s = lhe(i, t.form);
  return !s || s === t;
}, che = function(t) {
  return S7(t) && t.type === "radio";
}, dhe = function(t) {
  return che(t) && !uhe(t);
}, phe = function(t) {
  var r, n = t && dw(t), i = (r = n) === null || r === void 0 ? void 0 : r.host, s = !1;
  if (n && n !== t) {
    var o, a, l;
    for (s = !!((o = i) !== null && o !== void 0 && (a = o.ownerDocument) !== null && a !== void 0 && a.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !s && i; ) {
      var c, h, f;
      n = dw(i), i = (c = n) === null || c === void 0 ? void 0 : c.host, s = !!((h = i) !== null && h !== void 0 && (f = h.ownerDocument) !== null && f !== void 0 && f.contains(i));
    }
  }
  return s;
}, PR = function(t) {
  var r = t.getBoundingClientRect(), n = r.width, i = r.height;
  return n === 0 && i === 0;
}, hhe = function(t, r) {
  var n = r.displayCheck, i = r.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var s = Vd.call(t, "details>summary:first-of-type"), o = s ? t.parentElement : t;
  if (Vd.call(o, "details:not([open]) *"))
    return !0;
  if (!n || n === "full" || n === "legacy-full") {
    if (typeof i == "function") {
      for (var a = t; t; ) {
        var l = t.parentElement, c = dw(t);
        if (l && !l.shadowRoot && i(l) === !0)
          return PR(t);
        t.assignedSlot ? t = t.assignedSlot : !l && c !== t.ownerDocument ? t = c.host : t = l;
      }
      t = a;
    }
    if (phe(t))
      return !t.getClientRects().length;
    if (n !== "legacy-full")
      return !0;
  } else if (n === "non-zero-area")
    return PR(t);
  return !1;
}, fhe = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var r = t.parentElement; r; ) {
      if (r.tagName === "FIELDSET" && r.disabled) {
        for (var n = 0; n < r.children.length; n++) {
          var i = r.children.item(n);
          if (i.tagName === "LEGEND")
            return Vd.call(r, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      r = r.parentElement;
    }
  return !1;
}, hw = function(t, r) {
  return !(r.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  pw(r) || ohe(r) || hhe(r, t) || // For a details element with a summary, the summary element gets the focus
  ahe(r) || fhe(r));
}, oE = function(t, r) {
  return !(dhe(r) || _7(r) < 0 || !hw(t, r));
}, mhe = function(t) {
  var r = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(r) || r >= 0);
}, yhe = function e(t) {
  var r = [], n = [];
  return t.forEach(function(i, s) {
    var o = !!i.scopeParent, a = o ? i.scopeParent : i, l = ihe(a, o), c = o ? e(i.candidates) : a;
    l === 0 ? o ? r.push.apply(r, c) : r.push(a) : n.push({
      documentOrder: s,
      tabIndex: l,
      item: i,
      isScope: o,
      content: c
    });
  }), n.sort(she).reduce(function(i, s) {
    return s.isScope ? i.push.apply(i, s.content) : i.push(s.content), i;
  }, []).concat(r);
}, ghe = function(t, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = b7([t], r.includeContainer, {
    filter: oE.bind(null, r),
    flatten: !1,
    getShadowRoot: r.getShadowRoot,
    shadowRootFilter: mhe
  }) : n = v7(t, r.includeContainer, oE.bind(null, r)), yhe(n);
}, INe = function(t, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = b7([t], r.includeContainer, {
    filter: hw.bind(null, r),
    flatten: !0,
    getShadowRoot: r.getShadowRoot
  }) : n = v7(t, r.includeContainer, hw.bind(null, r)), n;
}, MNe = function(t, r) {
  if (r = r || {}, !t)
    throw new Error("No node provided");
  return Vd.call(t, cw) === !1 ? !1 : oE(r, t);
}, vhe = /* @__PURE__ */ y7.concat("iframe").join(","), ONe = function(t, r) {
  if (r = r || {}, !t)
    throw new Error("No node provided");
  return Vd.call(t, vhe) === !1 ? !1 : hw(r, t);
};
const bhe = {
  getShadowRoot: !0
};
function CNe(e) {
  const t = "dir", r = `[${t}]`, n = whe(e, r);
  return n ? n.getAttribute(t) : "ltr";
}
function CO(e) {
  return e.getRootNode();
}
function kNe(e) {
  const t = CO(e);
  return "host" in t ? t : null;
}
function $7(e) {
  return e.host || null;
}
function ANe(e, { selector: t, id: r }) {
  function n(i) {
    if (!i)
      return null;
    i.assignedSlot && (i = i.assignedSlot);
    const s = CO(i), o = r ? "getElementById" in s ? (
      /*
      Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
      https://github.com/Esri/calcite-design-system/pull/4280
       */
      s.getElementById(r)
    ) : null : t ? s.querySelector(t) : null, a = $7(s);
    return o || (a ? n(a) : null);
  }
  return n(e);
}
function whe(e, t) {
  function r(n) {
    return n ? n.closest(t) || r($7(CO(n))) : null;
  }
  return r(e);
}
function _he(e, t) {
  return x7(e, t);
}
function x7(e, t) {
  if (!e)
    return;
  const r = t(e);
  if (r !== void 0)
    return r;
  const { parentNode: n } = e;
  return x7(n instanceof ShadowRoot ? n.host : n, t);
}
function PNe(e, t) {
  return !!_he(t, (r) => r === e ? !0 : void 0);
}
function She(e) {
  return typeof (e == null ? void 0 : e.setFocus) == "function";
}
async function RNe(e) {
  if (e)
    return She(e) ? e.setFocus() : e.focus();
}
function LNe(e) {
  e && (ghe(e, bhe)[0] || e).focus();
}
const fg = ":not([slot])";
function NNe(e, t, r) {
  t && !Array.isArray(t) && typeof t != "string" && (r = t, t = null);
  const n = t ? Array.isArray(t) ? t.map((i) => `[slot="${i}"]`).join(",") : `[slot="${t}"]` : fg;
  return r != null && r.all ? $he(e, n, r) : xhe(e, n, r);
}
function T7(e, t) {
  return e ? Array.from(e.children || []).filter((r) => r == null ? void 0 : r.matches(t)) : [];
}
function $he(e, t, r) {
  let n = t === fg ? T7(e, fg) : Array.from(e.querySelectorAll(t));
  n = r && r.direct === !1 ? n : n.filter((s) => s.parentElement === e), n = r != null && r.matches ? n.filter((s) => s == null ? void 0 : s.matches(r.matches)) : n;
  const i = r == null ? void 0 : r.selector;
  return i ? n.map((s) => Array.from(s.querySelectorAll(i))).reduce((s, o) => [...s, ...o], []).filter((s) => !!s) : n;
}
function xhe(e, t, r) {
  let n = t === fg ? T7(e, fg)[0] || null : e.querySelector(t);
  n = r && r.direct === !1 || (n == null ? void 0 : n.parentElement) === e ? n : null, n = r != null && r.matches ? n != null && n.matches(r.matches) ? n : null : n;
  const i = r == null ? void 0 : r.selector;
  return i ? n == null ? void 0 : n.querySelector(i) : n;
}
function FNe(e, t, r) {
  if (typeof t == "string" && t !== "")
    return t;
  if (t === "")
    return e[r];
}
function DNe(e) {
  return (!!e).toString();
}
function jNe(e) {
  return Mhe(e) || Ehe(e);
}
function The(e) {
  return Ihe(e).filter((t) => t.nodeType === Node.TEXT_NODE).map((t) => t.textContent).join("").trim();
}
function Ehe(e) {
  return !!The(e);
}
function Ihe(e) {
  return e.target.assignedNodes({
    flatten: !0
  });
}
function Mhe(e) {
  return !!Ohe(e).length;
}
function Ohe(e) {
  return e.target.assignedElements({
    flatten: !0
  });
}
function VNe(e) {
  return !!(e.isPrimary && e.button === 0);
}
function zNe(e, t) {
  if (e.parentNode !== t.parentNode)
    return !1;
  const r = Array.from(e.parentNode.children);
  return r.indexOf(e) < r.indexOf(t);
}
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
function RR() {
  const { classList: e } = document.body, t = window.matchMedia("(prefers-color-scheme: dark)").matches, r = () => e.contains(m7) || e.contains(f7) && t ? "dark" : "light", n = (o) => document.body.dispatchEvent(new CustomEvent("calciteModeChange", { bubbles: !0, detail: { mode: o } })), i = (o) => {
    s !== o && n(o), s = o;
  };
  let s = r();
  n(s), window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (o) => i(o.matches ? "dark" : "light")), new MutationObserver(() => i(r())).observe(document.body, {
    attributes: !0,
    attributeFilter: ["class"]
  });
}
function Che() {
  typeof window < "u" && typeof location < "u" && typeof document < "u" && window.location === location && window.document === document && (document.readyState === "interactive" ? RR() : document.addEventListener("DOMContentLoaded", () => RR(), { once: !0 }));
}
const khe = Che;
khe();
let E7;
function Ahe() {
  try {
    hpe(".");
  } catch {
    fpe(cs(Ja(E7)));
  }
}
function UNe(e) {
  var r;
  const t = [];
  for (const n of Object.keys(e))
    customElements.get(`calcite-${n}`) || t.push((r = e[n]) == null ? void 0 : r.call(e));
  return Promise.all(t);
}
E7 = "components/assets";
const I7 = Symbol("widget"), Phe = Symbol("widget-test-data"), Rhe = [], Lhe = {}, fw = /* @__PURE__ */ new WeakMap();
function M7(e, t) {
  let r = t.children;
  if (r && r.length)
    for (let i = 0; i < r.length; ++i)
      r[i] = M7(e, r[i]);
  else
    r = Rhe;
  const n = t.vnodeSelector;
  if (kO(n)) {
    const i = t.properties || Lhe, s = i.key || n;
    return { vnodeSelector: "div", properties: { key: s, afterCreate: Nhe, afterUpdate: Fhe, afterRemoved: O7, parentWidget: e, widgetConstructor: n, widgetProperties: { ...i, key: s, children: r } }, children: void 0, text: void 0, domNode: null };
  }
  return t;
}
function Nhe(e, t, r, { parentWidget: n, widgetConstructor: i, widgetProperties: s }) {
  var a;
  const o = new i(s);
  o.container = e, fw.set(e, o), (a = o.afterCreate) == null || a.call(o, o, e), n._internalHandles.add(nl(() => O7(e)));
}
function Fhe(e, t, r, { widgetProperties: n }) {
  var s;
  const i = fw.get(e);
  i && (i.set(n), (s = i.afterUpdate) == null || s.call(i, i, e));
}
function O7(e) {
  var r;
  const t = fw.get(e);
  t && ((r = t.afterRemoved) == null || r.call(t, t, e), t.destroy(), fw.delete(e));
}
function kO(e) {
  return typeof e == "function" && e[I7];
}
const LR = /* @__PURE__ */ new Set();
function Dhe(e) {
  LR.add(e), e.finally(() => LR.delete(e));
}
var C7;
const jhe = "geoscene.widgets.Widget";
let Vhe = 0;
const zhe = { widgetIcon: "geoscene-icon-checkbox-unchecked" };
function k7(e, t) {
  for (const r in t)
    e[r] != null && (typeof e[r] == "object" && typeof t[r] == "object" ? k7(e[r], t == null ? void 0 : t[r]) : e[r] = t[r]);
  return e;
}
const Uhe = ppe({ postProcessProjectionOptions(e) {
  const t = e.eventHandlerInterceptor, r = /capture$/i;
  e.eventHandlerInterceptor = (n, i, s, o) => {
    const a = t == null ? void 0 : t(n, i, s, o), l = r.test(n);
    if (!((n = n.replace(r, "")).toLowerCase() in s) || l) {
      const c = n[2].toLowerCase() + n.slice(3), h = (y) => a == null ? void 0 : a.call(s, y);
      s.addEventListener(c, h, l);
      const f = () => s.removeEventListener(c, h, l), m = o.afterRemoved;
      o.afterRemoved = (y) => {
        m == null || m(y), f();
      };
    }
    return a;
  };
}, handleInterceptedEvent(e, t, r, n) {
  const { eventPhase: i, type: s } = n, o = i === Event.CAPTURING_PHASE;
  let a = `on${s}${o ? "capture" : ""}`;
  const l = t.properties;
  (l && a in l || (a = `on${s[0].toUpperCase()}${s.slice(1)}${o ? "Capture" : ""}`, l && a in l)) && (T9(), e.scheduleRender(), l[a].call(l.bind || r, n));
} });
let IS = !1, xr = class extends r_(Uu.EventedAccessor) {
  constructor(t, r) {
    super(t, r), this._attached = !1, this._internalHandles = new ca(), this._projector = Uhe, this._readyForTrueRender = !1, this.iconClass = zhe.widgetIcon, this.icon = null, this.key = this, this._loadLocale = gF(async () => {
      if (this._messageBundleProps && this._messageBundleProps.length) {
        const o = await Zd(this._messageBundleProps.map(async ({ bundlePath: a, propertyName: l }) => {
          if (this.destroyed)
            return;
          let c = await P6(a);
          this.uiStrings && Object.keys(this.uiStrings) && (c = k7(j(c), this.uiStrings)), this[l] = c;
        }));
        if (this.destroyed)
          return;
        for (const a of o)
          a.error && se.getLogger(this).error("widget-intl:locale-error", this.declaredClass, a.error);
      }
      await this.loadLocale();
    }), Ahe();
    const n = "geoscene-widget-uid-" + QV(), i = this.render.bind(this);
    this._trackingTarget = new Yw(() => this.scheduleRender());
    const s = () => {
      var h;
      if (!this._readyForTrueRender || this.destroyed)
        return null;
      const o = i();
      let { properties: a } = o;
      a || (o.properties = a = {});
      const { key: l } = a;
      l || (a.key = n), this.visible ? a.styles || (a.styles = {}) : (a.class = "", a.styles = { display: "none" }), a.styles.display || (a.styles.display = "");
      let c = 0;
      return (h = o.children) == null || h.forEach((f) => {
        if (kO(f.vnodeSelector))
          return;
        let { properties: m } = f;
        m || (f.properties = m = {}), m.key || (m.key = `${this.id}--${c++}`);
      }), M7(this, o);
    };
    this.render = () => {
      if (IS)
        return s();
      let o = Joe(this) ?? null;
      if (o)
        return o;
      this._trackingTarget.clear(), IS = !0;
      try {
        o = il(this._trackingTarget, s);
      } catch (a) {
        throw console.error(a), a;
      } finally {
        IS = !1;
      }
      return o && Zoe(this, o), o;
    }, this.addResolvingPromise(this._resourcesFetch = this.beforeFirstRender().then(() => {
      this._readyForTrueRender = !0, this._postInitialize();
    })), Dhe(this._resourcesFetch);
  }
  normalizeCtorArgs(t, r) {
    const n = { ...t };
    return r && (n.container = r), n;
  }
  postInitialize() {
  }
  beforeFirstRender() {
    return Promise.all([this.loadDependencies(), this._loadLocale()]).then(() => {
    }).catch(_k);
  }
  async loadDependencies() {
  }
  async loadLocale() {
  }
  destroy() {
    this.destroyed || (Vt(this._trackingTarget), Vt(this.viewModel), this._detach(this.container), this._set("container", null), this._internalHandles.destroy(), this._emitter.clear(), this.render = () => null, this._projector = null, aS(this));
  }
  set container(t) {
    this._get("container") || this._set("container", t);
  }
  castContainer(t) {
    return uO(t);
  }
  get domNode() {
    return this.container;
  }
  set domNode(t) {
    this.container = t;
  }
  get id() {
    return this._get("id") || this.get("container.id") || Date.now().toString(16) + "-widget-" + Vhe++;
  }
  set id(t) {
    t && this._set("id", t);
  }
  get label() {
    return this.declaredClass.split(".").pop();
  }
  set label(t) {
    this._overrideIfSome("label", t);
  }
  get renderable() {
    return this._resourcesFetch;
  }
  get visible() {
    return this._get("visible");
  }
  set visible(t) {
    this._set("visible", t);
  }
  get [(C7 = I7, Phe)]() {
    return { projector: this._projector };
  }
  render() {
    throw new Error("not implemented");
  }
  scheduleRender() {
    this.destroyed || (aS(this), this._projector.scheduleRender());
  }
  classes(...t) {
    return eae.apply(this, t);
  }
  renderNow() {
    aS(this), this._projector.renderNow();
  }
  _postInitialize() {
    var r;
    if (this.destroyed)
      return;
    this.scheduleRender(), (r = this._delegatedEventNames) != null && r.length && this._internalHandles.add(ze(() => this.viewModel, (n, i) => {
      i && this._internalHandles.remove("delegated-events"), n && Jw(n) && this._internalHandles.add(this._delegatedEventNames.map((s) => Zw(n, s, (o) => {
        this.emit(s, o);
      })), "delegated-events");
    }, ln)), this.postInitialize();
    const t = async () => {
      await this._loadLocale().catch(_k), this.scheduleRender();
    };
    this._internalHandles.add([k6(t), ze(() => this.uiStrings, t), Au(() => this.container, (n) => {
      this.destroyed || this._attach(n);
    }, { initial: !0, once: !0 })]);
  }
  _attach(t) {
    t && (this._projector.merge(t, this.render), this._attached = !0);
  }
  _detach(t) {
    var r;
    this._attached && (this._projector.detach(this.render), this._attached = !1), (r = t == null ? void 0 : t.parentNode) == null || r.removeChild(t);
  }
};
xr[C7] = !0, u([d()], xr.prototype, "_readyForTrueRender", void 0), u([d({ value: null })], xr.prototype, "container", null), u([xt("container")], xr.prototype, "castContainer", null), u([d()], xr.prototype, "iconClass", void 0), u([d()], xr.prototype, "icon", void 0), u([d()], xr.prototype, "id", null), u([d()], xr.prototype, "label", null), u([d()], xr.prototype, "renderable", null), u([d()], xr.prototype, "uiStrings", void 0), u([d()], xr.prototype, "viewModel", void 0), u([d({ value: !0 })], xr.prototype, "visible", null), u([d()], xr.prototype, "key", void 0), u([d()], xr.prototype, "children", void 0), u([d()], xr.prototype, "afterCreate", void 0), u([d()], xr.prototype, "afterUpdate", void 0), u([d()], xr.prototype, "afterRemoved", void 0), xr = u([E(jhe)], xr);
const t0 = xr;
function NR(e, t) {
  return e && "copyright" in e && (!t || typeof e.originOf == "function" && e.originOf("copyright") === "user");
}
function Bhe(e, t) {
  return e.length !== t.length || e.some((r, n) => r.text !== t[n].text);
}
function iv(e, t, r) {
  !r || !t || e.find((n) => n.layerView === t && n.text === r) || e.push({ text: r, layerView: t });
}
function qhe(e) {
  return e.type === "bing-maps";
}
const kl = [];
let Up = class extends Xb {
  constructor(t) {
    super(t), this._clear = () => {
      this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.handles.remove("suspension"), this.notifyChange("state");
    }, this._pendingAttributions = /* @__PURE__ */ new Set(), this._fetchedAttributionData = /* @__PURE__ */ new Map(), this.items = new je(), this.view = null, this._allLayerViewsChange = (r) => {
      this.handles.remove("suspension");
      const n = this.get("view.allLayerViews");
      n && this.handles.add(n.map((i) => ze(() => {
        var s;
        return [i.suspended, (s = i.layer) == null ? void 0 : s.attributionVisible];
      }, () => this._updateAttributionItems())), "suspension"), r && r.removed && r.removed.forEach((i) => {
        this._pendingAttributions.delete(i), this._fetchedAttributionData.delete(i);
      }), this._updateAttributionItems();
    }, this.handles.add([rg(() => {
      var r;
      return (r = this.view) == null ? void 0 : r.allLayerViews;
    }, "change", (r) => this._allLayerViewsChange(r), { onListenerAdd: () => this._allLayerViewsChange(), onListenerRemove: this._clear }), Au(() => {
      var r;
      return ((r = this.view) == null ? void 0 : r.stationary) === !0;
    }, () => this._updateAttributionItems())]);
  }
  destroy() {
    this.view = null, this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.items.removeAll();
  }
  get state() {
    return this.get("view.ready") ? this._pendingAttributions.size > 0 ? "loading" : "ready" : "disabled";
  }
  _updateAttributionItems() {
    const t = this.view, r = t == null ? void 0 : t.allLayerViews;
    kl.length = 0, t && r ? (r.forEach((n) => {
      var o;
      if (n.suspended || !((o = n.layer) != null && o.attributionVisible))
        return;
      const i = n.layer;
      if (NR(i, "user"))
        return void iv(kl, n, i.copyright);
      if (i.hasAttributionData) {
        if (this._fetchedAttributionData.has(n)) {
          const a = this._fetchedAttributionData.get(n);
          return void (a ? iv(kl, n, this._getDynamicAttribution(a, t, i)) : NR(i) && iv(kl, n, i.copyright));
        }
        return void this._fetchAttributionData(n);
      }
      const s = i.get("portalItem.accessInformation");
      iv(kl, n, s || i.copyright);
    }), Bhe(this.items, kl) && (this.items.removeAll(), this.items.addMany(kl)), kl.length = 0, this.notifyChange("state")) : this._clear();
  }
  async _fetchAttributionData(t) {
    if (this._pendingAttributions.has(t))
      return;
    this._pendingAttributions.add(t);
    const r = await n_(t.layer.fetchAttributionData());
    if (this._pendingAttributions.has(t)) {
      const n = r.ok ? this._createContributionIndex(r.value, qhe(t.layer)) : null;
      this._pendingAttributions.delete(t), this._fetchedAttributionData.set(t, n);
    }
    this._updateAttributionItems();
  }
  _createContributionIndex(t, r) {
    const n = t.contributors, i = {};
    if (!n)
      return i;
    for (let s = 0; s < n.length; s++) {
      const o = n[s], a = o.coverageAreas;
      if (!a)
        return;
      for (const l of a) {
        const c = l.bbox, h = l.zoomMin - (r && l.zoomMin ? 1 : 0), f = l.zoomMax - (r && l.zoomMax ? 1 : 0), m = new Ct({ xmin: c[1], ymin: c[0], xmax: c[3], ymax: c[2], spatialReference: tt.WGS84 }), y = { extent: Uv(m), attribution: o.attribution || "", score: l.score != null ? l.score : 100, id: s };
        for (let g = h; g <= f; g++)
          i[g] ?? (i[g] = []), i[g].push(y);
      }
    }
    return i.maxKey = Math.max.apply(null, Object.keys(i)), i;
  }
  _getDynamicAttribution(t, r, n) {
    var h;
    const { extent: i, scale: s } = r;
    let o = ((h = n.tileInfo) == null ? void 0 : h.scaleToZoom(s)) ?? 0;
    if (o = Math.min(t.maxKey ?? 0, Math.round(o)), !i || o == null || o <= -1)
      return "";
    const a = t[o], l = o_(i.center.clone().normalize(), r.spatialReference), c = /* @__PURE__ */ new Set();
    return a ? a.filter((f) => {
      const m = f.id, y = !c.has(m) && l && f.extent && a_(f.extent, l);
      return y && c.add(m), y;
    }).sort((f, m) => m.score - f.score || f.objectId - m.objectId).map((f) => f.attribution).join(", ") : "";
  }
};
u([d({ readOnly: !0, type: je })], Up.prototype, "items", void 0), u([d({ readOnly: !0 })], Up.prototype, "state", null), u([d()], Up.prototype, "view", void 0), Up = u([E("geoscene.widgets.Attribution.AttributionViewModel")], Up);
const A7 = Up;
function R_() {
  return function(e, t) {
    if (!e[t])
      throw new TypeError(`Cannot auto bind undefined function '${String(t)}'`);
    return { value: Hhe(e[t]) };
  };
}
function Ghe(e) {
  const t = e == null ? void 0 : e.type;
  return e instanceof KeyboardEvent || t === "keyup" || t === "keydown" || t === "keypress";
}
function Hhe(e) {
  return function(t, ...r) {
    Ghe(t) ? sae(t.key) && (t.preventDefault(), t.stopPropagation(), t.target.click()) : e.call(this, t, ...r);
  };
}
function L_(e) {
  return (t, r) => {
    t.hasOwnProperty("_messageBundleProps") || (t._messageBundleProps = t._messageBundleProps ? t._messageBundleProps.slice() : []), t._messageBundleProps.push({ bundlePath: e, propertyName: r });
  };
}
var Whe = function(e) {
  return { vnodeSelector: "", properties: void 0, children: void 0, text: e.toString(), domNode: null };
}, P7 = function(e, t) {
  for (var r = 0, n = e.length; r < n; r++) {
    var i = e[r];
    Array.isArray(i) ? P7(i, t) : i != null && i !== !1 && (i.hasOwnProperty("vnodeSelector") || (i = Whe(i)), t.push(i));
  }
}, Jhe = function(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  if (r.length === 1 && typeof r[0] == "string")
    return { vnodeSelector: e, properties: t || void 0, children: void 0, text: r[0], domNode: null };
  var i = [];
  return P7(r, i), { vnodeSelector: e, properties: t || void 0, children: i, text: void 0, domNode: null };
};
function xn(e, t, ...r) {
  return typeof e != "function" || kO(e) ? Jhe(e, t, ...r) : e(t, ...r);
}
const gp = "geoscene-attribution", Al = { base: `${gp} geoscene-widget`, poweredBy: `${gp}__powered-by`, sources: `${gp}__sources`, open: `${gp}--open`, sourcesOpen: `${gp}__sources--open`, link: `${gp}__link`, widgetIcon: "geoscene-icon-description", interactive: "geoscene-interactive" };
let bn = class extends t0 {
  constructor(t, r) {
    super(t, r), this._isOpen = !1, this._attributionTextOverflowed = !1, this._prevSourceNodeHeight = 0, this._resizeObserver = new ResizeObserver((n) => n.forEach(({ target: i }) => this._checkSourceTextOverflow(i))), this.iconClass = Al.widgetIcon, this.icon = null, this.itemDelimiter = " | ", this.messages = null, this.viewModel = new A7();
  }
  initialize() {
    this.addHandles(rg(() => {
      var t;
      return (t = this.viewModel) == null ? void 0 : t.items;
    }, "change", () => this.scheduleRender()));
  }
  destroy() {
    var t;
    (t = this._resizeObserver) == null || t.disconnect();
  }
  get _isInteractive() {
    return this._isOpen || this._attributionTextOverflowed;
  }
  get attributionText() {
    return this.viewModel.items.reduce((t, r) => (t.includes(r.text) || t.push(r.text), t), []).join(this.itemDelimiter);
  }
  get label() {
    var t;
    return ((t = this.messages) == null ? void 0 : t.widgetLabel) ?? "";
  }
  set label(t) {
    this._overrideIfSome("label", t);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(t) {
    this.viewModel.view = t;
  }
  render() {
    const t = { [Al.open]: this._isOpen };
    return xn("div", { bind: this, class: this.classes(Al.base, t), dir: "ltr", onclick: this._toggleState, onkeydown: this._toggleState }, this.renderSourcesNode(), this.renderPoweredBy());
  }
  renderPoweredBy() {
    return xn("div", { class: Al.poweredBy }, "Powered by", " ", xn("a", { class: Al.link, href: "https://www.geoscene.cn/", target: "_blank", rel: "noreferrer" }, "GeoScene"));
  }
  renderSourcesNode() {
    const t = this._isOpen, r = this._isInteractive, n = r ? "0" : "", { attributionText: i } = this, s = { [Al.sourcesOpen]: t, [Al.interactive]: r };
    return xn("div", { afterCreate: this._afterSourcesNodeCreate, bind: this, class: this.classes(Al.sources, s), innerHTML: i, tabindex: n });
  }
  _afterSourcesNodeCreate(t) {
    this._prevSourceNodeHeight = t.clientWidth, this._resizeObserver.observe(t);
  }
  _checkSourceTextOverflow(t) {
    let r = !1;
    const { clientHeight: n, clientWidth: i, scrollWidth: s } = t, o = s > i, a = this._attributionTextOverflowed !== o;
    if (this._attributionTextOverflowed = o, a && (r = !0), this._isOpen) {
      const l = n < this._prevSourceNodeHeight;
      this._prevSourceNodeHeight = n, l && (this._isOpen = !1, r = !0);
    }
    r && this.scheduleRender();
  }
  _toggleState() {
    this._isInteractive && (this._isOpen = !this._isOpen);
  }
};
u([d()], bn.prototype, "_isOpen", void 0), u([d()], bn.prototype, "_isInteractive", null), u([d()], bn.prototype, "_attributionTextOverflowed", void 0), u([d()], bn.prototype, "_prevSourceNodeHeight", void 0), u([d({ readOnly: !0, dependsOn: ["viewModel.items.length", "itemDelimiter"] })], bn.prototype, "attributionText", null), u([d()], bn.prototype, "iconClass", void 0), u([d()], bn.prototype, "icon", void 0), u([d()], bn.prototype, "itemDelimiter", void 0), u([d()], bn.prototype, "label", null), u([d(), L_("geoscene/widgets/Attribution/t9n/Attribution")], bn.prototype, "messages", void 0), u([d()], bn.prototype, "view", null), u([d({ type: A7 })], bn.prototype, "viewModel", void 0), u([R_()], bn.prototype, "_toggleState", null), bn = u([E("geoscene.widgets.Attribution")], bn);
const Zhe = bn, Khe = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this.goToOverride = null, this.view = null;
    }
    callGoTo(r) {
      const { view: n } = this;
      return j5(n), this.goToOverride ? this.goToOverride(n, r) : n.goTo(r.target, r.options);
    }
  };
  return u([d()], t.prototype, "goToOverride", void 0), u([d()], t.prototype, "view", void 0), t = u([E("geoscene.widgets.support.GoTo")], t), t;
}, Yhe = "geoscene.widgets.CompassViewModel";
let Ac = class extends Khe(Ae) {
  constructor(t) {
    super(t), this._handles = new ca(), this.orientation = { x: 0, y: 0, z: 0 }, this.view = null, this._updateForCamera = this._updateForCamera.bind(this), this._updateForRotation = this._updateForRotation.bind(this), this._updateRotationWatcher = this._updateRotationWatcher.bind(this);
  }
  initialize() {
    this._handles.add(ze(() => this.view, this._updateRotationWatcher, ln));
  }
  destroy() {
    tr(this._handles), this.view = null;
  }
  get canShowNorth() {
    const t = this.get("view.spatialReference");
    return !(!t || !t.isWebMercator && !t.isGeographic);
  }
  get state() {
    return this.get("view.ready") ? this.canShowNorth ? "compass" : "rotation" : "disabled";
  }
  reset() {
    var r;
    if (!this.get("view.ready"))
      return;
    const t = {};
    ((r = this.view) == null ? void 0 : r.type) === "2d" ? t.rotation = 0 : t.heading = 0, this.callGoTo({ target: t });
  }
  _updateForRotation(t) {
    t != null && (this.orientation = { z: t });
  }
  _updateForCamera(t) {
    if (!t)
      return;
    const r = -t.heading;
    this.orientation = { x: 0, y: 0, z: r };
  }
  _updateRotationWatcher(t) {
    this._handles.removeAll(), t && this._handles.add(t.type === "2d" ? ze(() => t == null ? void 0 : t.rotation, this._updateForRotation, ln) : ze(() => t == null ? void 0 : t.camera, this._updateForCamera, ln));
  }
};
u([d({ readOnly: !0 })], Ac.prototype, "canShowNorth", null), u([d()], Ac.prototype, "orientation", void 0), u([d({ readOnly: !0 })], Ac.prototype, "state", null), u([d()], Ac.prototype, "view", void 0), Ac = u([E(Yhe)], Ac);
const R7 = Ac, Pl = { base: "geoscene-compass geoscene-widget--button geoscene-widget", text: "geoscene-icon-font-fallback-text", icon: "geoscene-compass__icon", rotationIcon: "geoscene-icon-dial", northIcon: "geoscene-icon-compass", widgetIcon: "geoscene-icon-locate-circled", interactive: "geoscene-interactive", disabled: "geoscene-disabled" };
let qs = class extends t0 {
  constructor(t, r) {
    super(t, r), this.iconClass = Pl.widgetIcon, this.icon = null, this.messages = null, this.viewModel = new R7();
  }
  get goToOverride() {
    return this.viewModel.goToOverride;
  }
  set goToOverride(t) {
    this.viewModel.goToOverride = t;
  }
  get label() {
    var t;
    return ((t = this.messages) == null ? void 0 : t.widgetLabel) ?? "";
  }
  set label(t) {
    this._overrideIfSome("label", t);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(t) {
    this.viewModel.view = t;
  }
  reset() {
    return this.viewModel.reset();
  }
  render() {
    const { orientation: t, state: r } = this.viewModel, n = r === "disabled", i = (r === "rotation" ? "rotation" : "compass") == "compass", s = n ? -1 : 0, o = { [Pl.disabled]: n, [Pl.interactive]: !n }, a = { [Pl.northIcon]: i, [Pl.rotationIcon]: !i }, { messages: l } = this;
    return xn("div", { bind: this, class: this.classes(Pl.base, o), onclick: this._reset, onkeydown: this._reset, role: "button", tabIndex: s, "aria-label": l.reset, title: l.reset }, xn("span", { "aria-hidden": "true", class: this.classes(Pl.icon, a), styles: this._toRotationTransform(t) }), xn("span", { class: Pl.text }, l.reset));
  }
  _reset() {
    this.viewModel.reset();
  }
  _toRotationTransform(t) {
    return { transform: `rotateZ(${t.z}deg)` };
  }
};
u([d()], qs.prototype, "goToOverride", null), u([d()], qs.prototype, "iconClass", void 0), u([d()], qs.prototype, "icon", void 0), u([d()], qs.prototype, "label", null), u([d(), L_("geoscene/widgets/Compass/t9n/Compass")], qs.prototype, "messages", void 0), u([d()], qs.prototype, "view", null), u([d({ type: R7 })], qs.prototype, "viewModel", void 0), u([R_()], qs.prototype, "_reset", null), qs = u([E("geoscene.widgets.Compass")], qs);
const Qhe = qs, vp = "geoscene-navigation-toggle", Hi = { base: `${vp} geoscene-widget`, button: `${vp}__button geoscene-widget--button`, activeButton: `${vp}__button--active`, panButton: `${vp}__button--pan`, rotateButton: `${vp}__button--rotate`, isLayoutHorizontal: `${vp}--horizontal`, rotationIcon: "geoscene-icon-rotate", panIcon: "geoscene-icon-pan", widgetIcon: "geoscene-icon-pan2", disabled: "geoscene-disabled" };
let Bp = class extends Ae {
  constructor(t) {
    super(t), this.navigationMode = "pan", this.view = null;
  }
  initialize() {
    this.own(Au(() => {
      var t;
      return (t = this.view) == null ? void 0 : t.inputManager;
    }, () => this._setNavigationMode()));
  }
  destroy() {
    this.view = null;
  }
  get state() {
    var t;
    return this.get("view.ready") && ((t = this.view) == null ? void 0 : t.type) === "3d" ? "ready" : "disabled";
  }
  toggle() {
    this.state !== "disabled" && (this.navigationMode = this.navigationMode !== "pan" ? "pan" : "rotate", this._setNavigationMode());
  }
  _setNavigationMode() {
    this.get("view.inputManager").primaryDragAction = this.navigationMode === "pan" ? "pan" : "rotate";
  }
};
u([d({ readOnly: !0 })], Bp.prototype, "state", null), u([d()], Bp.prototype, "navigationMode", void 0), u([d()], Bp.prototype, "view", void 0), Bp = u([E("geoscene.widgets.NavigationToggleViewModel")], Bp);
const L7 = Bp;
let Gs = class extends t0 {
  constructor(t, r) {
    super(t, r), this.iconClass = Hi.widgetIcon, this.icon = null, this.messages = null, this.viewModel = new L7();
  }
  get label() {
    var t;
    return ((t = this.messages) == null ? void 0 : t.widgetLabel) ?? "";
  }
  set label(t) {
    this._overrideIfSome("label", t);
  }
  set layout(t) {
    t !== "horizontal" && (t = "vertical"), this._set("layout", t);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(t) {
    this.viewModel.view = t;
  }
  toggle() {
    return this.viewModel.toggle();
  }
  render() {
    const t = this.get("viewModel.state") === "disabled", r = this.get("viewModel.navigationMode") === "pan", n = { [Hi.disabled]: t, [Hi.isLayoutHorizontal]: this.layout === "horizontal" }, i = { [Hi.activeButton]: r }, s = { [Hi.activeButton]: !r }, o = t ? -1 : 0, a = this.messages.toggle;
    return xn("div", { bind: this, class: this.classes(Hi.base, n), onclick: this._toggle, onkeydown: this._toggle, tabIndex: o, "aria-label": a, title: a }, xn("div", { class: this.classes(Hi.button, Hi.panButton, i) }, xn("span", { class: Hi.panIcon })), xn("div", { class: this.classes(Hi.button, Hi.rotateButton, s) }, xn("span", { class: Hi.rotationIcon })));
  }
  _toggle() {
    this.toggle();
  }
};
u([d()], Gs.prototype, "iconClass", void 0), u([d()], Gs.prototype, "icon", void 0), u([d()], Gs.prototype, "label", null), u([d({ value: "vertical" })], Gs.prototype, "layout", null), u([d(), L_("geoscene/widgets/NavigationToggle/t9n/NavigationToggle")], Gs.prototype, "messages", void 0), u([d()], Gs.prototype, "view", null), u([d({ type: L7 })], Gs.prototype, "viewModel", void 0), u([R_()], Gs.prototype, "_toggle", null), Gs = u([E("geoscene.widgets.NavigationToggle")], Gs);
const Xhe = Gs, Xf = { button: "geoscene-widget--button geoscene-widget", disabled: "geoscene-disabled", interactive: "geoscene-interactive", iconText: "geoscene-icon-font-fallback-text", icon: "geoscene-icon" };
let Aa = class extends t0 {
  constructor() {
    super(...arguments), this.enabled = !0, this.iconClass = null, this.icon = null, this.title = "";
  }
  render() {
    const t = this.enabled ? 0 : -1, r = { [Xf.disabled]: !this.enabled, [Xf.interactive]: this.enabled };
    return xn("div", { bind: this, class: this.classes(Xf.button, r), onclick: this._triggerAction, onkeydown: this._triggerAction, role: "button", tabIndex: t, title: this.title }, xn("span", { "aria-hidden": "true", role: "presentation", class: this.classes(Xf.icon, this.iconClass ?? "") }), xn("span", { class: Xf.iconText }, this.title));
  }
  _triggerAction() {
    this.action.call(this);
  }
};
u([d()], Aa.prototype, "action", void 0), u([d()], Aa.prototype, "enabled", void 0), u([d()], Aa.prototype, "iconClass", void 0), u([d()], Aa.prototype, "icon", void 0), u([d()], Aa.prototype, "title", void 0), u([R_()], Aa.prototype, "_triggerAction", null), Aa = u([E("geoscene.widgets.IconButton")], Aa);
const FR = Aa;
let qp = class extends Ae {
  get canZoomIn() {
    if (!this.get("view.ready"))
      return !1;
    const t = this.get("view.animation.target.scale") || this.get("view.scale"), r = this.get("view.constraints.effectiveMaxScale");
    return r === 0 || t > r;
  }
  get canZoomOut() {
    if (!this.get("view.ready"))
      return !1;
    const t = this.get("view.animation.target.scale") || this.get("view.scale"), r = this.get("view.constraints.effectiveMinScale");
    return r === 0 || t < r;
  }
};
u([d({ readOnly: !0 })], qp.prototype, "canZoomIn", null), u([d({ readOnly: !0 })], qp.prototype, "canZoomOut", null), u([d()], qp.prototype, "view", void 0), qp = u([E("geoscene.widgets.Zoom.ZoomConditions2D")], qp);
const efe = qp;
let Gp = class extends Ae {
  get canZoomIn() {
    return !!this.view.ready;
  }
  get canZoomOut() {
    return !!this.view.ready;
  }
};
u([d({ readOnly: !0 })], Gp.prototype, "canZoomIn", null), u([d({ readOnly: !0 })], Gp.prototype, "canZoomOut", null), u([d()], Gp.prototype, "view", void 0), Gp = u([E("geoscene.widgets.Zoom.ZoomConditions3D")], Gp);
const tfe = Gp;
let eu = class extends Ae {
  constructor(t) {
    super(t);
  }
  destroy() {
    this.view = null;
  }
  get canZoomIn() {
    return this._zoomConditions != null && this._zoomConditions.canZoomIn;
  }
  get canZoomOut() {
    var t;
    return this._zoomConditions != null && ((t = this._zoomConditions) == null ? void 0 : t.canZoomOut);
  }
  get state() {
    var t;
    return (t = this.view) != null && t.ready ? "ready" : "disabled";
  }
  set view(t) {
    t ? t.type === "2d" ? this._zoomConditions = new efe({ view: t }) : t.type === "3d" && (this._zoomConditions = new tfe({ view: t })) : this._zoomConditions = null, this._set("view", t);
  }
  zoomIn() {
    if (!this.canZoomIn)
      return;
    const t = this.view;
    t.type === "2d" ? t.mapViewNavigation.zoomIn() : E$(t.goTo({ zoomFactor: 2 }));
  }
  zoomOut() {
    if (!this.canZoomOut)
      return;
    const t = this.view;
    t.type === "2d" ? t.mapViewNavigation.zoomOut() : E$(t.goTo({ zoomFactor: 0.5 }));
  }
};
u([d()], eu.prototype, "_zoomConditions", void 0), u([d()], eu.prototype, "canZoomIn", null), u([d()], eu.prototype, "canZoomOut", null), u([d({ readOnly: !0 })], eu.prototype, "state", null), u([d()], eu.prototype, "view", null), eu = u([E("geoscene.widgets.Zoom.ZoomViewModel")], eu);
const N7 = eu, em = { base: "geoscene-zoom geoscene-widget", horizontalLayout: "geoscene-zoom--horizontal", zoomInIcon: "geoscene-icon-plus", zoomOutIcon: "geoscene-icon-minus", widgetIcon: "geoscene-icon-zoom-in-magnifying-glass" };
let jo = class extends t0 {
  constructor(t, r) {
    super(t, r), this.iconClass = em.widgetIcon, this.icon = null, this.messages = null, this.viewModel = new N7();
  }
  initialize() {
    this._zoomInButton = new FR({ action: this.zoomIn.bind(this), iconClass: em.zoomInIcon }), this._zoomOutButton = new FR({ action: this.zoomOut.bind(this), iconClass: em.zoomOutIcon });
  }
  destroy() {
    this._zoomInButton = Vt(this._zoomInButton), this._zoomOutButton = Vt(this._zoomOutButton);
  }
  get label() {
    var t;
    return ((t = this.messages) == null ? void 0 : t.widgetLabel) ?? "";
  }
  set label(t) {
    this._overrideIfSome("label", t);
  }
  set layout(t) {
    t !== "horizontal" && (t = "vertical"), this._set("layout", t);
  }
  set view(t) {
    this.viewModel.view = t;
  }
  get view() {
    return this.viewModel.view;
  }
  render() {
    const t = this.viewModel, r = { [em.horizontalLayout]: this.layout === "horizontal" }, { canZoomIn: n, canZoomOut: i } = t;
    this._zoomInButton.enabled = n, this._zoomOutButton.enabled = i;
    const { zoomIn: s, zoomOut: o } = this.messages;
    return this._zoomInButton.title = s, this._zoomOutButton.title = o, xn("div", { class: this.classes(em.base, r) }, this._zoomInButton.render(), this._zoomOutButton.render());
  }
  zoomIn() {
    return this.viewModel.zoomIn();
  }
  zoomOut() {
    return this.viewModel.zoomOut();
  }
};
u([d()], jo.prototype, "iconClass", void 0), u([d()], jo.prototype, "icon", void 0), u([d()], jo.prototype, "label", null), u([d({ value: "vertical" })], jo.prototype, "layout", null), u([d(), L_("geoscene/widgets/Zoom/t9n/Zoom")], jo.prototype, "messages", void 0), u([d()], jo.prototype, "view", null), u([d({ type: N7 })], jo.prototype, "viewModel", void 0), jo = u([E("geoscene.widgets.Zoom")], jo);
const rfe = jo;
function nfe(e) {
  return (e == null ? void 0 : e.view) !== void 0;
}
let S1 = class extends spe {
  constructor(t) {
    super(t), this._defaultPositionLookup = { attribution: "manual", compass: "top-left", "navigation-toggle": "top-left", zoom: "top-left" }, this.components = [], this._updateViewAwareWidgets = (r) => {
      this.components.forEach((n) => {
        const i = this._find(n), s = i == null ? void 0 : i.widget;
        nfe(s) && (s.view = r);
      });
    }, this._componentsWatcher = (r, n) => {
      this._removeComponents(n), this._addComponents(r), this._adjustPadding(r);
    };
  }
  initialize() {
    this.addHandles([ze(() => this.components, this._componentsWatcher, ln), ze(() => this.view, this._updateViewAwareWidgets, ln)]);
  }
  _add(t, r, n, i, s) {
    let o = t;
    if (typeof t == "string" && this._defaultPositionLookup[t]) {
      if (this._find(t))
        return;
      o = this._createComponent(t);
    }
    super._add(o, r, n, i, s);
  }
  _removeComponents(t) {
    t.forEach((r) => {
      const n = this._find(r);
      n && (this.remove(n), n.destroy());
    });
  }
  _adjustPadding(t) {
    if (!t.includes("attribution") && !this._isOverridden("padding")) {
      const { top: r } = this.padding;
      this.padding = r;
    }
  }
  _addComponents(t) {
    this.constructed && t.forEach((r) => this.add(this._createComponent(r), this._defaultPositionLookup[r]));
  }
  _createComponent(t) {
    const r = this._createWidget(t);
    return new _1({ id: t, node: r });
  }
  _createWidget(t) {
    const { view: r } = this;
    switch (t) {
      case "attribution":
        return new Zhe({ view: r });
      case "compass":
        return new Qhe({ view: r });
      case "navigation-toggle":
        return new Xhe({ view: r });
      case "zoom":
        return new rfe({ view: r });
    }
  }
};
u([d()], S1.prototype, "components", void 0), S1 = u([E("geoscene.views.ui.DefaultUI")], S1);
const F7 = S1;
let $1 = class extends F7 {
  constructor(t) {
    super(t), this.components = ["attribution", "zoom"];
  }
};
u([d()], $1.prototype, "components", void 0), $1 = u([E("geoscene.views.ui.2d.DefaultUI2D")], $1);
const D7 = $1;
var aE;
let x1 = aE = class extends re {
  constructor(e) {
    super(e), this.color = new Me([0, 0, 0, 1]);
  }
  clone() {
    return new aE(j({ color: this.color }));
  }
};
u([d({ type: Me, json: { write: !0 } })], x1.prototype, "color", void 0), x1 = aE = u([E("geoscene.webmap.background.ColorBackground")], x1);
const ife = x1;
let j7, V7, z7, U7, B7, q7;
async function sfe() {
  const [, { GraphicsView2D: e, GraphicContainer: t, LabelManager: r, MapViewNavigation: n, MagnifierView2D: i, Stage: s }] = await Promise.all([import("./webglDeps-SoGCl3pt.js"), import("./mapViewDeps-VYQCxM0W.js")]);
  V7 = e, z7 = t, U7 = r, B7 = n, q7 = i, j7 = s;
}
const DR = 160, jR = { flipY: !0, premultipliedAlpha: !0 };
let De = class extends toe(Rae(wae(Sle))) {
  constructor(e) {
    super(e), this._magnifierView = null, this._stage = null, this._resolveWhenReady = [], this.rootLayerViews = new Ky({ getCollections: () => {
      var t, r;
      return [(t = this.basemapView) == null ? void 0 : t.baseLayerViews, this.layerViews, (r = this.basemapView) == null ? void 0 : r.referenceLayerViews];
    }, getChildrenFunction: () => null }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.graphicsView = null, this.stateManager = new Nn({ constraints: new $V({ view: this }) }), this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = { samplingMode: "dynamic", edgeLabelsVisible: !0, labelsAnimationTime: 125, labelCollisionsEnabled: !0 }, this.rendering = !1, this.supersampleScreenshotsEnabled = !0, this.supportsGround = !1, this._stationaryTimer = null, this._gotoTask = null, this.frameTask = new Vue(this), this._pePromise = null, this.floors = new je(), this.highlightOptions = new BV(), this.inputManager = new wde({ view: this }), this.map = null, this.spatialReferenceLocked = !1, this.timeline = new qV(), this.type = "2d", this.ui = new D7(), this.padding = { top: 0, right: 0, bottom: 0, left: 0 }, this.addHandles([ze(() => this.viewpoint, () => {
      this._lastStationaryEventTimestamp = performance.now(), this._flipStationary(DR);
    }, Wg), this.on("resize", (t) => this.stateManager.resize(t.width, t.height)), ze(() => {
      var t;
      return (t = this.animationManager) == null ? void 0 : t.animation;
    }, (t) => {
      this.animation = t;
    })]), Aie();
  }
  destroy() {
    this._set("preconditionsReady", !1), this.frameTask = Vt(this.frameTask), this._gotoTask = null, this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new Ide(this.featuresTilingScheme);
  }
  get constraintsInfo() {
    var r, n;
    const e = (r = this.defaultsFromMap) == null ? void 0 : r.tileInfo, t = this.spatialReference;
    return { lods: (n = e == null ? void 0 : e.spatialReference) != null && n.equals(t) ? e.lods : null, spatialReference: t };
  }
  get state() {
    return this.stateManager.state;
  }
  get initialExtentRequired() {
    var o;
    if (!this.stateManager)
      return !1;
    const { scale: e, constraints: t, center: r, viewpoint: n, extent: i } = this;
    let s = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && ((o = this.map.initialViewProperties) != null && o.viewpoint)) && !i && (t != null && t.effectiveLODs || (s = -1), (!r || e === 0 && s === -1) && (!n || n.targetGeometry == null || n.targetGeometry.type !== "extent" && !n.scale));
  }
  get resourceManager() {
    return this._stage.resourceManager;
  }
  get textureManager() {
    return this._stage.painter.textureManager;
  }
  get _defaultsFromMapSettings() {
    return { required: { tileInfo: !0, heightModelInfo: !1, extent: !1 }, requiresExtentInSpatialReference: this.spatialReferenceLocked };
  }
  get _projectionEngineLoaded() {
    return !!rp() || (this._pePromise || (this._pePromise = Ru().finally(() => {
      this._pePromise = null;
    })), !1);
  }
  get typeSpecificPreconditionsReady() {
    const e = this._getDefaultViewpoint();
    if (!e)
      return !1;
    const t = this.spatialReference, r = e.targetGeometry;
    return !!ll(r.spatialReference, t) || this._projectionEngineLoaded;
  }
  set animation(e) {
    const t = this._get("animation");
    if (e === t)
      return;
    if (t && t.stop(), !e || e.isFulfilled())
      return void this._set("animation", null);
    this._set("animation", e), this.frameTask.animationInProgress = !0;
    const r = () => {
      var n;
      e === this._get("animation") && (this._set("animation", null), (n = this.frameTask) == null || n.requestFrame()), this.frameTask.animationInProgress = !1;
    };
    e.when(r, r);
  }
  get background() {
    return afe(this.map) ? this.map.initialViewProperties.background : null;
  }
  set background(e) {
    this._override("background", e);
  }
  get center() {
    var e;
    return ((e = this.stateManager) == null ? void 0 : e.center) ?? null;
  }
  set center(e) {
    this.stateManager.center = e;
  }
  get constraints() {
    var e;
    return (e = this.stateManager) == null ? void 0 : e.constraints;
  }
  set constraints(e) {
    e.view = this;
    const t = this.stateManager.constraints;
    this.stateManager.constraints = e, t == null || t.destroy();
  }
  get extent() {
    var e;
    return ((e = this.stateManager) == null ? void 0 : e.extent) ?? null;
  }
  set extent(e) {
    this.stateManager.extent = e;
  }
  get padding() {
    var e;
    return (e = this.stateManager) == null ? void 0 : e.padding;
  }
  set padding(e) {
    this.stateManager && (this.stateManager.padding = e);
  }
  get resizeAlign() {
    return this.stateManager.resizeAlign;
  }
  set resizeAlign(e) {
    this.stateManager.resizeAlign = e;
  }
  get resolution() {
    return this.stateManager.resolution ?? 0;
  }
  get rotation() {
    return this.stateManager.rotation ?? 0;
  }
  set rotation(e) {
    this.stateManager.rotation = e;
  }
  get scale() {
    var e;
    return ((e = this.stateManager) == null ? void 0 : e.scale) ?? 0;
  }
  set scale(e) {
    this.stateManager && (this.stateManager.scale = e);
  }
  get stationary() {
    return !(this.animation || this.navigating || this.resizing || this._stationaryTimer);
  }
  get updating() {
    var t, r, n;
    const e = !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || this.layerViewManager.updating === !0 || this.labelManager.updating === !0 || this.graphicsView.updating === !0 || this.allLayerViews.some((i) => !i.destroyed && !("layerViews" in i) && i.updating === !0));
    if (U("geoscene-2d-log-updating")) {
      const i = this.allLayerViews.reduce((s, o) => ({ ...s, [o.layer.id]: !o.destroyed && !("layerViews" in o) && o.updating }), {});
      console.log(`Updating MapView: ${e}
-> Null LayerViewManager: ${!this.layerViewManager}
-> Null LabelManager: ${!this.labelManager}
-> Null GraphicsView: ${!this.graphicsView}
-> layerViewManager.updating: ${(t = this.layerViewManager) == null ? void 0 : t.updating}
-> labelManager.updating: ${(r = this.labelManager) == null ? void 0 : r.updating}
-> graphicsView.updating: ${(n = this.graphicsView) == null ? void 0 : n.updating}
-> allLayerViews: ${JSON.stringify(i)}
`);
    }
    return e;
  }
  get viewpoint() {
    return this.stateManager.viewpoint ?? null;
  }
  set viewpoint(e) {
    this.stateManager.viewpoint = e, this.frameTask.requestFrame();
  }
  get zoom() {
    return this.stateManager.zoom ?? -1;
  }
  set zoom(e) {
    this.stateManager.zoom = e;
  }
  get navigating() {
    return !(!this.mapViewNavigation || !this.mapViewNavigation.interacting);
  }
  goTo(e, t) {
    if (e)
      return this.animation && (this.animation = null), this._createAnimation(), tO(() => this.ready, t).then(() => {
        var i;
        const r = { animate: !0, ...t }, n = _ue(e, this);
        return (i = this.animation) == null || i.update(n), this._gotoTask = {}, r.animate ? this._gotoAnimated(n, r) : this._gotoImmediate(n, r);
      });
    se.getLogger(this).error("#goTo()", "target cannot be null or undefined");
  }
  async hitTest(e, t) {
    const r = WP(e) ? HP(this, e) : e;
    if (!this.ready || isNaN(r.x) || isNaN(r.y))
      return { screenPoint: r, results: [] };
    let n = /* @__PURE__ */ new Set(), i = !1, s = null, o = null;
    t != null && t.include ? zR(t.include, VR(this, (h) => n.add(h), (h) => {
      s || (s = /* @__PURE__ */ new Set()), s.add(h);
    }, (h) => n.add(h), () => i = !0)) : (i = !0, n = new Set(this.allLayerViews)), t != null && t.exclude && zR(t.exclude, VR(this, (h) => n.delete(h), (h) => {
      o || (o = /* @__PURE__ */ new Set()), o.add(h);
    }));
    const a = this.allLayerViews.filter((h) => !h.suspended && n.has(h)).reverse(), l = this.toMap(r);
    let c = [...i ? this.graphicsView.hitTest(l).map((h) => ({ type: "graphic", graphic: h, layer: null, mapPoint: l })) : [], ...await Promise.all(a.map((h) => h.hitTest(l, r)).toArray())].filter(kh).flat().filter(kh);
    return s && (c = c.filter((h) => !("graphic" in h) || !h.graphic || (s == null ? void 0 : s.has(lE(h.graphic))))), o && (c = c.filter((h) => !("graphic" in h) || !h.graphic || !(o != null && o.has(lE(h.graphic))))), { screenPoint: r, results: c };
  }
  async takeScreenshot(e) {
    const t = this._createScreenshotPlan(e), r = await this._stage.takeScreenshot(t);
    return Cde(r, { format: t.format, quality: t.quality, rotation: 0, disableDecorations: !1 }, jR);
  }
  async _takeScreenshot(e) {
    const t = this._createScreenshotPlan(e), r = await this._stage.takeScreenshot(t);
    return kde(r, jR);
  }
  _createScreenshotPlan(e) {
    e = e ?? {};
    const t = this.supersampleScreenshotsEnabled ? Math.min(4, Lde(this.size, Math.min(4096, this._stage.context.parameters.maxTextureSize))) : 1;
    let r;
    e.layers ? (r = [], e.layers.forEach((s) => {
      const o = this.allLayerViews.find((a) => a.layer.id === s.id);
      o && "container" in o && o.container && r.push(o.container);
    })) : r = this._stage.children;
    const { format: n, quality: i } = Rde(e.format, e.quality);
    return Ode(e, t, this.size, this.padding, n, i, r, e.rotation);
  }
  get test() {
    return { takeScreenshot: (e) => this._takeScreenshot(e) };
  }
  toMap(e) {
    if (!this.ready)
      return null;
    const t = WP(e) ? HP(this, e) : e;
    return this.stateManager.toMap(t);
  }
  toScreen(e) {
    return this.stateManager.toScreen(e);
  }
  on(e, t, r, n) {
    return this.inputManager && this.viewEvents.on(e, t, r, n) || super.on(e, t);
  }
  hasEventListener(e) {
    return super.hasEventListener(e) || this.viewEvents.hasHandler(e);
  }
  whenLayerView(e) {
    return super.whenLayerView(e);
  }
  graphicChanged(e) {
    this.graphicsView && this.graphicsView.graphicUpdateHandler(e);
  }
  whenReady() {
    return new Promise((e) => {
      this.ready ? e(this) : this._resolveWhenReady.push(e);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    var e, t, r;
    return this.map && "initialViewProperties" in this.map && ((t = (e = this.map) == null ? void 0 : e.initialViewProperties) == null ? void 0 : t.spatialReference) || ((r = this.defaultsFromMap) == null ? void 0 : r.spatialReference) || null;
  }
  hasLayerViewModule(e) {
    return eR.hasLayerViewModule(e);
  }
  importLayerView(e) {
    return eR.importLayerView(e);
  }
  pixelSizeAt() {
    return this.ready ? this.resolution : (se.getLogger(this).error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e) {
    return this.hitTest(e).then((t) => ({ ...t, mapPoint: this.toMap(e) }));
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    let e = Zde(this.type);
    return U("safari") && U("safari") < 9 && (e = new G("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", { type: "safari", requiredVersion: 9, detectedVersion: U("safari") })), e != null ? (se.getLogger(this).warn("#validate()", e.message), Promise.reject(e)) : sfe();
  }
  _createAnimation() {
    return this.animation && !this.animation.done || (this.animation = new qT()), this.animation;
  }
  _cancellableGoTo(e, t, r) {
    const n = () => e === this._gotoTask, i = r.then(() => {
      n() && (this.animation = null);
    }).catch((o) => {
      throw n() && (t && !t.done && (t.stop(), this.frameTask.animationInProgress = !1), this.animation = null), o;
    }), s = new Promise((o) => o(i));
    return t.when().catch(() => {
      n() && s.cancel && s.cancel();
    }), s;
  }
  _gotoImmediate(e, t) {
    const r = this._gotoTask, n = this.animation, i = e.then((s) => {
      if (lr(t), r !== this._gotoTask)
        throw new G("view:goto-interrupted", "Goto was interrupted");
      this.viewpoint = n.target = s, n.finish();
    });
    return this._cancellableGoTo(r, n, i);
  }
  _flipStationary(e) {
    return this._stationaryTimer !== null || (this._stationaryTimer = setTimeout(() => {
      this._stationaryTimer = null;
      const t = performance.now() - this._lastStationaryEventTimestamp;
      t < DR && (this._stationaryTimer = this._flipStationary(t));
    }, e)), this._stationaryTimer;
  }
  _getDefaultViewpoint() {
    var v;
    const { constraints: e, initialExtent: t, map: r, padding: n, size: i } = this;
    if (!e)
      return null;
    const s = r && "initialViewProperties" in r ? r.initialViewProperties : void 0, o = this.stateManager.getUserStartupOptions(this.size), a = s == null ? void 0 : s.viewpoint, l = ((v = a == null ? void 0 : a.targetGeometry) == null ? void 0 : v.extent) ?? t, c = l == null ? void 0 : l.center, h = (a == null ? void 0 : a.rotation) ?? 0, f = (a == null ? void 0 : a.scale) || l && Sh(l, [i[0] - n.left - n.right, i[1] - n.top - n.bottom]), m = o.center ?? c, y = o.rotation ?? h, g = o.scale ?? f;
    return m && g ? new Qo({ targetGeometry: m, scale: g, rotation: y }) : null;
  }
  _gotoAnimated(e, t) {
    const r = this._gotoTask, n = this.animation;
    if (!n)
      return Promise.resolve();
    const i = e.then((s) => {
      if (lr(t), r !== this._gotoTask)
        throw new G("view:goto-interrupted", "Goto was interrupted");
      return n.update(s), this.animationManager.animate(n, this.viewpoint, t), n.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(r, n, i);
  }
  _startup() {
    var o;
    this.timeline.begin("MapView Startup");
    const e = this._getDefaultViewpoint();
    this.stateManager.startup(e, this.size, this.spatialReference, (o = this.defaultsFromMap.extent) == null ? void 0 : o.center), this.graphics.owner = this;
    const t = new j7(this.surface, { canvas: this.renderCanvas, supersampleScreenshots: this.supersampleScreenshotsEnabled, contextOptions: { disabledExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions }, renderingOptions: this.renderingOptions, timeline: this.timeline });
    this._stage = t, this._magnifierView = new q7(), this._magnifierView.magnifier = this.magnifier;
    const r = new U7({ view: this });
    this._set("labelManager", r);
    const n = new jue({ view: this });
    this._set("animationManager", n);
    const i = new B7({ view: this, animationManager: n });
    this._set("mapViewNavigation", i), this._setupSpatialReferenceDependentProperties(), this.handles.add([this.rootLayerViews.on("change", () => this._updateStageChildren()), t.on("post-render", () => this._set("rendering", t.renderRequested)), t.on("will-render", () => this._set("rendering", t.renderRequested)), t.on("webgl-error", (a) => this.fatalError = a.error), ze(() => this.stationary, (a) => t.stationary = a, cu), ze(() => this.background, (a) => {
      t.backgroundColor = a == null ? void 0 : a.color, this._magnifierView.backgroundColor = a == null ? void 0 : a.color;
    }, cu), ze(() => this.magnifier, (a) => this._magnifierView.magnifier = a, cu), ze(() => this.renderingOptions, (a) => t.renderingOptions = a, cu), ze(() => this.highlightOptions, (a) => t.highlightOptions = a, cu), ze(() => this.state.id, () => t.state = this.state, cu)], "map-view"), this._updateStageChildren();
    const s = this._resolveWhenReady;
    this._resolveWhenReady = [], s.forEach((a) => a(this)), this.timeline.end("MapView Startup"), this.frameTask.start(), this._set("ready", !0);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.handles.remove("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this._stage.destroy(), this._stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask.stop(), this._stationaryTimer && (clearTimeout(this._stationaryTimer), this._stationaryTimer = null), this._set("ready", !1), this.stateManager.teardown(), this.animation = null;
  }
  _updateStageChildren() {
    this._stage.removeAllChildren(), this.rootLayerViews.forEach((t) => {
      this._stage.addChild(t.container);
    });
    const e = this.graphicsView;
    this._stage.addChild(e.container), this._stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e = new Kue(Xse.create({ spatialReference: this.spatialReference, size: 512, numLODs: 36 }));
    this._set("featuresTilingScheme", e);
    const t = new V7({ view: this, graphics: this.graphics, requestUpdateCallback: () => this.requestUpdate(), container: new z7(e) });
    this._set("graphicsView", t);
  }
  _destroySpatialReferenceDependentProperties() {
    const e = this.graphicsView;
    this._set("graphicsView", null), e.destroy(), this._set("featuresTilingScheme", null);
  }
  _spatialReferenceChanged(e) {
    if (this.ready) {
      this.frameTask.stop();
      for (const t of this.allLayerViews)
        t.processDetach();
      this._destroySpatialReferenceDependentProperties(), this.stateManager.changeSpatialReference(e), this._stage.state = this.state, this._setupSpatialReferenceDependentProperties();
      for (const t of this.allLayerViews)
        t.processAttach();
      this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
    }
  }
};
De.type = "2d", u([d({ readOnly: !0 })], De.prototype, "animationManager", void 0), u([d({ constructOnly: !0 })], De.prototype, "deactivatedWebGLExtensions", void 0), u([d({ constructOnly: !0 })], De.prototype, "debugWebGLExtensions", void 0), u([d({ readOnly: !0 })], De.prototype, "featuresTilingScheme", void 0), u([d({ readOnly: !0 })], De.prototype, "fullOpacity", void 0), u([d({ readOnly: !0 })], De.prototype, "graphicsTileStore", null), u([d()], De.prototype, "graphicsView", void 0), u([d()], De.prototype, "stateManager", void 0), u([d()], De.prototype, "constraintsInfo", null), u([d({ readOnly: !0 })], De.prototype, "state", null), u([d()], De.prototype, "initialExtentRequired", null), u([d()], De.prototype, "labelManager", void 0), u([d({ readOnly: !0 })], De.prototype, "resourceManager", null), u([d({ readOnly: !0 })], De.prototype, "textureManager", null), u([d({ readOnly: !0 })], De.prototype, "mapViewNavigation", void 0), u([d({ constructOnly: !0 })], De.prototype, "renderCanvas", void 0), u([d()], De.prototype, "renderingOptions", void 0), u([d({ readOnly: !0 })], De.prototype, "rendering", void 0), u([d({ constructOnly: !0 })], De.prototype, "supersampleScreenshotsEnabled", void 0), u([d({ readOnly: !0 })], De.prototype, "supportsGround", void 0), u([d()], De.prototype, "_stationaryTimer", void 0), u([d()], De.prototype, "_defaultsFromMapSettings", null), u([d()], De.prototype, "_pePromise", void 0), u([d({ readOnly: !0 })], De.prototype, "typeSpecificPreconditionsReady", null), u([d()], De.prototype, "animation", null), u([d({ type: ife })], De.prototype, "background", null), u([d()], De.prototype, "center", null), u([d({ type: $V })], De.prototype, "constraints", null), u([d()], De.prototype, "extent", null), u([d()], De.prototype, "floors", void 0), u([d({ type: BV })], De.prototype, "highlightOptions", void 0), u([d({ readOnly: !0 })], De.prototype, "inputManager", void 0), u([d()], De.prototype, "map", void 0), u([d()], De.prototype, "padding", null), u([d()], De.prototype, "resizeAlign", null), u([d({ readOnly: !0 })], De.prototype, "resolution", null), u([d()], De.prototype, "rotation", null), u([d()], De.prototype, "scale", null), u([d({ constructOnly: !0 })], De.prototype, "spatialReferenceLocked", void 0), u([d()], De.prototype, "stationary", null), u([d({ type: qV, readOnly: !0 })], De.prototype, "timeline", void 0), u([d({ readOnly: !0 })], De.prototype, "type", void 0), u([d({ readOnly: !0 })], De.prototype, "updating", null), u([d()], De.prototype, "viewpoint", null), u([d()], De.prototype, "zoom", null), u([d({ readOnly: !0 })], De.prototype, "navigating", null), u([d(), xt((e) => e instanceof F7 ? e : Xw(D7, e))], De.prototype, "ui", void 0), De = u([E("geoscene.views.MapView")], De);
const ofe = De;
function lE(e) {
  var r, n;
  const t = e.getObjectId();
  return t ? `${((r = e.layer) == null ? void 0 : r.uid) ?? ((n = e.sourceLayer) == null ? void 0 : n.uid) ?? "MapView"}/${t}` : `"MapView/${e.uid}`;
}
function VR(e, t, r, n, i) {
  return (s) => {
    if (s instanceof vr) {
      if (s.layer === e)
        i == null || i();
      else {
        const o = e.allLayerViews.find((a) => a.layer === s.layer);
        o && (n == null || n(o));
      }
      r(lE(s));
    } else {
      const o = e.allLayerViews.find((a) => a.layer === s);
      o && t(o);
    }
  };
}
function zR(e, t) {
  if (e)
    if (ob(e))
      for (const r of e)
        if (ob(r))
          for (const n of r)
            t(n);
        else
          t(r);
    else
      t(e);
}
function afe(e) {
  return (e == null ? void 0 : e.declaredClass) === "geoscene.WebMap";
}
function N_() {
  const e = new Float32Array(16);
  return e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;
}
function lfe(e) {
  const t = new Float32Array(16);
  return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
}
function ufe(e, t, r, n, i, s, o, a, l, c, h, f, m, y, g, v) {
  const b = new Float32Array(16);
  return b[0] = e, b[1] = t, b[2] = r, b[3] = n, b[4] = i, b[5] = s, b[6] = o, b[7] = a, b[8] = l, b[9] = c, b[10] = h, b[11] = f, b[12] = m, b[13] = y, b[14] = g, b[15] = v, b;
}
function cfe(e, t) {
  return new Float32Array(e, t, 16);
}
const dfe = N_();
Object.freeze(Object.defineProperty({ __proto__: null, IDENTITY: dfe, clone: lfe, create: N_, createView: cfe, fromValues: ufe }, Symbol.toStringTag, { value: "Module" }));
const pfe = (e, t) => {
  const r = Wu(e, t, 0, 0, 0, 0, t, 0, 0, 0, 0, t, 0, 0, 0, 0, 1);
  return hl(r, r);
}, hfe = (e, t) => {
  const r = Wu(e, t, 0, 0, 0.5 - 0.5 * t, 0, t, 0, 0.5 - 0.5 * t, 0, 0, t, 0.5 - 0.5 * t, 0, 0, 0, 1);
  return hl(r, r);
}, ffe = (e, t) => {
  const r = 1 - t, n = Wu(e, 0.2126 + 0.7874 * r, 0.7152 - 0.7152 * r, 0.0722 - 0.0722 * r, 0, 0.2126 - 0.2126 * r, 0.7152 + 0.2848 * r, 0.0722 - 0.0722 * r, 0, 0.2126 - 0.2126 * r, 0.7152 - 0.7152 * r, 0.0722 + 0.9278 * r, 0, 0, 0, 0, 1);
  return hl(n, n);
}, mfe = (e, t) => {
  const r = Math.sin(t * Math.PI / 180), n = Math.cos(t * Math.PI / 180), i = Wu(e, 0.213 + 0.787 * n - 0.213 * r, 0.715 - 0.715 * n - 0.715 * r, 0.072 - 0.072 * n + 0.928 * r, 0, 0.213 - 0.213 * n + 0.143 * r, 0.715 + 0.285 * n + 0.14 * r, 0.072 - 0.072 * n - 0.283 * r, 0, 0.213 - 0.213 * n - 0.787 * r, 0.715 - 0.715 * n + 0.715 * r, 0.072 + 0.928 * n + 0.072 * r, 0, 0, 0, 0, 1);
  return hl(i, i);
}, yfe = (e, t) => {
  const r = 1 - 2 * t, n = Wu(e, r, 0, 0, t, 0, r, 0, t, 0, 0, r, t, 0, 0, 0, 1);
  return hl(n, n);
}, gfe = (e, t) => {
  const r = Wu(e, 0.213 + 0.787 * t, 0.715 - 0.715 * t, 0.072 - 0.072 * t, 0, 0.213 - 0.213 * t, 0.715 + 0.285 * t, 0.072 - 0.072 * t, 0, 0.213 - 0.213 * t, 0.715 - 0.715 * t, 0.072 + 0.928 * t, 0, 0, 0, 0, 1);
  return hl(r, r);
}, vfe = (e, t) => {
  const r = 1 - t, n = Wu(e, 0.393 + 0.607 * r, 0.769 - 0.769 * r, 0.189 - 0.189 * r, 0, 0.349 - 0.349 * r, 0.686 + 0.314 * r, 0.168 - 0.168 * r, 0, 0.272 - 0.272 * r, 0.534 - 0.534 * r, 0.131 + 0.869 * r, 0, 0, 0, 0, 1);
  return hl(n, n);
};
let G7 = class H7 {
  constructor(t, r, n) {
    this.strength = t, this.radius = r, this.threshold = n, this.type = "bloom";
  }
  interpolate(t, r, n) {
    this.strength = oi(t.strength, r.strength, n), this.radius = oi(t.radius, r.radius, n), this.threshold = oi(t.threshold, r.threshold, n);
  }
  clone() {
    return new H7(this.strength, this.radius, this.threshold);
  }
  toJSON() {
    return { type: "bloom", radius: Ey(this.radius), strength: this.strength, threshold: this.threshold };
  }
}, W7 = class J7 {
  constructor(t) {
    this.radius = t, this.type = "blur";
  }
  interpolate(t, r, n) {
    this.radius = Math.round(oi(t.radius, r.radius, n));
  }
  clone() {
    return new J7(this.radius);
  }
  toJSON() {
    return { type: "blur", radius: Ey(this.radius) };
  }
}, uE = class Z7 {
  constructor(t, r) {
    this.type = t, this.amount = r, this.type !== "invert" && this.type !== "grayscale" && this.type !== "sepia" || (this.amount = Math.min(this.amount, 1));
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t, r, n) {
    this.amount = oi(t.amount, r.amount, n), this._updateMatrix();
  }
  clone() {
    return new Z7(this.type, this.amount);
  }
  toJSON() {
    return { type: this.type, amount: this.amount };
  }
  _updateMatrix() {
    const t = this._colorMatrix || N_();
    switch (this.type) {
      case "brightness":
        this._colorMatrix = pfe(t, this.amount);
        break;
      case "contrast":
        this._colorMatrix = hfe(t, this.amount);
        break;
      case "grayscale":
        this._colorMatrix = ffe(t, this.amount);
        break;
      case "invert":
        this._colorMatrix = yfe(t, this.amount);
        break;
      case "saturate":
        this._colorMatrix = gfe(t, this.amount);
        break;
      case "sepia":
        this._colorMatrix = vfe(t, this.amount);
    }
  }
}, K7 = class Y7 {
  constructor(t, r, n, i) {
    this.offsetX = t, this.offsetY = r, this.blurRadius = n, this.color = i, this.type = "drop-shadow";
  }
  interpolate(t, r, n) {
    this.offsetX = oi(t.offsetX, r.offsetX, n), this.offsetY = oi(t.offsetY, r.offsetY, n), this.blurRadius = oi(t.blurRadius, r.blurRadius, n), this.color[0] = Math.round(oi(t.color[0], r.color[0], n)), this.color[1] = Math.round(oi(t.color[1], r.color[1], n)), this.color[2] = Math.round(oi(t.color[2], r.color[2], n)), this.color[3] = oi(t.color[3], r.color[3], n);
  }
  clone() {
    return new Y7(this.offsetX, this.offsetY, this.blurRadius, [...this.color]);
  }
  toJSON() {
    const t = [...this.color];
    return t[3] *= 255, { type: "drop-shadow", xoffset: Ey(this.offsetX), yoffset: Ey(this.offsetY), blurRadius: Ey(this.blurRadius), color: t };
  }
}, Q7 = class X7 {
  constructor(t) {
    this.angle = t, this.type = "hue-rotate";
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t, r, n) {
    this.angle = oi(t.angle, r.angle, n), this._updateMatrix();
  }
  clone() {
    return new X7(this.angle);
  }
  toJSON() {
    return { type: "hue-rotate", angle: this.angle };
  }
  _updateMatrix() {
    const t = this._colorMatrix || N_();
    this._colorMatrix = mfe(t, this.angle);
  }
}, ez = class tz {
  constructor(t) {
    this.amount = t, this.type = "opacity", this.amount = Math.min(this.amount, 1);
  }
  interpolate(t, r, n) {
    this.amount = oi(t.amount, r.amount, n);
  }
  clone() {
    return new tz(this.amount);
  }
  toJSON() {
    return { type: "opacity", amount: this.amount };
  }
};
function oi(e, t, r) {
  return e + (t - e) * r;
}
function Ey(e) {
  return Math.round(1e3 * al(e)) / 1e3;
}
function bfe(e) {
  switch (e.type) {
    case "grayscale":
    case "sepia":
    case "invert":
      return new uE(e.type, 0);
    case "saturate":
    case "brightness":
    case "contrast":
      return new uE(e.type, 1);
    case "opacity":
      return new ez(1);
    case "hue-rotate":
      return new Q7(0);
    case "blur":
      return new W7(0);
    case "drop-shadow":
      return new K7(0, 0, 0, [...mM("transparent")]);
    case "bloom":
      return new G7(0, 0, 1);
  }
}
function wfe(e, t) {
  const r = e.length > t.length ? e : t;
  return (e.length > t.length ? t : e).every((n, i) => n.type === r[i].type);
}
function _fe(e, t) {
  const r = e.length > t.length ? e : t, n = e.length > t.length ? t : e;
  for (let i = n.length; i < r.length; i++)
    n.push(bfe(r[i]));
}
function Sfe(e) {
  const t = e[0];
  return !!t && "type" in t;
}
var UR, BR, cE = { exports: {} };
cE.exports, BR = function() {
  function e(i, s) {
    function o() {
      this.constructor = i;
    }
    o.prototype = s.prototype, i.prototype = new o();
  }
  function t(i, s, o, a) {
    var l = Error.call(this, i);
    return Object.setPrototypeOf && Object.setPrototypeOf(l, t.prototype), l.expected = s, l.found = o, l.location = a, l.name = "SyntaxError", l;
  }
  function r(i, s, o) {
    return o = o || " ", i.length > s ? i : (s -= i.length, i + (o += o.repeat(s)).slice(0, s));
  }
  function n(i, s) {
    var o, a = {}, l = (s = s !== void 0 ? s : {}).grammarSource, c = { start: QC }, h = QC, f = "none", m = ")", y = ",", g = "(", v = "%", b = "px", w = "cm", x = "mm", $ = "in", T = "pt", C = "pc", I = "deg", O = "rad", M = "grad", L = "turn", N = "#", ee = ".", D = "e", H = /^[ \t\n\r]/, J = /^[a-z\-]/, oe = /^[0-9a-fA-F]/, ye = /^[+\-]/, Q = /^[0-9]/, ve = fa("none"), Ee = Hr("none", !1), Lt = Hr(")", !1), ft = Hr(",", !1), Nt = fa("whitespace"), ir = Pf([" ", "	", `
`, "\r"], !1, !1), wr = fa("function"), _r = Hr("(", !1), Pr = fa("identifier"), xe = Pf([["a", "z"], "-"], !1, !1), Ne = fa("percentage"), He = Hr("%", !1), nt = fa("length"), wt = Hr("px", !1), cr = Hr("cm", !1), qr = Hr("mm", !1), mi = Hr("in", !1), Gn = Hr("pt", !1), On = Hr("pc", !1), Hn = fa("angle"), Cn = Hr("deg", !1), yi = Hr("rad", !1), dr = Hr("grad", !1), Wn = Hr("turn", !1), kn = fa("number"), Jn = fa("color"), Zn = Hr("#", !1), ae = Pf([["0", "9"], ["a", "f"], ["A", "F"]], !1, !1), Fe = Pf(["+", "-"], !1, !1), at = Pf([["0", "9"]], !1, !1), pr = Hr(".", !1), gi = Hr("e", !1), Is = function() {
      return [];
    }, wo = function(k, W) {
      return { type: "function", name: k, parameters: W || [] };
    }, te = function(k, W) {
      return W.length > 0 ? lG(k, W, 3) : [k];
    }, fe = function(k) {
      return { type: "quantity", value: k.value, unit: k.unit };
    }, _e = function(k) {
      return { type: "color", colorType: k.type, value: k.value };
    }, ct = function(k) {
      return k;
    }, An = function() {
      return g0();
    }, Gr = function(k) {
      return { value: k, unit: "%" };
    }, dn = function(k) {
      return { value: k, unit: "px" };
    }, Cf = function(k) {
      return { value: k, unit: "cm" };
    }, lp = function(k) {
      return { value: k, unit: "mm" };
    }, kf = function(k) {
      return { value: k, unit: "in" };
    }, Af = function(k) {
      return { value: k, unit: "pt" };
    }, V = function(k) {
      return { value: k, unit: "pc" };
    }, ie = function(k) {
      return { value: k, unit: "deg" };
    }, be = function(k) {
      return { value: k, unit: "rad" };
    }, Be = function(k) {
      return { value: k, unit: "grad" };
    }, sn = function(k) {
      return { value: k, unit: "turn" };
    }, pn = function(k) {
      return { value: k, unit: null };
    }, Kn = function() {
      return { type: "hex", value: g0() };
    }, Vi = function(k) {
      return { type: "function", value: k };
    }, Yn = function() {
      return { type: "named", value: g0() };
    }, up = function() {
      return parseFloat(g0());
    }, z = 0, it = 0, zi = [{ line: 1, column: 1 }], _o = 0, v2 = [], Te = 0;
    if ("startRule" in s) {
      if (!(s.startRule in c))
        throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
      h = c[s.startRule];
    }
    function g0() {
      return i.substring(it, z);
    }
    function Hr(k, W) {
      return { type: "literal", text: k, ignoreCase: W };
    }
    function Pf(k, W, ne) {
      return { type: "class", parts: k, inverted: W, ignoreCase: ne };
    }
    function Kq() {
      return { type: "end" };
    }
    function fa(k) {
      return { type: "other", description: k };
    }
    function KC(k) {
      var W, ne = zi[k];
      if (ne)
        return ne;
      for (W = k - 1; !zi[W]; )
        W--;
      for (ne = { line: (ne = zi[W]).line, column: ne.column }; W < k; )
        i.charCodeAt(W) === 10 ? (ne.line++, ne.column = 1) : ne.column++, W++;
      return zi[k] = ne, ne;
    }
    function YC(k, W, ne) {
      var Ze = KC(k), Sr = KC(W), Tt = { source: l, start: { offset: k, line: Ze.line, column: Ze.column }, end: { offset: W, line: Sr.line, column: Sr.column } };
      return ne && l && typeof l.offset == "function" && (Tt.start = l.offset(Tt.start), Tt.end = l.offset(Tt.end)), Tt;
    }
    function Ge(k) {
      z < _o || (z > _o && (_o = z, v2 = []), v2.push(k));
    }
    function Yq(k, W, ne) {
      return new t(t.buildMessage(k, W), k, W, ne);
    }
    function QC() {
      var k;
      return (k = Qq()) === a && (k = Xq()), k;
    }
    function Qq() {
      var k, W;
      return Te++, k = z, Wr(), i.substr(z, 4) === f ? (W = f, z += 4) : (W = a, Te === 0 && Ge(Ee)), W !== a ? (Wr(), it = k, k = Is()) : (z = k, k = a), Te--, k === a && Te === 0 && Ge(ve), k;
    }
    function Xq() {
      var k, W;
      if (k = [], (W = b2()) !== a)
        for (; W !== a; )
          k.push(W), W = b2();
      else
        k = a;
      return k;
    }
    function b2() {
      var k, W, ne, Ze;
      return k = z, Wr(), (W = tG()) !== a ? (Wr(), (ne = eG()) === a && (ne = null), Wr(), i.charCodeAt(z) === 41 ? (Ze = m, z++) : (Ze = a, Te === 0 && Ge(Lt)), Ze !== a ? (Wr(), it = k, k = wo(W, ne)) : (z = k, k = a)) : (z = k, k = a), k;
    }
    function eG() {
      var k, W, ne, Ze, Sr, Tt, Bi, v0;
      if (k = z, (W = w2()) !== a) {
        for (ne = [], Ze = z, Sr = Wr(), i.charCodeAt(z) === 44 ? (Tt = y, z++) : (Tt = a, Te === 0 && Ge(ft)), Tt === a && (Tt = null), Bi = Wr(), (v0 = w2()) !== a ? Ze = Sr = [Sr, Tt, Bi, v0] : (z = Ze, Ze = a); Ze !== a; )
          ne.push(Ze), Ze = z, Sr = Wr(), i.charCodeAt(z) === 44 ? (Tt = y, z++) : (Tt = a, Te === 0 && Ge(ft)), Tt === a && (Tt = null), Bi = Wr(), (v0 = w2()) !== a ? Ze = Sr = [Sr, Tt, Bi, v0] : (z = Ze, Ze = a);
        it = k, k = te(W, ne);
      } else
        z = k, k = a;
      return k;
    }
    function w2() {
      var k, W;
      return k = z, (W = rG()) === a && (W = nG()) === a && (W = iG()) === a && (W = sG()), W !== a && (it = k, W = fe(W)), (k = W) === a && (k = z, (W = oG()) !== a && (it = k, W = _e(W)), k = W), k;
    }
    function Wr() {
      var k, W;
      for (Te++, k = [], H.test(i.charAt(z)) ? (W = i.charAt(z), z++) : (W = a, Te === 0 && Ge(ir)); W !== a; )
        k.push(W), H.test(i.charAt(z)) ? (W = i.charAt(z), z++) : (W = a, Te === 0 && Ge(ir));
      return Te--, W = a, Te === 0 && Ge(Nt), k;
    }
    function tG() {
      var k, W, ne;
      return Te++, k = z, (W = XC()) !== a ? (i.charCodeAt(z) === 40 ? (ne = g, z++) : (ne = a, Te === 0 && Ge(_r)), ne !== a ? (it = k, k = ct(W)) : (z = k, k = a)) : (z = k, k = a), Te--, k === a && (W = a, Te === 0 && Ge(wr)), k;
    }
    function XC() {
      var k, W, ne;
      if (Te++, k = z, W = [], J.test(i.charAt(z)) ? (ne = i.charAt(z), z++) : (ne = a, Te === 0 && Ge(xe)), ne !== a)
        for (; ne !== a; )
          W.push(ne), J.test(i.charAt(z)) ? (ne = i.charAt(z), z++) : (ne = a, Te === 0 && Ge(xe));
      else
        W = a;
      return W !== a && (it = k, W = An()), Te--, (k = W) === a && (W = a, Te === 0 && Ge(Pr)), k;
    }
    function rG() {
      var k, W, ne;
      return Te++, k = z, Wr(), (W = Ui()) !== a ? (i.charCodeAt(z) === 37 ? (ne = v, z++) : (ne = a, Te === 0 && Ge(He)), ne !== a ? (it = k, k = Gr(W)) : (z = k, k = a)) : (z = k, k = a), Te--, k === a && Te === 0 && Ge(Ne), k;
    }
    function nG() {
      var k, W, ne;
      return Te++, k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === b ? (ne = b, z += 2) : (ne = a, Te === 0 && Ge(wt)), ne !== a ? (it = k, k = dn(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === w ? (ne = w, z += 2) : (ne = a, Te === 0 && Ge(cr)), ne !== a ? (it = k, k = Cf(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === x ? (ne = x, z += 2) : (ne = a, Te === 0 && Ge(qr)), ne !== a ? (it = k, k = lp(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === $ ? (ne = $, z += 2) : (ne = a, Te === 0 && Ge(mi)), ne !== a ? (it = k, k = kf(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === T ? (ne = T, z += 2) : (ne = a, Te === 0 && Ge(Gn)), ne !== a ? (it = k, k = Af(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, Wr(), (W = Ui()) !== a ? (i.substr(z, 2) === C ? (ne = C, z += 2) : (ne = a, Te === 0 && Ge(On)), ne !== a ? (it = k, k = V(W)) : (z = k, k = a)) : (z = k, k = a)))))), Te--, k === a && Te === 0 && Ge(nt), k;
    }
    function iG() {
      var k, W, ne;
      return Te++, k = z, (W = Ui()) !== a ? (i.substr(z, 3) === I ? (ne = I, z += 3) : (ne = a, Te === 0 && Ge(Cn)), ne !== a ? (it = k, k = ie(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, (W = Ui()) !== a ? (i.substr(z, 3) === O ? (ne = O, z += 3) : (ne = a, Te === 0 && Ge(yi)), ne !== a ? (it = k, k = be(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, (W = Ui()) !== a ? (i.substr(z, 4) === M ? (ne = M, z += 4) : (ne = a, Te === 0 && Ge(dr)), ne !== a ? (it = k, k = Be(W)) : (z = k, k = a)) : (z = k, k = a), k === a && (k = z, (W = Ui()) !== a ? (i.substr(z, 4) === L ? (ne = L, z += 4) : (ne = a, Te === 0 && Ge(Wn)), ne !== a ? (it = k, k = sn(W)) : (z = k, k = a)) : (z = k, k = a)))), Te--, k === a && (W = a, Te === 0 && Ge(Hn)), k;
    }
    function sG() {
      var k, W;
      return Te++, k = z, Wr(), (W = Ui()) !== a ? (it = k, k = pn(W)) : (z = k, k = a), Te--, k === a && Te === 0 && Ge(kn), k;
    }
    function oG() {
      var k, W, ne, Ze;
      if (Te++, k = z, i.charCodeAt(z) === 35 ? (W = N, z++) : (W = a, Te === 0 && Ge(Zn)), W !== a) {
        if (ne = [], oe.test(i.charAt(z)) ? (Ze = i.charAt(z), z++) : (Ze = a, Te === 0 && Ge(ae)), Ze !== a)
          for (; Ze !== a; )
            ne.push(Ze), oe.test(i.charAt(z)) ? (Ze = i.charAt(z), z++) : (Ze = a, Te === 0 && Ge(ae));
        else
          ne = a;
        ne !== a ? (it = k, k = Kn()) : (z = k, k = a);
      } else
        z = k, k = a;
      return k === a && (k = z, (W = b2()) !== a && (it = k, W = Vi(W)), (k = W) === a && (k = z, (W = XC()) !== a && (it = k, W = Yn()), k = W)), Te--, k === a && (W = a, Te === 0 && Ge(Jn)), k;
    }
    function Ui() {
      var k, W, ne, Ze, Sr, Tt, Bi;
      for (k = z, ye.test(i.charAt(z)) ? (i.charAt(z), z++) : Te === 0 && Ge(Fe), W = z, ne = [], Q.test(i.charAt(z)) ? (Ze = i.charAt(z), z++) : (Ze = a, Te === 0 && Ge(at)); Ze !== a; )
        ne.push(Ze), Q.test(i.charAt(z)) ? (Ze = i.charAt(z), z++) : (Ze = a, Te === 0 && Ge(at));
      if (i.charCodeAt(z) === 46 ? (Ze = ee, z++) : (Ze = a, Te === 0 && Ge(pr)), Ze !== a) {
        if (Sr = [], Q.test(i.charAt(z)) ? (Tt = i.charAt(z), z++) : (Tt = a, Te === 0 && Ge(at)), Tt !== a)
          for (; Tt !== a; )
            Sr.push(Tt), Q.test(i.charAt(z)) ? (Tt = i.charAt(z), z++) : (Tt = a, Te === 0 && Ge(at));
        else
          Sr = a;
        Sr !== a ? W = ne = [ne, Ze, Sr] : (z = W, W = a);
      } else
        z = W, W = a;
      if (W === a)
        if (W = [], Q.test(i.charAt(z)) ? (ne = i.charAt(z), z++) : (ne = a, Te === 0 && Ge(at)), ne !== a)
          for (; ne !== a; )
            W.push(ne), Q.test(i.charAt(z)) ? (ne = i.charAt(z), z++) : (ne = a, Te === 0 && Ge(at));
        else
          W = a;
      if (W !== a) {
        if (ne = z, i.charCodeAt(z) === 101 ? (Ze = D, z++) : (Ze = a, Te === 0 && Ge(gi)), Ze !== a) {
          if (ye.test(i.charAt(z)) ? (Sr = i.charAt(z), z++) : (Sr = a, Te === 0 && Ge(Fe)), Sr === a && (Sr = null), Tt = [], Q.test(i.charAt(z)) ? (Bi = i.charAt(z), z++) : (Bi = a, Te === 0 && Ge(at)), Bi !== a)
            for (; Bi !== a; )
              Tt.push(Bi), Q.test(i.charAt(z)) ? (Bi = i.charAt(z), z++) : (Bi = a, Te === 0 && Ge(at));
          else
            Tt = a;
          Tt !== a ? ne = Ze = [Ze, Sr, Tt] : (z = ne, ne = a);
        } else
          z = ne, ne = a;
        ne === a && (ne = null), it = k, k = up();
      } else
        z = k, k = a;
      return k;
    }
    function aG(k, W) {
      return k.map(function(ne) {
        return ne[W];
      });
    }
    function lG(k, W, ne) {
      return [k].concat(aG(W, ne));
    }
    if ((o = h()) !== a && z === i.length)
      return o;
    throw o !== a && z < i.length && Ge(Kq()), Yq(v2, _o < i.length ? i.charAt(_o) : null, _o < i.length ? YC(_o, _o + 1) : YC(_o, _o));
  }
  return e(t, Error), t.prototype.format = function(i) {
    var s = "Error: " + this.message;
    if (this.location) {
      var o, a = null;
      for (o = 0; o < i.length; o++)
        if (i[o].source === this.location.source) {
          a = i[o].text.split(/\r\n|\n|\r/g);
          break;
        }
      var l = this.location.start, c = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(l) : l, h = this.location.source + ":" + c.line + ":" + c.column;
      if (a) {
        var f = this.location.end, m = r("", c.line.toString().length, " "), y = a[l.line - 1], g = (l.line === f.line ? f.column : y.length + 1) - l.column || 1;
        s += `
 --> ` + h + `
` + m + ` |
` + c.line + " | " + y + `
` + m + " | " + r("", l.column - 1, " ") + r("", g, "^");
      } else
        s += `
 at ` + h;
    }
    return s;
  }, t.buildMessage = function(i, s) {
    var o = { literal: function(y) {
      return '"' + l(y.text) + '"';
    }, class: function(y) {
      var g = y.parts.map(function(v) {
        return Array.isArray(v) ? c(v[0]) + "-" + c(v[1]) : c(v);
      });
      return "[" + (y.inverted ? "^" : "") + g.join("") + "]";
    }, any: function() {
      return "any character";
    }, end: function() {
      return "end of input";
    }, other: function(y) {
      return y.description;
    } };
    function a(y) {
      return y.charCodeAt(0).toString(16).toUpperCase();
    }
    function l(y) {
      return y.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(g) {
        return "\\x0" + a(g);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(g) {
        return "\\x" + a(g);
      });
    }
    function c(y) {
      return y.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(g) {
        return "\\x0" + a(g);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(g) {
        return "\\x" + a(g);
      });
    }
    function h(y) {
      return o[y.type](y);
    }
    function f(y) {
      var g, v, b = y.map(h);
      if (b.sort(), b.length > 0) {
        for (g = 1, v = 1; g < b.length; g++)
          b[g - 1] !== b[g] && (b[v] = b[g], v++);
        b.length = v;
      }
      switch (b.length) {
        case 1:
          return b[0];
        case 2:
          return b[0] + " or " + b[1];
        default:
          return b.slice(0, -1).join(", ") + ", or " + b[b.length - 1];
      }
    }
    function m(y) {
      return y ? '"' + l(y) + '"' : "end of input";
    }
    return "Expected " + f(i) + " but " + m(s) + " found.";
  }, { SyntaxError: t, parse: n };
}, (UR = cE).exports && (UR.exports = BR());
var $fe = cE.exports;
function rz(e) {
  if (!e || e.length === 0)
    return null;
  if (typeof e == "string") {
    const r = qR(e);
    return r && r.length !== 0 ? r : null;
  }
  const t = e.map((r) => {
    if (!Number.isFinite(r.scale) || r.scale <= 0)
      throw new G("effect:invalid-scale", "scale must be finite and greater than 0", { stop: r });
    return { scale: r.scale, effects: qR(r.value) };
  });
  t.sort((r, n) => n.effects.length - r.effects.length);
  for (let r = 0; r < t.length - 1; r++) {
    if (!wfe(t[r].effects, t[r + 1].effects))
      throw new G("effect:interpolation-impossible", "Cannot interpolate by scale between 2 lists of mixed effects", { a: t[r].effects, b: t[r + 1].effects });
    _fe(t[r].effects, t[r + 1].effects);
  }
  return t.sort((r, n) => n.scale - r.scale), t;
}
function qR(e) {
  let t;
  if (!e)
    return [];
  try {
    t = $fe.parse(e);
  } catch (r) {
    throw new G("effect:invalid-syntax", "Invalid effect syntax", { value: e, error: r });
  }
  return t.map((r) => xfe(r));
}
function xfe(e) {
  try {
    switch (e.name) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
        return Tfe(e);
      case "opacity":
        return Efe(e);
      case "hue-rotate":
        return Ife(e);
      case "blur":
        return Mfe(e);
      case "drop-shadow":
        return Ofe(e);
      case "bloom":
        return Cfe(e);
    }
  } catch (t) {
    throw t.details.filter = e, t;
  }
  throw new G("effect:unknown-effect", `Effect '${e.name}' is not supported`, { effect: e });
}
function Tfe(e) {
  let t = 1;
  return bf(e.parameters, 1), e.parameters.length === 1 && (t = to(e.parameters[0])), new uE(e.name, t);
}
function Efe(e) {
  let t = 1;
  return bf(e.parameters, 1), e.parameters.length === 1 && (t = to(e.parameters[0])), new ez(t);
}
function Ife(e) {
  let t = 0;
  return bf(e.parameters, 1), e.parameters.length === 1 && (t = Nfe(e.parameters[0])), new Q7(t);
}
function Mfe(e) {
  let t = 0;
  return bf(e.parameters, 1), e.parameters.length === 1 && (t = RO(e.parameters[0]), r0(t, e.parameters[0])), new W7(t);
}
function Ofe(e) {
  const t = [];
  let r = null;
  for (const n of e.parameters)
    if (n.type === "color") {
      if (t.length && Object.freeze(t), r)
        throw new G("effect:type-error", "Accepts only one color", {});
      r = Ffe(n);
    } else {
      const i = RO(n);
      if (Object.isFrozen(t))
        throw new G("effect:type-error", "<length> parameters not consecutive", { lengths: t });
      t.push(i), t.length === 3 && r0(i, n);
    }
  if (t.length < 2 || t.length > 3)
    throw new G("effect:type-error", `Expected <length>{2,3}, Actual: <length>{${t.length}}`, { lengths: t });
  return new K7(t[0], t[1], t[2] || 0, r || nz("black"));
}
function Cfe(e) {
  let t = 1, r = 0, n = 0;
  return bf(e.parameters, 3), e.parameters[0] && (t = to(e.parameters[0])), e.parameters[1] && (r = RO(e.parameters[1]), r0(r, e.parameters[1])), e.parameters[2] && (n = to(e.parameters[2])), new G7(t, r, n);
}
function bf(e, t) {
  if (e.length > t)
    throw new G("effect:type-error", `Function supports up to ${t} parameters, Actual: ${e.length}`, { parameters: e });
}
function F_(e) {
  if (e.type === "color")
    return "<color>";
  if (e.unit) {
    if (e.unit in PO)
      return "<length>";
    if (e.unit in AO)
      return "<angle>";
    if (e.unit === "%")
      return "<percentage>";
  }
  return "<double>";
}
function r0(e, t) {
  if (e < 0)
    throw new G("effect:type-error", `Negative values are not allowed, Actual: ${e}`, { term: t });
}
function kfe(e) {
  if (e.type !== "quantity" || e.unit !== null)
    throw new G("effect:type-error", `Expected <double>, Actual: ${F_(e)}`, { term: e });
}
function Afe(e) {
  if (e.type !== "quantity" || e.unit !== null && e.unit !== "%")
    throw new G("effect:type-error", `Expected <double> or <percentage>, Actual: ${F_(e)}`, { term: e });
}
const AO = { deg: 1, grad: 0.9, rad: 180 / Math.PI, turn: 360 };
function Pfe(e) {
  if (e.type !== "quantity" || !(e.value === 0 && e.unit === null || e.unit && AO[e.unit] != null))
    throw new G("effect:type-error", `Expected <angle>, Actual: ${F_(e)}`, { term: e });
}
const PO = { px: 1, cm: 96 / 2.54, mm: 96 / 2.54 / 10, in: 96, pc: 16, pt: 96 / 72 };
function Rfe(e) {
  if (e.type !== "quantity" || !(e.value === 0 && e.unit === null || e.unit && PO[e.unit] != null))
    throw new G("effect:type-error", `Expected <length>, Actual: ${F_(e)}`, { term: e });
}
function to(e) {
  Afe(e);
  const t = e.value;
  return r0(t, e), e.unit === "%" ? 0.01 * t : t;
}
function Lfe(e) {
  return kfe(e), r0(e.value, e), e.value;
}
function Nfe(e) {
  return Pfe(e), e.value * AO[e.unit] || 0;
}
function RO(e) {
  return Rfe(e), e.value * PO[e.unit] || 0;
}
function Ffe(e) {
  switch (e.colorType) {
    case "hex":
      return CY(e.value);
    case "named":
      return nz(e.value);
    case "function":
      return Vfe(e.value);
  }
}
function nz(e) {
  if (!D6(e))
    throw new G("effect:unknown-color", `color '${e}' isn't valid`, { namedColor: e });
  return OY(e);
}
const Dfe = /^rgba?/i, jfe = /^hsla?/i;
function Vfe(e) {
  if (bf(e.parameters, 4), Dfe.test(e.name))
    return [to(e.parameters[0]), to(e.parameters[1]), to(e.parameters[2]), e.parameters[3] ? to(e.parameters[3]) : 1];
  if (jfe.test(e.name))
    return j6(Lfe(e.parameters[0]), to(e.parameters[1]), to(e.parameters[2]), e.parameters[3] ? to(e.parameters[3]) : 1);
  throw new G("effect:syntax-error", `Invalid color function '${e.name}'`, { colorFunction: e });
}
function LO(e, t, r) {
  var n;
  try {
    return Ufe(e);
  } catch (i) {
    (n = r == null ? void 0 : r.messages) == null || n.push(i);
  }
  return null;
}
function NO(e, t, r, n) {
  try {
    const i = zfe(e);
    In(r, i, t);
  } catch (i) {
    n.messages && n.messages.push(i);
  }
}
function zfe(e) {
  const t = rz(e);
  return t ? Sfe(t) ? t.map((r) => r.toJSON()) : t.map(({ scale: r, effects: n }) => ({ scale: r, value: n.map((i) => i.toJSON()) })) : null;
}
function Ufe(e) {
  if (!e || e.length === 0)
    return null;
  if (Bfe(e)) {
    const t = [];
    for (const r of e)
      t.push({ scale: r.scale, value: GR(r.value) });
    return t;
  }
  return GR(e);
}
function Bfe(e) {
  const t = e[0];
  return !!t && "scale" in t;
}
function GR(e) {
  if (!e || !e.length)
    return "";
  const t = [];
  for (const r of e) {
    let n = [];
    switch (r.type) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
      case "opacity":
        n = [ba(r, "amount")];
        break;
      case "blur":
        n = [ba(r, "radius", "pt")];
        break;
      case "hue-rotate":
        n = [ba(r, "angle", "deg")];
        break;
      case "drop-shadow":
        n = [ba(r, "xoffset", "pt"), ba(r, "yoffset", "pt"), ba(r, "blurRadius", "pt"), qfe(r, "color")];
        break;
      case "bloom":
        n = [ba(r, "strength"), ba(r, "radius", "pt"), ba(r, "threshold")];
    }
    const i = `${r.type}(${n.filter(Boolean).join(" ")})`;
    rz(i), t.push(i);
  }
  return t.join(" ");
}
function ba(e, t, r) {
  if (e[t] == null)
    throw new G("effect:missing-parameter", `Missing parameter '${t}' in ${e.type} effect`, { effect: e });
  return r ? e[t] + r : "" + e[t];
}
function qfe(e, t) {
  if (e[t] == null)
    throw new G("effect:missing-parameter", `Missing parameter '${t}' in ${e.type} effect`, { effect: e });
  const r = e[t];
  return `rgba(${r[0] || 0}, ${r[1] || 0}, ${r[2] || 0}, ${r[3] / 255 || 0})`;
}
const HR = { read: { reader: LO }, write: { allowNull: !0, writer: NO } }, iz = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.blendMode = "normal", this.effect = null;
    }
  };
  return u([d({ type: ["average", "color-burn", "color-dodge", "color", "darken", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "exclusion", "hard-light", "hue", "invert", "lighten", "lighter", "luminosity", "minus", "multiply", "normal", "overlay", "plus", "reflect", "saturation", "screen", "soft-light", "source-atop", "source-in", "source-out", "vivid-light", "xor"], nonNullable: !0, json: { read: !1, write: !1, origins: { "web-map": { read: !0, write: !0 }, "portal-item": { read: !0, write: !0 } } } })], t.prototype, "blendMode", void 0), u([d({ json: { read: !1, write: !1, origins: { "web-map": HR, "portal-item": HR } } })], t.prototype, "effect", void 0), t = u([E("geoscene.layers.mixins.BlendLayer")], t), t;
}, sz = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.minScale = 0, this.maxScale = 0;
    }
    get effectiveScaleRange() {
      const r = { minScale: this.minScale, maxScale: this.maxScale }, n = this.parent;
      n && "effectiveScaleRange" in n && Gfe(r, n.effectiveScaleRange);
      const i = this._get("effectiveScaleRange");
      return i && i.minScale === r.minScale && i.maxScale === r.maxScale ? i : r;
    }
  };
  return u([d({ type: Number, nonNullable: !0, json: { write: !0 } })], t.prototype, "minScale", void 0), u([d({ type: Number, nonNullable: !0, json: { write: !0 } })], t.prototype, "maxScale", void 0), u([d({ readOnly: !0 })], t.prototype, "effectiveScaleRange", null), t = u([E("geoscene.layers.mixins.ScaleRangeLayer")], t), t;
};
function Gfe(e, t) {
  return e.minScale = e.minScale > 0 ? t.minScale > 0 ? Math.min(e.minScale, t.minScale) : e.minScale : t.minScale, e.maxScale = e.maxScale > 0 ? t.maxScale > 0 ? Math.max(e.maxScale, t.maxScale) : e.maxScale : t.maxScale, e;
}
var dE;
let Wm = dE = class extends re {
  constructor(e) {
    super(e);
  }
  async collectRequiredFields(e, t) {
    return qn(e, t, this.expression);
  }
  clone() {
    return new dE({ expression: this.expression, title: this.title });
  }
  equals(e) {
    return this.expression === e.expression && this.title === e.title;
  }
};
u([d({ type: String, json: { write: !0 } })], Wm.prototype, "expression", void 0), u([d({ type: String, json: { write: !0 } })], Wm.prototype, "title", void 0), Wm = dE = u([E("geoscene.layers.support.FeatureExpressionInfo")], Wm);
const WR = Wm, FO = { unknown: 1, inches: Wi(1, "meters", "inches"), feet: Wi(1, "meters", "feet"), "us-feet": Wi(1, "meters", "us-feet"), yards: Wi(1, "meters", "yards"), miles: Wi(1, "meters", "miles"), "nautical-miles": Wi(1, "meters", "nautical-miles"), millimeters: Wi(1, "meters", "millimeters"), centimeters: Wi(1, "meters", "centimeters"), decimeters: Wi(1, "meters", "decimeters"), meters: Wi(1, "meters", "meters"), kilometers: Wi(1, "meters", "kilometers"), "decimal-degrees": 1 / QZ(1, "meters", Bt.radius) };
function n5e(e) {
  return 1 / (FO[e] || 1);
}
function Hfe() {
  const e = Object.keys(FO);
  return e.sort(), e;
}
const Wfe = Hfe();
var pE;
const sv = Mn()({ onTheGround: "on-the-ground", relativeToGround: "relative-to-ground", relativeToScene: "relative-to-scene", absoluteHeight: "absolute-height" }), JR = new et({ foot: "feet", kilometer: "kilometers", meter: "meters", mile: "miles", "us-foot": "us-feet", yard: "yards" });
let Pa = pE = class extends re {
  constructor(e) {
    super(e), this.offset = null;
  }
  readFeatureExpressionInfo(e, t) {
    return e ?? (t.featureExpression && t.featureExpression.value === 0 ? { expression: "0" } : void 0);
  }
  writeFeatureExpressionInfo(e, t, r, n) {
    t[r] = e.write({}, n), e.expression === "0" && (t.featureExpression = { value: 0 });
  }
  get mode() {
    const { offset: e, featureExpressionInfo: t } = this;
    return this._isOverridden("mode") ? this._get("mode") : e != null || t ? "relative-to-ground" : "on-the-ground";
  }
  set mode(e) {
    this._override("mode", e);
  }
  set unit(e) {
    this._set("unit", e);
  }
  write(e, t) {
    return this.offset || this.mode || this.featureExpressionInfo || this.unit ? super.write(e, t) : null;
  }
  clone() {
    return new pE({ mode: this.mode, offset: this.offset, featureExpressionInfo: this.featureExpressionInfo ? this.featureExpressionInfo.clone() : void 0, unit: this.unit });
  }
  equals(e) {
    return this.mode === e.mode && this.offset === e.offset && this.unit === e.unit && HH(this.featureExpressionInfo, e.featureExpressionInfo);
  }
};
u([d({ type: WR, json: { write: !0 } })], Pa.prototype, "featureExpressionInfo", void 0), u([ce("featureExpressionInfo", ["featureExpressionInfo", "featureExpression"])], Pa.prototype, "readFeatureExpressionInfo", null), u([ge("featureExpressionInfo", { featureExpressionInfo: { type: WR }, "featureExpression.value": { type: [0] } })], Pa.prototype, "writeFeatureExpressionInfo", null), u([d({ type: sv.apiValues, nonNullable: !0, json: { type: sv.jsonValues, read: sv.read, write: { writer: sv.write, isRequired: !0 } } })], Pa.prototype, "mode", null), u([d({ type: Number, json: { write: !0 } })], Pa.prototype, "offset", void 0), u([d({ type: Wfe, json: { type: String, read: JR.read, write: JR.write } })], Pa.prototype, "unit", null), Pa = pE = u([E("geoscene.layers.support.ElevationInfo")], Pa);
const oz = Pa;
let Ra = class extends iz(sz(EM)) {
  constructor(t) {
    super(t), this.elevationInfo = null, this.graphics = new wd(), this.screenSizePerspectiveEnabled = !0, this.type = "graphics", this.internal = !1;
  }
  destroy() {
    this.removeAll(), this.graphics.destroy();
  }
  add(t) {
    return this.graphics.add(t), this;
  }
  addMany(t) {
    return this.graphics.addMany(t), this;
  }
  removeAll() {
    return this.graphics.removeAll(), this;
  }
  remove(t) {
    this.graphics.remove(t);
  }
  removeMany(t) {
    this.graphics.removeMany(t);
  }
  on(t, r) {
    return super.on(t, r);
  }
  graphicChanged(t) {
    this.emit("graphic-update", t);
  }
};
u([d({ type: oz })], Ra.prototype, "elevationInfo", void 0), u([d(DT(wd, "graphics"))], Ra.prototype, "graphics", void 0), u([d({ type: ["show", "hide"] })], Ra.prototype, "listMode", void 0), u([d()], Ra.prototype, "screenSizePerspectiveEnabled", void 0), u([d({ readOnly: !0 })], Ra.prototype, "type", void 0), u([d({ constructOnly: !0 })], Ra.prototype, "internal", void 0), Ra = u([E("geoscene.layers.GraphicsLayer")], Ra);
const D_ = Ra;
var hE;
let Jm = hE = class extends re {
  constructor(e) {
    super(e), this.minValue = 0, this.maxValue = 0;
  }
  clone() {
    return new hE({ minValue: this.minValue, maxValue: this.maxValue });
  }
};
u([d({ type: Number, json: { write: !0 } })], Jm.prototype, "minValue", void 0), u([d({ type: Number, json: { write: !0 } })], Jm.prototype, "maxValue", void 0), Jm = hE = u([E("geoscene.renderer.support.AuthoringInfoClassBreakInfo")], Jm);
var fE;
let fu = fE = class extends re {
  constructor(e) {
    super(e), this.field = "", this.normalizationField = "", this.label = "", this.classBreakInfos = [];
  }
  clone() {
    return new fE({ field: this.field, normalizationField: this.normalizationField, label: this.label, classBreakInfos: j(this.classBreakInfos) });
  }
};
u([d({ type: String, json: { write: !0 } })], fu.prototype, "field", void 0), u([d({ type: String, json: { write: !0 } })], fu.prototype, "normalizationField", void 0), u([d({ type: String, json: { write: !0 } })], fu.prototype, "label", void 0), u([d({ type: [Jm], json: { write: !0 } })], fu.prototype, "classBreakInfos", void 0), fu = fE = u([E("geoscene.renderers.support.AuthoringInfoFieldInfo")], fu);
var mE;
const ov = new et({ percentTotal: "percent-of-total", ratio: "ratio", percent: "percent" }), av = new et({ sizeInfo: "size", colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation" }), ZR = { key: (e) => typeof e == "number" ? "number" : "string", typeMap: { number: Number, string: String }, base: null }, KR = ["high-to-low", "above-and-below", "centered-on", "extremes"], YR = [.../* @__PURE__ */ new Set(["high-to-low", "above-and-below", "centered-on", "extremes", "90-10", "above", "below", "high-to-low", "above-and-below", "90-10", "above", "below"])], QR = ["seconds", "minutes", "hours", "days", "months", "years"];
let ni = mE = class extends re {
  constructor(e) {
    super(e), this.endTime = null, this.field = null, this.maxSliderValue = null, this.minSliderValue = null, this.startTime = null, this.type = null, this.units = null;
  }
  castEndTime(e) {
    return typeof e == "string" || typeof e == "number" ? e : null;
  }
  castStartTime(e) {
    return typeof e == "string" || typeof e == "number" ? e : null;
  }
  get style() {
    return this.type === "color" ? this._get("style") : null;
  }
  set style(e) {
    this._set("style", e);
  }
  get theme() {
    return this.type === "color" || this.type === "size" ? this._get("theme") || "high-to-low" : null;
  }
  set theme(e) {
    this._set("theme", e);
  }
  clone() {
    return new mE({ endTime: this.endTime, field: this.field, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, startTime: this.startTime, style: this.style, theme: this.theme, type: this.type, units: this.units });
  }
};
u([d({ types: ZR, json: { write: !0 } })], ni.prototype, "endTime", void 0), u([xt("endTime")], ni.prototype, "castEndTime", null), u([d({ type: String, json: { write: !0 } })], ni.prototype, "field", void 0), u([d({ type: Number, json: { write: !0 } })], ni.prototype, "maxSliderValue", void 0), u([d({ type: Number, json: { write: !0 } })], ni.prototype, "minSliderValue", void 0), u([d({ types: ZR, json: { write: !0 } })], ni.prototype, "startTime", void 0), u([xt("startTime")], ni.prototype, "castStartTime", null), u([d({ type: ov.apiValues, value: null, json: { type: ov.jsonValues, read: ov.read, write: ov.write } })], ni.prototype, "style", null), u([d({ type: YR, value: null, json: { type: YR, origins: { "web-scene": { type: KR, write: { writer: (e, t) => {
  KR.includes(e) && (t.theme = e);
} } } }, write: !0 } })], ni.prototype, "theme", null), u([d({ type: av.apiValues, json: { type: av.jsonValues, read: av.read, write: av.write } })], ni.prototype, "type", void 0), u([d({ type: QR, json: { type: QR, write: !0 } })], ni.prototype, "units", void 0), ni = mE = u([E("geoscene.renderers.support.AuthoringInfoVisualVariable")], ni);
const Jfe = ni;
let T1 = class extends re {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d({ readOnly: !0, json: { read: !1, write: !0 } })], T1.prototype, "type", void 0), T1 = u([E("geoscene.rest.support.ColorRamp")], T1);
const DO = T1;
var yE;
let Pc = yE = class extends DO {
  constructor(e) {
    super(e), this.algorithm = null, this.fromColor = null, this.toColor = null, this.type = "algorithmic";
  }
  clone() {
    return new yE({ fromColor: j(this.fromColor), toColor: j(this.toColor), algorithm: this.algorithm });
  }
};
u([Ie({ esriCIELabAlgorithm: "cie-lab", esriHSVAlgorithm: "hsv", esriLabLChAlgorithm: "lab-lch" })], Pc.prototype, "algorithm", void 0), u([d({ type: Me, json: { type: [Ot], write: !0 } })], Pc.prototype, "fromColor", void 0), u([d({ type: Me, json: { type: [Ot], write: !0 } })], Pc.prototype, "toColor", void 0), u([d({ type: ["algorithmic"] })], Pc.prototype, "type", void 0), Pc = yE = u([E("geoscene.rest.support.AlgorithmicColorRamp")], Pc);
const jO = Pc;
var gE;
let Zm = gE = class extends DO {
  constructor(e) {
    super(e), this.colorRamps = null, this.type = "multipart";
  }
  clone() {
    return new gE({ colorRamps: j(this.colorRamps) });
  }
};
u([d({ type: [jO], json: { write: !0 } })], Zm.prototype, "colorRamps", void 0), u([d({ type: ["multipart"] })], Zm.prototype, "type", void 0), Zm = gE = u([E("geoscene.rest.support.MultipartColorRamp")], Zm);
const az = Zm, Zfe = { key: "type", base: DO, typeMap: { algorithmic: jO, multipart: az } };
function Kfe(e) {
  return e && e.type ? e.type === "algorithmic" ? jO.fromJSON(e) : e.type === "multipart" ? az.fromJSON(e) : null : null;
}
var vE;
const sc = new et({ esriClassifyDefinedInterval: "defined-interval", esriClassifyEqualInterval: "equal-interval", esriClassifyManual: "manual", esriClassifyNaturalBreaks: "natural-breaks", esriClassifyQuantile: "quantile", esriClassifyStandardDeviation: "standard-deviation" }), lv = new et({ pieChart: "pie-chart", classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density", flow: "flow" }), XR = new et({ classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density" }), e4 = ["inches", "feet", "yards", "miles", "nautical-miles", "millimeters", "centimeters", "decimeters", "meters", "kilometers", "decimal-degrees"], Yfe = ["high-to-low", "above-and-below", "above", "below", "90-10"], Qfe = ["flow-line", "wave-front"], Xfe = ["caret", "circle-caret", "arrow", "circle-arrow", "plus-minus", "circle-plus-minus", "square", "circle", "triangle", "happy-sad", "thumb", "custom"];
let sr = vE = class extends re {
  constructor(e) {
    super(e), this.colorRamp = null, this.fadeRatio = null, this.isAutoGenerated = !1, this.lengthUnit = null, this.maxSliderValue = null, this.minSliderValue = null, this.visualVariables = null;
  }
  get classificationMethod() {
    const e = this._get("classificationMethod"), t = this.type;
    return t && t !== "relationship" ? t === "class-breaks-size" || t === "class-breaks-color" ? e || "manual" : null : e;
  }
  set classificationMethod(e) {
    this._set("classificationMethod", e);
  }
  readColorRamp(e) {
    return e ? Kfe(e) : void 0;
  }
  get fields() {
    return this.type && this.type !== "predominance" ? null : this._get("fields");
  }
  set fields(e) {
    this._set("fields", e);
  }
  get field1() {
    return this.type && this.type !== "relationship" ? null : this._get("field1");
  }
  set field1(e) {
    this._set("field1", e);
  }
  get field2() {
    return this.type && this.type !== "relationship" ? null : this._get("field2");
  }
  set field2(e) {
    this._set("field2", e);
  }
  get flowTheme() {
    return this.type === "flow" ? this._get("flowTheme") : null;
  }
  set flowTheme(e) {
    this._set("flowTheme", e);
  }
  get focus() {
    return this.type && this.type !== "relationship" ? null : this._get("focus");
  }
  set focus(e) {
    this._set("focus", e);
  }
  get numClasses() {
    return this.type && this.type !== "relationship" ? null : this._get("numClasses");
  }
  set numClasses(e) {
    this._set("numClasses", e);
  }
  get statistics() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("statistics") : null;
  }
  set statistics(e) {
    this._set("statistics", e);
  }
  get standardDeviationInterval() {
    const e = this.type;
    return e && e !== "relationship" && e !== "class-breaks-size" && e !== "class-breaks-color" || this.classificationMethod && this.classificationMethod !== "standard-deviation" ? null : this._get("standardDeviationInterval");
  }
  set standardDeviationInterval(e) {
    this._set("standardDeviationInterval", e);
  }
  get type() {
    return this._get("type");
  }
  set type(e) {
    let t = e;
    e === "classed-size" ? t = "class-breaks-size" : e === "classed-color" && (t = "class-breaks-color"), this._set("type", t);
  }
  get univariateSymbolStyle() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("univariateSymbolStyle") : null;
  }
  set univariateSymbolStyle(e) {
    this._set("univariateSymbolStyle", e);
  }
  get univariateTheme() {
    return this.type === "univariate-color-size" ? this._get("univariateTheme") : null;
  }
  set univariateTheme(e) {
    this._set("univariateTheme", e);
  }
  clone() {
    return new vE({ classificationMethod: this.classificationMethod, colorRamp: j(this.colorRamp), fadeRatio: j(this.fadeRatio), fields: this.fields && this.fields.slice(0), field1: j(this.field1), field2: j(this.field2), isAutoGenerated: this.isAutoGenerated, focus: this.focus, numClasses: this.numClasses, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, lengthUnit: this.lengthUnit, statistics: this.statistics, standardDeviationInterval: this.standardDeviationInterval, type: this.type, visualVariables: this.visualVariables && this.visualVariables.map((e) => e.clone()), univariateSymbolStyle: this.univariateSymbolStyle, univariateTheme: this.univariateTheme, flowTheme: this.flowTheme });
  }
};
u([d({ type: sc.apiValues, value: null, json: { type: sc.jsonValues, read: sc.read, write: sc.write, origins: { "web-document": { default: "manual", type: sc.jsonValues, read: sc.read, write: sc.write } } } })], sr.prototype, "classificationMethod", null), u([d({ types: Zfe, json: { write: !0 } })], sr.prototype, "colorRamp", void 0), u([ce("colorRamp")], sr.prototype, "readColorRamp", null), u([d({ json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], sr.prototype, "fadeRatio", void 0), u([d({ type: [String], value: null, json: { write: !0 } })], sr.prototype, "fields", null), u([d({ type: fu, value: null, json: { write: !0 } })], sr.prototype, "field1", null), u([d({ type: fu, value: null, json: { write: !0 } })], sr.prototype, "field2", null), u([d({ type: Qfe, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], sr.prototype, "flowTheme", null), u([d({ type: ["HH", "HL", "LH", "LL"], value: null, json: { write: !0 } })], sr.prototype, "focus", null), u([d({ type: Boolean, json: { write: !0, default: !1, origins: { "web-scene": { write: !1 } } } })], sr.prototype, "isAutoGenerated", void 0), u([d({ type: Number, value: null, json: { type: Ot, write: !0 } })], sr.prototype, "numClasses", null), u([d({ type: e4, json: { type: e4, read: !1, write: !1, origins: { "web-scene": { read: !0, write: !0 } } } })], sr.prototype, "lengthUnit", void 0), u([d({ type: Number, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], sr.prototype, "maxSliderValue", void 0), u([d({ type: Number, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], sr.prototype, "minSliderValue", void 0), u([d({ type: Object, value: null, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], sr.prototype, "statistics", null), u([d({ type: [0.25, 0.33, 0.5, 1], value: null, json: { type: [0.25, 0.33, 0.5, 1], write: !0 } })], sr.prototype, "standardDeviationInterval", null), u([d({ type: lv.apiValues, value: null, json: { type: lv.jsonValues, read: lv.read, write: lv.write, origins: { "web-scene": { type: XR.jsonValues, write: { writer: XR.write, overridePolicy: (e) => ({ enabled: e !== "flow" }) } } } } })], sr.prototype, "type", null), u([d({ type: [Jfe], json: { write: !0 } })], sr.prototype, "visualVariables", void 0), u([d({ type: Xfe, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], sr.prototype, "univariateSymbolStyle", null), u([d({ type: Yfe, value: null, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], sr.prototype, "univariateTheme", null), sr = vE = u([E("geoscene.renderers.support.AuthoringInfo")], sr);
const VO = sr, MS = new et({ simple: "simple", uniqueValue: "unique-value", classBreaks: "class-breaks", heatmap: "heatmap", dotDensity: "dot-density", dictionary: "dictionary", pieChart: "pie-chart" }, { ignoreUnknown: !0 });
let Km = class extends re {
  constructor(t) {
    super(t), this.authoringInfo = null, this.type = null;
  }
  async getRequiredFields(t) {
    if (!this.collectRequiredFields)
      return [];
    const r = /* @__PURE__ */ new Set();
    return await this.collectRequiredFields(r, t), Array.from(r).sort();
  }
  getSymbol(t, r) {
  }
  async getSymbolAsync(t, r) {
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return JSON.stringify(this);
  }
  getMeshHash() {
    return JSON.stringify(this);
  }
};
u([d({ type: VO, json: { write: !0 } })], Km.prototype, "authoringInfo", void 0), u([d({ type: MS.apiValues, readOnly: !0, json: { type: MS.jsonValues, read: !1, write: { writer: MS.write, ignoreOrigin: !0 } } })], Km.prototype, "type", void 0), Km = u([E("geoscene.renderers.Renderer")], Km);
const fl = Km;
var bE;
let Ym = bE = class extends re {
  constructor(e) {
    super(e), this.color = null, this.ratio = null;
  }
  clone() {
    return new bE({ color: this.color, ratio: this.ratio });
  }
};
u([d({ type: Me, json: { type: [Ot], default: null, write: !0 } })], Ym.prototype, "color", void 0), u([d({ type: Number, json: { write: !0 } })], Ym.prototype, "ratio", void 0), Ym = bE = u([E("geoscene.renderers.support.HeatmapColorStop")], Ym);
const E1 = Ym;
let Hp = class extends Rt(re) {
  constructor() {
    super(...arguments), this.minLabel = null, this.maxLabel = null, this.title = null;
  }
};
u([d({ type: String, json: { write: !0 } })], Hp.prototype, "minLabel", void 0), u([d({ type: String, json: { write: !0 } })], Hp.prototype, "maxLabel", void 0), u([d({ type: String, json: { write: !0 } })], Hp.prototype, "title", void 0), Hp = u([E("geoscene.renderers.support.HeatmapLegendOptions")], Hp);
function j_() {
  return [0, 0, 0, 0];
}
function eme(e) {
  return [e[0], e[1], e[2], e[3]];
}
function wf(e, t, r, n) {
  return [e, t, r, n];
}
function tme(e) {
  const t = j_(), r = Math.min(4, e.length);
  for (let n = 0; n < r; ++n)
    t[n] = e[n];
  return t;
}
function rme(e, t) {
  return new Float64Array(e, t, 4);
}
function lz() {
  return j_();
}
function uz() {
  return wf(1, 1, 1, 1);
}
function cz() {
  return wf(1, 0, 0, 0);
}
function dz() {
  return wf(0, 1, 0, 0);
}
function pz() {
  return wf(0, 0, 1, 0);
}
function hz() {
  return wf(0, 0, 0, 1);
}
const nme = lz(), ime = uz(), sme = cz(), ome = dz(), ame = pz(), lme = hz();
Object.freeze(Object.defineProperty({ __proto__: null, ONES: ime, UNIT_W: lme, UNIT_X: sme, UNIT_Y: ome, UNIT_Z: ame, ZEROS: nme, clone: eme, create: j_, createView: rme, fromArray: tme, fromValues: wf, ones: uz, unitW: hz, unitX: cz, unitY: dz, unitZ: pz, zeros: lz }, Symbol.toStringTag, { value: "Module" }));
const zO = 2.4;
function ume(e) {
  return al(e * zO);
}
function cme(e) {
  return rj(e) / zO;
}
function dme(e, t, r, n) {
  let { color: i, ratio: s } = t, { color: o, ratio: a } = r;
  a === s && (a === 1 ? s -= 1e-6 : a += 1e-6);
  const l = ws((n - s) / (a - s), 0, 1);
  a8(e, i.toArray(), o.toArray(), l);
}
function l5e(e) {
  const r = new Uint8ClampedArray(2048);
  if (e = e.filter(({ ratio: a }) => a >= 0 && a <= 1).sort((a, l) => a.ratio - l.ratio).map(({ color: a, ratio: l }) => ({ color: a, ratio: Math.max(l, 1e-3) })), e.length < 1)
    return r;
  let n = e[0], i = e[0], s = 1;
  const o = j_();
  for (let a = 0; a < 512; a++) {
    const l = (a + 0.5) / 512;
    for (; l > i.ratio && s < e.length; )
      n = i, i = e[s++];
    dme(o, n, i, l), r.set(o, 4 * a);
  }
  return r;
}
function u5e(e, t, r, n) {
  const { radius: i, fieldOffset: s, field: o } = t, a = Math.round(rj(i)), l = new Float64Array(r * n);
  let c, h = Number.NEGATIVE_INFINITY;
  const f = fme(o, s), m = /* @__PURE__ */ new Set();
  for (const y of e) {
    const g = y.getCursor();
    for (; g.next(); ) {
      const v = g.getObjectId();
      if (m.has(v))
        continue;
      m.add(v);
      const b = g.readLegacyPointGeometry(), w = 128;
      if (b.x < -w || b.x >= r + w || b.y < -w || b.y > n + w)
        continue;
      const x = +f(g), $ = Math.max(0, Math.round(b.x) - a), T = Math.max(0, Math.round(b.y) - a), C = Math.min(n, Math.round(b.y) + a), I = Math.min(r, Math.round(b.x) + a);
      for (let O = T; O < C; O++)
        for (let M = $; M < I; M++) {
          const L = O * r + M, N = hme(b.x - M, b.y - O, a);
          c = l[L] += N * x, c > h && (h = c);
        }
    }
  }
  return { matrix: l.buffer, max: h };
}
function c5e(e, t, r, n, i, s) {
  e.canvas.width = e.canvas.height = t, e.clearRect(0, 0, t, t);
  const o = e.getImageData(0, 0, t, t);
  r && n && o.data.set(new Uint8ClampedArray(pme(t, r, n, i, s))), e.putImageData(o, 0, 0);
}
function pme(e, t, r, n, i) {
  const s = new Uint32Array(e * e), o = "buffer" in t ? t : new Float64Array(t), a = "buffer" in r ? new Uint32Array(r.buffer) : new Uint32Array(new Uint8Array(r).buffer), l = a.length / (i - n);
  for (let c = 0; c < o.length; c++) {
    const h = o[c], f = Math.floor((h - n) * l);
    s[c] = a[ws(f, 0, a.length - 1)];
  }
  return s.buffer;
}
function hme(e, t, r) {
  const n = Math.sqrt(e ** 2 + t ** 2) / r;
  return n > 1 ? 0 : 3 / (Math.PI * r ** 2) * (1 - n ** 2) ** 2;
}
function d5e(e, t) {
  return typeof e == "function" ? e : e ? typeof t == "string" ? (r) => -1 * +r[e] : (r) => +r[e] + t : () => 1;
}
function fme(e, t) {
  return e != null ? typeof t == "string" ? (r) => -1 * +r.readAttribute(e) : (r) => +r.readAttribute(e) + t : (r) => 1;
}
var wE;
const fz = "geoscene.renderers.HeatmapRenderer", mme = se.getLogger(fz);
function t4(e) {
  if (e != null) {
    const { maxDensity: t, minDensity: r, radius: n } = e;
    if (t != null || r != null || n != null) {
      const { blurRadius: i, maxPixelIntensity: s, minPixelIntensity: o, ...a } = e;
      return a;
    }
  }
  return e;
}
let Dr = wE = class extends fl {
  constructor(e) {
    super(e), this.authoringInfo = null, this.colorStops = [new E1({ ratio: 0, color: new Me("rgba(255, 140, 0, 0)") }), new E1({ ratio: 0.75, color: new Me("rgba(255, 140, 0, 1)") }), new E1({ ratio: 0.9, color: new Me("rgba(255, 0,   0, 1)") })], this.field = null, this.fieldOffset = 0, this.legendOptions = null, this.maxDensity = 0.04, this.minDensity = 0, this.radius = 18, this.referenceScale = 0, this.type = "heatmap", this.valueExpression = null, this.valueExpressionTitle = null, this._warnedProps = { blurRadius: !1, maxPixelIntensity: !1, minPixelIntensity: !1 };
  }
  normalizeCtorArgs(e) {
    return t4(e);
  }
  get blurRadius() {
    return cme(this.radius);
  }
  set blurRadius(e) {
    const t = this.maxPixelIntensity, r = this.minPixelIntensity;
    this._set("radius", ume(e)), this._warnAboutDeprecatedGaussianBlurProp("blurRadius", "radius"), this._set("maxDensity", t * this._pixelIntensityToDensity), this._set("minDensity", r * this._pixelIntensityToDensity);
  }
  get maxPixelIntensity() {
    return this.maxDensity / this._pixelIntensityToDensity;
  }
  set maxPixelIntensity(e) {
    this._set("maxDensity", e * this._pixelIntensityToDensity), this._warnAboutDeprecatedGaussianBlurProp("maxPixelIntensity", "maxDensity");
  }
  get minPixelIntensity() {
    return this.minDensity / this._pixelIntensityToDensity;
  }
  set minPixelIntensity(e) {
    this._set("minDensity", e * this._pixelIntensityToDensity), this._warnAboutDeprecatedGaussianBlurProp("minPixelIntensity", "minDensity");
  }
  get _pixelIntensityToDensity() {
    return 24 / (zO ** 2 * this.blurRadius ** 4);
  }
  _warnAboutDeprecatedGaussianBlurProp(e, t) {
    this._warnedProps[e] || Bn(this).getDefaultOrigin() === "user" && (this._warnedProps[e] = !0, nf(() => {
      V$(mme, e, { replacement: `${String(t)} (suggested value: ${this._get(t)})`, version: "4.24" });
    }));
  }
  read(e, t) {
    e = t4(e), super.read(e, t);
  }
  getSymbol() {
    return new Hu();
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  async collectRequiredFields(e, t) {
    const r = this.field, n = this.valueExpression;
    r && typeof r == "string" && await Pi(e, t, r), n && typeof n == "string" && await qn(e, t, n);
  }
  getAttributeHash() {
    return null;
  }
  getMeshHash() {
    return `${JSON.stringify(this.colorStops)}.${this.blurRadius}.${this.field}`;
  }
  clone() {
    return new wE({ authoringInfo: this.authoringInfo && this.authoringInfo.clone(), colorStops: j(this.colorStops), field: this.field, legendOptions: j(this.legendOptions), maxDensity: this.maxDensity, minDensity: this.minDensity, radius: this.radius, referenceScale: this.referenceScale, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
u([d({ type: VO, json: { write: !0, origins: { "web-scene": { write: !1, read: !1 } } } })], Dr.prototype, "authoringInfo", void 0), u([d({ type: Number, json: { origins: { "portal-item": { write: !0 }, "web-map": { write: !0 } } } })], Dr.prototype, "blurRadius", null), u([d({ type: [E1], json: { write: !0 } })], Dr.prototype, "colorStops", void 0), u([d({ type: String, json: { write: !0 } })], Dr.prototype, "field", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e, t, r) => ({ enabled: r == null }) }, origins: { "web-scene": { write: !1 } } } })], Dr.prototype, "fieldOffset", void 0), u([d({ type: Hp, json: { write: !0 } })], Dr.prototype, "legendOptions", void 0), u([d({ type: Number, json: { write: !0 } })], Dr.prototype, "maxDensity", void 0), u([d({ type: Number, json: { origins: { "portal-item": { write: !0 }, "web-map": { write: !0 } } } })], Dr.prototype, "maxPixelIntensity", null), u([d({ type: Number, json: { write: !0 } })], Dr.prototype, "minDensity", void 0), u([d({ type: Number, json: { origins: { "portal-item": { write: !0 }, "web-map": { write: !0 } } } })], Dr.prototype, "minPixelIntensity", null), u([d({ type: Number, cast: ut, json: { write: !0 } })], Dr.prototype, "radius", void 0), u([d({ type: Number, range: { min: 0 }, json: { default: 0, write: !0 } })], Dr.prototype, "referenceScale", void 0), u([Ie({ heatmap: "heatmap" })], Dr.prototype, "type", void 0), u([d({ type: String, json: { write: !0, origins: { "web-document": { write: !1 }, "portal-item": { write: !1 } } } })], Dr.prototype, "valueExpression", void 0), u([d({ type: String })], Dr.prototype, "valueExpressionTitle", void 0), u([d({ readOnly: !0 })], Dr.prototype, "_pixelIntensityToDensity", null), Dr = wE = u([E(fz)], Dr);
const UO = Dr;
function yme(e) {
  var t, r;
  return ((r = (t = e.match(gme)) == null ? void 0 : t[1]) == null ? void 0 : r.replace(/\\'/g, "'")) ?? null;
}
const gme = /^hash\(\$feature\['((\\'|[^'])+)'\]\) \* 8\.381e-8$/;
var _E;
let xh = _E = class extends re {
  constructor() {
    super(...arguments), this.title = null;
  }
  clone() {
    return new _E({ title: this.title });
  }
};
u([d({ type: String, json: { write: !0 } })], xh.prototype, "title", void 0), xh = _E = u([E("geoscene.renderers.support.LegendOptions")], xh);
var SE;
let I1 = SE = class extends xh {
  constructor() {
    super(...arguments), this.showLegend = null;
  }
  clone() {
    return new SE({ title: this.title, showLegend: this.showLegend });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], I1.prototype, "showLegend", void 0), I1 = SE = u([E("geoscene.renderers.visualVariables.support.VisualVariableLegendOptions")], I1);
const mz = I1, OS = new et({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" });
let Hs = class extends re {
  constructor(t) {
    super(t), this.index = null, this.type = null, this.field = null, this.valueExpression = null, this.valueExpressionTitle = null, this.legendOptions = null;
  }
  castField(t) {
    return t == null ? t : typeof t == "function" ? (se.getLogger(this).error(".field: field must be a string value"), null) : Rg(t);
  }
  get arcadeRequired() {
    return !!this.valueExpression;
  }
  clone() {
  }
  getAttributeHash() {
    return `${this.type}-${this.field}-${this.valueExpression}`;
  }
};
u([d()], Hs.prototype, "index", void 0), u([d({ type: OS.apiValues, readOnly: !0, json: { read: OS.read, write: OS.write } })], Hs.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Hs.prototype, "field", void 0), u([xt("field")], Hs.prototype, "castField", null), u([d({ type: String, json: { write: !0 } })], Hs.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], Hs.prototype, "valueExpressionTitle", void 0), u([d({ readOnly: !0 })], Hs.prototype, "arcadeRequired", null), u([d({ type: mz, json: { write: !0 } })], Hs.prototype, "legendOptions", void 0), Hs = u([E("geoscene.renderers.visualVariables.VisualVariable")], Hs);
const n0 = Hs;
var $E;
let Rc = $E = class extends re {
  constructor(e) {
    super(e), this.color = null, this.label = null, this.value = null;
  }
  writeValue(e, t, r) {
    t[r] = e ?? 0;
  }
  clone() {
    return new $E({ color: this.color && this.color.clone(), label: this.label, value: this.value });
  }
};
u([d({ type: Me, json: { type: [Ot], write: !0 } })], Rc.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], Rc.prototype, "label", void 0), u([d({ type: Number, json: { write: { writerEnsuresNonNull: !0 } } })], Rc.prototype, "value", void 0), u([ge("value")], Rc.prototype, "writeValue", null), Rc = $E = u([E("geoscene.renderers.visualVariables.support.ColorStop")], Rc);
const vme = Rc;
var xE;
let Lc = xE = class extends n0 {
  constructor(e) {
    super(e), this.type = "color", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(e) {
    e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, r) => t.value - r.value), this._set("stops", e);
  }
  clone() {
    return new xE({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((e) => e.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], Lc.prototype, "cache", null), u([d({ type: ["color"], json: { type: ["colorInfo"] } })], Lc.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Lc.prototype, "normalizationField", void 0), u([d({ type: [vme], json: { write: !0 } })], Lc.prototype, "stops", null), Lc = xE = u([E("geoscene.renderers.visualVariables.ColorVariable")], Lc);
const yz = Lc;
var TE;
let tu = TE = class extends re {
  constructor(e) {
    super(e), this.label = null, this.opacity = null, this.value = null;
  }
  readOpacity(e, t) {
    return Zy(t.transparency);
  }
  writeOpacity(e, t, r) {
    t[r] = u_(e);
  }
  clone() {
    return new TE({ label: this.label, opacity: this.opacity, value: this.value });
  }
};
u([d({ type: String, json: { write: !0 } })], tu.prototype, "label", void 0), u([d({ type: Number, json: { type: Ot, write: { target: "transparency" } } })], tu.prototype, "opacity", void 0), u([ce("opacity", ["transparency"])], tu.prototype, "readOpacity", null), u([ge("opacity")], tu.prototype, "writeOpacity", null), u([d({ type: Number, json: { write: !0 } })], tu.prototype, "value", void 0), tu = TE = u([E("geoscene.renderers.visualVariables.support.OpacityStop")], tu);
const bme = tu;
var EE;
let Nc = EE = class extends n0 {
  constructor(e) {
    super(e), this.type = "opacity", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(e) {
    e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, r) => t.value - r.value), this._set("stops", e);
  }
  clone() {
    return new EE({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((e) => e.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], Nc.prototype, "cache", null), u([d({ type: ["opacity"], json: { type: ["transparencyInfo"] } })], Nc.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Nc.prototype, "normalizationField", void 0), u([d({ type: [bme], json: { write: !0 } })], Nc.prototype, "stops", null), Nc = EE = u([E("geoscene.renderers.visualVariables.OpacityVariable")], Nc);
const gz = Nc;
var IE;
let La = IE = class extends n0 {
  constructor(e) {
    super(e), this.axis = null, this.type = "rotation", this.rotationType = "geographic", this.valueExpressionTitle = null;
  }
  get cache() {
    return { hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  writeValueExpressionTitleWebScene(e, t, r, n) {
    if (n && n.messages) {
      const i = `visualVariables[${this.index}]`;
      n.messages.push(new G("property:unsupported", this.type + "VisualVariable.valueExpressionTitle is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: i + ".valueExpressionTitle", context: n }));
    }
  }
  clone() {
    return new IE({ axis: this.axis, rotationType: this.rotationType, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
};
u([d({ readOnly: !0 })], La.prototype, "cache", null), u([d({ type: ["heading", "tilt", "roll"], json: { origins: { "web-scene": { default: "heading", write: !0 } } } })], La.prototype, "axis", void 0), u([d({ type: ["rotation"], json: { type: ["rotationInfo"] } })], La.prototype, "type", void 0), u([d({ type: ["geographic", "arithmetic"], json: { write: !0, origins: { "web-document": { write: !0, default: "geographic" } } } })], La.prototype, "rotationType", void 0), u([d({ type: String, json: { write: !0 } })], La.prototype, "valueExpressionTitle", void 0), u([ge("web-scene", "valueExpressionTitle")], La.prototype, "writeValueExpressionTitleWebScene", null), La = IE = u([E("geoscene.renderers.visualVariables.RotationVariable")], La);
const vz = La;
var ME;
let Wp = ME = class extends re {
  constructor(e) {
    super(e), this.label = null, this.size = null, this.value = null;
  }
  clone() {
    return new ME({ label: this.label, size: this.size, value: this.value });
  }
};
u([d({ type: String, json: { write: !0 } })], Wp.prototype, "label", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Wp.prototype, "size", void 0), u([d({ type: Number, json: { write: !0 } })], Wp.prototype, "value", void 0), Wp = ME = u([E("geoscene.renderers.visualVariables.support.SizeStop")], Wp);
const Jp = Wp;
var OE;
let M1 = OE = class extends mz {
  constructor() {
    super(...arguments), this.customValues = null;
  }
  clone() {
    return new OE({ title: this.title, showLegend: this.showLegend, customValues: this.customValues && this.customValues.slice(0) });
  }
};
u([d({ type: [Number], json: { write: !0 } })], M1.prototype, "customValues", void 0), M1 = OE = u([E("geoscene.renderers.visualVariables.support.SizeVariableLegendOptions")], M1);
const wme = M1;
var tl, Vr;
function $u(e) {
  return e && e.declaredClass === "geoscene.renderers.visualVariables.SizeVariable";
}
function mg(e) {
  return e != null && !isNaN(e) && isFinite(e);
}
function bz(e) {
  return e.valueExpression ? tl.Expression : e.field && typeof e.field == "string" ? tl.Field : tl.Unknown;
}
function _me(e, t) {
  const r = t || bz(e), n = e.valueUnit || "unknown";
  return r === tl.Unknown ? Vr.Constant : e.stops ? Vr.Stops : e.minSize != null && e.maxSize != null && e.minDataValue != null && e.maxDataValue != null ? Vr.ClampedLinear : n === "unknown" ? e.minSize != null && e.minDataValue != null ? e.minSize && e.minDataValue ? Vr.Proportional : Vr.Additive : Vr.Identity : Vr.RealWorldSize;
}
(function(e) {
  e.Unknown = "unknown", e.Expression = "expression", e.Field = "field";
})(tl || (tl = {})), function(e) {
  e.Unknown = "unknown", e.Stops = "stops", e.ClampedLinear = "clamped-linear", e.Proportional = "proportional", e.Additive = "additive", e.Constant = "constant", e.Identity = "identity", e.RealWorldSize = "real-world-size";
}(Vr || (Vr = {}));
const Lu = se.getLogger("geoscene.renderers.visualVariables.support.visualVariableUtils");
new vr();
const O1 = Math.PI, wz = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function Sme(e, t, r) {
  const n = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((g) => g.type === "color") : e;
  if (!n)
    return;
  if (n.declaredClass !== "geoscene.renderers.visualVariables.ColorVariable")
    return void Lu.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.ColorVariable");
  const i = typeof t == "number", s = i ? null : t, o = s && s.attributes;
  let a = i ? t : null;
  const l = n.field, { ipData: c, hasExpression: h } = n.cache;
  let f = n.cache.compiledFunc;
  if (!l && !h) {
    const g = n.stops;
    return g && g[0] && g[0].color;
  }
  if (typeof a != "number")
    if (h) {
      if (r == null || r.arcade == null)
        return void Lu.error("Use of arcade expressions requires an arcade context");
      const g = { viewingMode: r.viewingMode, scale: r.scale, spatialReference: r.spatialReference }, v = r.arcade.arcadeUtils, b = v.getViewInfo(g), w = v.createExecContext(s, b);
      if (!f) {
        const x = v.createSyntaxTree(n.valueExpression);
        f = v.createFunction(x), n.cache.compiledFunc = f;
      }
      a = v.executeFunction(f, w);
    } else
      o && (a = o[l]);
  const m = n.normalizationField, y = o != null && m != null ? parseFloat(o[m]) : void 0;
  if (a != null && (!m || i || !isNaN(y) && y !== 0)) {
    isNaN(y) || i || (a /= y);
    const g = qO(a, c);
    if (g) {
      const v = g[0], b = g[1], w = v === b ? n.stops[v].color : Me.blendColors(n.stops[v].color, n.stops[b].color, g[2], r != null ? r.color : void 0);
      return new Me(w);
    }
  }
}
function $me(e, t, r) {
  const n = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((g) => g.type === "opacity") : e;
  if (!n)
    return;
  if (n.declaredClass !== "geoscene.renderers.visualVariables.OpacityVariable")
    return void Lu.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.OpacityVariable");
  const i = typeof t == "number", s = i ? null : t, o = s && s.attributes;
  let a = i ? t : null;
  const l = n.field, { ipData: c, hasExpression: h } = n.cache;
  let f = n.cache.compiledFunc;
  if (!l && !h) {
    const g = n.stops;
    return g && g[0] && g[0].opacity;
  }
  if (typeof a != "number")
    if (h) {
      if (r == null || r.arcade == null)
        return void Lu.error("Use of arcade expressions requires an arcade context");
      const g = { viewingMode: r.viewingMode, scale: r.scale, spatialReference: r.spatialReference }, v = r.arcade.arcadeUtils, b = v.getViewInfo(g), w = v.createExecContext(s, b);
      if (!f) {
        const x = v.createSyntaxTree(n.valueExpression);
        f = v.createFunction(x), n.cache.compiledFunc = f;
      }
      a = v.executeFunction(f, w);
    } else
      o && (a = o[l]);
  const m = n.normalizationField, y = o != null && m != null ? parseFloat(o[m]) : void 0;
  if (a != null && (!m || i || !isNaN(y) && y !== 0)) {
    isNaN(y) || i || (a /= y);
    const g = qO(a, c);
    if (g) {
      const v = g[0], b = g[1];
      if (v === b)
        return n.stops[v].opacity;
      {
        const w = n.stops[v].opacity;
        return w + (n.stops[b].opacity - w) * g[2];
      }
    }
  }
}
function xme(e, t, r) {
  const n = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((y) => y.type === "rotation") : e;
  if (!n)
    return;
  if (n.declaredClass !== "geoscene.renderers.visualVariables.RotationVariable")
    return void Lu.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.RotationVariable");
  const i = n.axis || "heading", s = i === "heading" && n.rotationType === "arithmetic" ? 90 : 0, o = i === "heading" && n.rotationType === "arithmetic" ? -1 : 1, a = typeof t == "number" ? null : t, l = a && a.attributes, c = n.field, { hasExpression: h } = n.cache;
  let f = n.cache.compiledFunc, m = 0;
  if (!c && !h)
    return m;
  if (h) {
    if (r == null || r.arcade == null)
      return void Lu.error("Use of arcade expressions requires an arcade context");
    const y = { viewingMode: r.viewingMode, scale: r.scale, spatialReference: r.spatialReference }, g = r.arcade.arcadeUtils, v = g.getViewInfo(y), b = g.createExecContext(a, v);
    if (!f) {
      const w = g.createSyntaxTree(n.valueExpression);
      f = g.createFunction(w), n.cache.compiledFunc = f;
    }
    m = g.executeFunction(f, b);
  } else
    l && (m = l[c] || 0);
  return m = typeof m != "number" || isNaN(m) ? null : s + o * m, m;
}
function Tme(e, t, r) {
  const n = typeof t == "number", i = n ? null : t, s = i && i.attributes;
  let o = n ? t : null;
  const { isScaleDriven: a } = e.cache;
  let l = e.cache.compiledFunc;
  if (a) {
    const h = r != null ? r.scale : void 0, f = r != null ? r.view : void 0;
    o = h == null || f === "3d" ? Eme(e) : h;
  } else if (!n)
    switch (e.inputValueType) {
      case tl.Expression: {
        if (r == null || r.arcade == null)
          return void Lu.error("Use of arcade expressions requires an arcade context");
        const h = { viewingMode: r.viewingMode, scale: r.scale, spatialReference: r.spatialReference }, f = r.arcade.arcadeUtils, m = f.getViewInfo(h), y = f.createExecContext(i, m);
        if (!l) {
          const g = f.createSyntaxTree(e.valueExpression);
          l = f.createFunction(g), e.cache.compiledFunc = l;
        }
        o = f.executeFunction(l, y);
        break;
      }
      case tl.Field:
        s && (o = s[e.field]);
        break;
      case tl.Unknown:
        o = null;
    }
  if (!mg(o))
    return null;
  if (n || !e.normalizationField)
    return o;
  const c = s ? parseFloat(s[e.normalizationField]) : null;
  return mg(c) && c !== 0 ? o / c : null;
}
function Eme(e) {
  let t = null, r = null;
  const n = e.stops;
  return n ? (t = n[0].value, r = n[n.length - 1].value) : (t = e.minDataValue || 0, r = e.maxDataValue || 0), (t + r) / 2;
}
function BO(e, t, r) {
  const n = "visualVariables" in e && e.visualVariables ? e.visualVariables.find((s) => s.type === "size") : e;
  if (!n)
    return;
  if (n.declaredClass !== "geoscene.renderers.visualVariables.SizeVariable")
    return void Lu.warn("The visualVariable should be an instance of geoscene.renderers.visualVariables.SizeVariable");
  const i = Sz(Tme(n, t, r), n, t, r, n.cache.ipData);
  return i == null || isNaN(i) ? 0 : i;
}
function ys(e, t, r) {
  return e == null ? null : $u(e) ? BO(e, t, r) : mg(e) ? e : null;
}
function _z(e, t, r) {
  return mg(r) && e > r ? r : mg(t) && e < t ? t : e;
}
function Ime(e, t, r, n) {
  return e + ((ys(t.minSize, r, n) || t.minDataValue) ?? 0);
}
function Mme(e, t, r) {
  const n = e.stops;
  let i = n && n.length && n[0].size;
  return i == null && (i = e.minSize), ys(i, t, r);
}
function Ome(e, t, r, n) {
  const i = (e - t.minDataValue) / (t.maxDataValue - t.minDataValue), s = ys(t.minSize, r, n), o = ys(t.maxSize, r, n), a = n != null ? n.shape : void 0;
  if (e <= t.minDataValue)
    return s;
  if (e >= t.maxDataValue)
    return o;
  if (s == null || o == null)
    return null;
  if (t.scaleBy === "area" && a) {
    const l = a === "circle", c = l ? O1 * (s / 2) ** 2 : s * s, h = c + i * ((l ? O1 * (o / 2) ** 2 : o * o) - c);
    return l ? 2 * Math.sqrt(h / O1) : Math.sqrt(h);
  }
  return s + i * (o - s);
}
function Cme(e, t, r, n) {
  const i = n != null ? n.shape : void 0, s = e / t.minDataValue, o = ys(t.minSize, r, n), a = ys(t.maxSize, r, n);
  let l = null;
  return l = i === "circle" ? 2 * Math.sqrt(s * (o / 2) ** 2) : i === "square" || i === "diamond" || i === "image" ? Math.sqrt(s * o ** 2) : s * o, _z(l, o, a);
}
function kme(e, t, r, n, i) {
  var l, c, h;
  const [s, o, a] = qO(e, i);
  if (s === o)
    return ys((l = t.stops) == null ? void 0 : l[s].size, r, n);
  {
    const f = ys((c = t.stops) == null ? void 0 : c[s].size, r, n);
    return f + (ys((h = t.stops) == null ? void 0 : h[o].size, r, n) - f) * a;
  }
}
function Ame(e, t, r, n) {
  const i = (n != null && n.resolution ? n.resolution : 1) * FO[t.valueUnit], s = ys(t.minSize, r, n), o = ys(t.maxSize, r, n), { valueRepresentation: a } = t;
  let l = null;
  return l = a === "area" ? 2 * Math.sqrt(e / O1) / i : a === "radius" || a === "distance" ? 2 * e / i : e / i, _z(l, s, o);
}
function Sz(e, t, r, n, i) {
  switch (t.transformationType) {
    case Vr.Additive:
      return Ime(e, t, r, n);
    case Vr.Constant:
      return Mme(t, r, n);
    case Vr.ClampedLinear:
      return Ome(e, t, r, n);
    case Vr.Proportional:
      return Cme(e, t, r, n);
    case Vr.Stops:
      return kme(e, t, r, n, i);
    case Vr.RealWorldSize:
      return Ame(e, t, r, n);
    case Vr.Identity:
      return e;
    case Vr.Unknown:
      return null;
  }
}
function qO(e, t) {
  if (!t)
    return;
  let r = 0, n = t.length - 1;
  return t.some((i, s) => e < i ? (n = s, !0) : (r = s, !1)), [r, n, (e - t[r]) / (t[n] - t[r])];
}
function Pme(e, t, r) {
  const n = ["proportional", "proportional", "proportional"];
  for (const i of e) {
    const s = i.useSymbolValue ? "symbol-value" : BO(i, t, r);
    switch (i.axis) {
      case "width":
        n[0] = s;
        break;
      case "depth":
        n[1] = s;
        break;
      case "height":
        n[2] = s;
        break;
      case "width-and-depth":
        n[0] = s, n[1] = s;
        break;
      case "all":
      case void 0:
      case null:
        n[0] = s, n[1] = s, n[2] = s;
        break;
      default:
        i.axis;
    }
  }
  return n;
}
const h5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAllSizes: Pme,
  getColor: Sme,
  getOpacity: $me,
  getRotationAngle: xme,
  getSize: BO,
  getSizeForValue: Sz,
  getSizeFromNumberOrVariable: ys,
  viewScaleRE: wz
}, Symbol.toStringTag, { value: "Module" }));
var CE;
const uv = new et({ width: "width", depth: "depth", height: "height", widthAndDepth: "width-and-depth", all: "all" }), kE = new et({ unknown: "unknown", inch: "inches", foot: "feet", yard: "yards", mile: "miles", "nautical-mile": "nautical-miles", millimeter: "millimeters", centimeter: "centimeters", decimeter: "decimeters", meter: "meters", kilometer: "kilometers", "decimal-degree": "decimal-degrees" });
function r4(e) {
  if (e != null)
    return typeof e == "string" || typeof e == "number" ? ut(e) : e.type === "size" ? $u(e) ? e : (delete (e = { ...e }).type, new mt(e)) : void 0;
}
function n4(e, t, r) {
  if (typeof e != "object")
    return e;
  const n = new mt();
  return n.read(e, r), n;
}
let mt = CE = class extends n0 {
  constructor(e) {
    super(e), this.axis = null, this.legendOptions = null, this.normalizationField = null, this.scaleBy = null, this.target = null, this.type = "size", this.useSymbolValue = null, this.valueExpression = null, this.valueRepresentation = null, this.valueUnit = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null, isScaleDriven: this.valueExpression != null && wz.test(this.valueExpression) };
  }
  set expression(e) {
    se.getLogger(this).warn("'expression' is deprecated since version 4.2. Use 'valueExpression' instead. The only supported expression is 'view.scale'."), e === "view.scale" ? (this.valueExpression = "$view.scale", this._set("expression", e)) : this._set("expression", null);
  }
  set index(e) {
    $u(this.maxSize) && (this.maxSize.index = `visualVariables[${e}].maxSize`), $u(this.minSize) && (this.minSize.index = `visualVariables[${e}].minSize`), this._set("index", e);
  }
  get inputValueType() {
    return bz(this);
  }
  set maxDataValue(e) {
    e && this.stops && (se.getLogger(this).warn("cannot set maxDataValue when stops is not null."), e = null), this._set("maxDataValue", e);
  }
  set maxSize(e) {
    e && this.stops && (se.getLogger(this).warn("cannot set maxSize when stops is not null."), e = null), this._set("maxSize", e);
  }
  castMaxSize(e) {
    return r4(e);
  }
  readMaxSize(e, t, r) {
    return n4(e, t, r);
  }
  set minDataValue(e) {
    e && this.stops && (se.getLogger(this).warn("cannot set minDataValue when stops is not null."), e = null), this._set("minDataValue", e);
  }
  set minSize(e) {
    e && this.stops && (se.getLogger(this).warn("cannot set minSize when stops is not null."), e = null), this._set("minSize", e);
  }
  castMinSize(e) {
    return r4(e);
  }
  readMinSize(e, t, r) {
    return n4(e, t, r);
  }
  get arcadeRequired() {
    return !!this.valueExpression || this.minSize != null && typeof this.minSize == "object" && this.minSize.arcadeRequired || this.maxSize != null && typeof this.maxSize == "object" && this.maxSize.arcadeRequired;
  }
  set stops(e) {
    this.minDataValue == null && this.maxDataValue == null && this.minSize == null && this.maxSize == null ? e && Array.isArray(e) && (e = e.filter((t) => !!t)).sort((t, r) => t.value - r.value) : e && (se.getLogger(this).warn("cannot set stops when one of minDataValue, maxDataValue, minSize or maxSize is not null."), e = null), this._set("stops", e);
  }
  get transformationType() {
    return _me(this, this.inputValueType);
  }
  readValueExpression(e, t) {
    return e || t.expression && "$view.scale";
  }
  writeValueExpressionWebScene(e, t, r, n) {
    if (e === "$view.scale") {
      if (n && n.messages) {
        const i = this.index, s = typeof i == "string" ? i : `visualVariables[${i}]`;
        n.messages.push(new G("property:unsupported", this.type + "VisualVariable.valueExpression = '$view.scale' is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: s + ".valueExpression", context: n }));
      }
    } else
      t[r] = e;
  }
  readValueUnit(e) {
    return e ? kE.read(e) : null;
  }
  clone() {
    return new CE({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: $u(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: $u(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e) => e.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  flipSizes() {
    if (this.transformationType === Vr.ClampedLinear) {
      const { minSize: e, maxSize: t } = this;
      return this.minSize = t, this.maxSize = e, this;
    }
    if (this.transformationType === Vr.Stops) {
      const e = this.stops;
      if (!e)
        return this;
      const t = e.map((n) => n.size).reverse(), r = e.length;
      for (let n = 0; n < r; n++)
        e[n].size = t[n];
      return this;
    }
    return this;
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.target}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e) => e.value || 0);
  }
};
u([d({ readOnly: !0 })], mt.prototype, "cache", null), u([d({ type: uv.apiValues, json: { type: uv.jsonValues, origins: { "web-map": { read: !1 } }, read: uv.read, write: uv.write } })], mt.prototype, "axis", void 0), u([d({ type: String, value: null, json: { read: !1 } })], mt.prototype, "expression", null), u([d()], mt.prototype, "index", null), u([d({ type: String, readOnly: !0 })], mt.prototype, "inputValueType", null), u([d({ type: wme, json: { write: !0 } })], mt.prototype, "legendOptions", void 0), u([d({ type: Number, value: null, json: { write: !0 } })], mt.prototype, "maxDataValue", null), u([d({ type: Number, value: null, json: { write: !0 } })], mt.prototype, "maxSize", null), u([xt("maxSize")], mt.prototype, "castMaxSize", null), u([ce("maxSize")], mt.prototype, "readMaxSize", null), u([d({ type: Number, value: null, json: { write: !0 } })], mt.prototype, "minDataValue", null), u([d({ type: Number, value: null, json: { write: !0 } })], mt.prototype, "minSize", null), u([xt("minSize")], mt.prototype, "castMinSize", null), u([ce("minSize")], mt.prototype, "readMinSize", null), u([d({ type: String, json: { write: !0 } })], mt.prototype, "normalizationField", void 0), u([d({ readOnly: !0 })], mt.prototype, "arcadeRequired", null), u([d({ type: String })], mt.prototype, "scaleBy", void 0), u([d({ type: [Jp], value: null, json: { write: !0 } })], mt.prototype, "stops", null), u([d({ type: ["outline"], json: { write: !0 } })], mt.prototype, "target", void 0), u([d({ type: String, readOnly: !0 })], mt.prototype, "transformationType", null), u([d({ type: ["size"], json: { type: ["sizeInfo"] } })], mt.prototype, "type", void 0), u([d({ type: Boolean, json: { write: !0, origins: { "web-map": { read: !1 } } } })], mt.prototype, "useSymbolValue", void 0), u([d({ type: String, json: { write: !0 } })], mt.prototype, "valueExpression", void 0), u([ce("valueExpression", ["valueExpression", "expression"])], mt.prototype, "readValueExpression", null), u([ge("web-scene", "valueExpression")], mt.prototype, "writeValueExpressionWebScene", null), u([d({ type: ["radius", "diameter", "area", "width", "distance"], json: { write: !0 } })], mt.prototype, "valueRepresentation", void 0), u([d({ type: kE.apiValues, json: { write: kE.write, origins: { "web-map": { read: !1 }, "web-scene": { write: !0 }, "portal-item": { write: !0 } } } })], mt.prototype, "valueUnit", void 0), u([ce("valueUnit")], mt.prototype, "readValueUnit", null), mt = CE = u([E("geoscene.renderers.visualVariables.SizeVariable")], mt);
const V_ = mt, Rme = { color: yz, size: V_, opacity: gz, rotation: vz }, Lme = new et({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" }), Nme = /^\[([^\]]+)\]$/i;
let C1 = class extends Ae {
  constructor() {
    super(...arguments), this.colorVariables = null, this.opacityVariables = null, this.rotationVariables = null, this.sizeVariables = null;
  }
  set visualVariables(t) {
    if (this._resetVariables(), (t = t && t.filter((r) => !!r)) && t.length) {
      for (const r of t)
        switch (r.type) {
          case "color":
            this.colorVariables.push(r);
            break;
          case "opacity":
            this.opacityVariables.push(r);
            break;
          case "rotation":
            this.rotationVariables.push(r);
            break;
          case "size":
            this.sizeVariables.push(r);
        }
      this.sizeVariables.length && this.sizeVariables.some((r) => !!r.target) && t.sort((r, n) => {
        let i = null;
        return i = r.target === n.target ? 0 : r.target ? 1 : -1, i;
      });
      for (let r = 0; r < t.length; r++)
        t[r].index = r;
      this._set("visualVariables", t);
    } else
      this._set("visualVariables", t);
  }
  readVariables(t, r, n) {
    const { rotationExpression: i, rotationType: s } = r, o = i && i.match(Nme), a = o && o[1];
    if (a && (t || (t = []), t.push({ type: "rotationInfo", rotationType: s, field: a })), t)
      return t.map((l) => {
        const c = Lme.read(l.type), h = Rme[c];
        h || (se.getLogger(this).warn(`Unknown variable type: ${c}`), n && n.messages && n.messages.push(new bs("visual-variable:unsupported", `visualVariable of type '${c}' is not supported`, { definition: l, context: n })));
        const f = new h();
        return f.read(l, n), f;
      });
  }
  writeVariables(t, r) {
    const n = [];
    for (const i of t) {
      const s = i.toJSON(r);
      s && n.push(s);
    }
    return n;
  }
  _resetVariables() {
    this.colorVariables = [], this.opacityVariables = [], this.rotationVariables = [], this.sizeVariables = [];
  }
};
u([d()], C1.prototype, "visualVariables", null), C1 = u([E("geoscene.renderers.visualVariables.VisualVariableFactory")], C1);
const Fme = C1, Dme = { base: n0, key: "type", typeMap: { opacity: gz, color: yz, rotation: vz, size: V_ } }, _f = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this._vvFactory = new Fme();
    }
    set visualVariables(r) {
      this._vvFactory.visualVariables = r, this._set("visualVariables", this._vvFactory.visualVariables);
    }
    readVisualVariables(r, n, i) {
      return this._vvFactory.readVariables(r, n, i);
    }
    writeVisualVariables(r, n, i, s) {
      n[i] = this._vvFactory.writeVariables(r, s);
    }
    get arcadeRequiredForVisualVariables() {
      if (!this.visualVariables)
        return !1;
      for (const r of this.visualVariables)
        if (r.arcadeRequired)
          return !0;
      return !1;
    }
    hasVisualVariables(r, n) {
      return r ? this.getVisualVariablesForType(r, n).length > 0 : this.getVisualVariablesForType("size", n).length > 0 || this.getVisualVariablesForType("color", n).length > 0 || this.getVisualVariablesForType("opacity", n).length > 0 || this.getVisualVariablesForType("rotation", n).length > 0;
    }
    getVisualVariablesForType(r, n) {
      const i = this.visualVariables;
      return i ? i.filter((s) => s.type === r && (typeof n == "string" ? s.target === n : n !== !1 || !s.target)) : [];
    }
    async collectVVRequiredFields(r, n) {
      let i = [];
      this.visualVariables && (i = i.concat(this.visualVariables));
      for (const s of i)
        s && (s.field && Pi(r, n, s.field), s.normalizationField && Pi(r, n, s.normalizationField), s.valueExpression && (jme(s.valueExpression, r, n) || await qn(r, n, s.valueExpression)));
    }
  };
  return u([d({ types: [Dme], value: null, json: { write: !0 } })], t.prototype, "visualVariables", null), u([ce("visualVariables", ["visualVariables", "rotationType", "rotationExpression"])], t.prototype, "readVisualVariables", null), u([ge("visualVariables")], t.prototype, "writeVisualVariables", null), t = u([E("geoscene.renderers.mixins.VisualVariablesMixin")], t), t;
};
function jme(e, t, r) {
  const n = yme(e);
  return n != null && (Pi(t, r, n), !0);
}
const tm = { retainId: !1, ignoreDrivers: !1, hasLabelingContext: !0 };
function Vme(e, t = tm) {
  var a, l;
  if (!e)
    return { symbol: null };
  const { retainId: r = tm.retainId, ignoreDrivers: n = tm.ignoreDrivers, hasLabelingContext: i = tm.hasLabelingContext, retainCIM: s = tm.retainCIM } = t;
  let o = null;
  if (WA(e) || e instanceof tp)
    o = e.clone();
  else if (e.type === "cim") {
    const c = (l = (a = e.data) == null ? void 0 : a.symbol) == null ? void 0 : l.type;
    if (c !== "CIMPointSymbol")
      return { error: new G("symbol-conversion:unsupported-cim-symbol", `CIM symbol of type '${c || "unknown"}' is unsupported in 3D`, { symbol: e }) };
    o = s ? e.clone() : nd.fromCIMSymbol(e);
  } else if (e instanceof ji)
    o = w_.fromSimpleLineSymbol(e);
  else if (e instanceof Hu)
    o = nd.fromSimpleMarkerSymbol(e);
  else if (e instanceof S_)
    o = nd.fromPictureMarkerSymbol(e);
  else if (e instanceof ep)
    o = t.geometryType && t.geometryType === "mesh" ? __.fromSimpleFillSymbol(e) : Hg.fromSimpleFillSymbol(e);
  else {
    if (!(e instanceof mo))
      return { error: new G("symbol-conversion:unsupported-2d-symbol", `2D symbol of type '${e.type || e.declaredClass}' is unsupported in 3D`, { symbol: e }) };
    o = i ? b_.fromTextSymbol(e) : nd.fromTextSymbol(e);
  }
  return r && o && o.type !== "cim" && (o.id = e.id), n && WA(o) && o.symbolLayers.forEach((c) => c.ignoreDrivers = !0), { symbol: o };
}
function mw(e, t, r, n) {
  const i = $z(e, {}, { context: n, isLabelSymbol: !1 });
  i != null && (t[r] = i);
}
function i4(e, t, r, n) {
  const i = $z(e, {}, { context: n, isLabelSymbol: !0 });
  i != null && (t[r] = i);
}
function s4(e) {
  return e instanceof mf || e instanceof tp;
}
function $z(e, t, r) {
  if (e == null)
    return null;
  const { context: n, isLabelSymbol: i } = r, s = n == null ? void 0 : n.origin, o = n == null ? void 0 : n.messages;
  if (s === "web-scene" && !s4(e)) {
    const a = Vme(e, { retainCIM: !0, hasLabelingContext: i });
    return a.symbol != null ? a.symbol.write(t, n) : (o == null || o.push(new G("symbol:unsupported", `Symbols of type '${e.declaredClass}' are not supported in scenes. Use 3D symbology instead when working with WebScene and SceneView`, { symbol: e, context: n, error: a.error })), null);
  }
  return (s === "web-map" || s === "portal-item" && !L6(n == null ? void 0 : n.layer)) && s4(e) ? (o == null || o.push(new G("symbol:unsupported", `Symbols of type '${e.declaredClass}' are not supported in web maps and portal items. Use 2D symbology and CIMSymbol instead when working with MapView`, { symbol: e, context: n })), null) : e.write(t, n);
}
function m5e(e, t) {
  return Qne(e, null, t);
}
const Sf = { types: Lj, json: { write: { writer: mw }, origins: { "web-scene": { types: JA, write: { writer: mw }, read: { reader: sf({ types: JA }) } } } } }, xz = { types: { base: hi, key: "type", typeMap: { "simple-fill": vd.typeMap["simple-fill"], "picture-fill": vd.typeMap["picture-fill"], "polygon-3d": vd.typeMap["polygon-3d"] } }, json: { write: { writer: mw }, origins: { "web-scene": { type: Hg, write: { writer: mw } } } } }, k1 = { cast: (e) => e == null || typeof e == "string" || typeof e == "number" ? e : `${e}`, json: { type: String, write: { writer: (e, t) => {
  t.value = e == null ? void 0 : e.toString();
} } } };
var AE;
let ru = AE = class extends re {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new AE({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const e = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${e}`;
  }
};
u([d({ type: String, json: { write: !0 } })], ru.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], ru.prototype, "label", void 0), u([d({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], ru.prototype, "minValue", void 0), u([d({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], ru.prototype, "maxValue", void 0), u([d(Sf)], ru.prototype, "symbol", void 0), ru = AE = u([E("geoscene.renderers.support.ClassBreakInfo")], ru);
const yw = ru;
var PE;
const Tz = "log", A1 = "percent-of-total", P1 = "field", cv = new et({ esriNormalizeByLog: Tz, esriNormalizeByPercentOfTotal: A1, esriNormalizeByField: P1 }), zme = br(yw);
let Tr = PE = class extends _f(fl) {
  constructor(e) {
    super(e), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = !0, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e, t, r) {
    if (!Array.isArray(e))
      return;
    let n = t.minValue;
    return e.map((i) => {
      const s = new yw();
      return s.read(i, r), s.minValue == null && (s.minValue = n), s.maxValue == null && (s.maxValue = s.minValue), n = s.maxValue, s;
    });
  }
  writeClassBreakInfos(e, t, r, n) {
    const i = e.map((s) => s.write({}, n));
    this._areClassBreaksConsecutive() && i.forEach((s) => delete s.classMinValue), t[r] = i;
  }
  castField(e) {
    return e == null ? e : typeof e == "function" ? (se.getLogger(this).error(".field: field must be a string value"), null) : Rg(e);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e = this._get("normalizationType");
    const t = !!this.normalizationField, r = this.normalizationTotal != null;
    return t || r ? (e = t && P1 || r && A1 || null, t && r && se.getLogger(this).warn("warning: both normalizationField and normalizationTotal are set!")) : e !== P1 && e !== A1 || (e = null), e;
  }
  set normalizationType(e) {
    this._set("normalizationType", e);
  }
  addClassBreakInfo(e, t, r) {
    let n = null;
    n = typeof e == "number" ? new yw({ minValue: e, maxValue: t, symbol: Nj(r) }) : zme(j(e)), this.classBreakInfos.push(n), this.classBreakInfos.length === 1 && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e, t) {
    const r = this.classBreakInfos.length;
    for (let n = 0; n < r; n++) {
      const i = [this.classBreakInfos[n].minValue, this.classBreakInfos[n].maxValue];
      if (i[0] === e && i[1] === t) {
        this.classBreakInfos.splice(n, 1);
        break;
      }
    }
  }
  getBreakIndex(e, t) {
    return !this.valueExpression || t != null && t.arcade != null || se.getLogger(this).warn(""), this.valueExpression ? this._getBreakIndexForExpression(e, t) : this._getBreakIndexForField(e);
  }
  async getClassBreakInfo(e, t) {
    let r = t;
    !this.valueExpression || t != null && t.arcade != null || (r = { ...r, arcade: await Rd() });
    const n = this.getBreakIndex(e, r);
    return n !== -1 ? this.classBreakInfos[n] : null;
  }
  getSymbol(e, t) {
    if (this.valueExpression && (t == null || t.arcade == null))
      return void se.getLogger(this).error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const r = this.getBreakIndex(e, t);
    return r > -1 ? this.classBreakInfos[r].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e, t) {
    let r = t;
    if (this.valueExpression && (t == null || t.arcade == null)) {
      const i = await Rd(), { arcadeUtils: s } = i;
      s.hasGeometryOperations(this.valueExpression) && await s.enableGeometryOperations(), r = { ...r, arcade: i };
    }
    const n = this.getBreakIndex(e, r);
    return n > -1 ? this.classBreakInfos[n].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e = [];
    return this.classBreakInfos.forEach((t) => {
      t.symbol && e.push(t.symbol);
    }), this.defaultSymbol && e.push(this.defaultSymbol), e;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    const e = JSON.stringify(this.backgroundFillSymbol), t = JSON.stringify(this.defaultSymbol), r = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e}.${t}.${this.classBreakInfos.reduce((n, i) => n + i.getMeshHash(), "")}.${r}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    return new PE({ field: this.field, backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(), defaultLabel: this.defaultLabel, defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: j(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: j(this.visualVariables), legendOptions: j(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e, t) {
    const r = [this.collectVVRequiredFields(e, t), this.collectSymbolFields(e, t)];
    await Promise.all(r);
  }
  async collectSymbolFields(e, t) {
    const r = [...this.getSymbols().map((n) => n.collectRequiredFields(e, t)), qn(e, t, this.valueExpression)];
    Pi(e, t, this.field), Pi(e, t, this.normalizationField), await Promise.all(r);
  }
  _getBreakIndexForExpression(e, t) {
    const { viewingMode: r, scale: n, spatialReference: i, arcade: s } = t ?? {}, { valueExpression: o } = this;
    let a = this._compiledValueExpression.valueExpression === o ? this._compiledValueExpression.compiledFunction : null;
    const l = s.arcadeUtils;
    if (!a) {
      const h = l.createSyntaxTree(o);
      a = l.createFunction(h), this._compiledValueExpression.compiledFunction = a;
    }
    this._compiledValueExpression.valueExpression = o;
    const c = l.executeFunction(a, l.createExecContext(e, l.getViewInfo({ viewingMode: r, scale: n, spatialReference: i })));
    return this._getBreakIndexfromInfos(c);
  }
  _getBreakIndexForField(e) {
    const t = this.field, r = e.attributes, n = this.normalizationType;
    let i = parseFloat(r[t]);
    if (n) {
      const s = this.normalizationTotal, o = parseFloat(this.normalizationField ? r[this.normalizationField] : void 0);
      if (n === Tz)
        i = Math.log(i) * Math.LOG10E;
      else if (n !== A1 || s == null || isNaN(s)) {
        if (n === P1 && !isNaN(o)) {
          if (isNaN(i) || isNaN(o))
            return -1;
          i /= o;
        }
      } else
        i = i / s * 100;
    }
    return this._getBreakIndexfromInfos(i);
  }
  _getBreakIndexfromInfos(e) {
    const t = this.isMaxInclusive;
    if (e != null && typeof e == "number" && !isNaN(e))
      for (let r = 0; r < this.classBreakInfos.length; r++) {
        const n = [this.classBreakInfos[r].minValue, this.classBreakInfos[r].maxValue];
        if (n[0] <= e && (t ? e <= n[1] : e < n[1]))
          return r;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e = this.classBreakInfos, t = e.length;
    for (let r = 1; r < t; r++)
      if (e[r - 1].maxValue !== e[r].minValue)
        return !1;
    return !0;
  }
};
u([d(xz)], Tr.prototype, "backgroundFillSymbol", void 0), u([d({ type: [yw] })], Tr.prototype, "classBreakInfos", void 0), u([ce("classBreakInfos")], Tr.prototype, "readClassBreakInfos", null), u([ge("classBreakInfos")], Tr.prototype, "writeClassBreakInfos", null), u([d({ type: String, json: { write: !0 } })], Tr.prototype, "defaultLabel", void 0), u([d(Sf)], Tr.prototype, "defaultSymbol", void 0), u([d({ type: String, json: { write: !0 } })], Tr.prototype, "field", void 0), u([xt("field")], Tr.prototype, "castField", null), u([d({ type: Boolean })], Tr.prototype, "isMaxInclusive", void 0), u([d({ type: xh, json: { write: !0 } })], Tr.prototype, "legendOptions", void 0), u([d({ type: Number, readOnly: !0, value: null, json: { read: !1, write: { overridePolicy() {
  return this.classBreakInfos.length !== 0 && this._areClassBreaksConsecutive() ? { enabled: !0 } : { enabled: !1 };
} } } })], Tr.prototype, "minValue", null), u([d({ type: String, json: { write: !0 } })], Tr.prototype, "normalizationField", void 0), u([d({ type: Number, cast: (e) => ls(e), json: { write: !0 } })], Tr.prototype, "normalizationTotal", void 0), u([d({ type: cv.apiValues, value: null, json: { type: cv.jsonValues, read: cv.read, write: cv.write } })], Tr.prototype, "normalizationType", null), u([Ie({ classBreaks: "class-breaks" })], Tr.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Tr.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], Tr.prototype, "valueExpressionTitle", void 0), Tr = PE = u([E("geoscene.renderers.ClassBreaksRenderer")], Tr);
const Ez = Tr, CS = -3;
var mu;
(function(e) {
  e[e.ALL = 0] = "ALL", e[e.SOME = 1] = "SOME";
})(mu || (mu = {}));
let y5e = class {
  constructor(t, r, n) {
    this.name = t, this._storage = r, this.id = Bme++ + ":", this.size = 0, this.maxSize = 0, this._removeFunc = !1, this._hit = 0, this._miss = 0, this._storage.register(this), n && (this._storage.registerRemoveFunc(this.id, n), this._removeFunc = !0);
  }
  destroy() {
    this._storage.clear(this), this._removeFunc && this._storage.deregisterRemoveFunc(this.id), this._storage.deregister(this), this._storage = null;
  }
  get hitRate() {
    return this._hit / (this._hit + this._miss);
  }
  get sizeAll() {
    return this._storage.size;
  }
  resetHitRate() {
    this._hit = this._miss = 0;
  }
  put(t, r, n, i = 0) {
    this._storage.put(this, t, r, n, i);
  }
  get(t) {
    const r = this._storage.get(this, t);
    return r === void 0 ? ++this._miss : ++this._hit, r;
  }
  pop(t) {
    const r = this._storage.pop(this, t);
    return r === void 0 ? ++this._miss : ++this._hit, r;
  }
  updateSize(t, r, n) {
    this._storage.updateSize(this, t, r, n);
  }
  clear() {
    this._storage.clear(this);
  }
  clearAll() {
    this._storage.clearAll();
  }
  get performanceInfo() {
    return this._storage.performanceInfo;
  }
  resetStats() {
    this._storage.resetStats();
  }
}, Ume = class {
  get size() {
    return this._size;
  }
  constructor(t = 10485760) {
    this._maxSize = t, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._removeFuncs = new md(), this._users = new md();
  }
  destroy() {
    this.clearAll(), this._removeFuncs.clear(), this._users.clear(), this._db = null;
  }
  register(t) {
    this._users.push(t);
  }
  deregister(t) {
    this._users.removeUnordered(t);
  }
  registerRemoveFunc(t, r) {
    this._removeFuncs.push([t, r]);
  }
  deregisterRemoveFunc(t) {
    this._removeFuncs.filterInPlace((r) => r[0] !== t);
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t) {
    this._maxSize = Math.max(t, 0), this._checkSizeLimits();
  }
  put(t, r, n, i, s) {
    r = t.id + r;
    const o = this._db.get(r);
    if (o && (this._size -= o.size, t.size -= o.size, this._db.delete(r), o.entry !== n && this._notifyRemove(r, o.entry, mu.ALL)), i > this._maxSize)
      return void this._notifyRemove(r, n, mu.ALL);
    if (n === void 0)
      return void console.warn("Refusing to cache undefined entry ");
    if (!i || i < 0)
      return void console.warn("Refusing to cache entry with invalid size " + i);
    const a = 1 + Math.max(s, CS) - CS;
    this._db.set(r, { entry: n, size: i, lifetime: a, lives: a }), this._size += i, t.size += i, this._checkSizeLimits();
  }
  updateSize(t, r, n, i) {
    r = t.id + r;
    const s = this._db.get(r);
    if (s && s.entry === n) {
      for (this._size -= s.size, t.size -= s.size; i > this._maxSize; ) {
        const o = this._notifyRemove(r, n, mu.SOME);
        if (!(o != null && o > 0))
          return void this._db.delete(r);
        i = o;
      }
      s.size = i, this._size += i, t.size += i, this._checkSizeLimits();
    }
  }
  pop(t, r) {
    r = t.id + r;
    const n = this._db.get(r);
    if (n)
      return this._size -= n.size, t.size -= n.size, this._db.delete(r), ++this._hit, n.entry;
    ++this._miss;
  }
  get(t, r) {
    r = t.id + r;
    const n = this._db.get(r);
    if (n !== void 0)
      return this._db.delete(r), n.lives = n.lifetime, this._db.set(r, n), ++this._hit, n.entry;
    ++this._miss;
  }
  get performanceInfo() {
    const t = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, r = {}, n = new Array();
    this._db.forEach((o, a) => {
      const l = o.lifetime;
      n[l] = (n[l] || 0) + o.size, this._users.forAll((c) => {
        const { id: h, name: f } = c;
        if (a.startsWith(h)) {
          const m = r[f] || 0;
          r[f] = m + o.size;
        }
      });
    });
    const i = {};
    this._users.forAll((o) => {
      const a = o.name;
      if ("hitRate" in o && typeof o.hitRate == "number" && !isNaN(o.hitRate) && o.hitRate > 0) {
        const l = r[a] || 0;
        r[a] = l, i[a] = Math.round(100 * o.hitRate) + "%";
      } else
        i[a] = "0%";
    });
    const s = Object.keys(r);
    s.sort((o, a) => r[a] - r[o]), s.forEach((o) => t[o] = Math.round(r[o] / 2 ** 20) + "MB / " + i[o]);
    for (let o = n.length - 1; o >= 0; --o) {
      const a = n[o];
      a && (t["Priority " + (o + CS - 1)] = Math.round(a / this._size * 100) + "%");
    }
    return t;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forAll((t) => t.resetHitRate());
  }
  clear(t) {
    const r = t.id;
    this._db.forEach((n, i) => {
      i.startsWith(r) && (this._size -= n.size, this._db.delete(i), this._notifyRemove(i, n.entry, mu.ALL));
    }), t.size = 0;
  }
  clearAll() {
    this._db.forEach((t, r) => this._notifyRemove(r, t.entry, mu.ALL)), this._users.forEach((t) => t.size = 0), this._size = 0, this._db.clear();
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t, r, n) {
    let i;
    return this._removeFuncs.some((s) => {
      if (t.startsWith(s[0])) {
        const o = s[1](r, n);
        return typeof o == "number" && (i = o), !0;
      }
      return !1;
    }), i;
  }
  _checkSizeLimits() {
    if (this._size > this._maxSize) {
      for (const [t, r] of this._db)
        if (this._purgeItem(t, r), this._size <= 0.9 * this.maxSize)
          return;
    }
    this._users.forEach((t) => {
      if (t.maxSize > 0 && t.size > t.maxSize) {
        for (const [r, n] of this._db)
          if (r.startsWith(t.id) && (this._purgeItem(r, n, t), t.size <= 0.9 * t.maxSize))
            return;
      }
    });
  }
  _purgeItem(t, r, n = this._users.find((i) => t.startsWith(i.id))) {
    if (this._db.delete(t), r.lives <= 1) {
      this._size -= r.size, n && (n.size -= r.size);
      const i = this._notifyRemove(t, r.entry, mu.SOME);
      i != null && i > 0 && (this._size += i, n && (n.size += i), r.lives = r.lifetime, r.size = i, this._db.set(t, r));
    } else
      --r.lives, this._db.set(t, r);
  }
}, Bme = 0, qme = class {
  constructor(t, r) {
    this._storage = new Ume(), this.id = "", this.name = "", this.size = 0, this._storage.maxSize = t, this._storage.register(this), r && this._storage.registerRemoveFunc("", r);
  }
  destroy() {
    this._storage.deregister(this), this._storage.destroy();
  }
  put(t, r, n = 1) {
    this._storage.put(this, t, r, n, 1);
  }
  pop(t) {
    return this._storage.pop(this, t);
  }
  get(t) {
    return this._storage.get(this, t);
  }
  clear() {
    this._storage.clearAll();
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  set maxSize(t) {
    this._storage.maxSize = t;
  }
  resetHitRate() {
  }
}, RE = class {
  constructor(t, r, n = "") {
    this.major = t, this.minor = r, this._context = n;
  }
  lessThan(t, r) {
    return this.major < t || t === this.major && this.minor < r;
  }
  since(t, r) {
    return !this.lessThan(t, r);
  }
  validate(t) {
    if (this.major !== t.major) {
      const r = this._context && this._context + ":", n = this._context && this._context + " ";
      throw new G(r + "unsupported-version", `Required major ${n}version is '${this.major}', but got '\${version.major}.\${version.minor}'`, { version: t });
    }
  }
  clone() {
    return new RE(this.major, this.minor, this._context);
  }
  static parse(t, r = "") {
    const [n, i] = t.split("."), s = /^\s*\d+\s*$/;
    if (!n || !n.match || !s.test(n))
      throw new G((r && r + ":") + "invalid-version", "Expected major version to be a number, but got '${version}'", { version: t });
    if (!i || !i.match || !s.test(i))
      throw new G((r && r + ":") + "invalid-version", "Expected minor version to be a number, but got '${version}'", { version: t });
    const o = parseInt(n, 10), a = parseInt(i, 10);
    return new RE(o, a, r);
  }
};
function Gme(e) {
  return e.type === "date" || e.type === "esriFieldTypeDate" || e.type === "date-only" || e.type === "esriFieldTypeDateOnly" || e.type === "timestamp-offset" || e.type === "esriFieldTypeTimestampOffset";
}
function o4(e) {
  return e.type === "oid" || e.type === "esriFieldTypeOID";
}
function a4(e) {
  return e.type === "global-id" || e.type === "esriFieldTypeGlobalID";
}
let Iz = class {
  constructor(t = []) {
    if (this.fields = [], this._fieldsMap = /* @__PURE__ */ new Map(), this._normalizedFieldsMap = /* @__PURE__ */ new Map(), this._dateFieldsSet = /* @__PURE__ */ new Set(), this._numericFieldsSet = /* @__PURE__ */ new Set(), this.dateFields = [], this.numericFields = [], this._requiredFields = null, !t)
      return;
    this.fields = t;
    const r = [];
    for (const n of t) {
      const i = n == null ? void 0 : n.name, s = u4(n == null ? void 0 : n.name);
      if (i && s) {
        const o = l4(i);
        this._fieldsMap.set(i, n), this._fieldsMap.set(o, n), this._normalizedFieldsMap.set(s, n), r.push(o), Gme(n) ? (this.dateFields.push(n), this._dateFieldsSet.add(n)) : G8(n) && (this._numericFieldsSet.add(n), this.numericFields.push(n)), o4(n) || a4(n) || (n.editable = n.editable == null || !!n.editable, n.nullable = n.nullable == null || !!n.nullable);
      }
    }
    r.sort(), this.uid = r.join(",");
  }
  destroy() {
    this._fieldsMap.clear();
  }
  get requiredFields() {
    if (!this._requiredFields) {
      this._requiredFields = [];
      for (const t of this.fields)
        o4(t) || a4(t) || t.nullable || vee(t) !== void 0 || this._requiredFields.push(t);
    }
    return this._requiredFields;
  }
  has(t) {
    return this.get(t) != null;
  }
  get(t) {
    if (!t)
      return;
    let r = this._fieldsMap.get(t);
    return r || (r = this._fieldsMap.get(l4(t)) ?? this._normalizedFieldsMap.get(u4(t)), r && this._fieldsMap.set(t, r), r);
  }
  isDateField(t) {
    return this._dateFieldsSet.has(this.get(t));
  }
  isNumericField(t) {
    return this._numericFieldsSet.has(this.get(t));
  }
  normalizeFieldName(t) {
    const r = this.get(t);
    if (r)
      return r.name ?? void 0;
  }
};
function l4(e) {
  return e.trim().toLowerCase();
}
function u4(e) {
  var t;
  return ((t = ree(e)) == null ? void 0 : t.toLowerCase()) ?? "";
}
const c4 = "geoscene.renderers.support.DictionaryLoader", Hme = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
let GO = class {
  constructor(t, r, n) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new qme(100), this._dictionaryVersion = null, this._fieldIndex = null, this._dictionaryPromise = null, this.url = t, this.config = r, this.fieldMap = n;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t, r) {
    let n;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(r));
    try {
      n = await this._dictionaryPromise;
    } catch (g) {
      if (Fi(g))
        return this._dictionaryPromise = null, null;
    }
    const i = this._dictionaryVersion && this._dictionaryVersion.since(4, 0), s = {};
    if (this.fieldMap)
      for (const g of this._symbolFields) {
        const v = this._getFieldName(this.fieldMap[g]);
        s[g] = v ? i ? t.attributes[v] : "" + t.attributes[v] : "";
      }
    let o = null;
    try {
      o = n == null ? void 0 : n(s, r);
    } catch {
      return null;
    }
    if (!o || typeof o != "string")
      return null;
    const a = j3(o).toString(), l = this._symbolCache.get(a);
    if (l)
      return l.catch(() => {
        this._symbolCache.pop(a);
      }), l;
    const c = o.split(";"), h = [], f = [];
    for (const g of c)
      if (g)
        if (g.includes("po:")) {
          const v = g.substr(3).split("|");
          if (v.length === 3) {
            const b = v[0], w = v[1];
            let x = v[2];
            if (w === "DashTemplate")
              x = x.split(" ").map(($) => Number($));
            else if (w === "Color") {
              const $ = new Me(x).toRgba();
              x = [$[0], $[1], $[2], 255 * $[3]];
            } else
              x = Number(x);
            f.push({ primitiveName: b, propertyName: w, value: x });
          }
        } else if (g.includes("|")) {
          for (const v of g.split("|"))
            if (this._itemNames.has(v)) {
              h.push(v);
              break;
            }
        } else
          this._itemNames.has(g) && h.push(g);
    const m = t.geometry == null || !t.geometry.hasZ && t.geometry.type === "point", y = this._cimPartsToCIMSymbol(h, f, m, r);
    return this._symbolCache.put(a, y, 1), y;
  }
  async fetchResources(t) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void se.getLogger(c4).error("no valid URL!");
    const r = zr(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: t != null ? t.signal : null }), [{ data: n }] = await Promise.all([r, Rd()]);
    if (!n)
      throw this._dictionaryPromise = null, new G("geoscene.renderers.DictionaryRenderer", "Bad dictionary data!");
    const { authoringInfo: i, dictionary_version: s, expression: o, itemsNames: a } = n, l = o;
    let c = !1;
    s && (this._dictionaryVersion = RE.parse(s), c = this._dictionaryVersion.since(4, 0)), this._refSymbolUrlTemplate = this.url + "/" + n.cimRefTemplateUrl, this._itemNames = new Set(a), this._symbolFields = i.symbol;
    const h = {};
    if (this.config) {
      const y = this.config;
      for (const g in y)
        h[g] = y[g];
    }
    if (i.configuration)
      for (const y of i.configuration)
        h.hasOwnProperty(y.name) || (h[y.name] = y.value);
    const f = [];
    if (t != null && t.fields && this.fieldMap)
      for (const y of this._symbolFields) {
        const g = this.fieldMap[y], v = t.fields.filter((b) => b.name.toLowerCase() === (g == null ? void 0 : g.toLowerCase()));
        v.length > 0 && f.push({ ...v[0], type: c ? v[0].type : "esriFieldTypeString" });
      }
    f.length > 0 && (this._fieldIndex = new Iz(f));
    const m = XX(l, t != null ? t.spatialReference : null, f, h).then((y) => {
      const g = { scale: 0 };
      return (v, b) => {
        if (y == null)
          return null;
        const w = y.repurposeFeature({ geometry: null, attributes: v });
        return g.scale = b != null ? b.scale ?? void 0 : void 0, y.evaluate({ $feature: w, $view: g }, y.services);
      };
    }).catch((y) => (se.getLogger(c4).error("Creating dictinoary expression failed:", y), null));
    return this._dictionaryPromise = m, m;
  }
  async _cimPartsToCIMSymbol(t, r, n, i) {
    const s = new Array(t.length);
    for (let l = 0; l < t.length; l++)
      s[l] = this._getSymbolPart(t[l], i);
    const o = await Promise.all(s), a = this.fieldMap;
    if (a)
      for (const l of o)
        Mz(l, a);
    return new Ug({ data: this._combineSymbolParts(o, r, n) });
  }
  async _getSymbolPart(t, r) {
    if (this._ongoingRequests.has(t))
      return this._ongoingRequests.get(t).then((s) => s.data);
    const n = this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi, t), i = zr(n, { responseType: "json", query: { f: "json" }, ...r });
    this._ongoingRequests.set(t, i);
    try {
      return (await i).data;
    } catch (s) {
      throw this._ongoingRequests.delete(t), s;
    }
  }
  _combineSymbolParts(t, r, n) {
    if (!t || t.length === 0)
      return null;
    const i = { ...t[0] };
    if (t.length > 1) {
      i.symbolLayers = [];
      for (const s of t) {
        const o = s;
        i.symbolLayers.unshift(...o.symbolLayers);
      }
    }
    return n && (i.callout = Hme), { type: "CIMSymbolReference", symbol: i, primitiveOverrides: r };
  }
  _getFieldName(t) {
    if (this._fieldIndex !== null) {
      const r = this._fieldIndex.get(t);
      return r ? r.name : t;
    }
    return t;
  }
};
function Mz(e, t) {
  if (!e)
    return;
  const r = e.symbolLayers;
  if (!r)
    return;
  let n = r.length;
  for (; n--; ) {
    const i = r[n];
    i && i.enable !== !1 && i.type === "CIMVectorMarker" && Wme(i, t);
  }
}
function Wme(e, t) {
  const r = e.markerGraphics;
  if (r)
    for (const n of r) {
      if (!n)
        continue;
      const i = n.symbol;
      if (i)
        switch (i.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            Mz(i, t);
            break;
          case "CIMTextSymbol":
            i.fieldMap = t;
        }
    }
}
const $5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DictionaryLoader: GO
}, Symbol.toStringTag, { value: "Module" }));
var LE;
let Ws = LE = class extends _f(fl) {
  constructor(e) {
    super(e), this.config = null, this.fieldMap = null, this.scaleExpression = null, this.scaleExpressionTitle = null, this.url = null, this.type = "dictionary";
  }
  get _loader() {
    return new GO(this.url, this.config, this.fieldMap);
  }
  writeData(e, t) {
    e && (t.scalingExpressionInfo = { expression: e, returnType: "number" });
  }
  writeVisualVariables(e, t, r, n) {
    n != null && n.origin || super.writeVisualVariables(e, t, r, n);
  }
  clone() {
    return new LE({ config: j(this.config), scaleExpression: this.scaleExpression, scaleExpressionTitle: this.scaleExpressionTitle, fieldMap: j(this.fieldMap), url: j(this.url), visualVariables: j(this.visualVariables) });
  }
  async getSymbolAsync(e, t) {
    return this._loader.getSymbolAsync(e, t);
  }
  async collectRequiredFields(e, t) {
    await this.collectVVRequiredFields(e, t), this.scaleExpression && await qn(e, t, this.scaleExpression);
    for (const r in this.fieldMap) {
      const n = this.fieldMap[r];
      t.has(n) && e.add(n);
    }
  }
  get arcadeRequired() {
    return !0;
  }
  getSymbol() {
    return null;
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return `${this.url}-${JSON.stringify(this.fieldMap)}`;
  }
  getSymbolFields() {
    return this._loader.getSymbolFields();
  }
};
u([d({ type: GO })], Ws.prototype, "_loader", null), u([d({ type: Object, json: { read: { source: "configuration" }, write: { target: "configuration" } } })], Ws.prototype, "config", void 0), u([d({ type: Object, json: { write: !0 } })], Ws.prototype, "fieldMap", void 0), u([d({ type: String, json: { read: { source: "scalingExpressionInfo.expression" }, write: !0 } })], Ws.prototype, "scaleExpression", void 0), u([ge("scaleExpression")], Ws.prototype, "writeData", null), u([d({ type: String, json: { read: { source: "scalingExpressionInfo.title" }, write: { target: "scalingExpressionInfo.title", overridePolicy(e) {
  return { enabled: !!e && !!this.scaleExpression };
} } } })], Ws.prototype, "scaleExpressionTitle", void 0), u([d({ type: String, json: { write: !0 } })], Ws.prototype, "url", void 0), u([ge("visualVariables")], Ws.prototype, "writeVisualVariables", null), Ws = LE = u([E("geoscene.renderers.DictionaryRenderer")], Ws);
const Jme = Ws;
var NE;
let Na = NE = class extends re {
  constructor(e) {
    super(e), this.color = null, this.field = null, this.label = null, this.valueExpression = null, this.valueExpressionTitle = null;
  }
  castField(e) {
    return e == null ? e : typeof e == "function" ? (se.getLogger(this).error(".field: field must be a string value"), null) : Rg(e);
  }
  getAttributeHash() {
    return `${this.field}-${this.valueExpression}`;
  }
  clone() {
    return new NE({ color: this.color && this.color.clone(), field: this.field, label: this.label, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
u([d({ type: Me, json: { type: [Number], write: !0 } })], Na.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], Na.prototype, "field", void 0), u([xt("field")], Na.prototype, "castField", null), u([d({ type: String, json: { write: !0 } })], Na.prototype, "label", void 0), u([d({ type: String, json: { write: !0 } })], Na.prototype, "valueExpression", void 0), u([d({ type: String, json: { write: !0 } })], Na.prototype, "valueExpressionTitle", void 0), Na = NE = u([E("geoscene.renderers.support.AttributeColorInfo")], Na);
const Oz = Na;
var FE;
let R1 = FE = class extends re {
  constructor() {
    super(...arguments), this.unit = null;
  }
  clone() {
    return new FE({ unit: this.unit });
  }
};
u([d({ type: String, json: { write: !0 } })], R1.prototype, "unit", void 0), R1 = FE = u([E("geoscene.renderers.support.DotDensityLegendOptions")], R1);
const Zme = R1;
var DE;
let ii = DE = class extends _f(fl) {
  constructor(e) {
    super(e), this.attributes = null, this.backgroundColor = new Me([0, 0, 0, 0]), this.dotBlendingEnabled = !0, this.dotShape = "square", this.dotSize = 1, this.legendOptions = null, this.outline = new ji(), this.dotValue = null, this.referenceScale = null, this.seed = 1, this.type = "dot-density";
  }
  calculateDotValue(e) {
    if (this.referenceScale == null)
      return this.dotValue;
    const t = e / this.referenceScale * this.dotValue;
    return t < 1 ? 1 : t;
  }
  getSymbol() {
    return new ep({ outline: this.outline });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  getAttributeHash() {
    var e;
    return ((e = this.attributes) == null ? void 0 : e.reduce((t, r) => t + r.getAttributeHash(), "")) ?? "";
  }
  getMeshHash() {
    return JSON.stringify(this.outline);
  }
  clone() {
    return new DE({ attributes: j(this.attributes), backgroundColor: j(this.backgroundColor), dotBlendingEnabled: j(this.dotBlendingEnabled), dotShape: j(this.dotShape), dotSize: j(this.dotSize), dotValue: j(this.dotValue), legendOptions: j(this.legendOptions), outline: j(this.outline), referenceScale: j(this.referenceScale), visualVariables: j(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  getControllerHash() {
    var t;
    return `${(t = this.attributes) == null ? void 0 : t.map((r) => r.field || r.valueExpression || "")}-${this.outline && JSON.stringify(this.outline.toJSON()) || ""}`;
  }
  async collectRequiredFields(e, t) {
    await this.collectVVRequiredFields(e, t);
    for (const r of this.attributes ?? [])
      r.valueExpression && await qn(e, t, r.valueExpression), r.field && e.add(r.field);
  }
};
u([d({ type: [Oz], json: { write: !0 } })], ii.prototype, "attributes", void 0), u([d({ type: Me, json: { write: !0 } })], ii.prototype, "backgroundColor", void 0), u([d({ type: Boolean, json: { write: !0 } })], ii.prototype, "dotBlendingEnabled", void 0), u([d({ type: String, json: { write: !1 } })], ii.prototype, "dotShape", void 0), u([d({ type: Number, json: { write: !0 } })], ii.prototype, "dotSize", void 0), u([d({ type: Zme, json: { write: !0 } })], ii.prototype, "legendOptions", void 0), u([d({ type: ji, json: { default: null, write: !0 } })], ii.prototype, "outline", void 0), u([d({ type: Number, json: { write: !0 } })], ii.prototype, "dotValue", void 0), u([d({ type: Number, json: { write: !0 } })], ii.prototype, "referenceScale", void 0), u([d({ type: Number, json: { write: !0 } })], ii.prototype, "seed", void 0), u([Ie({ dotDensity: "dot-density" })], ii.prototype, "type", void 0), ii = DE = u([E("geoscene.renderers.DotDensityRenderer")], ii);
const Kme = ii;
let Xc = class extends Rt(re) {
  constructor() {
    super(...arguments), this.color = new Me([0, 0, 0, 0]), this.label = null, this.threshold = 0;
  }
};
u([d({ type: Me, json: { write: !0 } })], Xc.prototype, "color", void 0), u([d({ type: String, json: { write: !0 } })], Xc.prototype, "label", void 0), u([d({ type: Number, range: { min: 0, max: 1 }, json: { write: !0 } })], Xc.prototype, "threshold", void 0), Xc = u([E("geoscene.renderers.support.OthersCategory")], Xc);
let L1 = class extends Rt(re) {
  constructor() {
    super(...arguments), this.title = null;
  }
};
u([d({ type: String, json: { write: !0 } })], L1.prototype, "title", void 0), L1 = u([E("geoscene.renderers.support.PieChartLegendOptions")], L1);
let wi = class extends _f(Rt(fl)) {
  constructor(t) {
    super(t), this.attributes = null, this.backgroundFillSymbol = null, this.defaultColor = new Me([0, 0, 0, 0]), this.defaultLabel = null, this.holePercentage = 0, this.othersCategory = new Xc(), this.legendOptions = null, this.outline = null, this.size = 12, this.type = "pie-chart";
  }
  getSymbol() {
    var t;
    return new Hu({ size: this.size ? this.size / 2 + (((t = this.outline) == null ? void 0 : t.width) || 0) : 0 });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol(), this.backgroundFillSymbol].filter(kh);
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((t, r) => t + r.getAttributeHash(), "");
  }
  getMeshHash() {
    return this.getSymbols().reduce((t, r) => t + JSON.stringify(r), "");
  }
  async collectRequiredFields(t, r) {
    await this.collectVVRequiredFields(t, r);
    for (const n of this.attributes)
      n.valueExpression && await qn(t, r, n.valueExpression), n.field && t.add(n.field);
  }
};
u([d({ type: [Oz], json: { write: !0 } })], wi.prototype, "attributes", void 0), u([d({ type: ep, json: { default: null, write: !0 } })], wi.prototype, "backgroundFillSymbol", void 0), u([d({ type: Me, json: { write: !0 } })], wi.prototype, "defaultColor", void 0), u([d({ type: String, json: { write: !0 } })], wi.prototype, "defaultLabel", void 0), u([d({ type: Number, range: { min: 0, max: 1 }, json: { write: !0 } })], wi.prototype, "holePercentage", void 0), u([d({ type: Xc, json: { write: !0 } })], wi.prototype, "othersCategory", void 0), u([d({ type: L1, json: { write: !0 } })], wi.prototype, "legendOptions", void 0), u([d({ type: ji, json: { default: null, write: !0 } })], wi.prototype, "outline", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], wi.prototype, "size", void 0), u([Ie({ pieChart: "pie-chart" })], wi.prototype, "type", void 0), wi = u([E("geoscene.renderers.PieChartRenderer")], wi);
const Yme = wi;
var jE;
let Fc = jE = class extends _f(fl) {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.symbol = null, this.type = "simple";
  }
  async collectRequiredFields(e, t) {
    await Promise.all([this.collectSymbolFields(e, t), this.collectVVRequiredFields(e, t)]);
  }
  async collectSymbolFields(e, t) {
    await Promise.all(this.getSymbols().map((r) => r.collectRequiredFields(e, t)));
  }
  getSymbol(e, t) {
    return this.symbol;
  }
  async getSymbolAsync(e, t) {
    return this.symbol;
  }
  getSymbols() {
    return this.symbol ? [this.symbol] : [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    return this.getSymbols().reduce((e, t) => e + JSON.stringify(t), "");
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables;
  }
  clone() {
    return new jE({ description: this.description, label: this.label, symbol: this.symbol && this.symbol.clone(), visualVariables: j(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
};
u([d({ type: String, json: { write: !0 } })], Fc.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], Fc.prototype, "label", void 0), u([d(Sf)], Fc.prototype, "symbol", void 0), u([Ie({ simple: "simple" })], Fc.prototype, "type", void 0), Fc = jE = u([E("geoscene.renderers.SimpleRenderer")], Fc);
const z_ = Fc, Qme = ["geoscene.Color", "geoscene.portal.Portal", "geoscene.symbols.support.Symbol3DAnchorPosition2D", "geoscene.symbols.support.Symbol3DAnchorPosition3D"];
function VE(e) {
  return e instanceof Ae;
}
function d4(e) {
  return e instanceof je ? Object.keys(e.items) : VE(e) ? Bn(e).keys() : e ? Object.keys(e) : [];
}
function dv(e, t) {
  return e instanceof je ? e.items[t] : e[t];
}
function Xme(e, t) {
  return !(!Array.isArray(e) || !Array.isArray(t)) && e.length !== t.length;
}
function Iy(e) {
  return e ? e.declaredClass : null;
}
function Cz(e, t) {
  var f;
  const r = e.diff;
  if (r && typeof r == "function")
    return r(e, t);
  const n = d4(e), i = d4(t);
  if (n.length === 0 && i.length === 0)
    return;
  if (!n.length || !i.length || Xme(e, t))
    return { type: "complete", oldValue: e, newValue: t };
  const s = i.filter((m) => !n.includes(m)), o = n.filter((m) => !i.includes(m)), a = n.filter((m) => i.includes(m) && dv(e, m) !== dv(t, m)).concat(s, o).sort(), l = Iy(e);
  if (l && Qme.includes(l) && a.length)
    return { type: "complete", oldValue: e, newValue: t };
  let c;
  const h = VE(e) && VE(t);
  for (const m of a) {
    const y = dv(e, m), g = dv(t, m);
    let v;
    if ((h || typeof y != "function" && typeof g != "function") && y !== g && (y != null || g != null)) {
      if (r && r[m] && typeof r[m] == "function")
        v = (f = r[m]) == null ? void 0 : f.call(r, y, g);
      else if (y instanceof Date && g instanceof Date) {
        if (y.getTime() === g.getTime())
          continue;
        v = { type: "complete", oldValue: y, newValue: g };
      } else
        v = typeof y == "object" && typeof g == "object" && Iy(y) === Iy(g) ? Cz(y, g) : { type: "complete", oldValue: y, newValue: g };
      v != null && (c != null ? c.diff[m] = v : c = { type: "partial", diff: { [m]: v } });
    }
  }
  return c;
}
function eye(e, t) {
  if (e == null)
    return !1;
  const r = t.split(".");
  let n = e;
  for (const i of r) {
    if (n.type === "complete")
      return !0;
    if (n.type !== "partial")
      return !1;
    {
      const s = n.diff[i];
      if (!s)
        return !1;
      n = s;
    }
  }
  return !0;
}
function I5e(e, t) {
  for (const r of t)
    if (eye(e, r))
      return !0;
  return !1;
}
function tye(e, t) {
  if (typeof e != "function" && typeof t != "function" && (e != null || t != null))
    return e == null || t == null || typeof e == "object" && typeof t == "object" && Iy(e) !== Iy(t) ? { type: "complete", oldValue: e, newValue: t } : Cz(e, t);
}
let Zp = class extends Rt(re) {
  constructor(t) {
    super(t), this.value = null, this.value2 = null, this.value3 = null;
  }
};
u([d(k1)], Zp.prototype, "value", void 0), u([d(k1)], Zp.prototype, "value2", void 0), u([d(k1)], Zp.prototype, "value3", void 0), Zp = u([E("geoscene.renderers.support.UniqueValue")], Zp);
const Th = Zp;
let nu = class extends Rt(re) {
  constructor(t) {
    super(t), this.description = null, this.label = null, this.symbol = null, this.values = null;
  }
  castValues(t) {
    if (t == null)
      return null;
    const r = typeof (t = Array.isArray(t) ? t : [t])[0];
    return r === "string" || r === "number" ? t.map((n) => new Th({ value: n })) : r === "object" ? t[0] instanceof Th ? t : t.map((n) => new Th(n)) : null;
  }
};
u([d({ type: String, json: { write: !0 } })], nu.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], nu.prototype, "label", void 0), u([d(Sf)], nu.prototype, "symbol", void 0), u([d({ type: [Th], json: { type: [[String]], read: { reader: (e) => e ? e.map((t) => new Th({ value: t[0], value2: t[1], value3: t[2] })) : null }, write: { writer: (e, t) => {
  const r = [];
  for (const n of e) {
    const i = [n.value, n.value2, n.value3].filter(kh).map((s) => s.toString());
    r.push(i);
  }
  t.values = r;
} } } })], nu.prototype, "values", void 0), u([xt("values")], nu.prototype, "castValues", null), nu = u([E("geoscene.renderers.support.UniqueValueClass")], nu);
const kz = nu;
let Qm = class extends Rt(re) {
  constructor(t) {
    super(t), this.heading = null, this.classes = null;
  }
};
u([d({ type: String, json: { write: !0 } })], Qm.prototype, "heading", void 0), u([d({ type: [kz], json: { write: !0 } })], Qm.prototype, "classes", void 0), Qm = u([E("geoscene.renderers.support.UniqueValueGroup")], Qm);
const zE = Qm;
var UE;
let Dc = UE = class extends re {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.symbol = null, this.value = null;
  }
  clone() {
    return new UE({ value: this.value, description: this.description, label: this.label, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const e = JSON.stringify(this.symbol && this.symbol.toJSON());
    return `${this.value}.${e}`;
  }
};
u([d({ type: String, json: { write: !0 } })], Dc.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], Dc.prototype, "label", void 0), u([d(Sf)], Dc.prototype, "symbol", void 0), u([d(k1)], Dc.prototype, "value", void 0), Dc = UE = u([E("geoscene.renderers.support.UniqueValueInfo")], Dc);
const My = Dc, rye = () => !!U("enable-feature:force-wosr"), nye = () => U.add("enable-feature:direct-3d-object-feature-layer-display", !0, !0, !0), iye = () => U.add("enable-feature:direct-3d-object-feature-layer-display", !1, !0, !0), sye = () => U.add("enable-i3s-patching", !0, !0, !0), oye = () => U.add("enable-i3s-patching", !1, !0, !0), k5e = () => !!U("enable-feature:SceneLayer-editing"), aye = (e = "i3s-patching") => {
  switch (oye(), iye(), U.add("enable-feature:SceneLayer-editing", !0, !0, !0), e) {
    case "feature-layer-view":
      nye();
      break;
    case "i3s-patching":
      sye();
  }
};
aye("i3s-patching");
let kS = {};
async function lye(e, t) {
  try {
    return { data: (await pye(e, t)).data, baseUrl: OZ(e), styleUrl: e };
  } catch (r) {
    return Go(r), null;
  }
}
function uye(e, t, r) {
  const n = t.portal != null ? t.portal : pi.getDefault();
  let i;
  const s = `${n.url} - ${n.user && n.user.username} - ${e}`;
  return kS[s] || (kS[s] = cye(e, n, r).then((o) => (i = o, o.fetchData())).then((o) => ({ data: o, baseUrl: i.itemUrl ?? "", styleName: e }))), kS[s];
}
function cye(e, t, r) {
  return t.load(r).then(() => {
    const n = new Wo({ disableExtraQuery: !0, query: `owner:${p4} AND type:${h4} AND typekeywords:"${e}"` });
    return t.queryItems(n, r);
  }).then(({ results: n }) => {
    var o;
    let i = null;
    const s = e.toLowerCase();
    if (n && Array.isArray(n)) {
      for (const a of n)
        if (((o = a.typeKeywords) == null ? void 0 : o.some((c) => c.toLowerCase() === s)) && a.type === h4 && a.owner === p4) {
          i = a;
          break;
        }
    }
    if (!i)
      throw new G("symbolstyleutils:style-not-found", `The style '${e}' could not be found`, { styleName: e });
    return i.load(r);
  });
}
function dye(e, t, r) {
  return e && e.styleUrl != null ? lye(e.styleUrl, r) : e && e.styleName != null ? uye(e.styleName, t, r) : Promise.reject(new G("symbolstyleutils:style-url-and-name-missing", "Either styleUrl or styleName is required to resolve a style"));
}
function A5e(e) {
  return e === null || e.type === "CIMSymbolReference" ? e : { type: "CIMSymbolReference", symbol: e };
}
function P5e(e, t, r = ["gltf"]) {
  if (t === "cimRef")
    return e.cimRef;
  if (e.formatInfos && !rye())
    for (const n of r) {
      const i = e.formatInfos.find((s) => s.type === n);
      if (i)
        return i.href;
    }
  return e.webRef;
}
function pye(e, t) {
  const r = { responseType: "json", query: { f: "json" }, ...t };
  return zr(ao(e), r);
}
const p4 = "esri_en", h4 = "Style", R5e = "https://links.geoscene.cn/geoscene/sharing/rest/content/items/220936cc6ed342c9937abd8f180e7d1e/resources/styles/cim/{SymbolName}.json?f=json";
var Xm;
const Az = "geoscene.renderers.UniqueValueRenderer", Rl = se.getLogger(Az), f4 = "uvInfos-watcher", m4 = "uvGroups-watcher", hye = ",", fye = br(My);
function mye(e) {
  const { field1: t, field2: r, field3: n, fieldDelimiter: i, uniqueValueInfos: s, valueExpression: o } = e, a = !(!t || !r);
  return [{ classes: (s ?? []).map((l) => {
    var w;
    const { symbol: c, label: h, value: f, description: m } = l, [y, g, v] = a ? ((w = f == null ? void 0 : f.toString()) == null ? void 0 : w.split(i || "")) || [] : [f], b = [];
    return (t || o) && b.push(y), r && b.push(g), n && b.push(v), { symbol: c, label: h, values: [b], description: m };
  }) }];
}
let Wt = Xm = class extends _f(fl) {
  constructor(e) {
    super(e), this._valueInfoMap = {}, this._isDefaultSymbolDerived = !1, this._isInfosSource = null, this.type = "unique-value", this.backgroundFillSymbol = null, this.orderByClassesEnabled = !1, this.valueExpressionTitle = null, this.legendOptions = null, this.defaultLabel = null, this.portal = null, this.styleOrigin = null, this.diff = { uniqueValueInfos(t, r) {
      if (!t && !r)
        return;
      if (!t || !r)
        return { type: "complete", oldValue: t, newValue: r };
      let n = !1;
      const i = { type: "collection", added: [], removed: [], changed: [], unchanged: [] };
      for (let s = 0; s < r.length; s++) {
        const o = t.find((a) => a.value === r[s].value);
        o ? tye(o, r[s]) ? (i.changed.push({ type: "complete", oldValue: o, newValue: r[s] }), n = !0) : i.unchanged.push({ oldValue: o, newValue: r[s] }) : (i.added.push(r[s]), n = !0);
      }
      for (let s = 0; s < t.length; s++)
        r.find((o) => o.value === t[s].value) || (i.removed.push(t[s]), n = !0);
      return n ? i : void 0;
    } }, this._set("uniqueValueInfos", []), this._set("uniqueValueGroups", []);
  }
  get _cache() {
    return { compiledFunc: null };
  }
  set field(e) {
    this._set("field", e), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  castField(e) {
    return e == null || typeof e == "function" ? e : Rg(e);
  }
  writeField(e, t, r, n) {
    typeof e == "string" ? t[r] = e : n && n.messages ? n.messages.push(new G("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : Rl.error(".field: cannot write field to JSON since it's not a string value");
  }
  set field2(e) {
    this._set("field2", e), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  set field3(e) {
    this._set("field3", e), this._updateUniqueValues();
  }
  set valueExpression(e) {
    this._set("valueExpression", e), this._updateUniqueValues();
  }
  set defaultSymbol(e) {
    this._isDefaultSymbolDerived = !1, this._set("defaultSymbol", e);
  }
  set fieldDelimiter(e) {
    this._set("fieldDelimiter", e), this._updateUniqueValues();
  }
  readPortal(e, t, r) {
    return r.portal || pi.getDefault();
  }
  readStyleOrigin(e, t, r) {
    if (t.styleName)
      return Object.freeze({ styleName: t.styleName });
    if (t.styleUrl) {
      const n = hf(t.styleUrl, r);
      return Object.freeze({ styleUrl: n });
    }
  }
  writeStyleOrigin(e, t, r, n) {
    e.styleName ? t.styleName = e.styleName : e.styleUrl && (t.styleUrl = qg(e.styleUrl, n));
  }
  set uniqueValueGroups(e) {
    this.styleOrigin ? Rl.error("#uniqueValueGroups=", "Cannot modify unique value groups of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueGroups", e), this._updateInfosFromGroups(), this._isInfosSource = !1, this._watchUniqueValueGroups());
  }
  set uniqueValueInfos(e) {
    this.styleOrigin ? Rl.error("#uniqueValueInfos=", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", e), this._updateValueInfoMap(), this._updateGroupsFromInfos(), this._isInfosSource = !0, this._watchUniqueValueInfos());
  }
  addUniqueValueInfo(e, t) {
    var n;
    if (this.styleOrigin)
      return void Rl.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    let r;
    r = typeof e == "object" ? fye(e) : new My({ value: e, symbol: Nj(t) }), (n = this.uniqueValueInfos) == null || n.push(r), this._valueInfoMap[r.value] = r, this._updateGroupsFromInfos(), this._isInfosSource = !0, this._watchUniqueValueInfos();
  }
  removeUniqueValueInfo(e) {
    if (this.styleOrigin)
      return void Rl.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    const t = this.uniqueValueInfos;
    if (t) {
      for (let r = 0; r < t.length; r++)
        if (t[r].value === e + "") {
          delete this._valueInfoMap[e], t.splice(r, 1);
          break;
        }
    }
    this._updateGroupsFromInfos(), this._isInfosSource = !0, this._watchUniqueValueInfos();
  }
  async getUniqueValueInfo(e, t) {
    let r = t;
    return !this.valueExpression || t != null && t.arcade != null || (r = { ...r, arcade: await Rd() }), this._getUniqueValueInfo(e, r);
  }
  getSymbol(e, t) {
    if (this.valueExpression && (t == null || t.arcade == null))
      return void Rl.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const r = this._getUniqueValueInfo(e, t);
    return r && r.symbol || this.defaultSymbol;
  }
  async getSymbolAsync(e, t) {
    let r = t;
    if (this.valueExpression && (r == null || r.arcade == null)) {
      const i = await Rd(), { arcadeUtils: s } = i;
      s.hasGeometryOperations(this.valueExpression) && await s.enableGeometryOperations(), r = { ...r, arcade: i };
    }
    const n = this._getUniqueValueInfo(e, r);
    return n && n.symbol || this.defaultSymbol;
  }
  getSymbols() {
    const e = [];
    for (const t of this.uniqueValueInfos ?? [])
      t.symbol && e.push(t.symbol);
    return this.defaultSymbol && e.push(this.defaultSymbol), e;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e, t) => e + t.getAttributeHash(), "");
  }
  getMeshHash() {
    var n;
    const e = JSON.stringify(this.backgroundFillSymbol), t = JSON.stringify(this.defaultSymbol), r = (n = this.uniqueValueInfos) == null ? void 0 : n.reduce((i, s) => i + s.getMeshHash(), "");
    return `${e}.${t}.${r}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`;
  }
  clone() {
    const e = new Xm({ field: this.field, field2: this.field2, field3: this.field3, defaultLabel: this.defaultLabel, defaultSymbol: j(this.defaultSymbol), orderByClassesEnabled: this.orderByClassesEnabled, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, fieldDelimiter: this.fieldDelimiter, visualVariables: j(this.visualVariables), legendOptions: j(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone(), backgroundFillSymbol: j(this.backgroundFillSymbol) });
    this._isDefaultSymbolDerived && (e._isDefaultSymbolDerived = !0), e._set("portal", this.portal);
    const t = j(this.uniqueValueInfos), r = j(this.uniqueValueGroups);
    return this.styleOrigin && (e._set("styleOrigin", Object.freeze(j(this.styleOrigin))), Object.freeze(t), Object.freeze(r)), e._set("uniqueValueInfos", t), e._updateValueInfoMap(), e._set("uniqueValueGroups", r), e._isInfosSource = this._isInfosSource, e._watchUniqueValueInfosAndGroups(), e;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  async collectRequiredFields(e, t) {
    const r = [this.collectVVRequiredFields(e, t), this.collectSymbolFields(e, t)];
    await Promise.all(r);
  }
  async collectSymbolFields(e, t) {
    const r = [...this.getSymbols().map((n) => n.collectRequiredFields(e, t)), qn(e, t, this.valueExpression)];
    Pi(e, t, this.field), Pi(e, t, this.field2), Pi(e, t, this.field3), await Promise.all(r);
  }
  populateFromStyle() {
    return dye(this.styleOrigin, { portal: this.portal }).then((e) => {
      var r;
      const t = [];
      return this._valueInfoMap = {}, e && e.data && Array.isArray(e.data.items) && e.data.items.forEach((n) => {
        const i = new tp({ styleUrl: e.styleUrl, styleName: e.styleName, portal: this.portal, name: n.name });
        this.defaultSymbol || n.name !== e.data.defaultItem || (this.defaultSymbol = i, this._isDefaultSymbolDerived = !0);
        const s = new My({ value: n.name, symbol: i });
        t.push(s), this._valueInfoMap[n.name] = s;
      }), this._set("uniqueValueInfos", Object.freeze(t)), this._updateGroupsFromInfos(!0), this._isInfosSource = null, this._watchUniqueValueInfos(), !this.defaultSymbol && ((r = this.uniqueValueInfos) != null && r.length) && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = !0), this;
    });
  }
  _updateFieldDelimiter() {
    this.field && this.field2 && !this.fieldDelimiter && this._set("fieldDelimiter", hye);
  }
  _updateUniqueValues() {
    this._isInfosSource != null && (this._isInfosSource ? this._updateGroupsFromInfos() : this._updateInfosFromGroups());
  }
  _updateValueInfoMap() {
    this._valueInfoMap = {};
    const { uniqueValueInfos: e } = this;
    if (e)
      for (const t of e)
        this._valueInfoMap[t.value + ""] = t;
  }
  _watchUniqueValueInfosAndGroups() {
    this._watchUniqueValueInfos(), this._watchUniqueValueGroups();
  }
  _watchUniqueValueInfos() {
    this.removeHandles(f4);
    const { uniqueValueInfos: e } = this;
    if (e) {
      const t = [];
      for (const r of e)
        t.push(ze(() => ({ symbol: r.symbol, value: r.value, label: r.label, description: r.description }), (n, i) => {
          n !== i && (this._updateGroupsFromInfos(), this._isInfosSource = !0);
        }, { sync: !0 }));
      this.addHandles(t, f4);
    }
  }
  _watchUniqueValueGroups() {
    this.removeHandles(m4);
    const { uniqueValueGroups: e } = this;
    if (e) {
      const t = [];
      for (const r of e) {
        t.push(ze(() => ({ classes: r.classes }), (n, i) => {
          n !== i && (this._updateInfosFromGroups(), this._isInfosSource = !1);
        }, { sync: !0 }));
        for (const n of r.classes ?? [])
          t.push(ze(() => ({ symbol: n.symbol, values: n.values, label: n.label, description: n.description }), (i, s) => {
            i !== s && (this._updateInfosFromGroups(), this._isInfosSource = !1);
          }, { sync: !0 }));
      }
      this.addHandles(t, m4);
    }
  }
  _updateInfosFromGroups() {
    if (!this.uniqueValueGroups)
      return this._set("uniqueValueInfos", null), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const e = [], { field: t, field2: r, field3: n, fieldDelimiter: i, uniqueValueGroups: s, valueExpression: o } = this;
    if (!t && !o)
      return this._set("uniqueValueInfos", e), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const a = !(!t || !r);
    for (const l of s)
      for (const c of l.classes ?? []) {
        const { symbol: h, label: f, values: m, description: y } = c;
        for (const g of m ?? []) {
          const { value: v, value2: b, value3: w } = g, x = [v];
          r && x.push(b), n && x.push(w);
          const $ = a ? x.join(i || "") : x[0];
          e.push(new My({ symbol: h, label: f, value: $, description: y }));
        }
      }
    this._set("uniqueValueInfos", e), this._updateValueInfoMap(), this._watchUniqueValueInfos();
  }
  _updateGroupsFromInfos(e = !1) {
    if (!this.uniqueValueInfos)
      return this._set("uniqueValueGroups", null), void this._watchUniqueValueGroups();
    const { field: t, field2: r, valueExpression: n, fieldDelimiter: i, uniqueValueInfos: s } = this;
    if (!t && !n || !s.length)
      return this._set("uniqueValueGroups", []), void this._watchUniqueValueGroups();
    const o = !(!t || !r), a = s.map((c) => {
      var w;
      const { symbol: h, label: f, value: m, description: y } = c, [g, v, b] = o ? ((w = m == null ? void 0 : m.toString()) == null ? void 0 : w.split(i || "")) || [] : [m];
      return new kz({ symbol: h, label: f, description: y, values: [new Th({ value: g, value2: v, value3: b })] });
    }), l = [new zE({ classes: a })];
    e && Object.freeze(l), this._set("uniqueValueGroups", l), this._watchUniqueValueGroups();
  }
  _getUniqueValueInfo(e, t) {
    return this.valueExpression ? this._getUnqiueValueInfoForExpression(e, t) : this._getUnqiueValueInfoForFields(e);
  }
  _getUnqiueValueInfoForExpression(e, t) {
    const { viewingMode: r, scale: n, spatialReference: i, arcade: s } = t ?? {};
    let o = this._cache.compiledFunc;
    const a = s.arcadeUtils;
    if (!o) {
      const c = a.createSyntaxTree(this.valueExpression);
      o = a.createFunction(c), this._cache.compiledFunc = o;
    }
    const l = a.executeFunction(o, a.createExecContext(e, a.getViewInfo({ viewingMode: r, scale: n, spatialReference: i })));
    return this._valueInfoMap[l + ""];
  }
  _getUnqiueValueInfoForFields(e) {
    const t = this.field, r = e.attributes;
    let n;
    if (typeof t != "function" && this.field2) {
      const i = this.field2, s = this.field3, o = [];
      t && o.push(r[t]), i && o.push(r[i]), s && o.push(r[s]), n = o.join(this.fieldDelimiter || "");
    } else
      typeof t == "function" ? n = t(e) : t && (n = r[t]);
    return this._valueInfoMap[n + ""];
  }
  static fromPortalStyle(e, t) {
    const r = new Xm(t && t.properties);
    r._set("styleOrigin", Object.freeze({ styleName: e })), r._set("portal", t && t.portal || pi.getDefault());
    const n = r.populateFromStyle();
    return n.catch((i) => {
      Rl.error(`#fromPortalStyle('${e}'[, ...])`, "Failed to create unique value renderer from style name", i);
    }), n;
  }
  static fromStyleUrl(e, t) {
    const r = new Xm(t && t.properties);
    r._set("styleOrigin", Object.freeze({ styleUrl: e }));
    const n = r.populateFromStyle();
    return n.catch((i) => {
      Rl.error(`#fromStyleUrl('${e}'[, ...])`, "Failed to create unique value renderer from style URL", i);
    }), n;
  }
};
u([d({ readOnly: !0 })], Wt.prototype, "_cache", null), u([Ie({ uniqueValue: "unique-value" })], Wt.prototype, "type", void 0), u([d(xz)], Wt.prototype, "backgroundFillSymbol", void 0), u([d({ value: null, json: { type: String, read: { source: "field1" }, write: { target: "field1" } } })], Wt.prototype, "field", null), u([xt("field")], Wt.prototype, "castField", null), u([ge("field")], Wt.prototype, "writeField", null), u([d({ type: String, value: null, json: { write: !0 } })], Wt.prototype, "field2", null), u([d({ type: String, value: null, json: { write: !0 } })], Wt.prototype, "field3", null), u([d({ type: Boolean, json: { name: "drawInClassOrder", default: !1, write: !0, origins: { "web-scene": { write: !1 } } } })], Wt.prototype, "orderByClassesEnabled", void 0), u([d({ type: String, value: null, json: { write: !0 } })], Wt.prototype, "valueExpression", null), u([d({ type: String, json: { write: !0 } })], Wt.prototype, "valueExpressionTitle", void 0), u([d({ type: xh, json: { write: !0 } })], Wt.prototype, "legendOptions", void 0), u([d({ type: String, json: { write: !0 } })], Wt.prototype, "defaultLabel", void 0), u([d(nF({ ...Sf }, { json: { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} }, origins: { "web-scene": { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} } } } } }))], Wt.prototype, "defaultSymbol", null), u([d({ type: String, value: null, json: { write: !0 } })], Wt.prototype, "fieldDelimiter", null), u([d({ type: pi, readOnly: !0 })], Wt.prototype, "portal", void 0), u([ce("portal", ["styleName"])], Wt.prototype, "readPortal", null), u([d({ readOnly: !0, json: { write: { enabled: !1, overridePolicy: () => ({ enabled: !0 }) } } })], Wt.prototype, "styleOrigin", void 0), u([ce("styleOrigin", ["styleName", "styleUrl"])], Wt.prototype, "readStyleOrigin", null), u([ge("styleOrigin", { styleName: { type: String }, styleUrl: { type: String } })], Wt.prototype, "writeStyleOrigin", null), u([d({ type: [zE], json: { read: { source: ["uniqueValueGroups", "uniqueValueInfos"], reader: (e, t, r) => (t.uniqueValueGroups || mye(t)).map((n) => zE.fromJSON(n, r)) }, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: !1 } : { enabled: !0 };
} } } })], Wt.prototype, "uniqueValueGroups", null), u([d({ type: [My], json: { read: !1, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: !1 } : { enabled: !0 };
} } } })], Wt.prototype, "uniqueValueInfos", null), Wt = Xm = u([E(Az)], Wt);
const HO = Wt, U_ = { key: "type", base: fl, typeMap: { heatmap: UO, simple: z_, "unique-value": HO, "class-breaks": Ez, "dot-density": Kme, dictionary: Jme, "pie-chart": Yme }, errorContext: "renderer" }, yye = { key: "type", base: fl, typeMap: { simple: z_, "unique-value": HO, "class-breaks": Ez, heatmap: UO }, errorContext: "renderer" };
function L5e(e, t) {
  return yg(e, null, t);
}
const gye = sf({ types: U_ });
function yg(e, t, r) {
  return e ? e && (e.styleName || e.styleUrl) && e.type !== "uniqueValue" ? (r && r.messages && r.messages.push(new bs("renderer:unsupported", "Only UniqueValueRenderer can be referenced from a web style, but found '" + e.type + "'", { definition: e, context: r })), null) : gye(e, t, r) : null;
}
let vye = class Pz {
  constructor() {
    this._propertyOriginMap = /* @__PURE__ */ new Map(), this._originStores = new Array(x$), this._values = /* @__PURE__ */ new Map(), this.multipleOriginsSupported = !0;
  }
  clone(t) {
    const r = new Pz(), n = this._originStores[Qe.DEFAULTS];
    n && n.forEach((i, s) => {
      r.set(s, j(i), Qe.DEFAULTS);
    });
    for (let i = Qe.SERVICE; i < x$; i++) {
      const s = this._originStores[i];
      s && s.forEach((o, a) => {
        t && t.has(a) || r.set(a, j(o), i);
      });
    }
    return r;
  }
  get(t, r) {
    const n = r === void 0 ? this._values : this._originStores[r];
    return n ? n.get(t) : void 0;
  }
  keys(t) {
    const r = t == null ? this._values : this._originStores[t];
    return r ? [...r.keys()] : [];
  }
  set(t, r, n = Qe.USER) {
    let i = this._originStores[n];
    if (i || (i = /* @__PURE__ */ new Map(), this._originStores[n] = i), i.set(t, r), !this._values.has(t) || this._propertyOriginMap.get(t) <= n) {
      const s = this._values.get(t);
      return this._values.set(t, r), this._propertyOriginMap.set(t, n), s !== r;
    }
    return !1;
  }
  delete(t, r = Qe.USER) {
    const n = this._originStores[r];
    if (!n)
      return;
    const i = n.get(t);
    if (n.delete(t), this._values.has(t) && this._propertyOriginMap.get(t) === r) {
      this._values.delete(t);
      for (let s = r - 1; s >= 0; s--) {
        const o = this._originStores[s];
        if (o && o.has(t)) {
          this._values.set(t, o.get(t)), this._propertyOriginMap.set(t, s);
          break;
        }
      }
    }
    return i;
  }
  has(t, r) {
    const n = r === void 0 ? this._values : this._originStores[r];
    return !!n && n.has(t);
  }
  revert(t, r) {
    for (; r > 0 && !this.has(t, r); )
      --r;
    const n = this._originStores[r], i = n && n.get(t), s = this._values.get(t);
    return this._values.set(t, i), this._propertyOriginMap.set(t, r), s !== i;
  }
  originOf(t) {
    return this._propertyOriginMap.get(t) || Qe.DEFAULTS;
  }
  forEach(t) {
    this._values.forEach(t);
  }
};
const Rz = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r);
      const n = Bn(this), i = n.store, s = new vye();
      n.store = s, WF(n, i, s);
    }
    read(r, n) {
      ZF(this, r, n);
    }
    getAtOrigin(r, n) {
      const i = AS(this), s = bu(n);
      if (typeof r == "string")
        return i.get(r, s);
      const o = {};
      return r.forEach((a) => {
        o[a] = i.get(a, s);
      }), o;
    }
    originOf(r) {
      return cb(this.originIdOf(r));
    }
    originIdOf(r) {
      return AS(this).originOf(r);
    }
    revert(r, n) {
      const i = AS(this), s = bu(n), o = Bn(this);
      let a;
      a = typeof r == "string" ? r === "*" ? i.keys(s) : [r] : r, a.forEach((l) => {
        o.invalidate(l), i.revert(l, s), o.commit(l);
      });
    }
  };
  return t = u([E("geoscene.core.ReadOnlyMultiOriginJSONSupport")], t), t;
};
function AS(e) {
  return Bn(e).store;
}
let y4 = class extends Rz(Ae) {
};
y4 = u([E("geoscene.core.ReadOnlyMultiOriginJSONSupport")], y4);
const bye = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r);
    }
    clear(r, n = "user") {
      return PS(this).delete(r, bu(n));
    }
    write(r, n) {
      return YF(this, r = r || {}, n), r;
    }
    setAtOrigin(r, n, i) {
      Bn(this).setAtOrigin(r, n, bu(i));
    }
    removeOrigin(r) {
      const n = PS(this), i = bu(r), s = n.keys(i);
      for (const o of s)
        n.originOf(o) === i && n.set(o, n.get(o, i), Qe.USER);
    }
    updateOrigin(r, n) {
      const i = PS(this), s = bu(n), o = this.get(r);
      for (let a = s + 1; a < x$; ++a)
        i.delete(r, a);
      i.set(r, o, s);
    }
    toJSON(r) {
      return this.write({}, r);
    }
  };
  return t = u([E("geoscene.core.WriteableMultiOriginJSONSupport")], t), t.prototype.toJSON.isDefaultToJSON = !0, t;
};
function PS(e) {
  return Bn(e).store;
}
const Lz = (e) => {
  let t = class extends bye(Rz(e)) {
    constructor(...r) {
      super(...r);
    }
  };
  return t = u([E("geoscene.core.MultiOriginJSONSupport")], t), t;
};
let g4 = class extends Lz(Ae) {
};
g4 = u([E("geoscene.core.MultiOriginJSONSupport")], g4);
async function wye(e, t) {
  const { WhereClause: r } = await import("./WhereClause-ULyNcODK.js").then((n) => n.W);
  return r.create(e, t);
}
function _ye(e, t) {
  return e != null ? t != null ? `(${e}) AND (${t})` : e : t;
}
var BE;
let jc = BE = class extends re {
  constructor(e) {
    super(e), this.expression = null, this.name = null, this.returnType = "boolean", this.title = null;
  }
  clone() {
    return new BE({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
u([d({ type: String, json: { write: !0 } })], jc.prototype, "expression", void 0), u([d({ type: String, json: { write: !0 } })], jc.prototype, "name", void 0), u([d({ type: ["boolean", "date", "number", "string"], json: { write: !0 } })], jc.prototype, "returnType", void 0), u([d({ type: String, json: { write: !0 } })], jc.prototype, "title", void 0), jc = BE = u([E("geoscene.form.ExpressionInfo")], jc);
const Sye = jc;
let Vc = class extends re {
  constructor(t) {
    super(t), this.description = null, this.label = null, this.type = null, this.visibilityExpression = null;
  }
};
u([d({ type: String, json: { write: !0 } })], Vc.prototype, "description", void 0), u([d({ type: String, json: { write: !0 } })], Vc.prototype, "label", void 0), u([d()], Vc.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Vc.prototype, "visibilityExpression", void 0), Vc = u([E("geoscene.form.elements.Element")], Vc);
const qh = Vc;
var qE;
let N1 = qE = class extends re {
  constructor(e) {
    super(e), this.type = null;
  }
  clone() {
    return new qE({ type: this.type });
  }
};
u([d({ type: ["attachment", "audio", "document", "image", "signature", "video"], json: { write: !0 } })], N1.prototype, "type", void 0), N1 = qE = u([E("geoscene.form.elements.inputs.AttachmentInput")], N1);
const $ye = N1;
var GE;
let zc = GE = class extends qh {
  constructor(e) {
    super(e), this.attachmentKeyword = null, this.editable = !0, this.input = null, this.type = "attachment";
  }
  clone() {
    return new GE({ attachmentKeyword: this.attachmentKeyword, description: this.description, editable: this.editable, input: this.input, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ type: String, json: { write: !0 } })], zc.prototype, "attachmentKeyword", void 0), u([d({ type: Boolean, json: { write: !0 } })], zc.prototype, "editable", void 0), u([d({ type: $ye, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], zc.prototype, "input", void 0), u([d({ type: ["attachment"], json: { read: !1, write: !0 } })], zc.prototype, "type", void 0), zc = GE = u([E("geoscene.form.elements.AttachmentElement")], zc);
const v4 = zc;
let F1 = class extends re {
  constructor(t) {
    super(t), this.type = null;
  }
};
u([d()], F1.prototype, "type", void 0), F1 = u([E("geoscene.form.elements.inputs.Input")], F1);
const $f = F1;
let ey = class extends $f {
  constructor(t) {
    super(t), this.maxLength = null, this.minLength = 0;
  }
};
u([d({ type: Number, json: { write: !0 } })], ey.prototype, "maxLength", void 0), u([d({ type: Number, json: { write: !0 } })], ey.prototype, "minLength", void 0), ey = u([E("geoscene.form.elements.inputs.TextInput")], ey);
const WO = ey;
var HE;
let D1 = HE = class extends WO {
  constructor(e) {
    super(e), this.type = "barcode-scanner";
  }
  clone() {
    return new HE({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["barcode-scanner"], json: { read: !1, write: !0 } })], D1.prototype, "type", void 0), D1 = HE = u([E("geoscene.form.elements.inputs.BarcodeScannerInput")], D1);
const xye = D1;
var WE;
let Kp = WE = class extends $f {
  constructor(e) {
    super(e), this.noValueOptionLabel = null, this.showNoValueOption = !0, this.type = "combo-box";
  }
  clone() {
    return new WE({ showNoValueOption: this.showNoValueOption, noValueOptionLabel: this.noValueOptionLabel });
  }
};
u([d({ type: String, json: { write: !0 } })], Kp.prototype, "noValueOptionLabel", void 0), u([d({ type: Boolean, json: { write: !0 } })], Kp.prototype, "showNoValueOption", void 0), u([d({ type: ["combo-box"], json: { read: !1, write: !0 } })], Kp.prototype, "type", void 0), Kp = WE = u([E("geoscene.form.elements.inputs.ComboBoxInput")], Kp);
const Tye = Kp;
var JE;
function b4(e) {
  return e != null ? new Date(e) : null;
}
function w4(e) {
  return e ? e.getTime() : null;
}
let Js = JE = class extends $f {
  constructor(e) {
    super(e), this.includeTime = !1, this.max = null, this.min = null, this.type = "datetime-picker";
  }
  readMax(e, t) {
    return b4(t.max);
  }
  writeMax(e, t) {
    t.max = w4(e);
  }
  readMin(e, t) {
    return b4(t.min);
  }
  writeMin(e, t) {
    t.min = w4(e);
  }
  clone() {
    return new JE({ includeTime: this.includeTime, max: this.max, min: this.min });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Js.prototype, "includeTime", void 0), u([d({ type: Date, json: { type: Number, write: !0 } })], Js.prototype, "max", void 0), u([ce("max")], Js.prototype, "readMax", null), u([ge("max")], Js.prototype, "writeMax", null), u([d({ type: Date, json: { type: Number, write: !0 } })], Js.prototype, "min", void 0), u([ce("min")], Js.prototype, "readMin", null), u([ge("min")], Js.prototype, "writeMin", null), u([d({ type: ["datetime-picker"], json: { read: !1, write: !0 } })], Js.prototype, "type", void 0), Js = JE = u([E("geoscene.form.elements.inputs.DateTimePickerInput")], Js);
const Eye = Js;
var ZE;
let Yp = ZE = class extends $f {
  constructor(e) {
    super(e), this.noValueOptionLabel = null, this.showNoValueOption = !0, this.type = "radio-buttons";
  }
  clone() {
    return new ZE({ noValueOptionLabel: this.noValueOptionLabel, showNoValueOption: this.showNoValueOption });
  }
};
u([d({ type: String, json: { write: !0 } })], Yp.prototype, "noValueOptionLabel", void 0), u([d({ type: Boolean, json: { write: !0 } })], Yp.prototype, "showNoValueOption", void 0), u([d({ type: ["radio-buttons"], json: { read: !1, write: !0 } })], Yp.prototype, "type", void 0), Yp = ZE = u([E("geoscene.form.elements.inputs.RadioButtonsInput")], Yp);
const Iye = Yp;
var KE;
let Qp = KE = class extends $f {
  constructor(e) {
    super(e), this.offValue = null, this.onValue = null, this.type = "switch";
  }
  clone() {
    return new KE({ offValue: this.offValue, onValue: this.onValue });
  }
};
u([d({ type: [String, Number], json: { write: !0 } })], Qp.prototype, "offValue", void 0), u([d({ type: [String, Number], json: { write: !0 } })], Qp.prototype, "onValue", void 0), u([d({ type: ["switch"], json: { read: !1, write: !0 } })], Qp.prototype, "type", void 0), Qp = KE = u([E("geoscene.form.elements.inputs.SwitchInput")], Qp);
const Mye = Qp;
var YE;
let j1 = YE = class extends WO {
  constructor(e) {
    super(e), this.type = "text-area";
  }
  clone() {
    return new YE({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["text-area"], json: { read: !1, write: !0 } })], j1.prototype, "type", void 0), j1 = YE = u([E("geoscene.form.elements.inputs.TextAreaInput")], j1);
const Oye = j1;
var QE;
let V1 = QE = class extends WO {
  constructor(e) {
    super(e), this.type = "text-box";
  }
  clone() {
    return new QE({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
u([d({ type: ["text-box"], json: { read: !1, write: !0 } })], V1.prototype, "type", void 0), V1 = QE = u([E("geoscene.form.elements.inputs.TextBoxInput")], V1);
const Cye = V1, kye = { base: $f, key: "type", typeMap: { "barcode-scanner": xye, "combo-box": Tye, "datetime-picker": Eye, "radio-buttons": Iye, switch: Mye, "text-area": Oye, "text-box": Cye } };
var XE;
let ty = XE = class extends re {
  constructor(e) {
    super(e), this.name = null, this.code = null;
  }
  clone() {
    return new XE({ name: this.name, code: this.code });
  }
};
u([d({ type: String, json: { write: !0 } })], ty.prototype, "name", void 0), u([d({ type: [String, Number], json: { write: !0 } })], ty.prototype, "code", void 0), ty = XE = u([E("geoscene.layers.support.CodedValue")], ty);
const Aye = new et({ inherited: "inherited", codedValue: "coded-value", range: "range" });
let ry = class extends re {
  constructor(t) {
    super(t), this.name = null, this.type = null;
  }
};
u([d({ type: String, json: { write: !0 } })], ry.prototype, "name", void 0), u([Ie(Aye)], ry.prototype, "type", void 0), ry = u([E("geoscene.layers.support.Domain")], ry);
const B_ = ry;
var eI;
let ny = eI = class extends B_ {
  constructor(e) {
    super(e), this.codedValues = null, this.type = "coded-value";
  }
  getName(e) {
    let t = null;
    if (this.codedValues) {
      const r = String(e);
      this.codedValues.some((n) => (String(n.code) === r && (t = n.name), !!t));
    }
    return t;
  }
  clone() {
    return new eI({ codedValues: j(this.codedValues), name: this.name });
  }
};
u([d({ type: [ty], json: { write: !0 } })], ny.prototype, "codedValues", void 0), u([Ie({ codedValue: "coded-value" })], ny.prototype, "type", void 0), ny = eI = u([E("geoscene.layers.support.CodedValueDomain")], ny);
const Nz = ny;
var tI;
let z1 = tI = class extends B_ {
  constructor(e) {
    super(e), this.type = "inherited";
  }
  clone() {
    return new tI();
  }
};
u([Ie({ inherited: "inherited" })], z1.prototype, "type", void 0), z1 = tI = u([E("geoscene.layers.support.InheritedDomain")], z1);
const Fz = z1;
var rI;
let Xp = rI = class extends B_ {
  constructor(e) {
    super(e), this.maxValue = null, this.minValue = null, this.type = "range";
  }
  clone() {
    return new rI({ maxValue: this.maxValue, minValue: this.minValue, name: this.name });
  }
};
u([d({ type: Number, json: { type: [Number], read: { source: "range", reader: (e, t) => t.range && t.range[1] }, write: { enabled: !1, overridePolicy() {
  return { enabled: this.maxValue != null && this.minValue == null };
}, target: "range", writer(e, t, r) {
  t[r] = [this.minValue || 0, e];
} } } })], Xp.prototype, "maxValue", void 0), u([d({ type: Number, json: { type: [Number], read: { source: "range", reader: (e, t) => t.range && t.range[0] }, write: { target: "range", writer(e, t, r) {
  t[r] = [e, this.maxValue || 0];
} } } })], Xp.prototype, "minValue", void 0), u([Ie({ range: "range" })], Xp.prototype, "type", void 0), Xp = rI = u([E("geoscene.layers.support.RangeDomain")], Xp);
const Dz = Xp, jz = { key: "type", base: B_, typeMap: { range: Dz, "coded-value": Nz, inherited: Fz } };
function JO(e) {
  if (!e || !e.type)
    return null;
  switch (e.type) {
    case "range":
      return Dz.fromJSON(e);
    case "codedValue":
      return Nz.fromJSON(e);
    case "inherited":
      return Fz.fromJSON(e);
  }
  return null;
}
var nI;
const Vz = "geoscene.form.elements.FieldElement", _4 = se.getLogger(Vz);
let rs = nI = class extends qh {
  constructor(e) {
    super(e), this.domain = null, this.editableExpression = null, this.fieldName = null, this.hint = null, this.input = null, this.requiredExpression = null, this.type = "field", this.valueExpression = null;
  }
  get editable() {
    return V$(_4, "editable", { replacement: "editableExpression", version: "4.26", warnOnce: !0 }), this._get("editable") ?? !0;
  }
  set editable(e) {
    V$(_4, "editable", { replacement: "editableExpression", version: "4.26", warnOnce: !0 }), this._set("editable", e);
  }
  clone() {
    return new nI({ description: this.description, domain: this.domain, editable: this.editable, editableExpression: this.editableExpression, fieldName: this.fieldName, hint: this.hint, input: this.input, label: this.label, requiredExpression: this.requiredExpression, valueExpression: this.valueExpression, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ types: jz, json: { read: { reader: JO }, write: !0 } })], rs.prototype, "domain", void 0), u([d({ type: Boolean, json: { write: !0 } })], rs.prototype, "editable", null), u([d({ type: String, json: { write: !0 } })], rs.prototype, "editableExpression", void 0), u([d({ type: String, json: { write: !0 } })], rs.prototype, "fieldName", void 0), u([d({ type: String, json: { write: !0 } })], rs.prototype, "hint", void 0), u([d({ types: kye, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], rs.prototype, "input", void 0), u([d({ type: String, json: { write: !0 } })], rs.prototype, "requiredExpression", void 0), u([d({ type: String, json: { read: !1, write: !0 } })], rs.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], rs.prototype, "valueExpression", void 0), rs = nI = u([E(Vz)], rs);
const S4 = rs;
var iI;
let Fa = iI = class extends qh {
  constructor(e) {
    super(e), this.displayCount = null, this.displayType = "list", this.editableExpression = null, this.orderByFields = null, this.relationshipId = null, this.type = "relationship";
  }
  clone() {
    return new iI({ description: this.description, displayCount: this.displayCount, displayType: this.displayType, editableExpression: this.editableExpression, label: this.label, orderByFields: j(this.orderByFields), relationshipId: this.relationshipId, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ type: Number, json: { write: !0 } })], Fa.prototype, "displayCount", void 0), u([d({ type: ["list"], json: { write: !0 } })], Fa.prototype, "displayType", void 0), u([d({ type: String, json: { write: !0 } })], Fa.prototype, "editableExpression", void 0), u([d({ type: [zM], json: { write: !0 } })], Fa.prototype, "orderByFields", void 0), u([d({ type: Number, json: { write: !0 } })], Fa.prototype, "relationshipId", void 0), u([d({ type: ["relationship"], json: { read: !1, write: !0 } })], Fa.prototype, "type", void 0), Fa = iI = u([E("geoscene.form.elements.RelationshipElement")], Fa);
const $4 = Fa;
function zz(e) {
  return { typesWithGroup: { base: qh, key: "type", typeMap: { attachment: v4, field: S4, group: e, relationship: $4 } }, typesWithoutGroup: { base: qh, key: "type", typeMap: { attachment: v4, field: S4, relationship: $4 } } };
}
function Uz(e, t, r = !0) {
  if (!e)
    return null;
  const n = r ? t.typesWithGroup.typeMap : t.typesWithoutGroup.typeMap;
  return e.filter((i) => n[i.type]).map((i) => n[i.type].fromJSON(i));
}
function Bz(e, t, r = !0) {
  if (!e)
    return null;
  const n = r ? t.typesWithGroup.typeMap : t.typesWithoutGroup.typeMap;
  return e.filter((i) => n[i.type]).map((i) => i.toJSON());
}
function qz(e, t, r = !0) {
  return e ? e.map((n) => na(r ? t.typesWithGroup : t.typesWithoutGroup, n)) : null;
}
var sI;
let Uo = sI = class extends qh {
  constructor(e) {
    super(e), this.elements = null, this.initialState = "expanded", this.type = "group";
  }
  castElements(e) {
    return qz(e, RS, !1);
  }
  readElements(e, t) {
    return Uz(t.formElements, RS, !1);
  }
  writeElements(e, t) {
    t.formElements = Bz(e, RS, !1);
  }
  clone() {
    return new sI({ description: this.description, elements: j(this.elements), initialState: this.initialState, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
u([d({ json: { write: !0 } })], Uo.prototype, "elements", void 0), u([xt("elements")], Uo.prototype, "castElements", null), u([ce("elements", ["formElements"])], Uo.prototype, "readElements", null), u([ge("elements")], Uo.prototype, "writeElements", null), u([d({ type: ["collapsed", "expanded"], json: { write: !0 } })], Uo.prototype, "initialState", void 0), u([d({ type: String, json: { read: !1, write: !0 } })], Uo.prototype, "type", void 0), Uo = sI = u([E("geoscene.form.elements.GroupElement")], Uo);
const RS = zz(Uo), Pye = Uo;
var oI;
const LS = zz(Pye);
let Zs = oI = class extends re {
  constructor(e) {
    super(e), this.description = null, this.elements = null, this.expressionInfos = null, this.preserveFieldValuesWhenHidden = !1, this.title = null;
  }
  castElements(e) {
    return qz(e, LS);
  }
  readElements(e, t) {
    return Uz(t.formElements, LS);
  }
  writeElements(e, t) {
    t.formElements = Bz(e, LS);
  }
  clone() {
    return new oI({ description: this.description, expressionInfos: j(this.expressionInfos), elements: j(this.elements), title: this.title, preserveFieldValuesWhenHidden: this.preserveFieldValuesWhenHidden });
  }
};
u([d({ type: String, json: { write: !0 } })], Zs.prototype, "description", void 0), u([d({ json: { write: !0 } })], Zs.prototype, "elements", void 0), u([xt("elements")], Zs.prototype, "castElements", null), u([ce("elements", ["formElements"])], Zs.prototype, "readElements", null), u([ge("elements")], Zs.prototype, "writeElements", null), u([d({ type: [Sye], json: { write: !0 } })], Zs.prototype, "expressionInfos", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Zs.prototype, "preserveFieldValuesWhenHidden", void 0), u([d({ type: String, json: { write: !0 } })], Zs.prototype, "title", void 0), Zs = oI = u([E("geoscene.form.FormTemplate")], Zs);
const Rye = Zs;
function x4(e, t, r) {
  if (e.hasM == null || e.hasZ)
    for (const n of t)
      for (const i of n)
        i.length > 2 && (i[2] *= r);
}
function Lye(e, t, r) {
  if (!e && !t || !r)
    return;
  const n = Ib(r);
  T4(e, r, n), T4(t, r, n);
}
function T4(e, t, r) {
  if (e)
    for (const n of e)
      Nye(n.geometry, t, r);
}
function Nye(e, t, r) {
  if (e == null || !e.spatialReference || tn(e.spatialReference, t))
    return;
  const n = Ib(e.spatialReference) / r;
  if (n !== 1) {
    if ("x" in e)
      e.z != null && (e.z *= n);
    else if ("rings" in e)
      x4(e, e.rings, n);
    else if ("paths" in e)
      x4(e, e.paths, n);
    else if ("points" in e && (e.hasM == null || e.hasZ))
      for (const i of e.points)
        i.length > 2 && (i[2] *= n);
  }
}
function E4(e, t, r) {
  if (!r || !r.features || !r.hasZ)
    return;
  const n = Yj(r.geometryType, t, e.outSpatialReference);
  if (n != null)
    for (const i of r.features)
      n(i.geometry);
}
const Fye = new et({ esriFieldTypeSmallInteger: "small-integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "single", esriFieldTypeDouble: "double", esriFieldTypeLong: "long", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "oid", esriFieldTypeGeometry: "geometry", esriFieldTypeBlob: "blob", esriFieldTypeRaster: "raster", esriFieldTypeGUID: "guid", esriFieldTypeGlobalID: "global-id", esriFieldTypeXML: "xml", esriFieldTypeBigInteger: "big-integer", esriFieldTypeDateOnly: "date-only", esriFieldTypeTimeOnly: "time-only", esriFieldTypeTimestampOffset: "timestamp-offset" });
var aI;
const Dye = new et({ binary: "binary", coordinate: "coordinate", countOrAmount: "count-or-amount", dateAndTime: "date-and-time", description: "description", locationOrPlaceName: "location-or-place-name", measurement: "measurement", nameOrTitle: "name-or-title", none: "none", orderedOrRanked: "ordered-or-ranked", percentageOrRatio: "percentage-or-ratio", typeOrCategory: "type-or-category", uniqueIdentifier: "unique-identifier" });
let wn = aI = class extends re {
  constructor(e) {
    super(e), this.alias = null, this.defaultValue = void 0, this.description = null, this.domain = null, this.editable = !0, this.length = -1, this.name = null, this.nullable = !0, this.type = null, this.valueType = null, this.visible = !0;
  }
  readDescription(e, { description: t }) {
    let r = null;
    try {
      r = t ? JSON.parse(t) : null;
    } catch {
    }
    return (r == null ? void 0 : r.value) ?? null;
  }
  readValueType(e, { description: t }) {
    let r = null;
    try {
      r = t ? JSON.parse(t) : null;
    } catch {
    }
    return r ? Dye.fromJSON(r.fieldValueType) : null;
  }
  clone() {
    return new aI({ alias: this.alias, defaultValue: this.defaultValue, description: this.description, domain: this.domain && this.domain.clone() || null, editable: this.editable, length: this.length, name: this.name, nullable: this.nullable, type: this.type, valueType: this.valueType, visible: this.visible });
  }
};
u([d({ type: String, json: { write: !0 } })], wn.prototype, "alias", void 0), u([d({ type: [String, Number], json: { write: { allowNull: !0 } } })], wn.prototype, "defaultValue", void 0), u([d()], wn.prototype, "description", void 0), u([ce("description")], wn.prototype, "readDescription", null), u([d({ types: jz, json: { read: { reader: JO }, write: !0 } })], wn.prototype, "domain", void 0), u([d({ type: Boolean, json: { write: !0 } })], wn.prototype, "editable", void 0), u([d({ type: Ot, json: { write: !0 } })], wn.prototype, "length", void 0), u([d({ type: String, json: { write: !0 } })], wn.prototype, "name", void 0), u([d({ type: Boolean, json: { write: !0 } })], wn.prototype, "nullable", void 0), u([Ie(Fye)], wn.prototype, "type", void 0), u([d()], wn.prototype, "valueType", void 0), u([ce("valueType", ["description"])], wn.prototype, "readValueType", null), u([d({ type: Boolean, json: { read: !1 } })], wn.prototype, "visible", void 0), wn = aI = u([E("geoscene.layers.support.Field")], wn);
const ZO = wn;
var lI;
const uI = new et({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh", "": null });
let Kr = lI = class extends re {
  constructor(e) {
    super(e), this.displayFieldName = null, this.exceededTransferLimit = !1, this.features = [], this.fields = null, this.geometryType = null, this.hasM = !1, this.hasZ = !1, this.queryGeometry = null, this.spatialReference = null;
  }
  readFeatures(e, t) {
    const r = tt.fromJSON(t.spatialReference), n = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = vr.fromJSON(s), a = s.geometry && s.geometry.spatialReference;
      o.geometry == null || a || (o.geometry.spatialReference = r);
      const l = s.aggregateGeometries, c = o.aggregateGeometries;
      if (l && c != null)
        for (const h in c) {
          const f = c[h], m = l[h], y = m == null ? void 0 : m.spatialReference;
          f == null || y || (f.spatialReference = r);
        }
      n.push(o);
    }
    return n;
  }
  writeGeometryType(e, t, r, n) {
    if (e)
      return void uI.write(e, t, r, n);
    const { features: i } = this;
    if (i) {
      for (const s of i)
        if (s && s.geometry != null)
          return void uI.write(s.geometry.type, t, r, n);
    }
  }
  readQueryGeometry(e, t) {
    if (!e)
      return null;
    const r = !!e.spatialReference, n = Pd(e);
    return n && !r && t.spatialReference && (n.spatialReference = tt.fromJSON(t.spatialReference)), n;
  }
  writeSpatialReference(e, t) {
    if (e)
      return void (t.spatialReference = e.toJSON());
    const { features: r } = this;
    if (r) {
      for (const n of r)
        if (n && n.geometry != null && n.geometry.spatialReference)
          return void (t.spatialReference = n.geometry.spatialReference.toJSON());
    }
  }
  clone() {
    return new lI(this.cloneProperties());
  }
  cloneProperties() {
    return j({ displayFieldName: this.displayFieldName, exceededTransferLimit: this.exceededTransferLimit, features: this.features, fields: this.fields, geometryType: this.geometryType, hasM: this.hasM, hasZ: this.hasZ, queryGeometry: this.queryGeometry, spatialReference: this.spatialReference, transform: this.transform });
  }
  toJSON(e) {
    const t = this.write();
    if (t.features && Array.isArray(e) && e.length > 0)
      for (let r = 0; r < t.features.length; r++) {
        const n = t.features[r];
        if (n.geometry) {
          const i = e && e[r];
          n.geometry = i && i.toJSON() || n.geometry;
        }
      }
    return t;
  }
  quantize(e) {
    const { scale: [t, r], translate: [n, i] } = e, s = (c) => Math.round((c - n) / t), o = (c) => Math.round((i - c) / r), a = this.features, l = this._getQuantizationFunction(this.geometryType, s, o);
    for (let c = 0, h = a.length; c < h; c++)
      l != null && l(a[c].geometry) || (a.splice(c, 1), c--, h--);
    return this.transform = e, this;
  }
  unquantize() {
    var m, y;
    const { geometryType: e, features: t, transform: r } = this;
    if (!r)
      return this;
    const { translate: [n, i], scale: [s, o] } = r, a = (g) => g * s + n, l = (g) => i - g * o;
    let c = null, h = null;
    if (this.hasZ && ((m = r == null ? void 0 : r.scale) == null ? void 0 : m[2]) != null) {
      const { translate: [, , g], scale: [, , v] } = r;
      c = (b) => b * v + g;
    }
    if (this.hasM && ((y = r == null ? void 0 : r.scale) == null ? void 0 : y[3]) != null) {
      const { translate: [, , , g], scale: [, , , v] } = r;
      h = (b) => b == null ? b : b * v + g;
    }
    const f = this._getHydrationFunction(e, a, l, c, h);
    for (const { geometry: g } of t)
      g != null && f && f(g);
    return this.transform = null, this;
  }
  _quantizePoints(e, t, r) {
    let n, i;
    const s = [];
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o];
      if (o > 0) {
        const c = t(l[0]), h = r(l[1]);
        c === n && h === i || (s.push([c - n, h - i]), n = c, i = h);
      } else
        n = t(l[0]), i = r(l[1]), s.push([n, i]);
    }
    return s.length > 0 ? s : null;
  }
  _getQuantizationFunction(e, t, r) {
    return e === "point" ? (n) => (n.x = t(n.x), n.y = r(n.y), n) : e === "polyline" || e === "polygon" ? (n) => {
      const i = gy(n) ? n.rings : n.paths, s = [];
      for (let o = 0, a = i.length; o < a; o++) {
        const l = i[o], c = this._quantizePoints(l, t, r);
        c && s.push(c);
      }
      return s.length > 0 ? (gy(n) ? n.rings = s : n.paths = s, n) : null;
    } : e === "multipoint" ? (n) => {
      const i = this._quantizePoints(n.points, t, r);
      return i && i.length > 0 ? (n.points = i, n) : null;
    } : e === "extent" ? (n) => n : null;
  }
  _getHydrationFunction(e, t, r, n, i) {
    return e === "point" ? (s) => {
      s.x = t(s.x), s.y = r(s.y), n && (s.z = n(s.z));
    } : e === "polyline" || e === "polygon" ? (s) => {
      const o = gy(s) ? s.rings : s.paths;
      let a, l;
      for (let c = 0, h = o.length; c < h; c++) {
        const f = o[c];
        for (let m = 0, y = f.length; m < y; m++) {
          const g = f[m];
          m > 0 ? (a += g[0], l += g[1]) : (a = g[0], l = g[1]), g[0] = t(a), g[1] = r(l);
        }
      }
      if (n && i)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          for (let m = 0, y = f.length; m < y; m++) {
            const g = f[m];
            g[2] = n(g[2]), g[3] = i(g[3]);
          }
        }
      else if (n)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          for (let m = 0, y = f.length; m < y; m++) {
            const g = f[m];
            g[2] = n(g[2]);
          }
        }
      else if (i)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          for (let m = 0, y = f.length; m < y; m++) {
            const g = f[m];
            g[2] = i(g[2]);
          }
        }
    } : e === "extent" ? (s) => {
      s.xmin = t(s.xmin), s.ymin = r(s.ymin), s.xmax = t(s.xmax), s.ymax = r(s.ymax), n && s.zmax != null && s.zmin != null && (s.zmax = n(s.zmax), s.zmin = n(s.zmin)), i && s.mmax != null && s.mmin != null && (s.mmax = i(s.mmax), s.mmin = i(s.mmin));
    } : e === "multipoint" ? (s) => {
      const o = s.points;
      let a, l;
      for (let c = 0, h = o.length; c < h; c++) {
        const f = o[c];
        c > 0 ? (a += f[0], l += f[1]) : (a = f[0], l = f[1]), f[0] = t(a), f[1] = r(l);
      }
      if (n && i)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          f[2] = n(f[2]), f[3] = i(f[3]);
        }
      else if (n)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          f[2] = n(f[2]);
        }
      else if (i)
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          f[2] = i(f[2]);
        }
    } : null;
  }
};
u([d({ type: String, json: { write: !0 } })], Kr.prototype, "displayFieldName", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Kr.prototype, "exceededTransferLimit", void 0), u([d({ type: [vr], json: { write: !0 } })], Kr.prototype, "features", void 0), u([ce("features")], Kr.prototype, "readFeatures", null), u([d({ type: [ZO], json: { write: !0 } })], Kr.prototype, "fields", void 0), u([d({ type: ["point", "multipoint", "polyline", "polygon", "extent", "mesh"], json: { read: { reader: uI.read } } })], Kr.prototype, "geometryType", void 0), u([ge("geometryType")], Kr.prototype, "writeGeometryType", null), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Kr.prototype, "hasM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Kr.prototype, "hasZ", void 0), u([d({ types: Qd, json: { write: !0 } })], Kr.prototype, "queryGeometry", void 0), u([ce("queryGeometry")], Kr.prototype, "readQueryGeometry", null), u([d({ type: tt, json: { write: !0 } })], Kr.prototype, "spatialReference", void 0), u([ge("spatialReference")], Kr.prototype, "writeSpatialReference", null), u([d({ json: { write: !0 } })], Kr.prototype, "transform", void 0), Kr = lI = u([E("geoscene.rest.support.FeatureSet")], Kr), Kr.prototype.toJSON.isDefaultToJSON = !0;
const Gz = Kr;
let jye = 0;
const Hz = "geoscene.layers.graphics.sources.MemorySource", NS = se.getLogger(Hz);
let Ua = class extends sl.LoadableMixin(r_(M_(je))) {
  constructor(t) {
    super(t), this._idToClientGraphic = null, this.type = "memory";
  }
  load(t) {
    const r = t != null ? t.signal : null;
    return this.addResolvingPromise(this._startWorker(r)), Promise.resolve(this);
  }
  destroy() {
    var t;
    (t = this._connection) == null || t.close(), this._connection = null;
  }
  get _workerGeometryType() {
    var r;
    const t = (r = this.layer) == null ? void 0 : r.geometryType;
    return t ? this._geometryTypeRequiresClientGraphicMapping(t) ? "polygon" : t : null;
  }
  applyEdits(t) {
    return this.load().then(() => this._applyEdits(t));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(t, r = {}) {
    await this.load(r);
    const n = await this._connection.invoke("queryFeatures", t ? t.toJSON() : null, r);
    E4(t, this.layer.spatialReference, n);
    const i = Gz.fromJSON(n);
    if (!this._requiresClientGraphicMapping())
      return i;
    const s = this.layer.objectIdField;
    for (const o of i.features) {
      const a = o.attributes[s], l = this._idToClientGraphic.get(a);
      l && (o.geometry = l.geometry);
    }
    return i.geometryType = this.layer.geometryType, i;
  }
  async queryFeaturesJSON(t, r = {}) {
    if (this._requiresClientGraphicMapping())
      throw new G("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(r);
    const n = await this._connection.invoke("queryFeatures", t ? t.toJSON() : null, r);
    return E4(t, this.layer.spatialReference, n), n;
  }
  queryFeatureCount(t, r = {}) {
    return this.load(r).then(() => this._connection.invoke("queryFeatureCount", t ? t.toJSON() : null, r));
  }
  queryObjectIds(t, r = {}) {
    return this.load(r).then(() => this._connection.invoke("queryObjectIds", t ? t.toJSON() : null, r));
  }
  queryExtent(t, r = {}) {
    return this.load(r).then(() => this._connection.invoke("queryExtent", t ? t.toJSON() : null, r)).then((n) => ({ count: n.count, extent: Ct.fromJSON(n.extent) }));
  }
  querySnapping(t, r = {}) {
    return this.load(r).then(() => this._connection.invoke("querySnapping", t, r));
  }
  async _applyEdits(t) {
    if (!this._connection)
      throw new G("feature-layer-source:edit-failure", "Memory source not loaded");
    const r = this.layer.objectIdField;
    let n = null;
    const i = [], s = [];
    await Promise.all([this._prepareClientMapping(t.addFeatures, null), this._prepareClientMapping(t.updateFeatures, null)]);
    const o = (h) => "objectId" in h && h.objectId != null ? h.objectId : "attributes" in h && h.attributes[r] != null ? h.attributes[r] : null;
    if (t.addFeatures && (n = this._prepareAddFeatures(t.addFeatures)), t.deleteFeatures)
      for (const h of t.deleteFeatures) {
        const f = o(h);
        f != null && i.push(f);
      }
    const a = t.updateFeatures && this._idToClientGraphic ? /* @__PURE__ */ new Map() : null;
    if (t.updateFeatures) {
      for (const h of t.updateFeatures)
        if (s.push(this._serializeFeature(h)), a) {
          const f = o(h);
          f != null && a.set(f, h);
        }
    }
    Lye(n ? n.features : null, s, this.layer.spatialReference);
    const { fullExtent: l, featureEditResults: c } = await this._connection.invoke("applyEdits", { adds: n ? n.features : [], updates: s, deletes: i });
    return this.fullExtent = l, n && n.finish(c.uidToObjectId), this._updateClientGraphicIds(a, c), this._createEditsResult(c);
  }
  async _prepareClientMapping(t, r) {
    if (this._layerOrSourceGeometryType !== "mesh" || t == null)
      return;
    const n = [];
    for (const { geometry: i } of t)
      i == null || i.type !== "mesh" || i.hasExtent || i.loaded || n.push(i.load({ signal: r }));
    n.length && await Promise.all(n);
  }
  _updateClientGraphicIds(t, r) {
    if (this._idToClientGraphic) {
      if (t)
        for (const n of r.updateResults) {
          if (!n.success)
            continue;
          const i = t.get(n.objectId);
          i != null && this._addIdToClientGraphic(i);
        }
      for (const n of r.deleteResults)
        n.success && this._idToClientGraphic.delete(n.objectId);
    }
  }
  _createEditsResult(t) {
    return { addFeatureResults: t.addResults ? t.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: t.updateResults ? t.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: t.deleteResults ? t.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(t) {
    const r = t.success === !0 ? null : t.error || { code: void 0, description: void 0 };
    return { objectId: t.objectId, globalId: t.globalId, error: r ? new G("feature-layer-source:edit-failure", r.description, { code: r.code }) : null };
  }
  _prepareAddFeatures(t) {
    const r = /* @__PURE__ */ new Map(), n = new Array(t.length);
    let i = null;
    for (let o = 0; o < t.length; o++) {
      const a = t[o], l = this._serializeFeature(a);
      i || a.geometry == null || (i = a.geometry.type), n[o] = l, r.set(`${l.uid}`, a);
    }
    const s = this;
    return { features: n, inferredGeometryType: i, finish(o) {
      const a = s.sourceJSON.objectIdField;
      for (const l in o) {
        const c = o[l], h = r.get(l);
        h && (h.attributes || (h.attributes = {}), c === -1 ? delete h.attributes[a] : h.attributes[a] = c, s._addIdToClientGraphic(h));
      }
    } };
  }
  _addIdToClientGraphic(t) {
    if (!this._idToClientGraphic)
      return;
    const r = this.sourceJSON.objectIdField, n = t.attributes && t.attributes[r];
    n != null && this._idToClientGraphic.set(n, t);
  }
  get _layerOrSourceGeometryType() {
    var t, r;
    return ((t = this.layer) == null ? void 0 : t.geometryType) ?? ((r = this.sourceJSON) == null ? void 0 : r.geometryType);
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(t) {
    return this._geometryTypeRequiresClientGraphicMapping(t.type);
  }
  _geometryTypeRequiresClientGraphicMapping(t) {
    return t === "mesh" || t === "multipatch" || t === "extent";
  }
  _serializeFeature(t) {
    const { attributes: r } = t, n = this._geometryForSerialization(t), i = (jye++).toString();
    return n ? { uid: i, geometry: n.toJSON(), attributes: r } : { uid: i, attributes: r };
  }
  _geometryForSerialization(t) {
    const { geometry: r } = t;
    return r == null ? null : this._geometryRequiresClientGraphicMapping(r) ? r.extent ? af.fromExtent(r.extent) : null : r;
  }
  async _startWorker(t) {
    this._connection = await Pie("MemorySourceWorker", { strategy: U("feature-layers-workers") ? "dedicated" : "local", signal: t });
    const { fields: r, spatialReference: n, objectIdField: i, hasM: s, hasZ: o, timeInfo: a } = this.layer, l = this.layer.originOf("spatialReference") === "defaults";
    await this._prepareClientMapping(this.items, t);
    const c = this._prepareAddFeatures(this.items);
    this.handles.add(this.on("before-changes", (y) => {
      NS.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), y.preventDefault();
    }));
    const h = { features: c.features, fields: r && r.map((y) => y.toJSON()), geometryType: dA.toJSON(this._workerGeometryType), hasM: this._layerOrSourceGeometryType !== "mesh" && s, hasZ: this._layerOrSourceGeometryType === "mesh" || o, objectIdField: i, spatialReference: l ? null : n && n.toJSON(), timeInfo: a ? a.toJSON() : null }, f = await this._connection.invoke("load", h, { signal: t });
    for (const y of f.warnings)
      NS.warn(y.message, { layer: this.layer, warning: y });
    f.featureErrors.length && NS.warn(`Encountered ${f.featureErrors.length} validation errors while loading features`, f.featureErrors);
    const m = f.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(c.inferredGeometryType) && (m.geometryType = dA.toJSON(c.inferredGeometryType)), this.sourceJSON = m, this._requiresClientGraphicMapping() && (this._idToClientGraphic = /* @__PURE__ */ new Map()), c.finish(f.assignedObjectIds);
  }
};
u([H3({ Type: vr, ensureType: br(vr) })], Ua.prototype, "itemType", void 0), u([d()], Ua.prototype, "type", void 0), u([d({ constructOnly: !0 })], Ua.prototype, "layer", void 0), u([d({ readOnly: !0 })], Ua.prototype, "_workerGeometryType", null), u([d()], Ua.prototype, "sourceJSON", void 0), Ua = u([E(Hz)], Ua);
function Vye(e) {
  return "portalItem" in e;
}
const zye = (e) => {
  let t = class extends e {
    get apiKey() {
      var r;
      return this._isOverridden("apiKey") ? this._get("apiKey") : Vye(this) ? (r = this.portalItem) == null ? void 0 : r.apiKey : null;
    }
    set apiKey(r) {
      r != null ? this._override("apiKey", r) : (this._clearOverride("apiKey"), this.clear("apiKey", "user"));
    }
  };
  return u([d({ type: String })], t.prototype, "apiKey", null), t = u([E("geoscene.layers.mixins.APIKeyMixin")], t), t;
}, Uye = (e) => {
  let t = class extends e {
    get title() {
      if (this._get("title") && this.originOf("title") !== "defaults")
        return this._get("title");
      if (this.url) {
        const r = gf(this.url);
        if (r != null && r.title)
          return r.title;
      }
      return this._get("title") || "";
    }
    set title(r) {
      this._set("title", r);
    }
    set url(r) {
      this._set("url", hle(r, se.getLogger(this)));
    }
  };
  return u([d()], t.prototype, "title", null), u([d({ type: String })], t.prototype, "url", null), t = u([E("geoscene.layers.mixins.ArcGISService")], t), t;
}, Bye = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.customParameters = null;
    }
  };
  return u([d({ type: Object, json: { write: { overridePolicy: (r) => ({ enabled: !!(r && Object.keys(r).length > 0) }) } } })], t.prototype, "customParameters", void 0), t = u([E("geoscene.layers.mixins.CustomParametersMixin")], t), t;
}, Wz = new Uu.EventEmitter();
function B5e(e, t, r = !1) {
  const n = vs();
  return r = t == null || r, Wz.emit("apply-edits", { serviceUrl: e, layerId: t, mayReceiveServiceEdits: r, result: n.promise }), n;
}
const Jz = "geoscene.layers.mixins.EditBusLayer", Zz = Symbol(Jz);
function q5e(e) {
  return e != null && typeof e == "object" && Zz in e;
}
const qye = (e) => {
  var t;
  let r = class extends e {
    constructor(...n) {
      super(...n), this[t] = !0, this.when().then(() => {
        this.own([Wz.on("apply-edits", (i) => {
          const { serviceUrl: s, layerId: o, mayReceiveServiceEdits: a, result: l } = i, c = s === this.url, h = o != null && this.layerId != null && o === this.layerId;
          if (!c || !h && !a)
            return;
          const f = l.then((m) => {
            var g;
            if (h && (m.addedFeatures.length || m.updatedFeatures.length || m.deletedFeatures.length || m.addedAttachments.length || m.updatedAttachments.length || m.deletedAttachments.length))
              return this.emit("edits", j(m)), m;
            const y = (g = m.editedFeatures) == null ? void 0 : g.find(({ layerId: v }) => v === this.layerId);
            if (y) {
              const { adds: v, updates: b, deletes: w } = y.editedFeatures, x = { edits: null, addedAttachments: [], deletedAttachments: [], updatedAttachments: [], addedFeatures: v ? v.map(({ attributes: $ }) => ({ objectId: this.objectIdField && $[this.objectIdField], globalId: this.globalIdField && $[this.globalIdField] })) : [], deletedFeatures: w ? w.map(({ attributes: $ }) => ({ objectId: this.objectIdField && $[this.objectIdField], globalId: this.globalIdField && $[this.globalIdField] })) : [], updatedFeatures: b ? b.map(({ current: { attributes: $ } }) => ({ objectId: this.objectIdField && $[this.objectIdField], globalId: this.globalIdField && $[this.globalIdField] })) : [], editedFeatures: j(m.editedFeatures), exceededTransferLimit: !1 };
              return this.emit("edits", x), x;
            }
            return { edits: null, addedAttachments: [], deletedAttachments: [], updatedAttachments: [], addedFeatures: [], deletedFeatures: [], updatedFeatures: [], editedFeatures: j(m.editedFeatures), exceededTransferLimit: !1 };
          });
          this.emit("apply-edits", { result: f });
        })]);
      }, () => {
      });
    }
  };
  return t = Zz, r = u([E(Jz)], r), r;
};
var cI;
let eh = cI = class extends re {
  constructor(e) {
    super(e), this.type = "map-layer";
  }
  clone() {
    const { mapLayerId: e, gdbVersion: t } = this;
    return new cI({ mapLayerId: e, gdbVersion: t });
  }
};
u([Ie({ mapLayer: "map-layer" })], eh.prototype, "type", void 0), u([d({ type: Ot, json: { write: !0 } })], eh.prototype, "mapLayerId", void 0), u([d({ type: String, json: { write: !0 } })], eh.prototype, "gdbVersion", void 0), eh = cI = u([E("geoscene.layers.support.source.MapLayerSource")], eh);
var dI;
let Da = dI = class extends re {
  constructor(e) {
    super(e), this.type = "query-table";
  }
  clone() {
    const { workspaceId: e, query: t, oidFields: r, spatialReference: n, geometryType: i } = this, s = { workspaceId: e, query: t, oidFields: r, spatialReference: (n == null ? void 0 : n.clone()) ?? void 0, geometryType: i };
    return new dI(s);
  }
};
u([Ie({ queryTable: "query-table" })], Da.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Da.prototype, "workspaceId", void 0), u([d({ type: String, json: { write: !0 } })], Da.prototype, "query", void 0), u([d({ type: String, json: { write: !0 } })], Da.prototype, "oidFields", void 0), u([d({ type: tt, json: { write: !0 } })], Da.prototype, "spatialReference", void 0), u([Ie(GX)], Da.prototype, "geometryType", void 0), Da = dI = u([E("geoscene.layers.support.source.QueryTableDataSource")], Da);
var pI;
let th = pI = class extends re {
  constructor(e) {
    super(e), this.type = "raster";
  }
  clone() {
    const { workspaceId: e, dataSourceName: t } = this;
    return new pI({ workspaceId: e, dataSourceName: t });
  }
};
u([Ie({ raster: "raster" })], th.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], th.prototype, "dataSourceName", void 0), u([d({ type: String, json: { write: !0 } })], th.prototype, "workspaceId", void 0), th = pI = u([E("geoscene.layers.support.source.RasterDataSource")], th);
var hI;
let Uc = hI = class extends re {
  constructor(e) {
    super(e), this.type = "table";
  }
  clone() {
    const { workspaceId: e, gdbVersion: t, dataSourceName: r } = this;
    return new hI({ workspaceId: e, gdbVersion: t, dataSourceName: r });
  }
};
u([Ie({ table: "table" })], Uc.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], Uc.prototype, "workspaceId", void 0), u([d({ type: String, json: { write: !0 } })], Uc.prototype, "gdbVersion", void 0), u([d({ type: String, json: { write: !0 } })], Uc.prototype, "dataSourceName", void 0), Uc = hI = u([E("geoscene.layers.support.source.TableDataSource")], Uc);
var fI, mI;
const Gye = Mn()({ esriLeftInnerJoin: "left-inner-join", esriLeftOuterJoin: "left-outer-join" });
let _i = fI = class extends re {
  constructor(e) {
    super(e), this.type = "join-table";
  }
  readLeftTableSource(e, t, r) {
    return I4()(e, t, r);
  }
  castLeftTableSource(e) {
    return na(yI(), e);
  }
  readRightTableSource(e, t, r) {
    return I4()(e, t, r);
  }
  castRightTableSource(e) {
    return na(yI(), e);
  }
  clone() {
    const { leftTableKey: e, rightTableKey: t, leftTableSource: r, rightTableSource: n, joinType: i } = this, s = { leftTableKey: e, rightTableKey: t, leftTableSource: (r == null ? void 0 : r.clone()) ?? void 0, rightTableSource: (n == null ? void 0 : n.clone()) ?? void 0, joinType: i };
    return new fI(s);
  }
};
u([Ie({ joinTable: "join-table" })], _i.prototype, "type", void 0), u([d({ type: String, json: { write: !0 } })], _i.prototype, "leftTableKey", void 0), u([d({ type: String, json: { write: !0 } })], _i.prototype, "rightTableKey", void 0), u([d({ json: { write: !0 } })], _i.prototype, "leftTableSource", void 0), u([ce("leftTableSource")], _i.prototype, "readLeftTableSource", null), u([xt("leftTableSource")], _i.prototype, "castLeftTableSource", null), u([d({ json: { write: !0 } })], _i.prototype, "rightTableSource", void 0), u([ce("rightTableSource")], _i.prototype, "readRightTableSource", null), u([xt("rightTableSource")], _i.prototype, "castRightTableSource", null), u([Ie(Gye)], _i.prototype, "joinType", void 0), _i = fI = u([E("geoscene.layers.support.source.JoinTableDataSource")], _i);
let FS = null;
function I4() {
  return FS || (FS = sf({ types: yI() })), FS;
}
let DS = null;
function yI() {
  return DS || (DS = { key: "type", base: null, typeMap: { "data-layer": ro, "map-layer": eh } }), DS;
}
const Hye = { key: "type", base: null, typeMap: { "join-table": _i, "query-table": Da, raster: th, table: Uc } };
let ro = mI = class extends re {
  constructor(e) {
    super(e), this.type = "data-layer";
  }
  clone() {
    const { fields: e, dataSource: t } = this;
    return new mI({ fields: e, dataSource: t });
  }
};
u([Ie({ dataLayer: "data-layer" })], ro.prototype, "type", void 0), u([d({ type: [ZO], json: { write: !0 } })], ro.prototype, "fields", void 0), u([d({ types: Hye, json: { write: !0 } })], ro.prototype, "dataSource", void 0), ro = mI = u([E("geoscene.layers.support.source.DataLayerSource")], ro), ro.from = br(ro);
let Bc = class extends Rt(re) {
  constructor(t) {
    super(t), this.onFields = null, this.operator = null, this.searchTerm = null, this.searchType = null;
  }
};
u([d({ type: [String], json: { write: { enabled: !0, overridePolicy() {
  return { enabled: this.onFields != null && this.onFields.length > 0 };
} } } })], Bc.prototype, "onFields", void 0), u([d({ type: String, json: { write: !0 } })], Bc.prototype, "operator", void 0), u([d({ type: String, json: { write: !0 } })], Bc.prototype, "searchTerm", void 0), u([d({ type: String, json: { write: !0 } })], Bc.prototype, "searchType", void 0), Bc = u([E("geoscene.rest.support.FullTextSearch")], Bc);
const Wye = Bc;
var gI;
const M4 = new et({ count: "count", sum: "sum", min: "min", max: "max", avg: "avg", stddev: "stddev", var: "var", exceedslimit: "exceedslimit", percentile_cont: "percentile-continuous", percentile_disc: "percentile-discrete", EnvelopeAggregate: "envelope-aggregate", CentroidAggregate: "centroid-aggregate", ConvexHullAggregate: "convex-hull-aggregate" });
let Ks = gI = class extends re {
  constructor(e) {
    super(e), this.maxPointCount = void 0, this.maxRecordCount = void 0, this.maxVertexCount = void 0, this.onStatisticField = null, this.outStatisticFieldName = null, this.statisticType = null, this.statisticParameters = null;
  }
  writeStatisticParameters(e, t) {
    this.statisticType !== "percentile-continuous" && this.statisticType !== "percentile-discrete" || (t.statisticParameters = j(e));
  }
  clone() {
    return new gI({ maxPointCount: this.maxPointCount, maxRecordCount: this.maxRecordCount, maxVertexCount: this.maxVertexCount, onStatisticField: this.onStatisticField, outStatisticFieldName: this.outStatisticFieldName, statisticType: this.statisticType, statisticParameters: j(this.statisticParameters) });
  }
};
u([d({ type: Number, json: { write: !0 } })], Ks.prototype, "maxPointCount", void 0), u([d({ type: Number, json: { write: !0 } })], Ks.prototype, "maxRecordCount", void 0), u([d({ type: Number, json: { write: !0 } })], Ks.prototype, "maxVertexCount", void 0), u([d({ type: String, json: { write: !0 } })], Ks.prototype, "onStatisticField", void 0), u([d({ type: String, json: { write: !0 } })], Ks.prototype, "outStatisticFieldName", void 0), u([d({ type: String, json: { read: { source: "statisticType", reader: M4.read }, write: { target: "statisticType", writer: M4.write } } })], Ks.prototype, "statisticType", void 0), u([d({ type: Object })], Ks.prototype, "statisticParameters", void 0), u([ge("statisticParameters")], Ks.prototype, "writeStatisticParameters", null), Ks = gI = u([E("geoscene.rest.support.StatisticDefinition")], Ks);
const Jye = Ks;
var Eh;
const Zye = new et({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), Kye = new et({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let Ce = Eh = class extends re {
  static from(e) {
    return Xw(Eh, e);
  }
  constructor(e) {
    super(e), this.aggregateIds = null, this.cacheHint = void 0, this.compactGeometryEnabled = !1, this.datumTransformation = null, this.defaultSpatialReferenceEnabled = !1, this.distance = void 0, this.dynamicDataSource = void 0, this.formatOf3DObjects = null, this.fullText = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = void 0, this.groupByFieldsForStatistics = null, this.having = null, this.historicMoment = null, this.maxAllowableOffset = void 0, this.maxRecordCountFactor = 1, this.multipatchOption = null, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.outStatistics = null, this.parameterValues = null, this.pixelSize = null, this.quantizationParameters = null, this.rangeValues = null, this.relationParameter = null, this.resultType = null, this.returnCentroid = !1, this.returnDistinctValues = !1, this.returnExceededLimitFeatures = !0, this.returnGeometry = !1, this.returnQueryGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.sourceSpatialReference = null, this.spatialRelationship = "intersects", this.start = void 0, this.sqlFormat = null, this.text = null, this.timeExtent = null, this.timeReferenceUnknownClient = !1, this.units = null, this.where = null;
  }
  castDatumTransformation(e) {
    return typeof e == "number" || typeof e == "object" ? e : null;
  }
  writeHistoricMoment(e, t) {
    t.historicMoment = e && e.getTime();
  }
  writeParameterValues(e, t) {
    if (e) {
      const r = {};
      for (const n in e) {
        const i = e[n];
        Array.isArray(i) ? r[n] = i.map((s) => s instanceof Date ? s.getTime() : s) : i instanceof Date ? r[n] = i.getTime() : r[n] = i;
      }
      t.parameterValues = r;
    }
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10, t.where = "1=1";
  }
  writeWhere(e, t) {
    t.where = e || "1=1";
  }
  clone() {
    return new Eh(j({ aggregateIds: this.aggregateIds, cacheHint: this.cacheHint, compactGeometryEnabled: this.compactGeometryEnabled, datumTransformation: this.datumTransformation, defaultSpatialReferenceEnabled: this.defaultSpatialReferenceEnabled, distance: this.distance, fullText: this.fullText, formatOf3DObjects: this.formatOf3DObjects, gdbVersion: this.gdbVersion, geometry: this.geometry, geometryPrecision: this.geometryPrecision, groupByFieldsForStatistics: this.groupByFieldsForStatistics, having: this.having, historicMoment: this.historicMoment != null ? new Date(this.historicMoment.getTime()) : null, maxAllowableOffset: this.maxAllowableOffset, maxRecordCountFactor: this.maxRecordCountFactor, multipatchOption: this.multipatchOption, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, outStatistics: this.outStatistics, parameterValues: this.parameterValues, pixelSize: this.pixelSize, quantizationParameters: this.quantizationParameters, rangeValues: this.rangeValues, relationParameter: this.relationParameter, resultType: this.resultType, returnDistinctValues: this.returnDistinctValues, returnGeometry: this.returnGeometry, returnCentroid: this.returnCentroid, returnExceededLimitFeatures: this.returnExceededLimitFeatures, returnQueryGeometry: this.returnQueryGeometry, returnM: this.returnM, returnZ: this.returnZ, dynamicDataSource: this.dynamicDataSource, sourceSpatialReference: this.sourceSpatialReference, spatialRelationship: this.spatialRelationship, start: this.start, sqlFormat: this.sqlFormat, text: this.text, timeExtent: this.timeExtent, timeReferenceUnknownClient: this.timeReferenceUnknownClient, units: this.units, where: this.where }));
  }
};
Ce.MAX_MAX_RECORD_COUNT_FACTOR = 5, u([d({ json: { write: !0 } })], Ce.prototype, "aggregateIds", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ce.prototype, "cacheHint", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "compactGeometryEnabled", void 0), u([d({ json: { write: !0 } })], Ce.prototype, "datumTransformation", void 0), u([xt("datumTransformation")], Ce.prototype, "castDatumTransformation", null), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "defaultSpatialReferenceEnabled", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e) => ({ enabled: e > 0 }) } } })], Ce.prototype, "distance", void 0), u([d({ type: ro, json: { write: !0 } })], Ce.prototype, "dynamicDataSource", void 0), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "formatOf3DObjects", void 0), u([d({ type: [Wye], json: { write: { enabled: !0, overridePolicy() {
  return { enabled: this.fullText != null && this.fullText.length > 0 };
} } } })], Ce.prototype, "fullText", void 0), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "gdbVersion", void 0), u([d({ types: Qd, json: { read: Pd, write: !0 } })], Ce.prototype, "geometry", void 0), u([d({ type: Number, json: { write: !0 } })], Ce.prototype, "geometryPrecision", void 0), u([d({ type: [String], json: { write: !0 } })], Ce.prototype, "groupByFieldsForStatistics", void 0), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "having", void 0), u([d({ type: Date })], Ce.prototype, "historicMoment", void 0), u([ge("historicMoment")], Ce.prototype, "writeHistoricMoment", null), u([d({ type: Number, json: { write: !0 } })], Ce.prototype, "maxAllowableOffset", void 0), u([d({ type: Number, cast: (e) => e < 1 ? 1 : e > Eh.MAX_MAX_RECORD_COUNT_FACTOR ? Eh.MAX_MAX_RECORD_COUNT_FACTOR : e, json: { write: { overridePolicy: (e) => ({ enabled: e > 1 }) } } })], Ce.prototype, "maxRecordCountFactor", void 0), u([d({ type: ["xyFootprint"], json: { write: !0 } })], Ce.prototype, "multipatchOption", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Ce.prototype, "num", void 0), u([d({ json: { write: !0 } })], Ce.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], Ce.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], Ce.prototype, "outFields", void 0), u([d({ type: tt, json: { name: "outSR", write: !0 } })], Ce.prototype, "outSpatialReference", void 0), u([d({ type: [Jye], json: { write: { enabled: !0, overridePolicy() {
  return { enabled: this.outStatistics != null && this.outStatistics.length > 0 };
} } } })], Ce.prototype, "outStatistics", void 0), u([d({ json: { write: !0 } })], Ce.prototype, "parameterValues", void 0), u([ge("parameterValues")], Ce.prototype, "writeParameterValues", null), u([d({ type: Re, json: { write: !0 } })], Ce.prototype, "pixelSize", void 0), u([d({ type: zV, json: { write: !0 } })], Ce.prototype, "quantizationParameters", void 0), u([d({ type: [Object], json: { write: !0 } })], Ce.prototype, "rangeValues", void 0), u([d({ type: String, json: { read: { source: "relationParam" }, write: { target: "relationParam", overridePolicy() {
  return { enabled: this.spatialRelationship === "relation" };
} } } })], Ce.prototype, "relationParameter", void 0), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "resultType", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "returnCentroid", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "returnDistinctValues", void 0), u([d({ type: Boolean, json: { default: !0, write: !0 } })], Ce.prototype, "returnExceededLimitFeatures", void 0), u([d({ type: Boolean, json: { write: !0 } })], Ce.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "returnQueryGeometry", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Ce.prototype, "returnZ", void 0), u([d({ type: tt, json: { write: !0 } })], Ce.prototype, "sourceSpatialReference", void 0), u([Ie(Zye, { ignoreUnknown: !1, name: "spatialRel" })], Ce.prototype, "spatialRelationship", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Ce.prototype, "start", void 0), u([ge("start"), ge("num")], Ce.prototype, "writeStart", null), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "sqlFormat", void 0), u([d({ type: String, json: { write: !0 } })], Ce.prototype, "text", void 0), u([d({ type: ha, json: { write: !0 } })], Ce.prototype, "timeExtent", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Ce.prototype, "timeReferenceUnknownClient", void 0), u([Ie(Kye, { ignoreUnknown: !1 }), d({ json: { write: { overridePolicy(e) {
  return { enabled: !!e && this.distance != null && this.distance > 0 };
} } } })], Ce.prototype, "units", void 0), u([d({ type: String, json: { write: { overridePolicy(e) {
  return { enabled: e != null || this.start != null && this.start > 0 };
} } } })], Ce.prototype, "where", void 0), u([ge("where")], Ce.prototype, "writeWhere", null), Ce = Eh = u([E("geoscene.rest.support.Query")], Ce);
const xf = Ce;
var vI;
const jS = new et({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), VS = new et({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let Vo = vI = class extends re {
  constructor(e) {
    super(e), this.where = null, this.geometry = null, this.spatialRelationship = "intersects", this.distance = void 0, this.objectIds = null, this.units = null, this.timeExtent = null;
  }
  createQuery(e = {}) {
    const { where: t, geometry: r, spatialRelationship: n, timeExtent: i, objectIds: s, units: o, distance: a } = this;
    return new xf({ geometry: j(r), objectIds: j(s), spatialRelationship: n, timeExtent: j(i), where: t, units: o, distance: a, ...e });
  }
  clone() {
    const { where: e, geometry: t, spatialRelationship: r, timeExtent: n, objectIds: i, units: s, distance: o } = this;
    return new vI({ geometry: j(t), objectIds: j(i), spatialRelationship: r, timeExtent: j(n), where: e, units: s, distance: o });
  }
};
u([d({ type: String, json: { write: !0 } })], Vo.prototype, "where", void 0), u([d({ types: Qd, json: { write: !0 } })], Vo.prototype, "geometry", void 0), u([d({ type: jS.apiValues, json: { name: "spatialRel", read: { reader: jS.read }, write: { allowNull: !1, writer: jS.write, overridePolicy() {
  return { enabled: this.geometry != null };
} } } })], Vo.prototype, "spatialRelationship", void 0), u([d({ type: Number, json: { write: { overridePolicy(e) {
  return { enabled: e != null && this.geometry != null };
} } } })], Vo.prototype, "distance", void 0), u([d({ type: [Number], json: { write: !0 } })], Vo.prototype, "objectIds", void 0), u([d({ type: VS.apiValues, json: { read: VS.read, write: { writer: VS.write, overridePolicy(e) {
  return { enabled: e != null && this.geometry != null };
} } } })], Vo.prototype, "units", void 0), u([d({ type: ha, json: { write: !0 } })], Vo.prototype, "timeExtent", void 0), Vo = vI = u([E("geoscene.layers.support.FeatureFilter")], Vo);
const Yye = Vo;
var bI;
const O4 = { read: { reader: LO }, write: { writer: NO, overridePolicy() {
  return { allowNull: this.excludedEffect != null, isRequired: this.excludedEffect == null };
} } }, C4 = { read: { reader: LO }, write: { writer: NO, overridePolicy() {
  return { allowNull: this.includedEffect != null, isRequired: this.includedEffect == null };
} } }, k4 = { name: "showExcludedLabels", default: !0 };
let qc = bI = class extends re {
  constructor(e) {
    super(e), this.filter = null, this.includedEffect = null, this.excludedEffect = null, this.excludedLabelsVisible = !1;
  }
  write(e, t) {
    var n, i;
    const r = super.write(e, t);
    if (t != null && t.origin) {
      if (r.filter) {
        const s = Object.keys(r.filter);
        if (s.length > 1 || s[0] !== "where")
          return (n = t.messages) == null || n.push(new G("web-document-write:unsupported-feature-effect", "Invalid feature effect 'filter'. A filter can only contain a 'where' property", { layer: t.layer, effect: this })), null;
      }
      if ("showExcludedLabels" in r)
        return (i = t.messages) == null || i.push(new G("web-document-write:unsupported-feature-effect", "Invalid value for property 'excludedLabelsVisible' which should always be 'true'", { layer: t.layer, effect: this })), null;
    }
    return r;
  }
  clone() {
    return new bI({ filter: this.filter != null ? this.filter.clone() : null, includedEffect: this.includedEffect, excludedEffect: this.excludedEffect, excludedLabelsVisible: this.excludedLabelsVisible });
  }
};
u([d({ type: Yye, json: { write: { allowNull: !0, writer(e, t, r, n) {
  const i = e == null ? void 0 : e.write({}, n);
  i && Object.keys(i).length !== 0 ? In(r, i, t) : In(r, null, t);
} } } })], qc.prototype, "filter", void 0), u([d({ json: { write: !0, origins: { "web-map": O4, "portal-item": O4 } } })], qc.prototype, "includedEffect", void 0), u([d({ json: { write: !0, origins: { "web-map": C4, "portal-item": C4 } } })], qc.prototype, "excludedEffect", void 0), u([d({ type: Boolean, json: { write: !0, name: "showExcludedLabels", origins: { "web-map": k4, "portal-item": k4 } } })], qc.prototype, "excludedLabelsVisible", void 0), qc = bI = u([E("geoscene.layers.support.FeatureEffect")], qc);
const Qye = qc, A4 = { write: { allowNull: !0 } }, Xye = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.featureEffect = null;
    }
  };
  return u([d({ type: Qye, json: { origins: { "web-map": A4, "portal-item": A4 } } })], t.prototype, "featureEffect", void 0), t = u([E("geoscene.layers.mixins.FeatureEffectLayer")], t), t;
};
function ege(e) {
  if (!e)
    return e;
  const { start: t, end: r } = e;
  return new ha({ start: t != null ? bd(t, -t.getTimezoneOffset(), "minutes") : t, end: r != null ? bd(r, -r.getTimezoneOffset(), "minutes") : r });
}
function tge(e) {
  if (!e)
    return e;
  const { start: t, end: r } = e;
  return new ha({ start: t != null ? bd(t, t.getTimezoneOffset(), "minutes") : t, end: r != null ? bd(r, r.getTimezoneOffset(), "minutes") : r });
}
const rge = { type: Boolean, value: !0, json: { origins: { service: { read: !1, write: !1 }, "web-map": { read: !1, write: !1 } }, name: "screenSizePerspective", write: !0 } }, KO = { type: Boolean, value: !0, json: { name: "disablePopup", read: { reader: (e, t) => !t.disablePopup }, write: { enabled: !0, writer(e, t, r) {
  t[r] = !e;
} } } }, YO = { type: Boolean, value: !0, nonNullable: !0, json: { name: "showLabels", write: !0 } }, nge = { type: String, json: { origins: { "portal-item": { write: !1 } }, write: { isRequired: !0, ignoreOrigin: !0, writer: Nd } } }, ige = { type: Boolean, value: !0, nonNullable: !0, json: { origins: { service: { read: { enabled: !1 } } }, name: "showLegend", write: !0 } }, sge = { value: null, type: oz, json: { origins: { service: { name: "elevationInfo", write: !0 } }, name: "layerDefinition.elevationInfo", write: !0 } };
function H5e(e) {
  return { type: e, readOnly: !0, json: { origins: { service: { read: !0 } }, read: !1 } };
}
const Kz = { write: !0, read: !0 }, wI = { type: Number, json: { origins: { "web-document": Kz, "portal-item": { write: !0 } } } }, oge = { ...wI, json: { ...wI.json, origins: { "web-document": { ...Kz, write: { enabled: !0, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } } } }, read: { source: ["layerDefinition.drawingInfo.transparency", "drawingInfo.transparency"], reader: (e, t, r) => r && r.origin !== "service" || !t.drawingInfo || t.drawingInfo.transparency === void 0 ? t.layerDefinition && t.layerDefinition.drawingInfo && t.layerDefinition.drawingInfo.transparency !== void 0 ? Zy(t.layerDefinition.drawingInfo.transparency) : void 0 : Zy(t.drawingInfo.transparency) } } }, W5e = { type: ha, readOnly: !0, get() {
  var a, l;
  if (!((a = this.layer) != null && a.timeInfo))
    return null;
  const { datesInUnknownTimezone: e, timeOffset: t, useViewTime: r } = this.layer, n = (l = this.view) == null ? void 0 : l.timeExtent;
  let i = this.layer.timeExtent;
  e && (i = tge(i));
  let s = r ? n && i ? n.intersection(i) : n || i : i;
  if (!s || s.isEmpty || s.isAllTime)
    return s;
  t && (s = s.offset(-t.value, t.unit)), e && (s = ege(s));
  const o = this._get("timeExtent");
  return s.equals(o) ? o : s;
} }, J5e = { type: Ct, readOnly: !0, json: { origins: { service: { read: { source: ["fullExtent", "spatialReference"], reader: (e, t) => {
  const r = Ct.fromJSON(e);
  return t.spatialReference != null && typeof t.spatialReference == "object" && (r.spatialReference = tt.fromJSON(t.spatialReference)), r;
} } } }, read: !1 } }, age = { type: String, json: { origins: { service: { read: !1 }, "portal-item": { read: !1 } } } }, lge = { type: Number, json: { origins: { service: { write: { enabled: !1 } } }, read: { source: "layerDefinition.minScale" }, write: { target: "layerDefinition.minScale" } } }, uge = { type: Number, json: { origins: { service: { write: { enabled: !1 } } }, read: { source: "layerDefinition.maxScale" }, write: { target: "layerDefinition.maxScale" } } }, Yz = { json: { write: { ignoreOrigin: !0 }, origins: { "web-map": { read: !1, write: !1 } } } };
let ja = class extends Rt(re) {
  constructor(t) {
    super(t), this.creatorField = null, this.creationDateField = null, this.editorField = null, this.editDateField = null, this.realm = null, this.dateFieldsTimeReference = null;
  }
};
u([d()], ja.prototype, "creatorField", void 0), u([d()], ja.prototype, "creationDateField", void 0), u([d()], ja.prototype, "editorField", void 0), u([d()], ja.prototype, "editDateField", void 0), u([d()], ja.prototype, "realm", void 0), u([d({ type: Uh })], ja.prototype, "dateFieldsTimeReference", void 0), ja = u([E("geoscene.layers.support.EditFieldsInfo")], ja);
const cge = ja;
let Bo = class extends Rt(re) {
  constructor(t) {
    super(t);
  }
};
u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "name", void 0), u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "fields", void 0), u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "isAscending", void 0), u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "indexType", void 0), u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "isUnique", void 0), u([d({ constructOnly: !0, json: { write: !0 } })], Bo.prototype, "description", void 0), Bo = u([E("geoscene.layers.support.FeatureIndex")], Bo);
var _I;
let Yr = _I = class extends re {
  constructor(e) {
    super(e), this.attachmentTypes = null, this.attachmentsWhere = null, this.cacheHint = void 0, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.returnMetadata = !1, this.size = null, this.start = null, this.where = null;
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10;
  }
  clone() {
    return new _I(j({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, cacheHint: this.cacheHint, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
};
u([d({ type: [String], json: { write: !0 } })], Yr.prototype, "attachmentTypes", void 0), u([d({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], Yr.prototype, "attachmentsWhere", void 0), u([d({ type: Boolean, json: { write: !0 } })], Yr.prototype, "cacheHint", void 0), u([d({ type: [String], json: { write: !0 } })], Yr.prototype, "keywords", void 0), u([d({ type: [Number], json: { write: !0 } })], Yr.prototype, "globalIds", void 0), u([d({ json: { write: !0 } })], Yr.prototype, "name", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Yr.prototype, "num", void 0), u([d({ type: [Number], json: { write: !0 } })], Yr.prototype, "objectIds", void 0), u([d({ type: Boolean, json: { default: !1, write: !0 } })], Yr.prototype, "returnMetadata", void 0), u([d({ type: [Number], json: { write: !0 } })], Yr.prototype, "size", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Yr.prototype, "start", void 0), u([ge("start"), ge("num")], Yr.prototype, "writeStart", null), u([d({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], Yr.prototype, "where", void 0), Yr = _I = u([E("geoscene.rest.support.AttachmentQuery")], Yr), Yr.from = br(Yr);
const dge = Yr;
var SI;
let Qt = SI = class extends re {
  constructor(e) {
    super(e), this.cacheHint = void 0, this.dynamicDataSource = void 0, this.gdbVersion = null, this.geometryPrecision = void 0, this.historicMoment = null, this.maxAllowableOffset = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.relationshipId = void 0, this.start = void 0, this.num = void 0, this.returnGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.where = null;
  }
  _writeHistoricMoment(e, t) {
    t.historicMoment = e && e.getTime();
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10, this.start > 0 && this.where == null && (t.definitionExpression = "1=1");
  }
  clone() {
    return new SI(j({ cacheHint: this.cacheHint, dynamicDataSource: this.dynamicDataSource, gdbVersion: this.gdbVersion, geometryPrecision: this.geometryPrecision, historicMoment: this.historicMoment && new Date(this.historicMoment.getTime()), maxAllowableOffset: this.maxAllowableOffset, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, relationshipId: this.relationshipId, start: this.start, num: this.num, returnGeometry: this.returnGeometry, where: this.where, returnZ: this.returnZ, returnM: this.returnM }));
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Qt.prototype, "cacheHint", void 0), u([d({ type: ro, json: { write: !0 } })], Qt.prototype, "dynamicDataSource", void 0), u([d({ type: String, json: { write: !0 } })], Qt.prototype, "gdbVersion", void 0), u([d({ type: Number, json: { write: !0 } })], Qt.prototype, "geometryPrecision", void 0), u([d({ type: Date })], Qt.prototype, "historicMoment", void 0), u([ge("historicMoment")], Qt.prototype, "_writeHistoricMoment", null), u([d({ type: Number, json: { write: !0 } })], Qt.prototype, "maxAllowableOffset", void 0), u([d({ type: [Number], json: { write: !0 } })], Qt.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], Qt.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], Qt.prototype, "outFields", void 0), u([d({ type: tt, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], Qt.prototype, "outSpatialReference", void 0), u([d({ json: { write: !0 } })], Qt.prototype, "relationshipId", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Qt.prototype, "start", void 0), u([ge("start"), ge("num")], Qt.prototype, "writeStart", null), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Qt.prototype, "num", void 0), u([d({ json: { write: !0 } })], Qt.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Qt.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Qt.prototype, "returnZ", void 0), u([d({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], Qt.prototype, "where", void 0), Qt = SI = u([E("geoscene.rest.support.RelationshipQuery")], Qt), Qt.from = br(Qt);
const QO = Qt, Y5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: QO
}, Symbol.toStringTag, { value: "Module" })), $I = new et({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function pge(e, t, r, n) {
  const i = await Zu(e);
  if (await XO(e, t, n), !i.addAttachment)
    throw new G(n, "Layer source does not support addAttachment capability");
  return i.addAttachment(t, r);
}
function XO(e, t, r) {
  const { attributes: n } = t, { objectIdField: i } = e;
  return e.get("capabilities.data.supportsAttachment") ? t ? n ? i && n[i] ? Promise.resolve() : Promise.reject(new G(r, `feature is missing the identifying attribute ${i}`)) : Promise.reject(new G(r, "'attributes' are required on a feature to query attachments")) : Promise.reject(new G(r, "A feature is required to add/delete/update attachments")) : Promise.reject(new G(r, "this layer doesn't support attachments"));
}
async function hge(e, t, r, n, i) {
  const s = await Zu(e);
  if (await XO(e, t, i), !s.updateAttachment)
    throw new G(i, "Layer source does not support updateAttachment capability");
  return s.updateAttachment(t, r, n);
}
async function fge(e, t, r) {
  const { applyEdits: n } = await import("./editingSupport-sADRji8_.js"), i = await e.load();
  return n(i, i.source, t, r);
}
async function mge(e, t, r) {
  const { uploadAssets: n } = await import("./editingSupport-sADRji8_.js"), i = await e.load();
  return n(i, i.source, t, r);
}
async function yge(e, t, r, n) {
  const i = await Zu(e);
  if (await XO(e, t, n), !i.deleteAttachments)
    throw new G(n, "Layer source does not support deleteAttachments capability");
  return i.deleteAttachments(t, r);
}
async function gge(e, t, r) {
  const n = (await e.load({ signal: t == null ? void 0 : t.signal })).source;
  if (!n.fetchRecomputedExtents)
    throw new G(r, "Layer source does not support fetchUpdates capability");
  return n.fetchRecomputedExtents(t);
}
async function vge(e, t, r, n) {
  var y, g;
  t = dge.from(t), await e.load();
  const i = e.source, s = e.capabilities;
  if (!((y = s == null ? void 0 : s.data) != null && y.supportsAttachment))
    throw new G(n, "this layer doesn't support attachments");
  const { attachmentTypes: o, objectIds: a, globalIds: l, num: c, size: h, start: f, where: m } = t;
  if (!((g = s == null ? void 0 : s.operations) != null && g.supportsQueryAttachments) && ((o == null ? void 0 : o.length) > 0 || (l == null ? void 0 : l.length) > 0 || (h == null ? void 0 : h.length) > 0 || c || f || m))
    throw new G(n, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", t);
  if (!(a != null && a.length || l != null && l.length || m))
    throw new G(n, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", t);
  if (!i.queryAttachments)
    throw new G(n, "Layer source does not support queryAttachments capability", t);
  return i.queryAttachments(t);
}
async function bge(e, t, r, n) {
  const i = await Zu(e);
  if (!i.queryObjectIds)
    throw new G(n, "Layer source does not support queryObjectIds capability");
  return i.queryObjectIds(xf.from(t) ?? e.createQuery(), r);
}
async function wge(e, t, r, n) {
  const i = await Zu(e);
  if (!i.queryFeatureCount)
    throw new G(n, "Layer source does not support queryFeatureCount capability");
  return i.queryFeatureCount(xf.from(t) ?? e.createQuery(), r);
}
async function _ge(e, t, r, n) {
  const i = await Zu(e);
  if (!i.queryExtent)
    throw new G(n, "Layer source does not support queryExtent capability");
  return i.queryExtent(xf.from(t) ?? e.createQuery(), r);
}
async function Sge(e, t, r, n) {
  const i = await Zu(e);
  if (!i.queryRelatedFeatures)
    throw new G(n, "Layer source does not support queryRelatedFeatures capability");
  return i.queryRelatedFeatures(QO.from(t), r);
}
async function $ge(e, t, r, n) {
  const i = await Zu(e);
  if (!i.queryRelatedFeaturesCount)
    throw new G(n, "Layer source does not support queryRelatedFeaturesCount capability");
  return i.queryRelatedFeaturesCount(QO.from(t), r);
}
async function xge(e) {
  const t = e.source;
  if (t != null && t.refresh)
    try {
      const { dataChanged: r, updates: n } = await t.refresh();
      if (n != null && (e.sourceJSON = { ...e.sourceJSON, ...n }, e.read(n, { origin: "service", url: e.parsedUrl })), r)
        return !0;
    } catch {
    }
  if (e.definitionExpression)
    try {
      return (await wye(e.definitionExpression, e.fieldsIndex)).hasDateFunctions;
    } catch {
    }
  return !1;
}
function Tge(e) {
  const t = new xf(), r = e.get("capabilities.data"), n = e.get("capabilities.query");
  t.historicMoment = e.historicMoment, t.gdbVersion = e.gdbVersion, t.returnGeometry = !0, n && (t.compactGeometryEnabled = n.supportsCompactGeometry, t.defaultSpatialReferenceEnabled = n.supportsDefaultSpatialReference), r && (r.supportsZ && e.returnZ != null && (t.returnZ = e.returnZ), r.supportsM && e.returnM != null && (t.returnM = e.returnM)), t.outFields = ["*"];
  const { timeOffset: i, timeExtent: s } = e;
  return t.timeExtent = i != null && s != null ? s.offset(-i.value, i.unit) : s || null, t.multipatchOption = e.geometryType === "multipatch" ? "xyFootprint" : null, t;
}
function Qz(e) {
  const { globalIdField: t, fields: r } = e;
  if (t)
    return t;
  if (r) {
    for (const n of r)
      if (n.type === "esriFieldTypeGlobalID")
        return n.name;
  }
}
function Xz(e) {
  const { objectIdField: t, fields: r } = e;
  if (t)
    return t;
  if (r) {
    for (const n of r)
      if (n.type === "esriFieldTypeOID")
        return n.name;
  }
}
function Ege(e) {
  return e.currentVersion ? e.currentVersion : e.hasOwnProperty("capabilities") || e.hasOwnProperty("drawingInfo") || e.hasOwnProperty("hasAttachments") || e.hasOwnProperty("htmlPopupType") || e.hasOwnProperty("relationships") || e.hasOwnProperty("timeInfo") || e.hasOwnProperty("typeIdField") || e.hasOwnProperty("types") ? 10 : 9.3;
}
async function Zu(e) {
  return (await e.load()).source;
}
async function Ige(e, t) {
  if (!st || st.findCredential(e))
    return;
  let r;
  try {
    const n = await N6(e, t);
    n && (r = await st.checkSignInStatus(`${n}/sharing`));
  } catch {
  }
  if (r)
    try {
      const n = t != null ? t.signal : null;
      await st.getCredential(e, { signal: n });
    } catch {
    }
}
async function Mge(e, t) {
  var n;
  const r = (n = e.parsedUrl) == null ? void 0 : n.path;
  r && Oge(e) && await Ige(r, t);
}
function Oge(e) {
  const t = e.editFieldsInfo;
  return !(!(t != null && t.creatorField) && !(t != null && t.editorField)) || (e.userHasUpdateItemPrivileges ? e.hasUpdateItemRestrictions : !!e.userHasFullEditingPrivileges && e.hasFullEditingRestrictions);
}
function Cge(e) {
  var t;
  return !((t = e.sourceJSON) != null && t.isMultiServicesView) && (e.userHasUpdateItemPrivileges || e.editingEnabled);
}
const zS = sf({ types: Lj });
function eC(e, t) {
  if (e.defaultSymbol)
    return e.types && e.types.length ? new HO({ defaultSymbol: zS(e.defaultSymbol, e, t), field: e.typeIdField, uniqueValueInfos: e.types.map((r) => ({ id: r.id, symbol: zS(r.symbol, r, t) })) }) : new z_({ symbol: zS(e.defaultSymbol, e, t) });
}
let rh = class extends Rt(re) {
  constructor(t) {
    super(t), this.shapeAreaField = null, this.shapeLengthField = null, this.units = null;
  }
};
u([d({ type: String, json: { read: { source: "shapeAreaFieldName" } } })], rh.prototype, "shapeAreaField", void 0), u([d({ type: String, json: { read: { source: "shapeLengthFieldName" } } })], rh.prototype, "shapeLengthField", void 0), u([d({ type: String, json: { read: (e) => oK.read(e) || aK.read(e) } })], rh.prototype, "units", void 0), rh = u([E("geoscene.layers.support.GeometryFieldsInfo")], rh);
const kge = rh;
var xI;
let nh = xI = class extends re {
  constructor(e) {
    super(e), this.floorField = null, this.viewAllMode = !1, this.viewAllLevelIds = new je();
  }
  clone() {
    return new xI({ floorField: this.floorField, viewAllMode: this.viewAllMode, viewAllLevelIds: this.viewAllLevelIds });
  }
};
u([d({ type: String, json: { write: !0 } })], nh.prototype, "floorField", void 0), u([d({ json: { read: !1, write: !1 } })], nh.prototype, "viewAllMode", void 0), u([d({ json: { read: !1, write: !1 } })], nh.prototype, "viewAllLevelIds", void 0), nh = xI = u([E("geoscene.layers.support.LayerFloorInfo")], nh);
const Age = nh, P4 = new et({ esriRelCardinalityOneToOne: "one-to-one", esriRelCardinalityOneToMany: "one-to-many", esriRelCardinalityManyToMany: "many-to-many" }), R4 = new et({ esriRelRoleOrigin: "origin", esriRelRoleDestination: "destination" });
let ns = class extends Rt(re) {
  constructor(t) {
    super(t), this.cardinality = null, this.composite = null, this.id = null, this.keyField = null, this.keyFieldInRelationshipTable = null, this.name = null, this.relatedTableId = null, this.relationshipTableId = null, this.role = null;
  }
};
u([d({ json: { read: P4.read, write: P4.write } })], ns.prototype, "cardinality", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "composite", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "id", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "keyField", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "keyFieldInRelationshipTable", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "name", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "relatedTableId", void 0), u([d({ json: { read: !0, write: !0 } })], ns.prototype, "relationshipTableId", void 0), u([d({ json: { read: R4.read, write: R4.write } })], ns.prototype, "role", void 0), ns = u([E("geoscene.layers.support.Relationship")], ns);
const Pge = ns, Rge = { name: "supportsName", size: "supportsSize", contentType: "supportsContentType", keywords: "supportsKeywords", exifInfo: "supportsExifInfo" };
function Pe(e, t, r) {
  return !!eU(e, t, r);
}
function pv(e, t, r) {
  return eU(e, t, r);
}
function eU(e, t, r) {
  return e && e.hasOwnProperty(t) ? e[t] : r;
}
function Lge(e) {
  var r;
  const t = (r = e == null ? void 0 : e.supportedSpatialAggregationStatistics) == null ? void 0 : r.map((n) => n.toLowerCase());
  return { envelope: !!(t != null && t.includes("envelopeaggregate")), centroid: !!(t != null && t.includes("centroidaggregate")), convexHull: !!(t != null && t.includes("convexhullaggregate")) };
}
function i0(e, t) {
  var n;
  const r = (n = e == null ? void 0 : e.supportedOperationsWithCacheHint) == null ? void 0 : n.map((i) => i.toLowerCase());
  return !!(r != null && r.includes(t.toLowerCase()));
}
function tU(e, t) {
  return { analytics: Nge(e), attachment: Fge(e), data: Dge(e), metadata: jge(e), operations: Vge(e.capabilities, e, t), query: zge(e, t), queryRelated: Uge(e), queryTopFeatures: Bge(e), editing: qge(e) };
}
function Nge(e) {
  return { supportsCacheHint: i0(e.advancedQueryCapabilities, "queryAnalytics") };
}
function Fge(e) {
  const t = e.attachmentProperties, r = { supportsName: !1, supportsSize: !1, supportsContentType: !1, supportsKeywords: !1, supportsExifInfo: !1, supportsCacheHint: i0(e.advancedQueryCapabilities, "queryAttachments"), supportsResize: Pe(e, "supportsAttachmentsResizing", !1) };
  return t && Array.isArray(t) && t.forEach((n) => {
    const i = Rge[n.name];
    i && (r[i] = !!n.isEnabled);
  }), r;
}
function Dge(e) {
  return { isVersioned: Pe(e, "isDataVersioned", !1), supportsAttachment: Pe(e, "hasAttachments", !1), supportsM: Pe(e, "hasM", !1), supportsZ: Pe(e, "hasZ", !1) };
}
function jge(e) {
  return { supportsAdvancedFieldProperties: Pe(e, "supportsFieldDescriptionProperty", !1) };
}
function Vge(e, t, r) {
  const n = e ? e.toLowerCase().split(",").map((m) => m.trim()) : [], i = r ? gf(r) : null, s = n.includes(i != null && i.serverType === "MapServer" ? "data" : "query"), o = n.includes("editing") && !t.datesInUnknownTimezone;
  let a = o && n.includes("create"), l = o && n.includes("delete"), c = o && n.includes("update");
  const h = n.includes("changetracking"), f = t.advancedQueryCapabilities;
  return o && !(a || l || c) && (a = l = c = !0), { supportsCalculate: Pe(t, "supportsCalculate", !1), supportsTruncate: Pe(t, "supportsTruncate", !1), supportsValidateSql: Pe(t, "supportsValidateSql", !1), supportsAdd: a, supportsDelete: l, supportsEditing: o, supportsChangeTracking: h, supportsQuery: s, supportsQueryAnalytics: Pe(f, "supportsQueryAnalytic", !1), supportsQueryAttachments: Pe(f, "supportsQueryAttachments", !1), supportsQueryTopFeatures: Pe(f, "supportsTopFeaturesQuery", !1), supportsResizeAttachments: Pe(t, "supportsAttachmentsResizing", !1), supportsSync: n.includes("sync"), supportsUpdate: c, supportsExceedsLimitStatistics: Pe(t, "supportsExceedsLimitStatistics", !1), supportsAsyncConvert3D: Pe(t, "supportsAsyncConvert3D", !1) };
}
function zge(e, t) {
  const r = e.advancedQueryCapabilities, n = e.ownershipBasedAccessControlForFeatures, i = e.archivingInfo, s = e.currentVersion, o = t == null ? void 0 : t.includes("MapServer"), a = !o || s >= U("mapserver-pbf-version-support"), l = W9(t), c = new Set((e.supportedQueryFormats ?? "").split(",").map((h) => h.toLowerCase().trim()));
  return { supportsStatistics: Pe(r, "supportsStatistics", e.supportsStatistics), supportsPercentileStatistics: Pe(r, "supportsPercentileStatistics", !1), supportsSpatialAggregationStatistics: Pe(r, "supportsSpatialAggregationStatistics", !1), supportedSpatialAggregationStatistics: Lge(r), supportsCentroid: Pe(r, "supportsReturningGeometryCentroid", !1), supportsDistance: Pe(r, "supportsQueryWithDistance", !1), supportsDistinct: Pe(r, "supportsDistinct", e.supportsAdvancedQueries), supportsExtent: Pe(r, "supportsReturningQueryExtent", !1), supportsGeometryProperties: Pe(r, "supportsReturningGeometryProperties", !1), supportsHavingClause: Pe(r, "supportsHavingClause", !1), supportsOrderBy: Pe(r, "supportsOrderBy", e.supportsAdvancedQueries), supportsPagination: Pe(r, "supportsPagination", !1), supportsQuantization: Pe(e, "supportsCoordinatesQuantization", !1), supportsQuantizationEditMode: Pe(e, "supportsQuantizationEditMode", !1), supportsQueryGeometry: Pe(e, "supportsReturningQueryGeometry", !1), supportsResultType: Pe(r, "supportsQueryWithResultType", !1), supportsMaxRecordCountFactor: Pe(r, "supportsMaxRecordCountFactor", !1), supportsSqlExpression: Pe(r, "supportsSqlExpression", !1), supportsStandardizedQueriesOnly: Pe(e, "useStandardizedQueries", !1), supportsTopFeaturesQuery: Pe(r, "supportsTopFeaturesQuery", !1), supportsQueryByOthers: Pe(n, "allowOthersToQuery", !0), supportsHistoricMoment: Pe(i, "supportsQueryWithHistoricMoment", !1), supportsFormatPBF: a && c.has("pbf"), supportsDisjointSpatialRelationship: Pe(r, "supportsDisjointSpatialRel", !1), supportsCacheHint: Pe(r, "supportsQueryWithCacheHint", !1) || i0(r, "query"), supportsDefaultSpatialReference: Pe(r, "supportsDefaultSR", !1), supportsCompactGeometry: l, supportsFullTextSearch: Pe(r, "supportsFullTextSearch", !1), maxRecordCountFactor: pv(e, "maxRecordCountFactor", void 0), maxRecordCount: pv(e, "maxRecordCount", void 0), standardMaxRecordCount: pv(e, "standardMaxRecordCount", void 0), tileMaxRecordCount: pv(e, "tileMaxRecordCount", void 0) };
}
function Uge(e) {
  const t = e.advancedQueryCapabilities, r = Pe(t, "supportsAdvancedQueryRelated", !1);
  return { supportsPagination: Pe(t, "supportsQueryRelatedPagination", !1), supportsCount: r, supportsOrderBy: r, supportsCacheHint: i0(t, "queryRelated") };
}
function Bge(e) {
  return { supportsCacheHint: i0(e.advancedQueryCapabilities, "queryTopFilter") };
}
function qge(e) {
  const t = e.ownershipBasedAccessControlForFeatures, r = e ? e.advancedEditingCapabilities : void 0;
  return { supportsGeometryUpdate: Pe(e, "allowGeometryUpdates", !0), supportsGlobalId: Pe(e, "supportsApplyEditsWithGlobalIds", !1), supportsReturnServiceEditsInSourceSpatialReference: Pe(e, "supportsReturnServiceEditsInSourceSR", !1), supportsRollbackOnFailure: Pe(e, "supportsRollbackOnFailureParameter", !1), supportsUpdateWithoutM: Pe(e, "allowUpdateWithoutMValues", !1), supportsUploadWithItemId: Pe(e, "supportsAttachmentsByUploadId", !1), supportsDeleteByAnonymous: Pe(t, "allowAnonymousToDelete", !0), supportsDeleteByOthers: Pe(t, "allowOthersToDelete", !0), supportsUpdateByAnonymous: Pe(t, "allowAnonymousToUpdate", !0), supportsUpdateByOthers: Pe(t, "allowOthersToUpdate", !0), supportsAsyncApplyEdits: Pe(r, "supportsAsyncApplyEdits", !1) };
}
const Gge = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.capabilities = null, this.copyright = null, this.dateFieldsTimeReference = null, this.datesInUnknownTimezone = !1, this.displayField = null, this.definitionExpression = null, this.editFieldsInfo = null, this.editingInfo = null, this.elevationInfo = null, this.floorInfo = null, this.fullExtent = null, this.gdbVersion = null, this.geometryFieldsInfo = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.heightModelInfo = null, this.historicMoment = null, this.isTable = !1, this.layerId = void 0, this.minScale = 0, this.maxScale = 0, this.globalIdField = null, this.objectIdField = null, this.preferredTimeReference = null, this.relationships = null, this.sourceJSON = null, this.returnM = void 0, this.returnZ = void 0, this.serviceDefinitionExpression = null, this.serviceItemId = null, this.spatialReference = tt.WGS84, this.subtypeField = null, this.trackIdField = null, this.indexes = new (je.ofType(Bo))(), this.version = void 0;
    }
    readCapabilitiesFromService(r, n) {
      return tU(n, this.url);
    }
    get effectiveCapabilities() {
      var o;
      const r = this.capabilities;
      if (!r)
        return null;
      const n = j(r), { operations: i, editing: s } = n;
      return (o = this.sourceJSON) != null && o.isMultiServicesView ? (this.userHasUpdateItemPrivileges && (i.supportsQuery = !0), n) : this.userHasUpdateItemPrivileges ? (i.supportsAdd = i.supportsDelete = i.supportsEditing = i.supportsQuery = i.supportsUpdate = s.supportsDeleteByOthers = s.supportsGeometryUpdate = s.supportsUpdateByOthers = !0, n) : (this.userHasFullEditingPrivileges && i.supportsEditing && (i.supportsAdd = i.supportsDelete = i.supportsUpdate = s.supportsGeometryUpdate = !0), n);
    }
    get hasFullEditingRestrictions() {
      var s;
      const r = this.capabilities;
      if (!r || (s = this.sourceJSON) != null && s.isMultiServicesView)
        return !1;
      const { operations: n, editing: i } = r;
      return n.supportsEditing && !(n.supportsAdd && n.supportsDelete && n.supportsUpdate && i.supportsGeometryUpdate);
    }
    get hasUpdateItemRestrictions() {
      var s;
      const r = this.capabilities;
      if (!r)
        return !1;
      const { operations: n, editing: i } = r;
      return (s = this.sourceJSON) != null && s.isMultiServicesView ? !n.supportsQuery : !(n.supportsAdd && n.supportsDelete && n.supportsEditing && n.supportsQuery && n.supportsUpdate && i.supportsDeleteByOthers && i.supportsGeometryUpdate && i.supportsUpdateByOthers);
    }
    readEditingInfo(r, n) {
      const { editingInfo: i } = n;
      return i ? { lastEditDate: i.lastEditDate != null ? new Date(i.lastEditDate) : null } : null;
    }
    readIsTableFromService(r, n) {
      return n.type === "Table";
    }
    readMinScale(r, n) {
      return n.effectiveMinScale || r || 0;
    }
    readMaxScale(r, n) {
      return n.effectiveMaxScale || r || 0;
    }
    readGlobalIdFieldFromService(r, n) {
      return Qz(n);
    }
    readObjectIdFieldFromService(r, n) {
      return Xz(n);
    }
    readServiceDefinitionExpression(r, n) {
      return n.definitionQuery || n.definitionExpression;
    }
    set url(r) {
      const n = fle({ layer: this, url: r, nonStandardUrlAllowed: !0, logger: se.getLogger(this) });
      this._set("url", n.url), n.layerId != null && this._set("layerId", n.layerId);
    }
    writeUrl(r, n, i, s) {
      mle(this, r, null, n, s);
    }
    readVersion(r, n) {
      return Ege(n);
    }
  };
  return u([d({ readOnly: !0, json: { read: !1, origins: { service: { read: { source: ["advancedQueryCapabilities", "allowGeometryUpdates", "allowUpdateWithoutMValues", "archivingInfo", "capabilities", "datesInUnknownTimezone", "hasAttachments", "hasM", "hasZ", "maxRecordCount", "maxRecordCountFactor", "ownershipBasedAccessControlForFeatures", "standardMaxRecordCount", "supportedQueryFormats", "supportsAdvancedQueries", "supportsApplyEditsWithGlobalIds", "supportsAttachmentsByUploadId", "supportsAttachmentsResizing", "supportsCalculate", "supportsCoordinatesQuantization", "supportsExceedsLimitStatistics", "supportsFieldDescriptionProperty", "supportsQuantizationEditMode", "supportsRollbackOnFailureParameter", "supportsStatistics", "supportsTruncate", "supportsValidateSql", "tileMaxRecordCount", "useStandardizedQueries"] } } } } })], t.prototype, "capabilities", void 0), u([ce("service", "capabilities")], t.prototype, "readCapabilitiesFromService", null), u([d({ readOnly: !0 })], t.prototype, "effectiveCapabilities", null), u([d({ readOnly: !0 })], t.prototype, "hasFullEditingRestrictions", null), u([d({ readOnly: !0 })], t.prototype, "hasUpdateItemRestrictions", null), u([d({ type: String, json: { origins: { service: { read: { source: "copyrightText" } } } } })], t.prototype, "copyright", void 0), u([d({ type: Uh })], t.prototype, "dateFieldsTimeReference", void 0), u([d({ type: Boolean })], t.prototype, "datesInUnknownTimezone", void 0), u([d({ type: String, json: { origins: { service: { read: { source: "displayField" } } } } })], t.prototype, "displayField", void 0), u([d({ type: String, json: { origins: { service: { read: !1, write: !1 } }, name: "layerDefinition.definitionExpression", write: { enabled: !0, allowNull: !0 } } })], t.prototype, "definitionExpression", void 0), u([d({ readOnly: !0, type: cge })], t.prototype, "editFieldsInfo", void 0), u([d({ readOnly: !0 })], t.prototype, "editingInfo", void 0), u([ce("editingInfo")], t.prototype, "readEditingInfo", null), u([d((() => {
    const r = j(sge), n = r.json.origins;
    return n["web-map"] = { read: !1, write: !1 }, n["portal-item"] = { read: !1, write: !1 }, r;
  })())], t.prototype, "elevationInfo", void 0), u([d({ type: Age, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], t.prototype, "floorInfo", void 0), u([d({ type: Ct, json: { origins: { service: { read: { source: "extent" } } } } })], t.prototype, "fullExtent", void 0), u([d()], t.prototype, "gdbVersion", void 0), u([d({ readOnly: !0, type: kge, json: { read: { source: "geometryProperties" } } })], t.prototype, "geometryFieldsInfo", void 0), u([d({ type: ["point", "polygon", "polyline", "multipoint", "multipatch", "mesh"], json: { origins: { service: { read: $I.read } } } })], t.prototype, "geometryType", void 0), u([d({ type: Boolean, json: { origins: { service: { read: !0 } } } })], t.prototype, "hasM", void 0), u([d({ type: Boolean, json: { origins: { service: { read: !0 } } } })], t.prototype, "hasZ", void 0), u([d({ readOnly: !0, type: O_ })], t.prototype, "heightModelInfo", void 0), u([d({ type: Date })], t.prototype, "historicMoment", void 0), u([d({ readOnly: !0 })], t.prototype, "isTable", void 0), u([ce("service", "isTable", ["type"])], t.prototype, "readIsTableFromService", null), u([d({ type: Number, json: { origins: { service: { read: { source: "id" } }, "portal-item": { read: !1, write: { target: "id" } } }, read: !1 } })], t.prototype, "layerId", void 0), u([d(lge)], t.prototype, "minScale", void 0), u([ce("service", "minScale", ["minScale", "effectiveMinScale"])], t.prototype, "readMinScale", null), u([d(uge)], t.prototype, "maxScale", void 0), u([ce("service", "maxScale", ["maxScale", "effectiveMaxScale"])], t.prototype, "readMaxScale", null), u([d({ type: String })], t.prototype, "globalIdField", void 0), u([ce("service", "globalIdField", ["globalIdField", "fields"])], t.prototype, "readGlobalIdFieldFromService", null), u([d({ type: String })], t.prototype, "objectIdField", void 0), u([ce("service", "objectIdField", ["objectIdField", "fields"])], t.prototype, "readObjectIdFieldFromService", null), u([d({ type: Uh })], t.prototype, "preferredTimeReference", void 0), u([d({ type: [Pge], readOnly: !0 })], t.prototype, "relationships", void 0), u([d()], t.prototype, "sourceJSON", void 0), u([d({ type: Boolean })], t.prototype, "returnM", void 0), u([d({ type: Boolean })], t.prototype, "returnZ", void 0), u([d({ readOnly: !0 })], t.prototype, "serviceDefinitionExpression", void 0), u([ce("service", "serviceDefinitionExpression", ["definitionQuery", "definitionExpression"])], t.prototype, "readServiceDefinitionExpression", null), u([d({ type: String, readOnly: !0, json: { read: !1, origins: { service: { read: !0 } } } })], t.prototype, "serviceItemId", void 0), u([d({ type: tt, json: { origins: { service: { read: { source: "extent.spatialReference" } } } } })], t.prototype, "spatialReference", void 0), u([d({ type: String, readOnly: !0, json: { origins: { service: { read: !0 } } } })], t.prototype, "subtypeField", void 0), u([d({ type: String, json: { read: { source: "timeInfo.trackIdField" } } })], t.prototype, "trackIdField", void 0), u([d({ readOnly: !0, json: { write: !1 } })], t.prototype, "serverGens", void 0), u([d({ type: je.ofType(Bo), readOnly: !0 })], t.prototype, "indexes", void 0), u([d(nge)], t.prototype, "url", null), u([ge("url")], t.prototype, "writeUrl", null), u([d({ json: { origins: { service: { read: !0 } }, read: !1 } })], t.prototype, "version", void 0), u([ce("service", "version", ["currentVersion", "capabilities", "drawingInfo", "hasAttachments", "htmlPopupType", "relationships", "timeInfo", "typeIdField", "types"])], t.prototype, "readVersion", null), t = u([E("geoscene.layers.mixins.FeatureLayerBase")], t), t;
};
let ih = class extends Rt(re) {
  constructor(t) {
    super(t), this.expression = null, this.title = null, this.returnType = null;
  }
};
u([d({ type: String, json: { write: !0 } })], ih.prototype, "expression", void 0), u([d({ type: String, json: { write: !0 } })], ih.prototype, "title", void 0), u([d({ type: String, json: { write: !0 } })], ih.prototype, "returnType", void 0), ih = u([E("geoscene.layers.support.ExpressionInfo")], ih);
const tC = ih;
var TI;
let Va = TI = class extends re {
  constructor(e) {
    super(e), this.isAutoGenerated = !1, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new TI({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: j(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Va.prototype, "isAutoGenerated", void 0), u([d({ type: String, json: { write: !0 } })], Va.prototype, "name", void 0), u([d({ type: String, json: { write: !0 } })], Va.prototype, "alias", void 0), u([d({ type: String, json: { write: !0 } })], Va.prototype, "onStatisticField", void 0), u([d({ type: tC, json: { write: !0 } })], Va.prototype, "onStatisticExpression", void 0), u([d({ type: String, json: { write: !0 } })], Va.prototype, "statisticType", void 0), Va = TI = u([E("geoscene.layers.support.AggregateField")], Va);
const zd = Va;
let Ou = class extends re {
  constructor() {
    super(...arguments), this.type = null;
  }
};
u([d({ type: ["selection", "cluster", "binning"], readOnly: !0, json: { read: !1, write: !0 } })], Ou.prototype, "type", void 0), Ou = u([E("geoscene.layers.support.FeatureReduction")], Ou);
const rC = "__begin__", nC = "__end__", Hge = new RegExp(rC, "ig"), Wge = new RegExp(nC, "ig"), L4 = new RegExp("^" + rC, "i"), N4 = new RegExp(nC + "$", "i"), gw = '"', Jge = gw + " + ", Zge = " + " + gw;
function Kge(e) {
  return e.replaceAll(new RegExp("\\[", "g"), "{").replaceAll(new RegExp("\\]", "g"), "}");
}
function Yge(e) {
  return e.replaceAll(new RegExp("\\{", "g"), "[").replaceAll(new RegExp("\\}", "g"), "]");
}
function iC(e) {
  const t = { expression: "", type: "none" };
  return e.labelExpressionInfo ? e.labelExpressionInfo.value ? (t.expression = e.labelExpressionInfo.value, t.type = "conventional") : e.labelExpressionInfo.expression && (t.expression = e.labelExpressionInfo.expression, t.type = "arcade") : e.labelExpression != null && (t.expression = Kge(e.labelExpression), t.type = "conventional"), t;
}
function Qge(e) {
  const t = iC(e);
  if (!t)
    return null;
  switch (t.type) {
    case "conventional":
      return EI(t.expression);
    case "arcade":
      return t.expression;
  }
  return null;
}
function Xge(e) {
  const t = iC(e);
  if (!t)
    return null;
  switch (t.type) {
    case "conventional":
      return t0e(t.expression);
    case "arcade":
      return rU(t.expression);
  }
  return null;
}
function EI(e) {
  let t;
  return e ? (t = Ww(e, (r) => rC + '$feature["' + r + '"]' + nC), t = L4.test(t) ? t.replace(L4, "") : gw + t, t = N4.test(t) ? t.replace(N4, "") : t + gw, t = t.replaceAll(Hge, Jge).replaceAll(Wge, Zge)) : t = '""', t;
}
const e0e = /^\s*\{([^}]+)\}\s*$/i;
function t0e(e) {
  const t = e == null ? void 0 : e.match(e0e);
  return t && t[1].trim() || null;
}
const r0e = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*$/i, n0e = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])(\1|\3)(\5)\s*\));?\s*$/i, i0e = /^\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])([\w\s]+)(\1)\s*\));?\s*$/i;
function rU(e) {
  if (!e)
    return null;
  let t = r0e.exec(e) || n0e.exec(e);
  return t ? t[1] || t[3] : (t = i0e.exec(e), t ? t[2] : null);
}
var II;
let iu = II = class extends re {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(e, t) {
    return t.value ? EI(t.value) : e;
  }
  writeExpression(e, t, r) {
    this.value != null && (e = EI(this.value)), e != null && (t[r] = e);
  }
  clone() {
    return new II({ expression: this.expression, title: this.title, value: this.value });
  }
};
u([d({ type: String, json: { write: { writerEnsuresNonNull: !0 } } })], iu.prototype, "expression", void 0), u([ce("expression", ["expression", "value"])], iu.prototype, "readExpression", null), u([ge("expression")], iu.prototype, "writeExpression", null), u([d({ type: String, json: { write: !0, origins: { "web-scene": { write: !1 } } } })], iu.prototype, "title", void 0), u([d({ json: { read: !1, write: !1 } })], iu.prototype, "value", void 0), iu = II = u([E("geoscene.layers.support.LabelExpressionInfo")], iu);
const nU = iu, iU = [252, 146, 31, 255], s0e = { type: "esriSMS", style: "esriSMSCircle", size: 6, color: iU, outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [153, 153, 153, 255] } }, o0e = { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: iU }, a0e = { type: "esriSFS", style: "esriSFSSolid", color: [252, 146, 31, 196], outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [255, 255, 255, 191] } }, l0e = { type: "esriTS", color: [255, 255, 255, 255], font: { family: "arial-unicode-ms", size: 10, weight: "bold" }, horizontalAlignment: "center", kerning: !0, haloColor: [0, 0, 0, 255], haloSize: 1, rotated: !1, text: "", xoffset: 0, yoffset: 0, angle: 0 }, u0e = { type: "esriSMS", style: "esriSMSCircle", color: [0, 0, 0, 255], outline: null, size: 10.5 }, c0e = { type: "esriSLS", style: "esriSLSSolid", color: [0, 0, 0, 255], width: 1.5 }, d0e = { type: "esriSFS", style: "esriSFSSolid", color: [0, 0, 0, 255], outline: null }, rFe = Hu.fromJSON(s0e), nFe = ji.fromJSON(o0e), iFe = ep.fromJSON(a0e), p0e = mo.fromJSON(l0e), sFe = Hu.fromJSON(u0e), oFe = ji.fromJSON(c0e), aFe = ep.fromJSON(d0e);
var MI;
const hv = new et({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: !0 });
function fv(e, t, r) {
  return { enabled: !L6(r == null ? void 0 : r.layer) };
}
function sU(e) {
  var t;
  return !e || e.origin !== "service" && ((t = e.layer) == null ? void 0 : t.type) !== "map-image";
}
function h0e(e) {
  return (e == null ? void 0 : e.type) === "map-image";
}
function oU(e) {
  var t, r;
  return !!h0e(e) && !!((r = (t = e.capabilities) == null ? void 0 : t.exportMap) != null && r.supportsArcadeExpressionForLabeling);
}
function f0e(e) {
  return sU(e) || oU(e == null ? void 0 : e.layer);
}
let fr = MI = class extends re {
  static evaluateWhere(e, t) {
    const r = (n, i, s) => {
      switch (i) {
        case "=":
          return n == s;
        case "<>":
          return n != s;
        case ">":
          return n > s;
        case ">=":
          return n >= s;
        case "<":
          return n < s;
        case "<=":
          return n <= s;
      }
      return !1;
    };
    try {
      if (e == null)
        return !0;
      const n = e.split(" ");
      if (n.length === 3)
        return r(t[n[0]], n[1], n[2]);
      if (n.length === 7) {
        const i = r(t[n[0]], n[1], n[2]), s = n[3], o = r(t[n[4]], n[5], n[6]);
        switch (s) {
          case "AND":
            return i && o;
          case "OR":
            return i || o;
        }
      }
      return !1;
    } catch {
      console.log("Error.: can't parse = " + e);
    }
  }
  constructor(e) {
    super(e), this.type = "label", this.name = null, this.allowOverrun = !1, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = !0, this.repeatLabelDistance = null, this.symbol = p0e, this.useCodedValues = void 0, this.where = null;
  }
  readLabelExpression(e, t) {
    const r = t.labelExpressionInfo;
    if (!r || !r.value && !r.expression)
      return e;
  }
  writeLabelExpression(e, t, r) {
    if (this.labelExpressionInfo) {
      if (this.labelExpressionInfo.value != null)
        e = Yge(this.labelExpressionInfo.value);
      else if (this.labelExpressionInfo.expression != null) {
        const n = rU(this.labelExpressionInfo.expression);
        n && (e = "[" + n + "]");
      }
    }
    e != null && (t[r] = e);
  }
  writeLabelExpressionInfo(e, t, r, n) {
    if (e == null && this.labelExpression != null && sU(n))
      e = new nU({ expression: this.getLabelExpressionArcade() });
    else if (!e)
      return;
    const i = e.toJSON(n);
    i.expression && (t[r] = i);
  }
  writeMaxScale(e, t) {
    (e || this.minScale) && (t.maxScale = e);
  }
  writeMinScale(e, t) {
    (e || this.maxScale) && (t.minScale = e);
  }
  getLabelExpression() {
    return iC(this);
  }
  getLabelExpressionArcade() {
    return Qge(this);
  }
  getLabelExpressionSingleField() {
    return Xge(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new MI({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: j(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: j(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
};
u([d({ type: String, json: { write: !0 } })], fr.prototype, "name", void 0), u([d({ type: Boolean, json: { write: !0, default: !1, origins: { "web-scene": { write: !1 }, "portal-item": { default: !1, write: { overridePolicy: fv } } } } })], fr.prototype, "allowOverrun", void 0), u([d({ type: String, json: { write: !0, default: "static", origins: { "web-scene": { write: !1 }, "portal-item": { default: "static", write: { overridePolicy: fv } } } } })], fr.prototype, "deconflictionStrategy", void 0), u([d({ type: String, json: { write: { overridePolicy(e, t, r) {
  return this.labelExpressionInfo && (r == null ? void 0 : r.origin) === "service" && oU(r.layer) ? { enabled: !1 } : { allowNull: !0 };
} } } })], fr.prototype, "labelExpression", void 0), u([ce("labelExpression")], fr.prototype, "readLabelExpression", null), u([ge("labelExpression")], fr.prototype, "writeLabelExpression", null), u([d({ type: nU, json: { write: { overridePolicy: (e, t, r) => f0e(r) ? { allowNull: !0 } : { enabled: !1 } } } })], fr.prototype, "labelExpressionInfo", void 0), u([ge("labelExpressionInfo")], fr.prototype, "writeLabelExpressionInfo", null), u([d({ type: hv.apiValues, json: { type: hv.jsonValues, read: hv.read, write: hv.write } })], fr.prototype, "labelPlacement", void 0), u([d({ type: ["curved", "parallel"], json: { write: !0, origins: { "web-map": { write: !1 }, "web-scene": { write: !1 }, "portal-item": { write: !1 } } } })], fr.prototype, "labelPosition", void 0), u([d({ type: Number })], fr.prototype, "maxScale", void 0), u([ge("maxScale")], fr.prototype, "writeMaxScale", null), u([d({ type: Number })], fr.prototype, "minScale", void 0), u([ge("minScale")], fr.prototype, "writeMinScale", null), u([d({ type: Boolean, json: { write: !0, origins: { "web-scene": { write: !1 }, "portal-item": { write: { overridePolicy: fv } } } } })], fr.prototype, "repeatLabel", void 0), u([d({ type: Number, cast: ut, json: { write: !0, origins: { "web-scene": { write: !1 }, "portal-item": { write: { overridePolicy: fv } } } } })], fr.prototype, "repeatLabelDistance", void 0), u([d({ types: Xne, json: { origins: { "web-scene": { types: eie, write: i4, default: null } }, write: i4, default: null } })], fr.prototype, "symbol", void 0), u([d({ type: Boolean, json: { write: !0 } })], fr.prototype, "useCodedValues", void 0), u([d({ type: String, json: { write: !0 } })], fr.prototype, "where", void 0), fr = MI = u([E("geoscene.layers.support.LabelClass")], fr);
const q_ = fr;
var OI;
const m0e = "geoscene.layers.support.FeatureReductionBinning";
let Fn = OI = class extends Ou {
  constructor(e) {
    super(e), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = 3, this.labelingInfo = null, this.labelsVisible = !0, this.maxScale = 0, this.popupEnabled = !0, this.popupTemplate = null, this.fields = [], this.renderer = null;
  }
  writeFields(e, t, r) {
    const n = e.filter((i) => i.statisticType !== "avg_angle").map((i) => i.toJSON());
    In(r, n, t);
  }
  readRenderer(e, t, r) {
    var i;
    const n = (i = t.drawingInfo) == null ? void 0 : i.renderer;
    return n ? yg(n, t, r) ?? void 0 : eC(t, r);
  }
  clone() {
    return new OI({ fields: j(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: j(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: j(this.popupTemplate), renderer: j(this.renderer) });
  }
};
u([Ie({ binning: "binning" })], Fn.prototype, "type", void 0), u([Ie({ geohash: "geohash" })], Fn.prototype, "binType", void 0), u([d({ type: Number, range: { min: 1, max: 9 }, json: { write: !0 } })], Fn.prototype, "fixedBinLevel", void 0), u([d({ type: [q_], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], Fn.prototype, "labelingInfo", void 0), u([d(YO)], Fn.prototype, "labelsVisible", void 0), u([d({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], Fn.prototype, "maxScale", void 0), u([d(KO)], Fn.prototype, "popupEnabled", void 0), u([d({ type: zg, json: { name: "popupInfo", write: !0 } })], Fn.prototype, "popupTemplate", void 0), u([d({ type: [zd], json: { write: !0 } })], Fn.prototype, "fields", void 0), u([ge("fields")], Fn.prototype, "writeFields", null), u([d({ types: U_, json: { write: { target: "drawingInfo.renderer" } } })], Fn.prototype, "renderer", void 0), u([ce("renderer", ["drawingInfo.renderer"])], Fn.prototype, "readRenderer", null), Fn = OI = u([E(m0e)], Fn);
const aU = Fn;
var CI;
const y0e = "geoscene.layers.support.FeatureReductionCluster";
function F4(e) {
  var t;
  return e.type === "simple" && !((t = e.visualVariables) != null && t.length);
}
let Er = CI = class extends re {
  constructor(e) {
    super(e), this.type = "cluster", this.clusterRadius = ut("80px"), this.clusterMinSize = ut("12px"), this.clusterMaxSize = ut("50px"), this.maxScale = 0, this.popupEnabled = !0, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = !0, this.fields = null;
  }
  readRenderer(e, t, r) {
    var i, s;
    const n = (i = t.drawingInfo) == null ? void 0 : i.renderer;
    return (s = n == null ? void 0 : n.authoringInfo) != null && s.isAutoGenerated ? null : n ? F4(n) ? null : yg(n, t, r) ?? void 0 : eC(t, r);
  }
  readSymbol(e, t, r) {
    var i, s;
    const n = (i = t.drawingInfo) == null ? void 0 : i.renderer;
    if ((s = n == null ? void 0 : n.authoringInfo) != null && s.isAutoGenerated)
      return null;
    if (n && F4(n)) {
      const o = yg(n, t, r);
      return o == null ? void 0 : o.symbol;
    }
    return null;
  }
  writeSymbol(e, t, r, n) {
    var s, o;
    const i = (o = (s = this.renderer) == null ? void 0 : s.authoringInfo) == null ? void 0 : o.isAutoGenerated;
    if (!this.renderer || i) {
      const a = new z_({ symbol: e });
      t.drawingInfo = { renderer: a.write({}, n) };
    }
  }
  writeFields(e, t, r) {
    const n = e.filter((i) => i.statisticType !== "avg_angle").map((i) => i.toJSON());
    In(r, n, t);
  }
  readFields(e, t, r) {
    return e.filter((n) => !n.isAutoGenerated).map((n) => zd.fromJSON(n));
  }
  clone() {
    return new CI({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: j(this.labelingInfo), labelsVisible: this.labelsVisible, fields: j(this.fields), maxScale: this.maxScale, renderer: j(this.renderer), symbol: j(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: j(this.popupTemplate) });
  }
};
u([d({ type: ["cluster"], readOnly: !0, json: { write: !0 } })], Er.prototype, "type", void 0), u([d({ type: Number, cast: (e) => e === "auto" ? e : ut(e), json: { write: !0 } })], Er.prototype, "clusterRadius", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Er.prototype, "clusterMinSize", void 0), u([d({ type: Number, cast: ut, json: { write: !0 } })], Er.prototype, "clusterMaxSize", void 0), u([d({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], Er.prototype, "maxScale", void 0), u([d(KO)], Er.prototype, "popupEnabled", void 0), u([d({ type: zg, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], Er.prototype, "popupTemplate", void 0), u([d({ types: U_, json: { write: { target: "drawingInfo.renderer" } } })], Er.prototype, "renderer", void 0), u([ce("renderer", ["drawingInfo.renderer"])], Er.prototype, "readRenderer", null), u([d({ types: Yne })], Er.prototype, "symbol", void 0), u([ce("symbol", ["drawingInfo.renderer"])], Er.prototype, "readSymbol", null), u([ge("symbol")], Er.prototype, "writeSymbol", null), u([d({ type: [q_], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], Er.prototype, "labelingInfo", void 0), u([d(YO)], Er.prototype, "labelsVisible", void 0), u([d({ type: [zd], json: { write: !0 } })], Er.prototype, "fields", void 0), u([ge("fields")], Er.prototype, "writeFields", null), u([ce("fields")], Er.prototype, "readFields", null), Er = CI = u([E(y0e)], Er);
const lU = Er;
var kI;
let U1 = kI = class extends Ou {
  constructor(e) {
    super(e), this.type = "selection";
  }
  clone() {
    return new kI();
  }
};
u([d({ type: ["selection"] })], U1.prototype, "type", void 0), U1 = kI = u([E("geoscene.layers.support.FeatureReductionSelection")], U1);
const D4 = U1, j4 = { key: "type", base: Ou, typeMap: { cluster: lU, binning: aU } }, g0e = { types: { key: "type", base: Ou, typeMap: { selection: D4, cluster: lU, binning: aU } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: !0 }, origins: { "web-map": { types: j4 }, "portal-item": { types: j4 }, "web-scene": { types: { key: "type", base: Ou, typeMap: { selection: D4 } } } } } }, bp = { Base64: 0, Hex: 1, String: 2, Raw: 3 }, Ih = 8, uU = (1 << Ih) - 1;
function xu(e, t) {
  const r = (65535 & e) + (65535 & t);
  return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r;
}
function v0e(e) {
  const t = [];
  for (let r = 0, n = e.length * Ih; r < n; r += Ih)
    t[r >> 5] |= (e.charCodeAt(r / Ih) & uU) << r % 32;
  return t;
}
function b0e(e) {
  const t = [];
  for (let r = 0, n = 32 * e.length; r < n; r += Ih)
    t.push(String.fromCharCode(e[r >> 5] >>> r % 32 & uU));
  return t.join("");
}
function w0e(e) {
  const t = "0123456789abcdef", r = [];
  for (let n = 0, i = 4 * e.length; n < i; n++)
    r.push(t.charAt(e[n >> 2] >> n % 4 * 8 + 4 & 15) + t.charAt(e[n >> 2] >> n % 4 * 8 & 15));
  return r.join("");
}
function _0e(e) {
  const t = "=", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = [];
  for (let i = 0, s = 4 * e.length; i < s; i += 3) {
    const o = (e[i >> 2] >> i % 4 * 8 & 255) << 16 | (e[i + 1 >> 2] >> (i + 1) % 4 * 8 & 255) << 8 | e[i + 2 >> 2] >> (i + 2) % 4 * 8 & 255;
    for (let a = 0; a < 4; a++)
      8 * i + 6 * a > 32 * e.length ? n.push(t) : n.push(r.charAt(o >> 6 * (3 - a) & 63));
  }
  return n.join("");
}
function S0e(e, t) {
  return e << t | e >>> 32 - t;
}
function G_(e, t, r, n, i, s) {
  return xu(S0e(xu(xu(t, e), xu(n, s)), i), r);
}
function hn(e, t, r, n, i, s, o) {
  return G_(t & r | ~t & n, e, t, i, s, o);
}
function fn(e, t, r, n, i, s, o) {
  return G_(t & n | r & ~n, e, t, i, s, o);
}
function mn(e, t, r, n, i, s, o) {
  return G_(t ^ r ^ n, e, t, i, s, o);
}
function yn(e, t, r, n, i, s, o) {
  return G_(r ^ (t | ~n), e, t, i, s, o);
}
function $0e(e, t) {
  e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
  let r = 1732584193, n = -271733879, i = -1732584194, s = 271733878;
  for (let o = 0; o < e.length; o += 16) {
    const a = r, l = n, c = i, h = s;
    r = hn(r, n, i, s, e[o], 7, -680876936), s = hn(s, r, n, i, e[o + 1], 12, -389564586), i = hn(i, s, r, n, e[o + 2], 17, 606105819), n = hn(n, i, s, r, e[o + 3], 22, -1044525330), r = hn(r, n, i, s, e[o + 4], 7, -176418897), s = hn(s, r, n, i, e[o + 5], 12, 1200080426), i = hn(i, s, r, n, e[o + 6], 17, -1473231341), n = hn(n, i, s, r, e[o + 7], 22, -45705983), r = hn(r, n, i, s, e[o + 8], 7, 1770035416), s = hn(s, r, n, i, e[o + 9], 12, -1958414417), i = hn(i, s, r, n, e[o + 10], 17, -42063), n = hn(n, i, s, r, e[o + 11], 22, -1990404162), r = hn(r, n, i, s, e[o + 12], 7, 1804603682), s = hn(s, r, n, i, e[o + 13], 12, -40341101), i = hn(i, s, r, n, e[o + 14], 17, -1502002290), n = hn(n, i, s, r, e[o + 15], 22, 1236535329), r = fn(r, n, i, s, e[o + 1], 5, -165796510), s = fn(s, r, n, i, e[o + 6], 9, -1069501632), i = fn(i, s, r, n, e[o + 11], 14, 643717713), n = fn(n, i, s, r, e[o], 20, -373897302), r = fn(r, n, i, s, e[o + 5], 5, -701558691), s = fn(s, r, n, i, e[o + 10], 9, 38016083), i = fn(i, s, r, n, e[o + 15], 14, -660478335), n = fn(n, i, s, r, e[o + 4], 20, -405537848), r = fn(r, n, i, s, e[o + 9], 5, 568446438), s = fn(s, r, n, i, e[o + 14], 9, -1019803690), i = fn(i, s, r, n, e[o + 3], 14, -187363961), n = fn(n, i, s, r, e[o + 8], 20, 1163531501), r = fn(r, n, i, s, e[o + 13], 5, -1444681467), s = fn(s, r, n, i, e[o + 2], 9, -51403784), i = fn(i, s, r, n, e[o + 7], 14, 1735328473), n = fn(n, i, s, r, e[o + 12], 20, -1926607734), r = mn(r, n, i, s, e[o + 5], 4, -378558), s = mn(s, r, n, i, e[o + 8], 11, -2022574463), i = mn(i, s, r, n, e[o + 11], 16, 1839030562), n = mn(n, i, s, r, e[o + 14], 23, -35309556), r = mn(r, n, i, s, e[o + 1], 4, -1530992060), s = mn(s, r, n, i, e[o + 4], 11, 1272893353), i = mn(i, s, r, n, e[o + 7], 16, -155497632), n = mn(n, i, s, r, e[o + 10], 23, -1094730640), r = mn(r, n, i, s, e[o + 13], 4, 681279174), s = mn(s, r, n, i, e[o], 11, -358537222), i = mn(i, s, r, n, e[o + 3], 16, -722521979), n = mn(n, i, s, r, e[o + 6], 23, 76029189), r = mn(r, n, i, s, e[o + 9], 4, -640364487), s = mn(s, r, n, i, e[o + 12], 11, -421815835), i = mn(i, s, r, n, e[o + 15], 16, 530742520), n = mn(n, i, s, r, e[o + 2], 23, -995338651), r = yn(r, n, i, s, e[o], 6, -198630844), s = yn(s, r, n, i, e[o + 7], 10, 1126891415), i = yn(i, s, r, n, e[o + 14], 15, -1416354905), n = yn(n, i, s, r, e[o + 5], 21, -57434055), r = yn(r, n, i, s, e[o + 12], 6, 1700485571), s = yn(s, r, n, i, e[o + 3], 10, -1894986606), i = yn(i, s, r, n, e[o + 10], 15, -1051523), n = yn(n, i, s, r, e[o + 1], 21, -2054922799), r = yn(r, n, i, s, e[o + 8], 6, 1873313359), s = yn(s, r, n, i, e[o + 15], 10, -30611744), i = yn(i, s, r, n, e[o + 6], 15, -1560198380), n = yn(n, i, s, r, e[o + 13], 21, 1309151649), r = yn(r, n, i, s, e[o + 4], 6, -145523070), s = yn(s, r, n, i, e[o + 11], 10, -1120210379), i = yn(i, s, r, n, e[o + 2], 15, 718787259), n = yn(n, i, s, r, e[o + 9], 21, -343485551), r = xu(r, a), n = xu(n, l), i = xu(i, c), s = xu(s, h);
  }
  return [r, n, i, s];
}
function cU(e, t = bp.Hex) {
  const r = t || bp.Base64, n = $0e(v0e(e), e.length * Ih);
  switch (r) {
    case bp.Raw:
      return n;
    case bp.Hex:
      return w0e(n);
    case bp.String:
      return b0e(n);
    case bp.Base64:
      return _0e(n);
  }
}
var AI;
let iy = AI = class extends V_ {
  writeLevels(e, t, r) {
    for (const n in e) {
      const i = this.levels[n];
      return void (t.stops = i);
    }
  }
  clone() {
    return new AI({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: $u(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: $u(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e) => e.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone(), levels: j(this.levels) });
  }
};
u([d()], iy.prototype, "levels", void 0), u([ge("levels")], iy.prototype, "writeLevels", null), iy = AI = u([E("geoscene.views.2d.engine.LevelDependentSizeVariable")], iy);
const x0e = se.getLogger("geoscene.views.2d.layers.support.clusterUtils");
U.add("geoscene-cluster-arcade-enabled", !0);
const T0e = U("geoscene-cluster-arcade-enabled"), E0e = (e, t, r, n, i) => {
  const s = t.clone();
  if (!M0e(s))
    return s;
  if (s.authoringInfo || (s.authoringInfo = new VO()), s.authoringInfo.isAutoGenerated = !0, "visualVariables" in s) {
    const o = (s.visualVariables || []).filter((l) => l.valueExpression !== "$view.scale"), a = dU(o);
    o.forEach((l) => {
      l.type === "rotation" ? l.field ? l.field = oc(e, l.field, "avg_angle", "number") : l.valueExpression && (l.field = rm(e, l.valueExpression, "avg_angle", "number"), l.valueExpression = null) : l.normalizationField ? (l.field = oc(e, l.field, "avg_norm", "number", l.normalizationField), l.normalizationField = null) : l.field ? l.field = oc(e, l.field, "avg", "number") : l.valueExpression && (l.field = rm(e, l.valueExpression, "avg", "number"), l.valueExpression = null);
    }), a == null && !I0e(o) && i && (o.push(pU(r, n)), s.dynamicClusterSize = !0), s.visualVariables = o;
  }
  switch (s.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const o of s.attributes)
        o.field ? o.field = oc(e, o.field, "sum", "number") : o.valueExpression && (o.field = rm(e, o.valueExpression, "sum", "number"), o.valueExpression = null);
      break;
    case "unique-value":
      s.field ? s.field = oc(e, s.field, "mode", "string") : s.valueExpression && (s.field = rm(e, s.valueExpression, "mode", "string"), s.valueExpression = null);
      break;
    case "class-breaks":
      s.normalizationField ? (s.field = oc(e, s.field, "avg_norm", "number", s.normalizationField), s.normalizationField = null) : s.field ? s.field = oc(e, s.field, "avg", "number") : s.valueExpression && (s.field = rm(e, s.valueExpression, "avg", "number"), s.valueExpression = null);
  }
  return s;
}, dU = (e) => {
  for (const t of e)
    if (t.type === "size")
      return t;
  return null;
};
function lFe(e, t, r) {
  const n = e.clone();
  let i = !1;
  if ("visualVariables" in n) {
    const s = (n.visualVariables || []).filter((o) => o.valueExpression !== "$view.scale");
    dU(s) == null && (n.visualVariables || (n.visualVariables = []), n.visualVariables.push(pU(t, r)), n.dynamicClusterSize = !0, i = !0);
  }
  return { renderer: n, didInject: i };
}
const I0e = (e) => {
  for (const t of e)
    if (t.field === "cluster_count")
      return !0;
  return !1;
}, pU = (e, t) => {
  const r = [new Jp({ value: 0, size: 0 }), new Jp({ value: 1 })];
  if (t == null)
    return new V_({ field: "cluster_count", stops: [...r, new Jp({ value: 2, size: 0 })] });
  const n = Object.keys(t).reduce((i, s) => ({ ...i, [s]: [...r, new Jp({ value: Math.max(2, t[s].minValue), size: e.clusterMinSize }), new Jp({ value: Math.max(3, t[s].maxValue), size: e.clusterMaxSize })] }), {});
  return new iy({ field: "cluster_count", levels: n });
}, M0e = (e) => {
  const t = (r) => x0e.error(new G("Unsupported-renderer", r, { renderer: e }));
  if (!e)
    return !1;
  switch (e.type) {
    case "unique-value":
      if (e.field2 || e.field3)
        return t("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), !1;
      break;
    case "class-breaks":
      if (e.normalizationField) {
        const r = e.normalizationType;
        if (r !== "field")
          return t(`FeatureReductionCluster does not support a normalizationType of ${r}`), !1;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return t(`FeatureReductionCluster does not support renderers of type ${e.type}`), !1;
  }
  if (!T0e) {
    if ("valueExpression" in e && e.valueExpression)
      return t("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), !1;
    if (("visualVariables" in e && e.visualVariables || []).some((r) => !(!("valueExpression" in r) || !r.valueExpression)))
      return t("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), !1;
  }
  return !0;
};
function O0e(e, t, r) {
  switch (e) {
    case "sum":
      return `cluster_sum_${t}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${t}`;
    case "mode":
      return `cluster_type_${t}`;
    case "avg_norm": {
      const n = r, i = "field", s = t.toLowerCase() + ",norm:" + i + "," + n.toLowerCase();
      return "cluster_avg_" + cU(s);
    }
  }
}
function rm(e, t, r, n) {
  const i = cU(t), s = r === "mode" ? `cluster_type_${i}` : r === "sum" ? `cluster_sum_${i}` : `cluster_avg_${i}`;
  return e.some((o) => o.name === s) || e.push(new zd({ name: s, isAutoGenerated: !0, onStatisticExpression: new tC({ expression: t, returnType: n }), statisticType: r })), s;
}
function oc(e, t, r, n, i) {
  if (t === "cluster_count" || e.some((o) => o.name === t))
    return t;
  const s = O0e(r, t, i);
  return e.some((o) => o.name === s) || (r === "avg_norm" ? e.push(new zd({ name: s, isAutoGenerated: !0, onStatisticExpression: new tC({ expression: `$feature.${t} / $feature.${i}`, returnType: n }), statisticType: "avg" })) : e.push(new zd({ name: s, isAutoGenerated: !0, onStatisticField: t, statisticType: r }))), s;
}
const C0e = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this.own(this.watch("renderer", () => {
        if (this.featureReduction) {
          const n = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", n);
        }
      }, !0));
    }
    set featureReduction(r) {
      const n = this._normalizeFeatureReduction(r);
      this._set("featureReduction", n);
    }
    set renderer(r) {
    }
    _normalizeFeatureReduction(r) {
      var a;
      if ((r == null ? void 0 : r.type) !== "cluster")
        return r;
      const n = r.clone(), i = [new zd({ name: "cluster_count", isAutoGenerated: !0, statisticType: "count" })], s = (n.fields ?? []).filter((l) => !l.isAutoGenerated);
      if (r.renderer && !((a = r.renderer.authoringInfo) != null && a.isAutoGenerated))
        return n.fields = [...i, ...s], n;
      if (r.symbol)
        return n.fields = [...i, ...s], n.renderer = null, n;
      if (!this.renderer)
        return r;
      const o = E0e(i, this.renderer, r, null, !1);
      return n.fields = [...i, ...s], n.renderer = o, n;
    }
  };
  return u([d(g0e)], t.prototype, "featureReduction", null), t = u([E("geoscene.layers.mixins.FeatureReductionLayer")], t), t;
}, V4 = { ArcGISAnnotationLayer: !0, ArcGISDimensionLayer: !0, ArcGISFeatureLayer: !0, ArcGISImageServiceLayer: !0, ArcGISImageServiceVectorLayer: !0, ArcGISMapServiceLayer: !0, ArcGISStreamLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, BingMapsAerial: !0, BingMapsHybrid: !0, BingMapsRoad: !0, CSV: !0, GeoRSS: !0, GeoJSON: !0, GroupLayer: !0, KML: !0, MediaLayer: !0, OGCFeatureLayer: !0, OrientedImageryLayer: !0, SubtypeGroupLayer: !0, VectorTileLayer: !0, WFS: !0, WMS: !0, WebTiledLayer: !0 }, z4 = { ArcGISImageServiceLayer: !0, ArcGISImageServiceVectorLayer: !0, ArcGISMapServiceLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, OpenStreetMap: !0, VectorTileLayer: !0, WMS: !0, WebTiledLayer: !0, BingMapsAerial: !0, BingMapsRoad: !0, BingMapsHybrid: !0 }, U4 = { ArcGISFeatureLayer: !0 }, k0e = { "web-scene/operational-layers": { ArcGISDimensionLayer: !0, ArcGISFeatureLayer: !0, ArcGISImageServiceLayer: !0, ArcGISMapServiceLayer: !0, ArcGISSceneServiceLayer: !0, ArcGISTiledElevationServiceLayer: !0, ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, BuildingSceneLayer: !0, GroupLayer: !0, IntegratedMeshLayer: !0, OGCFeatureLayer: !0, PointCloudLayer: !0, WebTiledLayer: !0, CSV: !0, GeoJSON: !0, VectorTileLayer: !0, WFS: !0, WMS: !0, KML: !0, RasterDataLayer: !0, Voxel: !0, LineOfSightLayer: !0 }, "web-scene/basemap": { ArcGISTiledImageServiceLayer: !0, ArcGISTiledMapServiceLayer: !0, WebTiledLayer: !0, OpenStreetMap: !0, VectorTileLayer: !0, ArcGISImageServiceLayer: !0, WMS: !0, ArcGISMapServiceLayer: !0, ArcGISSceneServiceLayer: !0 }, "web-scene/ground": { ArcGISTiledElevationServiceLayer: !0, RasterDataElevationLayer: !0 }, "web-map/operational-layers": V4, "web-map/basemap": z4, "web-map/tables": U4, "link-chart/operational-layers": { ...V4, LinkChartLayer: !0 }, "link-chart/basemap": z4, "link-chart/tables": U4, "portal-item/operational-layers": { ArcGISFeatureLayer: !0, ArcGISSceneServiceLayer: !0, PointCloudLayer: !0, BuildingSceneLayer: !0, IntegratedMeshLayer: !0, OrientedImageryLayer: !0 } }, A0e = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.title = null;
    }
    writeListMode(r, n, i, s) {
      (s && s.layerContainerType === "ground" || r && HJ(this, i, {}, s)) && (n[i] = r);
    }
    writeOperationalLayerType(r, n, i, s) {
      !r || s && s.layerContainerType === "tables" || (n.layerType = r);
    }
    writeTitle(r, n) {
      n.title = r ?? "Layer";
    }
    read(r, n) {
      n && (n.layer = this), BJ(this, r, (i) => super.read(r, i), n);
    }
    write(r, n) {
      var o, a;
      if (n != null && n.origin) {
        const l = `${n.origin}/${n.layerContainerType || "operational-layers"}`, c = k0e[l];
        let h = !!(c != null && c[this.operationalLayerType]);
        if (this.operationalLayerType === "ArcGISTiledElevationServiceLayer" && l === "web-scene/operational-layers" && (h = !1), this.operationalLayerType === "ArcGISDimensionLayer" && l === "web-map/operational-layers" && (h = !1), !h)
          return (o = n.messages) == null || o.push(new G("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${l}'`, { layer: this })), null;
      }
      const i = super.write(r, { ...n, layer: this }), s = !!n && !!n.messages && !!n.messages.filter((l) => l instanceof G && l.name === "web-document-write:property-required").length;
      return s_(i == null ? void 0 : i.url) ? ((a = n == null ? void 0 : n.messages) == null || a.push(new G("layer:invalid-url", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a Blob URL cannot be written to web scenes and web maps`, { layer: this })), null) : !this.url && s ? null : i;
    }
    beforeSave() {
    }
  };
  return u([d({ type: String, json: { write: { ignoreOrigin: !0 }, origins: { "web-scene": { write: { isRequired: !0, ignoreOrigin: !0 } }, "portal-item": { write: !1 } } } })], t.prototype, "id", void 0), u([d(Yz)], t.prototype, "listMode", void 0), u([ge("listMode")], t.prototype, "writeListMode", null), u([d({ type: String, readOnly: !0, json: { read: !1, write: { target: "layerType", ignoreOrigin: !0 }, origins: { "portal-item": { write: !1 } } } })], t.prototype, "operationalLayerType", void 0), u([ge("operationalLayerType")], t.prototype, "writeOperationalLayerType", null), u([d(wI)], t.prototype, "opacity", void 0), u([d({ type: String, json: { write: { ignoreOrigin: !0, writerEnsuresNonNull: !0 }, origins: { "web-scene": { write: { isRequired: !0, ignoreOrigin: !0, writerEnsuresNonNull: !0 } }, "portal-item": { write: !1 } } }, value: "Layer" })], t.prototype, "title", void 0), u([ge("title"), ge(["web-scene"], "title")], t.prototype, "writeTitle", null), u([d({ type: Boolean, json: { name: "visibility" } })], t.prototype, "visible", void 0), t = u([E("geoscene.layers.mixins.OperationalLayer")], t), t;
};
var PI;
const US = new et({ asc: "ascending", desc: "descending" });
let sh = PI = class extends re {
  constructor(e) {
    super(e), this.field = null, this.valueExpression = null, this.order = "ascending";
  }
  clone() {
    return new PI({ field: this.field, valueExpression: this.valueExpression, order: this.order });
  }
};
u([d({ type: String, json: { write: !0 } })], sh.prototype, "field", void 0), u([d({ type: String, json: { write: !0 } })], sh.prototype, "valueExpression", void 0), u([d({ type: US.apiValues, json: { read: US.read, write: US.write } })], sh.prototype, "order", void 0), sh = PI = u([E("geoscene.layers.support.OrderByInfo")], sh);
const hU = sh;
function P0e(e, t, r) {
  if (!e)
    return null;
  const n = e.find((s) => !!s.field);
  if (!n)
    return null;
  const i = new hU();
  return i.read(n, r), [i];
}
function R0e(e, t, r, n) {
  const i = e.find((s) => !!s.field);
  i && In(r, [i.toJSON()], t);
}
const L0e = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.orderBy = null;
    }
  };
  return u([d({ type: [hU], json: { origins: { "web-scene": { write: !1, read: !1 } }, read: { source: "layerDefinition.orderBy", reader: P0e }, write: { target: "layerDefinition.orderBy", writer: R0e } } })], t.prototype, "orderBy", void 0), t = u([E("geoscene.layers.mixins.OrderedLayer")], t), t;
};
async function N0e(e) {
  const t = e.spatialReference;
  if (t.isWGS84)
    return e.clone();
  if (t.isWebMercator)
    return dm(e);
  const r = tt.WGS84;
  return await r9(t, r), Ju(e, r);
}
function uFe(e, t) {
  if (!fU(e, t)) {
    const r = e.typeKeywords;
    r ? r.push(t) : e.typeKeywords = [t];
  }
}
function fU(e, t) {
  var r;
  return !!((r = e.typeKeywords) != null && r.includes(t));
}
function cFe(e) {
  return fU(e, F0e.HOSTED_SERVICE);
}
function dFe(e, t) {
  const r = e.typeKeywords;
  if (r) {
    const n = r.indexOf(t);
    n > -1 && r.splice(n, 1);
  }
}
async function pFe(e) {
  const t = e.clone().normalize();
  let r;
  if (t.length > 1)
    for (const n of t)
      r ? n.width > r.width && (r = n) : r = n;
  else
    r = t[0];
  return N0e(r);
}
const F0e = { DEVELOPER_BASEMAP: "DeveloperBasemap", JSAPI: "GeoScene API for JavaScript", METADATA: "Metadata", MULTI_LAYER: "Multilayer", SINGLE_LAYER: "Singlelayer", TABLE: "Table", HOSTED_SERVICE: "Hosted Service" };
function B4(e) {
  var l;
  const { portal: t, isOrgItem: r, itemControl: n } = e, i = (l = t.user) == null ? void 0 : l.privileges;
  let s = !i || i.includes("features:user:edit"), o = !!r && !!(i != null && i.includes("features:user:fullEdit"));
  const a = n === "update" || n === "admin";
  return a ? o = s = !0 : o && (s = !0), { features: { edit: s, fullEdit: o }, content: { updateItem: a } };
}
const D0e = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = !0, this.userHasFullEditingPrivileges = !1, this.userHasUpdateItemPrivileges = !1;
    }
    destroy() {
      this.portalItem = Vt(this.portalItem), this.resourceReferences.portalItem = null, this.resourceReferences.paths.length = 0;
    }
    set portalItem(r) {
      r !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", r));
    }
    readPortalItem(r, n, i) {
      if (n.itemId)
        return new yy({ id: n.itemId, portal: i && i.portal });
    }
    writePortalItem(r, n) {
      r && r.id && (n.itemId = r.id);
    }
    async loadFromPortal(r, n) {
      if (this.portalItem && this.portalItem.id)
        try {
          const { load: i } = await import("./layersLoader-ejly62oA.js");
          return lr(n), await i({ instance: this, supportedTypes: r.supportedTypes, validateItem: r.validateItem, supportsData: r.supportsData, layerModuleTypeMap: r.layerModuleTypeMap }, n);
        } catch (i) {
          throw Fi(i) || se.getLogger(this).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${i}`), i;
        }
    }
    async finishLoadEditablePortalLayer(r) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(r).catch((n) => (Go(n), !0)));
    }
    async _setUserPrivileges(r, n) {
      if (!bt.userPrivilegesApplied)
        return this.finishLoadEditablePortalLayer(n);
      if (this.url)
        try {
          const { features: { edit: i, fullEdit: s }, content: { updateItem: o } } = await this._fetchUserPrivileges(r, n);
          this._set("userHasEditingPrivileges", i), this._set("userHasFullEditingPrivileges", s), this._set("userHasUpdateItemPrivileges", o);
        } catch (i) {
          Go(i);
        }
    }
    async _fetchUserPrivileges(r, n) {
      let i = this.portalItem;
      if (!r || !i || !i.loaded || i.sourceUrl)
        return this._fetchFallbackUserPrivileges(n);
      const s = r === i.id;
      if (s && i.portal.user)
        return B4(i);
      let o, a;
      if (s)
        o = i.portal.url;
      else
        try {
          o = await N6(this.url, n);
        } catch (f) {
          Go(f);
        }
      if (!o || !bZ(o, i.portal.url))
        return this._fetchFallbackUserPrivileges(n);
      try {
        const f = n != null ? n.signal : null;
        a = await (st == null ? void 0 : st.getCredential(`${o}/sharing`, { prompt: !1, signal: f }));
      } catch (f) {
        Go(f);
      }
      const l = !0, c = !1, h = !1;
      if (!a)
        return { features: { edit: l, fullEdit: c }, content: { updateItem: h } };
      try {
        if (s ? await i.reload() : (i = new yy({ id: r, portal: { url: o } }), await i.load(n)), i.portal.user)
          return B4(i);
      } catch (f) {
        Go(f);
      }
      return { features: { edit: l, fullEdit: c }, content: { updateItem: h } };
    }
    async _fetchFallbackUserPrivileges(r) {
      let n = !0;
      try {
        n = await this._fetchUserHasEditingPrivileges(r);
      } catch (i) {
        Go(i);
      }
      return { features: { edit: n, fullEdit: !1 }, content: { updateItem: !1 } };
    }
    async _fetchUserHasEditingPrivileges(r) {
      const n = this.url ? st == null ? void 0 : st.findCredential(this.url) : null;
      if (!n)
        return !0;
      const i = mv.credential === n ? mv.user : await this._fetchEditingUser(r);
      return mv.credential = n, mv.user = i, i == null || i.privileges == null || i.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(r) {
      var h, f;
      const n = (f = (h = this.portalItem) == null ? void 0 : h.portal) == null ? void 0 : f.user;
      if (n)
        return n;
      const i = st.findServerInfo(this.url ?? "");
      if (!(i != null && i.owningSystemUrl))
        return null;
      const s = `${i.owningSystemUrl}/sharing/rest`, o = pi.getDefault();
      if (o && o.loaded && ao(o.restUrl) === ao(s))
        return o.user;
      const a = `${s}/community/self`, l = r != null ? r.signal : null, c = await n_(zr(a, { authMode: "no-prompt", query: { f: "json" }, signal: l }));
      return c.ok ? hM.fromJSON(c.value.data) : null;
    }
    read(r, n) {
      n && (n.layer = this), super.read(r, n);
    }
    write(r, n) {
      const i = n && n.portal, s = this.portalItem && this.portalItem.id && (this.portalItem.portal || pi.getDefault());
      return i && s && !n6(s.restUrl, i.restUrl) ? (n.messages && n.messages.push(new G("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(r, { ...n, layer: this });
    }
  };
  return u([d({ type: yy })], t.prototype, "portalItem", null), u([ce("web-document", "portalItem", ["itemId"])], t.prototype, "readPortalItem", null), u([ge("web-document", "portalItem", { itemId: { type: String } })], t.prototype, "writePortalItem", null), u([d({ clonable: !1 })], t.prototype, "resourceReferences", void 0), u([d({ type: Boolean, readOnly: !0 })], t.prototype, "userHasEditingPrivileges", void 0), u([d({ type: Boolean, readOnly: !0 })], t.prototype, "userHasFullEditingPrivileges", void 0), u([d({ type: Boolean, readOnly: !0 })], t.prototype, "userHasUpdateItemPrivileges", void 0), t = u([E("geoscene.layers.mixins.PortalLayer")], t), t;
}, mv = { credential: null, user: null };
let sy = class extends Ae {
  constructor() {
    super(...arguments), this.updating = !1, this.status = "unknown";
  }
};
u([d()], sy.prototype, "updating", void 0), u([d()], sy.prototype, "status", void 0), sy = u([E("geoscene.layers.support.PublishingInfo")], sy);
const j0e = sy, mU = "geoscene.layers.mixins.PublishableLayer", V0e = Symbol(mU), z0e = (e) => {
  var t;
  let r = class extends e {
    constructor() {
      super(...arguments), this[t] = !0;
    }
    get publishingInfo() {
      if (this.destroyed)
        return null;
      const n = this._get("publishingInfo");
      if (n)
        return n;
      const i = new j0e();
      return this._checkPublishingStatus(i), i;
    }
    _checkPublishingStatus(n) {
      let o = 0;
      const a = async (c) => {
        let h;
        n.updating = !0;
        try {
          h = await this.fetchPublishingStatus();
        } catch {
          h = "unavailable";
        }
        h !== "published" && h !== "unavailable" || (n.status === "publishing" && this.refresh(), l.remove()), n.status = h, n.updating = !1, l.removed || (o = setTimeout(a, c, c + 125));
      }, l = { removed: !1, remove() {
        this.removed = !0, clearTimeout(o);
      } };
      this.when().catch(() => l.remove()), a(250), this.own(l);
    }
  };
  return t = V0e, u([d({ readOnly: !0, clonable: !1 })], r.prototype, "publishingInfo", null), r = u([E(mU)], r), r;
}, gg = new je(), Oy = /* @__PURE__ */ new WeakMap();
function U0e(e) {
  yU(e) && gg.push(e);
}
function B0e(e) {
  yU(e) && gg.includes(e) && gg.remove(e);
}
function yU(e) {
  return e != null && typeof e == "object" && "refreshInterval" in e && "refresh" in e;
}
function gU(e, t) {
  return Number.isFinite(e) && Number.isFinite(t) ? t <= 0 ? e : gU(t, e % t) : 0;
}
let BS = 0, yv = 0;
function q0e() {
  const e = Date.now();
  for (const t of gg)
    t.refreshInterval && e - (Oy.get(t) ?? 0) + 5 >= 6e4 * t.refreshInterval && (Oy.set(t, e), t.refresh(e));
}
$F(() => {
  const e = Date.now();
  let t = 0;
  for (const r of gg)
    t = gU(Math.round(6e4 * r.refreshInterval), t), r.refreshInterval ? Oy.get(r) || Oy.set(r, e) : Oy.delete(r);
  if (t !== yv) {
    if (yv = t, clearInterval(BS), yv === 0)
      return void (BS = 0);
    BS = setInterval(q0e, yv);
  }
});
const G0e = (e) => {
  let t = class extends e {
    constructor(...r) {
      super(...r), this.refreshInterval = 0, this.refreshTimestamp = 0, this._debounceHasDataChanged = gF(() => this.hasDataChanged()), this.when().then(() => {
        this.destroyed || U0e(this);
      }, () => {
      });
    }
    destroy() {
      B0e(this);
    }
    get refreshParameters() {
      return { _ts: this.refreshTimestamp || null };
    }
    refresh(r = Date.now()) {
      E$(this._debounceHasDataChanged()).then((n) => {
        n && this._set("refreshTimestamp", r), this.emit("refresh", { dataChanged: n });
      }, (n) => {
        se.getLogger(this).error(n), this.emit("refresh", { dataChanged: !1, error: n });
      });
    }
    async hasDataChanged() {
      return !0;
    }
  };
  return u([d({ type: Number, cast: (r) => r >= 0.1 ? r : r <= 0 ? 0 : 0.1, json: { write: !0 } })], t.prototype, "refreshInterval", void 0), u([d({ readOnly: !0 })], t.prototype, "refreshTimestamp", void 0), u([d()], t.prototype, "refreshParameters", null), t = u([E("geoscene.layers.mixins.RefreshableLayer")], t), t;
}, vU = Mn()({ esriTimeUnitsMilliseconds: "milliseconds", esriTimeUnitsSeconds: "seconds", esriTimeUnitsMinutes: "minutes", esriTimeUnitsHours: "hours", esriTimeUnitsDays: "days", esriTimeUnitsWeeks: "weeks", esriTimeUnitsMonths: "months", esriTimeUnitsYears: "years", esriTimeUnitsDecades: "decades", esriTimeUnitsCenturies: "centuries", esriTimeUnitsUnknown: void 0 });
let oy = class extends Rt(re) {
  constructor(t) {
    super(t), this.unit = "milliseconds", this.value = 0;
  }
  toMilliseconds() {
    return Fae(this.value, this.unit, "milliseconds");
  }
};
u([Ie(vU, { nonNullable: !0 })], oy.prototype, "unit", void 0), u([d({ type: Number, json: { write: !0 }, nonNullable: !0 })], oy.prototype, "value", void 0), oy = u([E("geoscene.TimeInterval")], oy);
const vw = oy;
function q4(e, t) {
  return vw.fromJSON({ value: e, unit: t });
}
let _n = class extends Rt(re) {
  constructor(e) {
    super(e), this.cumulative = !1, this.endField = null, this.fullTimeExtent = null, this.hasLiveData = !1, this.interval = null, this.startField = null, this.timeReference = null, this.trackIdField = null, this.useTime = !0;
  }
  readFullTimeExtent(e, t) {
    if (!t.timeExtent || !Array.isArray(t.timeExtent) || t.timeExtent.length !== 2)
      return null;
    const r = new Date(t.timeExtent[0]), n = new Date(t.timeExtent[1]);
    return new ha({ start: r, end: n });
  }
  writeFullTimeExtent(e, t) {
    e && e.start != null && e.end != null ? t.timeExtent = [e.start.getTime(), e.end.getTime()] : t.timeExtent = null;
  }
  readInterval(e, t) {
    return t.timeInterval && t.timeIntervalUnits ? q4(t.timeInterval, t.timeIntervalUnits) : t.defaultTimeInterval && t.defaultTimeIntervalUnits ? q4(t.defaultTimeInterval, t.defaultTimeIntervalUnits) : null;
  }
  writeInterval(e, t) {
    t.timeInterval = (e == null ? void 0 : e.toJSON().value) ?? null, t.timeIntervalUnits = (e == null ? void 0 : e.toJSON().unit) ?? null;
  }
};
u([d({ type: Boolean, json: { name: "exportOptions.timeDataCumulative", write: !0 } })], _n.prototype, "cumulative", void 0), u([d({ type: String, json: { name: "endTimeField", write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "endField", void 0), u([d({ type: ha, json: { write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "fullTimeExtent", void 0), u([ce("fullTimeExtent", ["timeExtent"])], _n.prototype, "readFullTimeExtent", null), u([ge("fullTimeExtent")], _n.prototype, "writeFullTimeExtent", null), u([d({ type: Boolean, json: { write: !0 } })], _n.prototype, "hasLiveData", void 0), u([d({ type: vw, json: { write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "interval", void 0), u([ce("interval", ["timeInterval", "timeIntervalUnits", "defaultTimeInterval", "defaultTimeIntervalUnits"])], _n.prototype, "readInterval", null), u([ge("interval")], _n.prototype, "writeInterval", null), u([d({ type: String, json: { name: "startTimeField", write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "startField", void 0), u([d({ type: Uh, json: { write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "timeReference", void 0), u([d({ type: String, json: { write: { enabled: !0, allowNull: !0 } } })], _n.prototype, "trackIdField", void 0), u([d({ type: Boolean, json: { name: "exportOptions.useTime", write: !0 } })], _n.prototype, "useTime", void 0), _n = u([E("geoscene.layers.support.TimeInfo")], _n);
const bU = _n, H0e = (e) => {
  let t = class extends e {
    constructor() {
      super(...arguments), this.timeExtent = null, this.timeOffset = null, this.useViewTime = !0;
    }
    readOffset(r, n) {
      const i = n.timeInfo.exportOptions;
      if (!i)
        return null;
      const s = i.timeOffset, o = vU.fromJSON(i.timeOffsetUnits);
      return s && o ? new vw({ value: s, unit: o }) : null;
    }
    set timeInfo(r) {
      D8(r, this.fieldsIndex), this._set("timeInfo", r);
    }
  };
  return u([d({ type: ha, json: { write: !1 } })], t.prototype, "timeExtent", void 0), u([d({ type: vw })], t.prototype, "timeOffset", void 0), u([ce("service", "timeOffset", ["timeInfo.exportOptions"])], t.prototype, "readOffset", null), u([d({ value: null, type: bU, json: { write: !0, origins: { "web-document": { read: !1, write: !1 }, "portal-item": { read: !1, write: !1 } } } })], t.prototype, "timeInfo", null), u([d({ type: Boolean, json: { read: { source: "timeAnimation" }, write: { target: "timeAnimation" }, origins: { "web-scene": { read: !1, write: !1 } } } })], t.prototype, "useViewTime", void 0), t = u([E("geoscene.layers.mixins.TemporalLayer")], t), t;
}, G4 = new et({ esriFeatureEditToolAutoCompletePolygon: "auto-complete-polygon", esriFeatureEditToolCircle: "circle", esriFeatureEditToolEllipse: "ellipse", esriFeatureEditToolFreehand: "freehand", esriFeatureEditToolLine: "line", esriFeatureEditToolNone: "none", esriFeatureEditToolPoint: "point", esriFeatureEditToolPolygon: "polygon", esriFeatureEditToolRectangle: "rectangle", esriFeatureEditToolArrow: "arrow", esriFeatureEditToolTriangle: "triangle", esriFeatureEditToolLeftArrow: "left-arrow", esriFeatureEditToolRightArrow: "right-arrow", esriFeatureEditToolUpArrow: "up-arrow", esriFeatureEditToolDownArrow: "down-arrow" });
let su = class extends Rt(re) {
  constructor(t) {
    super(t), this.name = null, this.description = null, this.drawingTool = null, this.prototype = null, this.thumbnail = null;
  }
};
u([d({ json: { write: !0 } })], su.prototype, "name", void 0), u([d({ json: { write: !0 } })], su.prototype, "description", void 0), u([d({ json: { read: G4.read, write: G4.write } })], su.prototype, "drawingTool", void 0), u([d({ json: { write: !0 } })], su.prototype, "prototype", void 0), u([d({ json: { write: !0 } })], su.prototype, "thumbnail", void 0), su = u([E("geoscene.layers.support.FeatureTemplate")], su);
const sC = su;
let za = class extends Rt(re) {
  constructor(t) {
    super(t), this.id = null, this.name = null, this.domains = null, this.templates = null;
  }
  readDomains(t) {
    const r = {};
    for (const n of Object.keys(t))
      r[n] = JO(t[n]);
    return r;
  }
  writeDomains(t, r) {
    var i;
    const n = {};
    for (const s of Object.keys(t))
      t[s] && (n[s] = (i = t[s]) == null ? void 0 : i.toJSON());
    r.domains = n;
  }
};
u([d({ json: { write: !0 } })], za.prototype, "id", void 0), u([d({ json: { write: !0 } })], za.prototype, "name", void 0), u([d({ json: { write: !0 } })], za.prototype, "domains", void 0), u([ce("domains")], za.prototype, "readDomains", null), u([ge("domains")], za.prototype, "writeDomains", null), u([d({ type: [sC], json: { write: !0 } })], za.prototype, "templates", void 0), za = u([E("geoscene.layers.support.FeatureType")], za);
const wU = za;
function W0e() {
  return { fields: { type: [ZO], value: null }, fieldsIndex: { readOnly: !0, get() {
    return new Iz(this.fields || []);
  } }, outFields: { type: [String], json: { read: !1 }, set: function(e) {
    this._userOutFields = e, this.notifyChange("outFields");
  }, get: function() {
    var t;
    const e = this._userOutFields;
    if (!e || !e.length)
      return null;
    if (e.includes("*"))
      return ["*"];
    if (!this.fields)
      return e;
    for (const r of e)
      ((t = this.fieldsIndex) == null ? void 0 : t.has(r)) || se.getLogger("geoscene.layers.support.fieldProperties").error("field-attributes-layer:invalid-field", `Invalid field ${r} found in outFields`, { layer: this, outFields: e });
    return MM(this.fieldsIndex, e);
  } } };
}
const qS = se.getLogger("geoscene.layers.support.labelingInfo"), J0e = /\[([^\[\]]+)\]/gi;
function H4(e, t, r) {
  return e ? e.map((n) => {
    const i = new q_();
    if (i.read(n, r), i.labelExpression) {
      const s = t.fields || t.layerDefinition && t.layerDefinition.fields || this.fields;
      i.labelExpression = i.labelExpression.replaceAll(J0e, (o, a) => `[${Z0e(a, s)}]`);
    }
    return i;
  }) : null;
}
function Z0e(e, t) {
  if (!t)
    return e;
  const r = e.toLowerCase();
  for (let n = 0; n < t.length; n++) {
    const i = t[n].name;
    if (i.toLowerCase() === r)
      return i;
  }
  return e;
}
const K0e = { esriGeometryPoint: ["above-right", "above-center", "above-left", "center-center", "center-left", "center-right", "below-center", "below-left", "below-right"], esriGeometryPolygon: ["always-horizontal"], esriGeometryPolyline: ["center-along"], esriGeometryMultipoint: null };
function gFe(e, t) {
  const r = j(e);
  return r.some((n) => Y0e(n, t)) ? [] : r;
}
function Y0e(e, t) {
  const r = e.labelPlacement, n = K0e[t];
  if (!e.symbol)
    return qS.warn("No ILabelClass symbol specified."), !0;
  if (!n)
    return qS.error(new G("labeling:unsupported-geometry-type", `Unable to create labels for layer, geometry type '${t}' is not supported`)), !0;
  if (!n.includes(r)) {
    const i = n[0];
    r && qS.warn(`Found invalid label placement type ${r} for ${t}. Defaulting to ${i}`), e.labelPlacement = i;
  }
  return !1;
}
const Ys = [];
function Q0e(e, t) {
  if (W9(e.url ?? ""))
    return !0;
  const { wkid: r } = t;
  for (const n of Ys) {
    if ((e.version ?? 0) >= n[0])
      return !0;
    if (typeof n[1] == "function" && (n[1] = n[1]()), n[1].has(r))
      return !1;
  }
  return !0;
}
Ys.push([10.91, () => {
  const e = /* @__PURE__ */ new Set([9709, 9716, 9741, 9761, 9766]);
  for (let t = 9712; t <= 9713; t++)
    e.add(t);
  for (let t = 9748; t <= 9749; t++)
    e.add(t);
  for (let t = 20904; t <= 20932; t++)
    e.add(t);
  for (let t = 21004; t <= 21032; t++)
    e.add(t);
  for (let t = 21207; t <= 21264; t++)
    e.add(t);
  for (let t = 21307; t <= 21364; t++)
    e.add(t);
  for (let t = 102759; t <= 102760; t++)
    e.add(t);
  for (let t = 102901; t <= 102955; t++)
    e.add(t);
  return e;
}]), Ys.push([10.9, () => {
  const e = /* @__PURE__ */ new Set([9300, 9354, 9364, 9367, 9373, 9377, 9387, 9456, 9473, 9498, 9678, 9680, 29874, 103599, 103872, 104028]);
  for (let t = 9356; t <= 9360; t++)
    e.add(t);
  for (let t = 9404; t <= 9407; t++)
    e.add(t);
  for (let t = 9476; t <= 9482; t++)
    e.add(t);
  for (let t = 9487; t <= 9494; t++)
    e.add(t);
  for (let t = 9697; t <= 9699; t++)
    e.add(t);
  return e;
}]), Ys.push([10.81, () => {
  const e = /* @__PURE__ */ new Set([9265, 9333, 103598, 103699]);
  for (let t = 9248; t <= 9254; t++)
    e.add(t);
  for (let t = 9271; t <= 9273; t++)
    e.add(t);
  for (let t = 9284; t <= 9285; t++)
    e.add(t);
  for (let t = 21453; t <= 21463; t++)
    e.add(t);
  return e;
}]), Ys.push([10.8, () => {
  const e = /* @__PURE__ */ new Set([8088, 8395, 8428, 8433, 8531, 8687, 8692, 8694, 8699, 8900, 9003, 9006, 9009, 9012, 9017, 9191]);
  for (let t = 8035; t <= 8036; t++)
    e.add(t);
  for (let t = 8455; t <= 8456; t++)
    e.add(t);
  for (let t = 8518; t <= 8529; t++)
    e.add(t);
  for (let t = 8533; t <= 8536; t++)
    e.add(t);
  for (let t = 8538; t <= 8540; t++)
    e.add(t);
  for (let t = 8677; t <= 8679; t++)
    e.add(t);
  for (let t = 8902; t <= 8903; t++)
    e.add(t);
  for (let t = 8907; t <= 8910; t++)
    e.add(t);
  for (let t = 8949; t <= 8951; t++)
    e.add(t);
  for (let t = 8972; t <= 8987; t++)
    e.add(t);
  for (let t = 9039; t <= 9040; t++)
    e.add(t);
  for (let t = 9068; t <= 9069; t++)
    e.add(t);
  for (let t = 9140; t <= 9141; t++)
    e.add(t);
  for (let t = 9148; t <= 9150; t++)
    e.add(t);
  for (let t = 9153; t <= 9159; t++)
    e.add(t);
  for (let t = 9205; t <= 9218; t++)
    e.add(t);
  for (let t = 9221; t <= 9222; t++)
    e.add(t);
  for (let t = 54098; t <= 54101; t++)
    e.add(t);
  return e;
}]), Ys.push([10.71, () => {
  const e = /* @__PURE__ */ new Set([6316]);
  for (let t = 8351; t <= 8353; t++)
    e.add(t);
  for (let t = 9294; t <= 9297; t++)
    e.add(t);
  for (let t = 22619; t <= 22621; t++)
    e.add(t);
  for (let t = 103586; t <= 103594; t++)
    e.add(t);
  return e;
}]), Ys.push([10.7, () => {
  const e = /* @__PURE__ */ new Set([8387, 8391, 8427, 8545, 8682, 8685, 8818, 31370, 104022, 104024, 104975]);
  for (let t = 8065; t <= 8068; t++)
    e.add(t);
  for (let t = 8082; t <= 8083; t++)
    e.add(t);
  for (let t = 8379; t <= 8385; t++)
    e.add(t);
  for (let t = 8836; t <= 8840; t++)
    e.add(t);
  for (let t = 8857; t <= 8860; t++)
    e.add(t);
  for (let t = 53035; t <= 53037; t++)
    e.add(t);
  for (let t = 54090; t <= 54091; t++)
    e.add(t);
  for (let t = 102498; t <= 102499; t++)
    e.add(t);
  return e;
}]), Ys.push([10.61, () => /* @__PURE__ */ new Set([102497])]), Ys.push([10.6, () => {
  const e = /* @__PURE__ */ new Set([7803, 7805, 7887, 8086, 8232, 8237, 8240, 8246, 8249, 8252, 8255, 9019, 9391]);
  for (let t = 7755; t <= 7787; t++)
    e.add(t);
  for (let t = 7791; t <= 7795; t++)
    e.add(t);
  for (let t = 7799; t <= 7801; t++)
    e.add(t);
  for (let t = 7825; t <= 7831; t++)
    e.add(t);
  for (let t = 7877; t <= 7878; t++)
    e.add(t);
  for (let t = 7882; t <= 7883; t++)
    e.add(t);
  for (let t = 7991; t <= 7992; t++)
    e.add(t);
  for (let t = 8042; t <= 8043; t++)
    e.add(t);
  for (let t = 8058; t <= 8059; t++)
    e.add(t);
  for (let t = 8311; t <= 8348; t++)
    e.add(t);
  for (let t = 9060; t <= 9067; t++)
    e.add(t);
  for (let t = 102562; t <= 102568; t++)
    e.add(t);
  for (let t = 102799; t <= 102900; t++)
    e.add(t);
  return e;
}]), Ys.push([10.51, () => {
  const e = /* @__PURE__ */ new Set([7683, 7881, 7886, 7899, 8888, 9e3]);
  for (let t = 8013; t <= 8032; t++)
    e.add(t);
  for (let t = 9053; t <= 9057; t++)
    e.add(t);
  for (let t = 104017; t <= 104018; t++)
    e.add(t);
  for (let t = 104971; t <= 104974; t++)
    e.add(t);
  return e;
}]), Ys.push([10.5, () => {
  const e = /* @__PURE__ */ new Set([6962, 7035, 7037, 7039, 7041, 7084, 7086, 7133, 7798, 102399]);
  for (let t = 4087; t <= 4088; t++)
    e.add(t);
  for (let t = 5896; t <= 5899; t++)
    e.add(t);
  for (let t = 7005; t <= 7007; t++)
    e.add(t);
  for (let t = 7057; t <= 7070; t++)
    e.add(t);
  for (let t = 7073; t <= 7082; t++)
    e.add(t);
  for (let t = 7109; t <= 7128; t++)
    e.add(t);
  for (let t = 7844; t <= 7859; t++)
    e.add(t);
  return e;
}]);
async function X0e(e, t, r) {
  const n = e && e.getAtOrigin && e.getAtOrigin("renderer", t.origin);
  if (n && n.type === "unique-value" && n.styleOrigin) {
    const i = await n_(n.populateFromStyle());
    if (lr(r), i.ok === !1) {
      const s = i.error;
      t && t.messages && t.messages.push(new bs("renderer:style-reference", `Failed to create unique value renderer from style reference: ${s.message}`, { error: s, context: t })), e.clear("renderer", t == null ? void 0 : t.origin);
    }
  }
}
var RI;
let oh = RI = class extends re {
  constructor(e) {
    super(e), this.groupByFields = void 0, this.topCount = void 0, this.orderByFields = void 0;
  }
  clone() {
    return new RI({ groupByFields: this.groupByFields, topCount: this.topCount, orderByFields: this.orderByFields });
  }
};
u([d({ type: [String], json: { write: !0 } })], oh.prototype, "groupByFields", void 0), u([d({ type: Number, json: { write: !0 } })], oh.prototype, "topCount", void 0), u([d({ type: [String], json: { write: !0 } })], oh.prototype, "orderByFields", void 0), oh = RI = u([E("geoscene.rest.support.TopFilter")], oh);
const eve = oh;
var LI;
const W4 = new et({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), J4 = new et({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let Dt = LI = class extends re {
  constructor(e) {
    super(e), this.cacheHint = void 0, this.distance = void 0, this.geometry = null, this.geometryPrecision = void 0, this.maxAllowableOffset = void 0, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.resultType = null, this.returnGeometry = !1, this.returnM = void 0, this.returnZ = void 0, this.start = void 0, this.spatialRelationship = "intersects", this.timeExtent = null, this.topFilter = void 0, this.units = null, this.where = "1=1";
  }
  writeStart(e, t) {
    t.resultOffset = this.start, t.resultRecordCount = this.num || 10;
  }
  clone() {
    return new LI(j({ cacheHint: this.cacheHint, distance: this.distance, geometry: this.geometry, geometryPrecision: this.geometryPrecision, maxAllowableOffset: this.maxAllowableOffset, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, resultType: this.resultType, returnGeometry: this.returnGeometry, returnZ: this.returnZ, returnM: this.returnM, start: this.start, spatialRelationship: this.spatialRelationship, timeExtent: this.timeExtent, topFilter: this.topFilter, units: this.units, where: this.where }));
  }
};
u([d({ type: Boolean, json: { write: !0 } })], Dt.prototype, "cacheHint", void 0), u([d({ type: Number, json: { write: { overridePolicy: (e) => ({ enabled: e > 0 }) } } })], Dt.prototype, "distance", void 0), u([d({ types: Qd, json: { read: Pd, write: !0 } })], Dt.prototype, "geometry", void 0), u([d({ type: Number, json: { write: !0 } })], Dt.prototype, "geometryPrecision", void 0), u([d({ type: Number, json: { write: !0 } })], Dt.prototype, "maxAllowableOffset", void 0), u([d({ type: Number, json: { read: { source: "resultRecordCount" } } })], Dt.prototype, "num", void 0), u([d({ json: { write: !0 } })], Dt.prototype, "objectIds", void 0), u([d({ type: [String], json: { write: !0 } })], Dt.prototype, "orderByFields", void 0), u([d({ type: [String], json: { write: !0 } })], Dt.prototype, "outFields", void 0), u([d({ type: tt, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], Dt.prototype, "outSpatialReference", void 0), u([d({ type: String, json: { write: !0 } })], Dt.prototype, "resultType", void 0), u([d({ json: { write: !0 } })], Dt.prototype, "returnGeometry", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Dt.prototype, "returnM", void 0), u([d({ type: Boolean, json: { write: { overridePolicy: (e) => ({ enabled: e }) } } })], Dt.prototype, "returnZ", void 0), u([d({ type: Number, json: { read: { source: "resultOffset" } } })], Dt.prototype, "start", void 0), u([ge("start"), ge("num")], Dt.prototype, "writeStart", null), u([d({ type: String, json: { read: { source: "spatialRel", reader: W4.read }, write: { target: "spatialRel", writer: W4.write } } })], Dt.prototype, "spatialRelationship", void 0), u([d({ type: ha, json: { write: !0 } })], Dt.prototype, "timeExtent", void 0), u([d({ type: eve, json: { write: !0 } })], Dt.prototype, "topFilter", void 0), u([d({ type: String, json: { read: J4.read, write: { writer: J4.write, overridePolicy(e) {
  return { enabled: e != null && this.distance != null && this.distance > 0 };
} } } })], Dt.prototype, "units", void 0), u([d({ type: String, json: { write: !0 } })], Dt.prototype, "where", void 0), Dt = LI = u([E("geoscene.rest.support.TopFeaturesQuery")], Dt), Dt.from = br(Dt);
const gv = Dt;
function tve({ displayField: e, editFieldsInfo: t, fields: r, objectIdField: n, title: i }, s) {
  if (!r)
    return null;
  const o = sve({ editFieldsInfo: t, fields: r, objectIdField: n }, s);
  if (!o.length)
    return null;
  const a = lve({ titleBase: i, fields: r, displayField: e }), l = ave();
  return new zg({ title: a, content: l, fieldInfos: o });
}
const rve = (e, t) => t.visibleFieldNames ? t.visibleFieldNames.has(e.name) : yee(e, t);
function nve(e, t) {
  const r = e;
  return t && (e = e.filter((n) => !t.includes(n.type))), e === r && (e = e.slice()), e.sort(ive), e;
}
function ive(e, t) {
  return e.type === "oid" ? -1 : t.type === "oid" ? 1 : Z4(e) ? -1 : Z4(t) ? 1 : (e.alias || e.name).toLocaleLowerCase().localeCompare((t.alias || t.name).toLocaleLowerCase());
}
function sve(e, t) {
  const r = t == null ? void 0 : t.visibleFieldNames;
  return nve(e.fields ?? [], (t == null ? void 0 : t.ignoreFieldTypes) || uve).map((n) => new jM({ fieldName: n.name, isEditable: mee(n, e), label: n.alias, format: ove(n), visible: rve(n, { ...e, visibleFieldNames: r }) }));
}
function ove(e) {
  switch (e.type) {
    case "small-integer":
    case "integer":
    case "single":
      return new gm({ digitSeparator: !0, places: 0 });
    case "double":
      return new gm({ digitSeparator: !0, places: 2 });
    case "date":
      return new gm({ dateFormat: "long-month-day-year" });
    default:
      return e.type === "string" && Ree(e.name) ? new gm({ digitSeparator: !0, places: 0 }) : null;
  }
}
function ave() {
  return [new eg(), new Qy()];
}
function lve(e) {
  const t = see(e), { titleBase: r } = e;
  return t ? `${r}: {${t.trim()}}` : r ?? "";
}
function Z4(e) {
  return (e.name && e.name.toLowerCase()) === "name" ? !0 : (e.alias && e.alias.toLowerCase()) === "name";
}
const uve = ["geometry", "blob", "raster", "guid", "xml"], Pn = "FeatureLayer", _U = "geoscene.layers.FeatureLayer", cve = se.getLogger(_U);
function vv(e, t) {
  return new G("layer:unsupported", `Layer (${e.title}, ${e.id}) of type '${e.declaredClass}' ${t}`, { layer: e });
}
function K4(e) {
  return e && e instanceof je;
}
const GS = W0e();
function HS(e, t, r) {
  const n = !!(r != null && r.writeLayerSchema);
  return { enabled: n, ignoreOrigin: n };
}
let $e = class extends Gge(C0e(Xye(z0e(qye(iz(L0e(H0e(sz(G0e(Uye(A0e(D0e(Lz(Bye(zye(Rt(EM))))))))))))))))) {
  constructor(...e) {
    super(...e), this._handles = new ca(), this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = !1, this.labelsVisible = !0, this.labelingInfo = null, this.legendEnabled = !0, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = !0, this.popupTemplate = null, this.screenSizePerspectiveEnabled = !0, this.spatialReference = tt.WGS84, this.subtypeCode = null, this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = !0;
  }
  destroy() {
    var e;
    (e = this.source) == null || e.destroy(), this._handles = Vt(this._handles);
  }
  normalizeCtorArgs(e, t) {
    return typeof e == "string" ? { url: e, ...t } : e;
  }
  load(e) {
    var n;
    const t = e != null ? e.signal : null;
    if ((n = this.portalItem) != null && n.loaded && this.source)
      return this.addResolvingPromise(this.createGraphicsSource(t).then((i) => this.initLayerProperties(i))), Promise.resolve(this);
    const r = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection"] }, e).catch(Go).then(async () => {
      if (this.url && this.layerId == null && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const i = await this._fetchFirstLayerId(t);
        i != null && (this.layerId = i);
      }
      if (!this.url && !this._hasMemorySource())
        throw new G("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(t));
    }).then(() => this._setUserPrivileges(this.serviceItemId, e)).then(() => Mge(this, e));
    return this.addResolvingPromise(r), Promise.resolve(this);
  }
  readCapabilities(e, t) {
    return t = t.layerDefinition || t, tU(t, this.url);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    var e;
    return !(this.loaded && !((e = this.capabilities) != null && e.operations.supportsEditing)) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e) {
    this._overrideIfSome("editingEnabled", e);
  }
  readEditingEnabled(e, t) {
    return this._readEditingEnabled(t, !1);
  }
  readEditingEnabledFromWebMap(e, t, r) {
    return this._readEditingEnabled(t, !0, r);
  }
  writeEditingEnabled(e, t) {
    this._writeEditingEnabled(e, t, !1);
  }
  writeEditingEnabledToWebMap(e, t, r, n) {
    this._writeEditingEnabled(e, t, !0, n);
  }
  get effectiveEditingEnabled() {
    return Cge(this);
  }
  readIsTable(e, t) {
    return (t = (t == null ? void 0 : t.layerDefinition) ?? t).type === "Table" || !t.geometryType;
  }
  writeIsTable(e, t, r, n) {
    n != null && n.writeLayerSchema && In(r, e ? "Table" : "Feature Layer", t);
  }
  readGlobalIdField(e, t) {
    return Qz(t.layerDefinition || t);
  }
  readObjectIdField(e, t) {
    return Xz(t.layerDefinition || t);
  }
  get parsedUrl() {
    const e = Di(this.url);
    return e != null && (this.dynamicDataSource != null ? e.path = Rh(e.path, "dynamicLayer") : this.layerId != null && (e.path = Rh(e.path, this.layerId.toString()))), e;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e) {
    fA(e, this.fieldsIndex), this._set("renderer", e);
  }
  readRenderer(e, t, r) {
    var i;
    t = t.layerDefinition || t;
    const n = (i = t.drawingInfo) == null ? void 0 : i.renderer;
    if (n) {
      const s = yg(n, t, r) ?? void 0;
      return s || cve.error("Failed to create renderer", { rendererDefinition: t.drawingInfo.renderer, layer: this, context: r }), s;
    }
    return eC(t, r);
  }
  set source(e) {
    const t = this._get("source");
    t !== e && (K4(t) && this._resetMemorySource(t), K4(e) && this._initMemorySource(e), this._set("source", e));
  }
  castSource(e) {
    return e ? Array.isArray(e) || e instanceof je ? new Ua({ layer: this, items: e }) : e : null;
  }
  readSource(e, t) {
    const r = Gz.fromJSON(t.featureSet);
    return new Ua({ layer: this, items: (r == null ? void 0 : r.features) ?? [] });
  }
  readTemplates(e, t) {
    const r = t.editFieldsInfo, n = r && r.creatorField, i = r && r.editorField;
    return e = e && e.map((s) => sC.fromJSON(s)), this._fixTemplates(e, n), this._fixTemplates(e, i), e;
  }
  readTitle(e, t) {
    var i;
    const r = ((i = t.layerDefinition) == null ? void 0 : i.name) ?? t.name, n = t.title || t.layerDefinition && t.layerDefinition.title;
    if (r) {
      const s = this.portalItem && this.portalItem.title;
      if (this.sublayerTitleMode === "item-title")
        return this.url ? ple(this.url, r) : r;
      let o = r;
      if (!o && this.url) {
        const a = gf(this.url);
        a != null && (o = a.title);
      }
      return o ? (this.sublayerTitleMode === "item-title-and-service-name" && s && s !== o && (o = s + " - " + o), fO(o)) : void 0;
    }
    if (this.sublayerTitleMode === "item-title" && n)
      return n;
  }
  readTitleFromWebMap(e, t) {
    return t.title || t.layerDefinition && t.layerDefinition.name;
  }
  readTypeIdField(e, t) {
    let r = (t = t.layerDefinition || t).typeIdField;
    if (r && t.fields) {
      r = r.toLowerCase();
      const n = t.fields.find((i) => i.name.toLowerCase() === r);
      n && (r = n.name);
    }
    return r;
  }
  readTypes(e, t) {
    e = (t = t.layerDefinition || t).types;
    const r = t.editFieldsInfo, n = r && r.creatorField, i = r && r.editorField;
    return e && e.map((s) => (s = wU.fromJSON(s), this._fixTemplates(s.templates, n), this._fixTemplates(s.templates, i), s));
  }
  readVisible(e, t) {
    return t.layerDefinition && t.layerDefinition.defaultVisibility != null ? !!t.layerDefinition.defaultVisibility : t.visibility != null ? !!t.visibility : void 0;
  }
  async addAttachment(e, t) {
    return pge(this, e, t, Pn);
  }
  async updateAttachment(e, t, r) {
    return hge(this, e, t, r, Pn);
  }
  async applyEdits(e, t) {
    return fge(this, e, t);
  }
  async uploadAssets(e, t) {
    return mge(this, e, t);
  }
  on(e, t) {
    return super.on(e, t);
  }
  createPopupTemplate(e) {
    return tve(this, e);
  }
  async createGraphicsSource(e) {
    if (this._hasMemorySource() && this.source)
      return this.source.load({ signal: e });
    const { default: t } = await CW(import("./FeatureLayerSource-1hIevvRW.js"), e);
    return new t({ layer: this }).load({ signal: e });
  }
  createQuery() {
    const e = Tge(this);
    e.dynamicDataSource = this.dynamicDataSource;
    const t = this.subtypeCode != null ? `${this.subtypeField} = ${this.subtypeCode}` : null, r = _ye(this.definitionExpression, t);
    return e.where = r || "1=1", e;
  }
  async deleteAttachments(e, t) {
    return yge(this, e, t, Pn);
  }
  async fetchRecomputedExtents(e) {
    return gge(this, e, Pn);
  }
  getFeatureType(e) {
    const { typeIdField: t, types: r } = this;
    if (!t || !e)
      return null;
    const n = e.attributes ? e.attributes[t] : void 0;
    if (n == null)
      return null;
    let i = null;
    return r == null || r.some((s) => {
      const { id: o } = s;
      return o != null && (o.toString() === n.toString() && (i = s), !!i);
    }), i;
  }
  getFieldDomain(e, t) {
    const r = t == null ? void 0 : t.feature, n = this.getFeatureType(r);
    if (n) {
      const i = n.domains && n.domains[e];
      if (i && i.type !== "inherited")
        return i;
    }
    return this._getLayerDomain(e);
  }
  getField(e) {
    return this.fieldsIndex.get(e);
  }
  async queryAttachments(e, t) {
    return vge(this, e, t, Pn);
  }
  async queryFeatures(e, t) {
    const r = await this.load(), n = await r.source.queryFeatures(xf.from(e) ?? r.createQuery(), t);
    if (n != null && n.features)
      for (const i of n.features)
        i.layer = i.sourceLayer = r;
    return n;
  }
  async queryObjectIds(e, t) {
    return bge(this, e, t, Pn);
  }
  async queryFeatureCount(e, t) {
    return wge(this, e, t, Pn);
  }
  async queryExtent(e, t) {
    return _ge(this, e, t, Pn);
  }
  async queryRelatedFeatures(e, t) {
    return Sge(this, e, t, Pn);
  }
  async queryRelatedFeaturesCount(e, t) {
    return $ge(this, e, t, Pn);
  }
  async queryTopFeatures(e, t) {
    var s;
    const { source: r, capabilities: n } = await this.load();
    if (!r.queryTopFeatures || !((s = n == null ? void 0 : n.query) != null && s.supportsTopFeaturesQuery))
      throw new G(Pn, "Layer source does not support queryTopFeatures capability");
    const i = await r.queryTopFeatures(gv.from(e), t);
    if (i != null && i.features)
      for (const o of i.features)
        o.layer = o.sourceLayer = this;
    return i;
  }
  async queryTopObjectIds(e, t) {
    const { source: r, capabilities: n } = await this.load();
    if (!r.queryTopObjectIds || !(n != null && n.query.supportsTopFeaturesQuery))
      throw new G(Pn, "Layer source does not support queryTopObjectIds capability");
    return r.queryTopObjectIds(gv.from(e), t);
  }
  async queryTopFeaturesExtent(e, t) {
    var i;
    const { source: r, capabilities: n } = await this.load();
    if (!r.queryTopExtents || !((i = n == null ? void 0 : n.query) != null && i.supportsTopFeaturesQuery))
      throw new G(Pn, "Layer source does not support queryTopExtents capability");
    return r.queryTopExtents(gv.from(e), t);
  }
  async queryTopFeatureCount(e, t) {
    var i;
    const { source: r, capabilities: n } = await this.load();
    if (!r.queryTopCount || !((i = n == null ? void 0 : n.query) != null && i.supportsTopFeaturesQuery))
      throw new G(Pn, "Layer source does not support queryFeatureCount capability");
    return r.queryTopCount(gv.from(e), t);
  }
  read(e, t) {
    const r = e.featureCollection;
    if (r) {
      const n = r.layers;
      n && n.length === 1 && (super.read(n[0], t), r.showLegend != null && super.read({ showLegend: r.showLegend }, t));
    }
    super.read(e, t), t && t.origin === "service" && (this.revert(["objectIdField", "fields", "timeInfo"], "service"), this.spatialReference || this.revert(["spatialReference"], "service"));
  }
  write(e, t) {
    t = { ...t, origin: (t == null ? void 0 : t.origin) ?? void 0, writeLayerSchema: (t == null ? void 0 : t.writeLayerSchema) ?? this._hasMemorySource() };
    const { origin: r, layerContainerType: n, messages: i } = t;
    if (this.dynamicDataSource)
      return i == null || i.push(vv(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if (r === "web-scene" || r === "web-map" && n !== "tables")
        return i == null || i.push(vv(this, "using a table source cannot be written to web scenes and web maps")), null;
      if (this._hasMemorySource())
        return i == null || i.push(vv(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && r === "web-map" && n === "tables")
      return i == null || i.push(vv(this, "using a non-table source cannot be written to tables in web maps")), null;
    return super.write(e, t);
  }
  clone() {
    if (this._hasMemorySource())
      throw new G(Pn, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e) {
    var t;
    return !!this.loaded && (((t = this.source) == null ? void 0 : t.type) === "memory" || Q0e(this, e));
  }
  async save(e) {
    const { save: t } = await import("./featureLayerUtils-5R3AGGVM.js");
    return t(this, e);
  }
  async saveAs(e, t) {
    const { saveAs: r } = await import("./featureLayerUtils-5R3AGGVM.js");
    return r(this, e, t);
  }
  _readEditingEnabled(e, t, r) {
    var i;
    let n = (i = e.layerDefinition) == null ? void 0 : i.capabilities;
    return n ? this._hasEditingCapability(n) : (n = e.capabilities, t && (r == null ? void 0 : r.origin) === "web-map" && !this._hasMemorySource() && n ? this._hasEditingCapability(n) : void 0);
  }
  _hasEditingCapability(e) {
    return e.toLowerCase().split(",").map((t) => t.trim()).includes("editing");
  }
  _writeEditingEnabled(e, t, r, n) {
    var i, s;
    if (!e) {
      const o = (s = (i = this.capabilities) == null ? void 0 : i.operations) != null && s.supportsSync ? "Query,Sync" : "Query";
      In("layerDefinition.capabilities", o, t), r && !(n != null && n.writeLayerSchema) && (t.capabilities = o);
    }
  }
  _getLayerDomain(e) {
    const t = this.fieldsIndex.get(e);
    return t ? t.domain : null;
  }
  _fetchFirstLayerId(e) {
    return zr(this.url, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e }).then((t) => {
      const r = t.data;
      if (r)
        return Array.isArray(r.layers) && r.layers.length > 0 ? r.layers[0].id : Array.isArray(r.tables) && r.tables.length > 0 ? r.tables[0].id : void 0;
    });
  }
  async initLayerProperties(e) {
    var t;
    return this._set("source", e), e.sourceJSON && (this.sourceJSON = e.sourceJSON, this.read(e.sourceJSON, { origin: "service", portalItem: this.portalItem, portal: (t = this.portalItem) == null ? void 0 : t.portal, url: this.parsedUrl })), this._verifySource(), this._verifyFields(), fA(this.renderer, this.fieldsIndex), D8(this.timeInfo, this.fieldsIndex), X0e(this, { origin: "service" });
  }
  async hasDataChanged() {
    return xge(this);
  }
  async fetchPublishingStatus() {
    const e = this.source;
    return e != null && e.fetchPublishingStatus ? e.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    var t, r;
    const e = ((t = this.parsedUrl) == null ? void 0 : t.path) ?? "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e + ")"), this.isTable || this._hasMemorySource() || e.search(/\/FeatureServer\//i) !== -1 || (r = this.fields) != null && r.some((n) => n.type === "geometry") || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e + ")");
  }
  _fixTemplates(e, t) {
    e && e.forEach((r) => {
      const n = r.prototype && r.prototype.attributes;
      n && t && delete n[t];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url)
        throw new G("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url)
      throw new G("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e) {
    e.forEach((t) => {
      t.layer = this, t.sourceLayer = this;
    }), this._handles.add([e.on("after-add", (t) => {
      t.item.layer = this, t.item.sourceLayer = this;
    }), e.on("after-remove", (t) => {
      t.item.layer = null, t.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e) {
    e.forEach((t) => {
      t.layer = null, t.sourceLayer = null;
    }), this._handles.remove("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
};
u([ce("service", "capabilities")], $e.prototype, "readCapabilities", null), u([d({ json: { origins: { "portal-item": { write: !0 }, "web-map": { write: !0 } } } })], $e.prototype, "charts", void 0), u([d({ readOnly: !0 })], $e.prototype, "createQueryVersion", null), u([d({ json: { read: { source: "layerDefinition.copyrightText" } } })], $e.prototype, "copyright", void 0), u([d({ json: { read: { source: "layerDefinition.displayField" } } })], $e.prototype, "displayField", void 0), u([d({ types: vd, readOnly: !0 })], $e.prototype, "defaultSymbol", void 0), u([d({ type: ro })], $e.prototype, "dynamicDataSource", void 0), u([d({ type: Boolean })], $e.prototype, "editingEnabled", null), u([ce(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], $e.prototype, "readEditingEnabled", null), u([ce("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], $e.prototype, "readEditingEnabledFromWebMap", null), u([ge(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], $e.prototype, "writeEditingEnabled", null), u([ge("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], $e.prototype, "writeEditingEnabledToWebMap", null), u([d({ readOnly: !0 })], $e.prototype, "effectiveEditingEnabled", null), u([d({ ...GS.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: HS } } } } })], $e.prototype, "fields", void 0), u([d(GS.fieldsIndex)], $e.prototype, "fieldsIndex", void 0), u([d({ type: Rye, json: { name: "formInfo", write: !0, origins: { "web-scene": { read: !1, write: !1 } } } })], $e.prototype, "formTemplate", void 0), u([d({ json: { read: { source: "layerDefinition.extent" } } })], $e.prototype, "fullExtent", void 0), u([d({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: HS, writer(e, t, r) {
  const n = e ? $I.toJSON(e) : null;
  n && In(r, n, t);
} } } }, read: { source: "layerDefinition.geometryType", reader: $I.read } } })], $e.prototype, "geometryType", void 0), u([d({ json: { read: { source: "layerDefinition.hasM" } } })], $e.prototype, "hasM", void 0), u([d({ json: { read: { source: "layerDefinition.hasZ" } } })], $e.prototype, "hasZ", void 0), u([d(age)], $e.prototype, "id", void 0), u([d({ readOnly: !0, json: { origins: { service: { read: !0 } }, read: !1 } })], $e.prototype, "infoFor3D", void 0), u([d({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], $e.prototype, "isTable", void 0), u([ce("service", "isTable", ["type", "geometryType"]), ce("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], $e.prototype, "readIsTable", null), u([ge("web-map", "isTable")], $e.prototype, "writeIsTable", null), u([d(YO)], $e.prototype, "labelsVisible", void 0), u([d({ type: [q_], json: { origins: { service: { read: { source: "drawingInfo.labelingInfo", reader: H4 }, write: { target: "drawingInfo.labelingInfo", enabled: !1 } } }, read: { source: "layerDefinition.drawingInfo.labelingInfo", reader: H4 }, write: { target: "layerDefinition.drawingInfo.labelingInfo" } } })], $e.prototype, "labelingInfo", void 0), u([d((() => {
  const e = j(oge);
  return e.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(t, r, n) {
    In(n, u_(t), r);
  } } }, e;
})())], $e.prototype, "opacity", void 0), u([d(ige)], $e.prototype, "legendEnabled", void 0), u([d({ type: ["show", "hide"], json: (() => {
  const e = j(Yz.json);
  return e.origins["portal-item"] = { read: !1, write: !1 }, e;
})() })], $e.prototype, "listMode", void 0), u([ce("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], $e.prototype, "readGlobalIdField", null), u([d({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: HS } } } } })], $e.prototype, "objectIdField", void 0), u([ce("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], $e.prototype, "readObjectIdField", null), u([d({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], $e.prototype, "operationalLayerType", void 0), u([d(GS.outFields)], $e.prototype, "outFields", void 0), u([d({ readOnly: !0 })], $e.prototype, "parsedUrl", null), u([d({ type: String, json: { origins: { "web-scene": { read: !0, write: !0 } }, read: !1 } })], $e.prototype, "path", void 0), u([d(KO)], $e.prototype, "popupEnabled", void 0), u([d({ type: zg, json: { name: "popupInfo", write: !0 } })], $e.prototype, "popupTemplate", void 0), u([d({ readOnly: !0 })], $e.prototype, "defaultPopupTemplate", null), u([d({ types: U_, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: !1 } }, "web-scene": { types: yye, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e, t, r) => ({ ignoreOrigin: r == null ? void 0 : r.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e, t, r) => ({ ignoreOrigin: r == null ? void 0 : r.writeLayerSchema }) } } })], $e.prototype, "renderer", null), u([ce("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), ce("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], $e.prototype, "readRenderer", null), u([d((() => {
  const e = j(rge);
  return e.json.origins["portal-item"] = { read: !1, write: !1 }, e;
})())], $e.prototype, "screenSizePerspectiveEnabled", void 0), u([d({ clonable: !1 })], $e.prototype, "source", null), u([xt("source")], $e.prototype, "castSource", null), u([ce("portal-item", "source", ["featureSet"]), ce("web-map", "source", ["featureSet"])], $e.prototype, "readSource", null), u([d({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], $e.prototype, "spatialReference", void 0), u([d({ type: Number })], $e.prototype, "subtypeCode", void 0), u([d({ type: [sC] })], $e.prototype, "templates", void 0), u([ce("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], $e.prototype, "readTemplates", null), u([d({ type: bU })], $e.prototype, "timeInfo", void 0), u([d()], $e.prototype, "title", void 0), u([ce("service", "title", ["name"]), ce("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], $e.prototype, "readTitle", null), u([ce("web-map", "title", ["layerDefinition.name", "title"])], $e.prototype, "readTitleFromWebMap", null), u([d({ type: String })], $e.prototype, "sublayerTitleMode", void 0), u([d({ json: { read: !1 } })], $e.prototype, "type", void 0), u([d({ type: String })], $e.prototype, "typeIdField", void 0), u([ce("service", "typeIdField"), ce("typeIdField", ["layerDefinition.typeIdField"])], $e.prototype, "readTypeIdField", null), u([d({ type: [wU] })], $e.prototype, "types", void 0), u([ce("service", "types", ["types"]), ce("types", ["layerDefinition.types"])], $e.prototype, "readTypes", null), u([d({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], $e.prototype, "visible", void 0), u([ce("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], $e.prototype, "readVisible", null), $e = u([E(_U)], $e);
const SU = $e, vFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: SU
}, Symbol.toStringTag, { value: "Module" })), $U = (e) => !e.getAttribute("aria-owns"), xU = (e, t, r) => {
  const { parentNode: n } = e;
  if (!n)
    return null;
  const i = n.querySelectorAll(r), s = Array.prototype.indexOf.call(i, e);
  return i[s + t] || null;
}, B1 = (e) => {
  e && (e.focus(), !$U(e) && e.click());
}, Ba = (e, t, { checkForDefaultPrevented: r = !0 } = {}) => (i) => {
  const s = e == null ? void 0 : e(i);
  if (r === !1 || !s)
    return t == null ? void 0 : t(i);
};
var Y4;
const Pt = typeof window < "u", dve = (e) => typeof e == "string", bw = () => {
}, TU = Pt && ((Y4 = window == null ? void 0 : window.navigator) == null ? void 0 : Y4.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Ud(e) {
  return typeof e == "function" ? e() : _(e);
}
function pve(e, t) {
  function r(...n) {
    return new Promise((i, s) => {
      Promise.resolve(e(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(i).catch(s);
    });
  }
  return r;
}
function hve(e, t = {}) {
  let r, n, i = bw;
  const s = (a) => {
    clearTimeout(a), i(), i = bw;
  };
  return (a) => {
    const l = Ud(e), c = Ud(t.maxWait);
    return r && s(r), l <= 0 || c !== void 0 && c <= 0 ? (n && (s(n), n = null), Promise.resolve(a())) : new Promise((h, f) => {
      i = t.rejectOnCancel ? f : h, c && !n && (n = setTimeout(() => {
        r && s(r), n = null, h(a());
      }, c)), r = setTimeout(() => {
        n && s(n), n = null, h(a());
      }, l);
    });
  };
}
function fve(e) {
  return e;
}
function H_(e) {
  return uG() ? (c5(e), !0) : !1;
}
function mve(e, t = 200, r = {}) {
  return pve(hve(t, r), e);
}
function yve(e, t = 200, r = {}) {
  const n = q(e.value), i = mve(() => {
    n.value = e.value;
  }, t, r);
  return Se(e, () => i()), n;
}
function gve(e, t = !0) {
  nn() ? qt(e) : t ? e() : Ye(e);
}
function ww(e, t, r = {}) {
  const {
    immediate: n = !0
  } = r, i = q(!1);
  let s = null;
  function o() {
    s && (clearTimeout(s), s = null);
  }
  function a() {
    i.value = !1, o();
  }
  function l(...c) {
    o(), i.value = !0, s = setTimeout(() => {
      i.value = !1, s = null, e(...c);
    }, Ud(t));
  }
  return n && (i.value = !0, Pt && l()), H_(a), {
    isPending: d5(i),
    start: l,
    stop: a
  };
}
function Ka(e) {
  var t;
  const r = Ud(e);
  return (t = r == null ? void 0 : r.$el) != null ? t : r;
}
const W_ = Pt ? window : void 0;
function rl(...e) {
  let t, r, n, i;
  if (dve(e[0]) || Array.isArray(e[0]) ? ([r, n, i] = e, t = W_) : [t, r, n, i] = e, !t)
    return bw;
  Array.isArray(r) || (r = [r]), Array.isArray(n) || (n = [n]);
  const s = [], o = () => {
    s.forEach((h) => h()), s.length = 0;
  }, a = (h, f, m, y) => (h.addEventListener(f, m, y), () => h.removeEventListener(f, m, y)), l = Se(() => [Ka(t), Ud(i)], ([h, f]) => {
    o(), h && s.push(...r.flatMap((m) => n.map((y) => a(h, m, y, f))));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), o();
  };
  return H_(c), c;
}
let Q4 = !1;
function vve(e, t, r = {}) {
  const { window: n = W_, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = r;
  if (!n)
    return;
  TU && !Q4 && (Q4 = !0, Array.from(n.document.body.children).forEach((m) => m.addEventListener("click", bw)));
  let a = !0;
  const l = (m) => i.some((y) => {
    if (typeof y == "string")
      return Array.from(n.document.querySelectorAll(y)).some((g) => g === m.target || m.composedPath().includes(g));
    {
      const g = Ka(y);
      return g && (m.target === g || m.composedPath().includes(g));
    }
  }), h = [
    rl(n, "click", (m) => {
      const y = Ka(e);
      if (!(!y || y === m.target || m.composedPath().includes(y))) {
        if (m.detail === 0 && (a = !l(m)), !a) {
          a = !0;
          return;
        }
        t(m);
      }
    }, { passive: !0, capture: s }),
    rl(n, "pointerdown", (m) => {
      const y = Ka(e);
      y && (a = !m.composedPath().includes(y) && !l(m));
    }, { passive: !0 }),
    o && rl(n, "blur", (m) => {
      var y;
      const g = Ka(e);
      ((y = n.document.activeElement) == null ? void 0 : y.tagName) === "IFRAME" && !(g != null && g.contains(n.document.activeElement)) && t(m);
    })
  ].filter(Boolean);
  return () => h.forEach((m) => m());
}
function bve(e, t = !1) {
  const r = q(), n = () => r.value = !!e();
  return n(), gve(n, t), r;
}
const X4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, eL = "__vueuse_ssr_handlers__";
X4[eL] = X4[eL] || {};
function wve(e, t, { window: r = W_, initialValue: n = "" } = {}) {
  const i = q(n), s = A(() => {
    var o;
    return Ka(t) || ((o = r == null ? void 0 : r.document) == null ? void 0 : o.documentElement);
  });
  return Se([s, () => Ud(e)], ([o, a]) => {
    var l;
    if (o && r) {
      const c = (l = r.getComputedStyle(o).getPropertyValue(a)) == null ? void 0 : l.trim();
      i.value = c || n;
    }
  }, { immediate: !0 }), Se(i, (o) => {
    var a;
    (a = s.value) != null && a.style && s.value.style.setProperty(Ud(e), o);
  }), i;
}
var tL = Object.getOwnPropertySymbols, _ve = Object.prototype.hasOwnProperty, Sve = Object.prototype.propertyIsEnumerable, $ve = (e, t) => {
  var r = {};
  for (var n in e)
    _ve.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && tL)
    for (var n of tL(e))
      t.indexOf(n) < 0 && Sve.call(e, n) && (r[n] = e[n]);
  return r;
};
function ip(e, t, r = {}) {
  const n = r, { window: i = W_ } = n, s = $ve(n, ["window"]);
  let o;
  const a = bve(() => i && "ResizeObserver" in i), l = () => {
    o && (o.disconnect(), o = void 0);
  }, c = Se(() => Ka(e), (f) => {
    l(), a.value && i && f && (o = new ResizeObserver(t), o.observe(f, s));
  }, { immediate: !0, flush: "post" }), h = () => {
    l(), c();
  };
  return H_(h), {
    isSupported: a,
    stop: h
  };
}
var rL;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(rL || (rL = {}));
var xve = Object.defineProperty, nL = Object.getOwnPropertySymbols, Tve = Object.prototype.hasOwnProperty, Eve = Object.prototype.propertyIsEnumerable, iL = (e, t, r) => t in e ? xve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ive = (e, t) => {
  for (var r in t || (t = {}))
    Tve.call(t, r) && iL(e, r, t[r]);
  if (nL)
    for (var r of nL(t))
      Eve.call(t, r) && iL(e, r, t[r]);
  return e;
};
const Mve = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Ive({
  linear: fve
}, Mve);
const Ove = () => Pt && /firefox/i.test(window.navigator.userAgent);
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const Xo = () => {
}, EU = Object.assign, Cve = Object.prototype.hasOwnProperty, sL = (e, t) => Cve.call(e, t), ul = Array.isArray, er = (e) => typeof e == "function", nr = (e) => typeof e == "string", kve = (e) => typeof e == "symbol", En = (e) => e !== null && typeof e == "object", NI = (e) => (En(e) || er(e)) && er(e.then) && er(e.catch), Ave = Object.prototype.toString, Pve = (e) => Ave.call(e), WS = (e) => Pve(e).slice(8, -1), oC = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (r) => t[r] || (t[r] = e(r));
}, Rve = /-(\w)/g, Lve = oC((e) => e.replace(Rve, (t, r) => r ? r.toUpperCase() : "")), Nve = /\B([A-Z])/g, Fve = oC(
  (e) => e.replace(Nve, "-$1").toLowerCase()
), Dve = oC((e) => e.charAt(0).toUpperCase() + e.slice(1));
var jve = typeof global == "object" && global && global.Object === Object && global;
const IU = jve;
var Vve = typeof self == "object" && self && self.Object === Object && self, zve = IU || Vve || Function("return this")();
const bo = zve;
var Uve = bo.Symbol;
const _s = Uve;
var MU = Object.prototype, Bve = MU.hasOwnProperty, qve = MU.toString, nm = _s ? _s.toStringTag : void 0;
function Gve(e) {
  var t = Bve.call(e, nm), r = e[nm];
  try {
    e[nm] = void 0;
    var n = !0;
  } catch {
  }
  var i = qve.call(e);
  return n && (t ? e[nm] = r : delete e[nm]), i;
}
var Hve = Object.prototype, Wve = Hve.toString;
function Jve(e) {
  return Wve.call(e);
}
var Zve = "[object Null]", Kve = "[object Undefined]", oL = _s ? _s.toStringTag : void 0;
function Tf(e) {
  return e == null ? e === void 0 ? Kve : Zve : oL && oL in Object(e) ? Gve(e) : Jve(e);
}
function Nu(e) {
  return e != null && typeof e == "object";
}
var Yve = "[object Symbol]";
function J_(e) {
  return typeof e == "symbol" || Nu(e) && Tf(e) == Yve;
}
function Qve(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var Xve = Array.isArray;
const Ss = Xve;
var e1e = 1 / 0, aL = _s ? _s.prototype : void 0, lL = aL ? aL.toString : void 0;
function OU(e) {
  if (typeof e == "string")
    return e;
  if (Ss(e))
    return Qve(e, OU) + "";
  if (J_(e))
    return lL ? lL.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -e1e ? "-0" : t;
}
var t1e = /\s/;
function r1e(e) {
  for (var t = e.length; t-- && t1e.test(e.charAt(t)); )
    ;
  return t;
}
var n1e = /^\s+/;
function i1e(e) {
  return e && e.slice(0, r1e(e) + 1).replace(n1e, "");
}
function yo(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var uL = NaN, s1e = /^[-+]0x[0-9a-f]+$/i, o1e = /^0b[01]+$/i, a1e = /^0o[0-7]+$/i, l1e = parseInt;
function FI(e) {
  if (typeof e == "number")
    return e;
  if (J_(e))
    return uL;
  if (yo(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = yo(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = i1e(e);
  var r = o1e.test(e);
  return r || a1e.test(e) ? l1e(e.slice(2), r ? 2 : 8) : s1e.test(e) ? uL : +e;
}
var cL = 1 / 0, u1e = 17976931348623157e292;
function c1e(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = FI(e), e === cL || e === -cL) {
    var t = e < 0 ? -1 : 1;
    return t * u1e;
  }
  return e === e ? e : 0;
}
function d1e(e) {
  var t = c1e(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
function CU(e) {
  return e;
}
var p1e = "[object AsyncFunction]", h1e = "[object Function]", f1e = "[object GeneratorFunction]", m1e = "[object Proxy]";
function kU(e) {
  if (!yo(e))
    return !1;
  var t = Tf(e);
  return t == h1e || t == f1e || t == p1e || t == m1e;
}
var y1e = bo["__core-js_shared__"];
const JS = y1e;
var dL = function() {
  var e = /[^.]+$/.exec(JS && JS.keys && JS.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function g1e(e) {
  return !!dL && dL in e;
}
var v1e = Function.prototype, b1e = v1e.toString;
function sp(e) {
  if (e != null) {
    try {
      return b1e.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var w1e = /[\\^$.*+?()[\]{}|]/g, _1e = /^\[object .+?Constructor\]$/, S1e = Function.prototype, $1e = Object.prototype, x1e = S1e.toString, T1e = $1e.hasOwnProperty, E1e = RegExp(
  "^" + x1e.call(T1e).replace(w1e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function I1e(e) {
  if (!yo(e) || g1e(e))
    return !1;
  var t = kU(e) ? E1e : _1e;
  return t.test(sp(e));
}
function M1e(e, t) {
  return e == null ? void 0 : e[t];
}
function op(e, t) {
  var r = M1e(e, t);
  return I1e(r) ? r : void 0;
}
var O1e = op(bo, "WeakMap");
const DI = O1e;
var pL = Object.create, C1e = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!yo(t))
      return {};
    if (pL)
      return pL(t);
    e.prototype = t;
    var r = new e();
    return e.prototype = void 0, r;
  };
}();
const k1e = C1e;
function A1e(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
function P1e(e, t) {
  var r = -1, n = e.length;
  for (t || (t = Array(n)); ++r < n; )
    t[r] = e[r];
  return t;
}
var R1e = 800, L1e = 16, N1e = Date.now;
function F1e(e) {
  var t = 0, r = 0;
  return function() {
    var n = N1e(), i = L1e - (n - r);
    if (r = n, i > 0) {
      if (++t >= R1e)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function D1e(e) {
  return function() {
    return e;
  };
}
var j1e = function() {
  try {
    var e = op(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
const _w = j1e;
var V1e = _w ? function(e, t) {
  return _w(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: D1e(t),
    writable: !0
  });
} : CU;
const z1e = V1e;
var U1e = F1e(z1e);
const B1e = U1e;
function q1e(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n && t(e[r], r, e) !== !1; )
    ;
  return e;
}
function G1e(e, t, r, n) {
  for (var i = e.length, s = r + (n ? 1 : -1); n ? s-- : ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
var H1e = 9007199254740991, W1e = /^(?:0|[1-9]\d*)$/;
function aC(e, t) {
  var r = typeof e;
  return t = t ?? H1e, !!t && (r == "number" || r != "symbol" && W1e.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function AU(e, t, r) {
  t == "__proto__" && _w ? _w(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
function lC(e, t) {
  return e === t || e !== e && t !== t;
}
var J1e = Object.prototype, Z1e = J1e.hasOwnProperty;
function uC(e, t, r) {
  var n = e[t];
  (!(Z1e.call(e, t) && lC(n, r)) || r === void 0 && !(t in e)) && AU(e, t, r);
}
function Z_(e, t, r, n) {
  var i = !r;
  r || (r = {});
  for (var s = -1, o = t.length; ++s < o; ) {
    var a = t[s], l = n ? n(r[a], e[a], a, r, e) : void 0;
    l === void 0 && (l = e[a]), i ? AU(r, a, l) : uC(r, a, l);
  }
  return r;
}
var hL = Math.max;
function K1e(e, t, r) {
  return t = hL(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var n = arguments, i = -1, s = hL(n.length - t, 0), o = Array(s); ++i < s; )
      o[i] = n[t + i];
    i = -1;
    for (var a = Array(t + 1); ++i < t; )
      a[i] = n[i];
    return a[t] = r(o), A1e(e, this, a);
  };
}
var Y1e = 9007199254740991;
function cC(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Y1e;
}
function PU(e) {
  return e != null && cC(e.length) && !kU(e);
}
var Q1e = Object.prototype;
function dC(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || Q1e;
  return e === r;
}
function X1e(e, t) {
  for (var r = -1, n = Array(e); ++r < e; )
    n[r] = t(r);
  return n;
}
var ebe = "[object Arguments]";
function fL(e) {
  return Nu(e) && Tf(e) == ebe;
}
var RU = Object.prototype, tbe = RU.hasOwnProperty, rbe = RU.propertyIsEnumerable, nbe = fL(/* @__PURE__ */ function() {
  return arguments;
}()) ? fL : function(e) {
  return Nu(e) && tbe.call(e, "callee") && !rbe.call(e, "callee");
};
const pC = nbe;
function ibe() {
  return !1;
}
var LU = typeof exports == "object" && exports && !exports.nodeType && exports, mL = LU && typeof module == "object" && module && !module.nodeType && module, sbe = mL && mL.exports === LU, yL = sbe ? bo.Buffer : void 0, obe = yL ? yL.isBuffer : void 0, abe = obe || ibe;
const Sw = abe;
var lbe = "[object Arguments]", ube = "[object Array]", cbe = "[object Boolean]", dbe = "[object Date]", pbe = "[object Error]", hbe = "[object Function]", fbe = "[object Map]", mbe = "[object Number]", ybe = "[object Object]", gbe = "[object RegExp]", vbe = "[object Set]", bbe = "[object String]", wbe = "[object WeakMap]", _be = "[object ArrayBuffer]", Sbe = "[object DataView]", $be = "[object Float32Array]", xbe = "[object Float64Array]", Tbe = "[object Int8Array]", Ebe = "[object Int16Array]", Ibe = "[object Int32Array]", Mbe = "[object Uint8Array]", Obe = "[object Uint8ClampedArray]", Cbe = "[object Uint16Array]", kbe = "[object Uint32Array]", Jt = {};
Jt[$be] = Jt[xbe] = Jt[Tbe] = Jt[Ebe] = Jt[Ibe] = Jt[Mbe] = Jt[Obe] = Jt[Cbe] = Jt[kbe] = !0;
Jt[lbe] = Jt[ube] = Jt[_be] = Jt[cbe] = Jt[Sbe] = Jt[dbe] = Jt[pbe] = Jt[hbe] = Jt[fbe] = Jt[mbe] = Jt[ybe] = Jt[gbe] = Jt[vbe] = Jt[bbe] = Jt[wbe] = !1;
function Abe(e) {
  return Nu(e) && cC(e.length) && !!Jt[Tf(e)];
}
function hC(e) {
  return function(t) {
    return e(t);
  };
}
var NU = typeof exports == "object" && exports && !exports.nodeType && exports, Cy = NU && typeof module == "object" && module && !module.nodeType && module, Pbe = Cy && Cy.exports === NU, ZS = Pbe && IU.process, Rbe = function() {
  try {
    var e = Cy && Cy.require && Cy.require("util").types;
    return e || ZS && ZS.binding && ZS.binding("util");
  } catch {
  }
}();
const Gh = Rbe;
var gL = Gh && Gh.isTypedArray, Lbe = gL ? hC(gL) : Abe;
const FU = Lbe;
var Nbe = Object.prototype, Fbe = Nbe.hasOwnProperty;
function DU(e, t) {
  var r = Ss(e), n = !r && pC(e), i = !r && !n && Sw(e), s = !r && !n && !i && FU(e), o = r || n || i || s, a = o ? X1e(e.length, String) : [], l = a.length;
  for (var c in e)
    (t || Fbe.call(e, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    aC(c, l))) && a.push(c);
  return a;
}
function jU(e, t) {
  return function(r) {
    return e(t(r));
  };
}
var Dbe = jU(Object.keys, Object);
const jbe = Dbe;
var Vbe = Object.prototype, zbe = Vbe.hasOwnProperty;
function Ube(e) {
  if (!dC(e))
    return jbe(e);
  var t = [];
  for (var r in Object(e))
    zbe.call(e, r) && r != "constructor" && t.push(r);
  return t;
}
function K_(e) {
  return PU(e) ? DU(e) : Ube(e);
}
function Bbe(e) {
  var t = [];
  if (e != null)
    for (var r in Object(e))
      t.push(r);
  return t;
}
var qbe = Object.prototype, Gbe = qbe.hasOwnProperty;
function Hbe(e) {
  if (!yo(e))
    return Bbe(e);
  var t = dC(e), r = [];
  for (var n in e)
    n == "constructor" && (t || !Gbe.call(e, n)) || r.push(n);
  return r;
}
function fC(e) {
  return PU(e) ? DU(e, !0) : Hbe(e);
}
var Wbe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Jbe = /^\w*$/;
function mC(e, t) {
  if (Ss(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || J_(e) ? !0 : Jbe.test(e) || !Wbe.test(e) || t != null && e in Object(t);
}
var Zbe = op(Object, "create");
const vg = Zbe;
function Kbe() {
  this.__data__ = vg ? vg(null) : {}, this.size = 0;
}
function Ybe(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Qbe = "__lodash_hash_undefined__", Xbe = Object.prototype, ewe = Xbe.hasOwnProperty;
function twe(e) {
  var t = this.__data__;
  if (vg) {
    var r = t[e];
    return r === Qbe ? void 0 : r;
  }
  return ewe.call(t, e) ? t[e] : void 0;
}
var rwe = Object.prototype, nwe = rwe.hasOwnProperty;
function iwe(e) {
  var t = this.__data__;
  return vg ? t[e] !== void 0 : nwe.call(t, e);
}
var swe = "__lodash_hash_undefined__";
function owe(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = vg && t === void 0 ? swe : t, this;
}
function Bd(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Bd.prototype.clear = Kbe;
Bd.prototype.delete = Ybe;
Bd.prototype.get = twe;
Bd.prototype.has = iwe;
Bd.prototype.set = owe;
function awe() {
  this.__data__ = [], this.size = 0;
}
function Y_(e, t) {
  for (var r = e.length; r--; )
    if (lC(e[r][0], t))
      return r;
  return -1;
}
var lwe = Array.prototype, uwe = lwe.splice;
function cwe(e) {
  var t = this.__data__, r = Y_(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : uwe.call(t, r, 1), --this.size, !0;
}
function dwe(e) {
  var t = this.__data__, r = Y_(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function pwe(e) {
  return Y_(this.__data__, e) > -1;
}
function hwe(e, t) {
  var r = this.__data__, n = Y_(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
function ml(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
ml.prototype.clear = awe;
ml.prototype.delete = cwe;
ml.prototype.get = dwe;
ml.prototype.has = pwe;
ml.prototype.set = hwe;
var fwe = op(bo, "Map");
const bg = fwe;
function mwe() {
  this.size = 0, this.__data__ = {
    hash: new Bd(),
    map: new (bg || ml)(),
    string: new Bd()
  };
}
function ywe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Q_(e, t) {
  var r = e.__data__;
  return ywe(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function gwe(e) {
  var t = Q_(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function vwe(e) {
  return Q_(this, e).get(e);
}
function bwe(e) {
  return Q_(this, e).has(e);
}
function wwe(e, t) {
  var r = Q_(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
function yl(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
yl.prototype.clear = mwe;
yl.prototype.delete = gwe;
yl.prototype.get = vwe;
yl.prototype.has = bwe;
yl.prototype.set = wwe;
var _we = "Expected a function";
function yC(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(_we);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var o = e.apply(this, n);
    return r.cache = s.set(i, o) || s, o;
  };
  return r.cache = new (yC.Cache || yl)(), r;
}
yC.Cache = yl;
var Swe = 500;
function $we(e) {
  var t = yC(e, function(n) {
    return r.size === Swe && r.clear(), n;
  }), r = t.cache;
  return t;
}
var xwe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Twe = /\\(\\)?/g, Ewe = $we(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(xwe, function(r, n, i, s) {
    t.push(i ? s.replace(Twe, "$1") : n || r);
  }), t;
});
const Iwe = Ewe;
function Mwe(e) {
  return e == null ? "" : OU(e);
}
function X_(e, t) {
  return Ss(e) ? e : mC(e, t) ? [e] : Iwe(Mwe(e));
}
var Owe = 1 / 0;
function s0(e) {
  if (typeof e == "string" || J_(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -Owe ? "-0" : t;
}
function gC(e, t) {
  t = X_(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[s0(t[r++])];
  return r && r == n ? e : void 0;
}
function ai(e, t, r) {
  var n = e == null ? void 0 : gC(e, t);
  return n === void 0 ? r : n;
}
function vC(e, t) {
  for (var r = -1, n = t.length, i = e.length; ++r < n; )
    e[i + r] = t[r];
  return e;
}
var vL = _s ? _s.isConcatSpreadable : void 0;
function Cwe(e) {
  return Ss(e) || pC(e) || !!(vL && e && e[vL]);
}
function bC(e, t, r, n, i) {
  var s = -1, o = e.length;
  for (r || (r = Cwe), i || (i = []); ++s < o; ) {
    var a = e[s];
    t > 0 && r(a) ? t > 1 ? bC(a, t - 1, r, n, i) : vC(i, a) : n || (i[i.length] = a);
  }
  return i;
}
function kwe(e) {
  var t = e == null ? 0 : e.length;
  return t ? bC(e, 1) : [];
}
function Awe(e) {
  return B1e(K1e(e, void 0, kwe), e + "");
}
var Pwe = jU(Object.getPrototypeOf, Object);
const VU = Pwe;
function jI() {
  if (!arguments.length)
    return [];
  var e = arguments[0];
  return Ss(e) ? e : [e];
}
function Rwe() {
  this.__data__ = new ml(), this.size = 0;
}
function Lwe(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
function Nwe(e) {
  return this.__data__.get(e);
}
function Fwe(e) {
  return this.__data__.has(e);
}
var Dwe = 200;
function jwe(e, t) {
  var r = this.__data__;
  if (r instanceof ml) {
    var n = r.__data__;
    if (!bg || n.length < Dwe - 1)
      return n.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new yl(n);
  }
  return r.set(e, t), this.size = r.size, this;
}
function ea(e) {
  var t = this.__data__ = new ml(e);
  this.size = t.size;
}
ea.prototype.clear = Rwe;
ea.prototype.delete = Lwe;
ea.prototype.get = Nwe;
ea.prototype.has = Fwe;
ea.prototype.set = jwe;
function Vwe(e, t) {
  return e && Z_(t, K_(t), e);
}
function zwe(e, t) {
  return e && Z_(t, fC(t), e);
}
var zU = typeof exports == "object" && exports && !exports.nodeType && exports, bL = zU && typeof module == "object" && module && !module.nodeType && module, Uwe = bL && bL.exports === zU, wL = Uwe ? bo.Buffer : void 0, _L = wL ? wL.allocUnsafe : void 0;
function Bwe(e, t) {
  if (t)
    return e.slice();
  var r = e.length, n = _L ? _L(r) : new e.constructor(r);
  return e.copy(n), n;
}
function qwe(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
    var o = e[r];
    t(o, r, e) && (s[i++] = o);
  }
  return s;
}
function UU() {
  return [];
}
var Gwe = Object.prototype, Hwe = Gwe.propertyIsEnumerable, SL = Object.getOwnPropertySymbols, Wwe = SL ? function(e) {
  return e == null ? [] : (e = Object(e), qwe(SL(e), function(t) {
    return Hwe.call(e, t);
  }));
} : UU;
const wC = Wwe;
function Jwe(e, t) {
  return Z_(e, wC(e), t);
}
var Zwe = Object.getOwnPropertySymbols, Kwe = Zwe ? function(e) {
  for (var t = []; e; )
    vC(t, wC(e)), e = VU(e);
  return t;
} : UU;
const BU = Kwe;
function Ywe(e, t) {
  return Z_(e, BU(e), t);
}
function qU(e, t, r) {
  var n = t(e);
  return Ss(e) ? n : vC(n, r(e));
}
function VI(e) {
  return qU(e, K_, wC);
}
function Qwe(e) {
  return qU(e, fC, BU);
}
var Xwe = op(bo, "DataView");
const zI = Xwe;
var e_e = op(bo, "Promise");
const UI = e_e;
var t_e = op(bo, "Set");
const BI = t_e;
var $L = "[object Map]", r_e = "[object Object]", xL = "[object Promise]", TL = "[object Set]", EL = "[object WeakMap]", IL = "[object DataView]", n_e = sp(zI), i_e = sp(bg), s_e = sp(UI), o_e = sp(BI), a_e = sp(DI), Gc = Tf;
(zI && Gc(new zI(new ArrayBuffer(1))) != IL || bg && Gc(new bg()) != $L || UI && Gc(UI.resolve()) != xL || BI && Gc(new BI()) != TL || DI && Gc(new DI()) != EL) && (Gc = function(e) {
  var t = Tf(e), r = t == r_e ? e.constructor : void 0, n = r ? sp(r) : "";
  if (n)
    switch (n) {
      case n_e:
        return IL;
      case i_e:
        return $L;
      case s_e:
        return xL;
      case o_e:
        return TL;
      case a_e:
        return EL;
    }
  return t;
});
const wg = Gc;
var l_e = Object.prototype, u_e = l_e.hasOwnProperty;
function c_e(e) {
  var t = e.length, r = new e.constructor(t);
  return t && typeof e[0] == "string" && u_e.call(e, "index") && (r.index = e.index, r.input = e.input), r;
}
var d_e = bo.Uint8Array;
const $w = d_e;
function _C(e) {
  var t = new e.constructor(e.byteLength);
  return new $w(t).set(new $w(e)), t;
}
function p_e(e, t) {
  var r = t ? _C(e.buffer) : e.buffer;
  return new e.constructor(r, e.byteOffset, e.byteLength);
}
var h_e = /\w*$/;
function f_e(e) {
  var t = new e.constructor(e.source, h_e.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var ML = _s ? _s.prototype : void 0, OL = ML ? ML.valueOf : void 0;
function m_e(e) {
  return OL ? Object(OL.call(e)) : {};
}
function y_e(e, t) {
  var r = t ? _C(e.buffer) : e.buffer;
  return new e.constructor(r, e.byteOffset, e.length);
}
var g_e = "[object Boolean]", v_e = "[object Date]", b_e = "[object Map]", w_e = "[object Number]", __e = "[object RegExp]", S_e = "[object Set]", $_e = "[object String]", x_e = "[object Symbol]", T_e = "[object ArrayBuffer]", E_e = "[object DataView]", I_e = "[object Float32Array]", M_e = "[object Float64Array]", O_e = "[object Int8Array]", C_e = "[object Int16Array]", k_e = "[object Int32Array]", A_e = "[object Uint8Array]", P_e = "[object Uint8ClampedArray]", R_e = "[object Uint16Array]", L_e = "[object Uint32Array]";
function N_e(e, t, r) {
  var n = e.constructor;
  switch (t) {
    case T_e:
      return _C(e);
    case g_e:
    case v_e:
      return new n(+e);
    case E_e:
      return p_e(e, r);
    case I_e:
    case M_e:
    case O_e:
    case C_e:
    case k_e:
    case A_e:
    case P_e:
    case R_e:
    case L_e:
      return y_e(e, r);
    case b_e:
      return new n();
    case w_e:
    case $_e:
      return new n(e);
    case __e:
      return f_e(e);
    case S_e:
      return new n();
    case x_e:
      return m_e(e);
  }
}
function F_e(e) {
  return typeof e.constructor == "function" && !dC(e) ? k1e(VU(e)) : {};
}
var D_e = "[object Map]";
function j_e(e) {
  return Nu(e) && wg(e) == D_e;
}
var CL = Gh && Gh.isMap, V_e = CL ? hC(CL) : j_e;
const z_e = V_e;
var U_e = "[object Set]";
function B_e(e) {
  return Nu(e) && wg(e) == U_e;
}
var kL = Gh && Gh.isSet, q_e = kL ? hC(kL) : B_e;
const G_e = q_e;
var H_e = 1, W_e = 2, J_e = 4, GU = "[object Arguments]", Z_e = "[object Array]", K_e = "[object Boolean]", Y_e = "[object Date]", Q_e = "[object Error]", HU = "[object Function]", X_e = "[object GeneratorFunction]", e2e = "[object Map]", t2e = "[object Number]", WU = "[object Object]", r2e = "[object RegExp]", n2e = "[object Set]", i2e = "[object String]", s2e = "[object Symbol]", o2e = "[object WeakMap]", a2e = "[object ArrayBuffer]", l2e = "[object DataView]", u2e = "[object Float32Array]", c2e = "[object Float64Array]", d2e = "[object Int8Array]", p2e = "[object Int16Array]", h2e = "[object Int32Array]", f2e = "[object Uint8Array]", m2e = "[object Uint8ClampedArray]", y2e = "[object Uint16Array]", g2e = "[object Uint32Array]", jt = {};
jt[GU] = jt[Z_e] = jt[a2e] = jt[l2e] = jt[K_e] = jt[Y_e] = jt[u2e] = jt[c2e] = jt[d2e] = jt[p2e] = jt[h2e] = jt[e2e] = jt[t2e] = jt[WU] = jt[r2e] = jt[n2e] = jt[i2e] = jt[s2e] = jt[f2e] = jt[m2e] = jt[y2e] = jt[g2e] = !0;
jt[Q_e] = jt[HU] = jt[o2e] = !1;
function ky(e, t, r, n, i, s) {
  var o, a = t & H_e, l = t & W_e, c = t & J_e;
  if (r && (o = i ? r(e, n, i, s) : r(e)), o !== void 0)
    return o;
  if (!yo(e))
    return e;
  var h = Ss(e);
  if (h) {
    if (o = c_e(e), !a)
      return P1e(e, o);
  } else {
    var f = wg(e), m = f == HU || f == X_e;
    if (Sw(e))
      return Bwe(e, a);
    if (f == WU || f == GU || m && !i) {
      if (o = l || m ? {} : F_e(e), !a)
        return l ? Ywe(e, zwe(o, e)) : Jwe(e, Vwe(o, e));
    } else {
      if (!jt[f])
        return i ? e : {};
      o = N_e(e, f, a);
    }
  }
  s || (s = new ea());
  var y = s.get(e);
  if (y)
    return y;
  s.set(e, o), G_e(e) ? e.forEach(function(b) {
    o.add(ky(b, t, r, b, e, s));
  }) : z_e(e) && e.forEach(function(b, w) {
    o.set(w, ky(b, t, r, w, e, s));
  });
  var g = c ? l ? Qwe : VI : l ? fC : K_, v = h ? void 0 : g(e);
  return q1e(v || e, function(b, w) {
    v && (w = b, b = e[w]), uC(o, w, ky(b, t, r, w, e, s));
  }), o;
}
var v2e = 4;
function AL(e) {
  return ky(e, v2e);
}
var b2e = 1, w2e = 4;
function JU(e) {
  return ky(e, b2e | w2e);
}
var _2e = "__lodash_hash_undefined__";
function S2e(e) {
  return this.__data__.set(e, _2e), this;
}
function $2e(e) {
  return this.__data__.has(e);
}
function xw(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.__data__ = new yl(); ++t < r; )
    this.add(e[t]);
}
xw.prototype.add = xw.prototype.push = S2e;
xw.prototype.has = $2e;
function x2e(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
    if (t(e[r], r, e))
      return !0;
  return !1;
}
function T2e(e, t) {
  return e.has(t);
}
var E2e = 1, I2e = 2;
function ZU(e, t, r, n, i, s) {
  var o = r & E2e, a = e.length, l = t.length;
  if (a != l && !(o && l > a))
    return !1;
  var c = s.get(e), h = s.get(t);
  if (c && h)
    return c == t && h == e;
  var f = -1, m = !0, y = r & I2e ? new xw() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < a; ) {
    var g = e[f], v = t[f];
    if (n)
      var b = o ? n(v, g, f, t, e, s) : n(g, v, f, e, t, s);
    if (b !== void 0) {
      if (b)
        continue;
      m = !1;
      break;
    }
    if (y) {
      if (!x2e(t, function(w, x) {
        if (!T2e(y, x) && (g === w || i(g, w, r, n, s)))
          return y.push(x);
      })) {
        m = !1;
        break;
      }
    } else if (!(g === v || i(g, v, r, n, s))) {
      m = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), m;
}
function M2e(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n, i) {
    r[++t] = [i, n];
  }), r;
}
function O2e(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n) {
    r[++t] = n;
  }), r;
}
var C2e = 1, k2e = 2, A2e = "[object Boolean]", P2e = "[object Date]", R2e = "[object Error]", L2e = "[object Map]", N2e = "[object Number]", F2e = "[object RegExp]", D2e = "[object Set]", j2e = "[object String]", V2e = "[object Symbol]", z2e = "[object ArrayBuffer]", U2e = "[object DataView]", PL = _s ? _s.prototype : void 0, KS = PL ? PL.valueOf : void 0;
function B2e(e, t, r, n, i, s, o) {
  switch (r) {
    case U2e:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case z2e:
      return !(e.byteLength != t.byteLength || !s(new $w(e), new $w(t)));
    case A2e:
    case P2e:
    case N2e:
      return lC(+e, +t);
    case R2e:
      return e.name == t.name && e.message == t.message;
    case F2e:
    case j2e:
      return e == t + "";
    case L2e:
      var a = M2e;
    case D2e:
      var l = n & C2e;
      if (a || (a = O2e), e.size != t.size && !l)
        return !1;
      var c = o.get(e);
      if (c)
        return c == t;
      n |= k2e, o.set(e, t);
      var h = ZU(a(e), a(t), n, i, s, o);
      return o.delete(e), h;
    case V2e:
      if (KS)
        return KS.call(e) == KS.call(t);
  }
  return !1;
}
var q2e = 1, G2e = Object.prototype, H2e = G2e.hasOwnProperty;
function W2e(e, t, r, n, i, s) {
  var o = r & q2e, a = VI(e), l = a.length, c = VI(t), h = c.length;
  if (l != h && !o)
    return !1;
  for (var f = l; f--; ) {
    var m = a[f];
    if (!(o ? m in t : H2e.call(t, m)))
      return !1;
  }
  var y = s.get(e), g = s.get(t);
  if (y && g)
    return y == t && g == e;
  var v = !0;
  s.set(e, t), s.set(t, e);
  for (var b = o; ++f < l; ) {
    m = a[f];
    var w = e[m], x = t[m];
    if (n)
      var $ = o ? n(x, w, m, t, e, s) : n(w, x, m, e, t, s);
    if (!($ === void 0 ? w === x || i(w, x, r, n, s) : $)) {
      v = !1;
      break;
    }
    b || (b = m == "constructor");
  }
  if (v && !b) {
    var T = e.constructor, C = t.constructor;
    T != C && "constructor" in e && "constructor" in t && !(typeof T == "function" && T instanceof T && typeof C == "function" && C instanceof C) && (v = !1);
  }
  return s.delete(e), s.delete(t), v;
}
var J2e = 1, RL = "[object Arguments]", LL = "[object Array]", bv = "[object Object]", Z2e = Object.prototype, NL = Z2e.hasOwnProperty;
function K2e(e, t, r, n, i, s) {
  var o = Ss(e), a = Ss(t), l = o ? LL : wg(e), c = a ? LL : wg(t);
  l = l == RL ? bv : l, c = c == RL ? bv : c;
  var h = l == bv, f = c == bv, m = l == c;
  if (m && Sw(e)) {
    if (!Sw(t))
      return !1;
    o = !0, h = !1;
  }
  if (m && !h)
    return s || (s = new ea()), o || FU(e) ? ZU(e, t, r, n, i, s) : B2e(e, t, l, r, n, i, s);
  if (!(r & J2e)) {
    var y = h && NL.call(e, "__wrapped__"), g = f && NL.call(t, "__wrapped__");
    if (y || g) {
      var v = y ? e.value() : e, b = g ? t.value() : t;
      return s || (s = new ea()), i(v, b, r, n, s);
    }
  }
  return m ? (s || (s = new ea()), W2e(e, t, r, n, i, s)) : !1;
}
function e2(e, t, r, n, i) {
  return e === t ? !0 : e == null || t == null || !Nu(e) && !Nu(t) ? e !== e && t !== t : K2e(e, t, r, n, e2, i);
}
var Y2e = 1, Q2e = 2;
function X2e(e, t, r, n) {
  var i = r.length, s = i, o = !n;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var a = r[i];
    if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    a = r[i];
    var l = a[0], c = e[l], h = a[1];
    if (o && a[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var f = new ea();
      if (n)
        var m = n(c, h, l, e, t, f);
      if (!(m === void 0 ? e2(h, c, Y2e | Q2e, n, f) : m))
        return !1;
    }
  }
  return !0;
}
function KU(e) {
  return e === e && !yo(e);
}
function eSe(e) {
  for (var t = K_(e), r = t.length; r--; ) {
    var n = t[r], i = e[n];
    t[r] = [n, i, KU(i)];
  }
  return t;
}
function YU(e, t) {
  return function(r) {
    return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
function tSe(e) {
  var t = eSe(e);
  return t.length == 1 && t[0][2] ? YU(t[0][0], t[0][1]) : function(r) {
    return r === e || X2e(r, e, t);
  };
}
function rSe(e, t) {
  return e != null && t in Object(e);
}
function nSe(e, t, r) {
  t = X_(t, e);
  for (var n = -1, i = t.length, s = !1; ++n < i; ) {
    var o = s0(t[n]);
    if (!(s = e != null && r(e, o)))
      break;
    e = e[o];
  }
  return s || ++n != i ? s : (i = e == null ? 0 : e.length, !!i && cC(i) && aC(o, i) && (Ss(e) || pC(e)));
}
function QU(e, t) {
  return e != null && nSe(e, t, rSe);
}
var iSe = 1, sSe = 2;
function oSe(e, t) {
  return mC(e) && KU(t) ? YU(s0(e), t) : function(r) {
    var n = ai(r, e);
    return n === void 0 && n === t ? QU(r, e) : e2(t, n, iSe | sSe);
  };
}
function aSe(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function lSe(e) {
  return function(t) {
    return gC(t, e);
  };
}
function uSe(e) {
  return mC(e) ? aSe(s0(e)) : lSe(e);
}
function cSe(e) {
  return typeof e == "function" ? e : e == null ? CU : typeof e == "object" ? Ss(e) ? oSe(e[0], e[1]) : tSe(e) : uSe(e);
}
var dSe = function() {
  return bo.Date.now();
};
const YS = dSe;
var pSe = "Expected a function", hSe = Math.max, fSe = Math.min;
function qI(e, t, r) {
  var n, i, s, o, a, l, c = 0, h = !1, f = !1, m = !0;
  if (typeof e != "function")
    throw new TypeError(pSe);
  t = FI(t) || 0, yo(r) && (h = !!r.leading, f = "maxWait" in r, s = f ? hSe(FI(r.maxWait) || 0, t) : s, m = "trailing" in r ? !!r.trailing : m);
  function y(I) {
    var O = n, M = i;
    return n = i = void 0, c = I, o = e.apply(M, O), o;
  }
  function g(I) {
    return c = I, a = setTimeout(w, t), h ? y(I) : o;
  }
  function v(I) {
    var O = I - l, M = I - c, L = t - O;
    return f ? fSe(L, s - M) : L;
  }
  function b(I) {
    var O = I - l, M = I - c;
    return l === void 0 || O >= t || O < 0 || f && M >= s;
  }
  function w() {
    var I = YS();
    if (b(I))
      return x(I);
    a = setTimeout(w, v(I));
  }
  function x(I) {
    return a = void 0, m && n ? y(I) : (n = i = void 0, o);
  }
  function $() {
    a !== void 0 && clearTimeout(a), c = 0, n = l = i = a = void 0;
  }
  function T() {
    return a === void 0 ? o : x(YS());
  }
  function C() {
    var I = YS(), O = b(I);
    if (n = arguments, i = this, l = I, O) {
      if (a === void 0)
        return g(l);
      if (f)
        return clearTimeout(a), a = setTimeout(w, t), y(l);
    }
    return a === void 0 && (a = setTimeout(w, t)), o;
  }
  return C.cancel = $, C.flush = T, C;
}
var mSe = Math.max, ySe = Math.min;
function gSe(e, t, r) {
  var n = e == null ? 0 : e.length;
  if (!n)
    return -1;
  var i = n - 1;
  return r !== void 0 && (i = d1e(r), i = r < 0 ? mSe(n + i, 0) : ySe(i, n - 1)), G1e(e, cSe(t), i, !0);
}
var vSe = 1 / 0;
function bSe(e) {
  var t = e == null ? 0 : e.length;
  return t ? bC(e, vSe) : [];
}
function Tw(e) {
  for (var t = -1, r = e == null ? 0 : e.length, n = {}; ++t < r; ) {
    var i = e[t];
    n[i[0]] = i[1];
  }
  return n;
}
function Cu(e, t) {
  return e2(e, t);
}
function o0(e) {
  return e == null;
}
function XU(e) {
  return e === void 0;
}
function eB(e, t, r, n) {
  if (!yo(e))
    return e;
  t = X_(t, e);
  for (var i = -1, s = t.length, o = s - 1, a = e; a != null && ++i < s; ) {
    var l = s0(t[i]), c = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (i != o) {
      var h = a[l];
      c = n ? n(h, l, a) : void 0, c === void 0 && (c = yo(h) ? h : aC(t[i + 1]) ? [] : {});
    }
    uC(a, l, c), a = a[l];
  }
  return e;
}
function wSe(e, t, r) {
  for (var n = -1, i = t.length, s = {}; ++n < i; ) {
    var o = t[n], a = gC(e, o);
    r(a, o) && eB(s, X_(o, e), a);
  }
  return s;
}
function _Se(e, t) {
  return wSe(e, t, function(r, n) {
    return QU(e, n);
  });
}
var SSe = Awe(function(e, t) {
  return e == null ? {} : _Se(e, t);
});
const $Se = SSe;
function xSe(e, t, r) {
  return e == null ? e : eB(e, t, r);
}
const Hh = (e) => e === void 0, Un = (e) => typeof e == "boolean", ar = (e) => typeof e == "number", GI = (e) => !e && e !== 0 || ul(e) && e.length === 0 || En(e) && !Object.keys(e).length, Fu = (e) => typeof Element > "u" ? !1 : e instanceof Element, TSe = (e) => nr(e) ? !Number.isNaN(Number(e)) : !1, ESe = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), FL = (e) => Dve(e), DL = (e) => Object.keys(e), QS = (e, t, r) => ({
  get value() {
    return ai(e, t, r);
  },
  set value(n) {
    xSe(e, t, n);
  }
});
class tB extends Error {
  constructor(t) {
    super(t), this.name = "ElementPlusError";
  }
}
function t2(e, t) {
  throw new tB(`[${e}] ${t}`);
}
function Ut(e, t) {
  if (process.env.NODE_ENV !== "production") {
    const r = nr(e) ? new tB(`[${e}] ${t}`) : e;
    console.warn(r);
  }
}
const ISe = "utils/dom/style", rB = (e = "") => e.split(" ").filter((t) => !!t.trim()), jL = (e, t) => {
  if (!e || !t)
    return !1;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e.classList.contains(t);
}, HI = (e, t) => {
  !e || !t.trim() || e.classList.add(...rB(t));
}, _g = (e, t) => {
  !e || !t.trim() || e.classList.remove(...rB(t));
}, ah = (e, t) => {
  var r;
  if (!Pt || !e || !t)
    return "";
  let n = Lve(t);
  n === "float" && (n = "cssFloat");
  try {
    const i = e.style[n];
    if (i)
      return i;
    const s = (r = document.defaultView) == null ? void 0 : r.getComputedStyle(e, "");
    return s ? s[n] : "";
  } catch {
    return e.style[n];
  }
};
function cl(e, t = "px") {
  if (!e)
    return "";
  if (ar(e) || TSe(e))
    return `${e}${t}`;
  if (nr(e))
    return e;
  Ut(ISe, "binding value must be a string or number");
}
let wv;
const MSe = (e) => {
  var t;
  if (!Pt)
    return 0;
  if (wv !== void 0)
    return wv;
  const r = document.createElement("div");
  r.className = `${e}-scrollbar__wrap`, r.style.visibility = "hidden", r.style.width = "100px", r.style.position = "absolute", r.style.top = "-9999px", document.body.appendChild(r);
  const n = r.offsetWidth;
  r.style.overflow = "scroll";
  const i = document.createElement("div");
  i.style.width = "100%", r.appendChild(i);
  const s = i.offsetWidth;
  return (t = r.parentNode) == null || t.removeChild(r), wv = n - s, wv;
};
function nB(e, t) {
  if (!Pt)
    return;
  if (!t) {
    e.scrollTop = 0;
    return;
  }
  const r = [];
  let n = t.offsetParent;
  for (; n !== null && e !== n && e.contains(n); )
    r.push(n), n = n.offsetParent;
  const i = t.offsetTop + r.reduce((l, c) => l + c.offsetTop, 0), s = i + t.offsetHeight, o = e.scrollTop, a = o + e.clientHeight;
  i < o ? e.scrollTop = i : s > a && (e.scrollTop = s - e.clientHeight);
}
/*! Element Plus Icons Vue v2.3.1 */
var OSe = /* @__PURE__ */ he({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), iB = OSe, CSe = /* @__PURE__ */ he({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), kSe = CSe, ASe = /* @__PURE__ */ he({
  name: "Check",
  __name: "check",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), sB = ASe, PSe = /* @__PURE__ */ he({
  name: "CircleCheck",
  __name: "circle-check",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      K("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), RSe = PSe, LSe = /* @__PURE__ */ he({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), oB = LSe, NSe = /* @__PURE__ */ he({
  name: "CircleClose",
  __name: "circle-close",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      K("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), r2 = NSe, FSe = /* @__PURE__ */ he({
  name: "Close",
  __name: "close",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), Ew = FSe, DSe = /* @__PURE__ */ he({
  name: "Hide",
  __name: "hide",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      K("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), jSe = DSe, VSe = /* @__PURE__ */ he({
  name: "InfoFilled",
  __name: "info-filled",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), aB = VSe, zSe = /* @__PURE__ */ he({
  name: "Loading",
  __name: "loading",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), a0 = zSe, USe = /* @__PURE__ */ he({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), lB = USe, BSe = /* @__PURE__ */ he({
  name: "View",
  __name: "view",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), qSe = BSe, GSe = /* @__PURE__ */ he({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(e) {
    return (t, r) => (R(), Z("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      K("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), uB = GSe;
const cB = "__epPropKey", Le = (e) => e, HSe = (e) => En(e) && !!e[cB], n2 = (e, t) => {
  if (!En(e) || HSe(e))
    return e;
  const { values: r, required: n, default: i, type: s, validator: o } = e, l = {
    type: s,
    required: !!n,
    validator: r || o ? (c) => {
      let h = !1, f = [];
      if (r && (f = Array.from(r), sL(e, "default") && f.push(i), h || (h = f.includes(c))), o && (h || (h = o(c))), !h && f.length > 0) {
        const m = [...new Set(f)].map((y) => JSON.stringify(y)).join(", ");
        cG(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${m}], got value ${JSON.stringify(c)}.`);
      }
      return h;
    } : void 0,
    [cB]: !0
  };
  return sL(e, "default") && (l.default = i), l;
}, ht = (e) => Tw(Object.entries(e).map(([t, r]) => [
  t,
  n2(r, t)
])), Oi = Le([
  String,
  Object,
  Function
]), dB = {
  Close: Ew
}, WSe = {
  Close: Ew,
  SuccessFilled: lB,
  InfoFilled: aB,
  WarningFilled: uB,
  CircleCloseFilled: oB
}, Iw = {
  success: lB,
  warning: uB,
  error: oB,
  info: aB
}, pB = {
  validating: a0,
  success: RSe,
  error: r2
}, fi = (e, t) => {
  if (e.install = (r) => {
    for (const n of [e, ...Object.values(t ?? {})])
      r.component(n.name, n);
  }, t)
    for (const [r, n] of Object.entries(t))
      e[r] = n;
  return e;
}, hB = (e, t) => (e.install = (r) => {
  e._context = r._context, r.config.globalProperties[t] = e;
}, e), Ku = (e) => (e.install = Xo, e), JSe = (...e) => (t) => {
  e.forEach((r) => {
    er(r) ? r(t) : r.value = t;
  });
}, Xt = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, At = "update:modelValue", aa = "change", WI = "input", l0 = ["", "default", "small", "large"], ZSe = {
  large: 40,
  default: 32,
  small: 24
}, KSe = (e) => ZSe[e || "default"], fB = (e) => ["", ...l0].includes(e);
var q1 = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(q1 || {});
const VL = (e) => [...new Set(e)], zL = (e) => !e && e !== 0 ? [] : Array.isArray(e) ? e : [e], SC = (e) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e), YSe = () => Math.floor(Math.random() * 1e4), mB = (e) => e, QSe = ["class", "style"], XSe = /^on[A-Z]/, e$e = (e = {}) => {
  const { excludeListeners: t = !1, excludeKeys: r } = e, n = A(() => ((r == null ? void 0 : r.value) || []).concat(QSe)), i = nn();
  return i ? A(() => {
    var s;
    return Tw(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter(([o]) => !n.value.includes(o) && !(t && XSe.test(o))));
  }) : (Ut("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), A(() => ({})));
}, Sg = ({ from: e, replacement: t, scope: r, version: n, ref: i, type: s = "API" }, o) => {
  Se(() => _(o), (a) => {
    a && Ut(r, `[${s}] ${e} is about to be deprecated in version ${n}, please use ${t} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
}, t$e = (e, t, r) => {
  let n = {
    offsetX: 0,
    offsetY: 0
  };
  const i = (a) => {
    const l = a.clientX, c = a.clientY, { offsetX: h, offsetY: f } = n, m = e.value.getBoundingClientRect(), y = m.left, g = m.top, v = m.width, b = m.height, w = document.documentElement.clientWidth, x = document.documentElement.clientHeight, $ = -y + h, T = -g + f, C = w - y - v + h, I = x - g - b + f, O = (L) => {
      const N = Math.min(Math.max(h + L.clientX - l, $), C), ee = Math.min(Math.max(f + L.clientY - c, T), I);
      n = {
        offsetX: N,
        offsetY: ee
      }, e.value && (e.value.style.transform = `translate(${cl(N)}, ${cl(ee)})`);
    }, M = () => {
      document.removeEventListener("mousemove", O), document.removeEventListener("mouseup", M);
    };
    document.addEventListener("mousemove", O), document.addEventListener("mouseup", M);
  }, s = () => {
    t.value && e.value && t.value.addEventListener("mousedown", i);
  }, o = () => {
    t.value && e.value && t.value.removeEventListener("mousedown", i);
  };
  qt(() => {
    dG(() => {
      r.value ? s() : o();
    });
  }), Ni(() => {
    o();
  });
};
var r$e = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const n$e = (e) => (t, r) => i$e(t, r, _(e)), i$e = (e, t, r) => ai(r, e, e).replace(/\{(\w+)\}/g, (n, i) => {
  var s;
  return `${(s = t == null ? void 0 : t[i]) != null ? s : `{${i}}`}`;
}), s$e = (e) => {
  const t = A(() => _(e).name), r = ra(e) ? e : q(e);
  return {
    lang: t,
    locale: r,
    t: n$e(e)
  };
}, yB = Symbol("localeContextKey"), ap = (e) => {
  const t = e || ot(yB, q());
  return s$e(A(() => t.value || r$e));
};
let o$e;
function a$e(e, t = o$e) {
  t && t.active && t.effects.push(e);
}
const UL = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, gB = (e) => (e.w & Du) > 0, vB = (e) => (e.n & Du) > 0, l$e = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= Du;
}, u$e = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let r = 0;
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      gB(i) && !vB(i) ? i.delete(e) : t[r++] = i, i.w &= ~Du, i.n &= ~Du;
    }
    t.length = r;
  }
};
let ay = 0, Du = 1;
const JI = 30;
let Ii;
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class c$e {
  constructor(t, r = null, n) {
    this.fn = t, this.scheduler = r, this.active = !0, this.deps = [], this.parent = void 0, a$e(this, n);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = Ii, r = G1;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = Ii, Ii = this, G1 = !0, Du = 1 << ++ay, ay <= JI ? l$e(this) : BL(this), this.fn();
    } finally {
      ay <= JI && u$e(this), Du = 1 << --ay, Ii = this.parent, G1 = r, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Ii === this ? this.deferStop = !0 : this.active && (BL(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function BL(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let r = 0; r < t.length; r++)
      t[r].delete(e);
    t.length = 0;
  }
}
let G1 = !0;
function qL(e, t) {
  let r = !1;
  ay <= JI ? vB(e) || (e.n |= Du, r = !gB(e)) : r = !e.has(Ii), r && (e.add(Ii), Ii.deps.push(e), process.env.NODE_ENV !== "production" && Ii.onTrack && Ii.onTrack(
    EU(
      {
        effect: Ii
      },
      t
    )
  ));
}
function GL(e, t) {
  const r = ul(e) ? e : [...e];
  for (const n of r)
    n.computed && HL(n, t);
  for (const n of r)
    n.computed || HL(n, t);
}
function HL(e, t) {
  (e !== Ii || e.allowRecurse) && (process.env.NODE_ENV !== "production" && e.onTrigger && e.onTrigger(EU({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
}
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(kve)
);
function i2(e) {
  const t = e && e.__v_raw;
  return t ? i2(t) : e;
}
function d$e(e) {
  G1 && Ii && (e = i2(e), process.env.NODE_ENV !== "production" ? qL(e.dep || (e.dep = UL()), {
    target: e,
    type: "get",
    key: "value"
  }) : qL(e.dep || (e.dep = UL())));
}
function p$e(e, t) {
  e = i2(e);
  const r = e.dep;
  r && (process.env.NODE_ENV !== "production" ? GL(r, {
    target: e,
    type: "set",
    key: "value",
    newValue: t
  }) : GL(r));
}
class h$e {
  constructor(t, r, n, i) {
    this._setter = r, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new c$e(t, () => {
      this._dirty || (this._dirty = !0, p$e(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = n;
  }
  get value() {
    const t = i2(this);
    return d$e(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
function f$e(e, t, r = !1) {
  let n, i;
  const s = er(e);
  s ? (n = e, i = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : Xo) : (n = e.get, i = e.set);
  const o = new h$e(n, i, s || !i, r);
  return process.env.NODE_ENV !== "production" && t && !r && (o.effect.onTrack = t.onTrack, o.effect.onTrigger = t.onTrigger), o;
}
const Ay = "el", m$e = "is-", ac = (e, t, r, n, i) => {
  let s = `${e}-${t}`;
  return r && (s += `-${r}`), n && (s += `__${n}`), i && (s += `--${i}`), s;
}, bB = Symbol("namespaceContextKey"), $C = (e) => {
  const t = e || (nn() ? ot(bB, q(Ay)) : q(Ay));
  return A(() => _(t) || Ay);
}, Je = (e, t) => {
  const r = $C(t);
  return {
    namespace: r,
    b: (v = "") => ac(r.value, e, v, "", ""),
    e: (v) => v ? ac(r.value, e, "", v, "") : "",
    m: (v) => v ? ac(r.value, e, "", "", v) : "",
    be: (v, b) => v && b ? ac(r.value, e, v, b, "") : "",
    em: (v, b) => v && b ? ac(r.value, e, "", v, b) : "",
    bm: (v, b) => v && b ? ac(r.value, e, v, "", b) : "",
    bem: (v, b, w) => v && b && w ? ac(r.value, e, v, b, w) : "",
    is: (v, ...b) => {
      const w = b.length >= 1 ? b[0] : !0;
      return v && w ? `${m$e}${v}` : "";
    },
    cssVar: (v) => {
      const b = {};
      for (const w in v)
        v[w] && (b[`--${r.value}-${w}`] = v[w]);
      return b;
    },
    cssVarName: (v) => `--${r.value}-${v}`,
    cssVarBlock: (v) => {
      const b = {};
      for (const w in v)
        v[w] && (b[`--${r.value}-${e}-${w}`] = v[w]);
      return b;
    },
    cssVarBlockName: (v) => `--${r.value}-${e}-${v}`
  };
}, y$e = (e, t = {}) => {
  ra(e) || t2("[useLockscreen]", "You need to pass a ref param to this function");
  const r = t.ns || Je("popup"), n = f$e(() => r.bm("parent", "hidden"));
  if (!Pt || jL(document.body, n.value))
    return;
  let i = 0, s = !1, o = "0";
  const a = () => {
    setTimeout(() => {
      _g(document == null ? void 0 : document.body, n.value), s && document && (document.body.style.width = o);
    }, 200);
  };
  Se(e, (l) => {
    if (!l) {
      a();
      return;
    }
    s = !jL(document.body, n.value), s && (o = document.body.style.width), i = MSe(r.namespace.value);
    const c = document.documentElement.clientHeight < document.body.scrollHeight, h = ah(document.body, "overflowY");
    i > 0 && (c || h === "scroll") && s && (document.body.style.width = `calc(100% - ${i}px)`), HI(document.body, n.value);
  }), c5(() => a());
}, g$e = n2({
  type: Le(Boolean),
  default: null
}), v$e = n2({
  type: Le(Function)
}), wB = (e) => {
  const t = `update:${e}`, r = `onUpdate:${e}`, n = [t], i = {
    [e]: g$e,
    [r]: v$e
  };
  return {
    useModelToggle: ({
      indicator: o,
      toggleReason: a,
      shouldHideWhenRouteChanges: l,
      shouldProceed: c,
      onShow: h,
      onHide: f
    }) => {
      const m = nn(), { emit: y } = m, g = m.props, v = A(() => er(g[r])), b = A(() => g[e] === null), w = (O) => {
        o.value !== !0 && (o.value = !0, a && (a.value = O), er(h) && h(O));
      }, x = (O) => {
        o.value !== !1 && (o.value = !1, a && (a.value = O), er(f) && f(O));
      }, $ = (O) => {
        if (g.disabled === !0 || er(c) && !c())
          return;
        const M = v.value && Pt;
        M && y(t, !0), (b.value || !M) && w(O);
      }, T = (O) => {
        if (g.disabled === !0 || !Pt)
          return;
        const M = v.value && Pt;
        M && y(t, !1), (b.value || !M) && x(O);
      }, C = (O) => {
        Un(O) && (g.disabled && O ? v.value && y(t, !1) : o.value !== O && (O ? w() : x()));
      }, I = () => {
        o.value ? T() : $();
      };
      return Se(() => g[e], C), l && m.appContext.config.globalProperties.$route !== void 0 && Se(() => ({
        ...m.proxy.$route
      }), () => {
        l.value && o.value && T();
      }), qt(() => {
        C(g[e]);
      }), {
        hide: T,
        show: $,
        toggle: I,
        hasUpdateHandler: v
      };
    },
    useModelToggleProps: i,
    useModelToggleEmits: n
  };
};
wB("modelValue");
const _B = (e) => {
  const t = nn();
  return A(() => {
    var r, n;
    return (n = (r = t == null ? void 0 : t.proxy) == null ? void 0 : r.$props) == null ? void 0 : n[e];
  });
};
var li = "top", $s = "bottom", xs = "right", ui = "left", xC = "auto", u0 = [li, $s, xs, ui], Wh = "start", $g = "end", b$e = "clippingParents", SB = "viewport", im = "popper", w$e = "reference", WL = /* @__PURE__ */ u0.reduce(function(e, t) {
  return e.concat([t + "-" + Wh, t + "-" + $g]);
}, []), s2 = /* @__PURE__ */ [].concat(u0, [xC]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Wh, t + "-" + $g]);
}, []), _$e = "beforeRead", S$e = "read", $$e = "afterRead", x$e = "beforeMain", T$e = "main", E$e = "afterMain", I$e = "beforeWrite", M$e = "write", O$e = "afterWrite", C$e = [_$e, S$e, $$e, x$e, T$e, E$e, I$e, M$e, O$e];
function la(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Li(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function qd(e) {
  var t = Li(e).Element;
  return e instanceof t || e instanceof Element;
}
function gs(e) {
  var t = Li(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function TC(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Li(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function k$e(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(r) {
    var n = t.styles[r] || {}, i = t.attributes[r] || {}, s = t.elements[r];
    !gs(s) || !la(s) || (Object.assign(s.style, n), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function A$e(e) {
  var t = e.state, r = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {
    Object.keys(t.elements).forEach(function(n) {
      var i = t.elements[n], s = t.attributes[n] || {}, o = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !gs(i) || !la(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const P$e = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: k$e,
  effect: A$e,
  requires: ["computeStyles"]
};
function ta(e) {
  return e.split("-")[0];
}
var Sd = Math.max, Mw = Math.min, Jh = Math.round;
function ZI() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function $B() {
  return !/^((?!chrome|android).)*safari/i.test(ZI());
}
function Zh(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var n = e.getBoundingClientRect(), i = 1, s = 1;
  t && gs(e) && (i = e.offsetWidth > 0 && Jh(n.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Jh(n.height) / e.offsetHeight || 1);
  var o = qd(e) ? Li(e) : window, a = o.visualViewport, l = !$B() && r, c = (n.left + (l && a ? a.offsetLeft : 0)) / i, h = (n.top + (l && a ? a.offsetTop : 0)) / s, f = n.width / i, m = n.height / s;
  return {
    width: f,
    height: m,
    top: h,
    right: c + f,
    bottom: h + m,
    left: c,
    x: c,
    y: h
  };
}
function EC(e) {
  var t = Zh(e), r = e.offsetWidth, n = e.offsetHeight;
  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: r,
    height: n
  };
}
function xB(e, t) {
  var r = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (r && TC(r)) {
    var n = t;
    do {
      if (n && e.isSameNode(n))
        return !0;
      n = n.parentNode || n.host;
    } while (n);
  }
  return !1;
}
function dl(e) {
  return Li(e).getComputedStyle(e);
}
function R$e(e) {
  return ["table", "td", "th"].indexOf(la(e)) >= 0;
}
function Yu(e) {
  return ((qd(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function o2(e) {
  return la(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (TC(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Yu(e)
  );
}
function JL(e) {
  return !gs(e) || // https://github.com/popperjs/popper-core/issues/837
  dl(e).position === "fixed" ? null : e.offsetParent;
}
function L$e(e) {
  var t = /firefox/i.test(ZI()), r = /Trident/i.test(ZI());
  if (r && gs(e)) {
    var n = dl(e);
    if (n.position === "fixed")
      return null;
  }
  var i = o2(e);
  for (TC(i) && (i = i.host); gs(i) && ["html", "body"].indexOf(la(i)) < 0; ) {
    var s = dl(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function c0(e) {
  for (var t = Li(e), r = JL(e); r && R$e(r) && dl(r).position === "static"; )
    r = JL(r);
  return r && (la(r) === "html" || la(r) === "body" && dl(r).position === "static") ? t : r || L$e(e) || t;
}
function IC(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Py(e, t, r) {
  return Sd(e, Mw(t, r));
}
function N$e(e, t, r) {
  var n = Py(e, t, r);
  return n > r ? r : n;
}
function TB() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function EB(e) {
  return Object.assign({}, TB(), e);
}
function IB(e, t) {
  return t.reduce(function(r, n) {
    return r[n] = e, r;
  }, {});
}
var F$e = function(t, r) {
  return t = typeof t == "function" ? t(Object.assign({}, r.rects, {
    placement: r.placement
  })) : t, EB(typeof t != "number" ? t : IB(t, u0));
};
function D$e(e) {
  var t, r = e.state, n = e.name, i = e.options, s = r.elements.arrow, o = r.modifiersData.popperOffsets, a = ta(r.placement), l = IC(a), c = [ui, xs].indexOf(a) >= 0, h = c ? "height" : "width";
  if (!(!s || !o)) {
    var f = F$e(i.padding, r), m = EC(s), y = l === "y" ? li : ui, g = l === "y" ? $s : xs, v = r.rects.reference[h] + r.rects.reference[l] - o[l] - r.rects.popper[h], b = o[l] - r.rects.reference[l], w = c0(s), x = w ? l === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0, $ = v / 2 - b / 2, T = f[y], C = x - m[h] - f[g], I = x / 2 - m[h] / 2 + $, O = Py(T, I, C), M = l;
    r.modifiersData[n] = (t = {}, t[M] = O, t.centerOffset = O - I, t);
  }
}
function j$e(e) {
  var t = e.state, r = e.options, n = r.element, i = n === void 0 ? "[data-popper-arrow]" : n;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || xB(t.elements.popper, i) && (t.elements.arrow = i));
}
const V$e = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: D$e,
  effect: j$e,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Kh(e) {
  return e.split("-")[1];
}
var z$e = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function U$e(e, t) {
  var r = e.x, n = e.y, i = t.devicePixelRatio || 1;
  return {
    x: Jh(r * i) / i || 0,
    y: Jh(n * i) / i || 0
  };
}
function ZL(e) {
  var t, r = e.popper, n = e.popperRect, i = e.placement, s = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, h = e.roundOffsets, f = e.isFixed, m = o.x, y = m === void 0 ? 0 : m, g = o.y, v = g === void 0 ? 0 : g, b = typeof h == "function" ? h({
    x: y,
    y: v
  }) : {
    x: y,
    y: v
  };
  y = b.x, v = b.y;
  var w = o.hasOwnProperty("x"), x = o.hasOwnProperty("y"), $ = ui, T = li, C = window;
  if (c) {
    var I = c0(r), O = "clientHeight", M = "clientWidth";
    if (I === Li(r) && (I = Yu(r), dl(I).position !== "static" && a === "absolute" && (O = "scrollHeight", M = "scrollWidth")), I = I, i === li || (i === ui || i === xs) && s === $g) {
      T = $s;
      var L = f && I === C && C.visualViewport ? C.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        I[O]
      );
      v -= L - n.height, v *= l ? 1 : -1;
    }
    if (i === ui || (i === li || i === $s) && s === $g) {
      $ = xs;
      var N = f && I === C && C.visualViewport ? C.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        I[M]
      );
      y -= N - n.width, y *= l ? 1 : -1;
    }
  }
  var ee = Object.assign({
    position: a
  }, c && z$e), D = h === !0 ? U$e({
    x: y,
    y: v
  }, Li(r)) : {
    x: y,
    y: v
  };
  if (y = D.x, v = D.y, l) {
    var H;
    return Object.assign({}, ee, (H = {}, H[T] = x ? "0" : "", H[$] = w ? "0" : "", H.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + v + "px)" : "translate3d(" + y + "px, " + v + "px, 0)", H));
  }
  return Object.assign({}, ee, (t = {}, t[T] = x ? v + "px" : "", t[$] = w ? y + "px" : "", t.transform = "", t));
}
function B$e(e) {
  var t = e.state, r = e.options, n = r.gpuAcceleration, i = n === void 0 ? !0 : n, s = r.adaptive, o = s === void 0 ? !0 : s, a = r.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: ta(t.placement),
    variation: Kh(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, ZL(Object.assign({}, c, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, ZL(Object.assign({}, c, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const q$e = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: B$e,
  data: {}
};
var _v = {
  passive: !0
};
function G$e(e) {
  var t = e.state, r = e.instance, n = e.options, i = n.scroll, s = i === void 0 ? !0 : i, o = n.resize, a = o === void 0 ? !0 : o, l = Li(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && c.forEach(function(h) {
    h.addEventListener("scroll", r.update, _v);
  }), a && l.addEventListener("resize", r.update, _v), function() {
    s && c.forEach(function(h) {
      h.removeEventListener("scroll", r.update, _v);
    }), a && l.removeEventListener("resize", r.update, _v);
  };
}
const H$e = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: G$e,
  data: {}
};
var W$e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function H1(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return W$e[t];
  });
}
var J$e = {
  start: "end",
  end: "start"
};
function KL(e) {
  return e.replace(/start|end/g, function(t) {
    return J$e[t];
  });
}
function MC(e) {
  var t = Li(e), r = t.pageXOffset, n = t.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: n
  };
}
function OC(e) {
  return Zh(Yu(e)).left + MC(e).scrollLeft;
}
function Z$e(e, t) {
  var r = Li(e), n = Yu(e), i = r.visualViewport, s = n.clientWidth, o = n.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    var c = $B();
    (c || !c && t === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + OC(e),
    y: l
  };
}
function K$e(e) {
  var t, r = Yu(e), n = MC(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = Sd(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = Sd(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -n.scrollLeft + OC(e), l = -n.scrollTop;
  return dl(i || r).direction === "rtl" && (a += Sd(r.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function CC(e) {
  var t = dl(e), r = t.overflow, n = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + i + n);
}
function MB(e) {
  return ["html", "body", "#document"].indexOf(la(e)) >= 0 ? e.ownerDocument.body : gs(e) && CC(e) ? e : MB(o2(e));
}
function Ry(e, t) {
  var r;
  t === void 0 && (t = []);
  var n = MB(e), i = n === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Li(n), o = i ? [s].concat(s.visualViewport || [], CC(n) ? n : []) : n, a = t.concat(o);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ry(o2(o)))
  );
}
function KI(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function Y$e(e, t) {
  var r = Zh(e, !1, t === "fixed");
  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;
}
function YL(e, t, r) {
  return t === SB ? KI(Z$e(e, r)) : qd(t) ? Y$e(t, r) : KI(K$e(Yu(e)));
}
function Q$e(e) {
  var t = Ry(o2(e)), r = ["absolute", "fixed"].indexOf(dl(e).position) >= 0, n = r && gs(e) ? c0(e) : e;
  return qd(n) ? t.filter(function(i) {
    return qd(i) && xB(i, n) && la(i) !== "body";
  }) : [];
}
function X$e(e, t, r, n) {
  var i = t === "clippingParents" ? Q$e(e) : [].concat(t), s = [].concat(i, [r]), o = s[0], a = s.reduce(function(l, c) {
    var h = YL(e, c, n);
    return l.top = Sd(h.top, l.top), l.right = Mw(h.right, l.right), l.bottom = Mw(h.bottom, l.bottom), l.left = Sd(h.left, l.left), l;
  }, YL(e, o, n));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function OB(e) {
  var t = e.reference, r = e.element, n = e.placement, i = n ? ta(n) : null, s = n ? Kh(n) : null, o = t.x + t.width / 2 - r.width / 2, a = t.y + t.height / 2 - r.height / 2, l;
  switch (i) {
    case li:
      l = {
        x: o,
        y: t.y - r.height
      };
      break;
    case $s:
      l = {
        x: o,
        y: t.y + t.height
      };
      break;
    case xs:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case ui:
      l = {
        x: t.x - r.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = i ? IC(i) : null;
  if (c != null) {
    var h = c === "y" ? "height" : "width";
    switch (s) {
      case Wh:
        l[c] = l[c] - (t[h] / 2 - r[h] / 2);
        break;
      case $g:
        l[c] = l[c] + (t[h] / 2 - r[h] / 2);
        break;
    }
  }
  return l;
}
function xg(e, t) {
  t === void 0 && (t = {});
  var r = t, n = r.placement, i = n === void 0 ? e.placement : n, s = r.strategy, o = s === void 0 ? e.strategy : s, a = r.boundary, l = a === void 0 ? b$e : a, c = r.rootBoundary, h = c === void 0 ? SB : c, f = r.elementContext, m = f === void 0 ? im : f, y = r.altBoundary, g = y === void 0 ? !1 : y, v = r.padding, b = v === void 0 ? 0 : v, w = EB(typeof b != "number" ? b : IB(b, u0)), x = m === im ? w$e : im, $ = e.rects.popper, T = e.elements[g ? x : m], C = X$e(qd(T) ? T : T.contextElement || Yu(e.elements.popper), l, h, o), I = Zh(e.elements.reference), O = OB({
    reference: I,
    element: $,
    strategy: "absolute",
    placement: i
  }), M = KI(Object.assign({}, $, O)), L = m === im ? M : I, N = {
    top: C.top - L.top + w.top,
    bottom: L.bottom - C.bottom + w.bottom,
    left: C.left - L.left + w.left,
    right: L.right - C.right + w.right
  }, ee = e.modifiersData.offset;
  if (m === im && ee) {
    var D = ee[i];
    Object.keys(N).forEach(function(H) {
      var J = [xs, $s].indexOf(H) >= 0 ? 1 : -1, oe = [li, $s].indexOf(H) >= 0 ? "y" : "x";
      N[H] += D[oe] * J;
    });
  }
  return N;
}
function exe(e, t) {
  t === void 0 && (t = {});
  var r = t, n = r.placement, i = r.boundary, s = r.rootBoundary, o = r.padding, a = r.flipVariations, l = r.allowedAutoPlacements, c = l === void 0 ? s2 : l, h = Kh(n), f = h ? a ? WL : WL.filter(function(g) {
    return Kh(g) === h;
  }) : u0, m = f.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  m.length === 0 && (m = f);
  var y = m.reduce(function(g, v) {
    return g[v] = xg(e, {
      placement: v,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[ta(v)], g;
  }, {});
  return Object.keys(y).sort(function(g, v) {
    return y[g] - y[v];
  });
}
function txe(e) {
  if (ta(e) === xC)
    return [];
  var t = H1(e);
  return [KL(e), t, KL(t)];
}
function rxe(e) {
  var t = e.state, r = e.options, n = e.name;
  if (!t.modifiersData[n]._skip) {
    for (var i = r.mainAxis, s = i === void 0 ? !0 : i, o = r.altAxis, a = o === void 0 ? !0 : o, l = r.fallbackPlacements, c = r.padding, h = r.boundary, f = r.rootBoundary, m = r.altBoundary, y = r.flipVariations, g = y === void 0 ? !0 : y, v = r.allowedAutoPlacements, b = t.options.placement, w = ta(b), x = w === b, $ = l || (x || !g ? [H1(b)] : txe(b)), T = [b].concat($).reduce(function(wr, _r) {
      return wr.concat(ta(_r) === xC ? exe(t, {
        placement: _r,
        boundary: h,
        rootBoundary: f,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: v
      }) : _r);
    }, []), C = t.rects.reference, I = t.rects.popper, O = /* @__PURE__ */ new Map(), M = !0, L = T[0], N = 0; N < T.length; N++) {
      var ee = T[N], D = ta(ee), H = Kh(ee) === Wh, J = [li, $s].indexOf(D) >= 0, oe = J ? "width" : "height", ye = xg(t, {
        placement: ee,
        boundary: h,
        rootBoundary: f,
        altBoundary: m,
        padding: c
      }), Q = J ? H ? xs : ui : H ? $s : li;
      C[oe] > I[oe] && (Q = H1(Q));
      var ve = H1(Q), Ee = [];
      if (s && Ee.push(ye[D] <= 0), a && Ee.push(ye[Q] <= 0, ye[ve] <= 0), Ee.every(function(wr) {
        return wr;
      })) {
        L = ee, M = !1;
        break;
      }
      O.set(ee, Ee);
    }
    if (M)
      for (var Lt = g ? 3 : 1, ft = function(_r) {
        var Pr = T.find(function(xe) {
          var Ne = O.get(xe);
          if (Ne)
            return Ne.slice(0, _r).every(function(He) {
              return He;
            });
        });
        if (Pr)
          return L = Pr, "break";
      }, Nt = Lt; Nt > 0; Nt--) {
        var ir = ft(Nt);
        if (ir === "break")
          break;
      }
    t.placement !== L && (t.modifiersData[n]._skip = !0, t.placement = L, t.reset = !0);
  }
}
const nxe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: rxe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function QL(e, t, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - r.y,
    right: e.right - t.width + r.x,
    bottom: e.bottom - t.height + r.y,
    left: e.left - t.width - r.x
  };
}
function XL(e) {
  return [li, xs, $s, ui].some(function(t) {
    return e[t] >= 0;
  });
}
function ixe(e) {
  var t = e.state, r = e.name, n = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, o = xg(t, {
    elementContext: "reference"
  }), a = xg(t, {
    altBoundary: !0
  }), l = QL(o, n), c = QL(a, i, s), h = XL(l), f = XL(c);
  t.modifiersData[r] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: h,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": h,
    "data-popper-escaped": f
  });
}
const sxe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: ixe
};
function oxe(e, t, r) {
  var n = ta(e), i = [ui, li].indexOf(n) >= 0 ? -1 : 1, s = typeof r == "function" ? r(Object.assign({}, t, {
    placement: e
  })) : r, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [ui, xs].indexOf(n) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function axe(e) {
  var t = e.state, r = e.options, n = e.name, i = r.offset, s = i === void 0 ? [0, 0] : i, o = s2.reduce(function(h, f) {
    return h[f] = oxe(f, t.rects, s), h;
  }, {}), a = o[t.placement], l = a.x, c = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = o;
}
const lxe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: axe
};
function uxe(e) {
  var t = e.state, r = e.name;
  t.modifiersData[r] = OB({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const cxe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: uxe,
  data: {}
};
function dxe(e) {
  return e === "x" ? "y" : "x";
}
function pxe(e) {
  var t = e.state, r = e.options, n = e.name, i = r.mainAxis, s = i === void 0 ? !0 : i, o = r.altAxis, a = o === void 0 ? !1 : o, l = r.boundary, c = r.rootBoundary, h = r.altBoundary, f = r.padding, m = r.tether, y = m === void 0 ? !0 : m, g = r.tetherOffset, v = g === void 0 ? 0 : g, b = xg(t, {
    boundary: l,
    rootBoundary: c,
    padding: f,
    altBoundary: h
  }), w = ta(t.placement), x = Kh(t.placement), $ = !x, T = IC(w), C = dxe(T), I = t.modifiersData.popperOffsets, O = t.rects.reference, M = t.rects.popper, L = typeof v == "function" ? v(Object.assign({}, t.rects, {
    placement: t.placement
  })) : v, N = typeof L == "number" ? {
    mainAxis: L,
    altAxis: L
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, L), ee = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = {
    x: 0,
    y: 0
  };
  if (I) {
    if (s) {
      var H, J = T === "y" ? li : ui, oe = T === "y" ? $s : xs, ye = T === "y" ? "height" : "width", Q = I[T], ve = Q + b[J], Ee = Q - b[oe], Lt = y ? -M[ye] / 2 : 0, ft = x === Wh ? O[ye] : M[ye], Nt = x === Wh ? -M[ye] : -O[ye], ir = t.elements.arrow, wr = y && ir ? EC(ir) : {
        width: 0,
        height: 0
      }, _r = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : TB(), Pr = _r[J], xe = _r[oe], Ne = Py(0, O[ye], wr[ye]), He = $ ? O[ye] / 2 - Lt - Ne - Pr - N.mainAxis : ft - Ne - Pr - N.mainAxis, nt = $ ? -O[ye] / 2 + Lt + Ne + xe + N.mainAxis : Nt + Ne + xe + N.mainAxis, wt = t.elements.arrow && c0(t.elements.arrow), cr = wt ? T === "y" ? wt.clientTop || 0 : wt.clientLeft || 0 : 0, qr = (H = ee == null ? void 0 : ee[T]) != null ? H : 0, mi = Q + He - qr - cr, Gn = Q + nt - qr, On = Py(y ? Mw(ve, mi) : ve, Q, y ? Sd(Ee, Gn) : Ee);
      I[T] = On, D[T] = On - Q;
    }
    if (a) {
      var Hn, Cn = T === "x" ? li : ui, yi = T === "x" ? $s : xs, dr = I[C], Wn = C === "y" ? "height" : "width", kn = dr + b[Cn], Jn = dr - b[yi], Zn = [li, ui].indexOf(w) !== -1, ae = (Hn = ee == null ? void 0 : ee[C]) != null ? Hn : 0, Fe = Zn ? kn : dr - O[Wn] - M[Wn] - ae + N.altAxis, at = Zn ? dr + O[Wn] + M[Wn] - ae - N.altAxis : Jn, pr = y && Zn ? N$e(Fe, dr, at) : Py(y ? Fe : kn, dr, y ? at : Jn);
      I[C] = pr, D[C] = pr - dr;
    }
    t.modifiersData[n] = D;
  }
}
const hxe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: pxe,
  requiresIfExists: ["offset"]
};
function fxe(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function mxe(e) {
  return e === Li(e) || !gs(e) ? MC(e) : fxe(e);
}
function yxe(e) {
  var t = e.getBoundingClientRect(), r = Jh(t.width) / e.offsetWidth || 1, n = Jh(t.height) / e.offsetHeight || 1;
  return r !== 1 || n !== 1;
}
function gxe(e, t, r) {
  r === void 0 && (r = !1);
  var n = gs(t), i = gs(t) && yxe(t), s = Yu(t), o = Zh(e, i, r), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (n || !n && !r) && ((la(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  CC(s)) && (a = mxe(t)), gs(t) ? (l = Zh(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : s && (l.x = OC(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function vxe(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function i(s) {
    r.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!r.has(a)) {
        var l = t.get(a);
        l && i(l);
      }
    }), n.push(s);
  }
  return e.forEach(function(s) {
    r.has(s.name) || i(s);
  }), n;
}
function bxe(e) {
  var t = vxe(e);
  return C$e.reduce(function(r, n) {
    return r.concat(t.filter(function(i) {
      return i.phase === n;
    }));
  }, []);
}
function wxe(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(r) {
      Promise.resolve().then(function() {
        t = void 0, r(e());
      });
    })), t;
  };
}
function _xe(e) {
  var t = e.reduce(function(r, n) {
    var i = r[n.name];
    return r[n.name] = i ? Object.assign({}, i, n, {
      options: Object.assign({}, i.options, n.options),
      data: Object.assign({}, i.data, n.data)
    }) : n, r;
  }, {});
  return Object.keys(t).map(function(r) {
    return t[r];
  });
}
var eN = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function tN() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return !t.some(function(n) {
    return !(n && typeof n.getBoundingClientRect == "function");
  });
}
function Sxe(e) {
  e === void 0 && (e = {});
  var t = e, r = t.defaultModifiers, n = r === void 0 ? [] : r, i = t.defaultOptions, s = i === void 0 ? eN : i;
  return function(a, l, c) {
    c === void 0 && (c = s);
    var h = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, eN, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], m = !1, y = {
      state: h,
      setOptions: function(w) {
        var x = typeof w == "function" ? w(h.options) : w;
        v(), h.options = Object.assign({}, s, h.options, x), h.scrollParents = {
          reference: qd(a) ? Ry(a) : a.contextElement ? Ry(a.contextElement) : [],
          popper: Ry(l)
        };
        var $ = bxe(_xe([].concat(n, h.options.modifiers)));
        return h.orderedModifiers = $.filter(function(T) {
          return T.enabled;
        }), g(), y.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!m) {
          var w = h.elements, x = w.reference, $ = w.popper;
          if (tN(x, $)) {
            h.rects = {
              reference: gxe(x, c0($), h.options.strategy === "fixed"),
              popper: EC($)
            }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(N) {
              return h.modifiersData[N.name] = Object.assign({}, N.data);
            });
            for (var T = 0; T < h.orderedModifiers.length; T++) {
              if (h.reset === !0) {
                h.reset = !1, T = -1;
                continue;
              }
              var C = h.orderedModifiers[T], I = C.fn, O = C.options, M = O === void 0 ? {} : O, L = C.name;
              typeof I == "function" && (h = I({
                state: h,
                options: M,
                name: L,
                instance: y
              }) || h);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: wxe(function() {
        return new Promise(function(b) {
          y.forceUpdate(), b(h);
        });
      }),
      destroy: function() {
        v(), m = !0;
      }
    };
    if (!tN(a, l))
      return y;
    y.setOptions(c).then(function(b) {
      !m && c.onFirstUpdate && c.onFirstUpdate(b);
    });
    function g() {
      h.orderedModifiers.forEach(function(b) {
        var w = b.name, x = b.options, $ = x === void 0 ? {} : x, T = b.effect;
        if (typeof T == "function") {
          var C = T({
            state: h,
            name: w,
            instance: y,
            options: $
          }), I = function() {
          };
          f.push(C || I);
        }
      });
    }
    function v() {
      f.forEach(function(b) {
        return b();
      }), f = [];
    }
    return y;
  };
}
var $xe = [H$e, cxe, q$e, P$e, lxe, nxe, hxe, V$e, sxe], xxe = /* @__PURE__ */ Sxe({
  defaultModifiers: $xe
});
const Txe = (e, t, r = {}) => {
  const n = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: l }) => {
      const c = Exe(l);
      Object.assign(o.value, c);
    },
    requires: ["computeStyles"]
  }, i = A(() => {
    const { onFirstUpdate: l, placement: c, strategy: h, modifiers: f } = _(r);
    return {
      onFirstUpdate: l,
      placement: c || "bottom",
      strategy: h || "absolute",
      modifiers: [
        ...f || [],
        n,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), s = fd(), o = q({
    styles: {
      popper: {
        position: _(i).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = () => {
    s.value && (s.value.destroy(), s.value = void 0);
  };
  return Se(i, (l) => {
    const c = _(s);
    c && c.setOptions(l);
  }, {
    deep: !0
  }), Se([e, t], ([l, c]) => {
    a(), !(!l || !c) && (s.value = xxe(l, c, _(i)));
  }), Ni(() => {
    a();
  }), {
    state: A(() => {
      var l;
      return { ...((l = _(s)) == null ? void 0 : l.state) || {} };
    }),
    styles: A(() => _(o).styles),
    attributes: A(() => _(o).attributes),
    update: () => {
      var l;
      return (l = _(s)) == null ? void 0 : l.update();
    },
    forceUpdate: () => {
      var l;
      return (l = _(s)) == null ? void 0 : l.forceUpdate();
    },
    instanceRef: A(() => _(s))
  };
};
function Exe(e) {
  const t = Object.keys(e.elements), r = Tw(t.map((i) => [i, e.styles[i] || {}])), n = Tw(t.map((i) => [i, e.attributes[i]]));
  return {
    styles: r,
    attributes: n
  };
}
const CB = (e) => {
  if (!e)
    return { onClick: Xo, onMousedown: Xo, onMouseup: Xo };
  let t = !1, r = !1;
  return { onClick: (o) => {
    t && r && e(o), t = r = !1;
  }, onMousedown: (o) => {
    t = o.target === o.currentTarget;
  }, onMouseup: (o) => {
    r = o.target === o.currentTarget;
  } };
};
function rN() {
  let e;
  const t = (n, i) => {
    r(), e = window.setTimeout(n, i);
  }, r = () => window.clearTimeout(e);
  return H_(() => r()), {
    registerTimeout: t,
    cancelTimeout: r
  };
}
const YI = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, Ixe = Symbol("elIdInjection"), kB = () => nn() ? ot(Ixe, YI) : YI, ju = (e) => {
  const t = kB();
  !Pt && t === YI && Ut("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const r = $C();
  return A(() => _(e) || `${r.value}-id-${t.prefix}-${t.current++}`);
};
let lh = [];
const nN = (e) => {
  const t = e;
  t.key === Xt.esc && lh.forEach((r) => r(t));
}, Mxe = (e) => {
  qt(() => {
    lh.length === 0 && document.addEventListener("keydown", nN), Pt && lh.push(e);
  }), Ni(() => {
    lh = lh.filter((t) => t !== e), lh.length === 0 && Pt && document.removeEventListener("keydown", nN);
  });
};
let iN;
const AB = () => {
  const e = $C(), t = kB(), r = A(() => `${e.value}-popper-container-${t.prefix}`), n = A(() => `#${r.value}`);
  return {
    id: r,
    selector: n
  };
}, Oxe = (e) => {
  const t = document.createElement("div");
  return t.id = e, document.body.appendChild(t), t;
}, Cxe = () => {
  const { id: e, selector: t } = AB();
  return pG(() => {
    Pt && (process.env.NODE_ENV === "test" || !iN && !document.body.querySelector(t.value)) && (iN = Oxe(e.value));
  }), {
    id: e,
    selector: t
  };
}, kxe = ht({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), Axe = ({
  showAfter: e,
  hideAfter: t,
  autoClose: r,
  open: n,
  close: i
}) => {
  const { registerTimeout: s } = rN(), {
    registerTimeout: o,
    cancelTimeout: a
  } = rN();
  return {
    onOpen: (h) => {
      s(() => {
        n(h);
        const f = _(r);
        ar(f) && f > 0 && o(() => {
          i(h);
        }, f);
      }, _(e));
    },
    onClose: (h) => {
      a(), s(() => {
        i(h);
      }, _(t));
    }
  };
}, PB = Symbol("elForwardRef"), Pxe = (e) => {
  cn(PB, {
    setForwardRef: (r) => {
      e.value = r;
    }
  });
}, Rxe = (e) => ({
  mounted(t) {
    e(t);
  },
  updated(t) {
    e(t);
  },
  unmounted() {
    e(null);
  }
}), sN = q(0), RB = 2e3, LB = Symbol("zIndexContextKey"), kC = (e) => {
  const t = e || (nn() ? ot(LB, void 0) : void 0), r = A(() => {
    const s = _(t);
    return ar(s) ? s : RB;
  }), n = A(() => r.value + sN.value);
  return {
    initialZIndex: r,
    currentZIndex: n,
    nextZIndex: () => (sN.value++, n.value)
  };
};
function Lxe(e) {
  const t = q();
  function r() {
    if (e.value == null)
      return;
    const { selectionStart: i, selectionEnd: s, value: o } = e.value;
    if (i == null || s == null)
      return;
    const a = o.slice(0, Math.max(0, i)), l = o.slice(Math.max(0, s));
    t.value = {
      selectionStart: i,
      selectionEnd: s,
      value: o,
      beforeTxt: a,
      afterTxt: l
    };
  }
  function n() {
    if (e.value == null || t.value == null)
      return;
    const { value: i } = e.value, { beforeTxt: s, afterTxt: o, selectionStart: a } = t.value;
    if (s == null || o == null || a == null)
      return;
    let l = i.length;
    if (i.endsWith(o))
      l = i.length - o.length;
    else if (i.startsWith(s))
      l = s.length;
    else {
      const c = s[a - 1], h = i.indexOf(c, a - 1);
      h !== -1 && (l = h + 1);
    }
    e.value.setSelectionRange(l, l);
  }
  return [r, n];
}
const Qu = n2({
  type: String,
  values: l0,
  required: !1
}), NB = Symbol("size"), Nxe = () => {
  const e = ot(NB, {});
  return A(() => _(e.size) || "");
};
function Fxe(e, { afterFocus: t, beforeBlur: r, afterBlur: n } = {}) {
  const i = nn(), { emit: s } = i, o = fd(), a = q(!1), l = (f) => {
    a.value || (a.value = !0, s("focus", f), t == null || t());
  }, c = (f) => {
    var m;
    er(r) && r(f) || f.relatedTarget && ((m = o.value) != null && m.contains(f.relatedTarget)) || (a.value = !1, s("blur", f), n == null || n());
  }, h = () => {
    var f;
    (f = e.value) == null || f.focus();
  };
  return Se(o, (f) => {
    f && f.setAttribute("tabindex", "-1");
  }), rl(o, "click", h), {
    wrapperRef: o,
    isFocused: a,
    handleFocus: l,
    handleBlur: c
  };
}
const FB = Symbol(), Ow = q();
function a2(e, t = void 0) {
  const r = nn() ? ot(FB, Ow) : Ow;
  return e ? A(() => {
    var n, i;
    return (i = (n = r.value) == null ? void 0 : n[e]) != null ? i : t;
  }) : r;
}
function AC(e, t) {
  const r = a2(), n = Je(e, A(() => {
    var a;
    return ((a = r.value) == null ? void 0 : a.namespace) || Ay;
  })), i = ap(A(() => {
    var a;
    return (a = r.value) == null ? void 0 : a.locale;
  })), s = kC(A(() => {
    var a;
    return ((a = r.value) == null ? void 0 : a.zIndex) || RB;
  })), o = A(() => {
    var a;
    return _(t) || ((a = r.value) == null ? void 0 : a.size) || "";
  });
  return DB(A(() => _(r) || {})), {
    ns: n,
    locale: i,
    zIndex: s,
    size: o
  };
}
const DB = (e, t, r = !1) => {
  var n;
  const i = !!nn(), s = i ? a2() : void 0, o = (n = t == null ? void 0 : t.provide) != null ? n : i ? cn : void 0;
  if (!o) {
    Ut("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const a = A(() => {
    const l = _(e);
    return s != null && s.value ? Dxe(s.value, l) : l;
  });
  return o(FB, a), o(yB, A(() => a.value.locale)), o(bB, A(() => a.value.namespace)), o(LB, A(() => a.value.zIndex)), o(NB, {
    size: A(() => a.value.size || "")
  }), (r || !Ow.value) && (Ow.value = a.value), a;
}, Dxe = (e, t) => {
  var r;
  const n = [.../* @__PURE__ */ new Set([...DL(e), ...DL(t)])], i = {};
  for (const s of n)
    i[s] = (r = t[s]) != null ? r : e[s];
  return i;
}, jxe = ht({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: Le(Object)
  },
  size: Qu,
  button: {
    type: Le(Object)
  },
  experimentalFeatures: {
    type: Le(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: Le(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}), QI = {};
he({
  name: "ElConfigProvider",
  props: jxe,
  setup(e, { slots: t }) {
    Se(() => e.message, (n) => {
      Object.assign(QI, n ?? {});
    }, { immediate: !0, deep: !0 });
    const r = DB(e);
    return () => ke(t, "default", { config: r == null ? void 0 : r.value });
  }
});
var rt = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, i] of t)
    r[n] = i;
  return r;
};
const Vxe = ht({
  size: {
    type: Le([Number, String])
  },
  color: {
    type: String
  }
}), zxe = he({
  name: "ElIcon",
  inheritAttrs: !1
}), Uxe = /* @__PURE__ */ he({
  ...zxe,
  props: Vxe,
  setup(e) {
    const t = e, r = Je("icon"), n = A(() => {
      const { size: i, color: s } = t;
      return !i && !s ? {} : {
        fontSize: Hh(i) ? void 0 : cl(i),
        "--color": s
      };
    });
    return (i, s) => (R(), Z("i", Ko({
      class: _(r).b(),
      style: _(n)
    }, i.$attrs), [
      ke(i.$slots, "default")
    ], 16));
  }
});
var Bxe = /* @__PURE__ */ rt(Uxe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const zt = fi(Bxe), Ef = Symbol("formContextKey"), Gd = Symbol("formItemContextKey"), go = (e, t = {}) => {
  const r = q(void 0), n = t.prop ? r : _B("size"), i = t.global ? r : Nxe(), s = t.form ? { size: void 0 } : ot(Ef, void 0), o = t.formItem ? { size: void 0 } : ot(Gd, void 0);
  return A(() => n.value || _(e) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "");
}, If = (e) => {
  const t = _B("disabled"), r = ot(Ef, void 0);
  return A(() => t.value || _(e) || (r == null ? void 0 : r.disabled) || !1);
}, gl = () => {
  const e = ot(Ef, void 0), t = ot(Gd, void 0);
  return {
    form: e,
    formItem: t
  };
}, d0 = (e, {
  formItemContext: t,
  disableIdGeneration: r,
  disableIdManagement: n
}) => {
  r || (r = q(!1)), n || (n = q(!1));
  const i = q();
  let s;
  const o = A(() => {
    var a;
    return !!(!e.label && t && t.inputIds && ((a = t.inputIds) == null ? void 0 : a.length) <= 1);
  });
  return qt(() => {
    s = Se([io(e, "id"), r], ([a, l]) => {
      const c = a ?? (l ? void 0 : ju().value);
      c !== i.value && (t != null && t.removeInputId && (i.value && t.removeInputId(i.value), !(n != null && n.value) && !l && c && t.addInputId(c)), i.value = c);
    }, { immediate: !0 });
  }), hG(() => {
    s && s(), t != null && t.removeInputId && i.value && t.removeInputId(i.value);
  }), {
    isLabeledByFormItem: o,
    inputId: i
  };
}, qxe = ht({
  size: {
    type: String,
    values: l0
  },
  disabled: Boolean
}), Gxe = ht({
  ...qxe,
  model: Object,
  rules: {
    type: Le(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
}), Hxe = {
  validate: (e, t, r) => (ul(e) || nr(e)) && Un(t) && nr(r)
}, Wxe = "ElForm";
function Jxe() {
  const e = q([]), t = A(() => {
    if (!e.value.length)
      return "0";
    const s = Math.max(...e.value);
    return s ? `${s}px` : "";
  });
  function r(s) {
    const o = e.value.indexOf(s);
    return o === -1 && t.value === "0" && Ut(Wxe, `unexpected width ${s}`), o;
  }
  function n(s, o) {
    if (s && o) {
      const a = r(o);
      e.value.splice(a, 1, s);
    } else
      s && e.value.push(s);
  }
  function i(s) {
    const o = r(s);
    o > -1 && e.value.splice(o, 1);
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: n,
    deregisterLabelWidth: i
  };
}
const Sv = (e, t) => {
  const r = jI(t);
  return r.length > 0 ? e.filter((n) => n.prop && r.includes(n.prop)) : e;
}, W1 = "ElForm", Zxe = he({
  name: W1
}), Kxe = /* @__PURE__ */ he({
  ...Zxe,
  props: Gxe,
  emits: Hxe,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = [], s = go(), o = Je("form"), a = A(() => {
      const { labelPosition: x, inline: $ } = n;
      return [
        o.b(),
        o.m(s.value || "default"),
        {
          [o.m(`label-${x}`)]: x,
          [o.m("inline")]: $
        }
      ];
    }), l = (x) => {
      i.push(x);
    }, c = (x) => {
      x.prop && i.splice(i.indexOf(x), 1);
    }, h = (x = []) => {
      if (!n.model) {
        Ut(W1, "model is required for resetFields to work.");
        return;
      }
      Sv(i, x).forEach(($) => $.resetField());
    }, f = (x = []) => {
      Sv(i, x).forEach(($) => $.clearValidate());
    }, m = A(() => {
      const x = !!n.model;
      return x || Ut(W1, "model is required for validate to work."), x;
    }), y = (x) => {
      if (i.length === 0)
        return [];
      const $ = Sv(i, x);
      return $.length ? $ : (Ut(W1, "please pass correct props!"), []);
    }, g = async (x) => b(void 0, x), v = async (x = []) => {
      if (!m.value)
        return !1;
      const $ = y(x);
      if ($.length === 0)
        return !0;
      let T = {};
      for (const C of $)
        try {
          await C.validate("");
        } catch (I) {
          T = {
            ...T,
            ...I
          };
        }
      return Object.keys(T).length === 0 ? !0 : Promise.reject(T);
    }, b = async (x = [], $) => {
      const T = !er($);
      try {
        const C = await v(x);
        return C === !0 && ($ == null || $(C)), C;
      } catch (C) {
        if (C instanceof Error)
          throw C;
        const I = C;
        return n.scrollToError && w(Object.keys(I)[0]), $ == null || $(!1, I), T && Promise.reject(I);
      }
    }, w = (x) => {
      var $;
      const T = Sv(i, x)[0];
      T && (($ = T.$el) == null || $.scrollIntoView(n.scrollIntoViewOptions));
    };
    return Se(() => n.rules, () => {
      n.validateOnRuleChange && g().catch((x) => Ut(x));
    }, { deep: !0 }), cn(Ef, ci({
      ...zu(n),
      emit: r,
      resetFields: h,
      clearValidate: f,
      validateField: b,
      addField: l,
      removeField: c,
      ...Jxe()
    })), t({
      validate: g,
      validateField: b,
      resetFields: h,
      clearValidate: f,
      scrollToField: w
    }), (x, $) => (R(), Z("form", {
      class: B(_(a))
    }, [
      ke(x.$slots, "default")
    ], 2));
  }
});
var Yxe = /* @__PURE__ */ rt(Kxe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
function dd() {
  return dd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, dd.apply(this, arguments);
}
function Qxe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Tg(e, t);
}
function XI(e) {
  return XI = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, XI(e);
}
function Tg(e, t) {
  return Tg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Tg(e, t);
}
function Xxe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function J1(e, t, r) {
  return Xxe() ? J1 = Reflect.construct.bind() : J1 = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), c = new l();
    return o && Tg(c, o.prototype), c;
  }, J1.apply(null, arguments);
}
function eTe(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function e3(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return e3 = function(n) {
    if (n === null || !eTe(n))
      return n;
    if (typeof n != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(n))
        return t.get(n);
      t.set(n, i);
    }
    function i() {
      return J1(n, arguments, XI(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Tg(i, n);
  }, e3(e);
}
var tTe = /%[sdj%]/g, jB = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (jB = function(t, r) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && r.every(function(n) {
    return typeof n == "string";
  }) && console.warn(t, r);
});
function t3(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(r) {
    var n = r.field;
    t[n] = t[n] || [], t[n].push(r);
  }), t;
}
function Ci(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var i = 0, s = r.length;
  if (typeof e == "function")
    return e.apply(null, r);
  if (typeof e == "string") {
    var o = e.replace(tTe, function(a) {
      if (a === "%%")
        return "%";
      if (i >= s)
        return a;
      switch (a) {
        case "%s":
          return String(r[i++]);
        case "%d":
          return Number(r[i++]);
        case "%j":
          try {
            return JSON.stringify(r[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return o;
  }
  return e;
}
function rTe(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function Ur(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || rTe(t) && typeof e == "string" && !e);
}
function nTe(e, t, r) {
  var n = [], i = 0, s = e.length;
  function o(a) {
    n.push.apply(n, a || []), i++, i === s && r(n);
  }
  e.forEach(function(a) {
    t(a, o);
  });
}
function oN(e, t, r) {
  var n = 0, i = e.length;
  function s(o) {
    if (o && o.length) {
      r(o);
      return;
    }
    var a = n;
    n = n + 1, a < i ? t(e[a], s) : r([]);
  }
  s([]);
}
function iTe(e) {
  var t = [];
  return Object.keys(e).forEach(function(r) {
    t.push.apply(t, e[r] || []);
  }), t;
}
var aN = /* @__PURE__ */ function(e) {
  Qxe(t, e);
  function t(r, n) {
    var i;
    return i = e.call(this, "Async Validation Error") || this, i.errors = r, i.fields = n, i;
  }
  return t;
}(/* @__PURE__ */ e3(Error));
function sTe(e, t, r, n, i) {
  if (t.first) {
    var s = new Promise(function(m, y) {
      var g = function(w) {
        return n(w), w.length ? y(new aN(w, t3(w))) : m(i);
      }, v = iTe(e);
      oN(v, r, g);
    });
    return s.catch(function(m) {
      return m;
    }), s;
  }
  var o = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], a = Object.keys(e), l = a.length, c = 0, h = [], f = new Promise(function(m, y) {
    var g = function(b) {
      if (h.push.apply(h, b), c++, c === l)
        return n(h), h.length ? y(new aN(h, t3(h))) : m(i);
    };
    a.length || (n(h), m(i)), a.forEach(function(v) {
      var b = e[v];
      o.indexOf(v) !== -1 ? oN(b, r, g) : nTe(b, r, g);
    });
  });
  return f.catch(function(m) {
    return m;
  }), f;
}
function oTe(e) {
  return !!(e && e.message !== void 0);
}
function aTe(e, t) {
  for (var r = e, n = 0; n < t.length; n++) {
    if (r == null)
      return r;
    r = r[t[n]];
  }
  return r;
}
function lN(e, t) {
  return function(r) {
    var n;
    return e.fullFields ? n = aTe(t, e.fullFields) : n = t[r.field || e.fullField], oTe(r) ? (r.field = r.field || e.fullField, r.fieldValue = n, r) : {
      message: typeof r == "function" ? r() : r,
      fieldValue: n,
      field: r.field || e.fullField
    };
  };
}
function uN(e, t) {
  if (t) {
    for (var r in t)
      if (t.hasOwnProperty(r)) {
        var n = t[r];
        typeof n == "object" && typeof e[r] == "object" ? e[r] = dd({}, e[r], n) : e[r] = n;
      }
  }
  return e;
}
var VB = function(t, r, n, i, s, o) {
  t.required && (!n.hasOwnProperty(t.field) || Ur(r, o || t.type)) && i.push(Ci(s.messages.required, t.fullField));
}, lTe = function(t, r, n, i, s) {
  (/^\s+$/.test(r) || r === "") && i.push(Ci(s.messages.whitespace, t.fullField));
}, $v, uTe = function() {
  if ($v)
    return $v;
  var e = "[a-fA-F\\d:]", t = function(T) {
    return T && T.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, r = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", n = "[a-fA-F\\d]{1,4}", i = (`
(?:
(?:` + n + ":){7}(?:" + n + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + n + ":){6}(?:" + r + "|:" + n + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + n + ":){5}(?::" + r + "|(?::" + n + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + n + ":){4}(?:(?::" + n + "){0,1}:" + r + "|(?::" + n + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + n + ":){3}(?:(?::" + n + "){0,2}:" + r + "|(?::" + n + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + n + ":){2}(?:(?::" + n + "){0,3}:" + r + "|(?::" + n + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + n + ":){1}(?:(?::" + n + "){0,4}:" + r + "|(?::" + n + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + n + "){0,5}:" + r + "|(?::" + n + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), s = new RegExp("(?:^" + r + "$)|(?:^" + i + "$)"), o = new RegExp("^" + r + "$"), a = new RegExp("^" + i + "$"), l = function(T) {
    return T && T.exact ? s : new RegExp("(?:" + t(T) + r + t(T) + ")|(?:" + t(T) + i + t(T) + ")", "g");
  };
  l.v4 = function($) {
    return $ && $.exact ? o : new RegExp("" + t($) + r + t($), "g");
  }, l.v6 = function($) {
    return $ && $.exact ? a : new RegExp("" + t($) + i + t($), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", h = "(?:\\S+(?::\\S*)?@)?", f = l.v4().source, m = l.v6().source, y = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", g = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", v = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", b = "(?::\\d{2,5})?", w = '(?:[/?#][^\\s"]*)?', x = "(?:" + c + "|www\\.)" + h + "(?:localhost|" + f + "|" + m + "|" + y + g + v + ")" + b + w;
  return $v = new RegExp("(?:^" + x + "$)", "i"), $v;
}, cN = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, ly = {
  integer: function(t) {
    return ly.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return ly.number(t) && !ly.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !ly.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(cN.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(uTe());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(cN.hex);
  }
}, cTe = function(t, r, n, i, s) {
  if (t.required && r === void 0) {
    VB(t, r, n, i, s);
    return;
  }
  var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = t.type;
  o.indexOf(a) > -1 ? ly[a](r) || i.push(Ci(s.messages.types[a], t.fullField, t.type)) : a && typeof r !== t.type && i.push(Ci(s.messages.types[a], t.fullField, t.type));
}, dTe = function(t, r, n, i, s) {
  var o = typeof t.len == "number", a = typeof t.min == "number", l = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, h = r, f = null, m = typeof r == "number", y = typeof r == "string", g = Array.isArray(r);
  if (m ? f = "number" : y ? f = "string" : g && (f = "array"), !f)
    return !1;
  g && (h = r.length), y && (h = r.replace(c, "_").length), o ? h !== t.len && i.push(Ci(s.messages[f].len, t.fullField, t.len)) : a && !l && h < t.min ? i.push(Ci(s.messages[f].min, t.fullField, t.min)) : l && !a && h > t.max ? i.push(Ci(s.messages[f].max, t.fullField, t.max)) : a && l && (h < t.min || h > t.max) && i.push(Ci(s.messages[f].range, t.fullField, t.min, t.max));
}, wp = "enum", pTe = function(t, r, n, i, s) {
  t[wp] = Array.isArray(t[wp]) ? t[wp] : [], t[wp].indexOf(r) === -1 && i.push(Ci(s.messages[wp], t.fullField, t[wp].join(", ")));
}, hTe = function(t, r, n, i, s) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(r) || i.push(Ci(s.messages.pattern.mismatch, t.fullField, r, t.pattern));
    else if (typeof t.pattern == "string") {
      var o = new RegExp(t.pattern);
      o.test(r) || i.push(Ci(s.messages.pattern.mismatch, t.fullField, r, t.pattern));
    }
  }
}, lt = {
  required: VB,
  whitespace: lTe,
  type: cTe,
  range: dTe,
  enum: pTe,
  pattern: hTe
}, fTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r, "string") && !t.required)
      return n();
    lt.required(t, r, i, o, s, "string"), Ur(r, "string") || (lt.type(t, r, i, o, s), lt.range(t, r, i, o, s), lt.pattern(t, r, i, o, s), t.whitespace === !0 && lt.whitespace(t, r, i, o, s));
  }
  n(o);
}, mTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && lt.type(t, r, i, o, s);
  }
  n(o);
}, yTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (r === "" && (r = void 0), Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && (lt.type(t, r, i, o, s), lt.range(t, r, i, o, s));
  }
  n(o);
}, gTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && lt.type(t, r, i, o, s);
  }
  n(o);
}, vTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), Ur(r) || lt.type(t, r, i, o, s);
  }
  n(o);
}, bTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && (lt.type(t, r, i, o, s), lt.range(t, r, i, o, s));
  }
  n(o);
}, wTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && (lt.type(t, r, i, o, s), lt.range(t, r, i, o, s));
  }
  n(o);
}, _Te = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (r == null && !t.required)
      return n();
    lt.required(t, r, i, o, s, "array"), r != null && (lt.type(t, r, i, o, s), lt.range(t, r, i, o, s));
  }
  n(o);
}, STe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && lt.type(t, r, i, o, s);
  }
  n(o);
}, $Te = "enum", xTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s), r !== void 0 && lt[$Te](t, r, i, o, s);
  }
  n(o);
}, TTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r, "string") && !t.required)
      return n();
    lt.required(t, r, i, o, s), Ur(r, "string") || lt.pattern(t, r, i, o, s);
  }
  n(o);
}, ETe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r, "date") && !t.required)
      return n();
    if (lt.required(t, r, i, o, s), !Ur(r, "date")) {
      var l;
      r instanceof Date ? l = r : l = new Date(r), lt.type(t, l, i, o, s), l && lt.range(t, l.getTime(), i, o, s);
    }
  }
  n(o);
}, ITe = function(t, r, n, i, s) {
  var o = [], a = Array.isArray(r) ? "array" : typeof r;
  lt.required(t, r, i, o, s, a), n(o);
}, XS = function(t, r, n, i, s) {
  var o = t.type, a = [], l = t.required || !t.required && i.hasOwnProperty(t.field);
  if (l) {
    if (Ur(r, o) && !t.required)
      return n();
    lt.required(t, r, i, a, s, o), Ur(r, o) || lt.type(t, r, i, a, s);
  }
  n(a);
}, MTe = function(t, r, n, i, s) {
  var o = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (Ur(r) && !t.required)
      return n();
    lt.required(t, r, i, o, s);
  }
  n(o);
}, Ly = {
  string: fTe,
  method: mTe,
  number: yTe,
  boolean: gTe,
  regexp: vTe,
  integer: bTe,
  float: wTe,
  array: _Te,
  object: STe,
  enum: xTe,
  pattern: TTe,
  date: ETe,
  url: XS,
  hex: XS,
  email: XS,
  required: ITe,
  any: MTe
};
function r3() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var n3 = r3(), p0 = /* @__PURE__ */ function() {
  function e(r) {
    this.rules = null, this._messages = n3, this.define(r);
  }
  var t = e.prototype;
  return t.define = function(n) {
    var i = this;
    if (!n)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof n != "object" || Array.isArray(n))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(n).forEach(function(s) {
      var o = n[s];
      i.rules[s] = Array.isArray(o) ? o : [o];
    });
  }, t.messages = function(n) {
    return n && (this._messages = uN(r3(), n)), this._messages;
  }, t.validate = function(n, i, s) {
    var o = this;
    i === void 0 && (i = {}), s === void 0 && (s = function() {
    });
    var a = n, l = i, c = s;
    if (typeof l == "function" && (c = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, a), Promise.resolve(a);
    function h(v) {
      var b = [], w = {};
      function x(T) {
        if (Array.isArray(T)) {
          var C;
          b = (C = b).concat.apply(C, T);
        } else
          b.push(T);
      }
      for (var $ = 0; $ < v.length; $++)
        x(v[$]);
      b.length ? (w = t3(b), c(b, w)) : c(null, a);
    }
    if (l.messages) {
      var f = this.messages();
      f === n3 && (f = r3()), uN(f, l.messages), l.messages = f;
    } else
      l.messages = this.messages();
    var m = {}, y = l.keys || Object.keys(this.rules);
    y.forEach(function(v) {
      var b = o.rules[v], w = a[v];
      b.forEach(function(x) {
        var $ = x;
        typeof $.transform == "function" && (a === n && (a = dd({}, a)), w = a[v] = $.transform(w)), typeof $ == "function" ? $ = {
          validator: $
        } : $ = dd({}, $), $.validator = o.getValidationMethod($), $.validator && ($.field = v, $.fullField = $.fullField || v, $.type = o.getType($), m[v] = m[v] || [], m[v].push({
          rule: $,
          value: w,
          source: a,
          field: v
        }));
      });
    });
    var g = {};
    return sTe(m, l, function(v, b) {
      var w = v.rule, x = (w.type === "object" || w.type === "array") && (typeof w.fields == "object" || typeof w.defaultField == "object");
      x = x && (w.required || !w.required && v.value), w.field = v.field;
      function $(I, O) {
        return dd({}, O, {
          fullField: w.fullField + "." + I,
          fullFields: w.fullFields ? [].concat(w.fullFields, [I]) : [I]
        });
      }
      function T(I) {
        I === void 0 && (I = []);
        var O = Array.isArray(I) ? I : [I];
        !l.suppressWarning && O.length && e.warning("async-validator:", O), O.length && w.message !== void 0 && (O = [].concat(w.message));
        var M = O.map(lN(w, a));
        if (l.first && M.length)
          return g[w.field] = 1, b(M);
        if (!x)
          b(M);
        else {
          if (w.required && !v.value)
            return w.message !== void 0 ? M = [].concat(w.message).map(lN(w, a)) : l.error && (M = [l.error(w, Ci(l.messages.required, w.field))]), b(M);
          var L = {};
          w.defaultField && Object.keys(v.value).map(function(D) {
            L[D] = w.defaultField;
          }), L = dd({}, L, v.rule.fields);
          var N = {};
          Object.keys(L).forEach(function(D) {
            var H = L[D], J = Array.isArray(H) ? H : [H];
            N[D] = J.map($.bind(null, D));
          });
          var ee = new e(N);
          ee.messages(l.messages), v.rule.options && (v.rule.options.messages = l.messages, v.rule.options.error = l.error), ee.validate(v.value, v.rule.options || l, function(D) {
            var H = [];
            M && M.length && H.push.apply(H, M), D && D.length && H.push.apply(H, D), b(H.length ? H : null);
          });
        }
      }
      var C;
      if (w.asyncValidator)
        C = w.asyncValidator(w, v.value, T, v.source, l);
      else if (w.validator) {
        try {
          C = w.validator(w, v.value, T, v.source, l);
        } catch (I) {
          console.error == null || console.error(I), l.suppressValidatorError || setTimeout(function() {
            throw I;
          }, 0), T(I.message);
        }
        C === !0 ? T() : C === !1 ? T(typeof w.message == "function" ? w.message(w.fullField || w.field) : w.message || (w.fullField || w.field) + " fails") : C instanceof Array ? T(C) : C instanceof Error && T(C.message);
      }
      C && C.then && C.then(function() {
        return T();
      }, function(I) {
        return T(I);
      });
    }, function(v) {
      h(v);
    }, a);
  }, t.getType = function(n) {
    if (n.type === void 0 && n.pattern instanceof RegExp && (n.type = "pattern"), typeof n.validator != "function" && n.type && !Ly.hasOwnProperty(n.type))
      throw new Error(Ci("Unknown rule type %s", n.type));
    return n.type || "string";
  }, t.getValidationMethod = function(n) {
    if (typeof n.validator == "function")
      return n.validator;
    var i = Object.keys(n), s = i.indexOf("message");
    return s !== -1 && i.splice(s, 1), i.length === 1 && i[0] === "required" ? Ly.required : Ly[this.getType(n)] || void 0;
  }, e;
}();
p0.register = function(t, r) {
  if (typeof r != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Ly[t] = r;
};
p0.warning = jB;
p0.messages = n3;
p0.validators = Ly;
const OTe = [
  "",
  "error",
  "validating",
  "success"
], CTe = ht({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: Le([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: Le([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: OTe
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: l0
  }
}), dN = "ElLabelWrap";
var kTe = he({
  name: dN,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e, {
    slots: t
  }) {
    const r = ot(Ef, void 0), n = ot(Gd);
    n || t2(dN, "usage: <el-form-item><label-wrap /></el-form-item>");
    const i = Je("form"), s = q(), o = q(0), a = () => {
      var h;
      if ((h = s.value) != null && h.firstElementChild) {
        const f = window.getComputedStyle(s.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(f));
      } else
        return 0;
    }, l = (h = "update") => {
      Ye(() => {
        t.default && e.isAutoWidth && (h === "update" ? o.value = a() : h === "remove" && (r == null || r.deregisterLabelWidth(o.value)));
      });
    }, c = () => l("update");
    return qt(() => {
      c();
    }), Ni(() => {
      l("remove");
    }), p5(() => c()), Se(o, (h, f) => {
      e.updateAll && (r == null || r.registerLabelWidth(h, f));
    }), ip(A(() => {
      var h, f;
      return (f = (h = s.value) == null ? void 0 : h.firstElementChild) != null ? f : null;
    }), c), () => {
      var h, f;
      if (!t)
        return null;
      const {
        isAutoWidth: m
      } = e;
      if (m) {
        const y = r == null ? void 0 : r.autoLabelWidth, g = n == null ? void 0 : n.hasLabel, v = {};
        if (g && y && y !== "auto") {
          const b = Math.max(0, Number.parseInt(y, 10) - o.value), w = r.labelPosition === "left" ? "marginRight" : "marginLeft";
          b && (v[w] = `${b}px`);
        }
        return de("div", {
          ref: s,
          class: [i.be("item", "label-wrap")],
          style: v
        }, [(h = t.default) == null ? void 0 : h.call(t)]);
      } else
        return de(Mt, {
          ref: s
        }, [(f = t.default) == null ? void 0 : f.call(t)]);
    };
  }
});
const ATe = ["role", "aria-labelledby"], PTe = he({
  name: "ElFormItem"
}), RTe = /* @__PURE__ */ he({
  ...PTe,
  props: CTe,
  setup(e, { expose: t }) {
    const r = e, n = ef(), i = ot(Ef, void 0), s = ot(Gd, void 0), o = go(void 0, { formItem: !1 }), a = Je("form-item"), l = ju().value, c = q([]), h = q(""), f = yve(h, 100), m = q(""), y = q();
    let g, v = !1;
    const b = A(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top")
        return {};
      const xe = cl(r.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return xe ? { width: xe } : {};
    }), w = A(() => {
      if ((i == null ? void 0 : i.labelPosition) === "top" || i != null && i.inline)
        return {};
      if (!r.label && !r.labelWidth && L)
        return {};
      const xe = cl(r.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
      return !r.label && !n.label ? { marginLeft: xe } : {};
    }), x = A(() => [
      a.b(),
      a.m(o.value),
      a.is("error", h.value === "error"),
      a.is("validating", h.value === "validating"),
      a.is("success", h.value === "success"),
      a.is("required", J.value || r.required),
      a.is("no-asterisk", i == null ? void 0 : i.hideRequiredAsterisk),
      (i == null ? void 0 : i.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [a.m("feedback")]: i == null ? void 0 : i.statusIcon }
    ]), $ = A(() => Un(r.inlineMessage) ? r.inlineMessage : (i == null ? void 0 : i.inlineMessage) || !1), T = A(() => [
      a.e("error"),
      { [a.em("error", "inline")]: $.value }
    ]), C = A(() => r.prop ? nr(r.prop) ? r.prop : r.prop.join(".") : ""), I = A(() => !!(r.label || n.label)), O = A(() => r.for || (c.value.length === 1 ? c.value[0] : void 0)), M = A(() => !O.value && I.value), L = !!s, N = A(() => {
      const xe = i == null ? void 0 : i.model;
      if (!(!xe || !r.prop))
        return QS(xe, r.prop).value;
    }), ee = A(() => {
      const { required: xe } = r, Ne = [];
      r.rules && Ne.push(...jI(r.rules));
      const He = i == null ? void 0 : i.rules;
      if (He && r.prop) {
        const nt = QS(He, r.prop).value;
        nt && Ne.push(...jI(nt));
      }
      if (xe !== void 0) {
        const nt = Ne.map((wt, cr) => [wt, cr]).filter(([wt]) => Object.keys(wt).includes("required"));
        if (nt.length > 0)
          for (const [wt, cr] of nt)
            wt.required !== xe && (Ne[cr] = { ...wt, required: xe });
        else
          Ne.push({ required: xe });
      }
      return Ne;
    }), D = A(() => ee.value.length > 0), H = (xe) => ee.value.filter((He) => !He.trigger || !xe ? !0 : Array.isArray(He.trigger) ? He.trigger.includes(xe) : He.trigger === xe).map(({ trigger: He, ...nt }) => nt), J = A(() => ee.value.some((xe) => xe.required)), oe = A(() => {
      var xe;
      return f.value === "error" && r.showMessage && ((xe = i == null ? void 0 : i.showMessage) != null ? xe : !0);
    }), ye = A(() => `${r.label || ""}${(i == null ? void 0 : i.labelSuffix) || ""}`), Q = (xe) => {
      h.value = xe;
    }, ve = (xe) => {
      var Ne, He;
      const { errors: nt, fields: wt } = xe;
      (!nt || !wt) && console.error(xe), Q("error"), m.value = nt ? (He = (Ne = nt == null ? void 0 : nt[0]) == null ? void 0 : Ne.message) != null ? He : `${r.prop} is required` : "", i == null || i.emit("validate", r.prop, !1, m.value);
    }, Ee = () => {
      Q("success"), i == null || i.emit("validate", r.prop, !0, "");
    }, Lt = async (xe) => {
      const Ne = C.value;
      return new p0({
        [Ne]: xe
      }).validate({ [Ne]: N.value }, { firstFields: !0 }).then(() => (Ee(), !0)).catch((nt) => (ve(nt), Promise.reject(nt)));
    }, ft = async (xe, Ne) => {
      if (v || !r.prop)
        return !1;
      const He = er(Ne);
      if (!D.value)
        return Ne == null || Ne(!1), !1;
      const nt = H(xe);
      return nt.length === 0 ? (Ne == null || Ne(!0), !0) : (Q("validating"), Lt(nt).then(() => (Ne == null || Ne(!0), !0)).catch((wt) => {
        const { fields: cr } = wt;
        return Ne == null || Ne(!1, cr), He ? !1 : Promise.reject(cr);
      }));
    }, Nt = () => {
      Q(""), m.value = "", v = !1;
    }, ir = async () => {
      const xe = i == null ? void 0 : i.model;
      if (!xe || !r.prop)
        return;
      const Ne = QS(xe, r.prop);
      v = !0, Ne.value = AL(g), await Ye(), Nt(), v = !1;
    }, wr = (xe) => {
      c.value.includes(xe) || c.value.push(xe);
    }, _r = (xe) => {
      c.value = c.value.filter((Ne) => Ne !== xe);
    };
    Se(() => r.error, (xe) => {
      m.value = xe || "", Q(xe ? "error" : "");
    }, { immediate: !0 }), Se(() => r.validateStatus, (xe) => Q(xe || ""));
    const Pr = ci({
      ...zu(r),
      $el: y,
      size: o,
      validateState: h,
      labelId: l,
      inputIds: c,
      isGroup: M,
      hasLabel: I,
      addInputId: wr,
      removeInputId: _r,
      resetField: ir,
      clearValidate: Nt,
      validate: ft
    });
    return cn(Gd, Pr), qt(() => {
      r.prop && (i == null || i.addField(Pr), g = AL(N.value));
    }), Ni(() => {
      i == null || i.removeField(Pr);
    }), t({
      size: o,
      validateMessage: m,
      validateState: h,
      validate: ft,
      clearValidate: Nt,
      resetField: ir
    }), (xe, Ne) => {
      var He;
      return R(), Z("div", {
        ref_key: "formItemRef",
        ref: y,
        class: B(_(x)),
        role: _(M) ? "group" : void 0,
        "aria-labelledby": _(M) ? _(l) : void 0
      }, [
        de(_(kTe), {
          "is-auto-width": _(b).width === "auto",
          "update-all": ((He = _(i)) == null ? void 0 : He.labelWidth) === "auto"
        }, {
          default: Y(() => [
            _(I) ? (R(), ue(gr(_(O) ? "label" : "div"), {
              key: 0,
              id: _(l),
              for: _(O),
              class: B(_(a).e("label")),
              style: $t(_(b))
            }, {
              default: Y(() => [
                ke(xe.$slots, "label", { label: _(ye) }, () => [
                  jr(Xe(_(ye)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : le("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        K("div", {
          class: B(_(a).e("content")),
          style: $t(_(w))
        }, [
          ke(xe.$slots, "default"),
          de(fG, {
            name: `${_(a).namespace.value}-zoom-in-top`
          }, {
            default: Y(() => [
              _(oe) ? ke(xe.$slots, "error", {
                key: 0,
                error: m.value
              }, () => [
                K("div", {
                  class: B(_(T))
                }, Xe(m.value), 3)
              ]) : le("v-if", !0)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, ATe);
    };
  }
});
var zB = /* @__PURE__ */ rt(RTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
const LTe = fi(Yxe, {
  FormItem: zB
}), Ls = Ku(zB);
let Ns;
const NTe = `
  height:0 !important;
  visibility:hidden !important;
  ${Ove() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, FTe = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function DTe(e) {
  const t = window.getComputedStyle(e), r = t.getPropertyValue("box-sizing"), n = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), i = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
  return { contextStyle: FTe.map((o) => `${o}:${t.getPropertyValue(o)}`).join(";"), paddingSize: n, borderSize: i, boxSizing: r };
}
function pN(e, t = 1, r) {
  var n;
  Ns || (Ns = document.createElement("textarea"), document.body.appendChild(Ns));
  const { paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a } = DTe(e);
  Ns.setAttribute("style", `${a};${NTe}`), Ns.value = e.value || e.placeholder || "";
  let l = Ns.scrollHeight;
  const c = {};
  o === "border-box" ? l = l + s : o === "content-box" && (l = l - i), Ns.value = "";
  const h = Ns.scrollHeight - i;
  if (ar(t)) {
    let f = h * t;
    o === "border-box" && (f = f + i + s), l = Math.max(f, l), c.minHeight = `${f}px`;
  }
  if (ar(r)) {
    let f = h * r;
    o === "border-box" && (f = f + i + s), l = Math.min(f, l);
  }
  return c.height = `${l}px`, (n = Ns.parentNode) == null || n.removeChild(Ns), Ns = void 0, c;
}
const jTe = ht({
  id: {
    type: String,
    default: void 0
  },
  size: Qu,
  disabled: Boolean,
  modelValue: {
    type: Le([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Le([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: Oi
  },
  prefixIcon: {
    type: Oi
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Le([Object, Array, String]),
    default: () => mB({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
}), VTe = {
  [At]: (e) => nr(e),
  input: (e) => nr(e),
  change: (e) => nr(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (e) => e instanceof MouseEvent,
  mouseenter: (e) => e instanceof MouseEvent,
  keydown: (e) => e instanceof Event,
  compositionstart: (e) => e instanceof CompositionEvent,
  compositionupdate: (e) => e instanceof CompositionEvent,
  compositionend: (e) => e instanceof CompositionEvent
}, zTe = ["role"], UTe = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], BTe = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], qTe = he({
  name: "ElInput",
  inheritAttrs: !1
}), GTe = /* @__PURE__ */ he({
  ...qTe,
  props: jTe,
  emits: VTe,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = h5(), s = ef(), o = A(() => {
      const ae = {};
      return n.containerRole === "combobox" && (ae["aria-haspopup"] = i["aria-haspopup"], ae["aria-owns"] = i["aria-owns"], ae["aria-expanded"] = i["aria-expanded"]), ae;
    }), a = A(() => [
      n.type === "textarea" ? b.b() : v.b(),
      v.m(y.value),
      v.is("disabled", g.value),
      v.is("exceed", wr.value),
      {
        [v.b("group")]: s.prepend || s.append,
        [v.bm("group", "append")]: s.append,
        [v.bm("group", "prepend")]: s.prepend,
        [v.m("prefix")]: s.prefix || n.prefixIcon,
        [v.m("suffix")]: s.suffix || n.suffixIcon || n.clearable || n.showPassword,
        [v.bm("suffix", "password-clear")]: Lt.value && ft.value
      },
      i.class
    ]), l = A(() => [
      v.e("wrapper"),
      v.is("focus", N.value)
    ]), c = e$e({
      excludeKeys: A(() => Object.keys(o.value))
    }), { form: h, formItem: f } = gl(), { inputId: m } = d0(n, {
      formItemContext: f
    }), y = go(), g = If(), v = Je("input"), b = Je("textarea"), w = fd(), x = fd(), $ = q(!1), T = q(!1), C = q(!1), I = q(), O = fd(n.inputStyle), M = A(() => w.value || x.value), { wrapperRef: L, isFocused: N, handleFocus: ee, handleBlur: D } = Fxe(M, {
      afterBlur() {
        var ae;
        n.validateEvent && ((ae = f == null ? void 0 : f.validate) == null || ae.call(f, "blur").catch((Fe) => Ut(Fe)));
      }
    }), H = A(() => {
      var ae;
      return (ae = h == null ? void 0 : h.statusIcon) != null ? ae : !1;
    }), J = A(() => (f == null ? void 0 : f.validateState) || ""), oe = A(() => J.value && pB[J.value]), ye = A(() => C.value ? qSe : jSe), Q = A(() => [
      i.style,
      n.inputStyle
    ]), ve = A(() => [
      n.inputStyle,
      O.value,
      { resize: n.resize }
    ]), Ee = A(() => o0(n.modelValue) ? "" : String(n.modelValue)), Lt = A(() => n.clearable && !g.value && !n.readonly && !!Ee.value && (N.value || $.value)), ft = A(() => n.showPassword && !g.value && !n.readonly && !!Ee.value && (!!Ee.value || N.value)), Nt = A(() => n.showWordLimit && !!c.value.maxlength && (n.type === "text" || n.type === "textarea") && !g.value && !n.readonly && !n.showPassword), ir = A(() => Ee.value.length), wr = A(() => !!Nt.value && ir.value > Number(c.value.maxlength)), _r = A(() => !!s.suffix || !!n.suffixIcon || Lt.value || n.showPassword || Nt.value || !!J.value && H.value), [Pr, xe] = Lxe(w);
    ip(x, (ae) => {
      if (nt(), !Nt.value || n.resize !== "both")
        return;
      const Fe = ae[0], { width: at } = Fe.contentRect;
      I.value = {
        right: `calc(100% - ${at + 15 + 6}px)`
      };
    });
    const Ne = () => {
      const { type: ae, autosize: Fe } = n;
      if (!(!Pt || ae !== "textarea" || !x.value))
        if (Fe) {
          const at = En(Fe) ? Fe.minRows : void 0, pr = En(Fe) ? Fe.maxRows : void 0, gi = pN(x.value, at, pr);
          O.value = {
            overflowY: "hidden",
            ...gi
          }, Ye(() => {
            x.value.offsetHeight, O.value = gi;
          });
        } else
          O.value = {
            minHeight: pN(x.value).minHeight
          };
    }, nt = ((ae) => {
      let Fe = !1;
      return () => {
        var at;
        if (Fe || !n.autosize)
          return;
        ((at = x.value) == null ? void 0 : at.offsetParent) === null || (ae(), Fe = !0);
      };
    })(Ne), wt = () => {
      const ae = M.value, Fe = n.formatter ? n.formatter(Ee.value) : Ee.value;
      !ae || ae.value === Fe || (ae.value = Fe);
    }, cr = async (ae) => {
      Pr();
      let { value: Fe } = ae.target;
      if (n.formatter && (Fe = n.parser ? n.parser(Fe) : Fe), !T.value) {
        if (Fe === Ee.value) {
          wt();
          return;
        }
        r(At, Fe), r("input", Fe), await Ye(), wt(), xe();
      }
    }, qr = (ae) => {
      r("change", ae.target.value);
    }, mi = (ae) => {
      r("compositionstart", ae), T.value = !0;
    }, Gn = (ae) => {
      var Fe;
      r("compositionupdate", ae);
      const at = (Fe = ae.target) == null ? void 0 : Fe.value, pr = at[at.length - 1] || "";
      T.value = !SC(pr);
    }, On = (ae) => {
      r("compositionend", ae), T.value && (T.value = !1, cr(ae));
    }, Hn = () => {
      C.value = !C.value, Cn();
    }, Cn = async () => {
      var ae;
      await Ye(), (ae = M.value) == null || ae.focus();
    }, yi = () => {
      var ae;
      return (ae = M.value) == null ? void 0 : ae.blur();
    }, dr = (ae) => {
      $.value = !1, r("mouseleave", ae);
    }, Wn = (ae) => {
      $.value = !0, r("mouseenter", ae);
    }, kn = (ae) => {
      r("keydown", ae);
    }, Jn = () => {
      var ae;
      (ae = M.value) == null || ae.select();
    }, Zn = () => {
      r(At, ""), r("change", ""), r("clear"), r("input", "");
    };
    return Se(() => n.modelValue, () => {
      var ae;
      Ye(() => Ne()), n.validateEvent && ((ae = f == null ? void 0 : f.validate) == null || ae.call(f, "change").catch((Fe) => Ut(Fe)));
    }), Se(Ee, () => wt()), Se(() => n.type, async () => {
      await Ye(), wt(), Ne();
    }), qt(() => {
      !n.formatter && n.parser && Ut("ElInput", "If you set the parser, you also need to set the formatter."), wt(), Ye(Ne);
    }), t({
      input: w,
      textarea: x,
      ref: M,
      textareaStyle: ve,
      autosize: io(n, "autosize"),
      focus: Cn,
      blur: yi,
      select: Jn,
      clear: Zn,
      resizeTextarea: Ne
    }), (ae, Fe) => Yt((R(), Z("div", Ko(_(o), {
      class: _(a),
      style: _(Q),
      role: ae.containerRole,
      onMouseenter: Wn,
      onMouseleave: dr
    }), [
      le(" input "),
      ae.type !== "textarea" ? (R(), Z(Mt, { key: 0 }, [
        le(" prepend slot "),
        ae.$slots.prepend ? (R(), Z("div", {
          key: 0,
          class: B(_(v).be("group", "prepend"))
        }, [
          ke(ae.$slots, "prepend")
        ], 2)) : le("v-if", !0),
        K("div", {
          ref_key: "wrapperRef",
          ref: L,
          class: B(_(l))
        }, [
          le(" prefix slot "),
          ae.$slots.prefix || ae.prefixIcon ? (R(), Z("span", {
            key: 0,
            class: B(_(v).e("prefix"))
          }, [
            K("span", {
              class: B(_(v).e("prefix-inner"))
            }, [
              ke(ae.$slots, "prefix"),
              ae.prefixIcon ? (R(), ue(_(zt), {
                key: 0,
                class: B(_(v).e("icon"))
              }, {
                default: Y(() => [
                  (R(), ue(gr(ae.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : le("v-if", !0)
            ], 2)
          ], 2)) : le("v-if", !0),
          K("input", Ko({
            id: _(m),
            ref_key: "input",
            ref: w,
            class: _(v).e("inner")
          }, _(c), {
            type: ae.showPassword ? C.value ? "text" : "password" : ae.type,
            disabled: _(g),
            formatter: ae.formatter,
            parser: ae.parser,
            readonly: ae.readonly,
            autocomplete: ae.autocomplete,
            tabindex: ae.tabindex,
            "aria-label": ae.label,
            placeholder: ae.placeholder,
            style: ae.inputStyle,
            form: n.form,
            autofocus: n.autofocus,
            onCompositionstart: mi,
            onCompositionupdate: Gn,
            onCompositionend: On,
            onInput: cr,
            onFocus: Fe[0] || (Fe[0] = (...at) => _(ee) && _(ee)(...at)),
            onBlur: Fe[1] || (Fe[1] = (...at) => _(D) && _(D)(...at)),
            onChange: qr,
            onKeydown: kn
          }), null, 16, UTe),
          le(" suffix slot "),
          _(_r) ? (R(), Z("span", {
            key: 1,
            class: B(_(v).e("suffix"))
          }, [
            K("span", {
              class: B(_(v).e("suffix-inner"))
            }, [
              !_(Lt) || !_(ft) || !_(Nt) ? (R(), Z(Mt, { key: 0 }, [
                ke(ae.$slots, "suffix"),
                ae.suffixIcon ? (R(), ue(_(zt), {
                  key: 0,
                  class: B(_(v).e("icon"))
                }, {
                  default: Y(() => [
                    (R(), ue(gr(ae.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : le("v-if", !0)
              ], 64)) : le("v-if", !0),
              _(Lt) ? (R(), ue(_(zt), {
                key: 1,
                class: B([_(v).e("icon"), _(v).e("clear")]),
                onMousedown: kt(_(Xo), ["prevent"]),
                onClick: Zn
              }, {
                default: Y(() => [
                  de(_(r2))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : le("v-if", !0),
              _(ft) ? (R(), ue(_(zt), {
                key: 2,
                class: B([_(v).e("icon"), _(v).e("password")]),
                onClick: Hn
              }, {
                default: Y(() => [
                  (R(), ue(gr(_(ye))))
                ]),
                _: 1
              }, 8, ["class"])) : le("v-if", !0),
              _(Nt) ? (R(), Z("span", {
                key: 3,
                class: B(_(v).e("count"))
              }, [
                K("span", {
                  class: B(_(v).e("count-inner"))
                }, Xe(_(ir)) + " / " + Xe(_(c).maxlength), 3)
              ], 2)) : le("v-if", !0),
              _(J) && _(oe) && _(H) ? (R(), ue(_(zt), {
                key: 4,
                class: B([
                  _(v).e("icon"),
                  _(v).e("validateIcon"),
                  _(v).is("loading", _(J) === "validating")
                ])
              }, {
                default: Y(() => [
                  (R(), ue(gr(_(oe))))
                ]),
                _: 1
              }, 8, ["class"])) : le("v-if", !0)
            ], 2)
          ], 2)) : le("v-if", !0)
        ], 2),
        le(" append slot "),
        ae.$slots.append ? (R(), Z("div", {
          key: 1,
          class: B(_(v).be("group", "append"))
        }, [
          ke(ae.$slots, "append")
        ], 2)) : le("v-if", !0)
      ], 64)) : (R(), Z(Mt, { key: 1 }, [
        le(" textarea "),
        K("textarea", Ko({
          id: _(m),
          ref_key: "textarea",
          ref: x,
          class: _(b).e("inner")
        }, _(c), {
          tabindex: ae.tabindex,
          disabled: _(g),
          readonly: ae.readonly,
          autocomplete: ae.autocomplete,
          style: _(ve),
          "aria-label": ae.label,
          placeholder: ae.placeholder,
          form: n.form,
          autofocus: n.autofocus,
          onCompositionstart: mi,
          onCompositionupdate: Gn,
          onCompositionend: On,
          onInput: cr,
          onFocus: Fe[2] || (Fe[2] = (...at) => _(ee) && _(ee)(...at)),
          onBlur: Fe[3] || (Fe[3] = (...at) => _(D) && _(D)(...at)),
          onChange: qr,
          onKeydown: kn
        }), null, 16, BTe),
        _(Nt) ? (R(), Z("span", {
          key: 0,
          style: $t(I.value),
          class: B(_(v).e("count"))
        }, Xe(_(ir)) + " / " + Xe(_(c).maxlength), 7)) : le("v-if", !0)
      ], 64))
    ], 16, zTe)), [
      [di, ae.type !== "hidden"]
    ]);
  }
});
var HTe = /* @__PURE__ */ rt(GTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const UB = fi(HTe), fh = 4, WTe = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, JTe = ({
  move: e,
  size: t,
  bar: r
}) => ({
  [r.size]: t,
  transform: `translate${r.axis}(${e}%)`
}), BB = Symbol("scrollbarContextKey"), ZTe = ht({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), KTe = "Thumb", YTe = /* @__PURE__ */ he({
  __name: "thumb",
  props: ZTe,
  setup(e) {
    const t = e, r = ot(BB), n = Je("scrollbar");
    r || t2(KTe, "can not inject scrollbar context");
    const i = q(), s = q(), o = q({}), a = q(!1);
    let l = !1, c = !1, h = Pt ? document.onselectstart : null;
    const f = A(() => WTe[t.vertical ? "vertical" : "horizontal"]), m = A(() => JTe({
      size: t.size,
      move: t.move,
      bar: f.value
    })), y = A(() => i.value[f.value.offset] ** 2 / r.wrapElement[f.value.scrollSize] / t.ratio / s.value[f.value.offset]), g = (I) => {
      var O;
      if (I.stopPropagation(), I.ctrlKey || [1, 2].includes(I.button))
        return;
      (O = window.getSelection()) == null || O.removeAllRanges(), b(I);
      const M = I.currentTarget;
      M && (o.value[f.value.axis] = M[f.value.offset] - (I[f.value.client] - M.getBoundingClientRect()[f.value.direction]));
    }, v = (I) => {
      if (!s.value || !i.value || !r.wrapElement)
        return;
      const O = Math.abs(I.target.getBoundingClientRect()[f.value.direction] - I[f.value.client]), M = s.value[f.value.offset] / 2, L = (O - M) * 100 * y.value / i.value[f.value.offset];
      r.wrapElement[f.value.scroll] = L * r.wrapElement[f.value.scrollSize] / 100;
    }, b = (I) => {
      I.stopImmediatePropagation(), l = !0, document.addEventListener("mousemove", w), document.addEventListener("mouseup", x), h = document.onselectstart, document.onselectstart = () => !1;
    }, w = (I) => {
      if (!i.value || !s.value || l === !1)
        return;
      const O = o.value[f.value.axis];
      if (!O)
        return;
      const M = (i.value.getBoundingClientRect()[f.value.direction] - I[f.value.client]) * -1, L = s.value[f.value.offset] - O, N = (M - L) * 100 * y.value / i.value[f.value.offset];
      r.wrapElement[f.value.scroll] = N * r.wrapElement[f.value.scrollSize] / 100;
    }, x = () => {
      l = !1, o.value[f.value.axis] = 0, document.removeEventListener("mousemove", w), document.removeEventListener("mouseup", x), C(), c && (a.value = !1);
    }, $ = () => {
      c = !1, a.value = !!t.size;
    }, T = () => {
      c = !0, a.value = l;
    };
    Ni(() => {
      C(), document.removeEventListener("mouseup", x);
    });
    const C = () => {
      document.onselectstart !== h && (document.onselectstart = h);
    };
    return rl(io(r, "scrollbarElement"), "mousemove", $), rl(io(r, "scrollbarElement"), "mouseleave", T), (I, O) => (R(), ue(po, {
      name: _(n).b("fade"),
      persisted: ""
    }, {
      default: Y(() => [
        Yt(K("div", {
          ref_key: "instance",
          ref: i,
          class: B([_(n).e("bar"), _(n).is(_(f).key)]),
          onMousedown: v
        }, [
          K("div", {
            ref_key: "thumb",
            ref: s,
            class: B(_(n).e("thumb")),
            style: $t(_(m)),
            onMousedown: g
          }, null, 38)
        ], 34), [
          [di, I.always || a.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var hN = /* @__PURE__ */ rt(YTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const QTe = ht({
  always: {
    type: Boolean,
    default: !0
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
}), XTe = /* @__PURE__ */ he({
  __name: "bar",
  props: QTe,
  setup(e, { expose: t }) {
    const r = e, n = q(0), i = q(0);
    return t({
      handleScroll: (o) => {
        if (o) {
          const a = o.offsetHeight - fh, l = o.offsetWidth - fh;
          i.value = o.scrollTop * 100 / a * r.ratioY, n.value = o.scrollLeft * 100 / l * r.ratioX;
        }
      }
    }), (o, a) => (R(), Z(Mt, null, [
      de(hN, {
        move: n.value,
        ratio: o.ratioX,
        size: o.width,
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      de(hN, {
        move: i.value,
        ratio: o.ratioY,
        size: o.height,
        vertical: "",
        always: o.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var eEe = /* @__PURE__ */ rt(XTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const tEe = ht({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Le([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
}), rEe = {
  scroll: ({
    scrollTop: e,
    scrollLeft: t
  }) => [e, t].every(ar)
}, i3 = "ElScrollbar", nEe = he({
  name: i3
}), iEe = /* @__PURE__ */ he({
  ...nEe,
  props: tEe,
  emits: rEe,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = Je("scrollbar");
    let s, o;
    const a = q(), l = q(), c = q(), h = q("0"), f = q("0"), m = q(), y = q(1), g = q(1), v = A(() => {
      const O = {};
      return n.height && (O.height = cl(n.height)), n.maxHeight && (O.maxHeight = cl(n.maxHeight)), [n.wrapStyle, O];
    }), b = A(() => [
      n.wrapClass,
      i.e("wrap"),
      { [i.em("wrap", "hidden-default")]: !n.native }
    ]), w = A(() => [i.e("view"), n.viewClass]), x = () => {
      var O;
      l.value && ((O = m.value) == null || O.handleScroll(l.value), r("scroll", {
        scrollTop: l.value.scrollTop,
        scrollLeft: l.value.scrollLeft
      }));
    };
    function $(O, M) {
      En(O) ? l.value.scrollTo(O) : ar(O) && ar(M) && l.value.scrollTo(O, M);
    }
    const T = (O) => {
      if (!ar(O)) {
        Ut(i3, "value must be a number");
        return;
      }
      l.value.scrollTop = O;
    }, C = (O) => {
      if (!ar(O)) {
        Ut(i3, "value must be a number");
        return;
      }
      l.value.scrollLeft = O;
    }, I = () => {
      if (!l.value)
        return;
      const O = l.value.offsetHeight - fh, M = l.value.offsetWidth - fh, L = O ** 2 / l.value.scrollHeight, N = M ** 2 / l.value.scrollWidth, ee = Math.max(L, n.minSize), D = Math.max(N, n.minSize);
      y.value = L / (O - L) / (ee / (O - ee)), g.value = N / (M - N) / (D / (M - D)), f.value = ee + fh < O ? `${ee}px` : "", h.value = D + fh < M ? `${D}px` : "";
    };
    return Se(() => n.noresize, (O) => {
      O ? (s == null || s(), o == null || o()) : ({ stop: s } = ip(c, I), o = rl("resize", I));
    }, { immediate: !0 }), Se(() => [n.maxHeight, n.height], () => {
      n.native || Ye(() => {
        var O;
        I(), l.value && ((O = m.value) == null || O.handleScroll(l.value));
      });
    }), cn(BB, ci({
      scrollbarElement: a,
      wrapElement: l
    })), qt(() => {
      n.native || Ye(() => {
        I();
      });
    }), p5(() => I()), t({
      wrapRef: l,
      update: I,
      scrollTo: $,
      setScrollTop: T,
      setScrollLeft: C,
      handleScroll: x
    }), (O, M) => (R(), Z("div", {
      ref_key: "scrollbarRef",
      ref: a,
      class: B(_(i).b())
    }, [
      K("div", {
        ref_key: "wrapRef",
        ref: l,
        class: B(_(b)),
        style: $t(_(v)),
        onScroll: x
      }, [
        (R(), ue(gr(O.tag), {
          id: O.id,
          ref_key: "resizeRef",
          ref: c,
          class: B(_(w)),
          style: $t(O.viewStyle),
          role: O.role,
          "aria-label": O.ariaLabel,
          "aria-orientation": O.ariaOrientation
        }, {
          default: Y(() => [
            ke(O.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      O.native ? le("v-if", !0) : (R(), ue(eEe, {
        key: 0,
        ref_key: "barRef",
        ref: m,
        height: f.value,
        width: h.value,
        always: O.always,
        "ratio-x": g.value,
        "ratio-y": y.value
      }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
    ], 2));
  }
});
var sEe = /* @__PURE__ */ rt(iEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const PC = fi(sEe), RC = Symbol("popper"), qB = Symbol("popperContent"), oEe = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], GB = ht({
  role: {
    type: String,
    values: oEe,
    default: "tooltip"
  }
}), aEe = he({
  name: "ElPopper",
  inheritAttrs: !1
}), lEe = /* @__PURE__ */ he({
  ...aEe,
  props: GB,
  setup(e, { expose: t }) {
    const r = e, n = q(), i = q(), s = q(), o = q(), a = A(() => r.role), l = {
      triggerRef: n,
      popperInstanceRef: i,
      contentRef: s,
      referenceRef: o,
      role: a
    };
    return t(l), cn(RC, l), (c, h) => ke(c.$slots, "default");
  }
});
var uEe = /* @__PURE__ */ rt(lEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const HB = ht({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), cEe = he({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), dEe = /* @__PURE__ */ he({
  ...cEe,
  props: HB,
  setup(e, { expose: t }) {
    const r = e, n = Je("popper"), { arrowOffset: i, arrowRef: s, arrowStyle: o } = ot(qB, void 0);
    return Se(() => r.arrowOffset, (a) => {
      i.value = a;
    }), Ni(() => {
      s.value = void 0;
    }), t({
      arrowRef: s
    }), (a, l) => (R(), Z("span", {
      ref_key: "arrowRef",
      ref: s,
      class: B(_(n).e("arrow")),
      style: $t(_(o)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var pEe = /* @__PURE__ */ rt(dEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const e$ = "ElOnlyChild", hEe = he({
  name: e$,
  setup(e, {
    slots: t,
    attrs: r
  }) {
    var n;
    const i = ot(PB), s = Rxe((n = i == null ? void 0 : i.setForwardRef) != null ? n : Xo);
    return () => {
      var o;
      const a = (o = t.default) == null ? void 0 : o.call(t, r);
      if (!a)
        return null;
      if (a.length > 1)
        return Ut(e$, "requires exact only one valid child."), null;
      const l = WB(a);
      return l ? Yt(mG(l, r), [[s]]) : (Ut(e$, "no valid child node found"), null);
    };
  }
});
function WB(e) {
  if (!e)
    return null;
  const t = e;
  for (const r of t) {
    if (En(r))
      switch (r.type) {
        case yG:
          continue;
        case f5:
        case "svg":
          return fN(r);
        case Mt:
          return WB(r.children);
        default:
          return r;
      }
    return fN(r);
  }
  return null;
}
function fN(e) {
  const t = Je("only-child");
  return de("span", {
    class: t.e("content")
  }, [e]);
}
const JB = ht({
  virtualRef: {
    type: Le(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Le(Function)
  },
  onMouseleave: {
    type: Le(Function)
  },
  onClick: {
    type: Le(Function)
  },
  onKeydown: {
    type: Le(Function)
  },
  onFocus: {
    type: Le(Function)
  },
  onBlur: {
    type: Le(Function)
  },
  onContextmenu: {
    type: Le(Function)
  },
  id: String,
  open: Boolean
}), fEe = he({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), mEe = /* @__PURE__ */ he({
  ...fEe,
  props: JB,
  setup(e, { expose: t }) {
    const r = e, { role: n, triggerRef: i } = ot(RC, void 0);
    Pxe(i);
    const s = A(() => a.value ? r.id : void 0), o = A(() => {
      if (n && n.value === "tooltip")
        return r.open && r.id ? r.id : void 0;
    }), a = A(() => {
      if (n && n.value !== "tooltip")
        return n.value;
    }), l = A(() => a.value ? `${r.open}` : void 0);
    let c;
    return qt(() => {
      Se(() => r.virtualRef, (h) => {
        h && (i.value = Ka(h));
      }, {
        immediate: !0
      }), Se(i, (h, f) => {
        c == null || c(), c = void 0, Fu(h) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((m) => {
          var y;
          const g = r[m];
          g && (h.addEventListener(m.slice(2).toLowerCase(), g), (y = f == null ? void 0 : f.removeEventListener) == null || y.call(f, m.slice(2).toLowerCase(), g));
        }), c = Se([s, o, a, l], (m) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((y, g) => {
            o0(m[g]) ? h.removeAttribute(y) : h.setAttribute(y, m[g]);
          });
        }, { immediate: !0 })), Fu(f) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((m) => f.removeAttribute(m));
      }, {
        immediate: !0
      });
    }), Ni(() => {
      c == null || c(), c = void 0;
    }), t({
      triggerRef: i
    }), (h, f) => h.virtualTriggering ? le("v-if", !0) : (R(), ue(_(hEe), Ko({ key: 0 }, h.$attrs, {
      "aria-controls": _(s),
      "aria-describedby": _(o),
      "aria-expanded": _(l),
      "aria-haspopup": _(a)
    }), {
      default: Y(() => [
        ke(h.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var yEe = /* @__PURE__ */ rt(mEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const t$ = "focus-trap.focus-after-trapped", r$ = "focus-trap.focus-after-released", gEe = "focus-trap.focusout-prevented", mN = {
  cancelable: !0,
  bubbles: !1
}, vEe = {
  cancelable: !0,
  bubbles: !1
}, yN = "focusAfterTrapped", gN = "focusAfterReleased", ZB = Symbol("elFocusTrap"), LC = q(), l2 = q(0), NC = q(0);
let xv = 0;
const KB = (e) => {
  const t = [], r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const i = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || i ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 || n === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode(); )
    t.push(r.currentNode);
  return t;
}, vN = (e, t) => {
  for (const r of e)
    if (!bEe(r, t))
      return r;
}, bEe = (e, t) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}, wEe = (e) => {
  const t = KB(e), r = vN(t, e), n = vN(t.reverse(), e);
  return [r, n];
}, _Ee = (e) => e instanceof HTMLInputElement && "select" in e, ou = (e, t) => {
  if (e && e.focus) {
    const r = document.activeElement;
    e.focus({ preventScroll: !0 }), NC.value = window.performance.now(), e !== r && _Ee(e) && t && e.select();
  }
};
function bN(e, t) {
  const r = [...e], n = e.indexOf(t);
  return n !== -1 && r.splice(n, 1), r;
}
const SEe = () => {
  let e = [];
  return {
    push: (n) => {
      const i = e[0];
      i && n !== i && i.pause(), e = bN(e, n), e.unshift(n);
    },
    remove: (n) => {
      var i, s;
      e = bN(e, n), (s = (i = e[0]) == null ? void 0 : i.resume) == null || s.call(i);
    }
  };
}, $Ee = (e, t = !1) => {
  const r = document.activeElement;
  for (const n of e)
    if (ou(n, t), document.activeElement !== r)
      return;
}, wN = SEe(), xEe = () => l2.value > NC.value, Tv = () => {
  LC.value = "pointer", l2.value = window.performance.now();
}, _N = () => {
  LC.value = "keyboard", l2.value = window.performance.now();
}, TEe = () => (qt(() => {
  xv === 0 && (document.addEventListener("mousedown", Tv), document.addEventListener("touchstart", Tv), document.addEventListener("keydown", _N)), xv++;
}), Ni(() => {
  xv--, xv <= 0 && (document.removeEventListener("mousedown", Tv), document.removeEventListener("touchstart", Tv), document.removeEventListener("keydown", _N));
}), {
  focusReason: LC,
  lastUserFocusTimestamp: l2,
  lastAutomatedFocusTimestamp: NC
}), Ev = (e) => new CustomEvent(gEe, {
  ...vEe,
  detail: e
}), EEe = he({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    yN,
    gN,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(e, { emit: t }) {
    const r = q();
    let n, i;
    const { focusReason: s } = TEe();
    Mxe((g) => {
      e.trapped && !o.paused && t("release-requested", g);
    });
    const o = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, a = (g) => {
      if (!e.loop && !e.trapped || o.paused)
        return;
      const { key: v, altKey: b, ctrlKey: w, metaKey: x, currentTarget: $, shiftKey: T } = g, { loop: C } = e, I = v === Xt.tab && !b && !w && !x, O = document.activeElement;
      if (I && O) {
        const M = $, [L, N] = wEe(M);
        if (L && N) {
          if (!T && O === N) {
            const D = Ev({
              focusReason: s.value
            });
            t("focusout-prevented", D), D.defaultPrevented || (g.preventDefault(), C && ou(L, !0));
          } else if (T && [L, M].includes(O)) {
            const D = Ev({
              focusReason: s.value
            });
            t("focusout-prevented", D), D.defaultPrevented || (g.preventDefault(), C && ou(N, !0));
          }
        } else if (O === M) {
          const D = Ev({
            focusReason: s.value
          });
          t("focusout-prevented", D), D.defaultPrevented || g.preventDefault();
        }
      }
    };
    cn(ZB, {
      focusTrapRef: r,
      onKeydown: a
    }), Se(() => e.focusTrapEl, (g) => {
      g && (r.value = g);
    }, { immediate: !0 }), Se([r], ([g], [v]) => {
      g && (g.addEventListener("keydown", a), g.addEventListener("focusin", h), g.addEventListener("focusout", f)), v && (v.removeEventListener("keydown", a), v.removeEventListener("focusin", h), v.removeEventListener("focusout", f));
    });
    const l = (g) => {
      t(yN, g);
    }, c = (g) => t(gN, g), h = (g) => {
      const v = _(r);
      if (!v)
        return;
      const b = g.target, w = g.relatedTarget, x = b && v.contains(b);
      e.trapped || w && v.contains(w) || (n = w), x && t("focusin", g), !o.paused && e.trapped && (x ? i = b : ou(i, !0));
    }, f = (g) => {
      const v = _(r);
      if (!(o.paused || !v))
        if (e.trapped) {
          const b = g.relatedTarget;
          !o0(b) && !v.contains(b) && setTimeout(() => {
            if (!o.paused && e.trapped) {
              const w = Ev({
                focusReason: s.value
              });
              t("focusout-prevented", w), w.defaultPrevented || ou(i, !0);
            }
          }, 0);
        } else {
          const b = g.target;
          b && v.contains(b) || t("focusout", g);
        }
    };
    async function m() {
      await Ye();
      const g = _(r);
      if (g) {
        wN.push(o);
        const v = g.contains(document.activeElement) ? n : document.activeElement;
        if (n = v, !g.contains(v)) {
          const w = new Event(t$, mN);
          g.addEventListener(t$, l), g.dispatchEvent(w), w.defaultPrevented || Ye(() => {
            let x = e.focusStartEl;
            nr(x) || (ou(x), document.activeElement !== x && (x = "first")), x === "first" && $Ee(KB(g), !0), (document.activeElement === v || x === "container") && ou(g);
          });
        }
      }
    }
    function y() {
      const g = _(r);
      if (g) {
        g.removeEventListener(t$, l);
        const v = new CustomEvent(r$, {
          ...mN,
          detail: {
            focusReason: s.value
          }
        });
        g.addEventListener(r$, c), g.dispatchEvent(v), !v.defaultPrevented && (s.value == "keyboard" || !xEe() || g.contains(document.activeElement)) && ou(n ?? document.body), g.removeEventListener(r$, c), wN.remove(o);
      }
    }
    return qt(() => {
      e.trapped && m(), Se(() => e.trapped, (g) => {
        g ? m() : y();
      });
    }), Ni(() => {
      e.trapped && y();
    }), {
      onKeydown: a
    };
  }
});
function IEe(e, t, r, n, i, s) {
  return ke(e.$slots, "default", { handleKeydown: e.onKeydown });
}
var YB = /* @__PURE__ */ rt(EEe, [["render", IEe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const MEe = ["fixed", "absolute"], OEe = ht({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Le(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: s2,
    default: "bottom"
  },
  popperOptions: {
    type: Le(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: MEe,
    default: "absolute"
  }
}), QB = ht({
  ...OEe,
  id: String,
  style: {
    type: Le([String, Array, Object])
  },
  className: {
    type: Le([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Le([String, Array, Object])
  },
  popperStyle: {
    type: Le([String, Array, Object])
  },
  referenceEl: {
    type: Le(Object)
  },
  triggerTargetEl: {
    type: Le(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), CEe = {
  mouseenter: (e) => e instanceof MouseEvent,
  mouseleave: (e) => e instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, kEe = (e, t = []) => {
  const { placement: r, strategy: n, popperOptions: i } = e, s = {
    placement: r,
    strategy: n,
    ...i,
    modifiers: [...PEe(e), ...t]
  };
  return REe(s, i == null ? void 0 : i.modifiers), s;
}, AEe = (e) => {
  if (Pt)
    return Ka(e);
};
function PEe(e) {
  const { offset: t, gpuAcceleration: r, fallbackPlacements: n } = e;
  return [
    {
      name: "offset",
      options: {
        offset: [0, t ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: n
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: r
      }
    }
  ];
}
function REe(e, t) {
  t && (e.modifiers = [...e.modifiers, ...t ?? []]);
}
const LEe = 0, NEe = (e) => {
  const { popperInstanceRef: t, contentRef: r, triggerRef: n, role: i } = ot(RC, void 0), s = q(), o = q(), a = A(() => ({
    name: "eventListeners",
    enabled: !!e.visible
  })), l = A(() => {
    var w;
    const x = _(s), $ = (w = _(o)) != null ? w : LEe;
    return {
      name: "arrow",
      enabled: !XU(x),
      options: {
        element: x,
        padding: $
      }
    };
  }), c = A(() => ({
    onFirstUpdate: () => {
      g();
    },
    ...kEe(e, [
      _(l),
      _(a)
    ])
  })), h = A(() => AEe(e.referenceEl) || _(n)), { attributes: f, state: m, styles: y, update: g, forceUpdate: v, instanceRef: b } = Txe(h, r, c);
  return Se(b, (w) => t.value = w), qt(() => {
    Se(() => {
      var w;
      return (w = _(h)) == null ? void 0 : w.getBoundingClientRect();
    }, () => {
      g();
    });
  }), {
    attributes: f,
    arrowRef: s,
    contentRef: r,
    instanceRef: b,
    state: m,
    styles: y,
    role: i,
    forceUpdate: v,
    update: g
  };
}, FEe = (e, {
  attributes: t,
  styles: r,
  role: n
}) => {
  const { nextZIndex: i } = kC(), s = Je("popper"), o = A(() => _(t).popper), a = q(ar(e.zIndex) ? e.zIndex : i()), l = A(() => [
    s.b(),
    s.is("pure", e.pure),
    s.is(e.effect),
    e.popperClass
  ]), c = A(() => [
    { zIndex: _(a) },
    _(r).popper,
    e.popperStyle || {}
  ]), h = A(() => n.value === "dialog" ? "false" : void 0), f = A(() => _(r).arrow || {});
  return {
    ariaModal: h,
    arrowStyle: f,
    contentAttrs: o,
    contentClass: l,
    contentStyle: c,
    contentZIndex: a,
    updateZIndex: () => {
      a.value = ar(e.zIndex) ? e.zIndex : i();
    }
  };
}, DEe = (e, t) => {
  const r = q(!1), n = q();
  return {
    focusStartRef: n,
    trapped: r,
    onFocusAfterReleased: (c) => {
      var h;
      ((h = c.detail) == null ? void 0 : h.focusReason) !== "pointer" && (n.value = "first", t("blur"));
    },
    onFocusAfterTrapped: () => {
      t("focus");
    },
    onFocusInTrap: (c) => {
      e.visible && !r.value && (c.target && (n.value = c.target), r.value = !0);
    },
    onFocusoutPrevented: (c) => {
      e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), r.value = !1);
    },
    onReleaseRequested: () => {
      r.value = !1, t("close");
    }
  };
}, jEe = he({
  name: "ElPopperContent"
}), VEe = /* @__PURE__ */ he({
  ...jEe,
  props: QB,
  emits: CEe,
  setup(e, { expose: t, emit: r }) {
    const n = e, {
      focusStartRef: i,
      trapped: s,
      onFocusAfterReleased: o,
      onFocusAfterTrapped: a,
      onFocusInTrap: l,
      onFocusoutPrevented: c,
      onReleaseRequested: h
    } = DEe(n, r), { attributes: f, arrowRef: m, contentRef: y, styles: g, instanceRef: v, role: b, update: w } = NEe(n), {
      ariaModal: x,
      arrowStyle: $,
      contentAttrs: T,
      contentClass: C,
      contentStyle: I,
      updateZIndex: O
    } = FEe(n, {
      styles: g,
      attributes: f,
      role: b
    }), M = ot(Gd, void 0), L = q();
    cn(qB, {
      arrowStyle: $,
      arrowRef: m,
      arrowOffset: L
    }), M && (M.addInputId || M.removeInputId) && cn(Gd, {
      ...M,
      addInputId: Xo,
      removeInputId: Xo
    });
    let N;
    const ee = (H = !0) => {
      w(), H && O();
    }, D = () => {
      ee(!1), n.visible && n.focusOnShow ? s.value = !0 : n.visible === !1 && (s.value = !1);
    };
    return qt(() => {
      Se(() => n.triggerTargetEl, (H, J) => {
        N == null || N(), N = void 0;
        const oe = _(H || y.value), ye = _(J || y.value);
        Fu(oe) && (N = Se([b, () => n.ariaLabel, x, () => n.id], (Q) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((ve, Ee) => {
            o0(Q[Ee]) ? oe.removeAttribute(ve) : oe.setAttribute(ve, Q[Ee]);
          });
        }, { immediate: !0 })), ye !== oe && Fu(ye) && ["role", "aria-label", "aria-modal", "id"].forEach((Q) => {
          ye.removeAttribute(Q);
        });
      }, { immediate: !0 }), Se(() => n.visible, D, { immediate: !0 });
    }), Ni(() => {
      N == null || N(), N = void 0;
    }), t({
      popperContentRef: y,
      popperInstanceRef: v,
      updatePopper: ee,
      contentStyle: I
    }), (H, J) => (R(), Z("div", Ko({
      ref_key: "contentRef",
      ref: y
    }, _(T), {
      style: _(I),
      class: _(C),
      tabindex: "-1",
      onMouseenter: J[0] || (J[0] = (oe) => H.$emit("mouseenter", oe)),
      onMouseleave: J[1] || (J[1] = (oe) => H.$emit("mouseleave", oe))
    }), [
      de(_(YB), {
        trapped: _(s),
        "trap-on-focus-in": !0,
        "focus-trap-el": _(y),
        "focus-start-el": _(i),
        onFocusAfterTrapped: _(a),
        onFocusAfterReleased: _(o),
        onFocusin: _(l),
        onFocusoutPrevented: _(c),
        onReleaseRequested: _(h)
      }, {
        default: Y(() => [
          ke(H.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var zEe = /* @__PURE__ */ rt(VEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const UEe = fi(uEe), FC = Symbol("elTooltip"), u2 = ht({
  ...kxe,
  ...QB,
  appendTo: {
    type: Le([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Le(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), XB = ht({
  ...JB,
  disabled: Boolean,
  trigger: {
    type: Le([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Le(Array),
    default: () => [Xt.enter, Xt.space]
  }
}), {
  useModelToggleProps: BEe,
  useModelToggleEmits: qEe,
  useModelToggle: GEe
} = wB("visible"), HEe = ht({
  ...GB,
  ...BEe,
  ...u2,
  ...XB,
  ...HB,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), WEe = [
  ...qEe,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], JEe = (e, t) => ul(e) ? e.includes(t) : e === t, _p = (e, t, r) => (n) => {
  JEe(_(e), t) && r(n);
}, ZEe = he({
  name: "ElTooltipTrigger"
}), KEe = /* @__PURE__ */ he({
  ...ZEe,
  props: XB,
  setup(e, { expose: t }) {
    const r = e, n = Je("tooltip"), { controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: c } = ot(FC, void 0), h = q(null), f = () => {
      if (_(i) || r.disabled)
        return !0;
    }, m = io(r, "trigger"), y = Ba(f, _p(m, "hover", a)), g = Ba(f, _p(m, "hover", l)), v = Ba(f, _p(m, "click", (T) => {
      T.button === 0 && c(T);
    })), b = Ba(f, _p(m, "focus", a)), w = Ba(f, _p(m, "focus", l)), x = Ba(f, _p(m, "contextmenu", (T) => {
      T.preventDefault(), c(T);
    })), $ = Ba(f, (T) => {
      const { code: C } = T;
      r.triggerKeys.includes(C) && (T.preventDefault(), c(T));
    });
    return t({
      triggerRef: h
    }), (T, C) => (R(), ue(_(yEe), {
      id: _(s),
      "virtual-ref": T.virtualRef,
      open: _(o),
      "virtual-triggering": T.virtualTriggering,
      class: B(_(n).e("trigger")),
      onBlur: _(w),
      onClick: _(v),
      onContextmenu: _(x),
      onFocus: _(b),
      onMouseenter: _(y),
      onMouseleave: _(g),
      onKeydown: _($)
    }, {
      default: Y(() => [
        ke(T.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var YEe = /* @__PURE__ */ rt(KEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const QEe = he({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), XEe = /* @__PURE__ */ he({
  ...QEe,
  props: u2,
  setup(e, { expose: t }) {
    const r = e, { selector: n } = AB(), i = Je("tooltip"), s = q(null), o = q(!1), {
      controlled: a,
      id: l,
      open: c,
      trigger: h,
      onClose: f,
      onOpen: m,
      onShow: y,
      onHide: g,
      onBeforeShow: v,
      onBeforeHide: b
    } = ot(FC, void 0), w = A(() => r.transition || `${i.namespace.value}-fade-in-linear`), x = A(() => process.env.NODE_ENV === "test" ? !0 : r.persistent);
    Ni(() => {
      o.value = !0;
    });
    const $ = A(() => _(x) ? !0 : _(c)), T = A(() => r.disabled ? !1 : _(c)), C = A(() => r.appendTo || n.value), I = A(() => {
      var Q;
      return (Q = r.style) != null ? Q : {};
    }), O = A(() => !_(c)), M = () => {
      g();
    }, L = () => {
      if (_(a))
        return !0;
    }, N = Ba(L, () => {
      r.enterable && _(h) === "hover" && m();
    }), ee = Ba(L, () => {
      _(h) === "hover" && f();
    }), D = () => {
      var Q, ve;
      (ve = (Q = s.value) == null ? void 0 : Q.updatePopper) == null || ve.call(Q), v == null || v();
    }, H = () => {
      b == null || b();
    }, J = () => {
      y(), ye = vve(A(() => {
        var Q;
        return (Q = s.value) == null ? void 0 : Q.popperContentRef;
      }), () => {
        if (_(a))
          return;
        _(h) !== "hover" && f();
      });
    }, oe = () => {
      r.virtualTriggering || f();
    };
    let ye;
    return Se(() => _(c), (Q) => {
      Q || ye == null || ye();
    }, {
      flush: "post"
    }), Se(() => r.content, () => {
      var Q, ve;
      (ve = (Q = s.value) == null ? void 0 : Q.updatePopper) == null || ve.call(Q);
    }), t({
      contentRef: s
    }), (Q, ve) => (R(), ue(m5, {
      disabled: !Q.teleported,
      to: _(C)
    }, [
      de(po, {
        name: _(w),
        onAfterLeave: M,
        onBeforeEnter: D,
        onAfterEnter: J,
        onBeforeLeave: H
      }, {
        default: Y(() => [
          _($) ? Yt((R(), ue(_(zEe), Ko({
            key: 0,
            id: _(l),
            ref_key: "contentRef",
            ref: s
          }, Q.$attrs, {
            "aria-label": Q.ariaLabel,
            "aria-hidden": _(O),
            "boundaries-padding": Q.boundariesPadding,
            "fallback-placements": Q.fallbackPlacements,
            "gpu-acceleration": Q.gpuAcceleration,
            offset: Q.offset,
            placement: Q.placement,
            "popper-options": Q.popperOptions,
            strategy: Q.strategy,
            effect: Q.effect,
            enterable: Q.enterable,
            pure: Q.pure,
            "popper-class": Q.popperClass,
            "popper-style": [Q.popperStyle, _(I)],
            "reference-el": Q.referenceEl,
            "trigger-target-el": Q.triggerTargetEl,
            visible: _(T),
            "z-index": Q.zIndex,
            onMouseenter: _(N),
            onMouseleave: _(ee),
            onBlur: oe,
            onClose: _(f)
          }), {
            default: Y(() => [
              o.value ? le("v-if", !0) : ke(Q.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [di, _(T)]
          ]) : le("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var eIe = /* @__PURE__ */ rt(XEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const tIe = ["innerHTML"], rIe = { key: 1 }, nIe = he({
  name: "ElTooltip"
}), iIe = /* @__PURE__ */ he({
  ...nIe,
  props: HEe,
  emits: WEe,
  setup(e, { expose: t, emit: r }) {
    const n = e;
    Cxe();
    const i = ju(), s = q(), o = q(), a = () => {
      var w;
      const x = _(s);
      x && ((w = x.popperInstanceRef) == null || w.update());
    }, l = q(!1), c = q(), { show: h, hide: f, hasUpdateHandler: m } = GEe({
      indicator: l,
      toggleReason: c
    }), { onOpen: y, onClose: g } = Axe({
      showAfter: io(n, "showAfter"),
      hideAfter: io(n, "hideAfter"),
      autoClose: io(n, "autoClose"),
      open: h,
      close: f
    }), v = A(() => Un(n.visible) && !m.value);
    cn(FC, {
      controlled: v,
      id: i,
      open: d5(l),
      trigger: io(n, "trigger"),
      onOpen: (w) => {
        y(w);
      },
      onClose: (w) => {
        g(w);
      },
      onToggle: (w) => {
        _(l) ? g(w) : y(w);
      },
      onShow: () => {
        r("show", c.value);
      },
      onHide: () => {
        r("hide", c.value);
      },
      onBeforeShow: () => {
        r("before-show", c.value);
      },
      onBeforeHide: () => {
        r("before-hide", c.value);
      },
      updatePopper: a
    }), Se(() => n.disabled, (w) => {
      w && l.value && (l.value = !1);
    });
    const b = (w) => {
      var x, $;
      const T = ($ = (x = o.value) == null ? void 0 : x.contentRef) == null ? void 0 : $.popperContentRef, C = (w == null ? void 0 : w.relatedTarget) || document.activeElement;
      return T && T.contains(C);
    };
    return gG(() => l.value && f()), t({
      popperRef: s,
      contentRef: o,
      isFocusInsideContent: b,
      updatePopper: a,
      onOpen: y,
      onClose: g,
      hide: f
    }), (w, x) => (R(), ue(_(UEe), {
      ref_key: "popperRef",
      ref: s,
      role: w.role
    }, {
      default: Y(() => [
        de(YEe, {
          disabled: w.disabled,
          trigger: w.trigger,
          "trigger-keys": w.triggerKeys,
          "virtual-ref": w.virtualRef,
          "virtual-triggering": w.virtualTriggering
        }, {
          default: Y(() => [
            w.$slots.default ? ke(w.$slots, "default", { key: 0 }) : le("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        de(eIe, {
          ref_key: "contentRef",
          ref: o,
          "aria-label": w.ariaLabel,
          "boundaries-padding": w.boundariesPadding,
          content: w.content,
          disabled: w.disabled,
          effect: w.effect,
          enterable: w.enterable,
          "fallback-placements": w.fallbackPlacements,
          "hide-after": w.hideAfter,
          "gpu-acceleration": w.gpuAcceleration,
          offset: w.offset,
          persistent: w.persistent,
          "popper-class": w.popperClass,
          "popper-style": w.popperStyle,
          placement: w.placement,
          "popper-options": w.popperOptions,
          pure: w.pure,
          "raw-content": w.rawContent,
          "reference-el": w.referenceEl,
          "trigger-target-el": w.triggerTargetEl,
          "show-after": w.showAfter,
          strategy: w.strategy,
          teleported: w.teleported,
          transition: w.transition,
          "virtual-triggering": w.virtualTriggering,
          "z-index": w.zIndex,
          "append-to": w.appendTo
        }, {
          default: Y(() => [
            ke(w.$slots, "content", {}, () => [
              w.rawContent ? (R(), Z("span", {
                key: 0,
                innerHTML: w.content
              }, null, 8, tIe)) : (R(), Z("span", rIe, Xe(w.content), 1))
            ]),
            w.showArrow ? (R(), ue(_(pEe), {
              key: 0,
              "arrow-offset": w.arrowOffset
            }, null, 8, ["arrow-offset"])) : le("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var sIe = /* @__PURE__ */ rt(iIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const s3 = fi(sIe), oIe = ht({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
}), aIe = ["textContent"], lIe = he({
  name: "ElBadge"
}), uIe = /* @__PURE__ */ he({
  ...lIe,
  props: oIe,
  setup(e, { expose: t }) {
    const r = e, n = Je("badge"), i = A(() => r.isDot ? "" : ar(r.value) && ar(r.max) ? r.max < r.value ? `${r.max}+` : `${r.value}` : `${r.value}`);
    return t({
      content: i
    }), (s, o) => (R(), Z("div", {
      class: B(_(n).b())
    }, [
      ke(s.$slots, "default"),
      de(po, {
        name: `${_(n).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: Y(() => [
          Yt(K("sup", {
            class: B([
              _(n).e("content"),
              _(n).em("content", s.type),
              _(n).is("fixed", !!s.$slots.default),
              _(n).is("dot", s.isDot)
            ]),
            textContent: Xe(_(i))
          }, null, 10, aIe), [
            [di, !s.hidden && (_(i) || s.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var cIe = /* @__PURE__ */ rt(uIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const dIe = fi(cIe), eq = Symbol("buttonGroupContextKey"), pIe = (e, t) => {
  Sg({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, A(() => e.type === "text"));
  const r = ot(eq, void 0), n = a2("button"), { form: i } = gl(), s = go(A(() => r == null ? void 0 : r.size)), o = If(), a = q(), l = ef(), c = A(() => e.type || (r == null ? void 0 : r.type) || ""), h = A(() => {
    var g, v, b;
    return (b = (v = e.autoInsertSpace) != null ? v : (g = n.value) == null ? void 0 : g.autoInsertSpace) != null ? b : !1;
  }), f = A(() => e.tag === "button" ? {
    ariaDisabled: o.value || e.loading,
    disabled: o.value || e.loading,
    autofocus: e.autofocus,
    type: e.nativeType
  } : {}), m = A(() => {
    var g;
    const v = (g = l.default) == null ? void 0 : g.call(l);
    if (h.value && (v == null ? void 0 : v.length) === 1) {
      const b = v[0];
      if ((b == null ? void 0 : b.type) === f5) {
        const w = b.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(w.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: o,
    _size: s,
    _type: c,
    _ref: a,
    _props: f,
    shouldAddSpace: m,
    handleClick: (g) => {
      e.nativeType === "reset" && (i == null || i.resetFields()), t("click", g);
    }
  };
}, hIe = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], fIe = ["button", "submit", "reset"], o3 = ht({
  size: Qu,
  disabled: Boolean,
  type: {
    type: String,
    values: hIe,
    default: ""
  },
  icon: {
    type: Oi
  },
  nativeType: {
    type: String,
    values: fIe,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Oi,
    default: () => a0
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Le([String, Object]),
    default: "button"
  }
}), mIe = {
  click: (e) => e instanceof MouseEvent
};
function un(e, t) {
  yIe(e) && (e = "100%");
  var r = gIe(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), r && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function Iv(e) {
  return Math.min(1, Math.max(0, e));
}
function yIe(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function gIe(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function tq(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function Mv(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function pd(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function vIe(e, t, r) {
  return {
    r: un(e, 255) * 255,
    g: un(t, 255) * 255,
    b: un(r, 255) * 255
  };
}
function SN(e, t, r) {
  e = un(e, 255), t = un(t, 255), r = un(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), s = 0, o = 0, a = (n + i) / 2;
  if (n === i)
    o = 0, s = 0;
  else {
    var l = n - i;
    switch (o = a > 0.5 ? l / (2 - n - i) : l / (n + i), n) {
      case e:
        s = (t - r) / l + (t < r ? 6 : 0);
        break;
      case t:
        s = (r - e) / l + 2;
        break;
      case r:
        s = (e - t) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function n$(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * (6 * r) : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function bIe(e, t, r) {
  var n, i, s;
  if (e = un(e, 360), t = un(t, 100), r = un(r, 100), t === 0)
    i = r, s = r, n = r;
  else {
    var o = r < 0.5 ? r * (1 + t) : r + t - r * t, a = 2 * r - o;
    n = n$(a, o, e + 1 / 3), i = n$(a, o, e), s = n$(a, o, e - 1 / 3);
  }
  return { r: n * 255, g: i * 255, b: s * 255 };
}
function $N(e, t, r) {
  e = un(e, 255), t = un(t, 255), r = un(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), s = 0, o = n, a = n - i, l = n === 0 ? 0 : a / n;
  if (n === i)
    s = 0;
  else {
    switch (n) {
      case e:
        s = (t - r) / a + (t < r ? 6 : 0);
        break;
      case t:
        s = (r - e) / a + 2;
        break;
      case r:
        s = (e - t) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function wIe(e, t, r) {
  e = un(e, 360) * 6, t = un(t, 100), r = un(r, 100);
  var n = Math.floor(e), i = e - n, s = r * (1 - t), o = r * (1 - i * t), a = r * (1 - (1 - i) * t), l = n % 6, c = [r, o, s, s, a, r][l], h = [a, r, r, o, s, s][l], f = [s, s, a, r, r, o][l];
  return { r: c * 255, g: h * 255, b: f * 255 };
}
function xN(e, t, r, n) {
  var i = [
    pd(Math.round(e).toString(16)),
    pd(Math.round(t).toString(16)),
    pd(Math.round(r).toString(16))
  ];
  return n && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function _Ie(e, t, r, n, i) {
  var s = [
    pd(Math.round(e).toString(16)),
    pd(Math.round(t).toString(16)),
    pd(Math.round(r).toString(16)),
    pd(SIe(n))
  ];
  return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function SIe(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function TN(e) {
  return Si(e) / 255;
}
function Si(e) {
  return parseInt(e, 16);
}
function $Ie(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var a3 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function xIe(e) {
  var t = { r: 0, g: 0, b: 0 }, r = 1, n = null, i = null, s = null, o = !1, a = !1;
  return typeof e == "string" && (e = IIe(e)), typeof e == "object" && (wa(e.r) && wa(e.g) && wa(e.b) ? (t = vIe(e.r, e.g, e.b), o = !0, a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : wa(e.h) && wa(e.s) && wa(e.v) ? (n = Mv(e.s), i = Mv(e.v), t = wIe(e.h, n, i), o = !0, a = "hsv") : wa(e.h) && wa(e.s) && wa(e.l) && (n = Mv(e.s), s = Mv(e.l), t = bIe(e.h, n, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (r = e.a)), r = tq(r), {
    ok: o,
    format: e.format || a,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: r
  };
}
var TIe = "[-\\+]?\\d+%?", EIe = "[-\\+]?\\d*\\.\\d+%?", Tu = "(?:".concat(EIe, ")|(?:").concat(TIe, ")"), i$ = "[\\s|\\(]+(".concat(Tu, ")[,|\\s]+(").concat(Tu, ")[,|\\s]+(").concat(Tu, ")\\s*\\)?"), s$ = "[\\s|\\(]+(".concat(Tu, ")[,|\\s]+(").concat(Tu, ")[,|\\s]+(").concat(Tu, ")[,|\\s]+(").concat(Tu, ")\\s*\\)?"), Qs = {
  CSS_UNIT: new RegExp(Tu),
  rgb: new RegExp("rgb" + i$),
  rgba: new RegExp("rgba" + s$),
  hsl: new RegExp("hsl" + i$),
  hsla: new RegExp("hsla" + s$),
  hsv: new RegExp("hsv" + i$),
  hsva: new RegExp("hsva" + s$),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function IIe(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (a3[e])
    e = a3[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var r = Qs.rgb.exec(e);
  return r ? { r: r[1], g: r[2], b: r[3] } : (r = Qs.rgba.exec(e), r ? { r: r[1], g: r[2], b: r[3], a: r[4] } : (r = Qs.hsl.exec(e), r ? { h: r[1], s: r[2], l: r[3] } : (r = Qs.hsla.exec(e), r ? { h: r[1], s: r[2], l: r[3], a: r[4] } : (r = Qs.hsv.exec(e), r ? { h: r[1], s: r[2], v: r[3] } : (r = Qs.hsva.exec(e), r ? { h: r[1], s: r[2], v: r[3], a: r[4] } : (r = Qs.hex8.exec(e), r ? {
    r: Si(r[1]),
    g: Si(r[2]),
    b: Si(r[3]),
    a: TN(r[4]),
    format: t ? "name" : "hex8"
  } : (r = Qs.hex6.exec(e), r ? {
    r: Si(r[1]),
    g: Si(r[2]),
    b: Si(r[3]),
    format: t ? "name" : "hex"
  } : (r = Qs.hex4.exec(e), r ? {
    r: Si(r[1] + r[1]),
    g: Si(r[2] + r[2]),
    b: Si(r[3] + r[3]),
    a: TN(r[4] + r[4]),
    format: t ? "name" : "hex8"
  } : (r = Qs.hex3.exec(e), r ? {
    r: Si(r[1] + r[1]),
    g: Si(r[2] + r[2]),
    b: Si(r[3] + r[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function wa(e) {
  return !!Qs.CSS_UNIT.exec(String(e));
}
var MIe = (
  /** @class */
  function() {
    function e(t, r) {
      t === void 0 && (t = ""), r === void 0 && (r = {});
      var n;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = $Ie(t)), this.originalInput = t;
      var i = xIe(t);
      this.originalInput = t, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (n = r.format) !== null && n !== void 0 ? n : i.format, this.gradientType = r.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), r, n, i, s = t.r / 255, o = t.g / 255, a = t.b / 255;
      return s <= 0.03928 ? r = s / 12.92 : r = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? n = o / 12.92 : n = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * r + 0.7152 * n + 0.0722 * i;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = tq(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = $N(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = $N(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsva(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = SN(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = SN(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsla(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), xN(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), _Ie(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), r = Math.round(this.g), n = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(r, ", ").concat(n, ")") : "rgba(".concat(t, ", ").concat(r, ", ").concat(n, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(r) {
        return "".concat(Math.round(un(r, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(r) {
        return Math.round(un(r, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + xN(this.r, this.g, this.b, !1), r = 0, n = Object.entries(a3); r < n.length; r++) {
        var i = n[r], s = i[0], o = i[1];
        if (t === o)
          return s;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var r = !!t;
      t = t ?? this.format;
      var n = !1, i = this.a < 1 && this.a >= 0, s = !r && i && (t.startsWith("hex") || t === "name");
      return s ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (n = this.toRgbString()), t === "prgb" && (n = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (n = this.toHexString()), t === "hex3" && (n = this.toHexString(!0)), t === "hex4" && (n = this.toHex8String(!0)), t === "hex8" && (n = this.toHex8String()), t === "name" && (n = this.toName()), t === "hsl" && (n = this.toHslString()), t === "hsv" && (n = this.toHsvString()), n || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l += t / 100, r.l = Iv(r.l), new e(r);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toRgb();
      return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(t / 100)))), r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(t / 100)))), r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(t / 100)))), new e(r);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l -= t / 100, r.l = Iv(r.l), new e(r);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s -= t / 100, r.s = Iv(r.s), new e(r);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s += t / 100, r.s = Iv(r.s), new e(r);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var r = this.toHsl(), n = (r.h + t) % 360;
      return r.h = n < 0 ? 360 + n : n, new e(r);
    }, e.prototype.mix = function(t, r) {
      r === void 0 && (r = 50);
      var n = this.toRgb(), i = new e(t).toRgb(), s = r / 100, o = {
        r: (i.r - n.r) * s + n.r,
        g: (i.g - n.g) * s + n.g,
        b: (i.b - n.b) * s + n.b,
        a: (i.a - n.a) * s + n.a
      };
      return new e(o);
    }, e.prototype.analogous = function(t, r) {
      t === void 0 && (t = 6), r === void 0 && (r = 30);
      var n = this.toHsl(), i = 360 / r, s = [this];
      for (n.h = (n.h - (i * t >> 1) + 720) % 360; --t; )
        n.h = (n.h + i) % 360, s.push(new e(n));
      return s;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var r = this.toHsv(), n = r.h, i = r.s, s = r.v, o = [], a = 1 / t; t--; )
        o.push(new e({ h: n, s: i, v: s })), s = (s + a) % 1;
      return o;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), r = t.h;
      return [
        this,
        new e({ h: (r + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (r + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var r = this.toRgb(), n = new e(t).toRgb(), i = r.a + n.a * (1 - r.a);
      return new e({
        r: (r.r * r.a + n.r * n.a * (1 - r.a)) / i,
        g: (r.g * r.a + n.g * n.a * (1 - r.a)) / i,
        b: (r.b * r.a + n.b * n.a * (1 - r.a)) / i,
        a: i
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var r = this.toHsl(), n = r.h, i = [this], s = 360 / t, o = 1; o < t; o++)
        i.push(new e({ h: (n + o * s) % 360, s: r.s, l: r.l }));
      return i;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
);
function Ll(e, t = 20) {
  return e.mix("#141414", t).toString();
}
function OIe(e) {
  const t = If(), r = Je("button");
  return A(() => {
    let n = {};
    const i = e.color;
    if (i) {
      const s = new MIe(i), o = e.dark ? s.tint(20).toString() : Ll(s, 20);
      if (e.plain)
        n = r.cssVarBlock({
          "bg-color": e.dark ? Ll(s, 90) : s.tint(90).toString(),
          "text-color": i,
          "border-color": e.dark ? Ll(s, 50) : s.tint(50).toString(),
          "hover-text-color": `var(${r.cssVarName("color-white")})`,
          "hover-bg-color": i,
          "hover-border-color": i,
          "active-bg-color": o,
          "active-text-color": `var(${r.cssVarName("color-white")})`,
          "active-border-color": o
        }), t.value && (n[r.cssVarBlockName("disabled-bg-color")] = e.dark ? Ll(s, 90) : s.tint(90).toString(), n[r.cssVarBlockName("disabled-text-color")] = e.dark ? Ll(s, 50) : s.tint(50).toString(), n[r.cssVarBlockName("disabled-border-color")] = e.dark ? Ll(s, 80) : s.tint(80).toString());
      else {
        const a = e.dark ? Ll(s, 30) : s.tint(30).toString(), l = s.isDark() ? `var(${r.cssVarName("color-white")})` : `var(${r.cssVarName("color-black")})`;
        if (n = r.cssVarBlock({
          "bg-color": i,
          "text-color": l,
          "border-color": i,
          "hover-bg-color": a,
          "hover-text-color": l,
          "hover-border-color": a,
          "active-bg-color": o,
          "active-border-color": o
        }), t.value) {
          const c = e.dark ? Ll(s, 50) : s.tint(50).toString();
          n[r.cssVarBlockName("disabled-bg-color")] = c, n[r.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${r.cssVarName("color-white")})`, n[r.cssVarBlockName("disabled-border-color")] = c;
        }
      }
    }
    return n;
  });
}
const CIe = he({
  name: "ElButton"
}), kIe = /* @__PURE__ */ he({
  ...CIe,
  props: o3,
  emits: mIe,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = OIe(n), s = Je("button"), { _ref: o, _size: a, _type: l, _disabled: c, _props: h, shouldAddSpace: f, handleClick: m } = pIe(n, r);
    return t({
      ref: o,
      size: a,
      type: l,
      disabled: c,
      shouldAddSpace: f
    }), (y, g) => (R(), ue(gr(y.tag), Ko({
      ref_key: "_ref",
      ref: o
    }, _(h), {
      class: [
        _(s).b(),
        _(s).m(_(l)),
        _(s).m(_(a)),
        _(s).is("disabled", _(c)),
        _(s).is("loading", y.loading),
        _(s).is("plain", y.plain),
        _(s).is("round", y.round),
        _(s).is("circle", y.circle),
        _(s).is("text", y.text),
        _(s).is("link", y.link),
        _(s).is("has-bg", y.bg)
      ],
      style: _(i),
      onClick: _(m)
    }), {
      default: Y(() => [
        y.loading ? (R(), Z(Mt, { key: 0 }, [
          y.$slots.loading ? ke(y.$slots, "loading", { key: 0 }) : (R(), ue(_(zt), {
            key: 1,
            class: B(_(s).is("loading"))
          }, {
            default: Y(() => [
              (R(), ue(gr(y.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : y.icon || y.$slots.icon ? (R(), ue(_(zt), { key: 1 }, {
          default: Y(() => [
            y.icon ? (R(), ue(gr(y.icon), { key: 0 })) : ke(y.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : le("v-if", !0),
        y.$slots.default ? (R(), Z("span", {
          key: 2,
          class: B({ [_(s).em("text", "expand")]: _(f) })
        }, [
          ke(y.$slots, "default")
        ], 2)) : le("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var AIe = /* @__PURE__ */ rt(kIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const PIe = {
  size: o3.size,
  type: o3.type
}, RIe = he({
  name: "ElButtonGroup"
}), LIe = /* @__PURE__ */ he({
  ...RIe,
  props: PIe,
  setup(e) {
    const t = e;
    cn(eq, ci({
      size: io(t, "size"),
      type: io(t, "type")
    }));
    const r = Je("button");
    return (n, i) => (R(), Z("div", {
      class: B(`${_(r).b("group")}`)
    }, [
      ke(n.$slots, "default")
    ], 2));
  }
});
var rq = /* @__PURE__ */ rt(LIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const o$ = fi(AIe, {
  ButtonGroup: rq
});
Ku(rq);
const au = /* @__PURE__ */ new Map();
let EN;
Pt && (document.addEventListener("mousedown", (e) => EN = e), document.addEventListener("mouseup", (e) => {
  for (const t of au.values())
    for (const { documentHandler: r } of t)
      r(e, EN);
}));
function IN(e, t) {
  let r = [];
  return Array.isArray(t.arg) ? r = t.arg : Fu(t.arg) && r.push(t.arg), function(n, i) {
    const s = t.instance.popperRef, o = n.target, a = i == null ? void 0 : i.target, l = !t || !t.instance, c = !o || !a, h = e.contains(o) || e.contains(a), f = e === o, m = r.length && r.some((g) => g == null ? void 0 : g.contains(o)) || r.length && r.includes(a), y = s && (s.contains(o) || s.contains(a));
    l || c || h || f || m || y || t.value(n, i);
  };
}
const nq = {
  beforeMount(e, t) {
    au.has(e) || au.set(e, []), au.get(e).push({
      documentHandler: IN(e, t),
      bindingFn: t.value
    });
  },
  updated(e, t) {
    au.has(e) || au.set(e, []);
    const r = au.get(e), n = r.findIndex((s) => s.bindingFn === t.oldValue), i = {
      documentHandler: IN(e, t),
      bindingFn: t.value
    };
    n >= 0 ? r.splice(n, 1, i) : r.push(i);
  },
  unmounted(e) {
    au.delete(e);
  }
}, iq = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Qu,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, sq = {
  [At]: (e) => nr(e) || ar(e) || Un(e),
  change: (e) => nr(e) || ar(e) || Un(e)
}, Mf = Symbol("checkboxGroupContextKey"), NIe = ({
  model: e,
  isChecked: t
}) => {
  const r = ot(Mf, void 0), n = A(() => {
    var s, o;
    const a = (s = r == null ? void 0 : r.max) == null ? void 0 : s.value, l = (o = r == null ? void 0 : r.min) == null ? void 0 : o.value;
    return !Hh(a) && e.value.length >= a && !t.value || !Hh(l) && e.value.length <= l && t.value;
  });
  return {
    isDisabled: If(A(() => (r == null ? void 0 : r.disabled.value) || n.value)),
    isLimitDisabled: n
  };
}, FIe = (e, {
  model: t,
  isLimitExceeded: r,
  hasOwnLabel: n,
  isDisabled: i,
  isLabeledByFormItem: s
}) => {
  const o = ot(Mf, void 0), { formItem: a } = gl(), { emit: l } = nn();
  function c(g) {
    var v, b;
    return g === e.trueLabel || g === !0 ? (v = e.trueLabel) != null ? v : !0 : (b = e.falseLabel) != null ? b : !1;
  }
  function h(g, v) {
    l("change", c(g), v);
  }
  function f(g) {
    if (r.value)
      return;
    const v = g.target;
    l("change", c(v.checked), g);
  }
  async function m(g) {
    r.value || !n.value && !i.value && s.value && (g.composedPath().some((w) => w.tagName === "LABEL") || (t.value = c([!1, e.falseLabel].includes(t.value)), await Ye(), h(t.value, g)));
  }
  const y = A(() => (o == null ? void 0 : o.validateEvent) || e.validateEvent);
  return Se(() => e.modelValue, () => {
    y.value && (a == null || a.validate("change").catch((g) => Ut(g)));
  }), {
    handleChange: f,
    onClickRoot: m
  };
}, DIe = (e) => {
  const t = q(!1), { emit: r } = nn(), n = ot(Mf, void 0), i = A(() => Hh(n) === !1), s = q(!1);
  return {
    model: A({
      get() {
        var a, l;
        return i.value ? (a = n == null ? void 0 : n.modelValue) == null ? void 0 : a.value : (l = e.modelValue) != null ? l : t.value;
      },
      set(a) {
        var l, c;
        i.value && ul(a) ? (s.value = ((l = n == null ? void 0 : n.max) == null ? void 0 : l.value) !== void 0 && a.length > (n == null ? void 0 : n.max.value), s.value === !1 && ((c = n == null ? void 0 : n.changeEvent) == null || c.call(n, a))) : (r(At, a), t.value = a);
      }
    }),
    isGroup: i,
    isLimitExceeded: s
  };
}, jIe = (e, t, { model: r }) => {
  const n = ot(Mf, void 0), i = q(!1), s = A(() => {
    const c = r.value;
    return Un(c) ? c : ul(c) ? En(e.label) ? c.map(Oh).some((h) => Cu(h, e.label)) : c.map(Oh).includes(e.label) : c != null ? c === e.trueLabel : !!c;
  }), o = go(A(() => {
    var c;
    return (c = n == null ? void 0 : n.size) == null ? void 0 : c.value;
  }), {
    prop: !0
  }), a = go(A(() => {
    var c;
    return (c = n == null ? void 0 : n.size) == null ? void 0 : c.value;
  })), l = A(() => !!t.default || !o0(e.label));
  return {
    checkboxButtonSize: o,
    isChecked: s,
    isFocused: i,
    checkboxSize: a,
    hasOwnLabel: l
  };
}, VIe = (e, { model: t }) => {
  function r() {
    ul(t.value) && !t.value.includes(e.label) ? t.value.push(e.label) : t.value = e.trueLabel || !0;
  }
  e.checked && r();
}, oq = (e, t) => {
  const { formItem: r } = gl(), { model: n, isGroup: i, isLimitExceeded: s } = DIe(e), {
    isFocused: o,
    isChecked: a,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: h
  } = jIe(e, t, { model: n }), { isDisabled: f } = NIe({ model: n, isChecked: a }), { inputId: m, isLabeledByFormItem: y } = d0(e, {
    formItemContext: r,
    disableIdGeneration: h,
    disableIdManagement: i
  }), { handleChange: g, onClickRoot: v } = FIe(e, {
    model: n,
    isLimitExceeded: s,
    hasOwnLabel: h,
    isDisabled: f,
    isLabeledByFormItem: y
  });
  return VIe(e, { model: n }), {
    inputId: m,
    isLabeledByFormItem: y,
    isChecked: a,
    isDisabled: f,
    isFocused: o,
    checkboxButtonSize: l,
    checkboxSize: c,
    hasOwnLabel: h,
    model: n,
    handleChange: g,
    onClickRoot: v
  };
}, zIe = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], UIe = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], BIe = he({
  name: "ElCheckbox"
}), qIe = /* @__PURE__ */ he({
  ...BIe,
  props: iq,
  emits: sq,
  setup(e) {
    const t = e, r = ef(), {
      inputId: n,
      isLabeledByFormItem: i,
      isChecked: s,
      isDisabled: o,
      isFocused: a,
      checkboxSize: l,
      hasOwnLabel: c,
      model: h,
      handleChange: f,
      onClickRoot: m
    } = oq(t, r), y = Je("checkbox"), g = A(() => [
      y.b(),
      y.m(l.value),
      y.is("disabled", o.value),
      y.is("bordered", t.border),
      y.is("checked", s.value)
    ]), v = A(() => [
      y.e("input"),
      y.is("disabled", o.value),
      y.is("checked", s.value),
      y.is("indeterminate", t.indeterminate),
      y.is("focus", a.value)
    ]);
    return (b, w) => (R(), ue(gr(!_(c) && _(i) ? "span" : "label"), {
      class: B(_(g)),
      "aria-controls": b.indeterminate ? b.controls : null,
      onClick: _(m)
    }, {
      default: Y(() => [
        K("span", {
          class: B(_(v))
        }, [
          b.trueLabel || b.falseLabel ? Yt((R(), Z("input", {
            key: 0,
            id: _(n),
            "onUpdate:modelValue": w[0] || (w[0] = (x) => ra(h) ? h.value = x : null),
            class: B(_(y).e("original")),
            type: "checkbox",
            indeterminate: b.indeterminate,
            name: b.name,
            tabindex: b.tabindex,
            disabled: _(o),
            "true-value": b.trueLabel,
            "false-value": b.falseLabel,
            onChange: w[1] || (w[1] = (...x) => _(f) && _(f)(...x)),
            onFocus: w[2] || (w[2] = (x) => a.value = !0),
            onBlur: w[3] || (w[3] = (x) => a.value = !1),
            onClick: w[4] || (w[4] = kt(() => {
            }, ["stop"]))
          }, null, 42, zIe)), [
            [nb, _(h)]
          ]) : Yt((R(), Z("input", {
            key: 1,
            id: _(n),
            "onUpdate:modelValue": w[5] || (w[5] = (x) => ra(h) ? h.value = x : null),
            class: B(_(y).e("original")),
            type: "checkbox",
            indeterminate: b.indeterminate,
            disabled: _(o),
            value: b.label,
            name: b.name,
            tabindex: b.tabindex,
            onChange: w[6] || (w[6] = (...x) => _(f) && _(f)(...x)),
            onFocus: w[7] || (w[7] = (x) => a.value = !0),
            onBlur: w[8] || (w[8] = (x) => a.value = !1),
            onClick: w[9] || (w[9] = kt(() => {
            }, ["stop"]))
          }, null, 42, UIe)), [
            [nb, _(h)]
          ]),
          K("span", {
            class: B(_(y).e("inner"))
          }, null, 2)
        ], 2),
        _(c) ? (R(), Z("span", {
          key: 0,
          class: B(_(y).e("label"))
        }, [
          ke(b.$slots, "default"),
          b.$slots.default ? le("v-if", !0) : (R(), Z(Mt, { key: 0 }, [
            jr(Xe(b.label), 1)
          ], 64))
        ], 2)) : le("v-if", !0)
      ]),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var GIe = /* @__PURE__ */ rt(qIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const HIe = ["name", "tabindex", "disabled", "true-value", "false-value"], WIe = ["name", "tabindex", "disabled", "value"], JIe = he({
  name: "ElCheckboxButton"
}), ZIe = /* @__PURE__ */ he({
  ...JIe,
  props: iq,
  emits: sq,
  setup(e) {
    const t = e, r = ef(), {
      isFocused: n,
      isChecked: i,
      isDisabled: s,
      checkboxButtonSize: o,
      model: a,
      handleChange: l
    } = oq(t, r), c = ot(Mf, void 0), h = Je("checkbox"), f = A(() => {
      var y, g, v, b;
      const w = (g = (y = c == null ? void 0 : c.fill) == null ? void 0 : y.value) != null ? g : "";
      return {
        backgroundColor: w,
        borderColor: w,
        color: (b = (v = c == null ? void 0 : c.textColor) == null ? void 0 : v.value) != null ? b : "",
        boxShadow: w ? `-1px 0 0 0 ${w}` : void 0
      };
    }), m = A(() => [
      h.b("button"),
      h.bm("button", o.value),
      h.is("disabled", s.value),
      h.is("checked", i.value),
      h.is("focus", n.value)
    ]);
    return (y, g) => (R(), Z("label", {
      class: B(_(m))
    }, [
      y.trueLabel || y.falseLabel ? Yt((R(), Z("input", {
        key: 0,
        "onUpdate:modelValue": g[0] || (g[0] = (v) => ra(a) ? a.value = v : null),
        class: B(_(h).be("button", "original")),
        type: "checkbox",
        name: y.name,
        tabindex: y.tabindex,
        disabled: _(s),
        "true-value": y.trueLabel,
        "false-value": y.falseLabel,
        onChange: g[1] || (g[1] = (...v) => _(l) && _(l)(...v)),
        onFocus: g[2] || (g[2] = (v) => n.value = !0),
        onBlur: g[3] || (g[3] = (v) => n.value = !1),
        onClick: g[4] || (g[4] = kt(() => {
        }, ["stop"]))
      }, null, 42, HIe)), [
        [nb, _(a)]
      ]) : Yt((R(), Z("input", {
        key: 1,
        "onUpdate:modelValue": g[5] || (g[5] = (v) => ra(a) ? a.value = v : null),
        class: B(_(h).be("button", "original")),
        type: "checkbox",
        name: y.name,
        tabindex: y.tabindex,
        disabled: _(s),
        value: y.label,
        onChange: g[6] || (g[6] = (...v) => _(l) && _(l)(...v)),
        onFocus: g[7] || (g[7] = (v) => n.value = !0),
        onBlur: g[8] || (g[8] = (v) => n.value = !1),
        onClick: g[9] || (g[9] = kt(() => {
        }, ["stop"]))
      }, null, 42, WIe)), [
        [nb, _(a)]
      ]),
      y.$slots.default || y.label ? (R(), Z("span", {
        key: 2,
        class: B(_(h).be("button", "inner")),
        style: $t(_(i) ? _(f) : void 0)
      }, [
        ke(y.$slots, "default", {}, () => [
          jr(Xe(y.label), 1)
        ])
      ], 6)) : le("v-if", !0)
    ], 2));
  }
});
var aq = /* @__PURE__ */ rt(ZIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const KIe = ht({
  modelValue: {
    type: Le(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Qu,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), YIe = {
  [At]: (e) => ul(e),
  change: (e) => ul(e)
}, QIe = he({
  name: "ElCheckboxGroup"
}), XIe = /* @__PURE__ */ he({
  ...QIe,
  props: KIe,
  emits: YIe,
  setup(e, { emit: t }) {
    const r = e, n = Je("checkbox"), { formItem: i } = gl(), { inputId: s, isLabeledByFormItem: o } = d0(r, {
      formItemContext: i
    }), a = async (c) => {
      t(At, c), await Ye(), t("change", c);
    }, l = A({
      get() {
        return r.modelValue;
      },
      set(c) {
        a(c);
      }
    });
    return cn(Mf, {
      ...$Se(zu(r), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: l,
      changeEvent: a
    }), Se(() => r.modelValue, () => {
      r.validateEvent && (i == null || i.validate("change").catch((c) => Ut(c)));
    }), (c, h) => {
      var f;
      return R(), ue(gr(c.tag), {
        id: _(s),
        class: B(_(n).b("group")),
        role: "group",
        "aria-label": _(o) ? void 0 : c.label || "checkbox-group",
        "aria-labelledby": _(o) ? (f = _(i)) == null ? void 0 : f.labelId : void 0
      }, {
        default: Y(() => [
          ke(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var lq = /* @__PURE__ */ rt(XIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const e3e = fi(GIe, {
  CheckboxButton: aq,
  CheckboxGroup: lq
});
Ku(aq);
Ku(lq);
const uq = ht({
  size: Qu,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
}), t3e = ht({
  ...uq,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}), cq = {
  [At]: (e) => nr(e) || ar(e) || Un(e),
  [aa]: (e) => nr(e) || ar(e) || Un(e)
}, dq = Symbol("radioGroupKey"), pq = (e, t) => {
  const r = q(), n = ot(dq, void 0), i = A(() => !!n), s = A({
    get() {
      return i.value ? n.modelValue : e.modelValue;
    },
    set(h) {
      i.value ? n.changeEvent(h) : t && t(At, h), r.value.checked = e.modelValue === e.label;
    }
  }), o = go(A(() => n == null ? void 0 : n.size)), a = If(A(() => n == null ? void 0 : n.disabled)), l = q(!1), c = A(() => a.value || i.value && s.value !== e.label ? -1 : 0);
  return {
    radioRef: r,
    isGroup: i,
    radioGroup: n,
    focus: l,
    size: o,
    disabled: a,
    tabIndex: c,
    modelValue: s
  };
}, r3e = ["value", "name", "disabled"], n3e = he({
  name: "ElRadio"
}), i3e = /* @__PURE__ */ he({
  ...n3e,
  props: t3e,
  emits: cq,
  setup(e, { emit: t }) {
    const r = e, n = Je("radio"), { radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: c } = pq(r, t);
    function h() {
      Ye(() => t("change", c.value));
    }
    return (f, m) => {
      var y;
      return R(), Z("label", {
        class: B([
          _(n).b(),
          _(n).is("disabled", _(l)),
          _(n).is("focus", _(o)),
          _(n).is("bordered", f.border),
          _(n).is("checked", _(c) === f.label),
          _(n).m(_(a))
        ])
      }, [
        K("span", {
          class: B([
            _(n).e("input"),
            _(n).is("disabled", _(l)),
            _(n).is("checked", _(c) === f.label)
          ])
        }, [
          Yt(K("input", {
            ref_key: "radioRef",
            ref: i,
            "onUpdate:modelValue": m[0] || (m[0] = (g) => ra(c) ? c.value = g : null),
            class: B(_(n).e("original")),
            value: f.label,
            name: f.name || ((y = _(s)) == null ? void 0 : y.name),
            disabled: _(l),
            type: "radio",
            onFocus: m[1] || (m[1] = (g) => o.value = !0),
            onBlur: m[2] || (m[2] = (g) => o.value = !1),
            onChange: h,
            onClick: m[3] || (m[3] = kt(() => {
            }, ["stop"]))
          }, null, 42, r3e), [
            [y5, _(c)]
          ]),
          K("span", {
            class: B(_(n).e("inner"))
          }, null, 2)
        ], 2),
        K("span", {
          class: B(_(n).e("label")),
          onKeydown: m[4] || (m[4] = kt(() => {
          }, ["stop"]))
        }, [
          ke(f.$slots, "default", {}, () => [
            jr(Xe(f.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var s3e = /* @__PURE__ */ rt(i3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const o3e = ht({
  ...uq,
  name: {
    type: String,
    default: ""
  }
}), a3e = ["value", "name", "disabled"], l3e = he({
  name: "ElRadioButton"
}), u3e = /* @__PURE__ */ he({
  ...l3e,
  props: o3e,
  setup(e) {
    const t = e, r = Je("radio"), { radioRef: n, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = pq(t), c = A(() => ({
      backgroundColor: (l == null ? void 0 : l.fill) || "",
      borderColor: (l == null ? void 0 : l.fill) || "",
      boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
      color: (l == null ? void 0 : l.textColor) || ""
    }));
    return (h, f) => {
      var m;
      return R(), Z("label", {
        class: B([
          _(r).b("button"),
          _(r).is("active", _(a) === h.label),
          _(r).is("disabled", _(o)),
          _(r).is("focus", _(i)),
          _(r).bm("button", _(s))
        ])
      }, [
        Yt(K("input", {
          ref_key: "radioRef",
          ref: n,
          "onUpdate:modelValue": f[0] || (f[0] = (y) => ra(a) ? a.value = y : null),
          class: B(_(r).be("button", "original-radio")),
          value: h.label,
          type: "radio",
          name: h.name || ((m = _(l)) == null ? void 0 : m.name),
          disabled: _(o),
          onFocus: f[1] || (f[1] = (y) => i.value = !0),
          onBlur: f[2] || (f[2] = (y) => i.value = !1),
          onClick: f[3] || (f[3] = kt(() => {
          }, ["stop"]))
        }, null, 42, a3e), [
          [y5, _(a)]
        ]),
        K("span", {
          class: B(_(r).be("button", "inner")),
          style: $t(_(a) === h.label ? _(c) : {}),
          onKeydown: f[4] || (f[4] = kt(() => {
          }, ["stop"]))
        }, [
          ke(h.$slots, "default", {}, () => [
            jr(Xe(h.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var hq = /* @__PURE__ */ rt(u3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const c3e = ht({
  id: {
    type: String,
    default: void 0
  },
  size: Qu,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), d3e = cq, p3e = ["id", "aria-label", "aria-labelledby"], h3e = he({
  name: "ElRadioGroup"
}), f3e = /* @__PURE__ */ he({
  ...h3e,
  props: c3e,
  emits: d3e,
  setup(e, { emit: t }) {
    const r = e, n = Je("radio"), i = ju(), s = q(), { formItem: o } = gl(), { inputId: a, isLabeledByFormItem: l } = d0(r, {
      formItemContext: o
    }), c = (f) => {
      t(At, f), Ye(() => t("change", f));
    };
    qt(() => {
      const f = s.value.querySelectorAll("[type=radio]"), m = f[0];
      !Array.from(f).some((y) => y.checked) && m && (m.tabIndex = 0);
    });
    const h = A(() => r.name || i.value);
    return cn(dq, ci({
      ...zu(r),
      changeEvent: c,
      name: h
    })), Se(() => r.modelValue, () => {
      r.validateEvent && (o == null || o.validate("change").catch((f) => Ut(f)));
    }), (f, m) => (R(), Z("div", {
      id: _(a),
      ref_key: "radioGroupRef",
      ref: s,
      class: B(_(n).b("group")),
      role: "radiogroup",
      "aria-label": _(l) ? void 0 : f.label || "radio-group",
      "aria-labelledby": _(l) ? _(o).labelId : void 0
    }, [
      ke(f.$slots, "default")
    ], 10, p3e));
  }
});
var fq = /* @__PURE__ */ rt(f3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
const zo = fi(s3e, {
  RadioButton: hq,
  RadioGroup: fq
}), Ov = Ku(fq);
Ku(hq);
var m3e = he({
  name: "NodeContent",
  setup() {
    return {
      ns: Je("cascader-node")
    };
  },
  render() {
    const { ns: e } = this, { node: t, panel: r } = this.$parent, { data: n, label: i } = t, { renderLabelFn: s } = r;
    return Ha("span", { class: e.e("label") }, s ? s({ node: t, data: n }) : i);
  }
});
const DC = Symbol(), y3e = he({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: e3e,
    ElRadio: zo,
    NodeContent: m3e,
    ElIcon: zt,
    Check: sB,
    Loading: a0,
    ArrowRight: kSe
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, { emit: t }) {
    const r = ot(DC), n = Je("cascader-node"), i = A(() => r.isHoverMenu), s = A(() => r.config.multiple), o = A(() => r.config.checkStrictly), a = A(() => {
      var I;
      return (I = r.checkedNodes[0]) == null ? void 0 : I.uid;
    }), l = A(() => e.node.isDisabled), c = A(() => e.node.isLeaf), h = A(() => o.value && !c.value || !l.value), f = A(() => y(r.expandingNode)), m = A(() => o.value && r.checkedNodes.some(y)), y = (I) => {
      var O;
      const { level: M, uid: L } = e.node;
      return ((O = I == null ? void 0 : I.pathNodes[M - 1]) == null ? void 0 : O.uid) === L;
    }, g = () => {
      f.value || r.expandNode(e.node);
    }, v = (I) => {
      const { node: O } = e;
      I !== O.checked && r.handleCheckChange(O, I);
    }, b = () => {
      r.lazyLoad(e.node, () => {
        c.value || g();
      });
    }, w = (I) => {
      i.value && (x(), !c.value && t("expand", I));
    }, x = () => {
      const { node: I } = e;
      !h.value || I.loading || (I.loaded ? g() : b());
    }, $ = () => {
      i.value && !c.value || (c.value && !l.value && !o.value && !s.value ? C(!0) : x());
    }, T = (I) => {
      o.value ? (v(I), e.node.loaded && g()) : C(I);
    }, C = (I) => {
      e.node.loaded ? (v(I), !o.value && g()) : b();
    };
    return {
      panel: r,
      isHoverMenu: i,
      multiple: s,
      checkStrictly: o,
      checkedNodeId: a,
      isDisabled: l,
      isLeaf: c,
      expandable: h,
      inExpandingPath: f,
      inCheckedPath: m,
      ns: n,
      handleHoverExpand: w,
      handleExpand: x,
      handleClick: $,
      handleCheck: C,
      handleSelectCheck: T
    };
  }
}), g3e = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], v3e = /* @__PURE__ */ K("span", null, null, -1);
function b3e(e, t, r, n, i, s) {
  const o = Or("el-checkbox"), a = Or("el-radio"), l = Or("check"), c = Or("el-icon"), h = Or("node-content"), f = Or("loading"), m = Or("arrow-right");
  return R(), Z("li", {
    id: `${e.menuId}-${e.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !e.isLeaf,
    "aria-owns": e.isLeaf ? null : e.menuId,
    "aria-expanded": e.inExpandingPath,
    tabindex: e.expandable ? -1 : void 0,
    class: B([
      e.ns.b(),
      e.ns.is("selectable", e.checkStrictly),
      e.ns.is("active", e.node.checked),
      e.ns.is("disabled", !e.expandable),
      e.inExpandingPath && "in-active-path",
      e.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: t[2] || (t[2] = (...y) => e.handleHoverExpand && e.handleHoverExpand(...y)),
    onFocus: t[3] || (t[3] = (...y) => e.handleHoverExpand && e.handleHoverExpand(...y)),
    onClick: t[4] || (t[4] = (...y) => e.handleClick && e.handleClick(...y))
  }, [
    le(" prefix "),
    e.multiple ? (R(), ue(o, {
      key: 0,
      "model-value": e.node.checked,
      indeterminate: e.node.indeterminate,
      disabled: e.isDisabled,
      onClick: t[0] || (t[0] = kt(() => {
      }, ["stop"])),
      "onUpdate:modelValue": e.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (R(), ue(a, {
      key: 1,
      "model-value": e.checkedNodeId,
      label: e.node.uid,
      disabled: e.isDisabled,
      "onUpdate:modelValue": e.handleSelectCheck,
      onClick: t[1] || (t[1] = kt(() => {
      }, ["stop"]))
    }, {
      default: Y(() => [
        le(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        v3e
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (R(), ue(c, {
      key: 2,
      class: B(e.ns.e("prefix"))
    }, {
      default: Y(() => [
        de(l)
      ]),
      _: 1
    }, 8, ["class"])) : le("v-if", !0),
    le(" content "),
    de(h),
    le(" postfix "),
    e.isLeaf ? le("v-if", !0) : (R(), Z(Mt, { key: 3 }, [
      e.node.loading ? (R(), ue(c, {
        key: 0,
        class: B([e.ns.is("loading"), e.ns.e("postfix")])
      }, {
        default: Y(() => [
          de(f)
        ]),
        _: 1
      }, 8, ["class"])) : (R(), ue(c, {
        key: 1,
        class: B(["arrow-right", e.ns.e("postfix")])
      }, {
        default: Y(() => [
          de(m)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, g3e);
}
var w3e = /* @__PURE__ */ rt(y3e, [["render", b3e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const _3e = he({
  name: "ElCascaderMenu",
  components: {
    Loading: a0,
    ElIcon: zt,
    ElScrollbar: PC,
    ElCascaderNode: w3e
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = nn(), r = Je("cascader-menu"), { t: n } = ap(), i = YSe();
    let s = null, o = null;
    const a = ot(DC), l = q(null), c = A(() => !e.nodes.length), h = A(() => !a.initialLoaded), f = A(() => `cascader-menu-${i}-${e.index}`), m = (b) => {
      s = b.target;
    }, y = (b) => {
      if (!(!a.isHoverMenu || !s || !l.value))
        if (s.contains(b.target)) {
          g();
          const w = t.vnode.el, { left: x } = w.getBoundingClientRect(), { offsetWidth: $, offsetHeight: T } = w, C = b.clientX - x, I = s.offsetTop, O = I + s.offsetHeight;
          l.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${C} ${I} L${$} 0 V${I} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${C} ${O} L${$} ${T} V${O} Z" />
        `;
        } else
          o || (o = window.setTimeout(v, a.config.hoverThreshold));
    }, g = () => {
      o && (clearTimeout(o), o = null);
    }, v = () => {
      l.value && (l.value.innerHTML = "", g());
    };
    return {
      ns: r,
      panel: a,
      hoverZone: l,
      isEmpty: c,
      isLoading: h,
      menuId: f,
      t: n,
      handleExpand: m,
      handleMouseMove: y,
      clearHoverZone: v
    };
  }
});
function S3e(e, t, r, n, i, s) {
  const o = Or("el-cascader-node"), a = Or("loading"), l = Or("el-icon"), c = Or("el-scrollbar");
  return R(), ue(c, {
    key: e.menuId,
    tag: "ul",
    role: "menu",
    class: B(e.ns.b()),
    "wrap-class": e.ns.e("wrap"),
    "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
    onMousemove: e.handleMouseMove,
    onMouseleave: e.clearHoverZone
  }, {
    default: Y(() => {
      var h;
      return [
        (R(!0), Z(Mt, null, Mi(e.nodes, (f) => (R(), ue(o, {
          key: f.uid,
          node: f,
          "menu-id": e.menuId,
          onExpand: e.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        e.isLoading ? (R(), Z("div", {
          key: 0,
          class: B(e.ns.e("empty-text"))
        }, [
          de(l, {
            size: "14",
            class: B(e.ns.is("loading"))
          }, {
            default: Y(() => [
              de(a)
            ]),
            _: 1
          }, 8, ["class"]),
          jr(" " + Xe(e.t("el.cascader.loading")), 1)
        ], 2)) : e.isEmpty ? (R(), Z("div", {
          key: 1,
          class: B(e.ns.e("empty-text"))
        }, Xe(e.t("el.cascader.noData")), 3)) : (h = e.panel) != null && h.isHoverMenu ? (R(), Z("svg", {
          key: 2,
          ref: "hoverZone",
          class: B(e.ns.e("hover-zone"))
        }, null, 2)) : le("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var $3e = /* @__PURE__ */ rt(_3e, [["render", S3e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let x3e = 0;
const T3e = (e) => {
  const t = [e];
  let { parent: r } = e;
  for (; r; )
    t.unshift(r), r = r.parent;
  return t;
};
let l3 = class u3 {
  constructor(t, r, n, i = !1) {
    this.data = t, this.config = r, this.parent = n, this.root = i, this.uid = x3e++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: s, label: o, children: a } = r, l = t[a], c = T3e(this);
    this.level = i ? 0 : n ? n.level + 1 : 1, this.value = t[s], this.label = t[o], this.pathNodes = c, this.pathValues = c.map((h) => h.value), this.pathLabels = c.map((h) => h.label), this.childrenData = l, this.children = (l || []).map((h) => new u3(h, r, this)), this.loaded = !r.lazy || this.isLeaf || !GI(l);
  }
  get isDisabled() {
    const { data: t, parent: r, config: n } = this, { disabled: i, checkStrictly: s } = n;
    return (er(i) ? i(t, this) : !!t[i]) || !s && (r == null ? void 0 : r.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: r, childrenData: n, loaded: i } = this, { lazy: s, leaf: o } = r, a = er(o) ? o(t, this) : t[o];
    return Hh(a) ? s && !i ? !1 : !(Array.isArray(n) && n.length) : !!a;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: r, children: n } = this, i = new u3(t, this.config, this);
    return Array.isArray(r) ? r.push(t) : this.childrenData = [t], n.push(i), i;
  }
  calcText(t, r) {
    const n = t ? this.pathLabels.join(r) : this.label;
    return this.text = n, n;
  }
  broadcast(t, ...r) {
    const n = `onParent${FL(t)}`;
    this.children.forEach((i) => {
      i && (i.broadcast(t, ...r), i[n] && i[n](...r));
    });
  }
  emit(t, ...r) {
    const { parent: n } = this, i = `onChild${FL(t)}`;
    n && (n[i] && n[i](...r), n.emit(t, ...r));
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, r = t.filter((i) => !i.isDisabled), n = r.length ? r.every((i) => i.checked) : !1;
    this.setCheckState(n);
  }
  setCheckState(t) {
    const r = this.children.length, n = this.children.reduce((i, s) => {
      const o = s.checked ? 1 : s.indeterminate ? 0.5 : 0;
      return i + o;
    }, 0);
    this.checked = this.loaded && this.children.filter((i) => !i.isDisabled).every((i) => i.loaded && i.checked) && t, this.indeterminate = this.loaded && n !== r && n > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: r, multiple: n } = this.config;
    r || !n ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
  }
};
const c3 = (e, t) => e.reduce((r, n) => (n.isLeaf ? r.push(n) : (!t && r.push(n), r = r.concat(c3(n.children, t))), r), []);
class MN {
  constructor(t, r) {
    this.config = r;
    const n = (t || []).map((i) => new l3(i, this.config));
    this.nodes = n, this.allNodes = c3(n, !1), this.leafNodes = c3(n, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, r) {
    const n = r ? r.appendChild(t) : new l3(t, this.config);
    r || this.nodes.push(n), this.allNodes.push(n), n.isLeaf && this.leafNodes.push(n);
  }
  appendNodes(t, r) {
    t.forEach((n) => this.appendNode(n, r));
  }
  getNodeByValue(t, r = !1) {
    return !t && t !== 0 ? null : this.getFlattedNodes(r).find((i) => Cu(i.value, t) || Cu(i.pathValues, t)) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(!1).find(({ value: n, level: i }) => Cu(t.value, n) && t.level === i) || null;
  }
}
const mq = ht({
  modelValue: {
    type: Le([Number, String, Array])
  },
  options: {
    type: Le(Array),
    default: () => []
  },
  props: {
    type: Le(Object),
    default: () => ({})
  }
}), E3e = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: Xo,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, I3e = (e) => A(() => ({
  ...E3e,
  ...e.props
})), ON = (e) => {
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2]);
}, M3e = (e) => {
  if (!e)
    return;
  const t = e.querySelector("input");
  t ? t.click() : $U(e) && e.click();
}, O3e = (e, t) => {
  const r = t.slice(0), n = r.map((s) => s.uid), i = e.reduce((s, o) => {
    const a = n.indexOf(o.uid);
    return a > -1 && (s.push(o), r.splice(a, 1), n.splice(a, 1)), s;
  }, []);
  return i.push(...r), i;
}, C3e = he({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: $3e
  },
  props: {
    ...mq,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [At, aa, "close", "expand-change"],
  setup(e, { emit: t, slots: r }) {
    let n = !1;
    const i = Je("cascader"), s = I3e(e);
    let o = null;
    const a = q(!0), l = q([]), c = q(null), h = q([]), f = q(null), m = q([]), y = A(() => s.value.expandTrigger === "hover"), g = A(() => e.renderLabel || r.default), v = () => {
      const { options: D } = e, H = s.value;
      n = !1, o = new MN(D, H), h.value = [o.getNodes()], H.lazy && GI(e.options) ? (a.value = !1, b(void 0, (J) => {
        J && (o = new MN(J, H), h.value = [o.getNodes()]), a.value = !0, M(!1, !0);
      })) : M(!1, !0);
    }, b = (D, H) => {
      const J = s.value;
      D = D || new l3({}, J, void 0, !0), D.loading = !0;
      const oe = (ye) => {
        const Q = D, ve = Q.root ? null : Q;
        ye && (o == null || o.appendNodes(ye, ve)), Q.loading = !1, Q.loaded = !0, Q.childrenData = Q.childrenData || [], H && H(ye);
      };
      J.lazyLoad(D, oe);
    }, w = (D, H) => {
      var J;
      const { level: oe } = D, ye = h.value.slice(0, oe);
      let Q;
      D.isLeaf ? Q = D.pathNodes[oe - 2] : (Q = D, ye.push(D.children)), ((J = f.value) == null ? void 0 : J.uid) !== (Q == null ? void 0 : Q.uid) && (f.value = D, h.value = ye, !H && t("expand-change", (D == null ? void 0 : D.pathValues) || []));
    }, x = (D, H, J = !0) => {
      const { checkStrictly: oe, multiple: ye } = s.value, Q = m.value[0];
      n = !0, !ye && (Q == null || Q.doCheck(!1)), D.doCheck(H), O(), J && !ye && !oe && t("close"), !J && !ye && !oe && $(D);
    }, $ = (D) => {
      D && (D = D.parent, $(D), D && w(D));
    }, T = (D) => o == null ? void 0 : o.getFlattedNodes(D), C = (D) => {
      var H;
      return (H = T(D)) == null ? void 0 : H.filter((J) => J.checked !== !1);
    }, I = () => {
      m.value.forEach((D) => D.doCheck(!1)), O(), h.value = h.value.slice(0, 1), f.value = null, t("expand-change", []);
    }, O = () => {
      var D;
      const { checkStrictly: H, multiple: J } = s.value, oe = m.value, ye = C(!H), Q = O3e(oe, ye), ve = Q.map((Ee) => Ee.valueByOption);
      m.value = Q, c.value = J ? ve : (D = ve[0]) != null ? D : null;
    }, M = (D = !1, H = !1) => {
      const { modelValue: J } = e, { lazy: oe, multiple: ye, checkStrictly: Q } = s.value, ve = !Q;
      if (!(!a.value || n || !H && Cu(J, c.value)))
        if (oe && !D) {
          const Lt = VL(bSe(zL(J))).map((ft) => o == null ? void 0 : o.getNodeByValue(ft)).filter((ft) => !!ft && !ft.loaded && !ft.loading);
          Lt.length ? Lt.forEach((ft) => {
            b(ft, () => M(!1, H));
          }) : M(!0, H);
        } else {
          const Ee = ye ? zL(J) : [J], Lt = VL(Ee.map((ft) => o == null ? void 0 : o.getNodeByValue(ft, ve)));
          L(Lt, H), c.value = JU(J);
        }
    }, L = (D, H = !0) => {
      const { checkStrictly: J } = s.value, oe = m.value, ye = D.filter((Ee) => !!Ee && (J || Ee.isLeaf)), Q = o == null ? void 0 : o.getSameNode(f.value), ve = H && Q || ye[0];
      ve ? ve.pathNodes.forEach((Ee) => w(Ee, !0)) : f.value = null, oe.forEach((Ee) => Ee.doCheck(!1)), e.props.multiple ? ci(ye).forEach((Ee) => Ee.doCheck(!0)) : ye.forEach((Ee) => Ee.doCheck(!0)), m.value = ye, Ye(N);
    }, N = () => {
      Pt && l.value.forEach((D) => {
        const H = D == null ? void 0 : D.$el;
        if (H) {
          const J = H.querySelector(`.${i.namespace.value}-scrollbar__wrap`), oe = H.querySelector(`.${i.b("node")}.${i.is("active")}`) || H.querySelector(`.${i.b("node")}.in-active-path`);
          nB(J, oe);
        }
      });
    }, ee = (D) => {
      const H = D.target, { code: J } = D;
      switch (J) {
        case Xt.up:
        case Xt.down: {
          D.preventDefault();
          const oe = J === Xt.up ? -1 : 1;
          B1(xU(H, oe, `.${i.b("node")}[tabindex="-1"]`));
          break;
        }
        case Xt.left: {
          D.preventDefault();
          const oe = l.value[ON(H) - 1], ye = oe == null ? void 0 : oe.$el.querySelector(`.${i.b("node")}[aria-expanded="true"]`);
          B1(ye);
          break;
        }
        case Xt.right: {
          D.preventDefault();
          const oe = l.value[ON(H) + 1], ye = oe == null ? void 0 : oe.$el.querySelector(`.${i.b("node")}[tabindex="-1"]`);
          B1(ye);
          break;
        }
        case Xt.enter:
          M3e(H);
          break;
      }
    };
    return cn(DC, ci({
      config: s,
      expandingNode: f,
      checkedNodes: m,
      isHoverMenu: y,
      initialLoaded: a,
      renderLabelFn: g,
      lazyLoad: b,
      expandNode: w,
      handleCheckChange: x
    })), Se([s, () => e.options], v, {
      deep: !0,
      immediate: !0
    }), Se(() => e.modelValue, () => {
      n = !1, M();
    }, {
      deep: !0
    }), Se(() => c.value, (D) => {
      Cu(D, e.modelValue) || (t(At, D), t(aa, D));
    }), vG(() => l.value = []), qt(() => !GI(e.modelValue) && M()), {
      ns: i,
      menuList: l,
      menus: h,
      checkedNodes: m,
      handleKeyDown: ee,
      handleCheckChange: x,
      getFlattedNodes: T,
      getCheckedNodes: C,
      clearCheckedNodes: I,
      calculateCheckedValue: O,
      scrollToExpandingNode: N
    };
  }
});
function k3e(e, t, r, n, i, s) {
  const o = Or("el-cascader-menu");
  return R(), Z("div", {
    class: B([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
    onKeydown: t[0] || (t[0] = (...a) => e.handleKeyDown && e.handleKeyDown(...a))
  }, [
    (R(!0), Z(Mt, null, Mi(e.menus, (a, l) => (R(), ue(o, {
      key: l,
      ref_for: !0,
      ref: (c) => e.menuList[l] = c,
      index: l,
      nodes: [...a]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var Z1 = /* @__PURE__ */ rt(C3e, [["render", k3e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
Z1.install = (e) => {
  e.component(Z1.name, Z1);
};
const A3e = Z1, jC = ht({
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: l0,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), P3e = {
  close: (e) => e instanceof MouseEvent,
  click: (e) => e instanceof MouseEvent
}, R3e = he({
  name: "ElTag"
}), L3e = /* @__PURE__ */ he({
  ...R3e,
  props: jC,
  emits: P3e,
  setup(e, { emit: t }) {
    const r = e, n = go(), i = Je("tag"), s = A(() => {
      const { type: l, hit: c, effect: h, closable: f, round: m } = r;
      return [
        i.b(),
        i.is("closable", f),
        i.m(l),
        i.m(n.value),
        i.m(h),
        i.is("hit", c),
        i.is("round", m)
      ];
    }), o = (l) => {
      t("close", l);
    }, a = (l) => {
      t("click", l);
    };
    return (l, c) => l.disableTransitions ? (R(), Z("span", {
      key: 0,
      class: B(_(s)),
      style: $t({ backgroundColor: l.color }),
      onClick: a
    }, [
      K("span", {
        class: B(_(i).e("content"))
      }, [
        ke(l.$slots, "default")
      ], 2),
      l.closable ? (R(), ue(_(zt), {
        key: 0,
        class: B(_(i).e("close")),
        onClick: kt(o, ["stop"])
      }, {
        default: Y(() => [
          de(_(Ew))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : le("v-if", !0)
    ], 6)) : (R(), ue(po, {
      key: 1,
      name: `${_(i).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: Y(() => [
        K("span", {
          class: B(_(s)),
          style: $t({ backgroundColor: l.color }),
          onClick: a
        }, [
          K("span", {
            class: B(_(i).e("content"))
          }, [
            ke(l.$slots, "default")
          ], 2),
          l.closable ? (R(), ue(_(zt), {
            key: 0,
            class: B(_(i).e("close")),
            onClick: kt(o, ["stop"])
          }, {
            default: Y(() => [
              de(_(Ew))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : le("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var N3e = /* @__PURE__ */ rt(L3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const d3 = fi(N3e), F3e = ht({
  ...mq,
  size: Qu,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: Le(Function),
    default: (e, t) => e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Le(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: u2.teleported,
  tagType: { ...jC.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), D3e = {
  [At]: (e) => !!e || e === null,
  [aa]: (e) => !!e || e === null,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  visibleChange: (e) => Un(e),
  expandChange: (e) => !!e,
  removeTag: (e) => !!e
}, j3e = { key: 0 }, V3e = ["placeholder", "onKeydown"], z3e = ["onClick"], U3e = "ElCascader", B3e = he({
  name: U3e
}), q3e = /* @__PURE__ */ he({
  ...B3e,
  props: F3e,
  emits: D3e,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: te }) => {
            const { modifiersData: fe, placement: _e } = te;
            ["right", "left", "bottom", "top"].includes(_e) || (fe.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, s = h5();
    let o = 0, a = 0;
    const l = Je("cascader"), c = Je("input"), { t: h } = ap(), { form: f, formItem: m } = gl(), y = q(null), g = q(null), v = q(null), b = q(null), w = q(null), x = q(!1), $ = q(!1), T = q(!1), C = q(!1), I = q(""), O = q(""), M = q([]), L = q([]), N = q([]), ee = q(!1), D = A(() => s.style), H = A(() => n.disabled || (f == null ? void 0 : f.disabled)), J = A(() => n.placeholder || h("el.cascader.placeholder")), oe = A(() => O.value || M.value.length > 0 || ee.value ? "" : J.value), ye = go(), Q = A(() => ["small"].includes(ye.value) ? "small" : "default"), ve = A(() => !!n.props.multiple), Ee = A(() => !n.filterable || ve.value), Lt = A(() => ve.value ? O.value : I.value), ft = A(() => {
      var te;
      return ((te = b.value) == null ? void 0 : te.checkedNodes) || [];
    }), Nt = A(() => !n.clearable || H.value || T.value || !$.value ? !1 : !!ft.value.length), ir = A(() => {
      const { showAllLevels: te, separator: fe } = n, _e = ft.value;
      return _e.length ? ve.value ? "" : _e[0].calcText(te, fe) : "";
    }), wr = A({
      get() {
        return JU(n.modelValue);
      },
      set(te) {
        r(At, te), r(aa, te), n.validateEvent && (m == null || m.validate("change").catch((fe) => Ut(fe)));
      }
    }), _r = A(() => [
      l.b(),
      l.m(ye.value),
      l.is("disabled", H.value),
      s.class
    ]), Pr = A(() => [
      c.e("icon"),
      "icon-arrow-down",
      l.is("reverse", x.value)
    ]), xe = A(() => l.is("focus", x.value || C.value)), Ne = A(() => {
      var te, fe;
      return (fe = (te = y.value) == null ? void 0 : te.popperRef) == null ? void 0 : fe.contentRef;
    }), He = (te) => {
      var fe, _e, ct;
      H.value || (te = te ?? !x.value, te !== x.value && (x.value = te, (_e = (fe = g.value) == null ? void 0 : fe.input) == null || _e.setAttribute("aria-expanded", `${te}`), te ? (nt(), Ye((ct = b.value) == null ? void 0 : ct.scrollToExpandingNode)) : n.filterable && Jn(), r("visibleChange", te)));
    }, nt = () => {
      Ye(() => {
        var te;
        (te = y.value) == null || te.updatePopper();
      });
    }, wt = () => {
      T.value = !1;
    }, cr = (te) => {
      const { showAllLevels: fe, separator: _e } = n;
      return {
        node: te,
        key: te.uid,
        text: te.calcText(fe, _e),
        hitState: !1,
        closable: !H.value && !te.isDisabled,
        isCollapseTag: !1
      };
    }, qr = (te) => {
      var fe;
      const _e = te.node;
      _e.doCheck(!1), (fe = b.value) == null || fe.calculateCheckedValue(), r("removeTag", _e.valueByOption);
    }, mi = () => {
      if (!ve.value)
        return;
      const te = ft.value, fe = [], _e = [];
      if (te.forEach((ct) => _e.push(cr(ct))), L.value = _e, te.length) {
        te.slice(0, n.maxCollapseTags).forEach((Gr) => fe.push(cr(Gr)));
        const ct = te.slice(n.maxCollapseTags), An = ct.length;
        An && (n.collapseTags ? fe.push({
          key: -1,
          text: `+ ${An}`,
          closable: !1,
          isCollapseTag: !0
        }) : ct.forEach((Gr) => fe.push(cr(Gr))));
      }
      M.value = fe;
    }, Gn = () => {
      var te, fe;
      const { filterMethod: _e, showAllLevels: ct, separator: An } = n, Gr = (fe = (te = b.value) == null ? void 0 : te.getFlattedNodes(!n.props.checkStrictly)) == null ? void 0 : fe.filter((dn) => dn.isDisabled ? !1 : (dn.calcText(ct, An), _e(dn, Lt.value)));
      ve.value && (M.value.forEach((dn) => {
        dn.hitState = !1;
      }), L.value.forEach((dn) => {
        dn.hitState = !1;
      })), T.value = !0, N.value = Gr, nt();
    }, On = () => {
      var te;
      let fe;
      T.value && w.value ? fe = w.value.$el.querySelector(`.${l.e("suggestion-item")}`) : fe = (te = b.value) == null ? void 0 : te.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`), fe && (fe.focus(), !T.value && fe.click());
    }, Hn = () => {
      var te, fe;
      const _e = (te = g.value) == null ? void 0 : te.input, ct = v.value, An = (fe = w.value) == null ? void 0 : fe.$el;
      if (!(!Pt || !_e)) {
        if (An) {
          const Gr = An.querySelector(`.${l.e("suggestion-list")}`);
          Gr.style.minWidth = `${_e.offsetWidth}px`;
        }
        if (ct) {
          const { offsetHeight: Gr } = ct, dn = M.value.length > 0 ? `${Math.max(Gr + 6, o)}px` : `${o}px`;
          _e.style.height = dn, nt();
        }
      }
    }, Cn = (te) => {
      var fe;
      return (fe = b.value) == null ? void 0 : fe.getCheckedNodes(te);
    }, yi = (te) => {
      nt(), r("expandChange", te);
    }, dr = (te) => {
      var fe;
      const _e = (fe = te.target) == null ? void 0 : fe.value;
      if (te.type === "compositionend")
        ee.value = !1, Ye(() => Is(_e));
      else {
        const ct = _e[_e.length - 1] || "";
        ee.value = !SC(ct);
      }
    }, Wn = (te) => {
      if (!ee.value)
        switch (te.code) {
          case Xt.enter:
            He();
            break;
          case Xt.down:
            He(!0), Ye(On), te.preventDefault();
            break;
          case Xt.esc:
            x.value === !0 && (te.preventDefault(), te.stopPropagation(), He(!1));
            break;
          case Xt.tab:
            He(!1);
            break;
        }
    }, kn = () => {
      var te;
      (te = b.value) == null || te.clearCheckedNodes(), !x.value && n.filterable && Jn(), He(!1);
    }, Jn = () => {
      const { value: te } = ir;
      I.value = te, O.value = te;
    }, Zn = (te) => {
      var fe, _e;
      const { checked: ct } = te;
      ve.value ? (fe = b.value) == null || fe.handleCheckChange(te, !ct, !1) : (!ct && ((_e = b.value) == null || _e.handleCheckChange(te, !0, !1)), He(!1));
    }, ae = (te) => {
      const fe = te.target, { code: _e } = te;
      switch (_e) {
        case Xt.up:
        case Xt.down: {
          const ct = _e === Xt.up ? -1 : 1;
          B1(xU(fe, ct, `.${l.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case Xt.enter:
          fe.click();
          break;
      }
    }, Fe = () => {
      const te = M.value, fe = te[te.length - 1];
      a = O.value ? 0 : a + 1, !(!fe || !a || n.collapseTags && te.length > 1) && (fe.hitState ? qr(fe) : fe.hitState = !0);
    }, at = (te) => {
      const fe = te.target, _e = l.e("search-input");
      fe.className === _e && (C.value = !0), r("focus", te);
    }, pr = (te) => {
      C.value = !1, r("blur", te);
    }, gi = qI(() => {
      const { value: te } = Lt;
      if (!te)
        return;
      const fe = n.beforeFilter(te);
      NI(fe) ? fe.then(Gn).catch(() => {
      }) : fe !== !1 ? Gn() : wt();
    }, n.debounce), Is = (te, fe) => {
      !x.value && He(!0), !(fe != null && fe.isComposing) && (te ? gi() : wt());
    }, wo = (te) => Number.parseFloat(wve(c.cssVarName("input-height"), te).value) - 2;
    return Se(T, nt), Se([ft, H], mi), Se(M, () => {
      Ye(() => Hn());
    }), Se(ye, async () => {
      await Ye();
      const te = g.value.input;
      o = wo(te) || o, Hn();
    }), Se(ir, Jn, { immediate: !0 }), qt(() => {
      const te = g.value.input, fe = wo(te);
      o = te.offsetHeight || fe, ip(te, Hn);
    }), t({
      getCheckedNodes: Cn,
      cascaderPanelRef: b,
      togglePopperVisible: He,
      contentRef: Ne
    }), (te, fe) => (R(), ue(_(s3), {
      ref_key: "tooltipRef",
      ref: y,
      visible: x.value,
      teleported: te.teleported,
      "popper-class": [_(l).e("dropdown"), te.popperClass],
      "popper-options": i,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${_(l).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: wt
    }, {
      default: Y(() => [
        Yt((R(), Z("div", {
          class: B(_(_r)),
          style: $t(_(D)),
          onClick: fe[5] || (fe[5] = () => He(_(Ee) ? void 0 : !0)),
          onKeydown: Wn,
          onMouseenter: fe[6] || (fe[6] = (_e) => $.value = !0),
          onMouseleave: fe[7] || (fe[7] = (_e) => $.value = !1)
        }, [
          de(_(UB), {
            ref_key: "input",
            ref: g,
            modelValue: I.value,
            "onUpdate:modelValue": fe[1] || (fe[1] = (_e) => I.value = _e),
            placeholder: _(oe),
            readonly: _(Ee),
            disabled: _(H),
            "validate-event": !1,
            size: _(ye),
            class: B(_(xe)),
            tabindex: _(ve) && te.filterable && !_(H) ? -1 : void 0,
            onCompositionstart: dr,
            onCompositionupdate: dr,
            onCompositionend: dr,
            onFocus: at,
            onBlur: pr,
            onInput: Is
          }, {
            suffix: Y(() => [
              _(Nt) ? (R(), ue(_(zt), {
                key: "clear",
                class: B([_(c).e("icon"), "icon-circle-close"]),
                onClick: kt(kn, ["stop"])
              }, {
                default: Y(() => [
                  de(_(r2))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (R(), ue(_(zt), {
                key: "arrow-down",
                class: B(_(Pr)),
                onClick: fe[0] || (fe[0] = kt((_e) => He(), ["stop"]))
              }, {
                default: Y(() => [
                  de(_(iB))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          _(ve) ? (R(), Z("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: v,
            class: B(_(l).e("tags"))
          }, [
            (R(!0), Z(Mt, null, Mi(M.value, (_e) => (R(), ue(_(d3), {
              key: _e.key,
              type: te.tagType,
              size: _(Q),
              hit: _e.hitState,
              closable: _e.closable,
              "disable-transitions": "",
              onClose: (ct) => qr(_e)
            }, {
              default: Y(() => [
                _e.isCollapseTag === !1 ? (R(), Z("span", j3e, Xe(_e.text), 1)) : (R(), ue(_(s3), {
                  key: 1,
                  disabled: x.value || !te.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: Y(() => [
                    K("span", null, Xe(_e.text), 1)
                  ]),
                  content: Y(() => [
                    K("div", {
                      class: B(_(l).e("collapse-tags"))
                    }, [
                      (R(!0), Z(Mt, null, Mi(L.value.slice(te.maxCollapseTags), (ct, An) => (R(), Z("div", {
                        key: An,
                        class: B(_(l).e("collapse-tag"))
                      }, [
                        (R(), ue(_(d3), {
                          key: ct.key,
                          class: "in-tooltip",
                          type: te.tagType,
                          size: _(Q),
                          hit: ct.hitState,
                          closable: ct.closable,
                          "disable-transitions": "",
                          onClose: (Gr) => qr(ct)
                        }, {
                          default: Y(() => [
                            K("span", null, Xe(ct.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            te.filterable && !_(H) ? Yt((R(), Z("input", {
              key: 0,
              "onUpdate:modelValue": fe[2] || (fe[2] = (_e) => O.value = _e),
              type: "text",
              class: B(_(l).e("search-input")),
              placeholder: _(ir) ? "" : _(J),
              onInput: fe[3] || (fe[3] = (_e) => Is(O.value, _e)),
              onClick: fe[4] || (fe[4] = kt((_e) => He(!0), ["stop"])),
              onKeydown: $i(Fe, ["delete"]),
              onCompositionstart: dr,
              onCompositionupdate: dr,
              onCompositionend: dr,
              onFocus: at,
              onBlur: pr
            }, null, 42, V3e)), [
              [g5, O.value]
            ]) : le("v-if", !0)
          ], 2)) : le("v-if", !0)
        ], 38)), [
          [_(nq), () => He(!1), _(Ne)]
        ])
      ]),
      content: Y(() => [
        Yt(de(_(A3e), {
          ref_key: "cascaderPanelRef",
          ref: b,
          modelValue: _(wr),
          "onUpdate:modelValue": fe[8] || (fe[8] = (_e) => ra(wr) ? wr.value = _e : null),
          options: te.options,
          props: n.props,
          border: !1,
          "render-label": te.$slots.default,
          onExpandChange: yi,
          onClose: fe[9] || (fe[9] = (_e) => te.$nextTick(() => He(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [di, !T.value]
        ]),
        te.filterable ? Yt((R(), ue(_(PC), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: w,
          tag: "ul",
          class: B(_(l).e("suggestion-panel")),
          "view-class": _(l).e("suggestion-list"),
          onKeydown: ae
        }, {
          default: Y(() => [
            N.value.length ? (R(!0), Z(Mt, { key: 0 }, Mi(N.value, (_e) => (R(), Z("li", {
              key: _e.uid,
              class: B([
                _(l).e("suggestion-item"),
                _(l).is("checked", _e.checked)
              ]),
              tabindex: -1,
              onClick: (ct) => Zn(_e)
            }, [
              K("span", null, Xe(_e.text), 1),
              _e.checked ? (R(), ue(_(zt), { key: 0 }, {
                default: Y(() => [
                  de(_(sB))
                ]),
                _: 1
              })) : le("v-if", !0)
            ], 10, z3e))), 128)) : ke(te.$slots, "empty", { key: 1 }, () => [
              K("li", {
                class: B(_(l).e("empty-text"))
              }, Xe(_(h)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [di, T.value]
        ]) : le("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var K1 = /* @__PURE__ */ rt(q3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
K1.install = (e) => {
  e.component(K1.name, K1);
};
const G3e = K1, H3e = G3e, W3e = he({
  name: "ElCollapseTransition"
}), J3e = /* @__PURE__ */ he({
  ...W3e,
  setup(e) {
    const t = Je("collapse-transition"), r = (i) => {
      i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom;
    }, n = {
      beforeEnter(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0;
      },
      enter(i) {
        i.dataset.oldOverflow = i.style.overflow, i.scrollHeight !== 0 ? i.style.maxHeight = `${i.scrollHeight}px` : i.style.maxHeight = 0, i.style.paddingTop = i.dataset.oldPaddingTop, i.style.paddingBottom = i.dataset.oldPaddingBottom, i.style.overflow = "hidden";
      },
      afterEnter(i) {
        i.style.maxHeight = "", i.style.overflow = i.dataset.oldOverflow;
      },
      enterCancelled(i) {
        r(i);
      },
      beforeLeave(i) {
        i.dataset || (i.dataset = {}), i.dataset.oldPaddingTop = i.style.paddingTop, i.dataset.oldPaddingBottom = i.style.paddingBottom, i.dataset.oldOverflow = i.style.overflow, i.style.maxHeight = `${i.scrollHeight}px`, i.style.overflow = "hidden";
      },
      leave(i) {
        i.scrollHeight !== 0 && (i.style.maxHeight = 0, i.style.paddingTop = 0, i.style.paddingBottom = 0);
      },
      afterLeave(i) {
        r(i);
      },
      leaveCancelled(i) {
        r(i);
      }
    };
    return (i, s) => (R(), ue(po, Ko({
      name: _(t).b()
    }, bG(n)), {
      default: Y(() => [
        ke(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Y1 = /* @__PURE__ */ rt(J3e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
Y1.install = (e) => {
  e.component(Y1.name, Y1);
};
const Z3e = Y1, yq = Z3e, K3e = ht({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: Le([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: Le([String, Number])
  }
}), Y3e = {
  click: (e) => e instanceof MouseEvent
}, Q3e = "overlay";
var X3e = he({
  name: "ElOverlay",
  props: K3e,
  emits: Y3e,
  setup(e, { slots: t, emit: r }) {
    const n = Je(Q3e), i = (l) => {
      r("click", l);
    }, { onClick: s, onMousedown: o, onMouseup: a } = CB(e.customMaskEvent ? void 0 : i);
    return () => e.mask ? de("div", {
      class: [n.b(), e.overlayClass],
      style: {
        zIndex: e.zIndex
      },
      onClick: s,
      onMousedown: o,
      onMouseup: a
    }, [ke(t, "default")], q1.STYLE | q1.CLASS | q1.PROPS, ["onClick", "onMouseup", "onMousedown"]) : Ha("div", {
      class: e.overlayClass,
      style: {
        zIndex: e.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [ke(t, "default")]);
  }
});
const eMe = X3e, gq = Symbol("dialogInjectionKey"), vq = ht({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: Oi
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), tMe = {
  close: () => !0
}, rMe = ["aria-level"], nMe = ["aria-label"], iMe = ["id"], sMe = he({ name: "ElDialogContent" }), oMe = /* @__PURE__ */ he({
  ...sMe,
  props: vq,
  emits: tMe,
  setup(e) {
    const t = e, { t: r } = ap(), { Close: n } = dB, { dialogRef: i, headerRef: s, bodyId: o, ns: a, style: l } = ot(gq), { focusTrapRef: c } = ot(ZB), h = A(() => [
      a.b(),
      a.is("fullscreen", t.fullscreen),
      a.is("draggable", t.draggable),
      a.is("align-center", t.alignCenter),
      { [a.m("center")]: t.center },
      t.customClass
    ]), f = JSe(c, i), m = A(() => t.draggable);
    return t$e(i, s, m), (y, g) => (R(), Z("div", {
      ref: _(f),
      class: B(_(h)),
      style: $t(_(l)),
      tabindex: "-1"
    }, [
      K("header", {
        ref_key: "headerRef",
        ref: s,
        class: B(_(a).e("header"))
      }, [
        ke(y.$slots, "header", {}, () => [
          K("span", {
            role: "heading",
            "aria-level": y.ariaLevel,
            class: B(_(a).e("title"))
          }, Xe(y.title), 11, rMe)
        ]),
        y.showClose ? (R(), Z("button", {
          key: 0,
          "aria-label": _(r)("el.dialog.close"),
          class: B(_(a).e("headerbtn")),
          type: "button",
          onClick: g[0] || (g[0] = (v) => y.$emit("close"))
        }, [
          de(_(zt), {
            class: B(_(a).e("close"))
          }, {
            default: Y(() => [
              (R(), ue(gr(y.closeIcon || _(n))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, nMe)) : le("v-if", !0)
      ], 2),
      K("div", {
        id: _(o),
        class: B(_(a).e("body"))
      }, [
        ke(y.$slots, "default")
      ], 10, iMe),
      y.$slots.footer ? (R(), Z("footer", {
        key: 0,
        class: B(_(a).e("footer"))
      }, [
        ke(y.$slots, "footer")
      ], 2)) : le("v-if", !0)
    ], 6));
  }
});
var aMe = /* @__PURE__ */ rt(oMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const lMe = ht({
  ...vq,
  appendToBody: Boolean,
  appendTo: {
    type: Le(String),
    default: "body"
  },
  beforeClose: {
    type: Le(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), uMe = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [At]: (e) => Un(e),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, cMe = (e, t) => {
  var r;
  const i = nn().emit, { nextZIndex: s } = kC();
  let o = "";
  const a = ju(), l = ju(), c = q(!1), h = q(!1), f = q(!1), m = q((r = e.zIndex) != null ? r : s());
  let y, g;
  const v = a2("namespace", Ay), b = A(() => {
    const oe = {}, ye = `--${v.value}-dialog`;
    return e.fullscreen || (e.top && (oe[`${ye}-margin-top`] = e.top), e.width && (oe[`${ye}-width`] = cl(e.width))), oe;
  }), w = A(() => e.alignCenter ? { display: "flex" } : {});
  function x() {
    i("opened");
  }
  function $() {
    i("closed"), i(At, !1), e.destroyOnClose && (f.value = !1);
  }
  function T() {
    i("close");
  }
  function C() {
    g == null || g(), y == null || y(), e.openDelay && e.openDelay > 0 ? { stop: y } = ww(() => L(), e.openDelay) : L();
  }
  function I() {
    y == null || y(), g == null || g(), e.closeDelay && e.closeDelay > 0 ? { stop: g } = ww(() => N(), e.closeDelay) : N();
  }
  function O() {
    function oe(ye) {
      ye || (h.value = !0, c.value = !1);
    }
    e.beforeClose ? e.beforeClose(oe) : I();
  }
  function M() {
    e.closeOnClickModal && O();
  }
  function L() {
    Pt && (c.value = !0);
  }
  function N() {
    c.value = !1;
  }
  function ee() {
    i("openAutoFocus");
  }
  function D() {
    i("closeAutoFocus");
  }
  function H(oe) {
    var ye;
    ((ye = oe.detail) == null ? void 0 : ye.focusReason) === "pointer" && oe.preventDefault();
  }
  e.lockScroll && y$e(c);
  function J() {
    e.closeOnPressEscape && O();
  }
  return Se(() => e.modelValue, (oe) => {
    oe ? (h.value = !1, C(), f.value = !0, m.value = XU(e.zIndex) ? s() : m.value++, Ye(() => {
      i("open"), t.value && (t.value.scrollTop = 0);
    })) : c.value && I();
  }), Se(() => e.fullscreen, (oe) => {
    t.value && (oe ? (o = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = o);
  }), qt(() => {
    e.modelValue && (c.value = !0, f.value = !0, C());
  }), {
    afterEnter: x,
    afterLeave: $,
    beforeLeave: T,
    handleClose: O,
    onModalClick: M,
    close: I,
    doClose: N,
    onOpenAutoFocus: ee,
    onCloseAutoFocus: D,
    onCloseRequested: J,
    onFocusoutPrevented: H,
    titleId: a,
    bodyId: l,
    closed: h,
    style: b,
    overlayDialogStyle: w,
    rendered: f,
    visible: c,
    zIndex: m
  };
}, dMe = ["aria-label", "aria-labelledby", "aria-describedby"], pMe = he({
  name: "ElDialog",
  inheritAttrs: !1
}), hMe = /* @__PURE__ */ he({
  ...pMe,
  props: lMe,
  emits: uMe,
  setup(e, { expose: t }) {
    const r = e, n = ef();
    Sg({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, A(() => !!n.title)), Sg({
      scope: "el-dialog",
      from: "custom-class",
      replacement: "class",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
      type: "Attribute"
    }, A(() => !!r.customClass));
    const i = Je("dialog"), s = q(), o = q(), a = q(), {
      visible: l,
      titleId: c,
      bodyId: h,
      style: f,
      overlayDialogStyle: m,
      rendered: y,
      zIndex: g,
      afterEnter: v,
      afterLeave: b,
      beforeLeave: w,
      handleClose: x,
      onModalClick: $,
      onOpenAutoFocus: T,
      onCloseAutoFocus: C,
      onCloseRequested: I,
      onFocusoutPrevented: O
    } = cMe(r, s);
    cn(gq, {
      dialogRef: s,
      headerRef: o,
      bodyId: h,
      ns: i,
      rendered: y,
      style: f
    });
    const M = CB($), L = A(() => r.draggable && !r.fullscreen);
    return t({
      visible: l,
      dialogContentRef: a
    }), (N, ee) => (R(), ue(m5, {
      to: N.appendTo,
      disabled: N.appendTo !== "body" ? !1 : !N.appendToBody
    }, [
      de(po, {
        name: "dialog-fade",
        onAfterEnter: _(v),
        onAfterLeave: _(b),
        onBeforeLeave: _(w),
        persisted: ""
      }, {
        default: Y(() => [
          Yt(de(_(eMe), {
            "custom-mask-event": "",
            mask: N.modal,
            "overlay-class": N.modalClass,
            "z-index": _(g)
          }, {
            default: Y(() => [
              K("div", {
                role: "dialog",
                "aria-modal": "true",
                "aria-label": N.title || void 0,
                "aria-labelledby": N.title ? void 0 : _(c),
                "aria-describedby": _(h),
                class: B(`${_(i).namespace.value}-overlay-dialog`),
                style: $t(_(m)),
                onClick: ee[0] || (ee[0] = (...D) => _(M).onClick && _(M).onClick(...D)),
                onMousedown: ee[1] || (ee[1] = (...D) => _(M).onMousedown && _(M).onMousedown(...D)),
                onMouseup: ee[2] || (ee[2] = (...D) => _(M).onMouseup && _(M).onMouseup(...D))
              }, [
                de(_(YB), {
                  loop: "",
                  trapped: _(l),
                  "focus-start-el": "container",
                  onFocusAfterTrapped: _(T),
                  onFocusAfterReleased: _(C),
                  onFocusoutPrevented: _(O),
                  onReleaseRequested: _(I)
                }, {
                  default: Y(() => [
                    _(y) ? (R(), ue(aMe, Ko({
                      key: 0,
                      ref_key: "dialogContentRef",
                      ref: a
                    }, N.$attrs, {
                      "custom-class": N.customClass,
                      center: N.center,
                      "align-center": N.alignCenter,
                      "close-icon": N.closeIcon,
                      draggable: _(L),
                      fullscreen: N.fullscreen,
                      "show-close": N.showClose,
                      title: N.title,
                      "aria-level": N.headerAriaLevel,
                      onClose: _(x)
                    }), f$({
                      header: Y(() => [
                        N.$slots.title ? ke(N.$slots, "title", { key: 1 }) : ke(N.$slots, "header", {
                          key: 0,
                          close: _(x),
                          titleId: _(c),
                          titleClass: _(i).e("title")
                        })
                      ]),
                      default: Y(() => [
                        ke(N.$slots, "default")
                      ]),
                      _: 2
                    }, [
                      N.$slots.footer ? {
                        name: "footer",
                        fn: Y(() => [
                          ke(N.$slots, "footer")
                        ])
                      } : void 0
                    ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : le("v-if", !0)
                  ]),
                  _: 3
                }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ], 46, dMe)
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [
            [di, _(l)]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["to", "disabled"]));
  }
});
var fMe = /* @__PURE__ */ rt(hMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const mMe = fi(fMe), bq = Symbol("ElSelectGroup"), c2 = Symbol("ElSelect");
function yMe(e, t) {
  const r = ot(c2), n = ot(bq, { disabled: !1 }), i = A(() => En(e.value)), s = A(() => r.props.multiple ? f(r.props.modelValue, e.value) : m(e.value, r.props.modelValue)), o = A(() => {
    if (r.props.multiple) {
      const v = r.props.modelValue || [];
      return !s.value && v.length >= r.props.multipleLimit && r.props.multipleLimit > 0;
    } else
      return !1;
  }), a = A(() => e.label || (i.value ? "" : e.value)), l = A(() => e.value || e.label || ""), c = A(() => e.disabled || t.groupDisabled || o.value), h = nn(), f = (v = [], b) => {
    if (i.value) {
      const w = r.props.valueKey;
      return v && v.some((x) => Oh(ai(x, w)) === ai(b, w));
    } else
      return v && v.includes(b);
  }, m = (v, b) => {
    if (i.value) {
      const { valueKey: w } = r.props;
      return ai(v, w) === ai(b, w);
    } else
      return v === b;
  }, y = () => {
    !e.disabled && !n.disabled && (r.hoverIndex = r.optionsArray.indexOf(h.proxy));
  };
  Se(() => a.value, () => {
    !e.created && !r.props.remote && r.setSelected();
  }), Se(() => e.value, (v, b) => {
    const { remote: w, valueKey: x } = r.props;
    if (Object.is(v, b) || (r.onOptionDestroy(b, h.proxy), r.onOptionCreate(h.proxy)), !e.created && !w) {
      if (x && En(v) && En(b) && v[x] === b[x])
        return;
      r.setSelected();
    }
  }), Se(() => n.disabled, () => {
    t.groupDisabled = n.disabled;
  }, { immediate: !0 });
  const { queryChange: g } = Oh(r);
  return Se(g, (v) => {
    const { query: b } = _(v), w = new RegExp(ESe(b), "i");
    t.visible = w.test(a.value) || e.created, t.visible || r.filteredOptionsCount--;
  }, { immediate: !0 }), {
    select: r,
    currentLabel: a,
    currentValue: l,
    itemSelected: s,
    isDisabled: c,
    hoverItem: y
  };
}
const gMe = he({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(e) {
    const t = Je("select"), r = ju(), n = A(() => [
      t.be("dropdown", "item"),
      t.is("disabled", _(a)),
      {
        selected: _(o),
        hover: _(f)
      }
    ]), i = ci({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hitState: !1,
      hover: !1
    }), { currentLabel: s, itemSelected: o, isDisabled: a, select: l, hoverItem: c } = yMe(e, i), { visible: h, hover: f } = zu(i), m = nn().proxy;
    l.onOptionCreate(m), Ni(() => {
      const g = m.value, { selected: v } = l, w = (l.props.multiple ? v : [v]).some((x) => x.value === m.value);
      Ye(() => {
        l.cachedOptions.get(g) === m && !w && l.cachedOptions.delete(g);
      }), l.onOptionDestroy(g, m);
    });
    function y() {
      e.disabled !== !0 && i.groupDisabled !== !0 && l.handleOptionSelect(m);
    }
    return {
      ns: t,
      id: r,
      containerKls: n,
      currentLabel: s,
      itemSelected: o,
      isDisabled: a,
      select: l,
      hoverItem: c,
      visible: h,
      hover: f,
      selectOptionClick: y,
      states: i
    };
  }
}), vMe = ["id", "aria-disabled", "aria-selected"];
function bMe(e, t, r, n, i, s) {
  return Yt((R(), Z("li", {
    id: e.id,
    class: B(e.containerKls),
    role: "option",
    "aria-disabled": e.isDisabled || void 0,
    "aria-selected": e.itemSelected,
    onMouseenter: t[0] || (t[0] = (...o) => e.hoverItem && e.hoverItem(...o)),
    onClick: t[1] || (t[1] = kt((...o) => e.selectOptionClick && e.selectOptionClick(...o), ["stop"]))
  }, [
    ke(e.$slots, "default", {}, () => [
      K("span", null, Xe(e.currentLabel), 1)
    ])
  ], 42, vMe)), [
    [di, e.visible]
  ]);
}
var VC = /* @__PURE__ */ rt(gMe, [["render", bMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const wMe = he({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e = ot(c2), t = Je("select"), r = A(() => e.props.popperClass), n = A(() => e.props.multiple), i = A(() => e.props.fitInputWidth), s = q("");
    function o() {
      var a;
      s.value = `${(a = e.selectWrapper) == null ? void 0 : a.offsetWidth}px`;
    }
    return qt(() => {
      o(), ip(e.selectWrapper, o);
    }), {
      ns: t,
      minWidth: s,
      popperClass: r,
      isMultiple: n,
      isFitInputWidth: i
    };
  }
});
function _Me(e, t, r, n, i, s) {
  return R(), Z("div", {
    class: B([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
    style: $t({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
  }, [
    e.$slots.header ? (R(), Z("div", {
      key: 0,
      class: B(e.ns.be("dropdown", "header"))
    }, [
      ke(e.$slots, "header")
    ], 2)) : le("v-if", !0),
    ke(e.$slots, "default"),
    e.$slots.footer ? (R(), Z("div", {
      key: 1,
      class: B(e.ns.be("dropdown", "footer"))
    }, [
      ke(e.$slots, "footer")
    ], 2)) : le("v-if", !0)
  ], 6);
}
var SMe = /* @__PURE__ */ rt(wMe, [["render", _Me], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function $Me(e) {
  const { t } = ap();
  return ci({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: !1,
    selected: e.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: !1,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: !1,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: !1,
    isOnComposition: !1,
    prefixWidth: 11,
    mouseEnter: !1,
    focused: !1
  });
}
const xMe = (e, t, r) => {
  const { t: n } = ap(), i = Je("select");
  Sg({
    from: "suffixTransition",
    replacement: "override style scheme",
    version: "2.3.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
  }, A(() => e.suffixTransition === !1));
  const s = q(null), o = q(null), a = q(null), l = q(null), c = q(null), h = q(null), f = q(null), m = q(null), y = q(), g = fd({ query: "" }), v = fd(""), b = q([]);
  let w = 0;
  const { form: x, formItem: $ } = gl(), T = A(() => !e.filterable || e.multiple || !t.visible), C = A(() => e.disabled || (x == null ? void 0 : x.disabled)), I = A(() => {
    const V = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : e.modelValue !== void 0 && e.modelValue !== null && e.modelValue !== "";
    return e.clearable && !C.value && t.inputHovering && V;
  }), O = A(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), M = A(() => i.is("reverse", O.value && t.visible && e.suffixTransition)), L = A(() => (x == null ? void 0 : x.statusIcon) && ($ == null ? void 0 : $.validateState) && pB[$ == null ? void 0 : $.validateState]), N = A(() => e.remote ? 300 : 0), ee = A(() => e.loading ? e.loadingText || n("el.select.loading") : e.remote && t.query === "" && t.options.size === 0 ? !1 : e.filterable && t.query && t.options.size > 0 && t.filteredOptionsCount === 0 ? e.noMatchText || n("el.select.noMatch") : t.options.size === 0 ? e.noDataText || n("el.select.noData") : null), D = A(() => {
    const V = Array.from(t.options.values()), ie = [];
    return b.value.forEach((be) => {
      const Be = V.findIndex((sn) => sn.currentLabel === be);
      Be > -1 && ie.push(V[Be]);
    }), ie.length >= V.length ? ie : V;
  }), H = A(() => Array.from(t.cachedOptions.values())), J = A(() => {
    const V = D.value.filter((ie) => !ie.created).some((ie) => ie.currentLabel === t.query);
    return e.filterable && e.allowCreate && t.query !== "" && !V;
  }), oe = go(), ye = A(() => ["small"].includes(oe.value) ? "small" : "default"), Q = A({
    get() {
      return t.visible && ee.value !== !1;
    },
    set(V) {
      t.visible = V;
    }
  });
  Se([() => C.value, () => oe.value, () => x == null ? void 0 : x.size], () => {
    Ye(() => {
      ve();
    });
  }), Se(() => e.placeholder, (V) => {
    t.cachedPlaceHolder = t.currentPlaceholder = V, e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (t.currentPlaceholder = "");
  }), Se(() => e.modelValue, (V, ie) => {
    e.multiple && (ve(), V && V.length > 0 || o.value && t.query !== "" ? t.currentPlaceholder = "" : t.currentPlaceholder = t.cachedPlaceHolder, e.filterable && !e.reserveKeyword && (t.query = "", Ee(t.query))), Nt(), e.filterable && !e.multiple && (t.inputLength = 20), !Cu(V, ie) && e.validateEvent && ($ == null || $.validate("change").catch((be) => Ut(be)));
  }, {
    flush: "post",
    deep: !0
  }), Se(() => t.visible, (V) => {
    var ie, be, Be, sn, pn;
    V ? ((be = (ie = l.value) == null ? void 0 : ie.updatePopper) == null || be.call(ie), e.filterable && (t.filteredOptionsCount = t.optionsCount, t.query = e.remote ? "" : t.selectedLabel, (sn = (Be = a.value) == null ? void 0 : Be.focus) == null || sn.call(Be), e.multiple ? (pn = o.value) == null || pn.focus() : t.selectedLabel && (t.currentPlaceholder = `${t.selectedLabel}`, t.selectedLabel = ""), Ee(t.query), !e.multiple && !e.remote && (g.value.query = "", Rf(g), Rf(v)))) : (e.filterable && (er(e.filterMethod) && e.filterMethod(""), er(e.remoteMethod) && e.remoteMethod("")), t.query = "", t.previousQuery = null, t.selectedLabel = "", t.inputLength = 20, t.menuVisibleOnFocus = !1, wr(), Ye(() => {
      o.value && o.value.value === "" && t.selected.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
    }), e.multiple || (t.selected && (e.filterable && e.allowCreate && t.createdSelected && t.createdLabel ? t.selectedLabel = t.createdLabel : t.selectedLabel = t.selected.currentLabel, e.filterable && (t.query = t.selectedLabel)), e.filterable && (t.currentPlaceholder = t.cachedPlaceHolder))), r.emit("visible-change", V);
  }), Se(() => t.options.entries(), () => {
    var V, ie, be;
    if (!Pt)
      return;
    (ie = (V = l.value) == null ? void 0 : V.updatePopper) == null || ie.call(V), e.multiple && ve();
    const Be = ((be = f.value) == null ? void 0 : be.querySelectorAll("input")) || [];
    (!e.filterable && !e.defaultFirstOption && !Hh(e.modelValue) || !Array.from(Be).includes(document.activeElement)) && Nt(), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && ft();
  }, {
    flush: "post"
  }), Se(() => t.hoverIndex, (V) => {
    ar(V) && V > -1 ? y.value = D.value[V] || {} : y.value = {}, D.value.forEach((ie) => {
      ie.hover = y.value === ie;
    });
  });
  const ve = () => {
    Ye(() => {
      var V, ie;
      if (!s.value)
        return;
      const be = s.value.$el.querySelector("input");
      w = w || (be.clientHeight > 0 ? be.clientHeight + 2 : 0);
      const Be = h.value, sn = getComputedStyle(be).getPropertyValue(i.cssVarName("input-height")), pn = Number.parseFloat(sn) || KSe(oe.value || (x == null ? void 0 : x.size)), Kn = oe.value || pn === w || w <= 0 ? pn : w;
      !(be.offsetParent === null) && (be.style.height = `${(t.selected.length === 0 ? Kn : Math.max(Be ? Be.clientHeight + (Be.clientHeight > Kn ? 6 : 0) : 0, Kn)) - 2}px`), t.visible && ee.value !== !1 && ((ie = (V = l.value) == null ? void 0 : V.updatePopper) == null || ie.call(V));
    });
  }, Ee = async (V) => {
    if (!(t.previousQuery === V || t.isOnComposition)) {
      if (t.previousQuery === null && (er(e.filterMethod) || er(e.remoteMethod))) {
        t.previousQuery = V;
        return;
      }
      t.previousQuery = V, Ye(() => {
        var ie, be;
        t.visible && ((be = (ie = l.value) == null ? void 0 : ie.updatePopper) == null || be.call(ie));
      }), t.hoverIndex = -1, e.multiple && e.filterable && Ye(() => {
        if (!C.value) {
          const ie = o.value.value.length * 15 + 20;
          t.inputLength = e.collapseTags ? Math.min(50, ie) : ie, Lt();
        }
        ve();
      }), e.remote && er(e.remoteMethod) ? (t.hoverIndex = -1, e.remoteMethod(V)) : er(e.filterMethod) ? (e.filterMethod(V), Rf(v)) : (t.filteredOptionsCount = t.optionsCount, g.value.query = V, Rf(g), Rf(v)), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && (await Ye(), ft());
    }
  }, Lt = () => {
    t.currentPlaceholder !== "" && (t.currentPlaceholder = o.value.value ? "" : t.cachedPlaceHolder);
  }, ft = () => {
    const V = D.value.filter((Be) => Be.visible && !Be.disabled && !Be.states.groupDisabled), ie = V.find((Be) => Be.created), be = V[0];
    t.hoverIndex = On(D.value, ie || be);
  }, Nt = () => {
    var V;
    if (e.multiple)
      t.selectedLabel = "";
    else {
      const be = ir(e.modelValue);
      (V = be.props) != null && V.created ? (t.createdLabel = be.props.value, t.createdSelected = !0) : t.createdSelected = !1, t.selectedLabel = be.currentLabel, t.selected = be, e.filterable && (t.query = t.selectedLabel);
      return;
    }
    const ie = [];
    Array.isArray(e.modelValue) && e.modelValue.forEach((be) => {
      ie.push(ir(be));
    }), t.selected = ie, Ye(() => {
      ve();
    });
  }, ir = (V) => {
    let ie;
    const be = WS(V).toLowerCase() === "object", Be = WS(V).toLowerCase() === "null", sn = WS(V).toLowerCase() === "undefined";
    for (let Vi = t.cachedOptions.size - 1; Vi >= 0; Vi--) {
      const Yn = H.value[Vi];
      if (be ? ai(Yn.value, e.valueKey) === ai(V, e.valueKey) : Yn.value === V) {
        ie = {
          value: V,
          currentLabel: Yn.currentLabel,
          isDisabled: Yn.isDisabled
        };
        break;
      }
    }
    if (ie)
      return ie;
    const pn = be ? V.label : !Be && !sn ? V : "", Kn = {
      value: V,
      currentLabel: pn
    };
    return e.multiple && (Kn.hitState = !1), Kn;
  }, wr = () => {
    setTimeout(() => {
      const V = e.valueKey;
      e.multiple ? t.selected.length > 0 ? t.hoverIndex = Math.min.apply(null, t.selected.map((ie) => D.value.findIndex((be) => ai(be, V) === ai(ie, V)))) : t.hoverIndex = -1 : t.hoverIndex = D.value.findIndex((ie) => _e(ie) === _e(t.selected));
    }, 300);
  }, _r = () => {
    var V, ie;
    Pr(), (ie = (V = l.value) == null ? void 0 : V.updatePopper) == null || ie.call(V), e.multiple && ve();
  }, Pr = () => {
    var V;
    t.inputWidth = (V = s.value) == null ? void 0 : V.$el.offsetWidth;
  }, xe = () => {
    e.filterable && t.query !== t.selectedLabel && (t.query = t.selectedLabel, Ee(t.query));
  }, Ne = qI(() => {
    xe();
  }, N.value), He = qI((V) => {
    Ee(V.target.value);
  }, N.value), nt = (V) => {
    Cu(e.modelValue, V) || r.emit(aa, V);
  }, wt = (V) => gSe(V, (ie) => !t.disabledOptions.has(ie)), cr = (V) => {
    if (V.code !== Xt.delete) {
      if (V.target.value.length <= 0 && !kn()) {
        const ie = e.modelValue.slice(), be = wt(ie);
        if (be < 0)
          return;
        ie.splice(be, 1), r.emit(At, ie), nt(ie);
      }
      V.target.value.length === 1 && e.modelValue.length === 0 && (t.currentPlaceholder = t.cachedPlaceHolder);
    }
  }, qr = (V, ie) => {
    const be = t.selected.indexOf(ie);
    if (be > -1 && !C.value) {
      const Be = e.modelValue.slice();
      Be.splice(be, 1), r.emit(At, Be), nt(Be), r.emit("remove-tag", ie.value);
    }
    V.stopPropagation(), Fe();
  }, mi = (V) => {
    V.stopPropagation();
    const ie = e.multiple ? [] : "";
    if (!nr(ie))
      for (const be of t.selected)
        be.isDisabled && ie.push(be.value);
    r.emit(At, ie), nt(ie), t.hoverIndex = -1, t.visible = !1, r.emit("clear"), Fe();
  }, Gn = (V) => {
    var ie;
    if (e.multiple) {
      const be = (e.modelValue || []).slice(), Be = On(be, V.value);
      Be > -1 ? be.splice(Be, 1) : (e.multipleLimit <= 0 || be.length < e.multipleLimit) && be.push(V.value), r.emit(At, be), nt(be), V.created && (t.query = "", Ee(""), t.inputLength = 20), e.filterable && ((ie = o.value) == null || ie.focus());
    } else
      r.emit(At, V.value), nt(V.value), t.visible = !1;
    Hn(), !t.visible && Ye(() => {
      Cn(V);
    });
  }, On = (V = [], ie) => {
    if (!En(ie))
      return V.indexOf(ie);
    const be = e.valueKey;
    let Be = -1;
    return V.some((sn, pn) => Oh(ai(sn, be)) === ai(ie, be) ? (Be = pn, !0) : !1), Be;
  }, Hn = () => {
    const V = o.value || s.value;
    V && (V == null || V.focus());
  }, Cn = (V) => {
    var ie, be, Be, sn, pn;
    const Kn = Array.isArray(V) ? V[0] : V;
    let Vi = null;
    if (Kn != null && Kn.value) {
      const Yn = D.value.filter((up) => up.value === Kn.value);
      Yn.length > 0 && (Vi = Yn[0].$el);
    }
    if (l.value && Vi) {
      const Yn = (sn = (Be = (be = (ie = l.value) == null ? void 0 : ie.popperRef) == null ? void 0 : be.contentRef) == null ? void 0 : Be.querySelector) == null ? void 0 : sn.call(Be, `.${i.be("dropdown", "wrap")}`);
      Yn && nB(Yn, Vi);
    }
    (pn = m.value) == null || pn.handleScroll();
  }, yi = (V) => {
    t.optionsCount++, t.filteredOptionsCount++, t.options.set(V.value, V), t.cachedOptions.set(V.value, V), V.disabled && t.disabledOptions.set(V.value, V);
  }, dr = (V, ie) => {
    t.options.get(V) === ie && (t.optionsCount--, t.filteredOptionsCount--, t.options.delete(V));
  }, Wn = (V) => {
    V.code !== Xt.backspace && kn(!1), t.inputLength = o.value.value.length * 15 + 20, ve();
  }, kn = (V) => {
    if (!Array.isArray(t.selected))
      return;
    const ie = wt(t.selected.map((Be) => Be.value)), be = t.selected[ie];
    if (be)
      return V === !0 || V === !1 ? (be.hitState = V, V) : (be.hitState = !be.hitState, be.hitState);
  }, Jn = (V) => {
    const ie = V.target.value;
    if (V.type === "compositionend")
      t.isOnComposition = !1, Ye(() => Ee(ie));
    else {
      const be = ie[ie.length - 1] || "";
      t.isOnComposition = !SC(be);
    }
  }, Zn = () => {
    Ye(() => Cn(t.selected));
  }, ae = (V) => {
    t.focused || ((e.automaticDropdown || e.filterable) && (e.filterable && !t.visible && (t.menuVisibleOnFocus = !0), t.visible = !0), t.focused = !0, r.emit("focus", V));
  }, Fe = () => {
    var V, ie;
    t.visible ? (V = o.value || s.value) == null || V.focus() : (ie = s.value) == null || ie.focus();
  }, at = () => {
    var V, ie, be;
    t.visible = !1, (V = s.value) == null || V.blur(), (be = (ie = a.value) == null ? void 0 : ie.blur) == null || be.call(ie);
  }, pr = (V) => {
    var ie, be, Be;
    (ie = l.value) != null && ie.isFocusInsideContent(V) || (be = c.value) != null && be.isFocusInsideContent(V) || (Be = f.value) != null && Be.contains(V.relatedTarget) || (t.visible && Is(), t.focused = !1, r.emit("blur", V));
  }, gi = (V) => {
    mi(V);
  }, Is = () => {
    t.visible = !1;
  }, wo = (V) => {
    t.visible && (V.preventDefault(), V.stopPropagation(), t.visible = !1);
  }, te = (V) => {
    V && !t.mouseEnter || C.value || (t.menuVisibleOnFocus ? t.menuVisibleOnFocus = !1 : (!l.value || !l.value.isFocusInsideContent()) && (t.visible = !t.visible), Fe());
  }, fe = () => {
    t.visible ? D.value[t.hoverIndex] && Gn(D.value[t.hoverIndex]) : te();
  }, _e = (V) => En(V.value) ? ai(V.value, e.valueKey) : V.value, ct = A(() => D.value.filter((V) => V.visible).every((V) => V.disabled)), An = A(() => e.multiple ? t.selected.slice(0, e.maxCollapseTags) : []), Gr = A(() => e.multiple ? t.selected.slice(e.maxCollapseTags) : []), dn = (V) => {
    if (!t.visible) {
      t.visible = !0;
      return;
    }
    if (!(t.options.size === 0 || t.filteredOptionsCount === 0) && !t.isOnComposition && !ct.value) {
      V === "next" ? (t.hoverIndex++, t.hoverIndex === t.options.size && (t.hoverIndex = 0)) : V === "prev" && (t.hoverIndex--, t.hoverIndex < 0 && (t.hoverIndex = t.options.size - 1));
      const ie = D.value[t.hoverIndex];
      (ie.disabled === !0 || ie.states.groupDisabled === !0 || !ie.visible) && dn(V), Ye(() => Cn(y.value));
    }
  }, Cf = () => {
    t.mouseEnter = !0;
  }, lp = () => {
    t.mouseEnter = !1;
  }, kf = (V, ie) => {
    var be, Be;
    qr(V, ie), (Be = (be = c.value) == null ? void 0 : be.updatePopper) == null || Be.call(be);
  }, Af = A(() => ({
    maxWidth: `${_(t.inputWidth) - 32 - (L.value ? 22 : 0)}px`,
    width: "100%"
  }));
  return {
    optionList: b,
    optionsArray: D,
    hoverOption: y,
    selectSize: oe,
    handleResize: _r,
    debouncedOnInputChange: Ne,
    debouncedQueryChange: He,
    deletePrevTag: cr,
    deleteTag: qr,
    deleteSelected: mi,
    handleOptionSelect: Gn,
    scrollToOption: Cn,
    readonly: T,
    resetInputHeight: ve,
    showClose: I,
    iconComponent: O,
    iconReverse: M,
    showNewOption: J,
    collapseTagSize: ye,
    setSelected: Nt,
    managePlaceholder: Lt,
    selectDisabled: C,
    emptyText: ee,
    toggleLastOptionHitState: kn,
    resetInputState: Wn,
    handleComposition: Jn,
    onOptionCreate: yi,
    onOptionDestroy: dr,
    handleMenuEnter: Zn,
    handleFocus: ae,
    focus: Fe,
    blur: at,
    handleBlur: pr,
    handleClearClick: gi,
    handleClose: Is,
    handleKeydownEscape: wo,
    toggleMenu: te,
    selectOption: fe,
    getValueKey: _e,
    navigateOptions: dn,
    handleDeleteTooltipTag: kf,
    dropMenuVisible: Q,
    queryChange: g,
    groupQueryChange: v,
    showTagList: An,
    collapseTagList: Gr,
    selectTagsStyle: Af,
    reference: s,
    input: o,
    iOSInput: a,
    tooltipRef: l,
    tagTooltipRef: c,
    tags: h,
    selectWrapper: f,
    scrollbar: m,
    handleMouseEnter: Cf,
    handleMouseLeave: lp
  };
};
var TMe = he({
  name: "ElOptions",
  emits: ["update-options"],
  setup(e, { slots: t, emit: r }) {
    let n = [];
    function i(s, o) {
      if (s.length !== o.length)
        return !1;
      for (const [a] of s.entries())
        if (s[a] != o[a])
          return !1;
      return !0;
    }
    return () => {
      var s, o;
      const a = (s = t.default) == null ? void 0 : s.call(t), l = [];
      function c(h) {
        Array.isArray(h) && h.forEach((f) => {
          var m, y, g, v;
          const b = (m = (f == null ? void 0 : f.type) || {}) == null ? void 0 : m.name;
          b === "ElOptionGroup" ? c(!nr(f.children) && !Array.isArray(f.children) && er((y = f.children) == null ? void 0 : y.default) ? (g = f.children) == null ? void 0 : g.default() : f.children) : b === "ElOption" ? l.push((v = f.props) == null ? void 0 : v.label) : Array.isArray(f.children) && c(f.children);
        });
      }
      return a.length && c((o = a[0]) == null ? void 0 : o.children), i(l, n) || (n = l, r("update-options", l)), a;
    };
  }
});
const CN = "ElSelect", EMe = he({
  name: CN,
  componentName: CN,
  components: {
    ElInput: UB,
    ElSelectMenu: SMe,
    ElOption: VC,
    ElOptions: TMe,
    ElTag: d3,
    ElScrollbar: PC,
    ElTooltip: s3,
    ElIcon: zt
  },
  directives: { ClickOutside: nq },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: fB
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: u2.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: Oi,
      default: r2
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: Oi,
      default: iB
    },
    tagType: { ...jC.type, default: "info" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    suffixTransition: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: String,
      values: s2,
      default: "bottom-start"
    },
    ariaLabel: {
      type: String,
      default: void 0
    }
  },
  emits: [
    At,
    aa,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const r = Je("select"), n = Je("input"), { t: i } = ap(), s = ju(), o = $Me(e), {
      optionList: a,
      optionsArray: l,
      hoverOption: c,
      selectSize: h,
      readonly: f,
      handleResize: m,
      collapseTagSize: y,
      debouncedOnInputChange: g,
      debouncedQueryChange: v,
      deletePrevTag: b,
      deleteTag: w,
      deleteSelected: x,
      handleOptionSelect: $,
      scrollToOption: T,
      setSelected: C,
      resetInputHeight: I,
      managePlaceholder: O,
      showClose: M,
      selectDisabled: L,
      iconComponent: N,
      iconReverse: ee,
      showNewOption: D,
      emptyText: H,
      toggleLastOptionHitState: J,
      resetInputState: oe,
      handleComposition: ye,
      onOptionCreate: Q,
      onOptionDestroy: ve,
      handleMenuEnter: Ee,
      handleFocus: Lt,
      focus: ft,
      blur: Nt,
      handleBlur: ir,
      handleClearClick: wr,
      handleClose: _r,
      handleKeydownEscape: Pr,
      toggleMenu: xe,
      selectOption: Ne,
      getValueKey: He,
      navigateOptions: nt,
      handleDeleteTooltipTag: wt,
      dropMenuVisible: cr,
      reference: qr,
      input: mi,
      iOSInput: Gn,
      tooltipRef: On,
      tagTooltipRef: Hn,
      tags: Cn,
      selectWrapper: yi,
      scrollbar: dr,
      queryChange: Wn,
      groupQueryChange: kn,
      handleMouseEnter: Jn,
      handleMouseLeave: Zn,
      showTagList: ae,
      collapseTagList: Fe,
      selectTagsStyle: at
    } = xMe(e, o, t), {
      inputWidth: pr,
      selected: gi,
      inputLength: Is,
      filteredOptionsCount: wo,
      visible: te,
      selectedLabel: fe,
      hoverIndex: _e,
      query: ct,
      inputHovering: An,
      currentPlaceholder: Gr,
      menuVisibleOnFocus: dn,
      isOnComposition: Cf,
      options: lp,
      cachedOptions: kf,
      optionsCount: Af,
      prefixWidth: V
    } = zu(o), ie = A(() => {
      const it = [r.b()], zi = _(h);
      return zi && it.push(r.m(zi)), e.disabled && it.push(r.m("disabled")), it;
    }), be = A(() => [
      r.e("tags"),
      r.is("disabled", _(L))
    ]), Be = A(() => [
      r.b("tags-wrapper"),
      { "has-prefix": _(V) && _(gi).length }
    ]), sn = A(() => [
      r.e("input"),
      r.is(_(h)),
      r.is("disabled", _(L))
    ]), pn = A(() => [
      r.e("input"),
      r.is(_(h)),
      r.em("input", "iOS")
    ]), Kn = A(() => [
      r.is("empty", !e.allowCreate && !!_(ct) && _(wo) === 0)
    ]), Vi = A(() => ({ maxWidth: `${_(pr) > 123 && _(gi).length > e.maxCollapseTags ? _(pr) - 123 : _(pr) - 75}px` })), Yn = A(() => ({
      marginLeft: `${_(V)}px`,
      flexGrow: 1,
      width: `${_(Is) / (_(pr) - 32)}%`,
      maxWidth: `${_(pr) - 42}px`
    }));
    cn(c2, ci({
      props: e,
      options: lp,
      optionsArray: l,
      cachedOptions: kf,
      optionsCount: Af,
      filteredOptionsCount: wo,
      hoverIndex: _e,
      handleOptionSelect: $,
      onOptionCreate: Q,
      onOptionDestroy: ve,
      selectWrapper: yi,
      selected: gi,
      setSelected: C,
      queryChange: Wn,
      groupQueryChange: kn
    })), qt(() => {
      o.cachedPlaceHolder = Gr.value = e.placeholder || (() => i("el.select.placeholder")), e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (Gr.value = ""), ip(yi, m), e.remote && e.multiple && I(), Ye(() => {
        const it = qr.value && qr.value.$el;
        if (it && (pr.value = it.getBoundingClientRect().width, t.slots.prefix)) {
          const zi = it.querySelector(`.${n.e("prefix")}`);
          V.value = Math.max(zi.getBoundingClientRect().width + 11, 30);
        }
      }), C();
    }), e.multiple && !Array.isArray(e.modelValue) && t.emit(At, []), !e.multiple && Array.isArray(e.modelValue) && t.emit(At, "");
    const up = A(() => {
      var it, zi;
      return (zi = (it = On.value) == null ? void 0 : it.popperRef) == null ? void 0 : zi.contentRef;
    });
    return {
      isIOS: TU,
      onOptionsRendered: (it) => {
        a.value = it;
      },
      prefixWidth: V,
      selectSize: h,
      readonly: f,
      handleResize: m,
      collapseTagSize: y,
      debouncedOnInputChange: g,
      debouncedQueryChange: v,
      deletePrevTag: b,
      deleteTag: w,
      handleDeleteTooltipTag: wt,
      deleteSelected: x,
      handleOptionSelect: $,
      scrollToOption: T,
      inputWidth: pr,
      selected: gi,
      inputLength: Is,
      filteredOptionsCount: wo,
      visible: te,
      selectedLabel: fe,
      hoverIndex: _e,
      query: ct,
      inputHovering: An,
      currentPlaceholder: Gr,
      menuVisibleOnFocus: dn,
      isOnComposition: Cf,
      options: lp,
      resetInputHeight: I,
      managePlaceholder: O,
      showClose: M,
      selectDisabled: L,
      iconComponent: N,
      iconReverse: ee,
      showNewOption: D,
      emptyText: H,
      toggleLastOptionHitState: J,
      resetInputState: oe,
      handleComposition: ye,
      handleMenuEnter: Ee,
      handleFocus: Lt,
      focus: ft,
      blur: Nt,
      handleBlur: ir,
      handleClearClick: wr,
      handleClose: _r,
      handleKeydownEscape: Pr,
      toggleMenu: xe,
      selectOption: Ne,
      getValueKey: He,
      navigateOptions: nt,
      dropMenuVisible: cr,
      reference: qr,
      input: mi,
      iOSInput: Gn,
      tooltipRef: On,
      popperPaneRef: up,
      tags: Cn,
      selectWrapper: yi,
      scrollbar: dr,
      wrapperKls: ie,
      tagsKls: be,
      tagWrapperKls: Be,
      inputKls: sn,
      iOSInputKls: pn,
      scrollbarKls: Kn,
      selectTagsStyle: at,
      nsSelect: r,
      tagTextStyle: Vi,
      inputStyle: Yn,
      handleMouseEnter: Jn,
      handleMouseLeave: Zn,
      showTagList: ae,
      collapseTagList: Fe,
      tagTooltipRef: Hn,
      contentId: s,
      hoverOption: c
    };
  }
}), IMe = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], MMe = ["disabled"], OMe = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
function CMe(e, t, r, n, i, s) {
  const o = Or("el-tag"), a = Or("el-tooltip"), l = Or("el-icon"), c = Or("el-input"), h = Or("el-option"), f = Or("el-options"), m = Or("el-scrollbar"), y = Or("el-select-menu"), g = wG("click-outside");
  return Yt((R(), Z("div", {
    ref: "selectWrapper",
    class: B(e.wrapperKls),
    onMouseenter: t[22] || (t[22] = (...v) => e.handleMouseEnter && e.handleMouseEnter(...v)),
    onMouseleave: t[23] || (t[23] = (...v) => e.handleMouseLeave && e.handleMouseLeave(...v)),
    onClick: t[24] || (t[24] = kt((...v) => e.toggleMenu && e.toggleMenu(...v), ["stop"]))
  }, [
    de(a, {
      ref: "tooltipRef",
      visible: e.dropMenuVisible,
      placement: e.placement,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "popper-options": e.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: e.effect,
      pure: "",
      trigger: "click",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: e.persistent,
      onShow: e.handleMenuEnter
    }, {
      default: Y(() => {
        var v, b;
        return [
          K("div", {
            class: "select-trigger",
            onMouseenter: t[20] || (t[20] = (w) => e.inputHovering = !0),
            onMouseleave: t[21] || (t[21] = (w) => e.inputHovering = !1)
          }, [
            e.multiple ? (R(), Z("div", {
              key: 0,
              ref: "tags",
              tabindex: "-1",
              class: B(e.tagsKls),
              style: $t(e.selectTagsStyle),
              onClick: t[15] || (t[15] = (...w) => e.focus && e.focus(...w))
            }, [
              e.collapseTags && e.selected.length ? (R(), ue(po, {
                key: 0,
                onAfterLeave: e.resetInputHeight
              }, {
                default: Y(() => [
                  K("span", {
                    class: B(e.tagWrapperKls)
                  }, [
                    (R(!0), Z(Mt, null, Mi(e.showTagList, (w) => (R(), ue(o, {
                      key: e.getValueKey(w),
                      closable: !e.selectDisabled && !w.isDisabled,
                      size: e.collapseTagSize,
                      hit: w.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (x) => e.deleteTag(x, w)
                    }, {
                      default: Y(() => [
                        K("span", {
                          class: B(e.nsSelect.e("tags-text")),
                          style: $t(e.tagTextStyle)
                        }, Xe(w.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128)),
                    e.selected.length > e.maxCollapseTags ? (R(), ue(o, {
                      key: 0,
                      closable: !1,
                      size: e.collapseTagSize,
                      type: e.tagType,
                      "disable-transitions": ""
                    }, {
                      default: Y(() => [
                        e.collapseTagsTooltip ? (R(), ue(a, {
                          key: 0,
                          ref: "tagTooltipRef",
                          disabled: e.dropMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: e.effect,
                          placement: "bottom",
                          teleported: e.teleported
                        }, {
                          default: Y(() => [
                            K("span", {
                              class: B(e.nsSelect.e("tags-text"))
                            }, "+ " + Xe(e.selected.length - e.maxCollapseTags), 3)
                          ]),
                          content: Y(() => [
                            K("div", {
                              class: B(e.nsSelect.e("collapse-tags"))
                            }, [
                              (R(!0), Z(Mt, null, Mi(e.collapseTagList, (w) => (R(), Z("div", {
                                key: e.getValueKey(w),
                                class: B(e.nsSelect.e("collapse-tag"))
                              }, [
                                de(o, {
                                  class: "in-tooltip",
                                  closable: !e.selectDisabled && !w.isDisabled,
                                  size: e.collapseTagSize,
                                  hit: w.hitState,
                                  type: e.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: (x) => e.handleDeleteTooltipTag(x, w)
                                }, {
                                  default: Y(() => [
                                    K("span", {
                                      class: B(e.nsSelect.e("tags-text")),
                                      style: $t({
                                        maxWidth: e.inputWidth - 75 + "px"
                                      })
                                    }, Xe(w.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"])
                              ], 2))), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect", "teleported"])) : (R(), Z("span", {
                          key: 1,
                          class: B(e.nsSelect.e("tags-text"))
                        }, "+ " + Xe(e.selected.length - e.maxCollapseTags), 3))
                      ]),
                      _: 1
                    }, 8, ["size", "type"])) : le("v-if", !0)
                  ], 2)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])) : le("v-if", !0),
              e.collapseTags ? le("v-if", !0) : (R(), ue(po, {
                key: 1,
                onAfterLeave: e.resetInputHeight
              }, {
                default: Y(() => [
                  K("span", {
                    class: B(e.tagWrapperKls),
                    style: $t(e.prefixWidth && e.selected.length ? { marginLeft: `${e.prefixWidth}px` } : "")
                  }, [
                    (R(!0), Z(Mt, null, Mi(e.selected, (w) => (R(), ue(o, {
                      key: e.getValueKey(w),
                      closable: !e.selectDisabled && !w.isDisabled,
                      size: e.collapseTagSize,
                      hit: w.hitState,
                      type: e.tagType,
                      "disable-transitions": "",
                      onClose: (x) => e.deleteTag(x, w)
                    }, {
                      default: Y(() => [
                        K("span", {
                          class: B(e.nsSelect.e("tags-text")),
                          style: $t({ maxWidth: e.inputWidth - 75 + "px" })
                        }, Xe(w.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]))), 128))
                  ], 6)
                ]),
                _: 1
              }, 8, ["onAfterLeave"])),
              e.filterable && !e.selectDisabled ? Yt((R(), Z("input", {
                key: 2,
                ref: "input",
                "onUpdate:modelValue": t[0] || (t[0] = (w) => e.query = w),
                type: "text",
                class: B(e.inputKls),
                disabled: e.selectDisabled,
                autocomplete: e.autocomplete,
                style: $t(e.inputStyle),
                role: "combobox",
                "aria-activedescendant": ((v = e.hoverOption) == null ? void 0 : v.id) || "",
                "aria-controls": e.contentId,
                "aria-expanded": e.dropMenuVisible,
                "aria-label": e.ariaLabel,
                "aria-autocomplete": "none",
                "aria-haspopup": "listbox",
                onFocus: t[1] || (t[1] = (...w) => e.handleFocus && e.handleFocus(...w)),
                onBlur: t[2] || (t[2] = (...w) => e.handleBlur && e.handleBlur(...w)),
                onKeyup: t[3] || (t[3] = (...w) => e.managePlaceholder && e.managePlaceholder(...w)),
                onKeydown: [
                  t[4] || (t[4] = (...w) => e.resetInputState && e.resetInputState(...w)),
                  t[5] || (t[5] = $i(kt((w) => e.navigateOptions("next"), ["prevent"]), ["down"])),
                  t[6] || (t[6] = $i(kt((w) => e.navigateOptions("prev"), ["prevent"]), ["up"])),
                  t[7] || (t[7] = $i((...w) => e.handleKeydownEscape && e.handleKeydownEscape(...w), ["esc"])),
                  t[8] || (t[8] = $i(kt((...w) => e.selectOption && e.selectOption(...w), ["stop", "prevent"]), ["enter"])),
                  t[9] || (t[9] = $i((...w) => e.deletePrevTag && e.deletePrevTag(...w), ["delete"])),
                  t[10] || (t[10] = $i((w) => e.visible = !1, ["tab"]))
                ],
                onCompositionstart: t[11] || (t[11] = (...w) => e.handleComposition && e.handleComposition(...w)),
                onCompositionupdate: t[12] || (t[12] = (...w) => e.handleComposition && e.handleComposition(...w)),
                onCompositionend: t[13] || (t[13] = (...w) => e.handleComposition && e.handleComposition(...w)),
                onInput: t[14] || (t[14] = (...w) => e.debouncedQueryChange && e.debouncedQueryChange(...w))
              }, null, 46, IMe)), [
                [g5, e.query]
              ]) : le("v-if", !0)
            ], 6)) : le("v-if", !0),
            e.isIOS && !e.multiple && e.filterable && e.readonly ? (R(), Z("input", {
              key: 1,
              ref: "iOSInput",
              class: B(e.iOSInputKls),
              disabled: e.selectDisabled,
              type: "text"
            }, null, 10, MMe)) : le("v-if", !0),
            de(c, {
              id: e.id,
              ref: "reference",
              modelValue: e.selectedLabel,
              "onUpdate:modelValue": t[16] || (t[16] = (w) => e.selectedLabel = w),
              type: "text",
              placeholder: typeof e.currentPlaceholder == "function" ? e.currentPlaceholder() : e.currentPlaceholder,
              name: e.name,
              autocomplete: e.autocomplete,
              size: e.selectSize,
              disabled: e.selectDisabled,
              readonly: e.readonly,
              "validate-event": !1,
              class: B([e.nsSelect.is("focus", e.visible)]),
              tabindex: e.multiple && e.filterable ? -1 : void 0,
              role: "combobox",
              "aria-activedescendant": ((b = e.hoverOption) == null ? void 0 : b.id) || "",
              "aria-controls": e.contentId,
              "aria-expanded": e.dropMenuVisible,
              label: e.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: e.handleFocus,
              onBlur: e.handleBlur,
              onInput: e.debouncedOnInputChange,
              onPaste: e.debouncedOnInputChange,
              onCompositionstart: e.handleComposition,
              onCompositionupdate: e.handleComposition,
              onCompositionend: e.handleComposition,
              onKeydown: [
                t[17] || (t[17] = $i(kt((w) => e.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                t[18] || (t[18] = $i(kt((w) => e.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                $i(kt(e.selectOption, ["stop", "prevent"]), ["enter"]),
                $i(e.handleKeydownEscape, ["esc"]),
                t[19] || (t[19] = $i((w) => e.visible = !1, ["tab"]))
              ]
            }, f$({
              suffix: Y(() => [
                e.iconComponent && !e.showClose ? (R(), ue(l, {
                  key: 0,
                  class: B([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
                }, {
                  default: Y(() => [
                    (R(), ue(gr(e.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : le("v-if", !0),
                e.showClose && e.clearIcon ? (R(), ue(l, {
                  key: 1,
                  class: B([e.nsSelect.e("caret"), e.nsSelect.e("icon")]),
                  onClick: e.handleClearClick
                }, {
                  default: Y(() => [
                    (R(), ue(gr(e.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : le("v-if", !0)
              ]),
              _: 2
            }, [
              e.$slots.prefix ? {
                name: "prefix",
                fn: Y(() => [
                  K("div", OMe, [
                    ke(e.$slots, "prefix")
                  ])
                ])
              } : void 0
            ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
          ], 32)
        ];
      }),
      content: Y(() => [
        de(y, null, f$({
          default: Y(() => [
            Yt(de(m, {
              id: e.contentId,
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": e.nsSelect.be("dropdown", "wrap"),
              "view-class": e.nsSelect.be("dropdown", "list"),
              class: B(e.scrollbarKls),
              role: "listbox",
              "aria-label": e.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: Y(() => [
                e.showNewOption ? (R(), ue(h, {
                  key: 0,
                  value: e.query,
                  created: !0
                }, null, 8, ["value"])) : le("v-if", !0),
                de(f, { onUpdateOptions: e.onOptionsRendered }, {
                  default: Y(() => [
                    ke(e.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["onUpdateOptions"])
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [di, e.options.size > 0 && !e.loading]
            ]),
            e.emptyText && (!e.allowCreate || e.loading || e.allowCreate && e.options.size === 0) ? (R(), Z(Mt, { key: 0 }, [
              e.$slots.empty ? ke(e.$slots, "empty", { key: 0 }) : (R(), Z("p", {
                key: 1,
                class: B(e.nsSelect.be("dropdown", "empty"))
              }, Xe(e.emptyText), 3))
            ], 64)) : le("v-if", !0)
          ]),
          _: 2
        }, [
          e.$slots.header ? {
            name: "header",
            fn: Y(() => [
              ke(e.$slots, "header")
            ])
          } : void 0,
          e.$slots.footer ? {
            name: "footer",
            fn: Y(() => [
              ke(e.$slots, "footer")
            ])
          } : void 0
        ]), 1024)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
  ], 34)), [
    [g, e.handleClose, e.popperPaneRef]
  ]);
}
var kMe = /* @__PURE__ */ rt(EMe, [["render", CMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const AMe = he({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e) {
    const t = Je("select"), r = q(!0), n = nn(), i = q([]);
    cn(bq, ci({
      ...zu(e)
    }));
    const s = ot(c2);
    qt(() => {
      i.value = o(n.subTree);
    });
    const o = (l) => {
      const c = [];
      return Array.isArray(l.children) && l.children.forEach((h) => {
        var f;
        h.type && h.type.name === "ElOption" && h.component && h.component.proxy ? c.push(h.component.proxy) : (f = h.children) != null && f.length && c.push(...o(h));
      }), c;
    }, { groupQueryChange: a } = Oh(s);
    return Se(a, () => {
      r.value = i.value.some((l) => l.visible === !0);
    }, { flush: "post" }), {
      visible: r,
      ns: t
    };
  }
});
function PMe(e, t, r, n, i, s) {
  return Yt((R(), Z("ul", {
    class: B(e.ns.be("group", "wrap"))
  }, [
    K("li", {
      class: B(e.ns.be("group", "title"))
    }, Xe(e.label), 3),
    K("li", null, [
      K("ul", {
        class: B(e.ns.b("group"))
      }, [
        ke(e.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [di, e.visible]
  ]);
}
var wq = /* @__PURE__ */ rt(AMe, [["render", PMe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const kN = fi(kMe, {
  Option: VC,
  OptionGroup: wq
}), Sp = Ku(VC);
Ku(wq);
const RMe = ht({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: fB
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: Oi
  },
  activeActionIcon: {
    type: Oi
  },
  activeIcon: {
    type: Oi
  },
  inactiveIcon: {
    type: Oi
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: Le(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  label: {
    type: String,
    default: void 0
  }
}), LMe = {
  [At]: (e) => Un(e) || nr(e) || ar(e),
  [aa]: (e) => Un(e) || nr(e) || ar(e),
  [WI]: (e) => Un(e) || nr(e) || ar(e)
}, NMe = ["onClick"], FMe = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], DMe = ["aria-hidden"], jMe = ["aria-hidden"], VMe = ["aria-hidden"], Q1 = "ElSwitch", zMe = he({
  name: Q1
}), UMe = /* @__PURE__ */ he({
  ...zMe,
  props: RMe,
  emits: LMe,
  setup(e, { expose: t, emit: r }) {
    const n = e, i = nn(), { formItem: s } = gl(), o = go(), a = Je("switch");
    ((M) => {
      M.forEach((L) => {
        Sg({
          from: L[0],
          replacement: L[1],
          scope: Q1,
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/switch.html#attributes",
          type: "Attribute"
        }, A(() => {
          var N;
          return !!((N = i.vnode.props) != null && N[L[2]]);
        }));
      });
    })([
      ['"value"', '"model-value" or "v-model"', "value"],
      ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
      ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
      ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
    ]);
    const { inputId: c } = d0(n, {
      formItemContext: s
    }), h = If(A(() => n.loading)), f = q(n.modelValue !== !1), m = q(), y = q(), g = A(() => [
      a.b(),
      a.m(o.value),
      a.is("disabled", h.value),
      a.is("checked", $.value)
    ]), v = A(() => [
      a.e("label"),
      a.em("label", "left"),
      a.is("active", !$.value)
    ]), b = A(() => [
      a.e("label"),
      a.em("label", "right"),
      a.is("active", $.value)
    ]), w = A(() => ({
      width: cl(n.width)
    }));
    Se(() => n.modelValue, () => {
      f.value = !0;
    }), Se(() => n.value, () => {
      f.value = !1;
    });
    const x = A(() => f.value ? n.modelValue : n.value), $ = A(() => x.value === n.activeValue);
    [n.activeValue, n.inactiveValue].includes(x.value) || (r(At, n.inactiveValue), r(aa, n.inactiveValue), r(WI, n.inactiveValue)), Se($, (M) => {
      var L;
      m.value.checked = M, n.validateEvent && ((L = s == null ? void 0 : s.validate) == null || L.call(s, "change").catch((N) => Ut(N)));
    });
    const T = () => {
      const M = $.value ? n.inactiveValue : n.activeValue;
      r(At, M), r(aa, M), r(WI, M), Ye(() => {
        m.value.checked = $.value;
      });
    }, C = () => {
      if (h.value)
        return;
      const { beforeChange: M } = n;
      if (!M) {
        T();
        return;
      }
      const L = M();
      [
        NI(L),
        Un(L)
      ].includes(!0) || t2(Q1, "beforeChange must return type `Promise<boolean>` or `boolean`"), NI(L) ? L.then((ee) => {
        ee && T();
      }).catch((ee) => {
        Ut(Q1, `some error occurred: ${ee}`);
      }) : L && T();
    }, I = A(() => a.cssVarBlock({
      ...n.activeColor ? { "on-color": n.activeColor } : null,
      ...n.inactiveColor ? { "off-color": n.inactiveColor } : null,
      ...n.borderColor ? { "border-color": n.borderColor } : null
    })), O = () => {
      var M, L;
      (L = (M = m.value) == null ? void 0 : M.focus) == null || L.call(M);
    };
    return qt(() => {
      m.value.checked = $.value;
    }), t({
      focus: O,
      checked: $
    }), (M, L) => (R(), Z("div", {
      class: B(_(g)),
      style: $t(_(I)),
      onClick: kt(C, ["prevent"])
    }, [
      K("input", {
        id: _(c),
        ref_key: "input",
        ref: m,
        class: B(_(a).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": _($),
        "aria-disabled": _(h),
        "aria-label": M.label,
        name: M.name,
        "true-value": M.activeValue,
        "false-value": M.inactiveValue,
        disabled: _(h),
        tabindex: M.tabindex,
        onChange: T,
        onKeydown: $i(C, ["enter"])
      }, null, 42, FMe),
      !M.inlinePrompt && (M.inactiveIcon || M.inactiveText) ? (R(), Z("span", {
        key: 0,
        class: B(_(v))
      }, [
        M.inactiveIcon ? (R(), ue(_(zt), { key: 0 }, {
          default: Y(() => [
            (R(), ue(gr(M.inactiveIcon)))
          ]),
          _: 1
        })) : le("v-if", !0),
        !M.inactiveIcon && M.inactiveText ? (R(), Z("span", {
          key: 1,
          "aria-hidden": _($)
        }, Xe(M.inactiveText), 9, DMe)) : le("v-if", !0)
      ], 2)) : le("v-if", !0),
      K("span", {
        ref_key: "core",
        ref: y,
        class: B(_(a).e("core")),
        style: $t(_(w))
      }, [
        M.inlinePrompt ? (R(), Z("div", {
          key: 0,
          class: B(_(a).e("inner"))
        }, [
          M.activeIcon || M.inactiveIcon ? (R(), ue(_(zt), {
            key: 0,
            class: B(_(a).is("icon"))
          }, {
            default: Y(() => [
              (R(), ue(gr(_($) ? M.activeIcon : M.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : M.activeText || M.inactiveText ? (R(), Z("span", {
            key: 1,
            class: B(_(a).is("text")),
            "aria-hidden": !_($)
          }, Xe(_($) ? M.activeText : M.inactiveText), 11, jMe)) : le("v-if", !0)
        ], 2)) : le("v-if", !0),
        K("div", {
          class: B(_(a).e("action"))
        }, [
          M.loading ? (R(), ue(_(zt), {
            key: 0,
            class: B(_(a).is("loading"))
          }, {
            default: Y(() => [
              de(_(a0))
            ]),
            _: 1
          }, 8, ["class"])) : M.activeActionIcon && _($) ? (R(), ue(_(zt), { key: 1 }, {
            default: Y(() => [
              (R(), ue(gr(M.activeActionIcon)))
            ]),
            _: 1
          })) : M.inactiveActionIcon && !_($) ? (R(), ue(_(zt), { key: 2 }, {
            default: Y(() => [
              (R(), ue(gr(M.inactiveActionIcon)))
            ]),
            _: 1
          })) : le("v-if", !0)
        ], 2)
      ], 6),
      !M.inlinePrompt && (M.activeIcon || M.activeText) ? (R(), Z("span", {
        key: 1,
        class: B(_(b))
      }, [
        M.activeIcon ? (R(), ue(_(zt), { key: 0 }, {
          default: Y(() => [
            (R(), ue(gr(M.activeIcon)))
          ]),
          _: 1
        })) : le("v-if", !0),
        !M.activeIcon && M.activeText ? (R(), Z("span", {
          key: 1,
          "aria-hidden": !_($)
        }, Xe(M.activeText), 9, VMe)) : le("v-if", !0)
      ], 2)) : le("v-if", !0)
    ], 14, NMe));
  }
});
var BMe = /* @__PURE__ */ rt(UMe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const Hc = fi(BMe);
function qMe(e) {
  let t;
  const r = q(!1), n = ci({
    ...e,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function i(m) {
    n.text = m;
  }
  function s() {
    const m = n.parent, y = f.ns;
    if (!m.vLoadingAddClassList) {
      let g = m.getAttribute("loading-number");
      g = Number.parseInt(g) - 1, g ? m.setAttribute("loading-number", g.toString()) : (_g(m, y.bm("parent", "relative")), m.removeAttribute("loading-number")), _g(m, y.bm("parent", "hidden"));
    }
    o(), h.unmount();
  }
  function o() {
    var m, y;
    (y = (m = f.$el) == null ? void 0 : m.parentNode) == null || y.removeChild(f.$el);
  }
  function a() {
    var m;
    e.beforeClose && !e.beforeClose() || (r.value = !0, clearTimeout(t), t = window.setTimeout(l, 400), n.visible = !1, (m = e.closed) == null || m.call(e));
  }
  function l() {
    if (!r.value)
      return;
    const m = n.parent;
    r.value = !1, m.vLoadingAddClassList = void 0, s();
  }
  const c = he({
    name: "ElLoading",
    setup(m, { expose: y }) {
      const { ns: g, zIndex: v } = AC("loading");
      return y({
        ns: g,
        zIndex: v
      }), () => {
        const b = n.spinner || n.svg, w = Ha("svg", {
          class: "circular",
          viewBox: n.svgViewBox ? n.svgViewBox : "0 0 50 50",
          ...b ? { innerHTML: b } : {}
        }, [
          Ha("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), x = n.text ? Ha("p", { class: g.b("text") }, [n.text]) : void 0;
        return Ha(po, {
          name: g.b("fade"),
          onAfterLeave: l
        }, {
          default: Y(() => [
            Yt(de("div", {
              style: {
                backgroundColor: n.background || ""
              },
              class: [
                g.b("mask"),
                n.customClass,
                n.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              Ha("div", {
                class: g.b("spinner")
              }, [w, x])
            ]), [[di, n.visible]])
          ])
        });
      };
    }
  }), h = _G(c), f = h.mount(document.createElement("div"));
  return {
    ...zu(n),
    setText: i,
    removeElLoadingChild: o,
    close: a,
    handleAfterLeave: l,
    vm: f,
    get $el() {
      return f.$el;
    }
  };
}
let Cv;
const p3 = function(e = {}) {
  if (!Pt)
    return;
  const t = GMe(e);
  if (t.fullscreen && Cv)
    return Cv;
  const r = qMe({
    ...t,
    closed: () => {
      var i;
      (i = t.closed) == null || i.call(t), t.fullscreen && (Cv = void 0);
    }
  });
  HMe(t, t.parent, r), AN(t, t.parent, r), t.parent.vLoadingAddClassList = () => AN(t, t.parent, r);
  let n = t.parent.getAttribute("loading-number");
  return n ? n = `${Number.parseInt(n) + 1}` : n = "1", t.parent.setAttribute("loading-number", n), t.parent.appendChild(r.$el), Ye(() => r.visible.value = t.visible), t.fullscreen && (Cv = r), r;
}, GMe = (e) => {
  var t, r, n, i;
  let s;
  return nr(e.target) ? s = (t = document.querySelector(e.target)) != null ? t : document.body : s = e.target || document.body, {
    parent: s === document.body || e.body ? document.body : s,
    background: e.background || "",
    svg: e.svg || "",
    svgViewBox: e.svgViewBox || "",
    spinner: e.spinner || !1,
    text: e.text || "",
    fullscreen: s === document.body && ((r = e.fullscreen) != null ? r : !0),
    lock: (n = e.lock) != null ? n : !1,
    customClass: e.customClass || "",
    visible: (i = e.visible) != null ? i : !0,
    target: s
  };
}, HMe = async (e, t, r) => {
  const { nextZIndex: n } = r.vm.zIndex || r.vm._.exposed.zIndex, i = {};
  if (e.fullscreen)
    r.originalPosition.value = ah(document.body, "position"), r.originalOverflow.value = ah(document.body, "overflow"), i.zIndex = n();
  else if (e.parent === document.body) {
    r.originalPosition.value = ah(document.body, "position"), await Ye();
    for (const s of ["top", "left"]) {
      const o = s === "top" ? "scrollTop" : "scrollLeft";
      i[s] = `${e.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(ah(document.body, `margin-${s}`), 10)}px`;
    }
    for (const s of ["height", "width"])
      i[s] = `${e.target.getBoundingClientRect()[s]}px`;
  } else
    r.originalPosition.value = ah(t, "position");
  for (const [s, o] of Object.entries(i))
    r.$el.style[s] = o;
}, AN = (e, t, r) => {
  const n = r.vm.ns || r.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(r.originalPosition.value) ? _g(t, n.bm("parent", "relative")) : HI(t, n.bm("parent", "relative")), e.fullscreen && e.lock ? HI(t, n.bm("parent", "hidden")) : _g(t, n.bm("parent", "hidden"));
}, h3 = Symbol("ElLoading"), PN = (e, t) => {
  var r, n, i, s;
  const o = t.instance, a = (m) => En(t.value) ? t.value[m] : void 0, l = (m) => {
    const y = nr(m) && (o == null ? void 0 : o[m]) || m;
    return y && q(y);
  }, c = (m) => l(a(m) || e.getAttribute(`element-loading-${Fve(m)}`)), h = (r = a("fullscreen")) != null ? r : t.modifiers.fullscreen, f = {
    text: c("text"),
    svg: c("svg"),
    svgViewBox: c("svgViewBox"),
    spinner: c("spinner"),
    background: c("background"),
    customClass: c("customClass"),
    fullscreen: h,
    target: (n = a("target")) != null ? n : h ? void 0 : e,
    body: (i = a("body")) != null ? i : t.modifiers.body,
    lock: (s = a("lock")) != null ? s : t.modifiers.lock
  };
  e[h3] = {
    options: f,
    instance: p3(f)
  };
}, WMe = (e, t) => {
  for (const r of Object.keys(t))
    ra(t[r]) && (t[r].value = e[r]);
}, RN = {
  mounted(e, t) {
    t.value && PN(e, t);
  },
  updated(e, t) {
    const r = e[h3];
    t.oldValue !== t.value && (t.value && !t.oldValue ? PN(e, t) : t.value && t.oldValue ? En(t.value) && WMe(t.value, r.options) : r == null || r.instance.close());
  },
  unmounted(e) {
    var t;
    (t = e[h3]) == null || t.instance.close();
  }
}, JMe = {
  install(e) {
    e.directive("loading", RN), e.config.globalProperties.$loading = p3;
  },
  directive: RN,
  service: p3
}, _q = ["success", "info", "warning", "error"], si = mB({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: Pt ? document.body : void 0
}), ZMe = ht({
  customClass: {
    type: String,
    default: si.customClass
  },
  center: {
    type: Boolean,
    default: si.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: si.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: si.duration
  },
  icon: {
    type: Oi,
    default: si.icon
  },
  id: {
    type: String,
    default: si.id
  },
  message: {
    type: Le([
      String,
      Object,
      Function
    ]),
    default: si.message
  },
  onClose: {
    type: Le(Function),
    required: !1
  },
  showClose: {
    type: Boolean,
    default: si.showClose
  },
  type: {
    type: String,
    values: _q,
    default: si.type
  },
  offset: {
    type: Number,
    default: si.offset
  },
  zIndex: {
    type: Number,
    default: si.zIndex
  },
  grouping: {
    type: Boolean,
    default: si.grouping
  },
  repeatNum: {
    type: Number,
    default: si.repeatNum
  }
}), KMe = {
  destroy: () => !0
}, oo = SG([]), YMe = (e) => {
  const t = oo.findIndex((i) => i.id === e), r = oo[t];
  let n;
  return t > 0 && (n = oo[t - 1]), { current: r, prev: n };
}, QMe = (e) => {
  const { prev: t } = YMe(e);
  return t ? t.vm.exposed.bottom.value : 0;
}, XMe = (e, t) => oo.findIndex((n) => n.id === e) > 0 ? 20 : t, eOe = ["id"], tOe = ["innerHTML"], rOe = he({
  name: "ElMessage"
}), nOe = /* @__PURE__ */ he({
  ...rOe,
  props: ZMe,
  emits: KMe,
  setup(e, { expose: t }) {
    const r = e, { Close: n } = WSe, { ns: i, zIndex: s } = AC("message"), { currentZIndex: o, nextZIndex: a } = s, l = q(), c = q(!1), h = q(0);
    let f;
    const m = A(() => r.type ? r.type === "error" ? "danger" : r.type : "info"), y = A(() => {
      const O = r.type;
      return { [i.bm("icon", O)]: O && Iw[O] };
    }), g = A(() => r.icon || Iw[r.type] || ""), v = A(() => QMe(r.id)), b = A(() => XMe(r.id, r.offset) + v.value), w = A(() => h.value + b.value), x = A(() => ({
      top: `${b.value}px`,
      zIndex: o.value
    }));
    function $() {
      r.duration !== 0 && ({ stop: f } = ww(() => {
        C();
      }, r.duration));
    }
    function T() {
      f == null || f();
    }
    function C() {
      c.value = !1;
    }
    function I({ code: O }) {
      O === Xt.esc && C();
    }
    return qt(() => {
      $(), a(), c.value = !0;
    }), Se(() => r.repeatNum, () => {
      T(), $();
    }), rl(document, "keydown", I), ip(l, () => {
      h.value = l.value.getBoundingClientRect().height;
    }), t({
      visible: c,
      bottom: w,
      close: C
    }), (O, M) => (R(), ue(po, {
      name: _(i).b("fade"),
      onBeforeLeave: O.onClose,
      onAfterLeave: M[0] || (M[0] = (L) => O.$emit("destroy")),
      persisted: ""
    }, {
      default: Y(() => [
        Yt(K("div", {
          id: O.id,
          ref_key: "messageRef",
          ref: l,
          class: B([
            _(i).b(),
            { [_(i).m(O.type)]: O.type && !O.icon },
            _(i).is("center", O.center),
            _(i).is("closable", O.showClose),
            O.customClass
          ]),
          style: $t(_(x)),
          role: "alert",
          onMouseenter: T,
          onMouseleave: $
        }, [
          O.repeatNum > 1 ? (R(), ue(_(dIe), {
            key: 0,
            value: O.repeatNum,
            type: _(m),
            class: B(_(i).e("badge"))
          }, null, 8, ["value", "type", "class"])) : le("v-if", !0),
          _(g) ? (R(), ue(_(zt), {
            key: 1,
            class: B([_(i).e("icon"), _(y)])
          }, {
            default: Y(() => [
              (R(), ue(gr(_(g))))
            ]),
            _: 1
          }, 8, ["class"])) : le("v-if", !0),
          ke(O.$slots, "default", {}, () => [
            O.dangerouslyUseHTMLString ? (R(), Z(Mt, { key: 1 }, [
              le(" Caution here, message could've been compromised, never use user's input as message "),
              K("p", {
                class: B(_(i).e("content")),
                innerHTML: O.message
              }, null, 10, tOe)
            ], 2112)) : (R(), Z("p", {
              key: 0,
              class: B(_(i).e("content"))
            }, Xe(O.message), 3))
          ]),
          O.showClose ? (R(), ue(_(zt), {
            key: 2,
            class: B(_(i).e("closeBtn")),
            onClick: kt(C, ["stop"])
          }, {
            default: Y(() => [
              de(_(n))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : le("v-if", !0)
        ], 46, eOe), [
          [di, c.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var iOe = /* @__PURE__ */ rt(nOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let sOe = 1;
const Sq = (e) => {
  const t = !e || nr(e) || jy(e) || er(e) ? { message: e } : e, r = {
    ...si,
    ...t
  };
  if (!r.appendTo)
    r.appendTo = document.body;
  else if (nr(r.appendTo)) {
    let n = document.querySelector(r.appendTo);
    Fu(n) || (Ut("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), n = document.body), r.appendTo = n;
  }
  return r;
}, oOe = (e) => {
  const t = oo.indexOf(e);
  if (t === -1)
    return;
  oo.splice(t, 1);
  const { handler: r } = e;
  r.close();
}, aOe = ({ appendTo: e, ...t }, r) => {
  const n = `message_${sOe++}`, i = t.onClose, s = document.createElement("div"), o = {
    ...t,
    id: n,
    onClose: () => {
      i == null || i(), oOe(h);
    },
    onDestroy: () => {
      ib(null, s);
    }
  }, a = de(iOe, o, er(o.message) || jy(o.message) ? {
    default: er(o.message) ? o.message : () => o.message
  } : null);
  a.appContext = r || Yh._context, ib(a, s), e.appendChild(s.firstElementChild);
  const l = a.component, h = {
    id: n,
    vnode: a,
    vm: l,
    handler: {
      close: () => {
        l.exposed.visible.value = !1;
      }
    },
    props: a.component.props
  };
  return h;
}, Yh = (e = {}, t) => {
  if (!Pt)
    return { close: () => {
    } };
  if (ar(QI.max) && oo.length >= QI.max)
    return { close: () => {
    } };
  const r = Sq(e);
  if (r.grouping && oo.length) {
    const i = oo.find(({ vnode: s }) => {
      var o;
      return ((o = s.props) == null ? void 0 : o.message) === r.message;
    });
    if (i)
      return i.props.repeatNum += 1, i.props.type = r.type, i.handler;
  }
  const n = aOe(r, t);
  return oo.push(n), n.handler;
};
_q.forEach((e) => {
  Yh[e] = (t = {}, r) => {
    const n = Sq(t);
    return Yh({ ...n, type: e }, r);
  };
});
function lOe(e) {
  for (const t of oo)
    (!e || e === t.props.type) && t.handler.close();
}
Yh.closeAll = lOe;
Yh._context = null;
const zC = hB(Yh, "$message"), $q = [
  "success",
  "info",
  "warning",
  "error"
], uOe = ht({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Oi
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: Le([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Le(Function),
    default: () => {
    }
  },
  onClose: {
    type: Le(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...$q, ""],
    default: ""
  },
  zIndex: Number
}), cOe = {
  destroy: () => !0
}, dOe = ["id"], pOe = ["textContent"], hOe = { key: 0 }, fOe = ["innerHTML"], mOe = he({
  name: "ElNotification"
}), yOe = /* @__PURE__ */ he({
  ...mOe,
  props: uOe,
  emits: cOe,
  setup(e, { expose: t }) {
    const r = e, { ns: n, zIndex: i } = AC("notification"), { nextZIndex: s, currentZIndex: o } = i, { Close: a } = dB, l = q(!1);
    let c;
    const h = A(() => {
      const $ = r.type;
      return $ && Iw[r.type] ? n.m($) : "";
    }), f = A(() => r.type && Iw[r.type] || r.icon), m = A(() => r.position.endsWith("right") ? "right" : "left"), y = A(() => r.position.startsWith("top") ? "top" : "bottom"), g = A(() => {
      var $;
      return {
        [y.value]: `${r.offset}px`,
        zIndex: ($ = r.zIndex) != null ? $ : o.value
      };
    });
    function v() {
      r.duration > 0 && ({ stop: c } = ww(() => {
        l.value && w();
      }, r.duration));
    }
    function b() {
      c == null || c();
    }
    function w() {
      l.value = !1;
    }
    function x({ code: $ }) {
      $ === Xt.delete || $ === Xt.backspace ? b() : $ === Xt.esc ? l.value && w() : v();
    }
    return qt(() => {
      v(), s(), l.value = !0;
    }), rl(document, "keydown", x), t({
      visible: l,
      close: w
    }), ($, T) => (R(), ue(po, {
      name: _(n).b("fade"),
      onBeforeLeave: $.onClose,
      onAfterLeave: T[1] || (T[1] = (C) => $.$emit("destroy")),
      persisted: ""
    }, {
      default: Y(() => [
        Yt(K("div", {
          id: $.id,
          class: B([_(n).b(), $.customClass, _(m)]),
          style: $t(_(g)),
          role: "alert",
          onMouseenter: b,
          onMouseleave: v,
          onClick: T[0] || (T[0] = (...C) => $.onClick && $.onClick(...C))
        }, [
          _(f) ? (R(), ue(_(zt), {
            key: 0,
            class: B([_(n).e("icon"), _(h)])
          }, {
            default: Y(() => [
              (R(), ue(gr(_(f))))
            ]),
            _: 1
          }, 8, ["class"])) : le("v-if", !0),
          K("div", {
            class: B(_(n).e("group"))
          }, [
            K("h2", {
              class: B(_(n).e("title")),
              textContent: Xe($.title)
            }, null, 10, pOe),
            Yt(K("div", {
              class: B(_(n).e("content")),
              style: $t($.title ? void 0 : { margin: 0 })
            }, [
              ke($.$slots, "default", {}, () => [
                $.dangerouslyUseHTMLString ? (R(), Z(Mt, { key: 1 }, [
                  le(" Caution here, message could've been compromised, never use user's input as message "),
                  K("p", { innerHTML: $.message }, null, 8, fOe)
                ], 2112)) : (R(), Z("p", hOe, Xe($.message), 1))
              ])
            ], 6), [
              [di, $.message]
            ]),
            $.showClose ? (R(), ue(_(zt), {
              key: 0,
              class: B(_(n).e("closeBtn")),
              onClick: kt(w, ["stop"])
            }, {
              default: Y(() => [
                de(_(a))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : le("v-if", !0)
          ], 2)
        ], 46, dOe), [
          [di, l.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var gOe = /* @__PURE__ */ rt(yOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
const Cw = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, f3 = 16;
let vOe = 1;
const Qh = function(e = {}, t = null) {
  if (!Pt)
    return { close: () => {
    } };
  (typeof e == "string" || jy(e)) && (e = { message: e });
  const r = e.position || "top-right";
  let n = e.offset || 0;
  Cw[r].forEach(({ vm: h }) => {
    var f;
    n += (((f = h.el) == null ? void 0 : f.offsetHeight) || 0) + f3;
  }), n += f3;
  const i = `notification_${vOe++}`, s = e.onClose, o = {
    ...e,
    offset: n,
    id: i,
    onClose: () => {
      bOe(i, r, s);
    }
  };
  let a = document.body;
  Fu(e.appendTo) ? a = e.appendTo : nr(e.appendTo) && (a = document.querySelector(e.appendTo)), Fu(a) || (Ut("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), a = document.body);
  const l = document.createElement("div"), c = de(gOe, o, jy(o.message) ? {
    default: () => o.message
  } : null);
  return c.appContext = t ?? Qh._context, c.props.onDestroy = () => {
    ib(null, l);
  }, ib(c, l), Cw[r].push({ vm: c }), a.appendChild(l.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = !1;
    }
  };
};
$q.forEach((e) => {
  Qh[e] = (t = {}) => ((typeof t == "string" || jy(t)) && (t = {
    message: t
  }), Qh({
    ...t,
    type: e
  }));
});
function bOe(e, t, r) {
  const n = Cw[t], i = n.findIndex(({ vm: c }) => {
    var h;
    return ((h = c.component) == null ? void 0 : h.props.id) === e;
  });
  if (i === -1)
    return;
  const { vm: s } = n[i];
  if (!s)
    return;
  r == null || r(s);
  const o = s.el.offsetHeight, a = t.split("-")[0];
  n.splice(i, 1);
  const l = n.length;
  if (!(l < 1))
    for (let c = i; c < l; c++) {
      const { el: h, component: f } = n[c].vm, m = Number.parseInt(h.style[a], 10) - o - f3;
      f.props.offset = m;
    }
}
function wOe() {
  for (const e of Object.values(Cw))
    e.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = !1;
    });
}
Qh.closeAll = wOe;
Qh._context = null;
const _Oe = hB(Qh, "$notify"), m3 = q(!1), Mh = {
  name: "演示路口",
  level: "无",
  color: "#999"
}, y3 = [
  {
    lane: [
      {
        arrow: "trun_left",
        vol: 0
      },
      {
        arrow: "straight_right",
        vol: 0
      }
    ],
    angle: 120.08650455410778
  },
  {
    lane: [
      {
        arrow: "trun_left",
        vol: 0
      },
      {
        arrow: "straight_right",
        vol: 0
      }
    ],
    angle: -58.277576574723355
  },
  {
    lane: [
      {
        arrow: "left_straight_right",
        vol: 0
      }
    ],
    angle: 20.68849989345116
  },
  {
    lane: [
      {
        arrow: "left_straight_right",
        vol: 0
      }
    ],
    angle: -160.50816807856677
  }
];
let lc = null, me = null;
const $r = 20, $p = 300, Xn = 3, Ny = 400, Fy = 400, LN = 100, a$ = 1, To = 15, SOe = 3;
function $Oe(e) {
  Mh.name = e.name, Mh.color = e.crossData.color, Mh.level = e.crossData.level, y3.length = 0, JSON.parse(JSON.stringify(e.crossData.lanes)).forEach((t) => {
    t.angle = xq(t.startPoint, t.endPoint), delete t.endPoint, delete t.startPoint, y3.push(t);
  }), m3.value = !0;
}
function xOe(e) {
  lc = e.value, lc.width = 800, lc.height = 800, me = lc.getContext("2d"), me.clearRect(0, 0, lc.width, lc.height), me.strokeStyle = "yellow", me.fillStyle = "#5c83a1", me.beginPath(), me.arc(Ny, Fy, 100, 0, 2 * Math.PI), me.stroke(), me.fill(), me.beginPath(), me.arc(Ny, Fy, 50, 0, 2 * Math.PI), me.fillStyle = Mh.color, me.fill(), me.fillStyle = "black", me.font = "40px Arial", me.textAlign = "center", me.textBaseline = "middle", me.fillText(Mh.level, Ny, Fy), me.fillStyle = "black", me.font = "20px Arial", me.textAlign = "left", me.textBaseline = "bottom", me.fillText(Mh.name, 10, lc.height - 10), y3.forEach((t) => {
    TOe(t);
  });
}
function TOe(e) {
  const { lane: t, angle: r } = e, n = t.length * $r * 2 + Xn, i = -r * Math.PI / 180, s = Math.sqrt(LN * LN - n / 2 * (n / 2)), o = Ny + s * Math.cos(i), a = Fy + s * Math.sin(i), l = Zr(s, n / 2, r), c = Zr(s + $p, n / 2, r), h = Zr(s + $p, -n / 2, r), f = Zr(s, -n / 2, r);
  me.beginPath(), me.moveTo(l.x, l.y), me.lineTo(c.x, c.y), me.lineTo(h.x, h.y), me.lineTo(f.x, f.y), me.closePath(), me.fillStyle = "#5c83a1", me.fill(), me.beginPath(), me.moveTo(l.x, l.y), me.lineTo(c.x, c.y), me.strokeStyle = "#ffff00", me.stroke(), me.beginPath(), me.moveTo(h.x, h.y), me.lineTo(f.x, f.y), me.strokeStyle = "#ffff00", me.stroke();
  const m = Zr(s + To, Xn / 2, r), y = Zr(s + $p, Xn / 2, r), g = Zr(s + To, -Xn / 2, r), v = Zr(s + $p, -Xn / 2, r);
  if (me.beginPath(), me.moveTo(m.x, m.y), me.lineTo(y.x, y.y), me.strokeStyle = "#ffff00", me.stroke(), me.beginPath(), me.moveTo(g.x, g.y), me.lineTo(v.x, v.y), me.strokeStyle = "#ffff00", me.stroke(), me.setLineDash([10, 10]), me.lineWidth = 1, me.strokeStyle = "white", t.length > 1)
    for (let T = 1; T < t.length; T++) {
      const C = Zr(s, Xn / 2 + T * $r, r), I = Zr(s + $p, Xn / 2 + T * $r, r);
      me.beginPath(), me.moveTo(C.x, C.y), me.lineTo(I.x, I.y), me.stroke();
      const O = Zr(s, -(Xn / 2 + T * $r), r), M = Zr(s + $p, -(Xn / 2 + T * $r), r);
      me.beginPath(), me.moveTo(O.x, O.y), me.lineTo(M.x, M.y), me.stroke();
    }
  me.setLineDash([]), me.save();
  const b = t.length * $r * 2 + Xn, w = a$ / 2, x = o - (b / 2 - w) * Math.cos(i + Math.PI / 2), $ = a - (b / 2 - w) * Math.sin(i + Math.PI / 2);
  for (let T = 0; T < b; T += a$ + SOe) {
    const C = x + T * Math.cos(i + Math.PI / 2), I = $ + T * Math.sin(i + Math.PI / 2), O = C + To * Math.cos(i), M = I + To * Math.sin(i);
    me.beginPath(), me.moveTo(C, I), me.lineTo(O, M), me.strokeStyle = "white", me.lineWidth = a$, me.stroke();
  }
  me.restore(), t.forEach((T, C) => {
    const { x: I, y: O } = Zr(s + To + 20, Xn / 2 + C * $r + $r / 2, r), { x: M, y: L } = Zr(s + To + 80, Xn / 2 + C * $r + $r / 2, r), { x: N, y: ee } = Zr(s + To + 140, Xn / 2 + C * $r + $r / 2, r);
    sm(T.arrow, I, O, r), sm(T.arrow, M, L, r), sm(T.arrow, N, ee, r);
    const { x: D, y: H } = Zr(s + To + 20, -(Xn / 2 + C * $r + $r / 2), r);
    sm("straight", D, H, r + 180);
    const { x: J, y: oe } = Zr(s + To + 80, n / 2 + C * $r + $r / 2 + $r, r), { x: ye, y: Q } = Zr(s + To + 100, n / 2 + C * $r + $r / 2 + $r, r);
    sm(T.arrow, J, oe, r), me.fillStyle = "#fff", me.font = "12px Arial", me.textAlign = "center", me.textBaseline = "middle", me.save(), me.translate(ye, Q), me.rotate(-r * Math.PI / 180), me.fillText(T.vol, 0, 0), me.restore();
  });
}
function sm(e, t, r, n) {
  const i = new Image();
  i.src = `/arrow/${e}.svg`, i.onload = () => {
    const o = i.width * 0.07, a = i.height * 0.07;
    me.save(), me.translate(t, r), me.rotate(-n * Math.PI / 180);
    const l = -o / 2, c = -a / 2;
    me.drawImage(i, l, c, o, a), me.restore();
  };
}
function xq(e, t) {
  return Math.atan2(t[1] - e[1], t[0] - e[0]) * 180 / Math.PI;
}
function Zr(e, t, r) {
  const n = r * Math.PI / 180, i = Math.sqrt(e * e + t * t), s = Math.atan2(t, e), o = Ny + i * Math.cos(-s - n), a = Fy + i * Math.sin(-s - n);
  return {
    x: o,
    y: a
  };
}
const Ue = ci({
  project: [],
  predictionAssessmentType: "current",
  predictionResearchPhase: "morningPeak",
  predictionObject: 1,
  predictionIndex: 1,
  predictionTrans: "out",
  link_name: "",
  heatMap: !1,
  spiderWeb: !1,
  expectedLine: !1,
  community: [],
  flowDiff: !1,
  showPulse: !1,
  // 显示脉冲图
  showOd: !1
  // 显示OD数据
}), Vu = {}, kw = {}, d2 = {}, Xh = [], h0 = q("link"), Tq = {
  current: 0,
  near: 1,
  far: 2
}, EOe = {
  morningPeak: 1,
  nightPeak: 2,
  holiday: 3,
  other: 4
}, is = q([]);
function IOe(e) {
  const t = [];
  return e.forEach((r) => {
    t.includes(r.predictionResearchPhase) || t.push(r.predictionResearchPhase);
  }), t;
}
function ed(e = "") {
  e && (h0.value = e), f0.forEach((t) => {
    t.visible = Ue.predictionObject === 1 && Ue.predictionIndex === 1;
  }), Of.forEach((t) => {
    t.visible = Ue.predictionObject === 1 && Ue.predictionIndex === 1 && ki.zoom > 16;
  }), Eg.forEach((t) => {
    t.visible = Ue.predictionObject === 2;
  }), p2.forEach((t) => {
    t.visible = Ue.predictionObject === 2;
  }), h2.forEach((t) => {
    t.visible = Ue.predictionIndex === 2;
  }), m0.forEach((t) => {
    t.visible = Ue.predictionIndex === 2 && ki.zoom > 16;
  });
}
function l$() {
  var t;
  JOe();
  const e = (t = kw.list.filter((r) => {
    const n = Ue.predictionAssessmentType === "current" ? void 0 : Ue.predictionAssessmentType;
    return r.predictionAssessmentType === n && r.predictionResearchPhase === Ue.predictionResearchPhase;
  })[0]) == null ? void 0 : t.data;
  e && (Object.assign(d2, e), MOe(), ZOe(), ed());
}
function MOe() {
  Xh.length = 0, d2.links.forEach((e) => {
    const t = {
      saturation: e.saturation,
      vol: e.vol,
      origin_id: e.origin_id,
      id: e.id
    }, r = Vu.links.find((n) => n.id === e.origin_id);
    t.link_name = r.link_name, t.shape = r.shape.split(" ").map((n) => n.split(",")), t.nodes = Eq(r.shape, e.direction), Xh.push(t);
  }), COe();
}
function Eq(e, t) {
  const r = e.split(" ").map((a) => a.split(",")), n = r[0], i = r[r.length - 1], s = 4e-5, o = r.map((a) => t === 2 ? [Number.parseFloat(a[0]) + s, Number.parseFloat(a[1])] : t === 1 ? [Number.parseFloat(a[0]) - s, Number.parseFloat(a[1])] : "Invalid direction specified");
  return [
    n,
    ...o,
    i
  ];
}
function UC(e) {
  const t = e.length, r = Math.floor(t / 2) - 1, n = [e[r], e[r + 1]], i = (n[0][0] + n[1][0]) / 2, s = (n[0][1] + n[1][1]) / 2, o = xq(e[0], e[t - 1], e[t - 1]), a = Math.abs(o);
  return { center: [i, s], slope: a };
}
function Iq(e) {
  if (e <= 0.4)
    return "#4B7902";
  if (e > 0.4 && e <= 0.6)
    return "#95F204";
  if (e > 0.6 && e <= 0.75)
    return "#FFD400";
  if (e > 0.75 && e <= 0.9)
    return "#F47920";
  if (e > 0.9 && e <= 1)
    return "#D9001B";
  if (e > 1)
    return "#843900";
}
function OOe(e) {
  return e >= is.value[0].text && e < is.value[1].text ? is.value[0].value : e >= is.value[1].text && e < is.value[2].text ? is.value[1].value : e >= is.value[2].text && e < is.value[3].text ? is.value[2].value : is.value[3].value;
}
function COe() {
  const e = Array.from(new Set(Xh.map((i) => i.vol))).sort((i, s) => i - s), t = e.length, r = [
    e[0],
    // 0%
    e[Math.ceil((t - 1) * 0.25)],
    e[Math.ceil((t - 1) * 0.5)],
    e[Math.ceil((t - 1) * 0.75)]
  ], n = [
    { value: 1, text: r[0] },
    { value: 4, text: r[1] },
    { value: 7, text: r[2] },
    { value: 10, text: r[3] }
  ];
  return is.value = n, n;
}
function u$(e, t = null) {
  let r = {};
  const n = Object.values(Vu.nodes).filter((i) => i.id === e)[0];
  return t ? t.forEach((i) => {
    r[i] = n[i];
  }) : r = n, r;
}
function kOe(e) {
  var t, r, n, i, s, o, a, l, c;
  if (e.results.length) {
    const h = e.results.filter((f) => f.graphic.geometry.type === "polyline" || f.graphic.geometry.type === "point")[0];
    ((r = (t = h.graphic) == null ? void 0 : t.attributes) == null ? void 0 : r.polylineType) === "line" && Ue.spiderWeb && AOe((n = h.graphic) == null ? void 0 : n.attributes), ((s = (i = h.graphic) == null ? void 0 : i.attributes) == null ? void 0 : s.polylineType) === "line-expected" && (console.log("点到期望点了"), Ue.expectedLine && VOe(h)), ((a = (o = h.graphic) == null ? void 0 : o.attributes) == null ? void 0 : a.polylineType) === "cross" && (console.log("点到交叉口了"), (l = h.graphic) != null && l.attributes.crossData && $Oe((c = h.graphic) == null ? void 0 : c.attributes));
  } else
    console.log("无效操作：点击"), h0.value === "spider" && (Ue.link_name = "", clearSpider());
}
function AOe(e) {
  R3.get(`/api/v1/prediction/link/spider/${Ue.project[1]}/${Tq[Ue.predictionAssessmentType]}/1/${EOe[Ue.predictionResearchPhase]}/${e.id}`).then((t) => {
    if (t.data.code === 0 && t.data.data.length) {
      Ue.link_name = e.link_name;
      const r = t.data.data;
      r.forEach((n) => {
        const i = Xh.find((s) => s.id === n.linkId);
        if (i) {
          const { shape: s, link_name: o } = i;
          Object.assign(n, { shape: s, link_name: o });
        }
      }), r.length && (hiddenGraphicsLayer(), drawSpider(r, e.id)), h0.value = "spider";
    } else
      zC.error("该路段无数据");
  }).catch((t) => {
    console.error("Error during API call:", t);
  });
}
function kv(e) {
  _Oe({
    title: "温馨提示:",
    message: e,
    type: "info",
    position: "bottom-right",
    duration: 1e4
  });
}
function POe() {
  try {
    Object.assign(Ue, {
      predictionAssessmentType: "current",
      predictionResearchPhase: "morningPeak",
      predictionObject: 1,
      predictionIndex: 1,
      predictionTrans: "out",
      link_name: "",
      heatMap: !1,
      spiderWeb: !1,
      expectedLine: !1,
      flowDiff: !1
    }), Object.keys(Vu).forEach((e) => delete Vu[e]), Object.keys(kw).forEach((e) => delete kw[e]), Xh.length = 0, map.removeAll(), f0.length = 0, Of.length = 0, h2.length = 0, m0.length = 0, Eg.length = 0, p2.length = 0, graphicsLayer.removeAll(), expectedLineGraphicsLayer.removeAll(), expectedGraphics.length = 0, nodeToExpectedLineGraphics.length = 0;
  } catch {
  }
}
const BC = {}, Mq = {};
let Aw = null;
function NN() {
  Oq();
  const e = [];
  BC.zone.forEach((t) => {
    const r = {
      geometry: {
        type: "point",
        x: t.lng,
        y: t.lat
      },
      attributes: {
        id: t.id,
        od: t[`${Ue.predictionTrans}Sum`],
        name: t.name
      }
    };
    e.push(r);
  }), Aw = new SU({
    fields: [
      {
        name: "od",
        alias: "Od",
        type: "double"
      }
    ],
    geometryType: "point",
    objectIdField: "ObjectID",
    source: e,
    renderer: new UO({
      colorStops: [
        { ratio: 0, color: "rgba(255, 255, 255, 0)" },
        { ratio: 0.2, color: "rgba(255, 0, 0, 0.8)" },
        { ratio: 0.5, color: "rgba(255, 140, 0, 0.8)" },
        { ratio: 0.8, color: "rgba(255, 140, 0, 0.9)" },
        { ratio: 1, color: "rgba(255, 0, 0, 0.9)" }
      ],
      field: "od",
      minPixelIntensity: 1,
      maxPixelIntensity: 800
    })
  }), Ts.add(Aw);
}
function Oq() {
  Aw && Aw.destroy(), Ts.remove();
}
function ROe() {
  const e = Object.values(Mq).find((i) => i.predictionAssessmentType === Tq[Ue.predictionAssessmentType] && i.predictionType === 1).details[0].od, { od: t, zone: r } = e;
  for (let i = 0; i < r.length; i++) {
    const s = u$(r[i].id, ["lng", "lat"]);
    r[i].lng = s.lng, r[i].lat = s.lat, r[i].outSum = 0, r[i].outLinks = [], r[i].inSum = 0, r[i].inLinks = [], t[i].map((o, a) => {
      if (r[i].outSum += Number(o), o) {
        const l = u$(r[a].id, ["lng", "lat"]);
        r[i].outLinks.push({
          coord: [l.lng, l.lat],
          vol: Number(o),
          index: a
        });
      }
    });
  }
  const n = t[0].map((i, s) => t.map((o) => o[s]));
  for (let i = 0; i < n.length; i++)
    r[i].inSum = 0, r[i].inLinks = [], n[i].map((s, o) => {
      if (r[i].inSum += Number(s), s) {
        const a = u$(r[o].id, ["lng", "lat"]);
        r[i].inLinks.push({
          coord: [a.lng, a.lat],
          vol: Number(s),
          index: o
        });
      }
    });
  Object.assign(BC, e);
}
const Cq = q([]), g3 = q(!1), zn = new D_(), Hd = [], $d = [];
function LOe() {
  BC.zone.forEach((e, t) => {
    const r = new vr({
      geometry: new Re({
        longitude: e.lng,
        latitude: e.lat
      }),
      symbol: new mo({
        text: e.name,
        font: {
          size: 10,
          weight: "bold",
          padding: 0
        },
        color: new Me([250, 250, 250, 1]),
        backgroundColor: new Me("#999999"),
        // 设置背景颜色为灰色
        borderLineColor: new Me([255, 255, 255, 1]),
        // 设置边框颜色为白色
        borderLineSize: 1,
        // 设置边框大小
        verticalAlignment: "middle"
      }),
      attributes: {
        ...e,
        index: t,
        polylineType: "line-expected"
      }
    });
    Hd.push(r);
  }), xd.addMany(Hd, 1e3);
}
function FN() {
  $d.length = 0, zn.removeAll(), Ue.community.length = 0, Hd.forEach((e) => {
    Pw(e, "#999999"), e.visible = !1;
  });
}
function NOe() {
  kq();
}
function FOe() {
  $d.length = 0, zn.removeAll(), Ue.community.length = 0, Hd.forEach((e) => {
    Pw(e, "#999999");
  });
}
function DOe() {
  Hd.length === 0 && LOe(), Hd.forEach((e) => {
    e.visible = !0;
  });
}
const om = [];
function jOe(e) {
  const t = om.indexOf(e);
  return t > -1 ? (om.splice(t, 1), zn.graphics.filter((n) => n.id === e).forEach((n) => {
    zn.remove(n);
  }), g3.value = !!om.length, !1) : (om.push(e), g3.value = !!om.length, !0);
}
function VOe(e) {
  BOe(e.graphic.attributes), GOe(), kq();
  const t = e.graphic.attributes.id;
  if (!jOe(t)) {
    Pw(e.graphic, "#999999");
    return;
  }
  Pw(e.graphic, "#006600");
}
function kq() {
  zn.removeAll(), Ue.community.length = 0, $d.forEach((e) => {
    Ue.community.push(e.name), (Ue.predictionTrans === "out" ? e.outLinks : e.inLinks).forEach((r) => {
      zOe([[e.lng, e.lat], r.coord]), UOe([[e.lng, e.lat], r.coord], r.vol), Ue.predictionTrans === "out" ? DN([e.lng, e.lat], r.coord) : DN(r.coord, [e.lng, e.lat]);
    });
  });
}
function zOe(e) {
  const t = new vr({
    geometry: {
      type: "polyline",
      paths: e
    },
    symbol: {
      type: "simple-line",
      color: [251, 146, 60, 0.8],
      width: 5
    },
    attributes: {
      polylineType: "expected-line"
    }
  }), r = new ji({
    color: "#fff",
    width: 1,
    style: "dash",
    dashPattern: [10, 5]
    // 定义虚线的样式：10px实线，5px空白
  }), n = new vr({
    geometry: {
      type: "polyline",
      paths: e
    },
    symbol: r
  });
  zn.add(t), zn.add(n), Ts.add(zn), Ts.reorder(zn, 0);
}
function UOe(e, t) {
  const r = UC(e), n = new vr({
    geometry: new Re({
      longitude: r.center[0],
      latitude: r.center[1]
    }),
    symbol: new mo({
      text: t.toFixed(0),
      font: {
        size: 10,
        weight: "bold",
        padding: 0
      },
      color: new Me([0, 0, 0, 1]),
      backgroundColor: new Me("#ccc"),
      // 设置背景颜色为灰色
      borderLineColor: new Me([255, 255, 255, 1]),
      // 设置边框颜色为白色
      borderLineSize: 1,
      // 设置边框大小
      verticalAlignment: "middle"
    }),
    attributes: {
      polylineType: "expected-data"
    }
  });
  n.visible = Ue.showOd, zn.add(n), Ts.add(zn), Ts.reorder(zn, 0);
}
function BOe(e) {
  const t = $d.findIndex((r) => r.id === e.id);
  t !== -1 ? $d.splice(t, 1) : $d.push(e);
}
function Pw(e, t) {
  const r = e.symbol.clone();
  r.backgroundColor = new Me(t), e.symbol = r;
}
function qOe(e, t, r, n) {
  const i = e * Math.PI / 180, s = r * Math.PI / 180, o = (n - t) * Math.PI / 180, a = Math.sin(o) * Math.cos(s), l = Math.cos(i) * Math.sin(s) - Math.sin(i) * Math.cos(s) * Math.cos(o);
  return (Math.atan2(a, l) * 180 / Math.PI + 360) % 360;
}
function DN(e, t) {
  const r = {
    type: "picture-marker",
    url: "/arrow/navigation.svg",
    // 箭头图片的路径
    width: "24px",
    height: "24px"
  }, n = new vr({
    symbol: r,
    attributes: {
      polylineType: `expected-arrow-${Ue.predictionTrans}`
    }
  });
  n.visible = Ue.showPulse, zn.add(n);
  const i = t[0] - e[0], s = t[1] - e[1], o = Math.sqrt(i * i + s * s), a = qOe(e[1], e[0], t[1], t[0]), c = 6e-5 / o;
  let h = 0;
  function f() {
    h += c, h >= 1 && (h = 0);
    const m = e[0] + i * h, y = e[1] + s * h;
    n.geometry = new Re([m, y]), n.symbol.angle = a, requestAnimationFrame(f);
  }
  f();
}
function GOe() {
  let e = [];
  $d.forEach((s) => {
    e = Ue.predictionTrans === "out" ? s.outLinks : s.inLinks;
  });
  const t = Array.from(new Set(e.map((s) => s.vol))).sort((s, o) => s - o), r = t.length, n = [
    t[0],
    // 0%
    t[Math.ceil((r - 1) * 0.25)],
    t[Math.ceil((r - 1) * 0.5)],
    t[Math.ceil((r - 1) * 0.75)]
  ], i = [
    { value: 1, text: n[0] },
    { value: 4, text: n[1] },
    { value: 7, text: n[2] },
    { value: 10, text: n[3] }
  ];
  return Cq.value = i, i;
}
function HOe() {
  zn.graphics.forEach((e) => {
    var t;
    ((t = e.attributes) == null ? void 0 : t.polylineType) === "expected-data" && (e.visible = Ue.showOd);
  });
}
function WOe() {
  zn.graphics.forEach((e) => {
    var t;
    ((t = e.attributes) == null ? void 0 : t.polylineType) === `expected-arrow-${Ue.predictionTrans}` && (e.visible = Ue.showPulse);
  });
}
const Ts = new N8({
  basemap: "geoscene-blue"
  // basemap: 'tianditu-vector',
}), ki = new ofe({
  map: Ts,
  center: "121.40569010038575, 31.141236748863733".split(","),
  // center: [121.479615, 31.234771],
  // center: [121.480255, 31.234279], // 交叉口有图
  zoom: 16
}), xd = new D_();
ki.ui.components = [];
function JOe() {
  xd.removeAll(), h0.value = "link";
}
ki.on("click", (e) => {
  ki.hitTest(e).then((t) => {
    kOe(t);
  });
});
ki.watch("zoom", (e) => {
  Of.forEach((t) => {
    t.visible = Ue.predictionObject === 1 && Ue.predictionIndex === 1 && ki.zoom > 16 && !Ue.flowDiff && !Ue.expectedLine;
  }), m0.forEach((t) => {
    t.visible = Ue.predictionIndex === 2 && ki.zoom > 16 && !Ue.flowDiff && !Ue.expectedLine;
  }), Hd.forEach((t) => {
    t.visible = Ue.expectedLine && ki.zoom > 14;
  });
});
const f0 = [], Of = [], Eg = [], p2 = [], h2 = [], m0 = [];
function ZOe() {
  KOe(), YOe(d2.nodes), xd.addMany([...p2, ...f0, ...Of, ...h2, ...m0]), xd.addMany(Eg), Ts.add(xd);
}
function KOe() {
  Xh.map((e) => {
    const t = UC(e.nodes), r = new vr({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Me(Iq(e.saturation)),
        width: 2
      },
      attributes: {
        ...e,
        polylineType: "line"
      }
    });
    f0.push(r);
    const n = new vr({
      geometry: new Re({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new mo({
        text: e.saturation.toFixed(2),
        font: {
          size: 8
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      })
    });
    n.visible = !1, Of.push(n);
    const i = new vr({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Me([252, 124, 124, 0.7]),
        width: OOe(e.vol)
      },
      attributes: {
        ...e,
        polylineType: "flow"
      }
    });
    h2.push(i);
    const s = new vr({
      geometry: new Re({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new mo({
        text: e.vol.toFixed(0),
        font: {
          size: 8
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      })
    });
    s.visible = !1, m0.push(s);
    const o = new vr({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Me([252, 124, 124, 0.7]),
        width: 2
      },
      attributes: {
        ...e,
        polylineType: "line"
      }
    });
    p2.push(o);
  });
}
function YOe(e) {
  e.forEach((t) => {
    const r = jN(t), n = r != null && r.delayAvg ? Iq(r == null ? void 0 : r.delayAvg) : "#999", i = new vr({
      geometry: new Re({
        longitude: t.longitude,
        latitude: t.latitude
      }),
      symbol: {
        type: "picture-marker",
        // autocasts as new PictureMarkerSymbol()
        url: eCe(n, (r == null ? void 0 : r.level) || t.name),
        width: "30px",
        height: "30px"
      },
      attributes: {
        ...t,
        crossData: {
          ...jN(t),
          color: n
        },
        polylineType: "cross"
      }
    });
    Eg.push(i);
  }), xd.addMany(Eg);
}
function jN(e) {
  var r, n, i;
  const t = Vu.nodes.find((s) => s.id === e.origin_id);
  return t.entranceLan ? (t.entranceLan.forEach((o) => {
    o.startPoint = [t.lng, t.lat];
    const a = Vu.links.find((h) => h.id === o.link_id), l = QOe(a.node_ids.split(","), e.origin_id), c = getNodeInfoById(l, ["lng", "lat"]);
    o.endPoint = [c.lng, c.lat];
  }), {
    lanes: XOe(t.entranceLan),
    level: ((r = e.inter_service_level) == null ? void 0 : r.level) || "-",
    delayAvg: ((n = e.inter_service_level) == null ? void 0 : n.delayAvg) || 0,
    satAvg: ((i = e.inter_service_level) == null ? void 0 : i.satAvg) || 0
  }) : {};
}
function QOe(e, t) {
  return e.length === 0 ? null : e[0] === t ? e[e.length - 1] : e[e.length - 1] === t ? e[0] : null;
}
function XOe(e) {
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const { trun_road: n, left_road: i, straight: s, right_road: o, lanes_cnt: a, startPoint: l, endPoint: c } = e[r], h = [];
    for (let f = 1; f <= a; f++) {
      let m = "";
      n.includes(f) && (m += "trun"), i.includes(f) && (m += `${m ? "_" : ""}left`), s.includes(f) && (m += `${m ? "_" : ""}straight`), o.includes(f) && (m += `${m ? "_" : ""}right`), m === "trun_left_straight_right" && (m = "left_straight_right"), h.push({ arrow: m, vol: 0 });
    }
    t.push({
      lane: h,
      startPoint: l,
      endPoint: c
    });
  }
  return t;
}
function eCe(e = "#999", t = "A") {
  const r = document.createElement("canvas"), n = r.getContext("2d");
  r.width = 60, r.height = 60, n.beginPath(), n.arc(30, 30, 28, 0, 2 * Math.PI, !1), n.fillStyle = e, n.fill(), n.lineWidth = 2, n.strokeStyle = "#fff", n.stroke(), n.fillStyle = "#fff", n.font = "28px sans-serif";
  const i = n.measureText(t).width, s = (r.width - i) / 2, o = (r.height + 28) / 2 - 4;
  return n.fillText(t, s, o), r.toDataURL();
}
function c$() {
  xd.graphics.forEach((e) => {
    e.visible = !1;
  });
}
const Dy = /^[a-z0-9]+(-[a-z0-9]+)*$/, f2 = (e, t, r, n = "") => {
  const i = e.split(":");
  if (e.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3)
      return null;
    n = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length)
    return null;
  if (i.length > 1) {
    const a = i.pop(), l = i.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: i.length > 0 ? i[0] : n,
      prefix: l,
      name: a
    };
    return t && !X1(c) ? null : c;
  }
  const s = i[0], o = s.split("-");
  if (o.length > 1) {
    const a = {
      provider: n,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !X1(a) ? null : a;
  }
  if (r && n === "") {
    const a = {
      provider: n,
      prefix: "",
      name: s
    };
    return t && !X1(a, r) ? null : a;
  }
  return null;
}, X1 = (e, t) => e ? !!((e.provider === "" || e.provider.match(Dy)) && (t && e.prefix === "" || e.prefix.match(Dy)) && e.name.match(Dy)) : !1, Aq = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Rw = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), m2 = Object.freeze({
  ...Aq,
  ...Rw
}), v3 = Object.freeze({
  ...m2,
  body: "",
  hidden: !1
});
function tCe(e, t) {
  const r = {};
  !e.hFlip != !t.hFlip && (r.hFlip = !0), !e.vFlip != !t.vFlip && (r.vFlip = !0);
  const n = ((e.rotate || 0) + (t.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function VN(e, t) {
  const r = tCe(e, t);
  for (const n in v3)
    n in Rw ? n in e && !(n in r) && (r[n] = Rw[n]) : n in t ? r[n] = t[n] : n in e && (r[n] = e[n]);
  return r;
}
function rCe(e, t) {
  const r = e.icons, n = e.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(o) {
    if (r[o])
      return i[o] = [];
    if (!(o in i)) {
      i[o] = null;
      const a = n[o] && n[o].parent, l = a && s(a);
      l && (i[o] = [a].concat(l));
    }
    return i[o];
  }
  return (t || Object.keys(r).concat(Object.keys(n))).forEach(s), i;
}
function nCe(e, t, r) {
  const n = e.icons, i = e.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function o(a) {
    s = VN(
      n[a] || i[a],
      s
    );
  }
  return o(t), r.forEach(o), VN(e, s);
}
function Pq(e, t) {
  const r = [];
  if (typeof e != "object" || typeof e.icons != "object")
    return r;
  e.not_found instanceof Array && e.not_found.forEach((i) => {
    t(i, null), r.push(i);
  });
  const n = rCe(e);
  for (const i in n) {
    const s = n[i];
    s && (t(i, nCe(e, i, s)), r.push(i));
  }
  return r;
}
const iCe = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Aq
};
function d$(e, t) {
  for (const r in t)
    if (r in e && typeof e[r] != typeof t[r])
      return !1;
  return !0;
}
function Rq(e) {
  if (typeof e != "object" || e === null)
    return null;
  const t = e;
  if (typeof t.prefix != "string" || !e.icons || typeof e.icons != "object" || !d$(e, iCe))
    return null;
  const r = t.icons;
  for (const i in r) {
    const s = r[i];
    if (!i.match(Dy) || typeof s.body != "string" || !d$(
      s,
      v3
    ))
      return null;
  }
  const n = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const i in n) {
    const s = n[i], o = s.parent;
    if (!i.match(Dy) || typeof o != "string" || !r[o] && !n[o] || !d$(
      s,
      v3
    ))
      return null;
  }
  return t;
}
const zN = /* @__PURE__ */ Object.create(null);
function sCe(e, t) {
  return {
    provider: e,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Wd(e, t) {
  const r = zN[e] || (zN[e] = /* @__PURE__ */ Object.create(null));
  return r[t] || (r[t] = sCe(e, t));
}
function qC(e, t) {
  return Rq(t) ? Pq(t, (r, n) => {
    n ? e.icons[r] = n : e.missing.add(r);
  }) : [];
}
function oCe(e, t, r) {
  try {
    if (typeof r.body == "string")
      return e.icons[t] = { ...r }, !0;
  } catch {
  }
  return !1;
}
let Ig = !1;
function Lq(e) {
  return typeof e == "boolean" && (Ig = e), Ig;
}
function aCe(e) {
  const t = typeof e == "string" ? f2(e, !0, Ig) : e;
  if (t) {
    const r = Wd(t.provider, t.prefix), n = t.name;
    return r.icons[n] || (r.missing.has(n) ? null : void 0);
  }
}
function lCe(e, t) {
  const r = f2(e, !0, Ig);
  if (!r)
    return !1;
  const n = Wd(r.provider, r.prefix);
  return oCe(n, r.name, t);
}
function uCe(e, t) {
  if (typeof e != "object")
    return !1;
  if (typeof t != "string" && (t = e.provider || ""), Ig && !t && !e.prefix) {
    let i = !1;
    return Rq(e) && (e.prefix = "", Pq(e, (s, o) => {
      o && lCe(s, o) && (i = !0);
    })), i;
  }
  const r = e.prefix;
  if (!X1({
    provider: t,
    prefix: r,
    name: "a"
  }))
    return !1;
  const n = Wd(t, r);
  return !!qC(n, e);
}
const Nq = Object.freeze({
  width: null,
  height: null
}), Fq = Object.freeze({
  // Dimensions
  ...Nq,
  // Transformations
  ...Rw
}), cCe = /(-?[0-9.]*[0-9]+[0-9.]*)/g, dCe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function UN(e, t, r) {
  if (t === 1)
    return e;
  if (r = r || 100, typeof e == "number")
    return Math.ceil(e * t * r) / r;
  if (typeof e != "string")
    return e;
  const n = e.split(cCe);
  if (n === null || !n.length)
    return e;
  const i = [];
  let s = n.shift(), o = dCe.test(s);
  for (; ; ) {
    if (o) {
      const a = parseFloat(s);
      isNaN(a) ? i.push(s) : i.push(Math.ceil(a * t * r) / r);
    } else
      i.push(s);
    if (s = n.shift(), s === void 0)
      return i.join("");
    o = !o;
  }
}
const pCe = (e) => e === "unset" || e === "undefined" || e === "none";
function hCe(e, t) {
  const r = {
    ...m2,
    ...e
  }, n = {
    ...Fq,
    ...t
  }, i = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let s = r.body;
  [r, n].forEach((g) => {
    const v = [], b = g.hFlip, w = g.vFlip;
    let x = g.rotate;
    b ? w ? x += 2 : (v.push(
      "translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"
    ), v.push("scale(-1 1)"), i.top = i.left = 0) : w && (v.push(
      "translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"
    ), v.push("scale(1 -1)"), i.top = i.left = 0);
    let $;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        $ = i.height / 2 + i.top, v.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        v.unshift(
          "rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")"
        );
        break;
      case 3:
        $ = i.width / 2 + i.left, v.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (i.left !== i.top && ($ = i.left, i.left = i.top, i.top = $), i.width !== i.height && ($ = i.width, i.width = i.height, i.height = $)), v.length && (s = '<g transform="' + v.join(" ") + '">' + s + "</g>");
  });
  const o = n.width, a = n.height, l = i.width, c = i.height;
  let h, f;
  o === null ? (f = a === null ? "1em" : a === "auto" ? c : a, h = UN(f, l / c)) : (h = o === "auto" ? l : o, f = a === null ? UN(h, c / l) : a === "auto" ? c : a);
  const m = {}, y = (g, v) => {
    pCe(v) || (m[g] = v.toString());
  };
  return y("width", h), y("height", f), m.viewBox = i.left.toString() + " " + i.top.toString() + " " + l.toString() + " " + c.toString(), {
    attributes: m,
    body: s
  };
}
const fCe = /\sid="(\S+)"/g, mCe = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let yCe = 0;
function gCe(e, t = mCe) {
  const r = [];
  let n;
  for (; n = fCe.exec(e); )
    r.push(n[1]);
  if (!r.length)
    return e;
  const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return r.forEach((s) => {
    const o = typeof t == "function" ? t(s) : t + (yCe++).toString(), a = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    e = e.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + o + i + "$3"
    );
  }), e = e.replace(new RegExp(i, "g"), ""), e;
}
const b3 = /* @__PURE__ */ Object.create(null);
function vCe(e, t) {
  b3[e] = t;
}
function w3(e) {
  return b3[e] || b3[""];
}
function GC(e) {
  let t;
  if (typeof e.resources == "string")
    t = [e.resources];
  else if (t = e.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: e.path || "/",
    // URL length limit
    maxURL: e.maxURL || 500,
    // Timeout before next host is used.
    rotate: e.rotate || 750,
    // Timeout before failing query.
    timeout: e.timeout || 5e3,
    // Randomise default API end point.
    random: e.random === !0,
    // Start index
    index: e.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: e.dataAfterTimeout !== !1
  };
}
const HC = /* @__PURE__ */ Object.create(null), am = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], eb = [];
for (; am.length > 0; )
  am.length === 1 || Math.random() > 0.5 ? eb.push(am.shift()) : eb.push(am.pop());
HC[""] = GC({
  resources: ["https://api.iconify.design"].concat(eb)
});
function bCe(e, t) {
  const r = GC(t);
  return r === null ? !1 : (HC[e] = r, !0);
}
function WC(e) {
  return HC[e];
}
const wCe = () => {
  let e;
  try {
    if (e = fetch, typeof e == "function")
      return e;
  } catch {
  }
};
let BN = wCe();
function _Ce(e, t) {
  const r = WC(e);
  if (!r)
    return 0;
  let n;
  if (!r.maxURL)
    n = 0;
  else {
    let i = 0;
    r.resources.forEach((o) => {
      i = Math.max(i, o.length);
    });
    const s = t + ".json?icons=";
    n = r.maxURL - i - r.path.length - s.length;
  }
  return n;
}
function SCe(e) {
  return e === 404;
}
const $Ce = (e, t, r) => {
  const n = [], i = _Ce(e, t), s = "icons";
  let o = {
    type: s,
    provider: e,
    prefix: t,
    icons: []
  }, a = 0;
  return r.forEach((l, c) => {
    a += l.length + 1, a >= i && c > 0 && (n.push(o), o = {
      type: s,
      provider: e,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), n.push(o), n;
};
function xCe(e) {
  if (typeof e == "string") {
    const t = WC(e);
    if (t)
      return t.path;
  }
  return "/";
}
const TCe = (e, t, r) => {
  if (!BN) {
    r("abort", 424);
    return;
  }
  let n = xCe(t.provider);
  switch (t.type) {
    case "icons": {
      const s = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      n += s + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const s = t.uri;
      n += s.slice(0, 1) === "/" ? s.slice(1) : s;
      break;
    }
    default:
      r("abort", 400);
      return;
  }
  let i = 503;
  BN(e + n).then((s) => {
    const o = s.status;
    if (o !== 200) {
      setTimeout(() => {
        r(SCe(o) ? "abort" : "next", o);
      });
      return;
    }
    return i = 501, s.json();
  }).then((s) => {
    if (typeof s != "object" || s === null) {
      setTimeout(() => {
        s === 404 ? r("abort", s) : r("next", i);
      });
      return;
    }
    setTimeout(() => {
      r("success", s);
    });
  }).catch(() => {
    r("next", i);
  });
}, ECe = {
  prepare: $Ce,
  send: TCe
};
function ICe(e) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, r = /* @__PURE__ */ Object.create(null);
  e.sort((i, s) => i.provider !== s.provider ? i.provider.localeCompare(s.provider) : i.prefix !== s.prefix ? i.prefix.localeCompare(s.prefix) : i.name.localeCompare(s.name));
  let n = {
    provider: "",
    prefix: "",
    name: ""
  };
  return e.forEach((i) => {
    if (n.name === i.name && n.prefix === i.prefix && n.provider === i.provider)
      return;
    n = i;
    const s = i.provider, o = i.prefix, a = i.name, l = r[s] || (r[s] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = Wd(s, o));
    let h;
    a in c.icons ? h = t.loaded : o === "" || c.missing.has(a) ? h = t.missing : h = t.pending;
    const f = {
      provider: s,
      prefix: o,
      name: a
    };
    h.push(f);
  }), t;
}
function Dq(e, t) {
  e.forEach((r) => {
    const n = r.loaderCallbacks;
    n && (r.loaderCallbacks = n.filter((i) => i.id !== t));
  });
}
function MCe(e) {
  e.pendingCallbacksFlag || (e.pendingCallbacksFlag = !0, setTimeout(() => {
    e.pendingCallbacksFlag = !1;
    const t = e.loaderCallbacks ? e.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let r = !1;
    const n = e.provider, i = e.prefix;
    t.forEach((s) => {
      const o = s.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== i)
          return !0;
        const c = l.name;
        if (e.icons[c])
          o.loaded.push({
            provider: n,
            prefix: i,
            name: c
          });
        else if (e.missing.has(c))
          o.missing.push({
            provider: n,
            prefix: i,
            name: c
          });
        else
          return r = !0, !0;
        return !1;
      }), o.pending.length !== a && (r || Dq([e], s.id), s.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        s.abort
      ));
    });
  }));
}
let OCe = 0;
function CCe(e, t, r) {
  const n = OCe++, i = Dq.bind(null, r, n);
  if (!t.pending.length)
    return i;
  const s = {
    id: n,
    icons: t,
    callback: e,
    abort: i
  };
  return r.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(s);
  }), i;
}
function kCe(e, t = !0, r = !1) {
  const n = [];
  return e.forEach((i) => {
    const s = typeof i == "string" ? f2(i, t, r) : i;
    s && n.push(s);
  }), n;
}
var ACe = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function PCe(e, t, r, n) {
  const i = e.resources.length, s = e.random ? Math.floor(Math.random() * i) : e.index;
  let o;
  if (e.random) {
    let I = e.resources.slice(0);
    for (o = []; I.length > 1; ) {
      const O = Math.floor(Math.random() * I.length);
      o.push(I[O]), I = I.slice(0, O).concat(I.slice(O + 1));
    }
    o = o.concat(I);
  } else
    o = e.resources.slice(s).concat(e.resources.slice(0, s));
  const a = Date.now();
  let l = "pending", c = 0, h, f = null, m = [], y = [];
  typeof n == "function" && y.push(n);
  function g() {
    f && (clearTimeout(f), f = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), g(), m.forEach((I) => {
      I.status === "pending" && (I.status = "aborted");
    }), m = [];
  }
  function b(I, O) {
    O && (y = []), typeof I == "function" && y.push(I);
  }
  function w() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: m.length,
      subscribe: b,
      abort: v
    };
  }
  function x() {
    l = "failed", y.forEach((I) => {
      I(void 0, h);
    });
  }
  function $() {
    m.forEach((I) => {
      I.status === "pending" && (I.status = "aborted");
    }), m = [];
  }
  function T(I, O, M) {
    const L = O !== "success";
    switch (m = m.filter((N) => N !== I), l) {
      case "pending":
        break;
      case "failed":
        if (L || !e.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (O === "abort") {
      h = M, x();
      return;
    }
    if (L) {
      h = M, m.length || (o.length ? C() : x());
      return;
    }
    if (g(), $(), !e.random) {
      const N = e.resources.indexOf(I.resource);
      N !== -1 && N !== e.index && (e.index = N);
    }
    l = "completed", y.forEach((N) => {
      N(M);
    });
  }
  function C() {
    if (l !== "pending")
      return;
    g();
    const I = o.shift();
    if (I === void 0) {
      if (m.length) {
        f = setTimeout(() => {
          g(), l === "pending" && ($(), x());
        }, e.timeout);
        return;
      }
      x();
      return;
    }
    const O = {
      status: "pending",
      resource: I,
      callback: (M, L) => {
        T(O, M, L);
      }
    };
    m.push(O), c++, f = setTimeout(C, e.rotate), r(I, t, O.callback);
  }
  return setTimeout(C), w;
}
function jq(e) {
  const t = {
    ...ACe,
    ...e
  };
  let r = [];
  function n() {
    r = r.filter((a) => a().status === "pending");
  }
  function i(a, l, c) {
    const h = PCe(
      t,
      a,
      l,
      (f, m) => {
        n(), c && c(f, m);
      }
    );
    return r.push(h), h;
  }
  function s(a) {
    return r.find((l) => a(l)) || null;
  }
  return {
    query: i,
    find: s,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: n
  };
}
function qN() {
}
const p$ = /* @__PURE__ */ Object.create(null);
function RCe(e) {
  if (!p$[e]) {
    const t = WC(e);
    if (!t)
      return;
    const r = jq(t), n = {
      config: t,
      redundancy: r
    };
    p$[e] = n;
  }
  return p$[e];
}
function LCe(e, t, r) {
  let n, i;
  if (typeof e == "string") {
    const s = w3(e);
    if (!s)
      return r(void 0, 424), qN;
    i = s.send;
    const o = RCe(e);
    o && (n = o.redundancy);
  } else {
    const s = GC(e);
    if (s) {
      n = jq(s);
      const o = e.resources ? e.resources[0] : "", a = w3(o);
      a && (i = a.send);
    }
  }
  return !n || !i ? (r(void 0, 424), qN) : n.query(t, i, r)().abort;
}
const GN = "iconify2", Mg = "iconify", Vq = Mg + "-count", HN = Mg + "-version", zq = 36e5, NCe = 168;
function _3(e, t) {
  try {
    return e.getItem(t);
  } catch {
  }
}
function JC(e, t, r) {
  try {
    return e.setItem(t, r), !0;
  } catch {
  }
}
function WN(e, t) {
  try {
    e.removeItem(t);
  } catch {
  }
}
function S3(e, t) {
  return JC(e, Vq, t.toString());
}
function $3(e) {
  return parseInt(_3(e, Vq)) || 0;
}
const y2 = {
  local: !0,
  session: !0
}, Uq = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let ZC = !1;
function FCe(e) {
  ZC = e;
}
let Av = typeof window > "u" ? {} : window;
function Bq(e) {
  const t = e + "Storage";
  try {
    if (Av && Av[t] && typeof Av[t].length == "number")
      return Av[t];
  } catch {
  }
  y2[e] = !1;
}
function qq(e, t) {
  const r = Bq(e);
  if (!r)
    return;
  const n = _3(r, HN);
  if (n !== GN) {
    if (n) {
      const a = $3(r);
      for (let l = 0; l < a; l++)
        WN(r, Mg + l.toString());
    }
    JC(r, HN, GN), S3(r, 0);
    return;
  }
  const i = Math.floor(Date.now() / zq) - NCe, s = (a) => {
    const l = Mg + a.toString(), c = _3(r, l);
    if (typeof c == "string") {
      try {
        const h = JSON.parse(c);
        if (typeof h == "object" && typeof h.cached == "number" && h.cached > i && typeof h.provider == "string" && typeof h.data == "object" && typeof h.data.prefix == "string" && // Valid item: run callback
        t(h, a))
          return !0;
      } catch {
      }
      WN(r, l);
    }
  };
  let o = $3(r);
  for (let a = o - 1; a >= 0; a--)
    s(a) || (a === o - 1 ? (o--, S3(r, o)) : Uq[e].add(a));
}
function Gq() {
  if (!ZC) {
    FCe(!0);
    for (const e in y2)
      qq(e, (t) => {
        const r = t.data, n = t.provider, i = r.prefix, s = Wd(
          n,
          i
        );
        if (!qC(s, r).length)
          return !1;
        const o = r.lastModified || -1;
        return s.lastModifiedCached = s.lastModifiedCached ? Math.min(s.lastModifiedCached, o) : o, !0;
      });
  }
}
function DCe(e, t) {
  const r = e.lastModifiedCached;
  if (
    // Matches or newer
    r && r >= t
  )
    return r === t;
  if (e.lastModifiedCached = t, r)
    for (const n in y2)
      qq(n, (i) => {
        const s = i.data;
        return i.provider !== e.provider || s.prefix !== e.prefix || s.lastModified === t;
      });
  return !0;
}
function jCe(e, t) {
  ZC || Gq();
  function r(n) {
    let i;
    if (!y2[n] || !(i = Bq(n)))
      return;
    const s = Uq[n];
    let o;
    if (s.size)
      s.delete(o = Array.from(s).shift());
    else if (o = $3(i), !S3(i, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / zq),
      provider: e.provider,
      data: t
    };
    return JC(
      i,
      Mg + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !DCe(e, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), r("local") || r("session"));
}
function JN() {
}
function VCe(e) {
  e.iconsLoaderFlag || (e.iconsLoaderFlag = !0, setTimeout(() => {
    e.iconsLoaderFlag = !1, MCe(e);
  }));
}
function zCe(e, t) {
  e.iconsToLoad ? e.iconsToLoad = e.iconsToLoad.concat(t).sort() : e.iconsToLoad = t, e.iconsQueueFlag || (e.iconsQueueFlag = !0, setTimeout(() => {
    e.iconsQueueFlag = !1;
    const { provider: r, prefix: n } = e, i = e.iconsToLoad;
    delete e.iconsToLoad;
    let s;
    if (!i || !(s = w3(r)))
      return;
    s.prepare(r, n, i).forEach((a) => {
      LCe(r, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            e.missing.add(c);
          });
        else
          try {
            const c = qC(
              e,
              l
            );
            if (!c.length)
              return;
            const h = e.pendingIcons;
            h && c.forEach((f) => {
              h.delete(f);
            }), jCe(e, l);
          } catch (c) {
            console.error(c);
          }
        VCe(e);
      });
    });
  }));
}
const UCe = (e, t) => {
  const r = kCe(e, !0, Lq()), n = ICe(r);
  if (!n.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        n.loaded,
        n.missing,
        n.pending,
        JN
      );
    }), () => {
      l = !1;
    };
  }
  const i = /* @__PURE__ */ Object.create(null), s = [];
  let o, a;
  return n.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === a && c === o)
      return;
    o = c, a = h, s.push(Wd(c, h));
    const f = i[c] || (i[c] = /* @__PURE__ */ Object.create(null));
    f[h] || (f[h] = []);
  }), n.pending.forEach((l) => {
    const { provider: c, prefix: h, name: f } = l, m = Wd(c, h), y = m.pendingIcons || (m.pendingIcons = /* @__PURE__ */ new Set());
    y.has(f) || (y.add(f), i[c][h].push(f));
  }), s.forEach((l) => {
    const { provider: c, prefix: h } = l;
    i[c][h].length && zCe(l, i[c][h]);
  }), t ? CCe(t, n, s) : JN;
};
function BCe(e, t) {
  const r = {
    ...e
  };
  for (const n in t) {
    const i = t[n], s = typeof i;
    n in Nq ? (i === null || i && (s === "string" || s === "number")) && (r[n] = i) : s === typeof r[n] && (r[n] = n === "rotate" ? i % 4 : i);
  }
  return r;
}
const qCe = /[\s,]+/;
function GCe(e, t) {
  t.split(qCe).forEach((r) => {
    switch (r.trim()) {
      case "horizontal":
        e.hFlip = !0;
        break;
      case "vertical":
        e.vFlip = !0;
        break;
    }
  });
}
function HCe(e, t = 0) {
  const r = e.replace(/^-?[0-9.]*/, "");
  function n(i) {
    for (; i < 0; )
      i += 4;
    return i % 4;
  }
  if (r === "") {
    const i = parseInt(e);
    return isNaN(i) ? 0 : n(i);
  } else if (r !== e) {
    let i = 0;
    switch (r) {
      case "%":
        i = 25;
        break;
      case "deg":
        i = 90;
    }
    if (i) {
      let s = parseFloat(e.slice(0, e.length - r.length));
      return isNaN(s) ? 0 : (s = s / i, s % 1 === 0 ? n(s) : 0);
    }
  }
  return t;
}
function WCe(e, t) {
  let r = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in t)
    r += " " + n + '="' + t[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + e + "</svg>";
}
function JCe(e) {
  return e.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function ZCe(e) {
  return "data:image/svg+xml," + JCe(e);
}
function KCe(e) {
  return 'url("' + ZCe(e) + '")';
}
const ZN = {
  ...Fq,
  inline: !1
}, YCe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, QCe = {
  display: "inline-block"
}, x3 = {
  backgroundColor: "currentColor"
}, Hq = {
  backgroundColor: "transparent"
}, KN = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, YN = {
  webkitMask: x3,
  mask: x3,
  background: Hq
};
for (const e in YN) {
  const t = YN[e];
  for (const r in KN)
    t[e + r] = KN[r];
}
const tb = {};
["horizontal", "vertical"].forEach((e) => {
  const t = e.slice(0, 1) + "Flip";
  tb[e + "-flip"] = t, tb[e.slice(0, 1) + "-flip"] = t, tb[e + "Flip"] = t;
});
function QN(e) {
  return e + (e.match(/^[-0-9.]+$/) ? "px" : "");
}
const XN = (e, t) => {
  const r = BCe(ZN, t), n = { ...YCe }, i = t.mode || "svg", s = {}, o = t.style, a = typeof o == "object" && !(o instanceof Array) ? o : {};
  for (let v in t) {
    const b = t[v];
    if (b !== void 0)
      switch (v) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          r[v] = b === !0 || b === "true" || b === 1;
          break;
        case "flip":
          typeof b == "string" && GCe(r, b);
          break;
        case "color":
          s.color = b;
          break;
        case "rotate":
          typeof b == "string" ? r[v] = HCe(b) : typeof b == "number" && (r[v] = b);
          break;
        case "ariaHidden":
        case "aria-hidden":
          b !== !0 && b !== "true" && delete n["aria-hidden"];
          break;
        default: {
          const w = tb[v];
          w ? (b === !0 || b === "true" || b === 1) && (r[w] = !0) : ZN[v] === void 0 && (n[v] = b);
        }
      }
  }
  const l = hCe(e, r), c = l.attributes;
  if (r.inline && (s.verticalAlign = "-0.125em"), i === "svg") {
    n.style = {
      ...s,
      ...a
    }, Object.assign(n, c);
    let v = 0, b = t.id;
    return typeof b == "string" && (b = b.replace(/-/g, "_")), n.innerHTML = gCe(l.body, b ? () => b + "ID" + v++ : "iconifyVue"), Ha("svg", n);
  }
  const { body: h, width: f, height: m } = e, y = i === "mask" || (i === "bg" ? !1 : h.indexOf("currentColor") !== -1), g = WCe(h, {
    ...c,
    width: f + "",
    height: m + ""
  });
  return n.style = {
    ...s,
    "--svg": KCe(g),
    width: QN(c.width),
    height: QN(c.height),
    ...QCe,
    ...y ? x3 : Hq,
    ...a
  }, Ha("span", n);
};
Lq(!0);
vCe("", ECe);
if (typeof document < "u" && typeof window < "u") {
  Gq();
  const e = window;
  if (e.IconifyPreload !== void 0) {
    const t = e.IconifyPreload, r = "Invalid IconifyPreload syntax.";
    typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((n) => {
      try {
        // Check if item is an object and not null/array
        (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
        typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
        !uCe(n)) && console.error(r);
      } catch {
        console.error(r);
      }
    });
  }
  if (e.IconifyProviders !== void 0) {
    const t = e.IconifyProviders;
    if (typeof t == "object" && t !== null)
      for (let r in t) {
        const n = "IconifyProviders[" + r + "] is invalid.";
        try {
          const i = t[r];
          if (typeof i != "object" || !i || i.resources === void 0)
            continue;
          bCe(r, i) || console.error(n);
        } catch {
          console.error(n);
        }
      }
  }
}
const XCe = {
  ...m2,
  body: ""
}, hd = he({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this._name = "", this._loadingIcon = null, this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(e, t) {
      if (typeof e == "object" && e !== null && typeof e.body == "string")
        return this._name = "", this.abortLoading(), {
          data: e
        };
      let r;
      if (typeof e != "string" || (r = f2(e, !1, !0)) === null)
        return this.abortLoading(), null;
      const n = aCe(r);
      if (!n)
        return (!this._loadingIcon || this._loadingIcon.name !== e) && (this.abortLoading(), this._name = "", n !== null && (this._loadingIcon = {
          name: e,
          abort: UCe([r], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== e && (this._name = e, t && t(e));
      const i = ["iconify"];
      return r.prefix !== "" && i.push("iconify--" + r.prefix), r.provider !== "" && i.push("iconify--" + r.provider), { data: n, classes: i };
    }
  },
  // Render icon
  render() {
    this.counter;
    const e = this.$attrs, t = this.iconMounted ? this.getIcon(e.icon, e.onLoad) : null;
    if (!t)
      return XN(XCe, e);
    let r = e;
    return t.classes && (r = {
      ...e,
      class: (typeof e.class == "string" ? e.class + " " : "") + t.classes.join(" ")
    }), XN({
      ...m2,
      ...t.data
    }, r);
  }
});
R3.defaults.withCredentials = !0;
const y0 = R3.create({
  // baseURL: 'http://49.234.15.230:30192',
  withCredentials: !0,
  timeout: 6e4
});
function eke(e) {
  const t = (n) => {
    var i;
    zC.error(((i = e == null ? void 0 : e.data) == null ? void 0 : i.message) ?? n);
  };
  if (!e.data) {
    t("请求超时，服务器无响应！");
    return;
  }
  const r = {
    404: () => t("服务器资源不存在"),
    500: () => t("服务器内部错误"),
    403: () => t("没有权限访问该资源"),
    401: () => {
      t("登录状态已过期，需要重新登录"), router.push(`/login?redirect=${encodeURIComponent(window.location.pathname + window.location.search)}`);
    }
  };
  r[e.status] ? r[e.status]() : t("未知错误！");
}
y0.interceptors.request.use(
  (e) => e,
  (e) => Promise.reject(e)
);
y0.interceptors.response.use(
  (e) => e,
  (e) => {
    const { response: t } = e;
    if (t)
      return eke(t), t;
    zC.error("Network error");
  }
);
let g2 = "";
function tke(e) {
  g2 = e;
}
function rke(e, t) {
  return y0.get(`${g2}/api/v1/prediction/stepData`, {
    withCredentials: !0,
    params: {
      tag: "step",
      projectId: e,
      predictionId: t
    }
  }).then((r) => r.data).catch((r) => {
    throw r;
  });
}
function Wq(e) {
  return y0.get(`${g2}/api/v1/prediction/predictionOutputData/${e}`).then((t) => t.data).catch((t) => {
    throw t;
  });
}
function nke(e, t) {
  return y0.post(`${g2}/api/v1/prediction/od`, {
    projectId: e,
    currentPredictionId: t
  }).then((r) => r.data).catch((r) => {
    throw r;
  });
}
let T3 = {}, E3 = {};
const Lw = [], ss = q([]);
function ike(e) {
  e ? ske(e) : T3 = {};
}
function ske(e) {
  Wq(e).then((t) => {
    var r;
    t.code === 0 && (T3 = t.data, E3 = (r = T3.list.filter((i) => {
      const s = Ue.predictionAssessmentType === "current" ? void 0 : Ue.predictionAssessmentType;
      return i.predictionAssessmentType === s && i.predictionResearchPhase === Ue.predictionResearchPhase;
    })[0]) == null ? void 0 : r.data, oke());
  }).catch((t) => ({ error: t }));
}
function oke() {
  Lw.length = 0, d2.links.forEach((e, t) => {
    const r = {
      saturation: e.saturation - E3.links[t].saturation,
      vol: e.vol - E3.links[t].vol,
      origin_id: e.origin_id,
      id: e.id
    }, n = Vu.links.find((i) => i.id === e.origin_id);
    r.link_name = n.link_name, r.shape = n.shape.split(" ").map((i) => i.split(",")), r.nodes = Eq(n.shape, e.direction), Lw.push(r);
  }), ake();
}
const Nw = new D_(), e5 = [], I3 = [];
function ake() {
  f0.forEach((e) => {
    e.visible = !1;
  }), Of.forEach((e) => {
    e.visible = !1;
  }), Lw.forEach((e) => {
    const t = UC(e.nodes), r = e.vol > 0 ? "red" : "green", n = new vr({
      geometry: {
        type: "polyline",
        paths: e.nodes
      },
      symbol: {
        type: "simple-line",
        color: new Me(r),
        width: uke(e.vol)
      },
      attributes: {
        ...e,
        polylineType: "diff-line"
      }
    });
    e5.push(n);
    const i = new vr({
      geometry: new Re({
        longitude: t.center[0],
        latitude: t.center[1]
      }),
      symbol: new mo({
        text: e.vol.toFixed(0),
        font: {
          size: 10
        },
        color: "black",
        haloColor: "white",
        haloSize: "2px",
        angle: t.slope
      }),
      attributes: {
        polylineType: "diff-line-text"
      }
    });
    I3.push(i), ki.zoom < 16 && (i.visible = !1);
  }), Nw.addMany([...e5, ...I3]), Ts.add(Nw);
}
function lm() {
  Nw.removeAll(), Ts.remove(Nw);
}
function lke() {
  const e = Array.from(new Set(Lw.map((i) => Math.abs(i.vol)))).sort((i, s) => i - s), t = e.length, r = [
    e[0],
    // 0%
    e[Math.ceil((t - 1) * 0.25)],
    e[Math.ceil((t - 1) * 0.5)],
    e[Math.ceil((t - 1) * 0.75)]
  ], n = [
    { value: 1, text: r[0] },
    { value: 4, text: r[1] },
    { value: 7, text: r[2] },
    { value: 10, text: r[3] }
  ];
  return ss.value = n, n;
}
function uke(e) {
  const t = Math.abs(e);
  return ss.value.length === 0 && lke(), t >= ss.value[0].text && t < ss.value[1].text ? ss.value[0].value : t >= ss.value[1].text && t < ss.value[2].text ? flowLegend.value[1].value : t >= ss.value[2].text && t < ss.value[3].text ? ss.value[2].value : ss.value[3].value;
}
ki.watch("zoom", (e) => {
  I3.forEach((t) => {
    t.visible = Ue.flowDiff && ki.zoom > 16;
  });
});
const Jq = q([]), t5 = new D_();
function cke() {
  t5.removeAll(), Ts.remove(t5), Jq.value.length = 0, ed();
}
const xp = "material-symbols:minimize", h$ = "material-symbols:chrome-maximize-outline-sharp", Zq = {
  __name: "ToggleWindowButton",
  emits: ["change"],
  setup(e, { emit: t }) {
    const r = t, n = q(xp);
    function i() {
      n.value = n.value === xp ? h$ : xp, r("change", n.value === xp);
    }
    return (s, o) => (R(), Z("div", {
      class: "cursor-pointer",
      onClick: i
    }, [
      n.value === xp ? (R(), ue(_(hd), {
        key: 0,
        icon: xp,
        class: "text-sm text-stone-600"
      })) : le("", !0),
      n.value === h$ ? (R(), ue(_(hd), {
        key: 1,
        icon: h$,
        class: "text-sm text-stone-600"
      })) : le("", !0)
    ]));
  }
}, dke = { class: "bg-white shadow text-sm divide-y w-[340px]" }, pke = { class: "h-10 flex items-center justify-between px-3" }, hke = /* @__PURE__ */ K("div", { class: "text-stone-600 text-base" }, " 业务指标筛选 ", -1), fke = {
  key: 0,
  class: "divide-y"
}, mke = { class: "px-3 py-2" }, yke = { class: "w-full flex items-center justify-between" }, gke = { class: "text-[#606266] leading-normal" }, vke = { class: "w-full flex items-center justify-between" }, bke = { class: "w-full" }, wke = { class: "text-[#606266] text-xs pt-2 pb-1 h-6 flex items-center" }, _ke = { class: "py-2 px-3" }, Ske = { class: "grid grid-cols-2 grid-rows-1 gap-1" }, $ke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, xke = /* @__PURE__ */ K("div", null, "热力图", -1), Tke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Eke = /* @__PURE__ */ K("div", null, "期望线", -1), Ike = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Mke = /* @__PURE__ */ K("div", null, "蛛网图", -1), Oke = { class: "flex items-center justify-center space-x-2 text-[#606266]" }, Cke = /* @__PURE__ */ K("div", null, "流量差", -1), kke = {
  __name: "ControlPanel",
  setup(e) {
    const t = A(() => Ue), r = q(!0), n = q("");
    function i(M) {
      r.value = M;
    }
    const s = ci([
      {
        label: "盘溪-江北嘴地下通道",
        value: 2355,
        children: [
          {
            label: "现状方案",
            value: 27446
          },
          {
            label: "规划方案",
            value: 27445
          },
          {
            label: "规划方案2",
            value: 27443
          }
        ]
      }
    ]), o = q([]);
    async function a() {
      const M = JMe.service({
        lock: !0,
        text: "加载中",
        background: "rgba(0, 0, 0, 0.7)"
      });
      Promise.all([
        rke(t.value.project[0], t.value.project[1]),
        Wq(t.value.project[1]),
        nke(t.value.project[0], t.value.project[1])
      ]).then((L) => {
        var N;
        L[0].code === 0 && L[1].code === 0 && (Object.assign(Vu, L[0].data), Object.assign(kw, L[1].data), o.value = IOe(L[1].data.list), l$()), ((N = L[2]) == null ? void 0 : N.code) === 0 && (Object.assign(Mq, L[2].data), ROe(t, L[2].data)), M.close();
      }).catch((L) => {
        L.response && L.response.status === 404 ? console.error("获取OD数据时发生404错误") : console.error("发生未知错误", L), M.close();
      });
    }
    function l() {
      POe(), a();
    }
    function c(M) {
      ed(M === 1 ? "link" : "cross"), M === 2 && (t.value.predictionIndex = 1);
    }
    function h(M) {
      ed(M === 1 ? "link" : "flow");
    }
    function f() {
      t.value.link_name = "", cke();
    }
    function m(M) {
      t.value.heatMap && NN(), t.value.expectedLine && NOe();
    }
    function y() {
      l$();
    }
    function g() {
      l$();
    }
    qt(() => {
      t.value.project.length === 0 && kv("请在条件筛选框中选择相应项⽬及⽅案");
    });
    function v(M) {
      lm(), ike(M);
    }
    function b() {
      n.value = "", lm(), c$();
    }
    function w() {
      FOe(), Ue.community.length = 0;
    }
    function x() {
      HOe();
    }
    function $() {
      WOe();
    }
    function T(M) {
      M ? NN() : Oq();
    }
    function C(M) {
      M ? (kv("请在地图中选择任意交通小区，允许多选"), c$(), DOe(), t.value.spiderWeb = !1, t.value.flowDiff = !1, n.value = "", lm()) : (FN(), ed());
    }
    function I(M) {
      M ? (kv("请在地图中选择任意路段"), t.value.predictionObject = 1, t.value.predictionIndex = 1, t.value.flowDiff = !1, t.value.expectedLine = !1, FN(), n.value = "", lm(), ed()) : f();
    }
    function O(M) {
      M ? (kv("流量差，即路段流量差值。系统将当前预测结果对应路段流量与目标对象进行比较，并将差值呈现在路网上"), t.value.predictionObject = 1, t.value.predictionIndex = 2, c$(), t.value.expectedLine = !1, t.value.spiderWeb = !1) : (n.value = "", lm(), ed());
    }
    return (M, L) => (R(), Z("div", dke, [
      K("div", pke, [
        hke,
        de(Zq, { onChange: i })
      ]),
      de(_(yq), null, {
        default: Y(() => [
          r.value ? (R(), Z("div", fke, [
            K("div", mke, [
              de(_(LTe), {
                model: t.value,
                "label-width": "95px"
              }, {
                default: Y(() => [
                  de(_(Ls), {
                    label: "选择方案:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(H3e), {
                        modelValue: t.value.project,
                        "onUpdate:modelValue": L[0] || (L[0] = (N) => t.value.project = N),
                        options: s,
                        props: { expandTrigger: "hover" },
                        filterable: "",
                        placeholder: "请选择项目及方案",
                        class: "w-full",
                        onChange: l
                      }, null, 8, ["modelValue", "options"])
                    ]),
                    _: 1
                  }),
                  de(_(Ls), {
                    label: "研究年:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Ov), {
                        modelValue: t.value.predictionAssessmentType,
                        "onUpdate:modelValue": L[1] || (L[1] = (N) => t.value.predictionAssessmentType = N),
                        disabled: t.value.project.length === 0,
                        onChange: y
                      }, {
                        default: Y(() => [
                          de(_(zo), {
                            label: "current",
                            class: "!mr-4"
                          }, {
                            default: Y(() => [
                              jr(" 现状 ")
                            ]),
                            _: 1
                          }),
                          de(_(zo), {
                            label: "near",
                            class: "!mr-4"
                          }, {
                            default: Y(() => [
                              jr(" 近期 ")
                            ]),
                            _: 1
                          }),
                          de(_(zo), { label: "far" }, {
                            default: Y(() => [
                              jr(" 远期 ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  }),
                  de(_(Ls), {
                    label: "研究时段:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(kN), {
                        modelValue: t.value.predictionResearchPhase,
                        "onUpdate:modelValue": L[2] || (L[2] = (N) => t.value.predictionResearchPhase = N),
                        placeholder: "请选择研究时段",
                        class: "w-full",
                        disabled: t.value.project.length === 0,
                        onChange: g
                      }, {
                        default: Y(() => [
                          de(_(Sp), {
                            label: "早高峰",
                            value: "morningPeak",
                            disabled: !o.value.includes("morningPeak")
                          }, null, 8, ["disabled"]),
                          de(_(Sp), {
                            label: "晚高峰",
                            value: "nightPeak",
                            disabled: !o.value.includes("nightPeak")
                          }, null, 8, ["disabled"]),
                          de(_(Sp), {
                            label: "节假日",
                            value: "holiday",
                            disabled: !o.value.includes("holiday")
                          }, null, 8, ["disabled"]),
                          de(_(Sp), {
                            label: "其它",
                            value: "other",
                            disabled: !o.value.includes("other")
                          }, null, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  }),
                  t.value.expectedLine ? le("", !0) : (R(), ue(_(Ls), {
                    key: 0,
                    label: "对象:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Ov), {
                        modelValue: t.value.predictionObject,
                        "onUpdate:modelValue": L[3] || (L[3] = (N) => t.value.predictionObject = N),
                        disabled: t.value.project.length === 0,
                        onChange: c
                      }, {
                        default: Y(() => [
                          de(_(zo), {
                            label: 1,
                            class: "!mr-4"
                          }, {
                            default: Y(() => [
                              jr(" 路段 ")
                            ]),
                            _: 1
                          }),
                          de(_(zo), {
                            label: 2,
                            disabled: t.value.spiderWeb || t.value.flowDiff
                          }, {
                            default: Y(() => [
                              jr(" 交叉口 ")
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })),
                  t.value.expectedLine ? le("", !0) : (R(), ue(_(Ls), {
                    key: 1,
                    label: "指标:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Ov), {
                        modelValue: t.value.predictionIndex,
                        "onUpdate:modelValue": L[4] || (L[4] = (N) => t.value.predictionIndex = N),
                        disabled: t.value.project.length === 0,
                        onChange: h
                      }, {
                        default: Y(() => [
                          de(_(zo), {
                            label: 1,
                            class: "!mr-4",
                            disabled: t.value.flowDiff
                          }, {
                            default: Y(() => [
                              jr(" 服务水平 ")
                            ]),
                            _: 1
                          }, 8, ["disabled"]),
                          de(_(zo), {
                            label: 2,
                            disabled: t.value.predictionObject === 2
                          }, {
                            default: Y(() => [
                              jr(" 流量 ")
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })),
                  t.value.expectedLine || t.value.heatMap ? (R(), ue(_(Ls), {
                    key: 2,
                    label: "小区交通量:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Ov), {
                        modelValue: t.value.predictionTrans,
                        "onUpdate:modelValue": L[5] || (L[5] = (N) => t.value.predictionTrans = N),
                        disabled: t.value.project.length === 0,
                        onChange: m
                      }, {
                        default: Y(() => [
                          de(_(zo), {
                            label: "out",
                            class: "!mr-4"
                          }, {
                            default: Y(() => [
                              jr(" 产生 ")
                            ]),
                            _: 1
                          }),
                          de(_(zo), { label: "in" }, {
                            default: Y(() => [
                              jr(" 吸引 ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue", "disabled"])
                    ]),
                    _: 1
                  })) : le("", !0),
                  t.value.spiderWeb ? (R(), ue(_(Ls), {
                    key: 3,
                    label: "选择路段:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      K("div", yke, [
                        K("div", gke, [
                          K("span", {
                            class: B({ "text-red-500": !t.value.link_name })
                          }, Xe(t.value.link_name || "请选择"), 3)
                        ]),
                        t.value.link_name ? (R(), ue(_(o$), {
                          key: 0,
                          size: "small",
                          type: "primary",
                          text: "",
                          bg: "",
                          class: "ml-2",
                          onClick: f
                        }, {
                          default: Y(() => [
                            jr(" 重置 ")
                          ]),
                          _: 1
                        })) : le("", !0)
                      ])
                    ]),
                    _: 1
                  })) : le("", !0),
                  t.value.expectedLine ? (R(), ue(_(Ls), {
                    key: 4,
                    label: "脉冲图:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Hc), {
                        modelValue: t.value.showPulse,
                        "onUpdate:modelValue": L[6] || (L[6] = (N) => t.value.showPulse = N),
                        onChange: $
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })) : le("", !0),
                  t.value.expectedLine ? (R(), ue(_(Ls), {
                    key: 5,
                    label: "显示OD数据:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      de(_(Hc), {
                        modelValue: t.value.showOd,
                        "onUpdate:modelValue": L[7] || (L[7] = (N) => t.value.showOd = N),
                        onChange: x
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })) : le("", !0),
                  t.value.expectedLine ? (R(), ue(_(Ls), {
                    key: 6,
                    label: "交通小区:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      K("div", vke, [
                        K("div", {
                          class: B(["text-[#606266] leading-normal flex-1 w-[170px] break-words", { "text-red-500": !t.value.community.length }])
                        }, Xe(t.value.community.join("; ") || "请选择"), 3),
                        t.value.community.length ? (R(), ue(_(o$), {
                          key: 0,
                          size: "small",
                          type: "primary",
                          text: "",
                          bg: "",
                          class: "ml-2",
                          onClick: w
                        }, {
                          default: Y(() => [
                            jr(" 重置 ")
                          ]),
                          _: 1
                        })) : le("", !0)
                      ])
                    ]),
                    _: 1
                  })) : le("", !0),
                  t.value.flowDiff ? (R(), ue(_(Ls), {
                    key: 7,
                    label: "对比方案:",
                    class: "!mb-1"
                  }, {
                    default: Y(() => [
                      K("div", bke, [
                        K("div", wke, [
                          jr(" 请选择以下预测方案进行比较 "),
                          n.value ? (R(), ue(_(o$), {
                            key: 0,
                            size: "small",
                            text: "",
                            type: "primary",
                            class: "!py-0",
                            onClick: b
                          }, {
                            default: Y(() => [
                              jr(" 重置 ")
                            ]),
                            _: 1
                          })) : le("", !0)
                        ]),
                        de(_(kN), {
                          modelValue: n.value,
                          "onUpdate:modelValue": L[8] || (L[8] = (N) => n.value = N),
                          placeholder: "请选择",
                          class: "w-full",
                          onChange: v
                        }, {
                          default: Y(() => [
                            de(_(Sp), {
                              label: "现状方案",
                              value: 27446
                            }),
                            de(_(Sp), {
                              label: "规划方案2",
                              value: 27443
                            })
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ])
                    ]),
                    _: 1
                  })) : le("", !0)
                ]),
                _: 1
              }, 8, ["model"])
            ]),
            K("div", _ke, [
              K("div", Ske, [
                K("div", $ke, [
                  de(_(hd), {
                    icon: "carbon:heat-map-02",
                    class: "text-base"
                  }),
                  xke,
                  de(_(Hc), {
                    modelValue: t.value.heatMap,
                    "onUpdate:modelValue": L[9] || (L[9] = (N) => t.value.heatMap = N),
                    disabled: t.value.project.length === 0,
                    onChange: T
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                K("div", Tke, [
                  de(_(hd), {
                    icon: "carbon:summary-kpi",
                    class: "text-base"
                  }),
                  Eke,
                  de(_(Hc), {
                    modelValue: t.value.expectedLine,
                    "onUpdate:modelValue": L[10] || (L[10] = (N) => t.value.expectedLine = N),
                    disabled: t.value.project.length === 0,
                    onChange: C
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                K("div", Ike, [
                  de(_(hd), {
                    icon: "carbon:chart-parallel",
                    class: "text-base"
                  }),
                  Mke,
                  de(_(Hc), {
                    modelValue: t.value.spiderWeb,
                    "onUpdate:modelValue": L[11] || (L[11] = (N) => t.value.spiderWeb = N),
                    disabled: t.value.project.length === 0,
                    onChange: I
                  }, null, 8, ["modelValue", "disabled"])
                ]),
                K("div", Oke, [
                  de(_(hd), {
                    icon: "carbon:traffic-flow",
                    class: "text-base"
                  }),
                  Cke,
                  de(_(Hc), {
                    modelValue: t.value.flowDiff,
                    "onUpdate:modelValue": L[12] || (L[12] = (N) => t.value.flowDiff = N),
                    disabled: t.value.project.length === 0,
                    onChange: O
                  }, null, 8, ["modelValue", "disabled"])
                ])
              ])
            ])
          ])) : le("", !0)
        ]),
        _: 1
      })
    ]));
  }
}, Ake = { class: "bg-white shadow text-sm divide-y min-w-[200px]" }, Pke = { class: "h-10 flex items-center justify-between px-3" }, Rke = /* @__PURE__ */ K("div", { class: "text-stone-600 text-base" }, " 图例 ", -1), Lke = {
  key: 0,
  class: "px-3 py-2"
}, Nke = {
  key: 0,
  class: "space-y-2"
}, Fke = {
  key: 0,
  class: "space-y-2 mb-5"
}, Dke = { class: "flex items-center justify-between" }, jke = { class: "text-center" }, Vke = /* @__PURE__ */ K("div", { class: "flex items-center space-x-4" }, [
  /* @__PURE__ */ K("div", { class: "w-10 h-[2px] bg-green-800" }),
  /* @__PURE__ */ K("span", null, " 小于等于 0")
], -1), zke = /* @__PURE__ */ K("div", { class: "flex items-center space-x-4" }, [
  /* @__PURE__ */ K("div", { class: "w-10 h-[2px] bg-red-500" }),
  /* @__PURE__ */ K("span", null, " 大于 0")
], -1), Uke = {
  key: 0,
  class: "space-y-2 mb-5"
}, Bke = { class: "flex items-center justify-between" }, qke = { class: "text-center" }, Gke = {
  key: 0,
  class: "space-y-2 mb-5"
}, Hke = { class: "flex items-center justify-between" }, Wke = { class: "text-center" }, Jke = {
  key: 0,
  class: "space-y-2"
}, Zke = {
  key: 1,
  class: "space-y-2"
}, Kke = { class: "flex items-center justify-between" }, Yke = { class: "text-center" }, Qke = {
  __name: "MapLegend",
  setup(e) {
    const t = A(() => Ue), r = [
      {
        text: "A 非常畅通",
        value: "#4B7902"
      },
      {
        text: "B 畅通",
        value: "#95F204"
      },
      {
        text: "C 基本畅通",
        value: "#FFD400"
      },
      {
        text: "D 轻度拥堵",
        value: "#F47920"
      },
      {
        text: "E 拥堵",
        value: "#D9001B"
      },
      {
        text: "F 严重拥堵",
        value: "#843900"
      }
    ];
    A(() => h0);
    const n = q(!0);
    function i(h) {
      n.value = h;
    }
    const s = A(() => is), o = A(() => Cq), a = A(() => ss), l = A(() => g3), c = A(() => Jq);
    return (h, f) => (R(), Z("div", Ake, [
      K("div", Pke, [
        Rke,
        de(Zq, { onChange: i })
      ]),
      de(_(yq), null, {
        default: Y(() => [
          n.value ? (R(), Z("div", Lke, [
            t.value.flowDiff ? (R(), Z("div", Nke, [
              a.value.value.length ? (R(), Z("div", Fke, [
                K("div", Dke, [
                  (R(!0), Z(Mt, null, Mi(a.value.value, (m) => (R(), Z("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    K("div", jke, Xe(m.text), 1),
                    K("div", {
                      style: $t({ height: `${m.value}px` }),
                      class: "bg-[#ccc]"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : le("", !0),
              Vke,
              zke
            ])) : t.value.expectedLine ? (R(), Z(Mt, { key: 1 }, [
              l.value.value ? (R(), Z("div", Uke, [
                K("div", Bke, [
                  (R(!0), Z(Mt, null, Mi(o.value.value, (m) => (R(), Z("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    K("div", qke, Xe(m.text), 1),
                    K("div", {
                      style: $t({ height: `${m.value}px` }),
                      class: "bg-orange-400"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : le("", !0)
            ], 64)) : t.value.spiderWeb ? (R(), Z(Mt, { key: 2 }, [
              c.value.value.length ? (R(), Z("div", Gke, [
                K("div", Hke, [
                  (R(!0), Z(Mt, null, Mi(c.value.value, (m) => (R(), Z("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    K("div", Wke, Xe(m.text), 1),
                    K("div", {
                      style: $t({ height: `${m.value}px` }),
                      class: "bg-[#90EE90]"
                    }, null, 4)
                  ]))), 128))
                ])
              ])) : le("", !0)
            ], 64)) : (R(), Z(Mt, { key: 3 }, [
              t.value.predictionIndex === 1 ? (R(), Z("div", Jke, [
                (R(), Z(Mt, null, Mi(r, (m) => K("div", {
                  key: m.value,
                  class: "flex items-center space-x-4"
                }, [
                  K("div", {
                    class: B(t.value.predictionObject === 1 ? "w-10 h-[2px]" : "w-5 h-5 rounded-full border-2 border-gray-300"),
                    style: $t({ backgroundColor: m.value })
                  }, null, 6),
                  K("span", null, Xe(m.text), 1)
                ])), 64))
              ])) : (R(), Z("div", Zke, [
                K("div", Kke, [
                  (R(!0), Z(Mt, null, Mi(s.value.value, (m) => (R(), Z("div", {
                    key: m.value,
                    class: "flex-1 flex flex-col justify-end h-8"
                  }, [
                    K("div", Yke, Xe(m.text), 1),
                    K("div", {
                      style: $t({ height: `${m.value}px` }),
                      class: "bg-red-400"
                    }, null, 4)
                  ]))), 128))
                ])
              ]))
            ], 64))
          ])) : le("", !0)
        ]),
        _: 1
      })
    ]));
  }
}, Xke = { class: "bg-white shadow text-sm" }, eAe = { class: "px-3 py-2 flex items-center space-x-2" }, tAe = /* @__PURE__ */ K("span", null, "卫星图", -1), rAe = {
  __name: "ChangeMap",
  emits: ["changeMap"],
  setup(e, { emit: t }) {
    const r = t, n = q("geoscene-blue");
    function i(s) {
      r("changeMap", s);
    }
    return (s, o) => (R(), Z("div", Xke, [
      K("div", eAe, [
        de(_(hd), { icon: "ic:round-satellite-alt" }),
        tAe,
        de(_(Hc), {
          modelValue: n.value,
          "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
          "active-value": "tianditu-image",
          "inactive-value": "geoscene-blue",
          onChange: i
        }, null, 8, ["modelValue"])
      ])
    ]));
  }
}, nAe = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, i] of t)
    r[n] = i;
  return r;
}, iAe = (e) => ($G("data-v-f2848984"), e = e(), xG(), e), sAe = /* @__PURE__ */ iAe(() => /* @__PURE__ */ K("div", { class: "h-0" }, null, -1)), oAe = {
  __name: "ShowCross",
  setup(e) {
    const t = q(null), r = A(() => m3.value);
    function n() {
      m3.value = !1, r.value = !1;
    }
    function i() {
      xOe(t);
    }
    return (s, o) => (R(), Z("div", null, [
      de(_(mMe), {
        modelValue: r.value,
        "onUpdate:modelValue": o[0] || (o[0] = (a) => r.value = a),
        title: "",
        width: "500px",
        onClose: n,
        onOpened: i
      }, {
        header: Y(() => [
          sAe
        ]),
        default: Y(() => [
          K("canvas", {
            ref_key: "canvasRef",
            ref: t,
            class: "w-[500px] h-[500px] bg-neutral-400"
          }, null, 512)
        ]),
        _: 1
      }, 8, ["modelValue"])
    ]));
  }
}, aAe = /* @__PURE__ */ nAe(oAe, [["__scopeId", "data-v-f2848984"]]), lAe = { class: "relative bg-slate-50 h-screen" }, rb = {
  __name: "view",
  props: {
    baseUrl: String
  },
  setup(e) {
    const t = e, r = q(null);
    qt(() => {
      ki.container = r.value, tke(t.baseUrl);
    });
    function n(i) {
      Ts.basemap = i;
    }
    return (i, s) => (R(), Z("div", lAe, [
      K("div", {
        ref_key: "mapDiv",
        ref: r,
        class: "w-full h-full absolute top-0 left-0 z-10"
      }, null, 512),
      de(kke, { class: "z-20 absolute top-4 left-4" }),
      de(Qke, { class: "z-20 absolute bottom-4 left-4" }),
      de(rAe, {
        class: "z-20 absolute top-4 right-4",
        onChangeMap: n
      }),
      de(aAe)
    ]));
  }
};
rb.install = (e) => {
  e.component(rb.__name, rb);
};
const uAe = [rb], cAe = (e) => {
  uAe.forEach((t) => {
    e.component(t.__name, t);
  });
}, bFe = { install: cAe };
export {
  el as $,
  Yye as A,
  as as B,
  et as C,
  GPe as D,
  OV as E,
  $O as F,
  gf as G,
  G as H,
  dle as I,
  wPe as J,
  UPe as K,
  Di as L,
  gF as M,
  fM as N,
  uFe as O,
  $Ae as P,
  SU as Q,
  kh as R,
  tn as S,
  Zd as T,
  yy as U,
  je as V,
  pi as W,
  pFe as X,
  dFe as Y,
  F0e as Z,
  sa as _,
  u as a,
  h4e as a$,
  Md as a0,
  P8 as a1,
  A8 as a2,
  k8 as a3,
  gy as a4,
  R8 as a5,
  bRe as a6,
  $X as a7,
  d_ as a8,
  tt as a9,
  af as aA,
  c_ as aB,
  Ct as aC,
  xf as aD,
  Yd as aE,
  MPe as aF,
  NRe as aG,
  MM as aH,
  Qe as aI,
  rp as aJ,
  Ru as aK,
  Ju as aL,
  ll as aM,
  xT as aN,
  Zt as aO,
  $T as aP,
  ET as aQ,
  Jb as aR,
  e9 as aS,
  j as aT,
  st as aU,
  P2 as aV,
  bt as aW,
  GM as aX,
  qA as aY,
  _Re as aZ,
  s4e as a_,
  BA as aa,
  p4e as ab,
  lRe as ac,
  j5 as ad,
  zr as ae,
  Kd as af,
  Hy as ag,
  dye as ah,
  hf as ai,
  OZ as aj,
  pye as ak,
  A5e as al,
  m5e as am,
  WA as an,
  $y as ao,
  uT as ap,
  R5e as aq,
  P5e as ar,
  Jd as as,
  ws as at,
  _de as au,
  fU as av,
  X0e as aw,
  EM as ax,
  wLe as ay,
  Re as az,
  d as b,
  vee as b$,
  M_ as b0,
  _ye as b1,
  W5e as b2,
  Ae as b3,
  Bw as b4,
  lr as b5,
  sX as b6,
  iX as b7,
  q5e as b8,
  B5e as b9,
  CAe as bA,
  BZ as bB,
  p6 as bC,
  h6 as bD,
  qZ as bE,
  oM as bF,
  lM as bG,
  Es as bH,
  xQ as bI,
  TQ as bJ,
  EQ as bK,
  AQ as bL,
  FQ as bM,
  a8 as bN,
  s8 as bO,
  o8 as bP,
  NQ as bQ,
  UQ as bR,
  BQ as bS,
  X6 as bT,
  tQ as bU,
  SQ as bV,
  ex as bW,
  l_ as bX,
  VZ as bY,
  Iz as bZ,
  Fye as b_,
  vs as ba,
  vY as bb,
  yY as bc,
  s0e as bd,
  o0e as be,
  a0e as bf,
  Rt as bg,
  da as bh,
  Ng as bi,
  Ie as bj,
  re as bk,
  ce as bl,
  Xse as bm,
  Sk as bn,
  Rh as bo,
  SPe as bp,
  gRe as bq,
  uo as br,
  RAe as bs,
  md as bt,
  bAe as bu,
  S$ as bv,
  Sde as bw,
  z5 as bx,
  BPe as by,
  QH as bz,
  E as c,
  cRe as c$,
  Z3 as c0,
  $Re as c1,
  ree as c2,
  G8 as c3,
  zRe as c4,
  URe as c5,
  DRe as c6,
  VRe as c7,
  en as c8,
  JPe as c9,
  kF as cA,
  Hw as cB,
  JM as cC,
  qg as cD,
  tg as cE,
  bu as cF,
  Ai as cG,
  Dne as cH,
  s_ as cI,
  jne as cJ,
  QV as cK,
  y4e as cL,
  H0e as cM,
  Uye as cN,
  zye as cO,
  Bye as cP,
  ha as cQ,
  XF as cR,
  Q0e as cS,
  Uh as cT,
  ge as cU,
  Ot as cV,
  ZO as cW,
  mo as cX,
  pRe as cY,
  Mse as cZ,
  vRe as c_,
  o_ as ca,
  kT as cb,
  kY as cc,
  X$ as cd,
  H6 as ce,
  Q6 as cf,
  Z6 as cg,
  qY as ch,
  Lg as ci,
  xM as cj,
  iz as ck,
  G0e as cl,
  A0e as cm,
  D0e as cn,
  sz as co,
  Lz as cp,
  Go as cq,
  Wy as cr,
  age as cs,
  ige as ct,
  nge as cu,
  hi as cv,
  ji as cw,
  S_ as cx,
  Hu as cy,
  ep as cz,
  Fi as d,
  qb as d$,
  In as d0,
  bs as d1,
  D_ as d2,
  uA as d3,
  du as d4,
  Gy as d5,
  W9 as d6,
  cs as d7,
  xt as d8,
  nf as d9,
  u5e as dA,
  iC as dB,
  ORe as dC,
  rU as dD,
  Ld as dE,
  F0 as dF,
  Xy as dG,
  Bu as dH,
  Pd as dI,
  lK as dJ,
  Pie as dK,
  pl as dL,
  lNe as dM,
  Wg as dN,
  zy as dO,
  Q3 as dP,
  b1 as dQ,
  mAe as dR,
  CV as dS,
  KT as dT,
  Bh as dU,
  uce as dV,
  kV as dW,
  Uw as dX,
  Ude as dY,
  rj as dZ,
  FO as d_,
  SNe as da,
  xNe as db,
  _Ne as dc,
  t7 as dd,
  DNe as de,
  bpe as df,
  CNe as dg,
  hpe as dh,
  jNe as di,
  TNe as dj,
  wNe as dk,
  ANe as dl,
  VNe as dm,
  kNe as dn,
  pAe as dp,
  qme as dq,
  a4e as dr,
  f4e as ds,
  yPe as dt,
  APe as du,
  gv as dv,
  E4 as dw,
  Xb as dx,
  tye as dy,
  td as dz,
  Dd as e,
  yye as e$,
  z3 as e0,
  cce as e1,
  _k as e2,
  Gj as e3,
  sl as e4,
  Lye as e5,
  yF as e6,
  r9 as e7,
  OPe as e8,
  $Pe as e9,
  hme as eA,
  Uu as eB,
  d4e as eC,
  MAe as eD,
  yf as eE,
  lQ as eF,
  fAe as eG,
  xZ as eH,
  Ph as eI,
  nM as eJ,
  GH as eK,
  GX as eL,
  Qse as eM,
  Nd as eN,
  L0e as eO,
  C0e as eP,
  Xye as eQ,
  fA as eR,
  D8 as eS,
  tve as eT,
  sge as eU,
  YO as eV,
  q_ as eW,
  H4 as eX,
  wI as eY,
  KO as eZ,
  U_ as e_,
  bNe as ea,
  eRe as eb,
  uh as ec,
  hy as ed,
  zv as ee,
  AT as ef,
  Ja as eg,
  ol as eh,
  We as ei,
  Fg as ej,
  Tn as ek,
  Vae as el,
  xRe as em,
  rPe as en,
  uRe as eo,
  G6 as ep,
  aQ as eq,
  sce as er,
  Qr as es,
  ace as et,
  ro as eu,
  CW as ev,
  Yj as ew,
  jZ as ex,
  Rd as ey,
  d5e as ez,
  ln as f,
  Age as f$,
  rge as f0,
  sC as f1,
  wU as f2,
  W0e as f3,
  KX as f4,
  ZX as f5,
  mX as f6,
  rA as f7,
  Bn as f8,
  cu as f9,
  qK as fA,
  Uv as fB,
  dm as fC,
  Me as fD,
  S4e as fE,
  dPe as fF,
  LY as fG,
  ms as fH,
  Ib as fI,
  OAe as fJ,
  TAe as fK,
  fs as fL,
  YAe as fM,
  ho as fN,
  rr as fO,
  nl as fP,
  YPe as fQ,
  dy as fR,
  Ase as fS,
  ca as fT,
  RE as fU,
  cFe as fV,
  tU as fW,
  U3 as fX,
  eh as fY,
  dge as fZ,
  gFe as f_,
  tO as fa,
  br as fb,
  LAe as fc,
  dA as fd,
  gh as fe,
  ia as ff,
  ao as fg,
  Ww as fh,
  yg as fi,
  eC as fj,
  oz as fk,
  uge as fl,
  lge as fm,
  oge as fn,
  Mhe as fo,
  XPe as fp,
  QO as fq,
  eye as fr,
  yr as fs,
  Au as ft,
  Zw as fu,
  qPe as fv,
  Vn as fw,
  kue as fx,
  I6 as fy,
  eJ as fz,
  Gz as g,
  H5 as g$,
  Xw as g0,
  cb as g1,
  JO as g2,
  sf as g3,
  Tge as g4,
  Rye as g5,
  fl as g6,
  HO as g7,
  Ez as g8,
  iFe as g9,
  n_ as gA,
  RX as gB,
  ut as gC,
  YH as gD,
  yAe as gE,
  O_ as gF,
  CRe as gG,
  sw as gH,
  fO as gI,
  fle as gJ,
  mle as gK,
  k5e as gL,
  kRe as gM,
  Ou as gN,
  D4 as gO,
  Zy as gP,
  PNe as gQ,
  whe as gR,
  gce as gS,
  KPe as gT,
  wf as gU,
  l8 as gV,
  rz as gW,
  wfe as gX,
  _fe as gY,
  WH as gZ,
  G5 as g_,
  nFe as ga,
  rFe as gb,
  Gge as gc,
  qye as gd,
  Mge as ge,
  Cge as gf,
  ple as gg,
  pge as gh,
  hge as gi,
  fge as gj,
  yge as gk,
  gge as gl,
  vge as gm,
  bge as gn,
  wge as go,
  _ge as gp,
  Sge as gq,
  $ge as gr,
  xge as gs,
  bU as gt,
  g4 as gu,
  _Le as gv,
  HJ as gw,
  FNe as gx,
  NNe as gy,
  fRe as gz,
  Kue as h,
  o4e as h$,
  xAe as h0,
  XH as h1,
  SRe as h2,
  v6 as h3,
  d6 as h4,
  zK as h5,
  JK as h6,
  a_ as h7,
  LPe as h8,
  NY as h9,
  ls as hA,
  Xj as hB,
  S as hC,
  IPe as hD,
  Pg as hE,
  SAe as hF,
  BV as hG,
  r_ as hH,
  _h as hI,
  gAe as hJ,
  vAe as hK,
  E2 as hL,
  O8 as hM,
  xX as hN,
  sRe as hO,
  Ume as hP,
  y5e as hQ,
  tr as hR,
  Ene as hS,
  F9 as hT,
  EAe as hU,
  WPe as hV,
  yQ as hW,
  N3 as hX,
  F3 as hY,
  HH as hZ,
  HM as h_,
  FY as ha,
  DY as hb,
  YQ as hc,
  AY as hd,
  ese as he,
  Bj as hf,
  oQ as hg,
  fse as hh,
  Lse as hi,
  nce as hj,
  RPe as hk,
  EPe as hl,
  Ece as hm,
  RY as hn,
  mse as ho,
  fQ as hp,
  qj as hq,
  jie as hr,
  Wi as hs,
  Y6 as ht,
  rQ as hu,
  QY as hv,
  K6 as hw,
  al as hx,
  hA as hy,
  nie as hz,
  wd as i,
  cU as i$,
  i4e as i0,
  Qd as i1,
  Yy as i2,
  hb as i3,
  fue as i4,
  PY as i5,
  rme as i6,
  vM as i7,
  j_ as i8,
  Gie as i9,
  pPe as iA,
  yRe as iB,
  hRe as iC,
  oce as iD,
  eue as iE,
  Zle as iF,
  Yg as iG,
  gM as iH,
  TM as iI,
  vPe as iJ,
  q5 as iK,
  o6 as iL,
  mPe as iM,
  Lk as iN,
  yj as iO,
  zNe as iP,
  ENe as iQ,
  IV as iR,
  Mle as iS,
  Q9 as iT,
  lFe as iU,
  E0e as iV,
  Mn as iW,
  vd as iX,
  xh as iY,
  vme as iZ,
  bPe as i_,
  ZPe as ia,
  RNe as ib,
  bhe as ic,
  ONe as id,
  ghe as ie,
  INe as ig,
  MNe as ih,
  _7 as ii,
  LNe as ij,
  $Ne as ik,
  Ohe as il,
  Yre as im,
  L_ as io,
  t0 as ip,
  xn as iq,
  M4e as ir,
  N4e as is,
  W5 as it,
  gPe as iu,
  sZ as iv,
  i_ as iw,
  kPe as ix,
  n5e as iy,
  j3 as iz,
  Vt as j,
  nRe as j$,
  bp as j0,
  Jye as j1,
  dce as j2,
  Yc as j3,
  H5e as j4,
  tZ as j5,
  nj as j6,
  J5e as j7,
  hle as j8,
  AAe as j9,
  Pi as jA,
  BRe as jB,
  dU as jC,
  pU as jD,
  M0e as jE,
  Oce as jF,
  _f as jG,
  VO as jH,
  Zfe as jI,
  Kfe as jJ,
  V_ as jK,
  vz as jL,
  Pme as jM,
  xme as jN,
  yw as jO,
  V$ as jP,
  az as jQ,
  My as jR,
  hie as jS,
  I5e as jT,
  Bt as jU,
  Ide as jV,
  wAe as jW,
  mRe as jX,
  aRe as jY,
  AX as jZ,
  PX as j_,
  PAe as ja,
  kAe as jb,
  _Z as jc,
  Hie as jd,
  Die as je,
  Vie as jf,
  kW as jg,
  B5 as jh,
  jn as ji,
  f8 as jj,
  Rse as jk,
  tM as jl,
  WAe as jm,
  c5e as jn,
  l5e as jo,
  xV as jp,
  xb as jq,
  E$ as jr,
  Vr as js,
  pg as jt,
  Qye as ju,
  FRe as jv,
  ARe as jw,
  RRe as jx,
  PRe as jy,
  LRe as jz,
  zg as k,
  zPe as k$,
  oFe as k0,
  aFe as k1,
  sFe as k2,
  UY as k3,
  HPe as k4,
  J6 as k5,
  W6 as k6,
  aK as k7,
  oK as k8,
  CPe as k9,
  ELe as kA,
  wye as kB,
  Pu as kC,
  W$ as kD,
  n6 as kE,
  iA as kF,
  tRe as kG,
  vX as kH,
  wRe as kI,
  iRe as kJ,
  _M as kK,
  y8 as kL,
  wX as kM,
  NX as kN,
  IX as kO,
  rRe as kP,
  oRe as kQ,
  m4e as kR,
  rce as kS,
  v_ as kT,
  dRe as kU,
  IM as kV,
  Bre as kW,
  Ure as kX,
  zre as kY,
  Ree as kZ,
  gm as k_,
  dJ as ka,
  oZ as kb,
  qV as kc,
  Ah as kd,
  pNe as ke,
  _Pe as kf,
  X9 as kg,
  Ile as kh,
  ug as ki,
  C_ as kj,
  Ho as kk,
  PV as kl,
  u0e as km,
  c0e as kn,
  d0e as ko,
  Iu as kp,
  Qo as kq,
  k_ as kr,
  QRe as ks,
  gV as kt,
  rV as ku,
  vV as kv,
  Sue as kw,
  TLe as kx,
  Pue as ky,
  cg as kz,
  ze as l,
  Hre as l0,
  UNe as l1,
  L4e as l2,
  tae as l3,
  eae as l4,
  jM as l5,
  E1 as l6,
  _Ae as l7,
  Wre as l8,
  Xde as l9,
  bFe as lA,
  MK as lB,
  A4e as lC,
  h5e as lD,
  $5e as lE,
  Y5e as lF,
  vFe as lG,
  OW as la,
  zb as lb,
  Bb as lc,
  eg as ld,
  Nee as le,
  NAe as lf,
  jRe as lg,
  ene as lh,
  tne as li,
  TP as lj,
  UM as lk,
  Khe as ll,
  F4e as lm,
  R_ as ln,
  Rce as lo,
  Lce as lp,
  Cce as lq,
  wQ as lr,
  dK as ls,
  l4e as lt,
  u4e as lu,
  gse as lv,
  yse as lw,
  rw as lx,
  c4e as ly,
  rb as lz,
  vr as m,
  kr as n,
  hNe as o,
  z_ as p,
  mue as q,
  VLe as r,
  se as s,
  L5e as t,
  Ed as u,
  GF as v,
  rg as w,
  Ky as x,
  DLe as y,
  U as z
};
